{"sha": "e316ba3b60433bd703575a00d7fd5e344e29912d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTZiYTNiNjA0MzNiZDcwMzU3NWEwMGQ3ZmQ1ZTM0NGUyOTkxMmQ=", "commit": {"author": {"name": "Baoshan", "email": "pangbw@gmail.com", "date": "2019-09-03T23:33:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-03T23:33:18Z"}, "message": "Merge pull request #12 from rust-lang/master\n\nsync with rust-lang/rust branch master", "tree": {"sha": "4d74702faa98a70d127b17f19f908dc3875e8faa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d74702faa98a70d127b17f19f908dc3875e8faa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e316ba3b60433bd703575a00d7fd5e344e29912d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdbvg+CRBK7hj4Ov3rIwAAdHIIAF2UavIBsZ8V2/0Oxu8JmOSs\nvX7RFV20Aaqsuvy9E6Oc+bqsYvkP35osDl4cvzK4KTYRIEnxrzZw1uYa07xeY9/K\ntvVEsu3RzQyN+fN4DmgkGVDWz+snpI2Az7j56GTbOfAZUsfPgHAl8HchIZwF6D5Z\nPP2Ig5ZzhITVpiP0xo/qqGTO3dpp4HbO2JvM6JSBAUdzz4OxFo+BPaXuA/wkBCph\nv52Wme0bwv1P9xe89/bDCYh5O+qVx+TIEEKOxuf2WjifN1NquZniK3FhMlvPoenN\n8FxwbZBUgILFyX4ZefnShnLvkTKmUgf8nuaDHIqTICUvsSCAUXuuXNw8LEWi4IM=\n=8zFo\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d74702faa98a70d127b17f19f908dc3875e8faa\nparent 964c37cdecbd1aa0e7870afac9ba38e5168be65f\nparent b9de4ef89e0e53099a084001b26ec3207c5f8391\nauthor Baoshan <pangbw@gmail.com> 1567553598 -0700\ncommitter GitHub <noreply@github.com> 1567553598 -0700\n\nMerge pull request #12 from rust-lang/master\n\nsync with rust-lang/rust branch master"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e316ba3b60433bd703575a00d7fd5e344e29912d", "html_url": "https://github.com/rust-lang/rust/commit/e316ba3b60433bd703575a00d7fd5e344e29912d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e316ba3b60433bd703575a00d7fd5e344e29912d/comments", "author": {"login": "BaoshanPang", "id": 3380860, "node_id": "MDQ6VXNlcjMzODA4NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3380860?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BaoshanPang", "html_url": "https://github.com/BaoshanPang", "followers_url": "https://api.github.com/users/BaoshanPang/followers", "following_url": "https://api.github.com/users/BaoshanPang/following{/other_user}", "gists_url": "https://api.github.com/users/BaoshanPang/gists{/gist_id}", "starred_url": "https://api.github.com/users/BaoshanPang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BaoshanPang/subscriptions", "organizations_url": "https://api.github.com/users/BaoshanPang/orgs", "repos_url": "https://api.github.com/users/BaoshanPang/repos", "events_url": "https://api.github.com/users/BaoshanPang/events{/privacy}", "received_events_url": "https://api.github.com/users/BaoshanPang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964c37cdecbd1aa0e7870afac9ba38e5168be65f", "url": "https://api.github.com/repos/rust-lang/rust/commits/964c37cdecbd1aa0e7870afac9ba38e5168be65f", "html_url": "https://github.com/rust-lang/rust/commit/964c37cdecbd1aa0e7870afac9ba38e5168be65f"}, {"sha": "b9de4ef89e0e53099a084001b26ec3207c5f8391", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9de4ef89e0e53099a084001b26ec3207c5f8391", "html_url": "https://github.com/rust-lang/rust/commit/b9de4ef89e0e53099a084001b26ec3207c5f8391"}], "stats": {"total": 25034, "additions": 13602, "deletions": 11432}, "files": [{"sha": "da8044de405a6afc1466e7a2f2e2d8b9b937c2f0", "filename": ".mailmap", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -117,6 +117,9 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <stucki.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <jeremy@myelin.ch>\n+Jeremy Stucki <dev@jeremystucki.ch>\n Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n@@ -181,12 +184,19 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n-Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github333195615777966@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <rust19446194516@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-no-reply-9879165716479413131@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git1984941651981@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github35764891676564198441@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <oli-obk@users.noreply.github.com>\n+Oliver Scherer <oliver.schneider@kit.edu> <public.oliver.schneider@kit.edu>\n+Oliver Scherer <oliver.schneider@kit.edu> <obk8176014uqher834@olio-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu>\n O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.com>\n Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>"}, {"sha": "e0d30647809a9c958f0bf412b9543964948ae830", "filename": "Cargo.lock", "status": "modified", "additions": 66, "deletions": 35, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -185,7 +185,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"time\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -202,7 +202,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -287,7 +287,7 @@ dependencies = [\n  \"git2-curl\",\n  \"glob\",\n  \"hex\",\n- \"home 0.4.2\",\n+ \"home 0.5.0\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -316,7 +316,7 @@ dependencies = [\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-width\",\n  \"url 2.1.0\",\n  \"walkdir\",\n@@ -442,7 +442,7 @@ dependencies = [\n  \"semver\",\n  \"serde\",\n  \"smallvec\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n ]\n@@ -946,6 +946,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustdoc\",\n+ \"walkdir\",\n ]\n \n [[package]]\n@@ -1138,10 +1139,12 @@ dependencies = [\n \n [[package]]\n name = \"getopts\"\n-version = \"0.2.19\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72327b15c228bfe31f1390f93dd5e9279587f0463836393c9df719ce62a3e450\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n  \"unicode-width\",\n ]\n \n@@ -1157,9 +1160,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.9.2\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cb400360e8a4d61b10e648285bbfa919bbf9519d0d5d5720354456f44349226\"\n+checksum = \"327d698f86a7ebdfeb86a4238ccdb004828939d3a3555b6ead679541d14e36c0\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1172,9 +1175,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.10.1\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2293de73491c3dc4174c5949ef53d2cc037b27613f88d72032e3f5237247a7dd\"\n+checksum = \"cd6527e480187ce19aaf4fa6acfb7657b25628ce31cb8ffabdfca3bf731524c5\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -1279,9 +1282,9 @@ dependencies = [\n \n [[package]]\n name = \"home\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"013e4e6e9134211bb4d6bf53dd8cfb75d9e2715cc33614b9c0827718c6fbe0b8\"\n+checksum = \"c07c315e106bd6f83f026a20ddaeef2706782e490db1dcdd37caad38a0e895b3\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n  \"winapi 0.3.6\",\n@@ -1579,9 +1582,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.60\"\n+version = \"0.2.61\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d44e80633f007889c7eff624b709ab43c92d708caad982295768a7b13ca3b5eb\"\n+checksum = \"c665266eb592905e8503ba3403020f4b8794d26263f412ca33171600eca9a6fa\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1601,9 +1604,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c179ed6d19cd3a051e68c177fbbc214e79ac4724fac3a850ec9f3d3eb8a5578\"\n+checksum = \"8c2078aec6f4b16d1b89f6a72e4f6eb1e75ffa85312023291e89c6d3087bc8fb\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1665,9 +1668,9 @@ dependencies = [\n \n [[package]]\n name = \"log\"\n-version = \"0.4.6\"\n+version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n+checksum = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -1785,7 +1788,7 @@ dependencies = [\n  \"serde_json\",\n  \"shlex\",\n  \"tempfile\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query\",\n ]\n \n@@ -1989,6 +1992,7 @@ dependencies = [\n  \"compiletest_rs\",\n  \"directories\",\n  \"env_logger 0.6.0\",\n+ \"getrandom\",\n  \"hex\",\n  \"log\",\n  \"num-traits\",\n@@ -2374,6 +2378,9 @@ dependencies = [\n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n \n [[package]]\n name = \"profiler_builtins\"\n@@ -2760,7 +2767,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-process\",\n  \"tokio-timer\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"url 1.7.2\",\n  \"walkdir\",\n ]\n@@ -3062,6 +3069,13 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc-std-workspace-std\"\n+version = \"1.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n@@ -3218,6 +3232,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"serialize\",\n  \"syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n@@ -3564,7 +3579,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.4\"\n+version = \"1.4.6\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3590,7 +3605,7 @@ dependencies = [\n  \"serde_json\",\n  \"structopt\",\n  \"term 0.6.0\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-segmentation\",\n  \"unicode-width\",\n  \"unicode_categories\",\n@@ -4067,6 +4082,10 @@ dependencies = [\n [[package]]\n name = \"term\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"core\",\n+ \"std\",\n+]\n \n [[package]]\n name = \"term\"\n@@ -4089,6 +4108,17 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"term_size\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327\"\n+dependencies = [\n+ \"kernel32-sys\",\n+ \"libc\",\n+ \"winapi 0.2.8\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -4113,8 +4143,13 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n+ \"core\",\n  \"getopts\",\n+ \"libc\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n  \"proc_macro\",\n+ \"std\",\n  \"term 0.0.0\",\n ]\n \n@@ -4382,15 +4417,6 @@ dependencies = [\n  \"tokio-reactor\",\n ]\n \n-[[package]]\n-name = \"toml\"\n-version = \"0.4.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"758664fc71a3a69038656bee8b6be6477d2a6c315a6b81f7081f591bffa4111f\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"toml\"\n version = \"0.5.3\"\n@@ -4411,7 +4437,7 @@ dependencies = [\n  \"is-match\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query_derive\",\n ]\n \n@@ -4491,9 +4517,14 @@ checksum = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526\"\n+checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+]\n \n [[package]]\n name = \"unicode-xid\""}, {"sha": "a242f090fbc07e889723c334dcb8689b3314be7b", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -68,6 +68,7 @@ rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n # here\n rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n+rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "30e2ee1b9babf4609e77ef6c663842e4fa68c2bd", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -382,11 +382,6 @@\n # This is the name of the directory in which codegen backends will get installed\n #codegen-backends-dir = \"codegen-backends\"\n \n-# Flag indicating whether `libstd` calls an imported function to handle basic IO\n-# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n-# target, as without this option the test output will not be captured.\n-#wasm-syscall = false\n-\n # Indicates whether LLD will be compiled and made available in the sysroot for\n # rustc to execute.\n #lld = false"}, {"sha": "c27c318f5ad07201703bd2a424fc5caed3ac80f3", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -44,7 +44,7 @@ cc = \"1.0.35\"\n libc = \"0.2\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n-toml = \"0.4\"\n+toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\""}, {"sha": "138b7f4b261046bad584bd2acd730da9e5b1bcf0", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -5,9 +5,6 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n \n use bootstrap::{Config, Build};"}, {"sha": "8cb48df14bfefd334bc4ef712e9b516075d9b4e1", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -15,9 +15,6 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::ffi::OsString;\n use std::io;\n@@ -124,8 +121,9 @@ fn main() {\n \n     if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n        env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n-        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n-        // there as well, some code doesn't go through this `rustc` wrapper.\n+        // When extending this list, add the new lints to the RUSTFLAGS of the\n+        // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n+        // some code doesn't go through this `rustc` wrapper.\n         cmd.arg(\"-Dwarnings\");\n         cmd.arg(\"-Drust_2018_idioms\");\n         cmd.arg(\"-Dunused_lifetimes\");"}, {"sha": "a13ff69a7b56f79f91a490541f3808cff974c004", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2,12 +2,10 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::process::Command;\n use std::path::PathBuf;\n+use std::ffi::OsString;\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -47,7 +45,9 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n     if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n-        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+        let mut arg = OsString::from(\"-Clinker=\");\n+        arg.push(&linker);\n+        cmd.arg(arg);\n     }\n \n     // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick"}, {"sha": "4162fe1df5086841b6c0953e041b4c8fd3deccef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -320,7 +320,7 @@ class RustBuild(object):\n     def __init__(self):\n         self.cargo_channel = ''\n         self.date = ''\n-        self._download_url = 'https://static.rust-lang.org'\n+        self._download_url = ''\n         self.rustc_channel = ''\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n@@ -631,6 +631,8 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n+        if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n+            env[\"RUSTFLAGS\"] += \"-Dwarnings -Drust_2018_idioms -Dunused_lifetimes \"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n@@ -731,9 +733,19 @@ def update_submodules(self):\n             self.update_submodule(module[0], module[1], recorded_submodules)\n         print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n+    def set_normal_environment(self):\n+        \"\"\"Set download URL for normal environment\"\"\"\n+        if 'RUSTUP_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://static.rust-lang.org'\n+\n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n-        self._download_url = 'https://dev-static.rust-lang.org'\n+        if 'RUSTUP_DEV_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DEV_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://dev-static.rust-lang.org'\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -826,6 +838,8 @@ def bootstrap(help_triggered):\n \n     if 'dev' in data:\n         build.set_dev_environment()\n+    else:\n+        build.set_normal_environment()\n \n     build.update_submodules()\n "}, {"sha": "4f5de1ecd2b44f8aa0cabf0e56249e191f62197d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -337,7 +337,6 @@ impl<'a> Builder<'a> {\n         match kind {\n             Kind::Build => describe!(\n                 compile::Std,\n-                compile::Test,\n                 compile::Rustc,\n                 compile::CodegenBackend,\n                 compile::StartupObjects,\n@@ -363,7 +362,6 @@ impl<'a> Builder<'a> {\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n-                check::Test,\n                 check::Rustc,\n                 check::CodegenBackend,\n                 check::Rustdoc\n@@ -425,8 +423,6 @@ impl<'a> Builder<'a> {\n                 doc::TheBook,\n                 doc::Standalone,\n                 doc::Std,\n-                doc::Test,\n-                doc::WhitelistedRustc,\n                 doc::Rustc,\n                 doc::Rustdoc,\n                 doc::ErrorIndex,\n@@ -801,7 +797,7 @@ impl<'a> Builder<'a> {\n         }\n \n         match mode {\n-            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n@@ -852,7 +848,6 @@ impl<'a> Builder<'a> {\n         // things still build right, please do!\n         match mode {\n             Mode::Std => metadata.push_str(\"std\"),\n-            Mode::Test => metadata.push_str(\"test\"),\n             _ => {},\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n@@ -875,8 +870,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd == \"clippy\" {\n-            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n-                --json-rendered=termcolor\");\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked\");\n         }\n \n         if !extra_args.is_empty() {\n@@ -949,9 +943,9 @@ impl<'a> Builder<'a> {\n \n         let debuginfo_level = match mode {\n             Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n-            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::Std => self.config.rust_debuginfo_level_std,\n             Mode::ToolBootstrap | Mode::ToolStd |\n-            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+            Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n         };\n         cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n \n@@ -1151,7 +1145,6 @@ impl<'a> Builder<'a> {\n \n         match (mode, self.config.rust_codegen_units_std, self.config.rust_codegen_units) {\n             (Mode::Std, Some(n), _) |\n-            (Mode::Test, Some(n), _) |\n             (_, _, Some(n)) => {\n                 cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n             }"}, {"sha": "2bb90fdb04edcef41bfe0e2df25743d1f4460307", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 64, "deletions": 89, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -365,27 +365,6 @@ fn dist_with_same_targets_and_hosts() {\n             },\n         ]\n     );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]\n-    );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -415,7 +394,47 @@ fn build_default() {\n     let b = INTERNER.intern_str(\"B\");\n     let c = INTERNER.intern_str(\"C\");\n \n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n     assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n@@ -450,63 +469,61 @@ fn build_default() {\n             },\n         ]\n     );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n \n     assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n+        first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 0 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: c,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: c,\n             },\n         ]\n     );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n-\n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -541,48 +558,6 @@ fn build_with_target_flag() {\n             },\n         ]\n     );\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]\n-    );\n }\n \n #[test]"}, {"sha": "205a80c3a3a9e5b2129bb7be7fcd2308197e8b40", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 54, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n+use crate::compile::{run_cargo, std_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n@@ -34,7 +34,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -92,7 +92,7 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Test { target });\n+        builder.ensure(Std { target });\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n             cargo_subcommand(builder.kind));\n@@ -159,47 +159,6 @@ impl Step for CodegenBackend {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Std { target });\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  args(builder.kind),\n-                  &libtest_stamp(builder, compiler, target),\n-                  true);\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustdoc {\n     pub target: Interned<String>,\n@@ -258,16 +217,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "9d57a4f00d7807e97817bb69d60e52ceee41b9ec", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 137, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -39,7 +39,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -216,7 +216,7 @@ pub fn std_cargo(builder: &Builder<'_>,\n \n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n \n         if target.contains(\"musl\") {\n             if let Some(p) = builder.musl_root(target) {\n@@ -358,129 +358,6 @@ impl Step for StartupObjects {\n     }\n }\n \n-#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-    pub compiler: Compiler,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Builds libtest.\n-    ///\n-    /// This will build libtest and supporting libraries for a particular stage of\n-    /// the build using the `compiler` targeting the `target` architecture. The\n-    /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(Std { compiler, target });\n-\n-        if builder.config.keep_stage.contains(&compiler.stage) {\n-            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n-            builder.ensure(TestLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n-        if compiler_to_use != compiler {\n-            builder.ensure(Test {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n-            builder.info(\n-                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n-            builder.ensure(TestLink {\n-                compiler: compiler_to_use,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  vec![],\n-                  &libtest_stamp(builder, compiler, target),\n-                  false);\n-\n-        builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, builder.config.build),\n-            target_compiler: compiler,\n-            target,\n-        });\n-    }\n-}\n-\n-/// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder<'_>,\n-                  _compiler: &Compiler,\n-                  _target: Interned<String>,\n-                  cargo: &mut Command) {\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n-    }\n-    cargo.arg(\"--manifest-path\")\n-        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TestLink {\n-    pub compiler: Compiler,\n-    pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for TestLink {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = self.compiler;\n-        let target_compiler = self.target_compiler;\n-        let target = self.target;\n-        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n-                target_compiler.stage,\n-                compiler.stage,\n-                &compiler.host,\n-                target_compiler.host,\n-                target));\n-        add_to_sysroot(\n-            builder,\n-            &builder.sysroot_libdir(target_compiler, target),\n-            &builder.sysroot_libdir(target_compiler, compiler.host),\n-            &libtest_stamp(builder, compiler, target)\n-        );\n-    }\n-}\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: Interned<String>,\n@@ -512,7 +389,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.ensure(Test { compiler, target });\n+        builder.ensure(Std { compiler, target });\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n@@ -541,7 +418,7 @@ impl Step for Rustc {\n         }\n \n         // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n-        builder.ensure(Test {\n+        builder.ensure(Std {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -872,16 +749,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "43d9264eaca92ee6584485ed37a2e1e71a503762", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -122,7 +122,6 @@ pub struct Config {\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n-    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n@@ -318,7 +317,6 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n-    wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n@@ -558,7 +556,6 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n-            set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);"}, {"sha": "0f4ac63651ca9ff02b76312fc3fadb2d976775c8", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -678,12 +678,7 @@ impl Step for Std {\n         if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            if builder.no_std(target) == Some(true) {\n-                // the `test` doesn't compile for no-std targets\n-                builder.ensure(compile::Std { compiler, target });\n-            } else {\n-                builder.ensure(compile::Test { compiler, target });\n-            }\n+            builder.ensure(compile::Std { compiler, target });\n         }\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n@@ -912,6 +907,7 @@ impl Step for Src {\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n             \"src/tools/rustc-std-workspace-alloc\",\n+            \"src/tools/rustc-std-workspace-std\",\n             \"src/librustc\",\n             \"src/libsyntax\",\n         ];"}, {"sha": "6faedc80ad3f5d34acb391001d4b1e86490f1536", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 131, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -375,7 +375,7 @@ impl Step for Standalone {\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n-               up_to_date(&version_info, &html) &&\n+               (builder.config.dry_run || up_to_date(&version_info, &html)) &&\n                (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n@@ -413,7 +413,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.all_krates(\"std\").default_condition(builder.config.docs)\n+        run.all_krates(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -478,138 +478,12 @@ impl Step for Std {\n             builder.run(&mut cargo);\n             builder.cp_r(&my_out, &out);\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n             run_cargo_rustdoc_for(krate);\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Test {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Compile all libtest documentation.\n-    ///\n-    /// This will generate all documentation for libtest and its dependencies. This\n-    /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Test)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n-        compile::test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        cargo.arg(\"--no-deps\")\n-             .arg(\"-p\").arg(\"test\")\n-             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct WhitelistedRustc {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for WhitelistedRustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(WhitelistedRustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Generates whitelisted compiler crate documentation.\n-    ///\n-    /// This will generate all documentation for crates that are whitelisted\n-    /// to be included in the standard documentation. This documentation is\n-    /// included in the standard Rust documentation, so we should always\n-    /// document it and symlink to merge with the rest of the std and test\n-    /// documentation. We don't build other compiler documentation\n-    /// here as we want to be able to keep it separate from the standard\n-    /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        compile::rustc_cargo(builder, &mut cargo);\n-\n-        // We don't want to build docs for internal compiler dependencies in this\n-        // step (there is another step for that). Therefore, we whitelist the crates\n-        // for which docs must be built.\n-        for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate)\n-                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-        }\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     stage: u32,\n@@ -825,8 +699,7 @@ impl Step for ErrorIndex {\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.run(&mut index);\n     }"}, {"sha": "5d7581c8211be84c1e05b0ae27663f69aa992202", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -103,9 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n@@ -297,9 +294,6 @@ pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Std,\n \n-    /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Test,\n-\n     /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Rustc,\n \n@@ -315,7 +309,6 @@ pub enum Mode {\n     /// Compile a tool which uses all libraries we compile (up to rustc).\n     /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n     /// tools like rustdoc, cargo, rls, etc.\n-    ToolTest,\n     ToolStd,\n     ToolRustc,\n }\n@@ -502,9 +495,6 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        if self.config.wasm_syscall {\n-            features.push_str(\" wasm_syscall\");\n-        }\n         features\n     }\n \n@@ -536,11 +526,10 @@ impl Build {\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Std => \"-std\",\n-            Mode::Test => \"-test\",\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))"}, {"sha": "97b28ed9e96c81468f2dd877f775d3cbeff051af", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1040,21 +1040,10 @@ impl Step for Compiletest {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n-        if builder.no_std(target) == Some(true) {\n-            // the `test` doesn't compile for no-std targets\n-            builder.ensure(compile::Std { compiler, target });\n-        } else {\n-            builder.ensure(compile::Test { compiler, target });\n-        }\n-\n-        if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g., thumb*),\n-            // we need a host compiler which is called by cargo.\n-            builder.ensure(compile::Std { compiler, target: compiler.host });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n+        // ensure that `libproc_macro` is available on the host.\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        // HACK(eddyb) ensure that `libproc_macro` is available on the host.\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n@@ -1399,7 +1388,7 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test {\n+        builder.ensure(compile::Std {\n             compiler,\n             target: compiler.host,\n         });\n@@ -1535,8 +1524,7 @@ impl Step for ErrorIndex {\n         );\n         tool.arg(\"markdown\")\n             .arg(&output)\n-            .env(\"CFG_BUILD\", &builder.config.build)\n-            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+            .env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1710,8 +1698,7 @@ impl Step for Crate {\n \n     fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run = run.krate(\"test\");\n-        for krate in run.builder.in_tree_crates(\"std\") {\n+        for krate in run.builder.in_tree_crates(\"test\") {\n             if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n@@ -1735,14 +1722,9 @@ impl Step for Crate {\n             });\n         };\n \n-        for krate in builder.in_tree_crates(\"std\") {\n-            if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Std, krate);\n-            }\n-        }\n         for krate in builder.in_tree_crates(\"test\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Test, krate);\n+                make(Mode::Std, krate);\n             }\n         }\n     }\n@@ -1762,7 +1744,7 @@ impl Step for Crate {\n         let test_kind = self.test_kind;\n         let krate = self.krate;\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -1776,9 +1758,6 @@ impl Step for Crate {\n             Mode::Std => {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Test => {\n-                compile::test_cargo(builder, &compiler, target, &mut cargo);\n-            }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(builder, &mut cargo);\n@@ -1832,16 +1811,6 @@ impl Step for Crate {\n                     .expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            // Warn about running tests without the `wasm_syscall` feature enabled.\n-            // The javascript shim implements the syscall interface so that test\n-            // output can be correctly reported.\n-            if !builder.config.wasm_syscall {\n-                builder.info(\n-                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n-                     test output may not be visible.\"\n-                );\n-            }\n-\n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -1980,7 +1949,7 @@ impl Step for RemoteCopyLibs {\n             return;\n         }\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));"}, {"sha": "54fe26f18e741d0a7558ada111628bb68cc84ee3", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -577,12 +577,6 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, so make sure the host\n-        // libstd/libproc_macro is available.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -650,31 +644,10 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n         let clippy = builder.ensure(Clippy {\n             compiler: self.compiler,\n@@ -684,12 +657,6 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n );"}, {"sha": "f035a7119188a1aa3c415e09096e20b8e896104f", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,6 +1,3 @@\n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -262,7 +259,7 @@ pub fn native_lib_boilerplate(\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n         Ok(NativeLibBoilerplate {\n             src_dir: src_dir.to_path_buf(),\n-            out_dir: out_dir,\n+            out_dir,\n         })\n     } else {\n         Err(())"}, {"sha": "105791194628b3130866d55f5293fb1b6431756d", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -104,9 +104,7 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-# FIXME: temporarily disable the redox builder,\n-# see: https://github.com/rust-lang/rust/issues/63160\n-# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n@@ -132,7 +130,7 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n-    \n+\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\"}, {"sha": "de8c359d16757a223b84fce8afce6ae2331bd61d", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "432ca26686c11d396eed6a59499f93ce1bf2433c", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1 +1 @@\n-Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999\n+Subproject commit 432ca26686c11d396eed6a59499f93ce1bf2433c"}, {"sha": "38b9a76bc8b59ac862663807fc51c9b757337fd6", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1 +1 @@\n-Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da\n+Subproject commit 38b9a76bc8b59ac862663807fc51c9b757337fd6"}, {"sha": "d191a0cdd3b92648e0f1e53b13140a14677cc65b", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1 +1 @@\n-Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa\n+Subproject commit d191a0cdd3b92648e0f1e53b13140a14677cc65b"}, {"sha": "580839d90aacd537f0293697096fa8355bc4e673", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1 +1 @@\n-Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764\n+Subproject commit 580839d90aacd537f0293697096fa8355bc4e673"}, {"sha": "6e25a3d0d3573eb42b2e2339f1219e969d1b3dee", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1 +1 @@\n-Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c\n+Subproject commit 6e25a3d0d3573eb42b2e2339f1219e969d1b3dee"}, {"sha": "5eea9c86879001ef9a13ee6f3c8ecbc487697ccc", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -304,3 +304,10 @@ to customize the output:\n \n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n+\n+## `@path`: load command-line flags from a path\n+\n+If you specify `@path` on the command-line, then it will open `path` and read\n+command line options from it. These options are one per line; a blank line indicates\n+an empty option. The file can use Unix or Windows style line endings, and must be\n+encoded as UTF-8."}, {"sha": "d3dfc3197e2f69749bc3e6537f4d55fb97376016", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -208,7 +208,7 @@ error: missing documentation for a function\n \n To fix the lint, add documentation to all items.\n \n-## single-use-lifetime\n+## single-use-lifetimes\n \n This lint detects lifetimes that are only used once. Some example code that\n triggers this lint:"}, {"sha": "993fc8412836e17c0cab32ad05460f50baa47932", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -311,19 +311,6 @@ When `rustdoc` receives this flag, it will print an extra \"Version (version)\" in\n the crate root's docs. You can use this flag to differentiate between different versions of your\n library's documentation.\n \n-### `--linker`: control the linker used for documentation tests\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc --test src/lib.rs -Z unstable-options --linker foo\n-$ rustdoc --test README.md -Z unstable-options --linker foo\n-```\n-\n-When `rustdoc` runs your documentation tests, it needs to compile and link the tests as executables\n-before running them. This flag can be used to change the linker used on these executables. It's\n-equivalent to passing `-C linker=foo` to `rustc`.\n-\n ### `--sort-modules-by-appearance`: control how items on module pages are sorted\n \n Using this flag looks like this:"}, {"sha": "262a53eabe3c7bf3030eafc9c8c79a8d3000522c", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -15,113 +15,7 @@ const buffer = fs.readFileSync(process.argv[2]);\n Error.stackTraceLimit = 20;\n \n let m = new WebAssembly.Module(buffer);\n-\n-let memory = null;\n-\n-function viewstruct(data, fields) {\n-  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n-}\n-\n-function copystr(a, b) {\n-  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n-  return String.fromCharCode.apply(null, view);\n-}\n-\n-function syscall_write([fd, ptr, len]) {\n-  let s = copystr(ptr, len);\n-  switch (fd) {\n-    case 1: process.stdout.write(s); break;\n-    case 2: process.stderr.write(s); break;\n-  }\n-}\n-\n-function syscall_exit([code]) {\n-  process.exit(code);\n-}\n-\n-function syscall_args(params) {\n-  let [ptr, len] = params;\n-\n-  // Calculate total required buffer size\n-  let totalLen = -1;\n-  for (let i = 2; i < process.argv.length; ++i) {\n-    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n-  }\n-  if (totalLen < 0) { totalLen = 0; }\n-  params[2] = totalLen;\n-\n-  // If buffer is large enough, copy data\n-  if (len >= totalLen) {\n-    let view = new Uint8Array(memory.buffer);\n-    for (let i = 2; i < process.argv.length; ++i) {\n-      let value = process.argv[i];\n-      Buffer.from(value).copy(view, ptr);\n-      ptr += Buffer.byteLength(process.argv[i]) + 1;\n-    }\n-  }\n-}\n-\n-function syscall_getenv(params) {\n-  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n-\n-  let key = copystr(keyPtr, keyLen);\n-  let value = process.env[key];\n-\n-  if (value == null) {\n-    params[4] = 0xFFFFFFFF;\n-  } else {\n-    let view = new Uint8Array(memory.buffer);\n-    let totalLen = Buffer.byteLength(value);\n-    params[4] = totalLen;\n-    if (valueLen >= totalLen) {\n-      Buffer.from(value).copy(view, valuePtr);\n-    }\n-  }\n-}\n-\n-function syscall_time(params) {\n-  let t = Date.now();\n-  let secs = Math.floor(t / 1000);\n-  let millis = t % 1000;\n-  params[1] = Math.floor(secs / 0x100000000);\n-  params[2] = secs % 0x100000000;\n-  params[3] = Math.floor(millis * 1000000);\n-}\n-\n-let imports = {};\n-imports.env = {\n-  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n-  // one day this is not necessary and something will automatically do this.\n-  fmod: function(x, y) { return x % y; },\n-  exp2: function(x) { return Math.pow(2, x); },\n-  exp2f: function(x) { return Math.pow(2, x); },\n-  ldexp: function(x, y) { return x * Math.pow(2, y); },\n-  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n-  sin: Math.sin,\n-  sinf: Math.sin,\n-  cos: Math.cos,\n-  cosf: Math.cos,\n-  log: Math.log,\n-  log2: Math.log2,\n-  log10: Math.log10,\n-  log10f: Math.log10,\n-\n-  rust_wasm_syscall: function(index, data) {\n-    switch (index) {\n-      case 1: syscall_write(viewstruct(data, 3)); return true;\n-      case 2: syscall_exit(viewstruct(data, 1)); return true;\n-      case 3: syscall_args(viewstruct(data, 3)); return true;\n-      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n-      case 6: syscall_time(viewstruct(data, 4)); return true;\n-      default:\n-        console.log(\"Unsupported syscall: \" + index);\n-        return false;\n-    }\n-  }\n-};\n-\n-let instance = new WebAssembly.Instance(m, imports);\n-memory = instance.exports.memory;\n+let instance = new WebAssembly.Instance(m, {});\n try {\n   instance.exports.main();\n } catch (e) {"}, {"sha": "816a71f2557982a22b7d53c5dea848098dd96291", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -276,7 +276,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Self {\n+    pub const fn new() -> Self {\n         LinkedList {\n             head: None,\n             tail: None,"}, {"sha": "a4a0fbb194dd448083c320643d2c8a2ef505a60b", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1810,7 +1810,7 @@ impl<T> VecDeque<T> {\n         other\n     }\n \n-    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n     ///\n     /// # Panics\n     ///\n@@ -1847,7 +1847,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n-    /// buf.retain(|&x| x%2 == 0);\n+    /// buf.retain(|&x| x % 2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n     ///"}, {"sha": "d5dc2d4b8688d79b0c8f5e25f76fbc759992cef8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -291,6 +291,7 @@ use crate::raw_vec::RawVec;\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n /// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(all(not(bootstrap), not(test)), rustc_diagnostic_item = \"vec_type\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n     len: usize,"}, {"sha": "607427a85d67aef435677761bc085c2913eb14e0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1012,8 +1012,10 @@ mod impls {\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n-                    if *self == *other { Equal }\n-                    else if *self < *other { Less }\n+                    // The order here is important to generate more optimal assembly.\n+                    // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n+                    if *self < *other { Less }\n+                    else if *self == *other { Equal }\n                     else { Greater }\n                 }\n             }"}, {"sha": "402a7b2c95a46f1e4638ddb5c4500f1dfd379003", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -104,22 +104,17 @@ pub const fn identity<T>(x: T) -> T { x }\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n-/// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n+/// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in few aspects:\n ///\n-/// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n+/// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n ///   a reference or a value.\n-/// - `Borrow` also requires that `Hash`, `Eq` and `Ord` for borrowed value are\n+/// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for borrowed value are\n ///   equivalent to those of the owned value. For this reason, if you want to\n-///   borrow only a single field of a struct you can implement `AsRef`, but not `Borrow`.\n-///\n-/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-///\n /// # Generic Implementations\n ///\n /// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n@@ -132,9 +127,16 @@ pub const fn identity<T>(x: T) -> T { x }\n /// converted to the specified type `T`.\n ///\n /// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n-/// want to accept all references that can be converted to `&str` as an argument.\n-/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n+/// want to accept all references that can be converted to [`&str`] as an argument.\n+/// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n+/// [`Option<T>`]: ../../std/option/enum.Option.html\n+/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n+/// [`&str`]: ../../std/primitive.str.html\n /// [`String`]: ../../std/string/struct.String.html\n ///\n /// ```"}, {"sha": "7e35188bc1082e7fbe1e5042b7871851201359bc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -518,7 +518,8 @@ impl Display for Arguments<'_> {\n     label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n )]\n #[doc(alias = \"{:?}\")]\n-#[lang = \"debug_trait\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, lang = \"debug_trait\")]\n+#[cfg_attr(not(boostrap_stdarch_ignore_this), rustc_diagnostic_item = \"debug_trait\")]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     ///"}, {"sha": "6439fa0e0c8b82425762e311bd2a59e2ea57a1ef", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -104,11 +104,19 @@ pub fn spin_loop() {\n     }\n }\n \n-/// A function that is opaque to the optimizer, to allow benchmarks to\n-/// pretend to use outputs to assist in avoiding dead-code\n-/// elimination.\n+/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n+/// `black_box` could do.\n ///\n-/// This function is a no-op, and does not even read from `dummy`.\n+/// [`std::convert::identity`]: https://doc.rust-lang.org/core/convert/fn.identity.html\n+///\n+/// Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n+/// use `x` in any possible valid way that Rust code is allowed to without introducing undefined\n+/// behavior in the calling code. This property makes `black_box` useful for writing code in which\n+/// certain optimizations are not desired, such as benchmarks.\n+///\n+/// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n+/// extent to which it can block optimisations may vary depending upon the platform and code-gen\n+/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n #[inline]\n #[unstable(feature = \"test\", issue = \"50297\")]\n #[allow(unreachable_code)] // this makes #[cfg] a bit easier below."}, {"sha": "f50781890ab225eabc5ea646bbc68e440792fb64", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1309,7 +1309,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n         match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n+            Some(None) => Try::from_ok(init),\n             Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n                 Ok(acc) => f(acc, v),\n                 Err(e) => {\n@@ -1326,7 +1326,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         match self.peeked {\n-            Some(None) => return init,\n+            Some(None) => init,\n             Some(Some(v)) => {\n                 let acc = self.iter.rfold(init, &mut fold);\n                 fold(acc, v)"}, {"sha": "ffaca029a8a78be3d31c72e8e349bec3eb81eaa3", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -734,7 +734,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -747,7 +746,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -1235,42 +1233,36 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n     #[unstable(feature = \"test\", issue = \"50297\",\n                reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "22e7573eca65b28c5693df365dc17af90fa5ed32", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -315,7 +315,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```"}, {"sha": "bbe1d040780602df44831bab76ff835a01da7898", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -327,7 +327,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```"}, {"sha": "59a10ae99bb6aa5bff9c66a5ebe3b2520a22a807", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -18,6 +18,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -41,6 +43,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -64,6 +68,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -83,6 +89,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {"}, {"sha": "4a0a2720fe44161116254e719ffc8403423606bf", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -185,14 +185,6 @@ pub trait FnMut<Args> : FnOnce<Args> {\n ///\n /// # Examples\n ///\n-/// ## Calling a by-value closure\n-///\n-/// ```\n-/// let x = 5;\n-/// let square_x = move || x * x;\n-/// assert_eq!(square_x(), 25);\n-/// ```\n-///\n /// ## Using a `FnOnce` parameter\n ///\n /// ```"}, {"sha": "931768564ca3cf8c5a34fca6a14e376567c4f1eb", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -3026,8 +3026,7 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            let diff = ($self.end as usize).wrapping_sub(start as usize);\n-            diff\n+            ($self.end as usize).wrapping_sub(start as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here"}, {"sha": "5e5b5593fd8a7d19fa949d5ab2a9cbe8c19f7033", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2170,6 +2170,7 @@ impl str {\n     #[inline(always)]\n     #[rustc_const_unstable(feature=\"const_str_as_bytes\")]\n     pub const fn as_bytes(&self) -> &[u8] {\n+        #[repr(C)]\n         union Slices<'a> {\n             str: &'a str,\n             slice: &'a [u8],\n@@ -3557,7 +3558,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3594,7 +3595,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///\n@@ -3761,7 +3762,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3800,7 +3801,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///"}, {"sha": "187bdac80019d51e914a6c70ec31e914c567d231", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -6,3 +6,6 @@ edition = \"2018\"\n \n [lib]\n path = \"lib.rs\"\n+\n+[dependencies]\n+std = { path = \"../libstd\" }"}, {"sha": "d408fef75153e2f83c597d9bfa6547b66585b1e2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -19,12 +19,15 @@\n \n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(allow_internal_unstable)]\n #![feature(const_fn)]\n+#![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(mem_take)]\n #![feature(non_exhaustive)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n@@ -222,11 +225,10 @@ pub mod token_stream {\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n-///\n-/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n+#[allow_internal_unstable(proc_macro_def_site)]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]"}, {"sha": "144e2d6bac43bb3061ecbb3c785965732e56c7e5", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -57,9 +57,9 @@ macro_rules! quote {\n }\n \n /// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual `quote!()` proc macro.\n+/// This is the actual implementation of the `quote!()` proc macro.\n ///\n-/// It is manually loaded in `CStore::load_macro_untracked`.\n+/// It is loaded by the compiler in `register_builtin_macros`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {"}, {"sha": "b3a561ef74be745f73e65092cd37bfd2b2b04b59", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -25,6 +25,16 @@ macro_rules! arena_types {\n             [] adt_def: rustc::ty::AdtDef,\n             [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n             [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_promoted: rustc::ty::steal::Steal<\n+                rustc_data_structures::indexed_vec::IndexVec<\n+                    rustc::mir::Promoted,\n+                    rustc::mir::Body<$tcx>\n+                >\n+            >,\n+            [] promoted: rustc_data_structures::indexed_vec::IndexVec<\n+                rustc::mir::Promoted,\n+                rustc::mir::Body<$tcx>\n+            >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n             [] vtable_method: Option<(\n@@ -84,6 +94,10 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n+                syntax::symbol::Symbol,\n+                rustc::hir::def_id::DefId,\n+            >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n             [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n             [few] lint_levels: rustc::lint::LintLevelMap,"}, {"sha": "2d09013f675a726194e259649c3ae8f8b1c3bcba", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2231,15 +2231,15 @@ register_diagnostics! {\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n-    E0628, // generators cannot have explicit arguments\n+    E0628, // generators cannot have explicit parameters\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n     E0697, // closures cannot be static\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with arguments are not currently supported\n+    E0708, // `async` non-`move` closures with parameters are not currently supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes"}, {"sha": "bbde3510e29f91cc3d89adc304a60379c7629640", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -210,8 +210,8 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n-    fn visit_arg(&mut self, arg: &'v Arg) {\n-        walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v Param) {\n+        walk_param(self, param)\n     }\n \n     /// Visits the top-level item and (optionally) nested items / impl items. See\n@@ -400,7 +400,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    walk_list!(visitor, visit_arg, &body.arguments);\n+    walk_list!(visitor, visit_param, &body.params);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -454,10 +454,10 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_arg<'v, V: Visitor<'v>>(visitor: &mut V, arg: &'v Arg) {\n-    visitor.visit_id(arg.hir_id);\n-    visitor.visit_pat(&arg.pat);\n-    walk_list!(visitor, visit_attribute, &arg.attrs);\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+    visitor.visit_id(param.hir_id);\n+    visitor.visit_pat(&param.pat);\n+    walk_list!(visitor, visit_attribute, &param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {"}, {"sha": "5e2aebfd3187ba9ab7981709fca5a382cc80fdc0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -510,12 +510,12 @@ impl<'a> LoweringContext<'a> {\n                             &f.generic_params\n                         );\n                         // Mirrors visit::walk_fn_decl\n-                        for argument in &f.decl.inputs {\n+                        for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n                             self.with_hir_id_owner(None, |this| {\n-                                this.visit_pat(&argument.pat);\n+                                this.visit_pat(&parameter.pat);\n                             });\n-                            self.visit_ty(&argument.ty)\n+                            self.visit_ty(&parameter.ty)\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n@@ -735,7 +735,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: DefId,\n@@ -880,7 +880,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn add_in_band_defs<F, T>(\n         &mut self,\n         generics: &Generics,\n@@ -1080,7 +1080,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n                         (true, ImplTraitContext::OpaqueTy(None)),\n \n-                    // We are in the argument position, but not within a dyn type:\n+                    // We are in the parameter position, but not within a dyn type:\n                     //\n                     //     fn foo(x: impl Iterator<Item: Debug>)\n                     //\n@@ -1204,7 +1204,7 @@ impl<'a> LoweringContext<'a> {\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                                arg_names: this.lower_fn_args_to_names(&f.decl),\n+                                param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))\n                         },\n                     )\n@@ -2093,12 +2093,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n+    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|arg| match arg.pat.node {\n+            .map(|param| match param.pat.node {\n                 PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(kw::Invalid, arg.pat.span),\n+                _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n             .collect()\n     }\n@@ -2136,11 +2136,11 @@ impl<'a> LoweringContext<'a> {\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n-                .map(|arg| {\n+                .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n                     } else {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                     }\n                 })\n                 .collect::<HirVec<_>>()\n@@ -2205,7 +2205,7 @@ impl<'a> LoweringContext<'a> {\n     //\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n-    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `inputs`: lowered types of parameters to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created"}, {"sha": "bd217831faabf5f06c50449524d0dce194022c5e", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -724,7 +724,7 @@ impl LoweringContext<'_> {\n                         self.sess,\n                         fn_decl_span,\n                         E0628,\n-                        \"generators cannot have explicit arguments\"\n+                        \"generators cannot have explicit parameters\"\n                     );\n                     self.sess.abort_if_errors();\n                 }\n@@ -775,7 +775,7 @@ impl LoweringContext<'_> {\n                     this.sess,\n                     fn_decl_span,\n                     E0708,\n-                    \"`async` non-`move` closures with arguments are not currently supported\",\n+                    \"`async` non-`move` closures with parameters are not currently supported\",\n                 )\n                 .help(\n                     \"consider using `let` statements to manually capture \\"}, {"sha": "4e432f4981d23b8bea148b5b03542b27e6a48bd0", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -720,7 +720,7 @@ impl LoweringContext<'_> {\n                             (\n                                 // Disallow impl Trait in foreign items\n                                 this.lower_fn_decl(fdec, None, false, None),\n-                                this.lower_fn_args_to_names(fdec),\n+                                this.lower_fn_params_to_names(fdec),\n                             )\n                         },\n                     );\n@@ -827,7 +827,7 @@ impl LoweringContext<'_> {\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n@@ -1028,10 +1028,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n-            arguments,\n+            params,\n             value,\n         };\n         let id = body.id();\n@@ -1041,21 +1041,21 @@ impl LoweringContext<'_> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Param>, hir::Expr),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n-        let (arguments, result) = f(self);\n-        let body_id = self.record_body(arguments, result);\n+        let (parameters, result) = f(self);\n+        let body_id = self.record_body(parameters, result);\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n-    fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        hir::Arg {\n-            attrs: self.lower_attrs(&arg.attrs),\n-            hir_id: self.lower_node_id(arg.id),\n-            pat: self.lower_pat(&arg.pat),\n-            span: arg.span,\n+    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+        hir::Param {\n+            attrs: self.lower_attrs(&param.attrs),\n+            hir_id: self.lower_node_id(param.id),\n+            pat: self.lower_pat(&param.pat),\n+            span: param.span,\n         }\n     }\n \n@@ -1065,7 +1065,7 @@ impl LoweringContext<'_> {\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::BodyId {\n         self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            decl.inputs.iter().map(|x| this.lower_param(x)).collect(),\n             body(this),\n         ))\n     }\n@@ -1093,10 +1093,10 @@ impl LoweringContext<'_> {\n         };\n \n         self.lower_body(|this| {\n-            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut parameters: Vec<hir::Param> = Vec::new();\n             let mut statements: Vec<hir::Stmt> = Vec::new();\n \n-            // Async function arguments are lowered into the closure body so that they are\n+            // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n             //\n             // from:\n@@ -1121,13 +1121,13 @@ impl LoweringContext<'_> {\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n-            for (index, argument) in decl.inputs.iter().enumerate() {\n-                let argument = this.lower_arg(argument);\n-                let span = argument.pat.span;\n+            for (index, parameter) in decl.inputs.iter().enumerate() {\n+                let parameter = this.lower_param(parameter);\n+                let span = parameter.pat.span;\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n-                let (ident, is_simple_argument) = match argument.pat.node {\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n+                let (ident, is_simple_parameter) = match parameter.pat.node {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {\n@@ -1142,32 +1142,32 @@ impl LoweringContext<'_> {\n                 let desugared_span =\n                     this.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // Construct a parameter representing `__argN: <ty>` to replace the parameter of the\n                 // async function.\n                 //\n-                // If this is the simple case, this argument will end up being the same as the\n-                // original argument, but with a different pattern id.\n+                // If this is the simple case, this parameter will end up being the same as the\n+                // original parameter, but with a different pattern id.\n                 let mut stmt_attrs = ThinVec::new();\n-                stmt_attrs.extend(argument.attrs.iter().cloned());\n-                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n-                let new_argument = hir::Arg {\n-                    attrs: argument.attrs,\n-                    hir_id: argument.hir_id,\n-                    pat: new_argument_pat,\n-                    span: argument.span,\n+                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n+                let new_parameter = hir::Param {\n+                    attrs: parameter.attrs,\n+                    hir_id: parameter.hir_id,\n+                    pat: new_parameter_pat,\n+                    span: parameter.span,\n                 };\n \n \n-                if is_simple_argument {\n+                if is_simple_parameter {\n                     // If this is the simple case, then we only insert one statement that is\n                     // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n                     // `HirId`s are densely assigned.\n-                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n                     statements.push(stmt);\n@@ -1179,7 +1179,7 @@ impl LoweringContext<'_> {\n                     // let <pat> = __argN;\n                     // ```\n                     //\n-                    // The first statement moves the argument into the closure and thus ensures\n+                    // The first statement moves the parameter into the closure and thus ensures\n                     // that the drop order is correct.\n                     //\n                     // The second statement creates the bindings that the user wrote.\n@@ -1189,7 +1189,7 @@ impl LoweringContext<'_> {\n                     // statement.\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n-                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n                         ThinVec::new(),\n                         desugared_span,\n@@ -1199,21 +1199,21 @@ impl LoweringContext<'_> {\n                     );\n \n                     // Construct the `let <pat> = __argN;` statement. We re-use the original\n-                    // argument's pattern so that `HirId`s are densely assigned.\n+                    // parameter's pattern so that `HirId`s are densely assigned.\n                     let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(pattern_expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n \n                     statements.push(move_stmt);\n                     statements.push(pattern_stmt);\n                 };\n \n-                arguments.push(new_argument);\n+                parameters.push(new_parameter);\n             }\n \n             let async_expr = this.make_async_expr(\n@@ -1222,7 +1222,7 @@ impl LoweringContext<'_> {\n                     let body = this.lower_block_with_stmts(body, false, statements);\n                     this.expr_block(body, ThinVec::new())\n                 });\n-            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n "}, {"sha": "773bb8dde06902aa16b02824b544b5b21d324dde", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -363,11 +363,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_arg(&mut self, arg: &'hir Arg) {\n-        let node = Node::Arg(arg);\n-        self.insert(arg.pat.span, arg.hir_id, node);\n-        self.with_parent(arg.hir_id, |this| {\n-            intravisit::walk_arg(this, arg);\n+    fn visit_param(&mut self, param: &'hir Param) {\n+        let node = Node::Param(param);\n+        self.insert(param.pat.span, param.hir_id, node);\n+        self.with_parent(param.hir_id, |this| {\n+            intravisit::walk_param(this, param);\n         });\n     }\n "}, {"sha": "17bcb1d0859683af3106c08dce35a1a49c9cf6b4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -154,20 +154,19 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'a Variant) {\n         let def = self.create_def(v.id,\n                                   DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n-            visit::walk_variant(this, v, g, item_id)\n+            visit::walk_variant(this, v)\n         });\n     }\n \n-    fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, data: &'a VariantData) {\n         for (index, field) in data.fields().iter().enumerate() {\n             let name = field.ident.map(|ident| ident.name)\n                 .unwrap_or_else(|| sym::integer(index));"}, {"sha": "eb8be6e6e3cbc36e3a4743ac84f833d387f7ea8d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -360,7 +360,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n-            Node::Arg(_) |\n+            Node::Param(_) |\n             Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n@@ -514,8 +514,7 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n-    {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n@@ -525,7 +524,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n-            _ => panic!(\"not a module\")\n+            node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n \n@@ -679,6 +678,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Wether `hir_id` corresponds to a `mod` or a crate.\n+    pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n+        match self.lookup(hir_id) {\n+            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Crate, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+\n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n     /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n@@ -955,7 +964,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n-            Some(Node::Arg(a)) => Some(&a.attrs[..]),\n+            Some(Node::Param(a)) => Some(&a.attrs[..]),\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -1019,7 +1028,7 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n-            Some(Node::Arg(arg)) => arg.span,\n+            Some(Node::Param(param)) => param.span,\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1214,15 +1223,15 @@ impl<'hir> print::PpAnn for Map<'hir> {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n \n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Arg(a)          => self.print_arg(&a),\n+            Node::Param(a)        => self.print_param(&a),\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n             Node::TraitItem(a)    => self.print_trait_item(a),\n@@ -1364,8 +1373,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n-        Some(Node::Arg(_)) => {\n-            format!(\"arg {}{}\", map.hir_to_pretty_string(id), id_str)\n+        Some(Node::Param(_)) => {\n+            format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Arm(_)) => {\n             format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)"}, {"sha": "d2c45a5af859884b9cc691291895ff0ccdb6f52a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1030,7 +1030,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -1324,15 +1324,15 @@ pub struct BodyId {\n ///\n /// Here, the `Body` associated with `foo()` would contain:\n ///\n-/// - an `arguments` array containing the `(x, y)` pattern\n+/// - an `params` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n /// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n-    pub arguments: HirVec<Arg>,\n+    pub params: HirVec<Param>,\n     pub value: Expr,\n     pub generator_kind: Option<GeneratorKind>,\n }\n@@ -1644,7 +1644,7 @@ pub enum LocalSource {\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n     /// When lowering async functions, we create locals within the `async move` so that\n-    /// all arguments are dropped after the future is polled.\n+    /// all parameters are dropped after the future is polled.\n     ///\n     /// ```ignore (pseudo-Rust)\n     /// async fn foo(<pattern> @ x: Type) {\n@@ -1940,7 +1940,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n-    pub arg_names: HirVec<Ident>,\n+    pub param_names: HirVec<Ident>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2027,9 +2027,9 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// Represents an argument in a function header.\n+/// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: HirVec<Attribute>,\n     pub hir_id: HirId,\n     pub pat: P<Pat>,\n@@ -2039,9 +2039,9 @@ pub struct Arg {\n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n-    /// The types of the function's arguments.\n+    /// The types of the function's parameters.\n     ///\n-    /// Additional argument data is stored in the function's [body](Body::arguments).\n+    /// Additional argument data is stored in the function's [body](Body::parameters).\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n@@ -2721,7 +2721,7 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Arg(&'hir Arg),\n+    Param(&'hir Param),\n     Item(&'hir Item),\n     ForeignItem(&'hir ForeignItem),\n     TraitItem(&'hir TraitItem),"}, {"sha": "21cc72efee4a32b567e94ef9234844d82e2582ba", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -33,7 +33,7 @@ pub enum Nested {\n     TraitItem(hir::TraitItemId),\n     ImplItem(hir::ImplItemId),\n     Body(hir::BodyId),\n-    BodyArgPat(hir::BodyId, usize)\n+    BodyParamPat(hir::BodyId, usize)\n }\n \n pub trait PpAnn {\n@@ -62,7 +62,7 @@ impl PpAnn for hir::Crate {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n@@ -318,7 +318,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n-                                 &f.arg_names[..]);\n+                                 &f.param_names[..]);\n             }\n             hir::TyKind::Def(..) => {},\n             hir::TyKind::Path(ref qpath) => {\n@@ -1290,7 +1290,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_args(&decl, body);\n+                self.print_closure_params(&decl, body);\n                 self.s.space();\n \n                 // this is a bare expression\n@@ -1775,7 +1775,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_arg(&mut self, arg: &hir::Arg) {\n+    pub fn print_param(&mut self, arg: &hir::Param) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n@@ -1864,7 +1864,7 @@ impl<'a> State<'a> {\n                 s.s.word(\":\");\n                 s.s.space();\n             } else if let Some(body_id) = body_id {\n-                s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+                s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n                 s.s.word(\":\");\n                 s.s.space();\n             }\n@@ -1881,13 +1881,13 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n-            s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+            s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n             if let hir::TyKind::Infer = ty.node {"}, {"sha": "fb981d961129f4252da997e33ec1975839f97e8d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -331,13 +331,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            arguments,\n+            params,\n             value,\n             generator_kind,\n         } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n-            arguments.hash_stable(hcx, hasher);\n+            params.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n             generator_kind.hash_stable(hcx, hasher);\n         });"}, {"sha": "05e2c7854b49ce7917ffa383ae57d363fd0f8451", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -402,7 +402,6 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     parent -> _,\n     call_site,\n     def_site,\n-    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "be7669fcad875aabb90e9d2cb2c9ad6660a0bd3f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -168,25 +168,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-// Allocations treat their relocations specially\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+// `Relocations` with default type parameters is a sorted map.\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for mir::interpret::Relocations<Tag>\n+where\n+    Tag: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'a>,\n         hasher: &mut StableHasher<W>,\n     ) {\n-        let mir::interpret::Allocation {\n-            bytes, relocations, undef_mask, align, mutability,\n-            extra: _,\n-        } = self;\n-        bytes.hash_stable(hcx, hasher);\n-        relocations.len().hash_stable(hcx, hasher);\n-        for reloc in relocations.iter() {\n+        self.len().hash_stable(hcx, hasher);\n+        for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n         }\n-        undef_mask.hash_stable(hcx, hasher);\n-        align.hash_stable(hcx, hasher);\n-        mutability.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "e684ccfeeb7ed7babc8c4a602c333de5ccc87626", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1636,6 +1636,9 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n                     Error0644(\"closure/generator type that references itself\")\n                 }\n+                TypeError::IntrinsicCast => {\n+                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                }\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }\n@@ -1650,7 +1653,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n-            IfExpression { .. } => \"if and else have compatible types\",\n+            IfExpression { .. } => \"if and else have incompatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\","}, {"sha": "7068fe3601a62de8e562237094ce5afde888a230", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -78,12 +78,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body) {\n-        for argument in &body.arguments {\n+        for param in &body.params {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n-                self.node_matches_type(argument.hir_id),\n+                self.node_matches_type(param.hir_id),\n             ) {\n-                self.found_arg_pattern = Some(&*argument.pat);\n+                self.found_arg_pattern = Some(&*param.pat);\n                 self.found_ty = Some(ty);\n             }\n         }\n@@ -150,12 +150,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> String {\n+    ) -> (String, Option<Span>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.sty {\n             let ty_vars = self.type_variables.borrow();\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name) =\n-                ty_vars.var_origin(ty_vid).kind {\n-                return name.to_string();\n+            let var_origin = ty_vars.var_origin(ty_vid);\n+            if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n+                return (name.to_string(), Some(var_origin.span));\n             }\n         }\n \n@@ -165,7 +165,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             printer.region_highlight_mode = highlight;\n         }\n         let _ = ty.print(printer);\n-        s\n+        (s, None)\n     }\n \n     pub fn need_type_info_err(\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let (name, name_sp) = self.extract_type_name(&ty, None);\n \n         let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -200,6 +200,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n+        } else if let Some(span) = name_sp {\n+            // `span` here lets us point at `sum` instead of the entire right hand side expr:\n+            // error[E0282]: type annotations needed\n+            //  --> file2.rs:3:15\n+            //   |\n+            // 3 |     let _ = x.sum() as f64;\n+            //   |               ^^^ cannot infer type for `S`\n+            span\n         } else {\n             span\n         };\n@@ -325,6 +333,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n             err.span_label(pattern.span, msg);\n         }\n+        // Instead of the following:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |             --^^^--------- cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        // We want:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |               ^^^ cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        let span = name_sp.unwrap_or(span);\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()\n@@ -342,7 +367,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let name = self.extract_type_name(&ty, None).0;\n         let mut err = struct_span_err!(\n             self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n         );"}, {"sha": "979815fa7f1843199df09f4e141df8a246abf387", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2,7 +2,7 @@\n //! where both the regions are anonymous.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::util::common::ErrorReported;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -59,13 +59,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n \n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            \"try_report_anon_anon_conflict: found_param1={:?} sup={:?} br1={:?}\",\n             ty_sub,\n             sup,\n             bregion_sup\n         );\n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            \"try_report_anon_anon_conflict: found_param2={:?} sub={:?} br2={:?}\",\n             ty_sup,\n             sub,\n             bregion_sub\n@@ -74,24 +74,24 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let (ty_sup, ty_fndecl_sup) = ty_sup;\n         let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-        let AnonymousArgInfo {\n-            arg: anon_arg_sup, ..\n-        } = self.find_arg_with_region(sup, sup)?;\n-        let AnonymousArgInfo {\n-            arg: anon_arg_sub, ..\n-        } = self.find_arg_with_region(sub, sub)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sup, ..\n+        } = self.find_param_with_region(sup, sup)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sub, ..\n+        } = self.find_param_with_region(sub, sub)?;\n \n         let sup_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n+        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n+        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "604115cfc371157225e7ca912bdb6797a1cd41cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -6,7 +6,7 @@ use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n@@ -24,23 +24,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n             && self.tcx().is_suitable_region(sup).is_some()\n-            && self.find_arg_with_region(sup, sub).is_some()\n+            && self.find_param_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n-                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n         } else if self.is_named_region(sup) && self.tcx().is_suitable_region(sub).is_some()\n-            && self.find_arg_with_region(sub, sup).is_some()\n+            && self.find_param_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n-                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.find_param_with_region(sub, sup).unwrap(),\n                 self.tcx().is_suitable_region(sub).unwrap(),\n             )\n         } else {\n@@ -49,20 +49,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n         debug!(\n-            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n-            anon_arg_info\n+            \"try_report_named_anon_conflict: anon_param_info = {:?}\",\n+            anon_param_info\n         );\n         debug!(\n             \"try_report_named_anon_conflict: region_info = {:?}\",\n             region_info\n         );\n \n-        let (arg, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n-            anon_arg_info.arg,\n-            anon_arg_info.arg_ty,\n-            anon_arg_info.arg_ty_span,\n-            anon_arg_info.bound_region,\n-            anon_arg_info.is_first,\n+        let (param, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_param_info.param,\n+            anon_param_info.param_ty,\n+            anon_param_info.param_ty_span,\n+            anon_param_info.bound_region,\n+            anon_param_info.is_first,\n             region_info.def_id,\n             region_info.is_impl_item,\n         );\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n+        let (error_var, span_label_var) = match param.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "668c99da0034fa5bc05725fca3406c4a2bc60e0f", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -10,37 +10,37 @@ use syntax_pos::Span;\n // The struct contains the information about the anonymous region\n // we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousArgInfo<'tcx> {\n-    // the argument corresponding to the anonymous region\n-    pub arg: &'tcx hir::Arg,\n-    // the type corresponding to the anonymopus region argument\n-    pub arg_ty: Ty<'tcx>,\n+pub(super) struct AnonymousParamInfo<'tcx> {\n+    // the parameter corresponding to the anonymous region\n+    pub param: &'tcx hir::Param,\n+    // the type corresponding to the anonymopus region parameter\n+    pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region\n     pub bound_region: ty::BoundRegion,\n-    // arg_ty_span contains span of argument type\n-    pub arg_ty_span : Span,\n+    // param_ty_span contains span of parameter type\n+    pub param_ty_span : Span,\n     // corresponds to id the argument is the first parameter\n     // in the declaration\n     pub is_first: bool,\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body arguments using\n+    // This method walks the Type of the function body parameters using\n     // `fold_regions()` function and returns the\n-    // &hir::Arg of the function argument corresponding to the anonymous\n+    // &hir::Param of the function parameter corresponding to the anonymous\n     // region and the Ty corresponding to the named region.\n     // Currently only the case where the function declaration consists of\n     // one named region and one anonymous region is handled.\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // Here, we would return the hir::Param for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Arg is the first argument in the function declaration.\n-    pub(super) fn find_arg_with_region(\n+    // the hir::Param is the first parameter in the function declaration.\n+    pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n-    ) -> Option<AnonymousArgInfo<'_>> {\n+    ) -> Option<AnonymousParamInfo<'_>> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ebr) => (\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let owner_id = hir.body_owner(body_id);\n                 let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n-                    body.arguments\n+                    body.params\n                         .iter()\n                         .enumerate()\n-                        .filter_map(|(index, arg)| {\n+                        .filter_map(|(index, param)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(arg.hir_id)?;\n+                            let param_ty_span = hir.span(ty_hir_id);\n+                            let ty = tables.node_type_opt(param.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n@@ -76,10 +76,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n-                                Some(AnonymousArgInfo {\n-                                    arg: arg,\n-                                    arg_ty: new_arg_ty,\n-                                    arg_ty_span : arg_ty_span,\n+                                Some(AnonymousParamInfo {\n+                                    param: param,\n+                                    param_ty: new_param_ty,\n+                                    param_ty_span : param_ty_span,\n                                     bound_region: bound_region,\n                                     is_first: is_first,\n                                 })"}, {"sha": "cc28567e2fc9ee3eaa7d19257c7bf839d0392e6c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1460,7 +1460,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n \n         // this can get called from typeck (by euv), and moves_by_default\n         // rightly refuses to work with inference variables, but"}, {"sha": "368f5bb64fe6c056afda13fd41fc31cabc1033ec", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -62,6 +62,7 @@\n #![feature(log_syntax)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(rustc_attrs)]\n \n #![recursion_limit=\"512\"]\n \n@@ -109,6 +110,7 @@ pub mod middle {\n     pub mod cstore;\n     pub mod dead;\n     pub mod dependency_format;\n+    pub mod diagnostic_items;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;"}, {"sha": "affda256322a492f8ca05373c9a9136cc475a5a6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -966,10 +966,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |cx| {\n-            lint_callback!(cx, check_arg, arg);\n-            hir_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1040,13 +1040,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_variant_data(&mut self,\n                         s: &'tcx hir::VariantData,\n-                        name: ast::Name,\n-                        g: &'tcx hir::Generics,\n-                        item_id: hir::HirId,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: hir::HirId,\n                         _: Span) {\n-        lint_callback!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s);\n         hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n@@ -1061,9 +1061,9 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v);\n         })\n     }\n \n@@ -1163,10 +1163,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n }\n \n impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_arg(&mut self, arg: &'a ast::Arg) {\n-        self.with_lint_attrs(arg.id, &arg.attrs, |cx| {\n-            run_early_pass!(cx, check_arg, arg);\n-            ast_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1214,18 +1214,13 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_fn_post, fk, decl, span, id);\n     }\n \n-    fn visit_variant_data(&mut self,\n-                        s: &'a ast::VariantData,\n-                        ident: ast::Ident,\n-                        g: &'a ast::Generics,\n-                        item_id: ast::NodeId,\n-                        _: Span) {\n-        run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n         if let Some(ctor_hir_id) = s.ctor_id() {\n             self.check_id(ctor_hir_id);\n         }\n         ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n@@ -1235,11 +1230,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v, g);\n-            ast_visit::walk_variant(cx, v, g, item_id);\n-            run_early_pass!(cx, check_variant_post, v, g);\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n         })\n     }\n "}, {"sha": "13834eaf40f576591e17ac71c75536a31bc4ac38", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -159,29 +159,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n }\n \n fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n-    if segment.ident.name == sym::TyKind {\n-        if let Some(res) = segment.res {\n-            if let Some(did) = res.opt_def_id() {\n-                return cx.match_def_path(did, TYKIND_PATH);\n-            }\n+    if let Some(res) = segment.res {\n+        if let Some(did) = res.opt_def_id() {\n+            return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n         }\n     }\n \n     false\n }\n \n-const TYKIND_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::sty, sym::TyKind];\n-const TY_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::Ty];\n-const TYCTXT_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::context, sym::TyCtxt];\n-\n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     match &ty.node {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n                 let did = path.res.opt_def_id()?;\n-                if cx.match_def_path(did, TY_PATH) {\n+                if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n                     return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                } else if cx.match_def_path(did, TYCTXT_PATH) {\n+                } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n                     return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n                 }\n             }"}, {"sha": "a3518b2b478ad67c42ce426e2a352a32fd800ae2", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -206,7 +206,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_arg(a: &$hir hir::Arg);\n+            fn check_param(a: &$hir hir::Param);\n             fn check_body(a: &$hir hir::Body);\n             fn check_body_post(a: &$hir hir::Body);\n             fn check_name(a: Span, b: ast::Name);\n@@ -248,21 +248,11 @@ macro_rules! late_lint_methods {\n             fn check_trait_item_post(a: &$hir hir::TraitItem);\n             fn check_impl_item(a: &$hir hir::ImplItem);\n             fn check_impl_item_post(a: &$hir hir::ImplItem);\n-            fn check_struct_def(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n-            fn check_struct_def_post(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n+            fn check_struct_def(a: &$hir hir::VariantData);\n+            fn check_struct_def_post(a: &$hir hir::VariantData);\n             fn check_struct_field(a: &$hir hir::StructField);\n-            fn check_variant(a: &$hir hir::Variant, b: &$hir hir::Generics);\n-            fn check_variant_post(a: &$hir hir::Variant, b: &$hir hir::Generics);\n+            fn check_variant(a: &$hir hir::Variant);\n+            fn check_variant_post(a: &$hir hir::Variant);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n             fn check_path(a: &$hir hir::Path, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n@@ -359,7 +349,7 @@ macro_rules! declare_combined_late_lint_pass {\n macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n-            fn check_arg(a: &ast::Arg);\n+            fn check_param(a: &ast::Param);\n             fn check_ident(a: ast::Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n@@ -395,21 +385,11 @@ macro_rules! early_lint_methods {\n             fn check_trait_item_post(a: &ast::TraitItem);\n             fn check_impl_item(a: &ast::ImplItem);\n             fn check_impl_item_post(a: &ast::ImplItem);\n-            fn check_struct_def(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n-            fn check_struct_def_post(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n+            fn check_struct_def(a: &ast::VariantData);\n+            fn check_struct_def_post(a: &ast::VariantData);\n             fn check_struct_field(a: &ast::StructField);\n-            fn check_variant(a: &ast::Variant, b: &ast::Generics);\n-            fn check_variant_post(a: &ast::Variant, b: &ast::Generics);\n+            fn check_variant(a: &ast::Variant);\n+            fn check_variant_post(a: &ast::Variant);\n             fn check_lifetime(a: &ast::Lifetime);\n             fn check_path(a: &ast::Path, b: ast::NodeId);\n             fn check_attribute(a: &ast::Attribute);\n@@ -812,9 +792,9 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |builder| {\n-            intravisit::walk_arg(builder, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+            intravisit::walk_param(builder, param);\n         });\n     }\n "}, {"sha": "d4805a7c7832252731a46186446e7c35298d4a43", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -30,10 +30,11 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n-        Some(Node::TraitItem(..)) =>\n-            true,\n-        _ =>\n-            false\n+        Some(Node::TraitItem(..)) |\n+        Some(Node::Variant(..)) |\n+        Some(Node::AnonConst(..)) |\n+        Some(Node::Pat(..)) => true,\n+        _ => false\n     }\n }\n \n@@ -75,7 +76,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(res.def_id());\n             }\n             _ if self.in_pat => {},\n-            Res::PrimTy(..) | Res::SelfTy(..) | Res::SelfCtor(..) |\n+            Res::PrimTy(..) | Res::SelfCtor(..) |\n             Res::Local(..) => {}\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n@@ -92,6 +93,14 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     self.check_def_id(variant_id);\n                 }\n             }\n+            Res::SelfTy(t, i) => {\n+                if let Some(t) = t {\n+                    self.check_def_id(t);\n+                }\n+                if let Some(i) = i {\n+                    self.check_def_id(i);\n+                }\n+            }\n             Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => {}\n             _ => {\n                 self.check_def_id(res.def_id());\n@@ -271,7 +280,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 let res = self.tables.qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n             }\n-            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+            PatKind::Path(ref qpath) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 self.handle_res(res);\n             }\n@@ -298,6 +307,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_ty(self, ty);\n     }\n+\n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        self.live_symbols.insert(c.hir_id);\n+        intravisit::walk_anon_const(self, c);\n+    }\n }\n \n fn has_allow_dead_code_or_lang_attr("}, {"sha": "dfae169b27824abe35d7242c0c6ee3e7ac66139e", "filename": "src/librustc/middle/diagnostic_items.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -0,0 +1,123 @@\n+//! Detecting diagnostic items.\n+//!\n+//! Diagnostic items are items that are not language-inherent, but can reasonably be expected to\n+//! exist for diagnostic purposes. This allows diagnostic authors to refer to specific items\n+//! directly, without having to guess module paths and crates.\n+//! Examples are:\n+//!\n+//! * Traits like `Debug`, that have no bearing on language semantics\n+//!\n+//! * Compiler internal types like `Ty` and `TyCtxt`\n+\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::ty::TyCtxt;\n+use crate::util::nodemap::FxHashMap;\n+\n+use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir;\n+\n+struct DiagnosticItemCollector<'tcx> {\n+    // items from this crate\n+    items: FxHashMap<Symbol, DefId>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        self.observe_item(&item.attrs, item.hir_id);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        self.observe_item(&trait_item.attrs, trait_item.hir_id);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        self.observe_item(&impl_item.attrs, impl_item.hir_id);\n+    }\n+}\n+\n+impl<'tcx> DiagnosticItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> DiagnosticItemCollector<'tcx> {\n+        DiagnosticItemCollector {\n+            tcx,\n+            items: Default::default(),\n+        }\n+    }\n+\n+    fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n+        if let Some(name) = extract(attrs) {\n+            let def_id = self.tcx.hir().local_def_id(hir_id);\n+            // insert into our table\n+            collect_item(self.tcx, &mut self.items, name, def_id);\n+        }\n+    }\n+}\n+\n+fn collect_item(\n+    tcx: TyCtxt<'_>,\n+    items: &mut FxHashMap<Symbol, DefId>,\n+    name: Symbol,\n+    item_def_id: DefId,\n+) {\n+    // Check for duplicates.\n+    if let Some(original_def_id) = items.insert(name, item_def_id) {\n+        if original_def_id != item_def_id {\n+            let mut err = match tcx.hir().span_if_local(item_def_id) {\n+                Some(span) => tcx.sess.struct_span_err(\n+                    span,\n+                    &format!(\"duplicate diagnostic item found: `{}`.\", name)),\n+                None => tcx.sess.struct_err(&format!(\n+                        \"duplicate diagnostic item in crate `{}`: `{}`.\",\n+                        tcx.crate_name(item_def_id.krate),\n+                        name)),\n+            };\n+            if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n+                span_note!(&mut err, span, \"first defined here.\");\n+            } else {\n+                err.note(&format!(\"first defined in crate `{}`.\",\n+                                    tcx.crate_name(original_def_id.krate)));\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n+fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    attrs.iter().find_map(|attr| {\n+        if attr.check_name(sym::rustc_diagnostic_item) {\n+            attr.value_str()\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Traverse and collect the diagnostic items in the current\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = DiagnosticItemCollector::new(tcx);\n+\n+    // Collect diagnostic items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    tcx.arena.alloc(collector.items)\n+}\n+\n+\n+/// Traverse and collect all the diagnostic items in all crates.\n+pub fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = FxHashMap::default();\n+\n+    // Collect diagnostic items in other crates.\n+    for &cnum in tcx.crates().iter().chain(std::iter::once(&LOCAL_CRATE)) {\n+        for (&name, &def_id) in tcx.diagnostic_items(cnum).iter() {\n+            collect_item(tcx, &mut collector, name, def_id);\n+        }\n+    }\n+\n+    tcx.arena.alloc(collector)\n+}"}, {"sha": "222c2a405d65b3944ec64173224a0ec8e971eba8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -313,23 +313,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_body(&mut self, body: &hir::Body) {\n         debug!(\"consume_body(body={:?})\", body);\n \n-        for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.pat_ty_adjusted(&arg.pat));\n-            debug!(\"consume_body: arg_ty = {:?}\", arg_ty);\n+        for param in &body.params {\n+            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n+            debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(\n                     region::Scope {\n                         id: body.value.hir_id.local_id,\n                         data: region::ScopeData::Node\n                 }));\n-            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n-                arg.hir_id,\n-                arg.pat.span,\n-                fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty));\n+            let param_cmt = Rc::new(self.mc.cat_rvalue(\n+                param.hir_id,\n+                param.pat.span,\n+                fn_body_scope_r, // Parameters live only as long as the fn body.\n+                param_ty));\n \n-            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n+            self.walk_irrefutable_pat(param_cmt, &param.pat);\n         }\n \n         self.consume_expr(&body.value);"}, {"sha": "6b04600eb75f8d0e2d903bbf111774ef9049e370", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -367,8 +367,6 @@ language_item_table! {\n \n     MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n \n-    DebugTraitLangItem,          \"debug_trait\",        debug_trait,             Target::Trait;\n-\n     // Align offset for stride != 1, must not panic.\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n@@ -381,9 +379,13 @@ language_item_table! {\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally abort compilation.\n-    pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n+    pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n-            self.sess.fatal(&msg)\n+            if let Some(span) = span {\n+                self.sess.span_fatal(span, &msg)\n+            } else {\n+                self.sess.fatal(&msg)\n+            }\n         })\n     }\n }"}, {"sha": "00013bfc574f4e108ce489807281d0c089fe4ecf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -242,7 +242,7 @@ struct LocalInfo {\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(HirId, ast::Name),\n+    Param(HirId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n }\n@@ -298,7 +298,7 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             CleanExit => {}\n@@ -320,7 +320,7 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Arg(_, name) => {\n+            Local(LocalInfo { name, .. }) | Param(_, name) => {\n                 name.to_string()\n             },\n             CleanExit => \"<clean-exit>\".to_owned()\n@@ -330,7 +330,7 @@ impl IrMaps<'tcx> {\n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Arg(..) | CleanExit => false\n+            Param(..) | CleanExit => false\n         }\n     }\n \n@@ -371,21 +371,21 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n-    for arg in &body.arguments {\n-        let is_shorthand = match arg.pat.node {\n+    for param in &body.params {\n+        let is_shorthand = match param.pat.node {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n-        arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            debug!(\"adding argument {:?}\", hir_id);\n+        param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+            debug!(\"adding parameters {:?}\", hir_id);\n             let var = if is_shorthand {\n                 Local(LocalInfo {\n                     id: hir_id,\n                     name: ident.name,\n                     is_shorthand: true,\n                 })\n             } else {\n-                Arg(hir_id, ident.name)\n+                Param(hir_id, ident.name)\n             };\n             fn_maps.add_variable(var);\n         })\n@@ -1525,8 +1525,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, hir_id, _, ident| {\n+        for param in &body.params {\n+            param.pat.each_binding(|_bm, hir_id, _, ident| {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self."}, {"sha": "28aa86ef9afb2706a0c449d64232b2fc237bebc0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1383,8 +1383,8 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n-        for argument in &body.arguments {\n-            self.visit_pat(&argument.pat);\n+        for param in &body.params {\n+            self.visit_pat(&param.pat);\n         }\n \n         // The body of the every fn is a root scope."}, {"sha": "8836a632a7ca89bddb6cb710f696d0aa27debc74", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2557,7 +2557,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(ident) = parent.and_then(|body| {\n-                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+                self.tcx.hir().body(body).params[index].pat.simple_ident()\n             }) {\n                 format!(\"`{}`\", ident)\n             } else {"}, {"sha": "df1d9a987011d0891f75fe43cf4813d2eb22d8e1", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 196, "deletions": 13, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -13,18 +13,33 @@ use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+// NOTE: When adding new fields, make sure to adjust the Snapshot impl in\n+// `src/librustc_mir/interpret/snapshot.rs`.\n+#[derive(\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n+    /// Note that the bytes of a pointer represent the offset of the pointer.\n+    bytes: Vec<u8>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    pub relocations: Relocations<Tag>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n+    relocations: Relocations<Tag>,\n+    /// Denotes which part of this allocation is initialized.\n+    undef_mask: UndefMask,\n+    /// The size of the allocation. Currently, must always equal `bytes.len()`.\n+    pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n     /// Whether the allocation is mutable.\n@@ -85,11 +100,12 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n+        let size = Size::from_bytes(bytes.len() as u64);\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask,\n+            undef_mask: UndefMask::new(size, true),\n+            size,\n             align,\n             mutability: Mutability::Immutable,\n             extra: (),\n@@ -106,13 +122,39 @@ impl<Tag> Allocation<Tag> {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n+            size,\n             align,\n             mutability: Mutability::Mutable,\n             extra: (),\n         }\n     }\n }\n \n+/// Raw accessors. Provide access to otherwise private bytes.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    pub fn len(&self) -> usize {\n+        self.size.bytes() as usize\n+    }\n+\n+    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// This must not be used for reads affecting the interpreter execution.\n+    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+        &self.bytes[range]\n+    }\n+\n+    /// Returns the undef mask.\n+    pub fn undef_mask(&self) -> &UndefMask {\n+        &self.undef_mask\n+    }\n+\n+    /// Returns the relocation list.\n+    pub fn relocations(&self) -> &Relocations<Tag> {\n+        &self.relocations\n+    }\n+}\n+\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Byte accessors\n@@ -132,9 +174,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         );\n         let end = end.bytes() as usize;\n         assert!(\n-            end <= self.bytes.len(),\n+            end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(), size.bytes(), self.bytes.len()\n+            offset.bytes(), size.bytes(), self.len()\n         );\n         (offset.bytes() as usize)..end\n     }\n@@ -422,7 +464,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns all relocations overlapping with the given ptr-offset pair.\n-    pub fn relocations(\n+    pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -443,7 +485,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        if self.relocations(cx, ptr, size).is_empty() {\n+        if self.get_relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n             throw_unsup!(ReadPointerAsBytes)\n@@ -465,7 +507,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n-            let relocations = self.relocations(cx, ptr, size);\n+            let relocations = self.get_relocations(cx, ptr, size);\n             if relocations.is_empty() {\n                 return Ok(());\n             }\n@@ -536,6 +578,94 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n+/// Run-length encoding of the undef mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct AllocationDefinedness {\n+    /// The definedness of the first range.\n+    initial: bool,\n+    /// The lengths of ranges that are run-length encoded.\n+    /// The definedness of the ranges alternate starting with `initial`.\n+    ranges: smallvec::SmallVec::<[u64; 1]>,\n+}\n+\n+/// Transferring the definedness mask to other allocations.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a run-length encoding of the undef_mask.\n+    pub fn compress_undef_range(\n+        &self,\n+        src: Pointer<Tag>,\n+        size: Size,\n+    ) -> AllocationDefinedness {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // a precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // [5, 1, 2, 1, 3, 3, 1]\n+        // where each element toggles the state\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let initial = self.undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = initial;\n+\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n+\n+        ranges.push(cur_len);\n+\n+        AllocationDefinedness { ranges, initial, }\n+    }\n+\n+    /// Apply multiple instances of the run-length encoding to the undef_mask.\n+    pub fn mark_compressed_undef_range(\n+        &mut self,\n+        defined: &AllocationDefinedness,\n+        dest: Pointer<Tag>,\n+        size: Size,\n+        repeat: u64,\n+    ) {\n+        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                defined.initial,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = defined.initial;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n+                );\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}\n+\n /// Relocations\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n@@ -566,6 +696,59 @@ impl<Tag> DerefMut for Relocations<Tag> {\n     }\n }\n \n+/// A partial, owned list of relocations to transfer into another allocation.\n+pub struct AllocationRelocations<Tag> {\n+    relative_relocations: Vec<(Size, (Tag, AllocId))>,\n+}\n+\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    pub fn prepare_relocation_copy(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        src: Pointer<Tag>,\n+        size: Size,\n+        dest: Pointer<Tag>,\n+        length: u64,\n+    ) -> AllocationRelocations<Tag> {\n+        let relocations = self.get_relocations(cx, src, size);\n+        if relocations.is_empty() {\n+            return AllocationRelocations { relative_relocations: Vec::new() };\n+        }\n+\n+        let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+\n+        for i in 0..length {\n+            new_relocations.extend(\n+                relocations\n+                .iter()\n+                .map(|&(offset, reloc)| {\n+                    // compute offset for current repetition\n+                    let dest_offset = dest.offset + (i * size);\n+                    (\n+                        // shift offsets from source allocation to destination allocation\n+                        offset + dest_offset - src.offset,\n+                        reloc,\n+                    )\n+                })\n+            );\n+        }\n+\n+        AllocationRelocations {\n+            relative_relocations: new_relocations,\n+        }\n+    }\n+\n+    /// Apply a relocation copy.\n+    /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n+    /// to be clear of relocations.\n+    pub fn mark_relocation_range(\n+        &mut self,\n+        relocations: AllocationRelocations<Tag>,\n+    ) {\n+        self.relocations.insert_presorted(relocations.relative_relocations);\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "5ac99ba1470001ebfaaad1d36f3b617aa66e2dff", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -108,11 +108,6 @@ pub struct Body<'tcx> {\n     /// needn't) be tracked across crates.\n     pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n \n-    /// Rvalues promoted from this function, such as borrows of constants.\n-    /// Each of them is the Body of a constant with the fn's type parameters\n-    /// in scope, but a separate set of locals.\n-    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n-\n     /// Yields type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n@@ -174,7 +169,6 @@ impl<'tcx> Body<'tcx> {\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        promoted: IndexVec<Promoted, Body<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n@@ -196,7 +190,6 @@ impl<'tcx> Body<'tcx> {\n             basic_blocks,\n             source_scopes,\n             source_scope_local_data,\n-            promoted,\n             yield_ty,\n             generator_drop: None,\n             generator_layout: None,\n@@ -418,7 +411,6 @@ impl_stable_hash_for!(struct Body<'tcx> {\n     basic_blocks,\n     source_scopes,\n     source_scope_local_data,\n-    promoted,\n     yield_ty,\n     generator_drop,\n     generator_layout,\n@@ -1555,7 +1547,7 @@ pub struct Statement<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(Statement<'_>, 56);\n \n-impl<'tcx> Statement<'tcx> {\n+impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_nop(&mut self) {\n@@ -1677,7 +1669,7 @@ pub struct InlineAsm<'tcx> {\n     pub inputs: Box<[(Span, Operand<'tcx>)]>,\n }\n \n-impl<'tcx> Debug for Statement<'tcx> {\n+impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n@@ -1737,23 +1729,32 @@ pub enum PlaceBase<'tcx> {\n }\n \n /// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub kind: StaticKind,\n+    pub kind: StaticKind<'tcx>,\n+    /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n+    /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n+    /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n+    /// into the calling frame.\n+    pub def_id: DefId,\n }\n \n #[derive(\n-    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n )]\n-pub enum StaticKind {\n-    Promoted(Promoted),\n-    Static(DefId),\n+pub enum StaticKind<'tcx> {\n+    /// Promoted references consist of an id (`Promoted`) and the substs necessary to monomorphize\n+    /// it. Usually, these substs are just the identity substs for the item. However, the inliner\n+    /// will adjust these substs when it inlines a function based on the substs at the callsite.\n+    Promoted(Promoted, SubstsRef<'tcx>),\n+    Static,\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n     ty,\n-    kind\n+    kind,\n+    def_id\n });\n \n /// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n@@ -2047,7 +2048,7 @@ impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n \n impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n \n-impl<'tcx> Debug for Place<'tcx> {\n+impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         self.iterate(|_place_base, place_projections| {\n             // FIXME: remove this collect once we have migrated to slices\n@@ -2114,10 +2115,12 @@ impl Debug for PlaceBase<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n+            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static, def_id }) => {\n                 write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n             }\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Promoted(promoted) }) => {\n+            PlaceBase::Static(box self::Static {\n+                ty, kind: StaticKind::Promoted(promoted, _), def_id: _\n+            }) => {\n                 write!(fmt, \"({:?}: {:?})\", promoted, ty)\n             }\n         }\n@@ -3032,7 +3035,6 @@ BraceStructTypeFoldableImpl! {\n         basic_blocks,\n         source_scopes,\n         source_scope_local_data,\n-        promoted,\n         yield_ty,\n         generator_drop,\n         generator_layout,\n@@ -3226,13 +3228,63 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Place {\n-            base: self.base.clone(),\n+            base: self.base.fold_with(folder),\n             projection: self.projection.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.projection.visit_with(visitor)\n+        self.base.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n+            PlaceBase::Static(static_) => PlaceBase::Static(static_.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            PlaceBase::Local(local) => local.visit_with(visitor),\n+            PlaceBase::Static(static_) => (**static_).visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Static {\n+            ty: self.ty.fold_with(folder),\n+            kind: self.kind.fold_with(folder),\n+            def_id: self.def_id,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let Static { ty, kind, def_id: _ } = self;\n+\n+        ty.visit_with(visitor) || kind.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for StaticKind<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                StaticKind::Promoted(promoted.fold_with(folder), substs.fold_with(folder)),\n+            StaticKind::Static => StaticKind::Static\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                promoted.visit_with(visitor) || substs.visit_with(visitor),\n+            StaticKind::Static => { false }\n+        }\n     }\n }\n "}, {"sha": "821367e9ea12c480645c9c0f3ad12bc93593355d", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -708,7 +708,7 @@ macro_rules! make_mir_visitor {\n                     PlaceBase::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    PlaceBase::Static(box Static { kind: _, ty }) => {\n+                    PlaceBase::Static(box Static { kind: _, ty, def_id: _ }) => {\n                         self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                 }\n@@ -724,10 +724,6 @@ macro_rules! make_mir_visitor {\n                 }\n \n                 match & $($mutability)? proj.elem {\n-                    ProjectionElem::Deref => {\n-                    }\n-                    ProjectionElem::Subslice { from: _, to: _ } => {\n-                    }\n                     ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n@@ -738,11 +734,12 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n+                    ProjectionElem::Deref |\n+                    ProjectionElem::Subslice { from: _, to: _ } |\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n-                                                    from_end: _ } => {\n-                    }\n-                    ProjectionElem::Downcast(_name, _variant_index) => {\n+                                                    from_end: _ } |\n+                    ProjectionElem::Downcast(_, _) => {\n                     }\n                 }\n             }"}, {"sha": "ef838114f6c36886ae2e141a2aaf283efd27667d", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -110,7 +110,11 @@ rustc_queries! {\n             no_hash\n         }\n \n-        query mir_validated(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_validated(_: DefId) ->\n+            (\n+                &'tcx Steal<mir::Body<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+            ) {\n             no_hash\n         }\n \n@@ -125,7 +129,17 @@ rustc_queries! {\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> { }\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            cache_on_disk_if { key.is_local() }\n+            load_cached(tcx, id) {\n+                let promoted: Option<\n+                    rustc_data_structures::indexed_vec::IndexVec<\n+                        crate::mir::Promoted,\n+                        crate::mir::Body<'tcx>\n+                    >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                promoted.map(|p| &*tcx.arena.alloc(p))\n+            }\n+        }\n     }\n \n     TypeChecking {\n@@ -790,7 +804,7 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        /// Lifetime resolution. See `middle::resolve_lifetimes`.\n         query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n             desc { \"resolving lifetimes\" }\n         }\n@@ -832,13 +846,30 @@ rustc_queries! {\n             -> &'tcx [(Symbol, Option<Symbol>)] {\n             desc { \"calculating the lib features defined in a crate\" }\n         }\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n+        // FIXME: It is illegal to pass a `CrateNum` other than `LOCAL_CRATE` here, just get rid\n+        // of that argument?\n         query get_lang_items(_: CrateNum) -> &'tcx LanguageItems {\n             eval_always\n             desc { \"calculating the lang items map\" }\n         }\n+\n+        /// Returns all diagnostic items defined in all crates\n+        query all_diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            eval_always\n+            desc { \"calculating the diagnostic items map\" }\n+        }\n+\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n         query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, usize)] {\n             desc { \"calculating the lang items defined in a crate\" }\n         }\n+\n+        /// Returns the diagnostic items defined in a crate\n+        query diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            desc { \"calculating the diagnostic items map in a crate\" }\n+        }\n+\n         query missing_lang_items(_: CrateNum) -> &'tcx [LangItem] {\n             desc { \"calculating the missing lang items in a crate\" }\n         }"}, {"sha": "740d9db7edcf77d2a909008489af2728f16bafaf", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1292,6 +1292,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show macro backtraces even for non-local macros\"),\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help\"),\n+    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"set the current terminal width\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n     dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n@@ -1719,13 +1721,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              static, framework, or dylib (the default).\",\n             \"[KIND=]NAME\",\n         ),\n-        opt::multi_s(\n-            \"\",\n-            \"crate-type\",\n-            \"Comma separated list of types of crates\n-                                    for the compiler to emit\",\n-            \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n-        ),\n+        make_crate_type_option(),\n         opt::opt_s(\n             \"\",\n             \"crate-name\",\n@@ -2506,6 +2502,16 @@ pub fn build_session_options_and_crate_config(\n     )\n }\n \n+pub fn make_crate_type_option() -> RustcOptGroup {\n+    opt::multi_s(\n+        \"\",\n+        \"crate-type\",\n+        \"Comma separated list of types of crates\n+                                for the compiler to emit\",\n+        \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n+    )\n+}\n+\n pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in &list_list {"}, {"sha": "f01883d9634cdf3f501f2df8dd564a4d6865af2d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1055,13 +1055,15 @@ fn default_emitter(\n                         Some(source_map.clone()),\n                         short,\n                         sopts.debugging_opts.teach,\n+                        sopts.debugging_opts.terminal_width,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n                         Some(source_map.clone()),\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n+                        None,  // no terminal width\n                     ),\n                 };\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n@@ -1375,7 +1377,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n             Box::new(JsonEmitter::basic(pretty, json_rendered)),\n@@ -1389,7 +1391,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n             Box::new(JsonEmitter::basic(pretty, json_rendered)),"}, {"sha": "b38e1f5f83937808602c863b60b1f95fbce9e312", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 85, "deletions": 22, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,20 +1,21 @@\n use super::{\n+    ConstEvalFailure,\n+    EvaluationResult,\n     FulfillmentError,\n     FulfillmentErrorCode,\n     MismatchedProjectionTypes,\n+    ObjectSafetyViolation,\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n     OnUnimplementedDirective,\n     OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n-    TraitNotObjectSafe,\n-    ConstEvalFailure,\n+    Overflow,\n     PredicateObligation,\n     SelectionContext,\n     SelectionError,\n-    ObjectSafetyViolation,\n-    Overflow,\n+    TraitNotObjectSafe,\n };\n \n use crate::hir;\n@@ -35,7 +36,7 @@ use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n-use syntax::symbol::sym;\n+use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -657,19 +658,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(||\n-                                format!(\"the trait bound `{}` is not satisfied{}\",\n-                                        trait_ref.to_predicate(), post_message)\n-                            ));\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            )));\n \n                         let explanation =\n                             if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n                                 \"consider using `()`, or a `Result`\".to_owned()\n                             } else {\n-                                format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                        pre_message,\n-                                        trait_ref,\n-                                        trait_ref.self_ty())\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref,\n+                                    trait_ref.self_ty(),\n+                                )\n                             };\n \n                         if let Some(ref s) = label {\n@@ -686,6 +690,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n@@ -953,6 +958,57 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        match self_ty.sty {\n+            ty::FnDef(def_id, _) => {\n+                // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n+                // to a type that *would* satisfy the trait binding. If it would, suggest calling\n+                // it: `bar(foo)` -> `bar(foo)`. This case is *very* likely to be hit if `foo` is\n+                // `async`.\n+                let output_ty = self_ty.fn_sig(self.tcx).output();\n+                let new_trait_ref = ty::TraitRef {\n+                    def_id: trait_ref.def_id(),\n+                    substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n+                };\n+                let obligation = Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+                match self.evaluate_obligation(&obligation) {\n+                    Ok(EvaluationResult::EvaluatedToOk) |\n+                    Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n+                    Ok(EvaluationResult::EvaluatedToAmbig) => {\n+                        if let Some(hir::Node::Item(hir::Item {\n+                            ident,\n+                            node: hir::ItemKind::Fn(.., body_id),\n+                            ..\n+                        })) = self.tcx.hir().get_if_local(def_id) {\n+                            let body = self.tcx.hir().body(*body_id);\n+                            err.help(&format!(\n+                                \"use parentheses to call the function: `{}({})`\",\n+                                ident,\n+                                body.params.iter()\n+                                    .map(|arg| match &arg.pat.node {\n+                                        hir::PatKind::Binding(_, _, ident, None)\n+                                        if ident.name != kw::SelfLower => ident.to_string(),\n+                                        _ => \"_\".to_string(),\n+                                    }).collect::<Vec<_>>().join(\", \")));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n     fn suggest_remove_reference(\n@@ -1044,7 +1100,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span),\n+                 self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(ref args, _),\n@@ -1534,25 +1591,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{}` is well-formed\",\n-                                  data));\n+                err.note(&format!(\n+                    \"required so that the projection `{}` is well-formed\",\n+                    data,\n+                ));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-                err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n-                                  ref_ty));\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n-                err.note(&format!(\"required so that the lifetime bound of `{}` for `{}` \\\n-                                   is satisfied\",\n-                                  region, object_ty));\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region,\n+                    object_ty,\n+                ));\n             }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.def_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n-                    err.span_note(sp, &msg);\n+                    err.span_label(sp, &msg);\n                 } else {\n                     err.note(&msg);\n                 }"}, {"sha": "87a23f655a8f33560917b9db59563381a8c42fdf", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -15,7 +15,6 @@ use super::util;\n use crate::hir::def_id::DefId;\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n@@ -397,40 +396,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.selcx.tcx().global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.selcx.tcx(), self.param_env)\n     }\n }\n "}, {"sha": "c31ff3ab1b55ddfba793327ca3665875abd26d4d", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -5,11 +5,10 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::{Subst, InternalSubsts};\n+use crate::ty::subst::Subst;\n use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n@@ -191,40 +190,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.infcx.tcx.global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None,\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.infcx.tcx, self.param_env)\n     }\n }\n "}, {"sha": "217c887d5254eb66bcee93b126fb557500af9db7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -3513,7 +3513,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // We can only make objects from sized types.\n                 let tr = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     substs: tcx.mk_substs_trait(source, &[]),\n                 };\n                 nested.push(predicate_to_obligation(tr.to_predicate()));"}, {"sha": "17c9e520bcea284c2d385eb71649003555f70f60", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -21,7 +21,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, ProjectionKind};\n+use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -978,6 +978,7 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyCtxt\")]\n pub struct TyCtxt<'tcx> {\n     gcx: &'tcx GlobalCtxt<'tcx>,\n }\n@@ -1096,6 +1097,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+        self.arena.alloc(Steal::new(promoted))\n+    }\n+\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+        self.arena.alloc(promoted)\n+    }\n+\n     pub fn alloc_adt_def(\n         self,\n         did: DefId,\n@@ -1298,10 +1309,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.get_lib_features(LOCAL_CRATE)\n     }\n \n+    /// Obtain all lang items of this crate and all dependencies (recursively)\n     pub fn lang_items(self) -> &'tcx middle::lang_items::LanguageItems {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n+    /// Obtain the given diagnostic item's `DefId`. Use `is_diagnostic_item` if you just want to\n+    /// compare against another `DefId`, since `is_diagnostic_item` is cheaper.\n+    pub fn get_diagnostic_item(self, name: Symbol) -> Option<DefId> {\n+        self.all_diagnostic_items(LOCAL_CRATE).get(&name).copied()\n+    }\n+\n+    /// Check whether the diagnostic item with the given `name` has the given `DefId`.\n+    pub fn is_diagnostic_item(self, name: Symbol, did: DefId) -> bool {\n+        self.diagnostic_items(did.krate).get(&name) == Some(&did)\n+    }\n+\n     pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n         self.stability_index(LOCAL_CRATE)\n     }\n@@ -2375,13 +2398,19 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n+        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n+    #[inline]\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(item, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem);\n+        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n@@ -2886,6 +2915,14 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n+    providers.diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect(tcx)\n+    };\n+    providers.all_diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect_all(tcx)\n+    };\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "fe8f94ab1d314bdcb1e3a2a2870a228b7b295c99", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -46,6 +46,8 @@ pub enum TypeError<'tcx> {\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+\n+    IntrinsicCast,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -179,6 +181,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ConstMismatch(ref values) => {\n                 write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n+            IntrinsicCast => {\n+                write!(f, \"cannot coerce intrinsics to function pointers\")\n+            }\n         }\n     }\n }\n@@ -247,20 +252,32 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(self,\n-                                     db: &mut DiagnosticBuilder<'_>,\n-                                     err: &TypeError<'tcx>,\n-                                     sp: Span) {\n+    pub fn note_and_explain_type_err(\n+        self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        err: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         use self::TypeError::*;\n \n-        match err.clone() {\n+        match err {\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n+                if expected_str == found_str && expected_str == \"opaque type\" { // Issue #63167\n+                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    let e_str = values.expected.to_string();\n+                    let f_str = values.found.to_string();\n+                    if &e_str == &f_str && &e_str == \"impl std::future::Future\" {\n+                        // FIXME: use non-string based check.\n+                        db.help(\"if both `Future`s have the same `Output` type, consider \\\n+                                 `.await`ing on both of them\");\n+                    }\n+                }\n                 if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n                        (&values.found.sty, &values.expected.sty) // Issue #53280\n                 {"}, {"sha": "a26fa72f330410180080ffa6f143e1be1819e210", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n-        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n+        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem, None);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n     }"}, {"sha": "5ec4754c4535bc54019426bea5cef721428e9c52", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -273,14 +273,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                              repr: &ReprOptions,\n                              kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n-        let packed = repr.packed();\n-        if packed && repr.align > 0 {\n+        let pack = repr.pack;\n+        if pack.is_some() && repr.align.is_some() {\n             bug!(\"struct cannot be packed and aligned\");\n         }\n \n-        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n-\n-        let mut align = if packed {\n+        let mut align = if pack.is_some() {\n             dl.i8_align\n         } else {\n             dl.aggregate_align\n@@ -303,7 +301,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             };\n             let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyLayout<'_>| {\n-                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+                if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n                 StructKind::AlwaysSized |\n@@ -334,7 +332,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align = if packed {\n+            let prefix_align = if let Some(pack) = pack {\n                 prefix_align.min(pack)\n             } else {\n                 prefix_align\n@@ -355,7 +353,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if packed {\n+            let field_align = if let Some(pack) = pack {\n                 field.align.min(AbiAndPrefAlign::new(pack))\n             } else {\n                 field.align\n@@ -379,10 +377,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n \n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n         debug!(\"univariant min_size: {:?}\", offset);\n@@ -730,23 +726,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    let packed = def.repr.packed();\n-                    if packed && def.repr.align > 0 {\n-                        bug!(\"Union cannot be packed and aligned\");\n+                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                        bug!(\"union cannot be packed and aligned\");\n                     }\n \n-                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n-\n-                    let mut align = if packed {\n+                    let mut align = if def.repr.pack.is_some() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    if def.repr.align > 0 {\n-                        let repr_align = def.repr.align as u64;\n-                        align = align.max(\n-                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+                    if let Some(repr_align) = def.repr.align {\n+                        align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -755,13 +746,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n-\n-                        let field_align = if packed {\n-                            field.align.min(AbiAndPrefAlign::new(pack))\n-                        } else {\n-                            field.align\n-                        };\n-                        align = align.max(field_align);\n+                        align = align.max(field.align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -796,6 +781,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n+                    if let Some(pack) = def.repr.pack {\n+                        align = align.min(AbiAndPrefAlign::new(pack));\n+                    }\n+\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n@@ -1637,7 +1626,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.packed();\n+        let adt_packed = adt_def.repr.pack.is_some();\n \n         let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],"}, {"sha": "56505c04f0f0c5185df95fcdb6bb540178f5b827", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -33,6 +33,7 @@ use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_target::abi::Align;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n@@ -580,6 +581,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     }\n }\n \n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"Ty\")]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n@@ -2057,8 +2059,8 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n-    pub align: u32,\n-    pub pack: u32,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n@@ -2073,18 +2075,19 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-        let mut max_align = 0;\n-        let mut min_pack = 0;\n+        let mut max_align: Option<Align> = None;\n+        let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n-                        min_pack = if min_pack > 0 {\n-                            cmp::min(pack, min_pack)\n+                        let pack = Align::from_bytes(pack as u64).unwrap();\n+                        min_pack = Some(if let Some(min_pack) = min_pack {\n+                            min_pack.min(pack)\n                         } else {\n                             pack\n-                        };\n+                        });\n                         ReprFlags::empty()\n                     },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n@@ -2094,7 +2097,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     },\n                     attr::ReprAlign(align) => {\n-                        max_align = cmp::max(align, max_align);\n+                        max_align = max_align.max(Some(Align::from_bytes(align as u64).unwrap()));\n                         ReprFlags::empty()\n                     },\n                 });\n@@ -2113,7 +2116,7 @@ impl ReprOptions {\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.pack > 0 }\n+    pub fn packed(&self) -> bool { self.pack.is_some() }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -2133,8 +2136,12 @@ impl ReprOptions {\n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n-            self.int.is_some()\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n@@ -2588,12 +2595,12 @@ impl<'tcx> ClosureKind {\n \n     pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n+            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem, None),\n             ClosureKind::FnMut => {\n-                tcx.require_lang_item(FnMutTraitLangItem)\n+                tcx.require_lang_item(FnMutTraitLangItem, None)\n             }\n             ClosureKind::FnOnce => {\n-                tcx.require_lang_item(FnOnceTraitLangItem)\n+                tcx.require_lang_item(FnOnceTraitLangItem, None)\n             }\n         }\n     }"}, {"sha": "a72ecdb5745bbcfe8c884e43b00c714576b7a000", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -944,10 +944,16 @@ pub trait PrettyPrinter<'tcx>:\n                         .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active slice reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active `str` reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     p!(write(\"{:?}\", s));"}, {"sha": "674f8944f261a8fc218b727793d71b9b4fadabeb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -20,10 +20,10 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use std::mem;\n-use syntax::ast::NodeId;\n+use syntax::ast::{Ident, NodeId};\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -591,10 +591,11 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n-        // as long as incremental compilation does not kick in before that.\n+        // until we want incremental compilation to serialize Spans that we need\n+        // full hygiene information for.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n-            let span = location().fresh_expansion(expn_data);\n+        let recover_from_expn_data = |this: &Self, expn_data, transparency, pos| {\n+            let span = location().fresh_expansion_with_transparency(expn_data, transparency);\n             this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -603,9 +604,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 location()\n             }\n             TAG_EXPN_DATA_INLINE => {\n-                let expn_data = Decodable::decode(self)?;\n+                let (expn_data, transparency) = Decodable::decode(self)?;\n                 recover_from_expn_data(\n-                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n+                    self, expn_data, transparency, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n             TAG_EXPN_DATA_SHORTHAND => {\n@@ -614,9 +615,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_data =\n-                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n-                    recover_from_expn_data(self, expn_data, pos)\n+                    let (expn_data, transparency) =\n+                        self.with_position(pos.to_usize(), |this| Decodable::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, transparency, pos)\n                 }\n             }\n             _ => {\n@@ -626,6 +627,13 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n+        // FIXME: Handle hygiene in incremental\n+        bug!(\"Trying to decode Ident for incremental\");\n+    }\n+}\n+\n // This impl makes sure that we get a runtime error when we try decode a\n // DefIndex that is not contained in a DefId. Such a case would be problematic\n // because we would not know how to transform the DefIndex to the current\n@@ -819,20 +827,33 @@ where\n         if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            let (expn_id, transparency, expn_data) = span_data.ctxt.outer_mark_with_data();\n             if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n                 TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n                 TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n                 self.expn_data_shorthands.insert(expn_id, pos);\n-                expn_data.encode(self)\n+                (expn_data, transparency).encode(self)\n             }\n         }\n     }\n }\n \n+impl<'a, 'tcx, E> SpecializedEncoder<Ident> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n+{\n+    fn specialized_encode(&mut self, _: &Ident) -> Result<(), Self::Error> {\n+        // We don't currently encode enough information to ensure hygiene works\n+        // with incremental, so panic rather than risk incremental bugs.\n+\n+        // FIXME: Handle hygiene in incremental\n+        bug!(\"Trying to encode Ident for incremental\")\n+    }\n+}\n+\n impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + ty_codec::TyEncoder,"}, {"sha": "565447dd7e1afd7fc0fc63aff0b9e401383b70b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n+use crate::mir::interpret::{ConstValue, Scalar};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -551,26 +551,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n-            // FIXME(eddyb) get the right param_env.\n-            let param_env = ty::ParamEnv::empty();\n-            if !substs.has_local_value() {\n-                let instance = ty::Instance::resolve(\n-                    tcx.global_tcx(),\n-                    param_env,\n-                    def_id,\n-                    substs,\n-                );\n-                if let Some(instance) = instance {\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None,\n-                    };\n-                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n-                        return ct.val;\n-                    }\n-                }\n-            }\n+        if !x.val.has_local_value() {\n+            return x.eval(tcx, relation.param_env()).val;\n         }\n         x.val\n     };"}, {"sha": "ec7cf1a13c5964f81b47fa94aff9e807a12db82c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -748,6 +748,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            IntrinsicCast => IntrinsicCast,\n         })\n     }\n }\n@@ -1338,6 +1339,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n         (ty::error::TypeError::ConstMismatch)(x),\n+        (ty::error::TypeError::IntrinsicCast),\n     }\n }\n "}, {"sha": "d2edf6fb1ee808b44685400f5a0ab6586f970254", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -86,6 +86,7 @@ impl BoundRegion {\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable, Debug)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyKind\")]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -385,7 +386,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.sty),\n         }\n     }\n }\n@@ -2299,23 +2300,33 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty);\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.eval(tcx, param_env).val.try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    pub fn eval(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> &Const<'tcx> {\n+        // FIXME(const_generics): this doesn't work right now,\n+        // because it tries to relate an `Infer` to a `Param`.\n         match self.val {\n-            // FIXME(const_generics): this doesn't work right now,\n-            // because it tries to relate an `Infer` to a `Param`.\n             ConstValue::Unevaluated(did, substs) => {\n                 // if `substs` has no unresolved components, use and empty param_env\n                 let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n                 // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n+                    Some(instance) => instance,\n+                    None => return self,\n+                };\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                let evaluated = tcx.const_eval(param_env.and(gid)).ok()?;\n-                evaluated.val.try_to_bits(size)\n+                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n             },\n-            // otherwise just extract a `ConstValue`'s bits if possible\n-            _ => self.val.try_to_bits(size),\n+            _ => self,\n         }\n     }\n "}, {"sha": "7a77418050cdb5100e7cae724b0af7db311cfbd1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -998,7 +998,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1011,7 +1011,7 @@ fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1024,7 +1024,7 @@ fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,"}, {"sha": "d6de217f79c29c7086a8dc86d6140ddd1122dcef", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n-                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n             self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));"}, {"sha": "18d968fbddd9b6b319798a369251ec85bab2bce0", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,13 +1,13 @@\n use crate::{Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use crate::{Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n+use core::cmp::{self, Ordering};\n+use core::convert::TryFrom;\n+use core::fmt::{self, Write};\n+use core::marker::PhantomData;\n+use core::mem;\n+use core::ops::Neg;\n use smallvec::{SmallVec, smallvec};\n-use std::cmp::{self, Ordering};\n-use std::convert::TryFrom;\n-use std::fmt::{self, Write};\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::ops::Neg;\n \n #[must_use]\n pub struct IeeeFloat<S> {\n@@ -2287,8 +2287,8 @@ impl Loss {\n /// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n /// As a rule of thumb, no functions in this module should dynamically allocate.\n mod sig {\n-    use std::cmp::Ordering;\n-    use std::mem;\n+    use core::cmp::Ordering;\n+    use core::mem;\n     use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {"}, {"sha": "1190cea21acc3cf364b89018d7798462f9b7c4b2", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -31,15 +31,19 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![no_std]\n #![forbid(unsafe_code)]\n \n #![feature(nll)]\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n-use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n-use std::str::FromStr;\n+#[macro_use]\n+extern crate alloc;\n+\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use core::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use core::str::FromStr;\n \n bitflags::bitflags! {\n     /// IEEE-754R 7: Default exception handling.\n@@ -587,7 +591,7 @@ macro_rules! float_common_impls {\n             }\n         }\n \n-        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+        impl<$t> ::core::str::FromStr for $ty<$t> where Self: Float {\n             type Err = ParseError;\n             fn from_str(s: &str) -> Result<Self, ParseError> {\n                 Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n@@ -596,66 +600,66 @@ macro_rules! float_common_impls {\n \n         // Rounding ties to the nearest even, by default.\n \n-        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Add for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn add(self, rhs: Self) -> StatusAnd<Self> {\n                 self.add_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Sub for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn sub(self, rhs: Self) -> StatusAnd<Self> {\n                 self.sub_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Mul for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn mul(self, rhs: Self) -> StatusAnd<Self> {\n                 self.mul_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Div for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn div(self, rhs: Self) -> StatusAnd<Self> {\n                 self.div_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Rem for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn rem(self, rhs: Self) -> StatusAnd<Self> {\n                 self.c_fmod(rhs)\n             }\n         }\n \n-        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::AddAssign for $ty<$t> where Self: Float {\n             fn add_assign(&mut self, rhs: Self) {\n                 *self = (*self + rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::SubAssign for $ty<$t> where Self: Float {\n             fn sub_assign(&mut self, rhs: Self) {\n                 *self = (*self - rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::MulAssign for $ty<$t> where Self: Float {\n             fn mul_assign(&mut self, rhs: Self) {\n                 *self = (*self * rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::DivAssign for $ty<$t> where Self: Float {\n             fn div_assign(&mut self, rhs: Self) {\n                 *self = (*self / rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::RemAssign for $ty<$t> where Self: Float {\n             fn rem_assign(&mut self, rhs: Self) {\n                 *self = (*self % rhs).value;\n             }"}, {"sha": "8e2e390568e48261e5e0ea262dfd89a64ad07bc4", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,9 +1,9 @@\n use crate::{Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n use crate::ieee;\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::Neg;\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::Neg;\n \n #[must_use]\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]"}, {"sha": "3a4c8c924764eadcf2ad964e6ce0175446766555", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -186,8 +186,8 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n             index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        for arg in &body.arguments {\n-            formals.visit_pat(&arg.pat);\n+        for param in &body.params {\n+            formals.visit_pat(&param.pat);\n         }\n         impl<'a, 'v> Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {"}, {"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -183,14 +183,40 @@ pub(crate) fn prepare_thin(\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n+    // Sort out all our lists of incoming modules into two lists.\n+    //\n+    // * `serialized_modules` (also and argument to this function) contains all\n+    //   modules that are serialized in-memory.\n+    // * `in_memory` contains modules which are already parsed and in-memory,\n+    //   such as from multi-CGU builds.\n+    //\n+    // All of `cached_modules` (cached from previous incremental builds) can\n+    // immediately go onto the `serialized_modules` modules list and then we can\n+    // split the `modules` array into these two lists.\n+    let mut in_memory = Vec::new();\n+    serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+        info!(\"pushing cached module {:?}\", wp.cgu_name);\n+        (buffer, CString::new(wp.cgu_name).unwrap())\n+    }));\n+    for module in modules {\n+        match module {\n+            FatLTOInput::InMemory(m) => in_memory.push(m),\n+            FatLTOInput::Serialized { name, buffer } => {\n+                info!(\"pushing serialized module {:?}\", name);\n+                let buffer = SerializedModule::Local(buffer);\n+                serialized_modules.push((buffer, CString::new(name).unwrap()));\n+            }\n+        }\n+    }\n+\n     // Find the \"costliest\" module and merge everything into that codegen unit.\n     // All the other modules will be serialized and reparsed into the new\n     // context, so this hopefully avoids serializing and parsing the largest\n@@ -200,14 +226,8 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let costliest_module = modules.iter()\n+    let costliest_module = in_memory.iter()\n         .enumerate()\n-        .filter_map(|(i, module)| {\n-            match module {\n-                FatLTOInput::InMemory(m) => Some((i, m)),\n-                FatLTOInput::Serialized { .. } => None,\n-            }\n-        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n@@ -223,26 +243,14 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // re-executing the LTO passes. If that's the case deserialize the first\n     // module and create a linker with it.\n     let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n-        Some((_cost, i)) => {\n-            match modules.remove(i) {\n-                FatLTOInput::InMemory(m) => m,\n-                FatLTOInput::Serialized { .. } => unreachable!(),\n-            }\n-        }\n+        Some((_cost, i)) => in_memory.remove(i),\n         None => {\n-            let pos = modules.iter().position(|m| {\n-                match m {\n-                    FatLTOInput::InMemory(_) => false,\n-                    FatLTOInput::Serialized { .. } => true,\n-                }\n-            }).expect(\"must have at least one serialized module\");\n-            let (name, buffer) = match modules.remove(pos) {\n-                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n-                FatLTOInput::InMemory(_) => unreachable!(),\n-            };\n+            assert!(serialized_modules.len() > 0, \"must have at least one serialized module\");\n+            let (buffer, name) = serialized_modules.remove(0);\n+            info!(\"no in-memory regular modules to choose from, parsing {:?}\", name);\n             ModuleCodegen {\n-                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n-                name,\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, buffer.data(), diag_handler)?,\n+                name: name.into_string().unwrap(),\n                 kind: ModuleKind::Regular,\n             }\n         }\n@@ -265,25 +273,13 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        let mut new_modules = modules.into_iter().map(|module| {\n-            match module {\n-                FatLTOInput::InMemory(module) => {\n-                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-                    let llmod_id = CString::new(&module.name[..]).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-                FatLTOInput::Serialized { name, buffer } => {\n-                    let llmod_id = CString::new(name).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-            }\n-        }).collect::<Vec<_>>();\n+        for module in in_memory {\n+            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n         // Sort the modules to ensure we produce deterministic results.\n-        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n-        serialized_modules.extend(new_modules);\n-        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n-            (buffer, CString::new(wp.cgu_name).unwrap())\n-        }));\n+        serialized_modules.sort_by(|module1, module2| module1.1.cmp(&module2.1));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -850,7 +846,7 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n \n-fn parse_module<'a>(\n+pub fn parse_module<'a>(\n     cx: &'a llvm::Context,\n     name: &CStr,\n     data: &[u8],"}, {"sha": "958666cb8858a62fa1b71f6119e1fb58db2ea275", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -25,21 +25,31 @@ use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n use std::ffi::{CStr, CString};\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n-    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n+    for &(offset, ((), alloc_id)) in alloc.relocations().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n+            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // is within the bounds of the allocation, and it doesn't affect interpreter execution\n+            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n+            // some arbitrary byte value.\n+            //\n+            // FIXME: relay undef bytes to codegen as undef const bytes\n+            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n-            &alloc.bytes[offset..(offset + pointer_size)],\n+            // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n+            // affect interpreter execution (we inspect the result after interpreter execution),\n+            // and we properly interpret the relocation as a relocation pointer offset.\n+            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n@@ -51,8 +61,16 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         ));\n         next_offset = offset + pointer_size;\n     }\n-    if alloc.bytes.len() >= next_offset {\n-        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n+    if alloc.len() >= next_offset {\n+        let range = next_offset..alloc.len();\n+        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n+        // inspect the result after interpreter execution). Any undef byte is replaced with some\n+        // arbitrary byte value.\n+        //\n+        // FIXME: relay undef bytes to codegen as undef const bytes\n+        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        llvals.push(cx.const_bytes(bytes));\n     }\n \n     cx.const_struct(&llvals, true)\n@@ -437,7 +455,23 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.target.options.is_like_osx {\n-                    let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n+                    assert_eq!(alloc.relocations().len(), 0);\n+\n+                    let is_zeroed = {\n+                        // Treats undefined bytes as if they were defined with the byte value that\n+                        // happens to be currently assigned in mir. This is valid since reading\n+                        // undef bytes may yield arbitrary values.\n+                        //\n+                        // FIXME: ignore undef bytes even with representation `!= 0`.\n+                        //\n+                        // The `inspect` method is okay here because we checked relocations, and\n+                        // because we are doing this access to inspect the final interpreter state\n+                        // (not as part of the interpreter execution).\n+                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .iter()\n+                            .all(|b| *b == 0)\n+                    };\n+                    let sect_name = if is_zeroed {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n                     } else {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n@@ -456,10 +490,17 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                         section.as_str().as_ptr() as *const _,\n                         section.as_str().len() as c_uint,\n                     );\n+                    assert!(alloc.relocations().is_empty());\n+\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state (not\n+                    // as part of the interpreter execution).\n+                    let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(\n+                        0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n-                        alloc.bytes.as_ptr() as *const _,\n-                        alloc.bytes.len() as c_uint,\n+                        bytes.as_ptr() as *const _,\n+                        bytes.len() as c_uint,\n                     );\n                     let data = [section, alloc];\n                     let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);"}, {"sha": "928532a1f4760f60cf2db0c5b01566ce3ddf87d6", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -683,11 +683,13 @@ pub fn type_metadata(\n         }\n         ty::Closure(def_id, substs) => {\n             let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n+            let containing_scope = get_namespace_for_item(cx, def_id);\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+                                   usage_site_span,\n+                                   Some(containing_scope)).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n             let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n@@ -728,7 +730,8 @@ pub fn type_metadata(\n                                    t,\n                                    &tys,\n                                    unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+                                   usage_site_span,\n+                                   NO_SCOPE_METADATA).finalize(cx)\n         }\n         _ => {\n             bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n@@ -1205,14 +1208,15 @@ fn prepare_tuple_metadata(\n     component_types: &[Ty<'tcx>],\n     unique_type_id: UniqueTypeId,\n     span: Span,\n+    containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n     let struct_stub = create_struct_stub(cx,\n                                          tuple_type,\n                                          &tuple_name[..],\n                                          unique_type_id,\n-                                         NO_SCOPE_METADATA);\n+                                         containing_scope);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,"}, {"sha": "2fd78885bd01e8106b8ffb22d2cd468075dcad8d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -54,6 +54,7 @@ use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n+use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n@@ -386,13 +387,13 @@ impl ModuleLlvm {\n \n     fn parse(\n         cgcx: &CodegenContext<LlvmCodegenBackend>,\n-        name: &str,\n-        buffer: &back::lto::ModuleBuffer,\n+        name: &CStr,\n+        buffer: &[u8],\n         handler: &Handler,\n     ) -> Result<Self, FatalError> {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n             let tm = match (cgcx.tm_factory.0)() {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "de481d2262478630d74266e20b1e1342678d048e", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -430,10 +430,13 @@ impl<'a> Linker for GccLinker<'a> {\n             // Write an LD version script\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n-                writeln!(f, \"{{\\n  global:\")?;\n-                for sym in self.info.exports[&crate_type].iter() {\n-                    debug!(\"    {};\", sym);\n-                    writeln!(f, \"    {};\", sym)?;\n+                writeln!(f, \"{{\")?;\n+                if !self.info.exports[&crate_type].is_empty() {\n+                    writeln!(f, \"  global:\")?;\n+                    for sym in self.info.exports[&crate_type].iter() {\n+                        debug!(\"    {};\", sym);\n+                        writeln!(f, \"    {};\", sym)?;\n+                    }\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n             };"}, {"sha": "4acbe0356b47cb174cdbe581ce83071af9de4e86", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -456,7 +456,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         let arg_argv = param_argv;\n \n         let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem);\n+            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem, None);\n             let start_fn = callee::resolve_and_get_fn(\n                 cx,\n                 start_def_id,"}, {"sha": "9b5ad94ecd7cbbc145f9f31b8ab405752c7a98e4", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -190,11 +190,17 @@ pub fn push_debuginfo_type_name<'tcx>(\n             // processing\n             visited.remove(t);\n         },\n-        ty::Closure(..) => {\n-            output.push_str(\"closure\");\n+        ty::Closure(def_id, ..) => {\n+            output.push_str(&format!(\n+                \"closure-{}\",\n+                tcx.def_key(def_id).disambiguated_data.disambiguator\n+            ));\n         }\n-        ty::Generator(..) => {\n-            output.push_str(\"generator\");\n+        ty::Generator(def_id, ..) => {\n+            output.push_str(&format!(\n+                \"generator-{}\",\n+                tcx.def_key(def_id).disambiguated_data.disambiguator\n+            ));\n         }\n         ty::Error |\n         ty::Infer(_) |"}, {"sha": "d2a7571fde1e20336de06e51e2e982f7d3e8a0ba", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -609,17 +609,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         mir::Operand::Copy(\n                             Place {\n                                 base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted),\n+                                    kind: StaticKind::Promoted(promoted, _),\n                                     ty,\n+                                    def_id: _,\n                                 }),\n                                 projection: None,\n                             }\n                         ) |\n                         mir::Operand::Move(\n                             Place {\n                                 base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted),\n+                                    kind: StaticKind::Promoted(promoted, _),\n                                     ty,\n+                                    def_id: _,\n                                 }),\n                                 projection: None,\n                             }"}, {"sha": "ac72928a89677194376ca5af1ff377de00069545", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Instance, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n@@ -454,13 +454,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Static(box mir::Static {\n                     ty,\n-                    kind: mir::StaticKind::Promoted(promoted),\n+                    kind: mir::StaticKind::Promoted(promoted, substs),\n+                    def_id,\n                 }),\n                 projection: None,\n             } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n+                let instance = Instance::new(*def_id, self.monomorphize(substs));\n                 let cid = mir::interpret::GlobalId {\n-                    instance: self.instance,\n+                    instance: instance,\n                     promoted: Some(*promoted),\n                 };\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n@@ -487,7 +489,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Static(box mir::Static {\n                     ty,\n-                    kind: mir::StaticKind::Static(def_id),\n+                    kind: mir::StaticKind::Static,\n+                    def_id,\n                 }),\n                 projection: None,\n             } => {"}, {"sha": "ea771d9f20f8b69a60068870ba93060854736233", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -20,7 +20,6 @@ pub struct TinyList<T: PartialEq> {\n }\n \n impl<T: PartialEq> TinyList<T> {\n-\n     #[inline]\n     pub fn new() -> TinyList<T> {\n         TinyList {\n@@ -60,20 +59,24 @@ impl<T: PartialEq> TinyList<T> {\n \n     #[inline]\n     pub fn contains(&self, data: &T) -> bool {\n-        if let Some(ref head) = self.head {\n-            head.contains(data)\n-        } else {\n-            false\n+        let mut elem = self.head.as_ref();\n+        while let Some(ref e) = elem {\n+            if &e.data == data {\n+                return true;\n+            }\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        false\n     }\n \n     #[inline]\n     pub fn len(&self) -> usize {\n-        if let Some(ref head) = self.head {\n-            head.len()\n-        } else {\n-            0\n+        let (mut elem, mut count) = (self.head.as_ref(), 0);\n+        while let Some(ref e) = elem {\n+            count += 1;\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        count\n     }\n }\n \n@@ -84,40 +87,13 @@ struct Element<T: PartialEq> {\n }\n \n impl<T: PartialEq> Element<T> {\n-\n     fn remove_next(&mut self, data: &T) -> bool {\n-        let new_next = if let Some(ref mut next) = self.next {\n-            if next.data != *data {\n-                return next.remove_next(data)\n-            } else {\n-                next.next.take()\n-            }\n-        } else {\n-            return false\n+        let new_next = match self.next {\n+            Some(ref mut next) if next.data == *data => next.next.take(),\n+            Some(ref mut next) => return next.remove_next(data),\n+            None => return false,\n         };\n-\n         self.next = new_next;\n-\n         true\n     }\n-\n-    fn len(&self) -> usize {\n-        if let Some(ref next) = self.next {\n-            1 + next.len()\n-        } else {\n-            1\n-        }\n-    }\n-\n-    fn contains(&self, data: &T) -> bool {\n-        if self.data == *data {\n-            return true\n-        }\n-\n-        if let Some(ref next) = self.next {\n-            next.contains(data)\n-        } else {\n-            false\n-        }\n-    }\n }"}, {"sha": "0142631590cc9af411574dbf2ab8835b47852754", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n #[test]\n fn test_contains_and_insert() {\n@@ -98,36 +98,59 @@ fn test_remove_single() {\n #[bench]\n fn bench_insert_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new();\n+        let mut list = black_box(TinyList::new());\n         list.insert(1);\n+        list\n     })\n }\n \n #[bench]\n fn bench_insert_one(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new_single(0);\n+        let mut list = black_box(TinyList::new_single(0));\n         list.insert(1);\n+        list\n     })\n }\n \n+#[bench]\n+fn bench_contains_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new()).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_unknown(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(0)).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(1)).contains(&1)\n+    });\n+}\n+\n #[bench]\n fn bench_remove_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new().remove(&1)\n+        black_box(TinyList::new()).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_unknown(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(0).remove(&1)\n+        black_box(TinyList::new_single(0)).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_one(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(1).remove(&1)\n+        black_box(TinyList::new_single(1)).remove(&1)\n     });\n }"}, {"sha": "0906d358badd49dcbd940e5fc6e2f59ccd817756", "filename": "src/librustc_driver/args.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -0,0 +1,53 @@\n+use std::error;\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::str;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+static USED_ARGSFILE_FEATURE: AtomicBool = AtomicBool::new(false);\n+\n+pub fn used_unstable_argsfile() -> bool {\n+    USED_ARGSFILE_FEATURE.load(Ordering::Relaxed)\n+}\n+\n+pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n+    if arg.starts_with(\"@\") {\n+        let path = &arg[1..];\n+        let file = match fs::read_to_string(path) {\n+            Ok(file) => {\n+                USED_ARGSFILE_FEATURE.store(true, Ordering::Relaxed);\n+                file\n+            }\n+            Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {\n+                return Err(Error::Utf8Error(Some(path.to_string())));\n+            }\n+            Err(err) => return Err(Error::IOError(path.to_string(), err)),\n+        };\n+        Ok(file.lines().map(ToString::to_string).collect())\n+    } else {\n+        Ok(vec![arg])\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    Utf8Error(Option<String>),\n+    IOError(String, io::Error),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Error::Utf8Error(None) => write!(fmt, \"Utf8 error\"),\n+            Error::Utf8Error(Some(path)) => write!(fmt, \"Utf8 error in {}\", path),\n+            Error::IOError(path, err) => write!(fmt, \"IO Error: {}: {}\", path, err),\n+        }\n+    }\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &'static str {\n+        \"argument error\"\n+    }\n+}"}, {"sha": "9a6a12e261c10007f643edb53b85ea8d3e3c63e9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -68,6 +68,7 @@ use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n+mod args;\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n@@ -141,14 +142,22 @@ impl Callbacks for TimePassesCallbacks {\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler(\n-    args: &[String],\n+    at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n     emitter: Option<Box<dyn Write + Send>>\n ) -> interface::Result<()> {\n+    let mut args = Vec::new();\n+    for arg in at_args {\n+        match args::arg_expand(arg.clone()) {\n+            Ok(arg) => args.extend(arg),\n+            Err(err) => early_error(ErrorOutputType::default(),\n+                &format!(\"Failed to load argument file: {}\", err)),\n+        }\n+    }\n     let diagnostic_output = emitter.map(|emitter| DiagnosticOutput::Raw(emitter))\n                                    .unwrap_or(DiagnosticOutput::Default);\n-    let matches = match handle_options(args) {\n+    let matches = match handle_options(&args) {\n         Some(matches) => matches,\n         None => return Ok(()),\n     };\n@@ -430,6 +439,15 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n             } else {\n                 None\n             };\n+            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n+                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").\n+                            expect(\"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n+                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\");\n+                let line = isize::from_str_radix(&line, 10).\n+                            expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n+                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n+                return Some((Input::Str { name: file_name, input: src }, None, err));\n+            }\n             Some((Input::Str { name: FileName::anon_source_code(&src), input: src },\n                   None, err))\n         } else {\n@@ -779,13 +797,19 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    println!(\"{}\\nAdditional help:\n+    let at_path = if verbose && nightly_options::is_nightly_build() {\n+        \"    @path               Read newline separated options from `path`\\n\"\n+    } else {\n+        \"\"\n+    };\n+    println!(\"{options}{at_path}\\nAdditional help:\n     -C help             Print codegen options\n     -W help             \\\n-              Print 'lint' options and default settings{}{}\\n\",\n-             options.usage(message),\n-             nightly_help,\n-             verbose_help);\n+              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n+             options = options.usage(message),\n+             at_path = at_path,\n+             nightly = nightly_help,\n+             verbose = verbose_help);\n }\n \n fn print_wall_help() {\n@@ -1010,6 +1034,12 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     //   (unstable option being used on stable)\n     nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n \n+    // Late check to see if @file was used without unstable options enabled\n+    if crate::args::used_unstable_argsfile() && !nightly_options::is_unstable_enabled(&matches) {\n+        early_error(ErrorOutputType::default(),\n+            \"@path is unstable - use -Z unstable-options to enable its use\");\n+    }\n+\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n         usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));\n@@ -1135,11 +1165,13 @@ pub fn report_ices_to_stderr_if_any<F: FnOnce() -> R, R>(f: F) -> Result<R, Erro\n             // Thread panicked without emitting a fatal diagnostic\n             eprintln!(\"\");\n \n-            let emitter =\n-                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                None,\n-                                                                false,\n-                                                                false));\n+            let emitter = Box::new(errors::emitter::EmitterWriter::stderr(\n+                errors::ColorConfig::Auto,\n+                None,\n+                false,\n+                false,\n+                None,\n+            ));\n             let handler = errors::Handler::with_emitter(true, None, emitter);\n \n             // a .span_bug or .bug call has already printed what\n@@ -1190,7 +1222,7 @@ pub fn main() {\n     let result = report_ices_to_stderr_if_any(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n-                early_error(ErrorOutputType::default(),\n+                    early_error(ErrorOutputType::default(),\n                             &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n             }))\n             .collect::<Vec<_>>();"}, {"sha": "1541845bb55f62f5a39a577e34e053967bee8d53", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -18,3 +18,4 @@ unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.6.1\"\n+term_size = \"0.3.1\""}, {"sha": "3bed5d81dc514fcac7c3c96c16ff2e9d8c83ecd1", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -30,10 +30,8 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let primary_span = db.span.clone();\n         let children = db.children.clone();\n-        // FIXME(#59346): Collect suggestions (see emitter.rs)\n-        let suggestions: &[_] = &[];\n+        let (primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n "}, {"sha": "a298f9958f2d1258be61208a043e4dabe1fa644a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 403, "deletions": 101, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n-use std::cmp::{min, Reverse};\n+use std::cmp::{min, max, Reverse};\n use std::path::Path;\n use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter, Ansi};\n use termcolor::{WriteColor, Color, Buffer};\n@@ -51,9 +51,127 @@ impl HumanReadableErrorType {\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMapperDyn>>,\n         teach: bool,\n+        terminal_width: Option<usize>,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n-        EmitterWriter::new(dst, source_map, short, teach, color_config.suggests_using_colors())\n+        let color = color_config.suggests_using_colors();\n+        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width)\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+struct Margin {\n+    /// The available whitespace in the left that can be consumed when centering.\n+    pub whitespace_left: usize,\n+    /// The column of the beginning of left-most span.\n+    pub span_left: usize,\n+    /// The column of the end of right-most span.\n+    pub span_right: usize,\n+    /// The beginning of the line to be displayed.\n+    pub computed_left: usize,\n+    /// The end of the line to be displayed.\n+    pub computed_right: usize,\n+    /// The current width of the terminal. 140 by default and in tests.\n+    pub column_width: usize,\n+    /// The end column of a span label, including the span. Doesn't account for labels not in the\n+    /// same line as the span.\n+    pub label_right: usize,\n+}\n+\n+impl Margin {\n+    fn new(\n+        whitespace_left: usize,\n+        span_left: usize,\n+        span_right: usize,\n+        label_right: usize,\n+        column_width: usize,\n+        max_line_len: usize,\n+    ) -> Self {\n+        // The 6 is padding to give a bit of room for `...` when displaying:\n+        // ```\n+        // error: message\n+        //   --> file.rs:16:58\n+        //    |\n+        // 16 | ... fn foo(self) -> Self::Bar {\n+        //    |                     ^^^^^^^^^\n+        // ```\n+\n+        let mut m = Margin {\n+            whitespace_left: if whitespace_left >= 6 { whitespace_left - 6 } else { 0 },\n+            span_left: if span_left >= 6 { span_left - 6 } else { 0 },\n+            span_right: span_right + 6,\n+            computed_left: 0,\n+            computed_right: 0,\n+            column_width,\n+            label_right: label_right + 6,\n+        };\n+        m.compute(max_line_len);\n+        m\n+    }\n+\n+    fn was_cut_left(&self) -> bool {\n+        self.computed_left > 0\n+    }\n+\n+    fn was_cut_right(&self, line_len: usize) -> bool {\n+        let right = if self.computed_right == self.span_right ||\n+            self.computed_right == self.label_right\n+        {\n+            // Account for the \"...\" padding given above. Otherwise we end up with code lines that\n+            // do fit but end in \"...\" as if they were trimmed.\n+            self.computed_right - 6\n+        } else {\n+            self.computed_right\n+        };\n+        right < line_len && line_len > self.computed_left + self.column_width\n+    }\n+\n+    fn compute(&mut self, max_line_len: usize) {\n+        // When there's a lot of whitespace (>20), we want to trim it as it is useless.\n+        self.computed_left = if self.whitespace_left > 20 {\n+            self.whitespace_left - 16 // We want some padding.\n+        } else {\n+            0\n+        };\n+        // We want to show as much as possible, max_line_len is the right-most boundary for the\n+        // relevant code.\n+        self.computed_right = max(max_line_len, self.computed_left);\n+\n+        if self.computed_right - self.computed_left > self.column_width {\n+            // Trimming only whitespace isn't enough, let's get craftier.\n+            if self.label_right - self.whitespace_left <= self.column_width {\n+                // Attempt to fit the code window only trimming whitespace.\n+                self.computed_left = self.whitespace_left;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.label_right - self.span_left <= self.column_width {\n+                // Attempt to fit the code window considering only the spans and labels.\n+                let padding_left = (self.column_width - (self.label_right - self.span_left)) / 2;\n+                self.computed_left = self.span_left.saturating_sub(padding_left);\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.span_right - self.span_left <= self.column_width {\n+                // Attempt to fit the code window considering the spans and labels plus padding.\n+                let padding_left = (self.column_width - (self.span_right - self.span_left)) / 5 * 2;\n+                self.computed_left = self.span_left.saturating_sub(padding_left);\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else { // Mostly give up but still don't show the full line.\n+                self.computed_left = self.span_left;\n+                self.computed_right = self.span_right;\n+            }\n+        }\n+    }\n+\n+    fn left(&self, line_len: usize) -> usize {\n+        min(self.computed_left, line_len)\n+    }\n+\n+    fn right(&self, line_len: usize) -> usize {\n+        if max(line_len, self.computed_left) - self.computed_left <= self.column_width {\n+            line_len\n+        } else if self.computed_right > line_len {\n+            line_len\n+        } else {\n+            self.computed_right\n+        }\n     }\n }\n \n@@ -73,16 +191,25 @@ pub trait Emitter {\n     fn should_show_explain(&self) -> bool {\n         true\n     }\n-}\n \n-impl Emitter for EmitterWriter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    /// Formats the substitutions of the primary_span\n+    ///\n+    /// The are a lot of conditions to this method, but in short:\n+    ///\n+    /// * If the current `Diagnostic` has only one visible `CodeSuggestion`,\n+    ///   we format the `help` suggestion depending on the content of the\n+    ///   substitutions. In that case, we return the modified span only.\n+    ///\n+    /// * If the current `Diagnostic` has multiple suggestions,\n+    ///   we return the original `primary_span` and the original suggestions.\n+    fn primary_span_formatted<'a>(\n+        &mut self,\n+        db: &'a DiagnosticBuilder<'_>\n+    ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = db.span.clone();\n-        let mut children = db.children.clone();\n-        let mut suggestions: &[_] = &[];\n-\n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n             if rest.is_empty() &&\n+               // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n                sugg.substitutions.len() == 1 &&\n                // don't display multipart suggestions as labels\n@@ -98,21 +225,34 @@ impl Emitter for EmitterWriter {\n             {\n                 let substitution = &sugg.substitutions[0].parts[0].snippet.trim();\n                 let msg = if substitution.len() == 0 || sugg.style.hide_inline() {\n-                    // This substitution is only removal or we explicitly don't want to show the\n-                    // code inline, don't show it\n+                    // This substitution is only removal OR we explicitly don't want to show the\n+                    // code inline (`hide_inline`). Therefore, we don't show the substitution.\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n+                    // Show the default suggestion text with the substitution\n                     format!(\"help: {}: `{}`\", sugg.msg, substitution)\n                 };\n                 primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n+\n+                // We return only the modified primary_span\n+                (primary_span, &[])\n             } else {\n                 // if there are multiple suggestions, print them all in full\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                suggestions = &db.suggestions;\n+                (primary_span, &db.suggestions)\n             }\n+        } else {\n+            (primary_span, &db.suggestions)\n         }\n+    }\n+}\n+\n+impl Emitter for EmitterWriter {\n+    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         self.fix_multispans_in_std_macros(&mut primary_span,\n                                           &mut children,\n@@ -180,6 +320,7 @@ pub struct EmitterWriter {\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n+    terminal_width: Option<usize>,\n }\n \n #[derive(Debug)]\n@@ -190,18 +331,21 @@ pub struct FileWithAnnotatedLines {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig,\n-                  source_map: Option<Lrc<SourceMapperDyn>>,\n-                  short_message: bool,\n-                  teach: bool)\n-                  -> EmitterWriter {\n+    pub fn stderr(\n+        color_config: ColorConfig,\n+        source_map: Option<Lrc<SourceMapperDyn>>,\n+        short_message: bool,\n+        teach: bool,\n+        terminal_width: Option<usize>,\n+    ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n             dst,\n             sm: source_map,\n             short_message,\n             teach,\n             ui_testing: false,\n+            terminal_width,\n         }\n     }\n \n@@ -211,13 +355,15 @@ impl EmitterWriter {\n         short_message: bool,\n         teach: bool,\n         colored: bool,\n+        terminal_width: Option<usize>,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n             sm: source_map,\n             short_message,\n             teach,\n             ui_testing: false,\n+            terminal_width,\n         }\n     }\n \n@@ -234,12 +380,70 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn render_source_line(&self,\n-                          buffer: &mut StyledBuffer,\n-                          file: Lrc<SourceFile>,\n-                          line: &Line,\n-                          width_offset: usize,\n-                          code_offset: usize) -> Vec<(usize, Style)> {\n+    fn draw_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        source_string: &str,\n+        line_index: usize,\n+        line_offset: usize,\n+        width_offset: usize,\n+        code_offset: usize,\n+        margin: Margin,\n+    ) {\n+        let line_len = source_string.len();\n+        // Create the source line we will highlight.\n+        let left = margin.left(line_len);\n+        let right = margin.right(line_len);\n+        // On long lines, we strip the source line, accounting for unicode.\n+        let mut taken = 0;\n+        let code: String = source_string.chars().skip(left).take_while(|ch| {\n+            // Make sure that the trimming on the right will fall within the terminal width.\n+            // FIXME: `unicode_width` sometimes disagrees with terminals on how wide a `char` is.\n+            // For now, just accept that sometimes the code line will be longer than desired.\n+            let next = unicode_width::UnicodeWidthChar::width(*ch).unwrap_or(1);\n+            if taken + next > right - left {\n+                return false;\n+            }\n+            taken += next;\n+            true\n+        }).collect();\n+        buffer.puts(line_offset, code_offset, &code, Style::Quotation);\n+        if margin.was_cut_left() {\n+            // We have stripped some code/whitespace from the beginning, make it clear.\n+            buffer.puts(line_offset, code_offset, \"...\", Style::LineNumber);\n+        }\n+        if margin.was_cut_right(line_len) {\n+            // We have stripped some code after the right-most span end, make it clear we did so.\n+            buffer.puts(line_offset, code_offset + taken - 3, \"...\", Style::LineNumber);\n+        }\n+        buffer.puts(line_offset, 0, &self.maybe_anonymized(line_index), Style::LineNumber);\n+\n+        draw_col_separator(buffer, line_offset, width_offset - 2);\n+    }\n+\n+    fn render_source_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        file: Lrc<SourceFile>,\n+        line: &Line,\n+        width_offset: usize,\n+        code_offset: usize,\n+        margin: Margin,\n+    ) -> Vec<(usize, Style)> {\n+        // Draw:\n+        //\n+        //   LL | ... code ...\n+        //      |     ^^-^ span label\n+        //      |       |\n+        //      |       secondary span label\n+        //\n+        //   ^^ ^ ^^^ ^^^^ ^^^ we don't care about code too far to the right of a span, we trim it\n+        //   |  | |   |\n+        //   |  | |   actual code found in your source code and the spans we use to mark it\n+        //   |  | when there's too much wasted space to the left, trim it\n+        //   |  vertical divider between the column number and the code\n+        //   column number\n+\n         if line.line_index == 0 {\n             return Vec::new();\n         }\n@@ -251,14 +455,21 @@ impl EmitterWriter {\n \n         let line_offset = buffer.num_lines();\n \n-        // First create the source line we will highlight.\n-        buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n-        buffer.puts(line_offset,\n-                    0,\n-                    &self.maybe_anonymized(line.line_index),\n-                    Style::LineNumber);\n+        let left = margin.left(source_string.len()); // Left trim\n+        // Account for unicode characters of width !=0 that were removed.\n+        let left = source_string.chars().take(left).fold(0, |acc, ch| {\n+            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n+        });\n \n-        draw_col_separator(buffer, line_offset, width_offset - 2);\n+        self.draw_line(\n+            buffer,\n+            &source_string,\n+            line.line_index,\n+            line_offset,\n+            width_offset,\n+            code_offset,\n+            margin,\n+        );\n \n         // Special case when there's only one annotation involved, it is the start of a multiline\n         // span and there's no text at the beginning of the code line. Instead of doing the whole\n@@ -279,18 +490,13 @@ impl EmitterWriter {\n         if line.annotations.len() == 1 {\n             if let Some(ref ann) = line.annotations.get(0) {\n                 if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string.chars()\n-                                    .take(ann.start_col)\n-                                    .all(|c| c.is_whitespace()) {\n+                    if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n                         let style = if ann.is_primary {\n                             Style::UnderlinePrimary\n                         } else {\n                             Style::UnderlineSecondary\n                         };\n-                        buffer.putc(line_offset,\n-                                    width_offset + depth - 1,\n-                                    '/',\n-                                    style);\n+                        buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n                         return vec![(depth, style)];\n                     }\n                 }\n@@ -511,19 +717,23 @@ impl EmitterWriter {\n             match annotation.annotation_type {\n                 AnnotationType::MultilineStart(depth) |\n                 AnnotationType::MultilineEnd(depth) => {\n-                    draw_range(buffer,\n-                               '_',\n-                               line_offset + pos,\n-                               width_offset + depth,\n-                               code_offset + annotation.start_col,\n-                               style);\n+                    draw_range(\n+                        buffer,\n+                        '_',\n+                        line_offset + pos,\n+                        width_offset + depth,\n+                        code_offset + annotation.start_col - left,\n+                        style,\n+                    );\n                 }\n                 _ if self.teach => {\n-                    buffer.set_style_range(line_offset,\n-                                           code_offset + annotation.start_col,\n-                                           code_offset + annotation.end_col,\n-                                           style,\n-                                           annotation.is_primary);\n+                    buffer.set_style_range(\n+                        line_offset,\n+                        code_offset + annotation.start_col - left,\n+                        code_offset + annotation.end_col - left,\n+                        style,\n+                        annotation.is_primary,\n+                    );\n                 }\n                 _ => {}\n             }\n@@ -551,7 +761,7 @@ impl EmitterWriter {\n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n-                                code_offset + annotation.start_col,\n+                                code_offset + annotation.start_col - margin.computed_left,\n                                 '|',\n                                 style);\n                 }\n@@ -595,15 +805,20 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, annotation.end_col + 1)\n+                (pos + 1, if annotation.end_col + 1 > left {\n+                    annotation.end_col + 1 - left\n+                } else {\n+                    0\n+                })\n             } else {\n-                (pos + 2, annotation.start_col)\n+                (pos + 2, if annotation.start_col > left {\n+                    annotation.start_col - left\n+                } else {\n+                    0\n+                })\n             };\n             if let Some(ref label) = annotation.label {\n-                buffer.puts(line_offset + pos,\n-                            code_offset + col,\n-                            &label,\n-                            style);\n+                buffer.puts(line_offset + pos, code_offset + col, &label, style);\n             }\n         }\n \n@@ -638,10 +853,16 @@ impl EmitterWriter {\n                 ('-', Style::UnderlineSecondary)\n             };\n             for p in annotation.start_col..annotation.end_col {\n-                buffer.putc(line_offset + 1,\n-                            code_offset + p,\n-                            underline,\n-                            style);\n+                buffer.putc(\n+                    line_offset + 1,\n+                    if code_offset + p > left {\n+                        code_offset + p - left\n+                    } else {\n+                        0\n+                    },\n+                    underline,\n+                    style,\n+                );\n             }\n         }\n         annotations_position.iter().filter_map(|&(_, annotation)| {\n@@ -979,22 +1200,30 @@ impl EmitterWriter {\n                     let buffer_msg_line_offset = buffer.num_lines();\n \n                     buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n-                    buffer.append(buffer_msg_line_offset,\n-                                  &format!(\"{}:{}:{}\",\n-                                           loc.file.name,\n-                                           sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                           loc.col.0 + 1),\n-                                  Style::LineAndColumn);\n+                    buffer.append(\n+                        buffer_msg_line_offset,\n+                        &format!(\n+                            \"{}:{}:{}\",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                     for _ in 0..max_line_num_len {\n                         buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                     }\n                 } else {\n-                    buffer.prepend(0,\n-                                   &format!(\"{}:{}:{}: \",\n-                                            loc.file.name,\n-                                            sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                            loc.col.0 + 1),\n-                                   Style::LineAndColumn);\n+                    buffer.prepend(\n+                        0,\n+                        &format!(\n+                            \"{}:{}:{}: \",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                 }\n             } else if !self.short_message {\n                 // remember where we are in the output buffer for easy reference\n@@ -1037,22 +1266,96 @@ impl EmitterWriter {\n                 // Contains the vertical lines' positions for active multiline annotations\n                 let mut multilines = FxHashMap::default();\n \n+                // Get the left-side margin to remove it\n+                let mut whitespace_margin = std::usize::MAX;\n+                for line_idx in 0..annotated_file.lines.len() {\n+                    let file = annotated_file.file.clone();\n+                    let line = &annotated_file.lines[line_idx];\n+                    if let Some(source_string) = file.get_line(line.line_index - 1) {\n+                        let leading_whitespace = source_string\n+                            .chars()\n+                            .take_while(|c| c.is_whitespace())\n+                            .count();\n+                        if source_string.chars().any(|c| !c.is_whitespace()) {\n+                            whitespace_margin = min(\n+                                whitespace_margin,\n+                                leading_whitespace,\n+                            );\n+                        }\n+                    }\n+                }\n+                if whitespace_margin == std::usize::MAX {\n+                    whitespace_margin = 0;\n+                }\n+\n+                // Left-most column any visible span points at.\n+                let mut span_left_margin = std::usize::MAX;\n+                for line in &annotated_file.lines {\n+                    for ann in &line.annotations {\n+                        span_left_margin = min(span_left_margin, ann.start_col);\n+                        span_left_margin = min(span_left_margin, ann.end_col);\n+                    }\n+                }\n+                if span_left_margin == std::usize::MAX {\n+                    span_left_margin = 0;\n+                }\n+\n+                // Right-most column any visible span points at.\n+                let mut span_right_margin = 0;\n+                let mut label_right_margin = 0;\n+                let mut max_line_len = 0;\n+                for line in &annotated_file.lines {\n+                    max_line_len = max(max_line_len, annotated_file.file\n+                        .get_line(line.line_index - 1)\n+                        .map(|s| s.len())\n+                        .unwrap_or(0));\n+                    for ann in &line.annotations {\n+                        span_right_margin = max(span_right_margin, ann.start_col);\n+                        span_right_margin = max(span_right_margin, ann.end_col);\n+                        // FIXME: account for labels not in the same line\n+                        let label_right = ann.label.as_ref().map(|l| l.len() + 1).unwrap_or(0);\n+                        label_right_margin = max(label_right_margin, ann.end_col + label_right);\n+                    }\n+                }\n+\n+                let width_offset = 3 + max_line_num_len;\n+                let code_offset = if annotated_file.multiline_depth == 0 {\n+                    width_offset\n+                } else {\n+                    width_offset + annotated_file.multiline_depth + 1\n+                };\n+\n+                let column_width = if let Some(width) = self.terminal_width {\n+                    width.saturating_sub(code_offset)\n+                } else if self.ui_testing {\n+                    140\n+                } else {\n+                    term_size::dimensions()\n+                        .map(|(w, _)| w.saturating_sub(code_offset))\n+                        .unwrap_or(std::usize::MAX)\n+                };\n+\n+                let margin = Margin::new(\n+                    whitespace_margin,\n+                    span_left_margin,\n+                    span_right_margin,\n+                    label_right_margin,\n+                    column_width,\n+                    max_line_len,\n+                );\n+\n                 // Next, output the annotate source for this file\n                 for line_idx in 0..annotated_file.lines.len() {\n                     let previous_buffer_line = buffer.num_lines();\n \n-                    let width_offset = 3 + max_line_num_len;\n-                    let code_offset = if annotated_file.multiline_depth == 0 {\n-                        width_offset\n-                    } else {\n-                        width_offset + annotated_file.multiline_depth + 1\n-                    };\n-\n-                    let depths = self.render_source_line(&mut buffer,\n-                                                         annotated_file.file.clone(),\n-                                                         &annotated_file.lines[line_idx],\n-                                                         width_offset,\n-                                                         code_offset);\n+                    let depths = self.render_source_line(\n+                        &mut buffer,\n+                        annotated_file.file.clone(),\n+                        &annotated_file.lines[line_idx],\n+                        width_offset,\n+                        code_offset,\n+                        margin,\n+                    );\n \n                     let mut to_add = FxHashMap::default();\n \n@@ -1099,25 +1402,24 @@ impl EmitterWriter {\n \n                             let last_buffer_line_num = buffer.num_lines();\n \n-                            buffer.puts(last_buffer_line_num,\n-                                        0,\n-                                        &self.maybe_anonymized(annotated_file.lines[line_idx + 1]\n-                                                                             .line_index - 1),\n-                                        Style::LineNumber);\n-                            draw_col_separator(&mut buffer,\n-                                               last_buffer_line_num,\n-                                               1 + max_line_num_len);\n-                            buffer.puts(last_buffer_line_num,\n-                                        code_offset,\n-                                        &unannotated_line,\n-                                        Style::Quotation);\n+                            self.draw_line(\n+                                &mut buffer,\n+                                &unannotated_line,\n+                                annotated_file.lines[line_idx + 1].line_index - 1,\n+                                last_buffer_line_num,\n+                                width_offset,\n+                                code_offset,\n+                                margin,\n+                            );\n \n                             for (depth, style) in &multilines {\n-                                draw_multiline_line(&mut buffer,\n-                                                    last_buffer_line_num,\n-                                                    width_offset,\n-                                                    *depth,\n-                                                    *style);\n+                                draw_multiline_line(\n+                                    &mut buffer,\n+                                    last_buffer_line_num,\n+                                    width_offset,\n+                                    *depth,\n+                                    *style,\n+                                );\n                             }\n                         }\n                     }\n@@ -1207,7 +1509,7 @@ impl EmitterWriter {\n                         // ...or trailing spaces. Account for substitutions containing unicode\n                         // characters.\n                         let sub_len = part.snippet.trim().chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n                         });\n \n                         let underline_start = (span_start_pos + start) as isize + offset;\n@@ -1230,7 +1532,7 @@ impl EmitterWriter {\n \n                         // length of the code after substitution\n                         let full_sub_len = part.snippet.chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0) as isize\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1) as isize\n                         });\n \n                         // length of the code to be substituted"}, {"sha": "6585633e00af85dda299db9e58629f800d3d0970", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -383,7 +383,7 @@ impl Handler {\n                                       cm: Option<Lrc<SourceMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false, None));\n         Handler::with_emitter_and_flags(emitter, flags)\n     }\n "}, {"sha": "837aa9360c8953fcf8506987317740a987f486aa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -24,6 +24,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use syntax::symbol::{Symbol, sym};\n@@ -71,6 +72,7 @@ const BASE_IMPL: &[&str] = &[\n /// code, i.e., functions+methods\n const BASE_MIR: &[&str] = &[\n     label_strs::optimized_mir,\n+    label_strs::promoted_mir,\n     label_strs::mir_built,\n ];\n \n@@ -472,26 +474,39 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n+        let current_fingerprint = self.get_fingerprint(&dep_node);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n-        if Some(current_fingerprint) == prev_fingerprint {\n+        if current_fingerprint == prev_fingerprint {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx.sess.span_err(\n                 item_span,\n                 &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n+    fn get_fingerprint(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+        if self.tcx.dep_graph.dep_node_exists(dep_node) {\n+            let dep_node_index = self.tcx.dep_graph.dep_node_index_of(dep_node);\n+            Some(self.tcx.dep_graph.fingerprint_of(dep_node_index))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n+        let current_fingerprint = self.get_fingerprint(&dep_node);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n-        if Some(current_fingerprint) != prev_fingerprint {\n+        // if the node wasn't previously evaluated and now is (or vice versa),\n+        // then the node isn't actually clean or dirty.\n+        if (current_fingerprint == None) ^ (prev_fingerprint == None) {\n+            return;\n+        }\n+\n+        if current_fingerprint != prev_fingerprint {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx.sess.span_err(\n                 item_span,"}, {"sha": "24b44964e4fd22b08fa676c567883554322c0065", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -473,14 +473,25 @@ fn configure_and_expand_inner<'a>(\n         ast_validation::check_crate(sess, &krate)\n     });\n \n-    // If we're in rustdoc we're always compiling as an rlib, but that'll trip a\n-    // bunch of checks in the `modify` function below. For now just skip this\n-    // step entirely if we're rustdoc as it's not too useful anyway.\n-    if !sess.opts.actually_rustdoc {\n+\n+    let crate_types = sess.crate_types.borrow();\n+    let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n+\n+    // For backwards compatibility, we don't try to run proc macro injection\n+    // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n+    // specified. This should only affect users who manually invoke 'rustdoc', as\n+    // 'cargo doc' will automatically pass the proper '--crate-type' flags.\n+    // However, we do emit a warning, to let such users know that they should\n+    // start passing '--crate-type proc-macro'\n+    if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n+        let mut msg = sess.diagnostic().struct_warn(&\"Trying to document proc macro crate \\\n+            without passing '--crate-type proc-macro to rustdoc\");\n+\n+        msg.warn(\"The generated documentation may be incorrect\");\n+        msg.emit()\n+    } else {\n         krate = time(sess, \"maybe creating a macro crate\", || {\n-            let crate_types = sess.crate_types.borrow();\n             let num_crate_types = crate_types.len();\n-            let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n             let is_test_crate = sess.opts.test;\n             syntax_ext::proc_macro_harness::inject(\n                 &sess.parse_sess,"}, {"sha": "26e7b789f8f9047b73f4b8ba0de4a64c3a498960", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.id),\n                                       &v.attrs,\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             _ => return,\n         }\n \n-        let debug = match cx.tcx.lang_items().debug_trait() {\n+        let debug = match cx.tcx.get_diagnostic_item(sym::debug_trait) {\n             Some(debug) => debug,\n             None => return,\n         };"}, {"sha": "bb6119d0ff2aa0fbdb7eb701ebb148ea6d592456", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -146,7 +146,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant) {\n         self.check_case(cx, \"variant\", &v.ident);\n     }\n \n@@ -350,9 +350,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         &mut self,\n         cx: &LateContext<'_, '_>,\n         s: &hir::VariantData,\n-        _: ast::Name,\n-        _: &hir::Generics,\n-        _: hir::HirId,\n     ) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);"}, {"sha": "5bf4067431f24a6b73a8e08ee4c2df3895377021", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -95,11 +95,6 @@ pub struct CrateMetadata {\n     pub raw_proc_macros: Option<&'static [ProcMacro]>,\n }\n \n-pub struct FullProcMacro {\n-    pub name: ast::Name,\n-    pub ext: Lrc<SyntaxExtension>\n-}\n-\n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n@@ -109,7 +104,7 @@ pub struct CStore {\n \n pub enum LoadedMacro {\n     MacroDef(ast::Item),\n-    ProcMacro(Lrc<SyntaxExtension>),\n+    ProcMacro(SyntaxExtension),\n }\n \n impl CStore {"}, {"sha": "d6450f00c8b6a47ca66265365d2d425010d6830b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -30,11 +30,9 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n-use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -127,15 +125,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    optimized_mir => {\n-        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n-            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n-        });\n-\n-        let mir = tcx.arena.alloc(mir);\n-\n-        mir\n-    }\n+    optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n+    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n     mir_const_qualif => {\n         (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n     }\n@@ -157,7 +148,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n     // incremental recompilation ever enabled.\n-    fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+    fn_arg_names => { cdata.get_fn_param_names(def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n@@ -235,6 +226,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n     defined_lang_items => { cdata.get_lang_items(tcx) }\n+    diagnostic_items => { cdata.get_diagnostic_items(tcx) }\n     missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n     missing_extern_crate_item => {\n@@ -427,15 +419,7 @@ impl cstore::CStore {\n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if data.is_proc_macro_crate() {\n-            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n-        } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n-            let ext = SyntaxExtension {\n-                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n-                ..SyntaxExtension::default(kind, data.root.edition)\n-            };\n-            return LoadedMacro::ProcMacro(Lrc::new(ext));\n+            return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n \n         let def = data.get_macro(id.index);"}, {"sha": "75d7261704722bf6d9bb999df140d14eb10c6b24", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,8 +1,9 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use crate::schema::*;\n \n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n@@ -11,13 +12,14 @@ use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::mir::interpret::AllocDecodingSession;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::mir::Body;\n+use rustc::mir::{Body, Promoted};\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -449,11 +451,19 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n+\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.is_proc_macro_crate() &&\n             self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n+    fn entry_unless_proc_macro(&self, id: DefIndex) -> Option<Entry<'tcx>> {\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => Some(self.entry(id)),\n+        }\n+    }\n+\n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n@@ -511,35 +521,14 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(index).span.decode((self, sess))\n     }\n \n-\n-    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n-        if sess.opts.debugging_opts.dual_proc_macros {\n-            let host_lib = self.host_lib.as_ref().unwrap();\n-            self.load_proc_macro(\n-                &host_lib.metadata.get_root(),\n-                id,\n-                sess\n-            )\n-        } else {\n-            self.load_proc_macro(&self.root, id, sess)\n-        }\n-    }\n-\n-    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n-                        id: DefIndex,\n-                        sess: &Session)\n-                        -> FullProcMacro {\n-\n-        let raw_macro = self.raw_proc_macro(id);\n-        let (name, kind, helper_attrs) = match *raw_macro {\n+    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+        let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                        client, attrs: helper_attrs.clone()\n-                    })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n                     helper_attrs,\n                 )\n             }\n@@ -550,17 +539,21 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n+        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n+            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n+        } else {\n+            self.root.edition\n+        };\n \n-        let span = self.get_span(id, sess);\n-\n-        FullProcMacro {\n-            name: Symbol::intern(name),\n-            ext: Lrc::new(SyntaxExtension {\n-                span,\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            })\n-        }\n+        SyntaxExtension::new(\n+            &sess.parse_sess,\n+            kind,\n+            self.get_span(id, sess),\n+            helper_attrs,\n+            edition,\n+            Symbol::intern(name),\n+            &self.get_attributes(&self.entry(id), sess),\n+        )\n     }\n \n     pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n@@ -703,10 +696,8 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n-        }\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n@@ -767,6 +758,23 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    /// Iterates over the diagnostic items in the given crate.\n+    pub fn get_diagnostic_items(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx FxHashMap<Symbol, DefId> {\n+        tcx.arena.alloc(if self.is_proc_macro_crate() {\n+            // Proc macro crates do not export any diagnostic-items to the target.\n+            Default::default()\n+        } else {\n+            self.root\n+                .diagnostic_items\n+                .decode(self)\n+                .map(|(name, def_index)| (name, self.local_def_id(def_index)))\n+                .collect()\n+        })\n+    }\n+\n     /// Iterates over each child of the given item.\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n@@ -916,11 +924,24 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Option<Body<'tcx>> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n-        }\n+    pub fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n+            .unwrap_or_else(|| {\n+                bug!(\"get_optimized_mir: missing MIR for `{:?}\", self.local_def_id(id))\n+            })\n+    }\n+\n+    pub fn get_promoted_mir(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        id: DefIndex,\n+    ) -> IndexVec<Promoted, Body<'tcx>> {\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.promoted_mir.map(|promoted| promoted.decode((self, tcx))))\n+            .unwrap_or_else(|| {\n+                bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n+            })\n     }\n \n     pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n@@ -1138,14 +1159,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let arg_names = match self.entry(id).kind {\n+    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let param_names = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n-            EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n+            EntryKind::ForeignFn(data) => data.decode(self).param_names,\n+            EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        arg_names.decode(self).collect()\n+        param_names.decode(self).collect()\n     }\n \n     pub fn exported_symbols("}, {"sha": "db212408d8ebd5d29aad23e5edf5e753b3d132ee", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 37, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -8,6 +8,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId,\n use rustc::hir::GenericParamKind;\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n                                       metadata_symbol_name};\n@@ -32,7 +33,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, sym, Ident};\n+use syntax::symbol::{kw, sym, Ident, Symbol};\n use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -403,6 +404,11 @@ impl<'tcx> EncodeContext<'tcx> {\n         let lang_items_missing = self.encode_lang_items_missing();\n         let lang_item_bytes = self.position() - i;\n \n+        // Encode the diagnostic items.\n+        i = self.position();\n+        let diagnostic_items = self.encode_diagnostic_items();\n+        let diagnostic_item_bytes = self.position() - i;\n+\n         // Encode the native libraries used\n         i = self.position();\n         let native_libraries = self.encode_native_libraries();\n@@ -519,6 +525,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             dylib_dependency_formats,\n             lib_features,\n             lang_items,\n+            diagnostic_items,\n             lang_items_missing,\n             native_libraries,\n             foreign_modules,\n@@ -544,6 +551,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"             dep bytes: {}\", dep_bytes);\n             println!(\"     lib feature bytes: {}\", lib_feature_bytes);\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n+            println!(\" diagnostic item bytes: {}\", diagnostic_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         source_map bytes: {}\", source_map_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n@@ -623,6 +631,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -677,6 +686,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -713,7 +723,8 @@ impl EncodeContext<'tcx> {\n             predicates: None,\n             predicates_defined_on: None,\n \n-            mir: None\n+            mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -748,6 +759,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -808,6 +820,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -863,18 +876,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n-                    let arg_names = match *m {\n+                    let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n-                            self.encode_fn_arg_names(names)\n+                            self.encode_fn_param_names(names)\n                         }\n                         hir::TraitMethod::Provided(body) => {\n-                            self.encode_fn_arg_names_for_body(body)\n+                            self.encode_fn_param_names_for_body(body)\n                         }\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -923,6 +936,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -969,8 +983,8 @@ impl EncodeContext<'tcx> {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n                         constness: sig.header.constness,\n-                        arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names: self.encode_fn_param_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -1022,14 +1036,15 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n+            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n         }\n     }\n \n-    fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.arguments.iter().map(|arg| {\n+            self.lazy(body.params.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1038,7 +1053,7 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+    fn encode_fn_param_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n@@ -1052,6 +1067,19 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n+    fn encode_promoted_mir(\n+        &mut self,\n+        def_id: DefId,\n+    ) -> Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>> {\n+        debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n+        if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n+            let promoted = self.tcx.promoted_mir(def_id);\n+            Some(self.lazy(promoted))\n+        } else {\n+            None\n+        }\n+    }\n+\n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n@@ -1101,7 +1129,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n                     constness: header.constness,\n-                    arg_names: self.encode_fn_arg_names_for_body(body),\n+                    param_names: self.encode_fn_param_names_for_body(body),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n@@ -1202,6 +1230,20 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n+        let mir = match item.node {\n+            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n+            hir::ItemKind::Fn(_, header, ..) => {\n+                let generics = tcx.generics_of(def_id);\n+                let needs_inline =\n+                    (generics.requires_monomorphization(tcx) ||\n+                        tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        !self.metadata_output_only();\n+                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n+                needs_inline || header.constness == hir::Constness::Const || always_encode_mir\n+            }\n+            _ => false,\n+        };\n+\n         Entry {\n             kind,\n             visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n@@ -1301,29 +1343,8 @@ impl EncodeContext<'tcx> {\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n \n-            mir: match item.node {\n-                hir::ItemKind::Static(..) => {\n-                    self.encode_optimized_mir(def_id)\n-                }\n-                hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemKind::Fn(_, header, ..) => {\n-                    let generics = tcx.generics_of(def_id);\n-                    let needs_inline =\n-                        (generics.requires_monomorphization(tcx) ||\n-                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n-                            !self.metadata_output_only();\n-                    let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                    if needs_inline\n-                        || header.constness == hir::Constness::Const\n-                        || always_encode_mir\n-                    {\n-                        self.encode_optimized_mir(def_id)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n+            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n+            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n         }\n     }\n \n@@ -1350,6 +1371,7 @@ impl EncodeContext<'tcx> {\n             predicates: None,\n             predicates_defined_on: None,\n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -1376,6 +1398,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -1436,6 +1459,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -1464,6 +1488,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -1537,6 +1562,12 @@ impl EncodeContext<'tcx> {\n         self.lazy(lib_features.to_vec())\n     }\n \n+    fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n+        let tcx = self.tcx;\n+        let diagnostic_items = tcx.diagnostic_items(LOCAL_CRATE);\n+        self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n+    }\n+\n     fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n@@ -1645,7 +1676,7 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(names),\n+                    param_names: self.encode_fn_param_names(names),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n@@ -1675,6 +1706,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n }"}, {"sha": "1a5f0e17ba7ceebdd110b95321808718b9a6e004", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -11,6 +11,7 @@ use rustc::session::CrateDisambiguator;\n use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n \n use syntax::{ast, attr};\n@@ -175,6 +176,7 @@ pub struct CrateRoot<'tcx> {\n     pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n     pub lang_items: Lazy<[(DefIndex, usize)]>,\n     pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    pub diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n     pub native_libraries: Lazy<[NativeLibrary]>,\n     pub foreign_modules: Lazy<[ForeignModule]>,\n     pub source_map: Lazy<[syntax_pos::SourceFile]>,\n@@ -231,6 +233,7 @@ pub struct Entry<'tcx> {\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub mir: Option<Lazy<mir::Body<'tcx>>>,\n+    pub promoted_mir: Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n@@ -293,7 +296,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: Lazy<[ast::Name]>,\n+    pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}, {"sha": "251d4b727c7544b35427d1b81e5e3e8db6bfd809", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -159,7 +159,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(_),\n+                        kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n                 projection: None,\n@@ -169,7 +169,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static(def_id),\n+                        kind: StaticKind::Static,\n+                        def_id,\n                         ..\n                     }),\n                 projection: None,\n@@ -440,7 +441,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n         if let PlaceRef {\n             base: PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(def_id),\n+                kind: StaticKind::Static,\n+                def_id,\n                 ..\n             }),\n             projection: None,"}, {"sha": "8ded539e7205a60c33cfc9730e52dfc418fd6792", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::{\n     ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n     Static, StaticKind\n };\n-use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Field, Projection, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -22,6 +22,7 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use smallvec::SmallVec;\n \n use std::collections::BTreeMap;\n@@ -86,12 +87,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n-    let input_body = tcx.mir_validated(def_id);\n+    let (input_body, promoted) = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n-        do_mir_borrowck(&infcx, input_body, def_id)\n+        let promoted: &IndexVec<_, _> = &promoted.borrow();\n+        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -101,6 +103,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n+    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -147,7 +150,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n     let mut body: Body<'tcx> = input_body.clone();\n-    let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body);\n+    let mut promoted: IndexVec<Promoted, Body<'tcx>> = input_promoted.clone();\n+    let free_regions =\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n     let location_table = &LocationTable::new(body);\n \n@@ -184,6 +189,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         def_id,\n         free_regions,\n         body,\n+        &promoted,\n         &upvars,\n         location_table,\n         param_env,\n@@ -1462,13 +1468,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assert!(root_place.projection.is_none());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(_),\n+                kind: StaticKind::Promoted(..),\n                 ..\n             }) => {\n                 (true, false)\n             }\n             PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(_),\n+                kind: StaticKind::Static,\n                 ..\n             }) => {\n                 // Thread-locals might be dropped after the function exits, but\n@@ -2150,7 +2156,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(_),\n+                    kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n                 projection: None,\n@@ -2162,7 +2168,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Static(def_id),\n+                    kind: StaticKind::Static,\n+                    def_id,\n                     ..\n                 }),\n                 projection: None,"}, {"sha": "f10ff71b15e6810a41e48f3ddb38823de3ad4284", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -415,20 +415,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             \"{:?}\",\n             move_place.ty(self.body, self.infcx.tcx).ty,\n         );\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n-        let is_option = move_ty.starts_with(\"std::option::Option\");\n-        let is_result = move_ty.starts_with(\"std::result::Result\");\n-        if  is_option || is_result {\n-            err.span_suggestion(\n-                span,\n-                &format!(\"consider borrowing the `{}`'s content\", if is_option {\n-                    \"Option\"\n-                } else {\n-                    \"Result\"\n-                }),\n-                format!(\"{}.as_ref()\", snippet),\n-                Applicability::MaybeIncorrect,\n-            );\n+        if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+            let is_option = move_ty.starts_with(\"std::option::Option\");\n+            let is_result = move_ty.starts_with(\"std::result::Result\");\n+            if is_option || is_result {\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\"consider borrowing the `{}`'s content\", if is_option {\n+                        \"Option\"\n+                    } else {\n+                        \"Result\"\n+                    }),\n+                    format!(\"{}.as_ref()\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n         err\n     }\n@@ -439,19 +440,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n                 move_from,\n                 ..\n             } => {\n-                err.span_suggestion(\n-                    span,\n-                    \"consider borrowing here\",\n-                    format!(\"&{}\", snippet),\n-                    Applicability::Unspecified,\n-                );\n+                if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n@@ -517,27 +519,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 }))\n             ) = bind_to.is_user_variable {\n-                let pat_snippet = self.infcx.tcx.sess.source_map()\n-                    .span_to_snippet(pat_span)\n-                    .unwrap();\n-                if pat_snippet.starts_with('&') {\n-                    let pat_snippet = pat_snippet[1..].trim_start();\n-                    let suggestion;\n-                    let to_remove;\n-                    if pat_snippet.starts_with(\"mut\")\n-                        && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n-                    {\n-                        suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                        to_remove = \"&mut\";\n-                    } else {\n-                        suggestion = pat_snippet;\n-                        to_remove = \"&\";\n+                if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n+                {\n+                    if pat_snippet.starts_with('&') {\n+                        let pat_snippet = pat_snippet[1..].trim_start();\n+                        let suggestion;\n+                        let to_remove;\n+                        if pat_snippet.starts_with(\"mut\")\n+                            && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n+                        {\n+                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n+                            to_remove = \"&mut\";\n+                        } else {\n+                            suggestion = pat_snippet;\n+                            to_remove = \"&\";\n+                        }\n+                        suggestions.push((\n+                            pat_span,\n+                            to_remove,\n+                            suggestion.to_owned(),\n+                        ));\n                     }\n-                    suggestions.push((\n-                        pat_span,\n-                        to_remove,\n-                        suggestion.to_owned(),\n-                    ));\n                 }\n             }\n         }"}, {"sha": "5a5534922aa8a0bd2c5fd041c7d687dc601882b0", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(_),\n+                        kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n                 projection: None,\n@@ -158,7 +158,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static(def_id),\n+                        kind: StaticKind::Static,\n+                        def_id,\n                         ..\n                     }),\n                 projection: None,\n@@ -711,8 +712,8 @@ fn annotate_struct_field(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n     {"}, {"sha": "11ec154e5b5c13a769014998c101cc164a34f26d", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -11,8 +11,9 @@ use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Body};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Body, Promoted};\n use rustc::ty::{self, RegionKind, RegionVid};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n use std::fmt::Debug;\n use std::env;\n@@ -52,14 +53,15 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, body);\n+    renumber::renumber_mir(infcx, body, promoted);\n \n     let source = MirSource::item(def_id);\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n@@ -75,6 +77,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n+    promoted: &IndexVec<Promoted, Body<'tcx>>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -105,6 +108,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         infcx,\n         param_env,\n         body,\n+        promoted,\n         def_id,\n         &universal_regions,\n         location_table,"}, {"sha": "75a31628a54b6771bfbad90e5843132a23ea285b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<RegionName> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, *counter);\n-        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -695,7 +695,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *counter);\n-        let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n@@ -758,7 +758,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *counter);\n-        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "c479c38f30c7ea9dcfe23bad512e991804854266", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,16 +1,26 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Body};\n+use rustc::mir::{Location, Body, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn renumber_mir<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n+\n+    for body in promoted.iter_mut() {\n+        visitor.visit_body(body);\n+    }\n+\n     visitor.visit_body(body);\n }\n \n@@ -44,14 +54,6 @@ impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n-    fn visit_body(&mut self, body: &mut Body<'tcx>) {\n-        for promoted in body.promoted.iter_mut() {\n-            self.visit_body(promoted);\n-        }\n-\n-        self.super_body(body);\n-    }\n-\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "da1f64b05151bc310c9e9eaefe1a80a343666ee8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -112,6 +112,7 @@ pub(crate) fn type_check<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n+    promoted: &IndexVec<Promoted, Body<'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -157,6 +158,7 @@ pub(crate) fn type_check<'tcx>(\n         mir_def_id,\n         param_env,\n         body,\n+        promoted,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n@@ -180,6 +182,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &'a Body<'tcx>,\n+    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -197,7 +200,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body);\n+        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n         verifier.visit_body(body);\n         verifier.errors_reported\n     };\n@@ -254,6 +257,7 @@ enum FieldAccessError {\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n+    promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -380,9 +384,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, body: &'b Body<'tcx>) -> Self {\n+    fn new(\n+        cx: &'a mut TypeChecker<'b, 'tcx>,\n+        body: &'b Body<'tcx>,\n+        promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n+    ) -> Self {\n         TypeVerifier {\n             body,\n+            promoted,\n             mir_def_id: cx.mir_def_id,\n             cx,\n             last_span: body.span,\n@@ -416,7 +425,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             let mut place_ty = match place_base {\n                 PlaceBase::Local(index) =>\n                     PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-                PlaceBase::Static(box Static { kind, ty: sty }) => {\n+                PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n                     let sty = self.sanitize_type(place, sty);\n                     let check_err =\n                         |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n@@ -440,16 +449,16 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                             };\n                         };\n                     match kind {\n-                        StaticKind::Promoted(promoted) => {\n+                        StaticKind::Promoted(promoted, _) => {\n                             if !self.errors_reported {\n-                                let promoted_body = &self.body.promoted[*promoted];\n+                                let promoted_body = &self.promoted[*promoted];\n                                 self.sanitize_promoted(promoted_body, location);\n \n                                 let promoted_ty = promoted_body.return_ty();\n                                 check_err(self, place, promoted_ty, sty);\n                             }\n                         }\n-                        StaticKind::Static(def_id) => {\n+                        StaticKind::Static => {\n                             let ty = self.tcx().type_of(*def_id);\n                             let ty = self.cx.normalize(ty, location);\n \n@@ -466,7 +475,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     let is_promoted = match place {\n                         Place {\n                             base: PlaceBase::Static(box Static {\n-                                kind: StaticKind::Promoted(_),\n+                                kind: StaticKind::Promoted(..),\n                                 ..\n                             }),\n                             projection: None,"}, {"sha": "5caba637ccc4abf1b7473d32e478d0da0d69daca", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -46,9 +46,9 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         }\n                     }\n                 }\n-                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) =>\n+                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n                     false,\n-                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n                     tcx.is_mutable_static(*def_id)\n                 }\n             };"}, {"sha": "4f469174b392d04df81651befb6a542d0c45d507", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -329,11 +329,11 @@ fn place_base_conflict<'tcx>(\n         }\n         (PlaceBase::Static(s1), PlaceBase::Static(s2)) => {\n             match (&s1.kind, &s2.kind) {\n-                (StaticKind::Static(def_id_1), StaticKind::Static(def_id_2)) => {\n-                    if def_id_1 != def_id_2 {\n+                (StaticKind::Static, StaticKind::Static) => {\n+                    if s1.def_id != s2.def_id {\n                         debug!(\"place_element_conflict: DISJOINT-STATIC\");\n                         Overlap::Disjoint\n-                    } else if tcx.is_mutable_static(*def_id_1) {\n+                    } else if tcx.is_mutable_static(s1.def_id) {\n                         // We ignore mutable statics - they can only be unsafe code.\n                         debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n                         Overlap::Disjoint\n@@ -342,7 +342,7 @@ fn place_base_conflict<'tcx>(\n                         Overlap::EqualOrDisjoint\n                     }\n                 },\n-                (StaticKind::Promoted(promoted_1), StaticKind::Promoted(promoted_2)) => {\n+                (StaticKind::Promoted(promoted_1, _), StaticKind::Promoted(promoted_2, _)) => {\n                     if promoted_1 == promoted_2 {\n                         if let ty::Array(_, len) = s1.ty.sty {\n                             if let Some(0) = len.try_eval_usize(tcx, param_env) {"}, {"sha": "4c6be23de28be5746f0bfef3ae0fae88c26c2a43", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -136,7 +136,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                 }\n                 PrefixSet::All => {\n                     // all prefixes: just blindly enqueue the base\n-                    // of the projection\n+                    // of the projection.\n                     self.next = Some(PlaceRef {\n                         base: cursor.base,\n                         projection: &proj.base,"}, {"sha": "98cf4bba1c75fc68713441bd871dd0d88457804b", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -126,7 +126,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::StaticRef { id } => block.and(Place {\n                 base: PlaceBase::Static(Box::new(Static {\n                     ty: expr.ty,\n-                    kind: StaticKind::Static(id),\n+                    kind: StaticKind::Static,\n+                    def_id: id,\n                 })),\n                 projection: None,\n             }),"}, {"sha": "d5890d00ea80fb8384c8e5fd7803377eae9c557b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -443,7 +443,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };\n \n-        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n+        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem, None);\n         let method = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n         let bool_ty = self.hir.bool_ty();"}, {"sha": "7ab0bf7d66a64a7850f3a46e8db1b3f112b876ea", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -94,7 +94,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n             let body = tcx.hir().body(body_id);\n             let explicit_arguments =\n-                body.arguments\n+                body.params\n                     .iter()\n                     .enumerate()\n                     .map(|(index, arg)| {\n@@ -502,7 +502,7 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n     match unwind_attr {\n-        None => true,\n+        None => false, // FIXME(#58794)\n         Some(UnwindAttr::Allowed) => false,\n         Some(UnwindAttr::Aborts) => true,\n     }\n@@ -511,7 +511,7 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Arg>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Param>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,\n@@ -763,7 +763,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.basic_blocks,\n             self.source_scopes,\n             ClearCrossCrate::Set(self.source_scope_local_data),\n-            IndexVec::new(),\n             yield_ty,\n             self.local_decls,\n             self.canonical_user_type_annotations,"}, {"sha": "5aa487d9016635ef1cc290b3cbd08fe07543c868", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -49,17 +49,6 @@ pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n     InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), Default::default())\n }\n \n-pub(crate) fn eval_promoted<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cid: GlobalId<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = mk_eval_cx(tcx, span, param_env);\n-    eval_body_using_ecx(&mut ecx, cid, body, param_env)\n-}\n-\n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n@@ -360,7 +349,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n         }\n         // This is a const fn. Call it.\n-        Ok(Some(match ecx.load_mir(instance.def) {\n+        Ok(Some(match ecx.load_mir(instance.def, None) {\n             Ok(body) => body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n@@ -530,6 +519,9 @@ pub fn const_variant_index<'tcx>(\n     ecx.read_discriminant(op).unwrap().1\n }\n \n+/// Turn an interpreter error into something to report to the user.\n+/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+/// Should be called only if the error is actually going to to be reported!\n pub fn error_to_const_error<'mir, 'tcx>(\n     ecx: &InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     mut error: InterpErrorInfo<'tcx>,\n@@ -664,14 +656,8 @@ pub fn const_eval_raw_provider<'tcx>(\n         Default::default()\n     );\n \n-    let res = ecx.load_mir(cid.instance.def);\n-    res.map(|body| {\n-        if let Some(index) = cid.promoted {\n-            &body.promoted[index]\n-        } else {\n-            body\n-        }\n-    }).and_then(\n+    let res = ecx.load_mir(cid.instance.def, cid.promoted);\n+    res.and_then(\n         |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n     ).and_then(|place| {\n         Ok(RawConst {"}, {"sha": "2ea6c4ae10fdc8f84682950a38f8ae232b8896fd", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -269,10 +269,6 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n         debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n         match stmt.kind {\n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n-                // Make sure there are no remaining borrows for variables\n-                // that are assigned over.\n-                self.kill_borrows_on_place(trans, lhs);\n-\n                 if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n@@ -287,6 +283,10 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n \n                     trans.gen(*index);\n                 }\n+\n+                // Make sure there are no remaining borrows for variables\n+                // that are assigned over.\n+                self.kill_borrows_on_place(trans, lhs);\n             }\n \n             mir::StatementKind::StorageDead(local) => {"}, {"sha": "e5a19572170a7053856a8e5e04e2cc113cefbc22", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -240,7 +240,7 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place_ref: PlaceRef<'cx, 'tcx>) -> LookupResult {\n+    pub fn find(&self, place_ref: PlaceRef<'_, '_>) -> LookupResult {\n         place_ref.iterate(|place_base, place_projection| {\n             let mut result = match place_base {\n                 PlaceBase::Local(local) => self.locals[*local],"}, {"sha": "5352888006c30318676f95501be485d7926b57f4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -91,9 +91,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n \n-        for arg in &body.arguments {\n-            self.check_irrefutable(&arg.pat, \"function argument\");\n-            self.check_patterns(false, slice::from_ref(&arg.pat));\n+        for param in &body.params {\n+            self.check_irrefutable(&param.pat, \"function argument\");\n+            self.check_patterns(false, slice::from_ref(&param.pat));\n         }\n     }\n }"}, {"sha": "054b65f0e1a9edc0c8ba0da1a17b391bf895b396", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -294,6 +294,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n+        promoted: Option<mir::Promoted>,\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n@@ -303,7 +304,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         {\n             throw_inval!(TypeckError)\n         }\n-        trace!(\"load mir {:?}\", instance);\n+        trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n+        if let Some(promoted) = promoted {\n+            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n+        }\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n@@ -438,27 +442,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Issue #27023: must add any necessary padding to `size`\n                 // (to make it a multiple of `align`) before returning it.\n-                //\n-                // Namely, the returned size should be, in C notation:\n-                //\n-                //   `size + ((size & (align-1)) ? align : 0)`\n-                //\n-                // emulated via the semi-standard fast bit trick:\n-                //\n-                //   `(size + (align-1)) & -align`\n-\n-                Ok(Some((size.align_to(align), align)))\n+                let size = size.align_to(align);\n+\n+                // Check if this brought us over the size limit.\n+                if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n+                    throw_ub_format!(\"wide pointer metadata contains invalid information: \\\n+                        total size is bigger than largest supported object\");\n+                }\n+                Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n                 let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n-                // the second entry in the vtable is the dynamic size of the object.\n+                // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n                 let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n                 let elem = layout.field(self, 0)?;\n-                Ok(Some((elem.size * len, elem.align.abi)))\n+\n+                // Make sure the slice is not too big.\n+                let size = elem.size.checked_mul(len, &*self.tcx)\n+                    .ok_or_else(|| err_ub_format!(\"invalid slice: \\\n+                        total size is bigger than largest supported object\"))?;\n+                Ok(Some((size, elem.align.abi)))\n             }\n \n             ty::Foreign(_) => {"}, {"sha": "4cbbc0ffe17cc4262462a27d977307710f0b64a1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -94,7 +94,7 @@ impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n         alloc.mutability = mutability;\n         // link the alloc id to the actual allocation\n         let alloc = tcx.intern_const_alloc(alloc);\n-        self.leftover_relocations.extend(alloc.relocations.iter().map(|&(_, ((), reloc))| reloc));\n+        self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n         tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n         Ok(None)\n     }\n@@ -316,7 +316,7 @@ pub fn intern_const_alloc_recursive(\n             // So we hand-roll the interning logic here again\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, ((), reloc)) in alloc.relocations.iter() {\n+            for &(_, ((), reloc)) in alloc.relocations().iter() {\n                 if leftover_relocations.insert(reloc) {\n                     todo.push(reloc);\n                 }"}, {"sha": "0f2305e03ff33e74d4ff24a7aad639fb28662a1d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -81,7 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let alloc = alloc_type_name(self.tcx.tcx, substs.type_at(0));\n                 let name_id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 let id_ptr = self.memory.tag_static_base_pointer(name_id.into());\n-                let alloc_len = alloc.bytes.len() as u64;\n+                let alloc_len = alloc.size.bytes();\n                 let name_val = Immediate::new_slice(Scalar::Ptr(id_ptr), alloc_len, self);\n                 self.write_immediate(name_val, dest)?;\n             }\n@@ -95,7 +95,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | \"bitreverse\" => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => throw_unsup!(TypeNotPrimitive(ty)),\n@@ -149,7 +150,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // term since the sign of the second term can be inferred from this and\n                         // the fact that the operation has overflowed (if either is 0 no\n                         // overflow can occur)\n-                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                        let first_term: u128 = self.force_bits(l.to_scalar()?, l.layout.size)?;\n                         let first_term_positive = first_term & (1 << (num_bits-1)) == 0;\n                         if first_term_positive {\n                             // Negative overflow not possible since the positive first term\n@@ -187,7 +188,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n+                    let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n                     throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                 }\n                 self.write_scalar(val, dest)?;\n@@ -196,8 +197,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val_bits = self.read_scalar(args[0])?.to_bits(layout.size)?;\n-                let raw_shift_bits = self.read_scalar(args[1])?.to_bits(layout.size)?;\n+                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val_bits = self.force_bits(val, layout.size)?;\n+                let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n+                let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = layout.size.bits() as u128;\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;"}, {"sha": "032d16a49db4baa3d0f181e85c96292bbefa4f3c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -221,7 +221,7 @@ pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx>\n         val: ConstValue::Slice {\n             data: alloc,\n             start: 0,\n-            end: alloc.bytes.len(),\n+            end: alloc.len(),\n         },\n         ty: tcx.mk_static_str(),\n     })"}, {"sha": "62b1760508b4cd0d00bcb4214a5e5fa3b813e2ca", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 94, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -210,7 +210,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind);\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n+            None => self.get(ptr.alloc_id)?.size,\n         };\n         self.copy(\n             ptr,\n@@ -271,20 +271,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             ))\n         }\n         if let Some((size, align)) = old_size_and_align {\n-            if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n-                let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n+            if size != alloc.size || align != alloc.align {\n+                let bytes = alloc.size;\n                 throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n             }\n         }\n \n         // Let the machine take some extra action\n-        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        let size = alloc.size;\n         AllocationExtra::memory_deallocated(&mut alloc, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n             ptr.alloc_id,\n-            (Size::from_bytes(alloc.bytes.len() as u64), alloc.align)\n+            (alloc.size, alloc.align)\n         );\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n@@ -555,7 +555,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n-            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+            return Ok((alloc.size, alloc.align));\n         }\n \n         // # Function pointers\n@@ -583,7 +583,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(alloc)) =>\n                 // Need to duplicate the logic here, because the global allocations have\n                 // different associated types than the interpreter-local ones.\n-                Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+                Ok((alloc.size, alloc.align)),\n             Some(GlobalAlloc::Function(_)) =>\n                 bug!(\"We already checked function pointers above\"),\n             // The rest must be dead.\n@@ -645,17 +645,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let prefix_len = msg.len();\n         let mut relocations = vec![];\n \n-        for i in 0..(alloc.bytes.len() as u64) {\n+        for i in 0..alloc.size.bytes() {\n             let i = Size::from_bytes(i);\n-            if let Some(&(_, target_id)) = alloc.relocations.get(&i) {\n+            if let Some(&(_, target_id)) = alloc.relocations().get(&i) {\n                 if allocs_seen.insert(target_id) {\n                     allocs_to_print.push_back(target_id);\n                 }\n                 relocations.push((i, target_id));\n             }\n-            if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n+            if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n+                let i = i.bytes() as usize;\n+\n+                // Checked definedness (and thus range) and relocations. This access also doesn't\n+                // influence interpreter execution but is only for debugging.\n+                let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(i..i+1);\n+                write!(msg, \"{:02x} \", bytes[0]).unwrap();\n             } else {\n                 msg.push_str(\"__ \");\n             }\n@@ -664,7 +669,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\n             \"{}({} bytes, alignment {}){}\",\n             msg,\n-            alloc.bytes.len(),\n+            alloc.size.bytes(),\n             alloc.align.bytes(),\n             extra\n         );\n@@ -803,32 +808,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = {\n-            let relocations = self.get(src.alloc_id)?.relocations(self, src, size);\n-            if relocations.is_empty() {\n-                // nothing to copy, ignore even the `length` loop\n-                Vec::new()\n-            } else {\n-                let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n-                for i in 0..length {\n-                    new_relocations.extend(\n-                        relocations\n-                        .iter()\n-                        .map(|&(offset, reloc)| {\n-                            // compute offset for current repetition\n-                            let dest_offset = dest.offset + (i * size);\n-                            (\n-                                // shift offsets from source allocation to destination allocation\n-                                offset + dest_offset - src.offset,\n-                                reloc,\n-                            )\n-                        })\n-                    );\n-                }\n-\n-                new_relocations\n-            }\n-        };\n+        let relocations = self.get(src.alloc_id)?\n+            .prepare_relocation_copy(self, src, size, dest, length);\n \n         let tcx = self.tcx.tcx;\n \n@@ -875,7 +856,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n         // copy the relocations to the destination\n-        self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n+        self.get_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n \n         Ok(())\n     }\n@@ -894,65 +875,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let undef_mask = &self.get(src.alloc_id)?.undef_mask;\n-\n-        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n-        // the source and write it to the destination. Even if we optimized the memory accesses,\n-        // we'd be doing all of this `repeat` times.\n-        // Therefor we precompute a compressed version of the undef mask of the source value and\n-        // then write it back `repeat` times without computing any more information from the source.\n-\n-        // a precomputed cache for ranges of defined/undefined bits\n-        // 0000010010001110 will become\n-        // [5, 1, 2, 1, 3, 3, 1]\n-        // where each element toggles the state\n-        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let first = undef_mask.get(src.offset);\n-        let mut cur_len = 1;\n-        let mut cur = first;\n-        for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n-            if undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n-                cur_len += 1;\n-            } else {\n-                ranges.push(cur_len);\n-                cur_len = 1;\n-                cur = !cur;\n-            }\n-        }\n+        let src_alloc = self.get(src.alloc_id)?;\n+        let compressed = src_alloc.compress_undef_range(src, size);\n \n         // now fill in all the data\n         let dest_allocation = self.get_mut(dest.alloc_id)?;\n-        // an optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n-        if ranges.is_empty() {\n-            dest_allocation.undef_mask.set_range_inbounds(\n-                dest.offset,\n-                dest.offset + size * repeat,\n-                first,\n-            );\n-            return Ok(())\n-        }\n+        dest_allocation.mark_compressed_undef_range(&compressed, dest, size, repeat);\n \n-        // remember to fill in the trailing bits\n-        ranges.push(cur_len);\n-\n-        for mut j in 0..repeat {\n-            j *= size.bytes();\n-            j += dest.offset.bytes();\n-            let mut cur = first;\n-            for range in &ranges {\n-                let old_j = j;\n-                j += range;\n-                dest_allocation.undef_mask.set_range_inbounds(\n-                    Size::from_bytes(old_j),\n-                    Size::from_bytes(j),\n-                    cur,\n-                );\n-                cur = !cur;\n-            }\n-        }\n         Ok(())\n     }\n "}, {"sha": "b5aab992e3adb6f4e84750ea34987cd38bcdef3a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -629,11 +629,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // post-process\n         Ok(match *discr_kind {\n             layout::DiscriminantKind::Tag => {\n-                let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n-                    Ok(raw_discr) => raw_discr,\n-                    Err(_) =>\n-                        throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n-                };\n+                let bits_discr = raw_discr\n+                    .not_undef()\n+                    .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n+                    .map_err(|_| err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant"}, {"sha": "23c9e7fdf67ce7c692f62723408c1200e68f887f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -585,19 +585,19 @@ where\n         use rustc::mir::StaticKind;\n \n         Ok(match place_static.kind {\n-            StaticKind::Promoted(promoted) => {\n+            StaticKind::Promoted(promoted, _) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted),\n                 })?\n             }\n \n-            StaticKind::Static(def_id) => {\n+            StaticKind::Static => {\n                 let ty = place_static.ty;\n                 assert!(!ty.needs_subst());\n                 let layout = self.layout_of(ty)?;\n-                let instance = ty::Instance::mono(*self.tcx, def_id);\n+                let instance = ty::Instance::mono(*self.tcx, place_static.def_id);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None"}, {"sha": "2cac8bb0c517e49b99a8a20390689f4e61266dd2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::interpret::{\n };\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::{Align, Size};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -276,6 +276,7 @@ struct AllocationSnapshot<'a> {\n     relocations: Relocations<(), AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n     align: &'a Align,\n+    size: &'a Size,\n     mutability: &'a Mutability,\n }\n \n@@ -285,12 +286,28 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     type Item = AllocationSnapshot<'a>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { bytes, relocations, undef_mask, align, mutability, extra: () } = self;\n+        let Allocation {\n+            size,\n+            align,\n+            mutability,\n+            extra: (),\n+            ..\n+        } = self;\n+\n+        let all_bytes = 0..self.len();\n+        // This 'inspect' is okay since following access respects undef and relocations. This does\n+        // influence interpreter exeuction, but only to detect the error of cycles in evalution\n+        // dependencies.\n+        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n+\n+        let undef_mask = self.undef_mask();\n+        let relocations = self.relocations();\n \n         AllocationSnapshot {\n             bytes,\n             undef_mask,\n             align,\n+            size,\n             mutability,\n             relocations: relocations.snapshot(ctx),\n         }"}, {"sha": "10b767ebba191174fa663f9192a8f9c980641646", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty, Instance, TypeFoldable};\n-use rustc::ty::layout::{Size, Align, LayoutOf};\n+use rustc::ty::layout::{Size, Align, LayoutOf, HasDataLayout};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n use super::{InterpCx, Machine, MemoryKind, FnVal};\n@@ -144,11 +144,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size, self)?\n-        )?.to_bits(pointer_size)? as u64;\n+        )?.not_undef()?;\n+        let size = self.force_bits(size, pointer_size)? as u64;\n         let align = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size * 2, self)?,\n-        )?.to_bits(pointer_size)? as u64;\n+        )?.not_undef()?;\n+        let align = self.force_bits(align, pointer_size)? as u64;\n+\n+        if size >= self.tcx.data_layout().obj_size_bound() {\n+            throw_ub_format!(\"invalid vtable: \\\n+                size is bigger than largest supported object\");\n+        }\n         Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n     }\n }"}, {"sha": "3e14ba3efcc584d51267ef462e4dc7f29b37ec3a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 60, "deletions": 35, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,3 +1,9 @@\n+//! Check the validity invariant of a given value, and tell the user\n+//! where in the value it got violated.\n+//! In const context, this goes even further and tries to approximate const safety.\n+//! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n+//! to be const-safe.\n+\n use std::fmt::Write;\n use std::ops::RangeInclusive;\n \n@@ -11,7 +17,7 @@ use std::hash::Hash;\n \n use super::{\n     GlobalAlloc, InterpResult,\n-    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n+    Scalar, OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! throw_validation_failure {\n@@ -250,6 +256,47 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         self.path.truncate(path_len);\n         Ok(())\n     }\n+\n+    fn check_wide_ptr_meta(\n+        &mut self,\n+        meta: Option<Scalar<M::PointerTag>>,\n+        pointee: TyLayout<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n+        match tail.sty {\n+            ty::Dynamic(..) => {\n+                let vtable = meta.unwrap();\n+                try_validation!(\n+                    self.ecx.memory.check_ptr_access(\n+                        vtable,\n+                        3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n+                        self.ecx.tcx.data_layout.pointer_align.abi,\n+                    ),\n+                    \"dangling or unaligned vtable pointer in wide pointer or too small vtable\",\n+                    self.path\n+                );\n+                try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n+                    \"invalid drop fn in vtable\", self.path);\n+                try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n+                    \"invalid size or align in vtable\", self.path);\n+                // FIXME: More checks for the vtable.\n+            }\n+            ty::Slice(..) | ty::Str => {\n+                let _len = try_validation!(meta.unwrap().to_usize(self.ecx),\n+                    \"non-integer slice length in wide pointer\", self.path);\n+                // We do not check that `len * elem_size <= isize::MAX`:\n+                // that is only required for references, and there it falls out of the\n+                // \"dereferencable\" check performed by Stacked Borrows.\n+            }\n+            ty::Foreign(..) => {\n+                // Unsized, but not wide.\n+            }\n+            _ =>\n+                bug!(\"Unexpected unsized type tail: {:?}\", tail),\n+        }\n+\n+        Ok(())\n+    }\n }\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n@@ -341,56 +388,34 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n+                // Check pointer part.\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: For consistency with integers, we do not\n                     // accept undef.\n                     let _ptr = try_validation!(value.to_scalar_ptr(),\n                         \"undefined address in raw pointer\", self.path);\n-                    let _meta = try_validation!(value.to_meta(),\n-                        \"uninitialized data in raw fat pointer metadata\", self.path);\n                 } else {\n                     // Remain consistent with `usize`: Accept anything.\n                 }\n+\n+                // Check metadata.\n+                let meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in wide pointer metadata\", self.path);\n+                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    self.check_wide_ptr_meta(meta, layout)?;\n+                }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n-                // Handle fat pointers.\n+                // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n                 let ptr = try_validation!(value.to_scalar_ptr(),\n                     \"undefined address in pointer\", self.path);\n                 let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", self.path);\n+                    \"uninitialized data in wide pointer metadata\", self.path);\n                 let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(layout.ty,\n-                                                                          self.ecx.param_env);\n-                    match tail.sty {\n-                        ty::Dynamic(..) => {\n-                            let vtable = meta.unwrap();\n-                            try_validation!(\n-                                self.ecx.memory.check_ptr_access(\n-                                    vtable,\n-                                    3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                                    self.ecx.tcx.data_layout.pointer_align.abi,\n-                                ),\n-                                \"dangling or unaligned vtable pointer or too small vtable\",\n-                                self.path\n-                            );\n-                            try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n-                                \"invalid drop fn in vtable\", self.path);\n-                            try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n-                                \"invalid size or align in vtable\", self.path);\n-                            // FIXME: More checks for the vtable.\n-                        }\n-                        ty::Slice(..) | ty::Str => {\n-                            try_validation!(meta.unwrap().to_usize(self.ecx),\n-                                \"non-integer slice length in fat pointer\", self.path);\n-                        }\n-                        ty::Foreign(..) => {\n-                            // Unsized, but not fat.\n-                        }\n-                        _ =>\n-                            bug!(\"Unexpected unsized type tail: {:?}\", tail),\n-                    }\n+                    self.check_wide_ptr_meta(meta, layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n                 let (size, align) = self.ecx.size_and_align_of(meta, layout)?"}, {"sha": "1f7efebfda819950f2f54deb3400400e8d212f36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -180,12 +180,12 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind, Instance};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, Location, PlaceBase, Promoted, Static, StaticKind};\n+use rustc::mir::{self, Location, PlaceBase, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         _context: mir::visit::PlaceContext,\n                         location: Location) {\n         match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. }) => {\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n                 debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n \n                 let tcx = self.tcx;\n@@ -670,8 +670,24 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     self.output.push(MonoItem::Static(*def_id));\n                 }\n             }\n-            PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => {\n-                // FIXME: should we handle promoteds here instead of eagerly in collect_neighbours?\n+            PlaceBase::Static(box Static {\n+                kind: StaticKind::Promoted(promoted, substs),\n+                def_id,\n+                ..\n+            }) => {\n+                let param_env = ty::ParamEnv::reveal_all();\n+                let cid = GlobalId {\n+                    instance: Instance::new(*def_id, substs.subst(self.tcx, self.param_substs)),\n+                    promoted: Some(*promoted),\n+                };\n+                match self.tcx.const_eval(param_env.and(cid)) {\n+                    Ok(val) => collect_const(self.tcx, val, substs, self.output),\n+                    Err(ErrorHandled::Reported) => {},\n+                    Err(ErrorHandled::TooGeneric) => {\n+                        let span = self.tcx.promoted_mir(*def_id)[*promoted].span;\n+                        span_bug!(span, \"collection encountered polymorphic constant\")\n+                    },\n+                }\n             }\n             PlaceBase::Local(_) => {\n                 // Locals have no relevance for collector\n@@ -1202,7 +1218,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n         }\n         Some(GlobalAlloc::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &((), inner) in alloc.relocations.values() {\n+            for &((), inner) in alloc.relocations().values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n@@ -1222,6 +1238,7 @@ fn collect_neighbours<'tcx>(\n     instance: Instance<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n+    debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n \n     MirNeighborCollector {\n@@ -1230,22 +1247,6 @@ fn collect_neighbours<'tcx>(\n         output,\n         param_substs: instance.substs,\n     }.visit_body(&body);\n-    let param_env = ty::ParamEnv::reveal_all();\n-    for i in 0..body.promoted.len() {\n-        use rustc_data_structures::indexed_vec::Idx;\n-        let i = Promoted::new(i);\n-        let cid = GlobalId {\n-            instance,\n-            promoted: Some(i),\n-        };\n-        match tcx.const_eval(param_env.and(cid)) {\n-            Ok(val) => collect_const(tcx, val, instance.substs, output),\n-            Err(ErrorHandled::Reported) => {},\n-            Err(ErrorHandled::TooGeneric) => span_bug!(\n-                body.promoted[i].span, \"collection encountered polymorphic constant\",\n-            ),\n-        }\n-    }\n }\n \n fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n@@ -1268,7 +1269,7 @@ fn collect_const<'tcx>(\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n         ConstValue::ByRef { alloc, .. } => {\n-            for &((), id) in alloc.relocations.values() {\n+            for &((), id) in alloc.relocations().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "aa83255bf62f45a541ceb239173041a17a43b8c3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -112,7 +112,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n     };\n     debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n \n-    run_passes(tcx, &mut result, instance, MirPhase::Const, &[\n+    run_passes(tcx, &mut result, instance, None, MirPhase::Const, &[\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n         &no_landing_pads::NoLandingPads,\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n@@ -201,7 +201,6 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        IndexVec::new(),\n         None,\n         local_decls_for_sig(&sig, span),\n         IndexVec::new(),\n@@ -369,7 +368,6 @@ impl CloneShimBuilder<'tcx> {\n                 SourceScopeData { span: self.span, parent_scope: None }, 1\n             ),\n             ClearCrossCrate::Clear,\n-            IndexVec::new(),\n             None,\n             self.local_decls,\n             IndexVec::new(),\n@@ -813,7 +811,6 @@ fn build_call_shim<'tcx>(\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        IndexVec::new(),\n         None,\n         local_decls,\n         IndexVec::new(),\n@@ -900,7 +897,6 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        IndexVec::new(),\n         None,\n         local_decls,\n         IndexVec::new(),"}, {"sha": "15ecc6c37920b5c87f6eee616ed3540001326505", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -30,8 +30,8 @@ pub use self::AddCallGuards::*;\n  *\n  */\n \n-impl MirPass for AddCallGuards {\n-    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for AddCallGuards {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "052631ddff37125df0e6429759b32effbb1c1d4b", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -39,8 +39,8 @@ use crate::util;\n \n pub struct AddMovesForPackedDrops;\n \n-impl MirPass for AddMovesForPackedDrops {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }"}, {"sha": "0fd75cd57b2ac31856938a2707fa59b1274ea986", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -65,8 +65,8 @@ fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-impl MirPass for AddRetag {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for AddRetag {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "539922c54d12d9530b49e755f2d6d93bf34266ce", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -205,10 +205,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 PlaceBase::Local(..) => {\n                     // Locals are safe.\n                 }\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => {\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n                     bug!(\"unsafety checking should happen before promotion\")\n                 }\n-                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. }) => {\n+                PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n                     if self.tcx.is_mutable_static(*def_id) {\n                         self.require_unsafe(\"use of mutable static\",\n                             \"mutable statics can be mutated by multiple threads: aliasing \\"}, {"sha": "ede1cb62f9451475583c390ec82bf5aea48014fd", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -26,8 +26,8 @@ pub struct CleanupNonCodegenStatements;\n \n pub struct DeleteNonCodegenStatements;\n \n-impl MirPass for CleanupNonCodegenStatements {\n-    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;\n         delete.visit_body(body);\n     }"}, {"sha": "f261fdc268b5b3da6d262427a0ff4d2610dd903f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n     Local, NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n     TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n-    SourceScope, SourceScopeLocalData, LocalDecl, Promoted,\n+    SourceScope, SourceScopeLocalData, LocalDecl,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -27,14 +27,14 @@ use crate::interpret::{\n     ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n-    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n+    CompileTimeInterpreter, error_to_const_error, mk_eval_cx,\n };\n use crate::transform::{MirPass, MirSource};\n \n pub struct ConstProp;\n \n-impl MirPass for ConstProp {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for ConstProp {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -64,17 +64,12 @@ impl MirPass for ConstProp {\n             &mut body.source_scope_local_data,\n             ClearCrossCrate::Clear\n         );\n-        let promoted = std::mem::replace(\n-            &mut body.promoted,\n-            IndexVec::new()\n-        );\n \n         let dummy_body =\n             &Body::new(\n                 body.basic_blocks().clone(),\n                 Default::default(),\n                 ClearCrossCrate::Clear,\n-                Default::default(),\n                 None,\n                 body.local_decls.clone(),\n                 Default::default(),\n@@ -92,22 +87,17 @@ impl MirPass for ConstProp {\n             body,\n             dummy_body,\n             source_scope_local_data,\n-            promoted,\n             tcx,\n             source\n         );\n         optimization_finder.visit_body(body);\n \n         // put back the data we stole from `mir`\n-        let (source_scope_local_data, promoted) = optimization_finder.release_stolen_data();\n+        let source_scope_local_data = optimization_finder.release_stolen_data();\n         std::mem::replace(\n             &mut body.source_scope_local_data,\n             source_scope_local_data\n         );\n-        std::mem::replace(\n-            &mut body.promoted,\n-            promoted\n-        );\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n@@ -124,7 +114,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n-    promoted: IndexVec<Promoted, Body<'tcx>>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -155,7 +144,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         body: &Body<'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        promoted: IndexVec<Promoted, Body<'tcx>>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n@@ -184,17 +172,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n-            promoted,\n         }\n     }\n \n-    fn release_stolen_data(\n-        self,\n-    ) -> (\n-        ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        IndexVec<Promoted, Body<'tcx>>,\n-    ) {\n-        (self.source_scope_local_data, self.promoted)\n+    fn release_stolen_data(self) -> ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>> {\n+        self.source_scope_local_data\n     }\n \n     fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n@@ -255,9 +237,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                let diagnostic = error_to_const_error(&self.ecx, error);\n                 use rustc::mir::interpret::InterpError::*;\n-                match diagnostic.error {\n+                match error.kind {\n                     Exit(_) => bug!(\"the CTFE program cannot exit\"),\n                     Unsupported(_)\n                     | UndefinedBehavior(_)\n@@ -266,6 +247,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         // Ignore these errors.\n                     }\n                     Panic(_) => {\n+                        let diagnostic = error_to_const_error(&self.ecx, error);\n                         diagnostic.report_as_lint(\n                             self.ecx.tcx,\n                             \"this expression will panic at runtime\",\n@@ -303,7 +285,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         place.iterate(|place_base, place_projection| {\n             let mut eval = match place_base {\n                 PlaceBase::Local(loc) => self.get_const(*loc).clone()?,\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..}) => {\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n                     let generics = self.tcx.generics_of(self.source.def_id());\n                     if generics.requires_monomorphization(self.tcx) {\n                         // FIXME: can't handle code with generics\n@@ -315,11 +297,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         instance,\n                         promoted: Some(*promoted),\n                     };\n-                    // cannot use `const_eval` here, because that would require having the MIR\n-                    // for the current function available, but we're producing said MIR right now\n                     let res = self.use_ecx(source_info, |this| {\n-                        let body = &this.promoted[*promoted];\n-                        eval_promoted(this.tcx, cid, body, this.param_env)\n+                        this.ecx.const_eval_raw(cid)\n                     })?;\n                     trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n                     res.into()"}, {"sha": "f3a523a813413e8abfe31a651fa965dc11e7a16a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -29,8 +29,8 @@ use crate::util::def_use::DefUseAnalysis;\n \n pub struct CopyPropagation;\n \n-impl MirPass for CopyPropagation {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for CopyPropagation {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "1fc7ce09aa647db7a2d2229f3956578a79ba5794", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -5,8 +5,8 @@ use crate::util::expand_aggregate;\n \n pub struct Deaggregator;\n \n-impl MirPass for Deaggregator {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for Deaggregator {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "ed0eff943a165d86408dbf4d3295a8bec690dad7", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -13,12 +13,12 @@ use crate::util as mir_util;\n \n pub struct Marker(pub &'static str);\n \n-impl MirPass for Marker {\n+impl<'tcx> MirPass<'tcx> for Marker {\n     fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n     }\n }\n "}, {"sha": "7a5c00c85962946cec88c94dbbf4312af32be100", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -20,8 +20,8 @@ use syntax_pos::Span;\n \n pub struct ElaborateDrops;\n \n-impl MirPass for ElaborateDrops {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();"}, {"sha": "21ca339eb968bdfb6f644a14011725a021daee75", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -49,8 +49,8 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n \n pub struct EraseRegions;\n \n-impl MirPass for EraseRegions {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for EraseRegions {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "d87331195dd2402ef380075a4a0ae7e1aaae8058", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1115,8 +1115,8 @@ where\n     }).collect()\n }\n \n-impl MirPass for StateTransform {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for StateTransform {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "f31303c642faa1ec34523b5ae3b87a6bb5645428", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -37,8 +37,8 @@ struct CallSite<'tcx> {\n     location: SourceInfo,\n }\n \n-impl MirPass for Inline {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for Inline {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n@@ -394,7 +394,6 @@ impl Inliner<'tcx> {\n \n                 let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n-                let mut promoted_map = IndexVec::with_capacity(callee_body.promoted.len());\n \n                 for mut scope in callee_body.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n@@ -420,10 +419,6 @@ impl Inliner<'tcx> {\n                     local_map.push(idx);\n                 }\n \n-                promoted_map.extend(\n-                    callee_body.promoted.iter().cloned().map(|p| caller_body.promoted.push(p))\n-                );\n-\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -484,12 +479,10 @@ impl Inliner<'tcx> {\n                     args: &args,\n                     local_map,\n                     scope_map,\n-                    promoted_map,\n-                    _callsite: callsite,\n                     destination: dest,\n                     return_block,\n                     cleanup_block: cleanup,\n-                    in_cleanup_block: false\n+                    in_cleanup_block: false,\n                 };\n \n \n@@ -644,8 +637,6 @@ struct Integrator<'a, 'tcx> {\n     args: &'a [Local],\n     local_map: IndexVec<Local, Local>,\n     scope_map: IndexVec<SourceScope, SourceScope>,\n-    promoted_map: IndexVec<Promoted, Promoted>,\n-    _callsite: CallSite<'tcx>,\n     destination: Place<'tcx>,\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n@@ -698,17 +689,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(promoted),\n-                    ..\n-                }),\n-                projection: None,\n-            } => {\n-                if let Some(p) = self.promoted_map.get(*promoted).cloned() {\n-                    *promoted = p;\n-                }\n-            },\n             _ => self.super_place(place, _ctxt, _location)\n         }\n     }"}, {"sha": "abe41606e80794a76ce3de1375ae218d2b37ff96", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -11,8 +11,8 @@ use crate::transform::{MirPass, MirSource};\n \n pub struct InstCombine;\n \n-impl MirPass for InstCombine {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for InstCombine {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return"}, {"sha": "ac291c2996d065afc7140d92dc366141a8b59cf8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 76, "deletions": 60, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -137,68 +137,58 @@ pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n /// A streamlined trait that you can implement to create a pass; the\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n-pub trait MirPass {\n+pub trait MirPass<'tcx> {\n     fn name(&self) -> Cow<'_, str> {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n+    promoted: Option<Promoted>,\n     mir_phase: MirPhase,\n-    passes: &[&dyn MirPass],\n+    passes: &[&dyn MirPass<'tcx>],\n ) {\n     let phase_index = mir_phase.phase_index();\n \n-    let run_passes = |body: &mut Body<'tcx>, promoted| {\n-        if body.phase >= mir_phase {\n-            return;\n-        }\n+    if body.phase >= mir_phase {\n+        return;\n+    }\n \n-        let source = MirSource {\n-            instance,\n-            promoted,\n-        };\n-        let mut index = 0;\n-        let mut run_pass = |pass: &dyn MirPass| {\n-            let run_hooks = |body: &_, index, is_after| {\n-                dump_mir::on_mir_pass(tcx, &format_args!(\"{:03}-{:03}\", phase_index, index),\n-                                      &pass.name(), source, body, is_after);\n-            };\n-            run_hooks(body, index, false);\n-            pass.run_pass(tcx, source, body);\n-            run_hooks(body, index, true);\n-\n-            index += 1;\n+    let source = MirSource {\n+        instance,\n+        promoted,\n+    };\n+    let mut index = 0;\n+    let mut run_pass = |pass: &dyn MirPass<'tcx>| {\n+        let run_hooks = |body: &_, index, is_after| {\n+            dump_mir::on_mir_pass(tcx, &format_args!(\"{:03}-{:03}\", phase_index, index),\n+                                    &pass.name(), source, body, is_after);\n         };\n+        run_hooks(body, index, false);\n+        pass.run_pass(tcx, source, body);\n+        run_hooks(body, index, true);\n \n-        for pass in passes {\n-            run_pass(*pass);\n-        }\n-\n-        body.phase = mir_phase;\n+        index += 1;\n     };\n \n-    run_passes(body, None);\n-\n-    for (index, promoted_body) in body.promoted.iter_enumerated_mut() {\n-        run_passes(promoted_body, Some(index));\n-\n-        //Let's make sure we don't miss any nested instances\n-        assert!(promoted_body.promoted.is_empty())\n+    for pass in passes {\n+        run_pass(*pass);\n     }\n+\n+    body.phase = mir_phase;\n }\n \n fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n     let mut body = tcx.mir_built(def_id).steal();\n-    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Const, &[\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n@@ -207,7 +197,10 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     tcx.alloc_steal_mir(body)\n }\n \n-fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_validated(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -216,33 +209,23 @@ fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     }\n \n     let mut body = tcx.mir_const(def_id).steal();\n-    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Validated, &[\n+    let qualify_and_promote_pass = qualify_consts::QualifyAndPromoteConstants::default();\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_consts::QualifyAndPromoteConstants,\n+        &qualify_and_promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n-    tcx.alloc_steal_mir(body)\n+    let promoted = qualify_and_promote_pass.promoted.into_inner();\n+    (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n-fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n-    if tcx.is_constructor(def_id) {\n-        // There's no reason to run all of the MIR passes on constructors when\n-        // we can just output the MIR we want directly. This also saves const\n-        // qualification and borrow checking the trouble of special casing\n-        // constructors.\n-        return shim::build_adt_ctor(tcx, def_id);\n-    }\n-\n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    tcx.ensure().mir_borrowck(def_id);\n-\n-    if tcx.use_ast_borrowck() {\n-        tcx.ensure().borrowck(def_id);\n-    }\n-\n-    let mut body = tcx.mir_validated(def_id).steal();\n-    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Optimized, &[\n+fn run_optimization_passes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    def_id: DefId,\n+    promoted: Option<Promoted>,\n+) {\n+    run_passes(tcx, body, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads,\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n@@ -293,10 +276,43 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n         &add_call_guards::CriticalCallEdges,\n         &dump_mir::Marker(\"PreCodegen\"),\n     ]);\n+}\n+\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n+    if tcx.is_constructor(def_id) {\n+        // There's no reason to run all of the MIR passes on constructors when\n+        // we can just output the MIR we want directly. This also saves const\n+        // qualification and borrow checking the trouble of special casing\n+        // constructors.\n+        return shim::build_adt_ctor(tcx, def_id);\n+    }\n+\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    tcx.ensure().mir_borrowck(def_id);\n+\n+    if tcx.use_ast_borrowck() {\n+        tcx.ensure().borrowck(def_id);\n+    }\n+\n+    let (body, _) = tcx.mir_validated(def_id);\n+    let mut body = body.steal();\n+    run_optimization_passes(tcx, &mut body, def_id, None);\n     tcx.arena.alloc(body)\n }\n \n fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n-    let body = tcx.optimized_mir(def_id);\n-    &body.promoted\n+    if tcx.is_constructor(def_id) {\n+        return tcx.intern_promoted(IndexVec::new());\n+    }\n+\n+    tcx.ensure().mir_borrowck(def_id);\n+    let (_, promoted) = tcx.mir_validated(def_id);\n+    let mut promoted = promoted.steal();\n+\n+    for (p, mut body) in promoted.iter_enumerated_mut() {\n+        run_optimization_passes(tcx, &mut body, def_id, Some(p));\n+    }\n+\n+    tcx.intern_promoted(promoted)\n }"}, {"sha": "762bb5d44839f096c06ee216889d3310bec56ed0", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -8,8 +8,8 @@ use crate::transform::{MirPass, MirSource};\n \n pub struct NoLandingPads;\n \n-impl MirPass for NoLandingPads {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for NoLandingPads {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }"}, {"sha": "cdccdfea3994342dddcf72a66e65c04688c250e2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -12,9 +12,11 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n+use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n+use rustc::ty::subst::InternalSubsts;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n@@ -293,17 +295,28 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         new_temp\n     }\n \n-    fn promote_candidate(mut self, candidate: Candidate) {\n+    fn promote_candidate(\n+        mut self,\n+        def_id: DefId,\n+        candidate: Candidate,\n+        next_promoted_id: usize,\n+    ) -> Option<Body<'tcx>> {\n         let mut operand = {\n             let promoted = &mut self.promoted;\n-            let promoted_id = Promoted::new(self.source.promoted.len());\n+            let promoted_id = Promoted::new(next_promoted_id);\n+            let tcx = self.tcx;\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n                 Place {\n                     base: PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(promoted_id),\n-                        ty\n+                        kind:\n+                            StaticKind::Promoted(\n+                                promoted_id,\n+                                InternalSubsts::identity_for_item(tcx, def_id),\n+                            ),\n+                        ty,\n+                        def_id,\n                     }),\n                     projection: None,\n                 }\n@@ -319,7 +332,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             let span = statement.source_info.span;\n \n                             Operand::Move(Place {\n-                                base: mem::replace(&mut place.base, promoted_place(ty, span).base),\n+                                base: mem::replace(\n+                                    &mut place.base,\n+                                    promoted_place(ty, span).base\n+                                ),\n                                 projection: None,\n                             })\n                         }\n@@ -332,7 +348,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         StatementKind::Assign(_, box Rvalue::Repeat(ref mut operand, _)) => {\n                             let ty = operand.ty(local_decls, self.tcx);\n                             let span = statement.source_info.span;\n-                            mem::replace(operand, Operand::Copy(promoted_place(ty, span)))\n+                            mem::replace(\n+                                operand,\n+                                Operand::Copy(promoted_place(ty, span))\n+                            )\n                         }\n                         _ => bug!()\n                     }\n@@ -353,7 +372,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         // a function requiring a constant argument and as that constant value\n                         // providing a value whose computation contains another call to a function\n                         // requiring a constant argument.\n-                        TerminatorKind::Goto { .. } => return,\n+                        TerminatorKind::Goto { .. } => return None,\n                         _ => bug!()\n                     }\n                 }\n@@ -368,7 +387,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n         let span = self.promoted.span;\n         self.assign(RETURN_PLACE, Rvalue::Use(operand), span);\n-        self.source.promoted.push(self.promoted);\n+        Some(self.promoted)\n     }\n }\n \n@@ -385,14 +404,17 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n }\n \n pub fn promote_candidates<'tcx>(\n+    def_id: DefId,\n     body: &mut Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-) {\n+) -> IndexVec<Promoted, Body<'tcx>> {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n+    let mut promotions = IndexVec::new();\n+\n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n@@ -426,7 +448,6 @@ pub fn promote_candidates<'tcx>(\n                 // memory usage?\n                 body.source_scopes.clone(),\n                 body.source_scope_local_data.clone(),\n-                IndexVec::new(),\n                 None,\n                 initial_locals,\n                 IndexVec::new(),\n@@ -440,7 +461,11 @@ pub fn promote_candidates<'tcx>(\n             temps: &mut temps,\n             keep_original: false\n         };\n-        promoter.promote_candidate(candidate);\n+\n+        //FIXME(oli-obk): having a `maybe_push()` method on `IndexVec` might be nice\n+        if let Some(promoted) = promoter.promote_candidate(def_id, candidate, promotions.len()) {\n+            promotions.push(promoted);\n+        }\n     }\n \n     // Eliminate assignments to, and drops of promoted temps.\n@@ -474,4 +499,6 @@ pub fn promote_candidates<'tcx>(\n             _ => {}\n         }\n     }\n+\n+    promotions\n }"}, {"sha": "a77421ce15008011058ce3a83241cd2f24c0f257", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -25,6 +25,7 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::cell::Cell;\n use std::fmt;\n use std::ops::{Deref, Index, IndexMut};\n use std::usize;\n@@ -222,7 +223,7 @@ trait Qualif {\n             } => Self::in_local(cx, *local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(_),\n+                    kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n                 projection: None,\n@@ -433,13 +434,13 @@ impl Qualif for IsNotPromotable {\n \n     fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n         match static_.kind {\n-            StaticKind::Promoted(_) => unreachable!(),\n-            StaticKind::Static(def_id) => {\n+            StaticKind::Promoted(_, _) => unreachable!(),\n+            StaticKind::Static => {\n                 // Only allow statics (not consts) to refer to other statics.\n                 let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n                 !allowed ||\n-                    cx.tcx.get_attrs(def_id).iter().any(\n+                    cx.tcx.get_attrs(static_.def_id).iter().any(\n                         |attr| attr.check_name(sym::thread_local)\n                     )\n             }\n@@ -872,7 +873,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     dest_projection = &proj.base;\n                 },\n                 (&PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(_),\n+                    kind: StaticKind::Promoted(..),\n                     ..\n                 }), None) => bug!(\"promoteds don't exist yet during promotion\"),\n                 (&PlaceBase::Static(box Static{ kind: _, .. }), None) => {\n@@ -1027,10 +1028,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         self.super_place_base(place_base, context, location);\n         match place_base {\n             PlaceBase::Local(_) => {}\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) => {\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n                 unreachable!()\n             }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n                 if self.tcx\n                         .get_attrs(*def_id)\n                         .iter()\n@@ -1570,10 +1571,20 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n }\n \n-pub struct QualifyAndPromoteConstants;\n+pub struct QualifyAndPromoteConstants<'tcx> {\n+    pub promoted: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+}\n+\n+impl<'tcx> Default for QualifyAndPromoteConstants<'tcx> {\n+    fn default() -> Self {\n+        QualifyAndPromoteConstants {\n+            promoted: Cell::new(IndexVec::new()),\n+        }\n+    }\n+}\n \n-impl MirPass for QualifyAndPromoteConstants {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         if body.return_ty().references_error() {\n             tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n@@ -1649,7 +1660,9 @@ impl MirPass for QualifyAndPromoteConstants {\n             };\n \n             // Do the actual promotion, now that we know what's viable.\n-            promote_consts::promote_candidates(body, tcx, temps, candidates);\n+            self.promoted.set(\n+                promote_consts::promote_candidates(def_id, body, tcx, temps, candidates)\n+            );\n         } else {\n             if !body.control_flow_destroyed.is_empty() {\n                 let mut locals = body.vars_iter();\n@@ -1739,7 +1752,10 @@ impl MirPass for QualifyAndPromoteConstants {\n                 fulfillment_cx.register_bound(&infcx,\n                                               param_env,\n                                               ty,\n-                                              tcx.require_lang_item(lang_items::SyncTraitLangItem),\n+                                              tcx.require_lang_item(\n+                                                  lang_items::SyncTraitLangItem,\n+                                                  Some(body.span)\n+                                              ),\n                                               cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n                     infcx.report_fulfillment_errors(&err, None, false);"}, {"sha": "56093527aee249c3301af89bcc46922b4d1055ed", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -264,11 +264,11 @@ fn check_place(\n         }\n \n         match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }) => {\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n                 Err((span, \"cannot access `static` items in const fn\".into()))\n             }\n             PlaceBase::Local(_)\n-            | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => Ok(()),\n+            | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n         }\n     })\n }"}, {"sha": "73089a2106f6b4f46885d7ea607dbf227e39ad4b", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -18,8 +18,8 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>)\n     RemoveNoopLandingPads.remove_nop_landing_pads(body)\n }\n \n-impl MirPass for RemoveNoopLandingPads {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "1d3bf247387a74ea588264a9679267b35bc4000c", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -23,8 +23,8 @@ use crate::dataflow::has_rustc_mir_with;\n \n pub struct SanityCheck;\n \n-impl MirPass for SanityCheck {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for SanityCheck {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));"}, {"sha": "d4599ee08aa4614f43c8db3c37b3808bdeb95e83", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -52,12 +52,12 @@ pub fn simplify_cfg(body: &mut Body<'_>) {\n     body.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n-impl MirPass for SimplifyCfg {\n+impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n     fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -292,8 +292,8 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n \n pub struct SimplifyLocals;\n \n-impl MirPass for SimplifyLocals {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n         marker.visit_body(body);\n         // Return pointer and arguments are always live"}, {"sha": "0a509666d34aedb76ffd0711af52c4562db8fc8f", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -14,12 +14,12 @@ impl SimplifyBranches {\n     }\n }\n \n-impl MirPass for SimplifyBranches {\n+impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n     fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let param_env = tcx.param_env(src.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();"}, {"sha": "8199a252e78b06c877774a4fe4e80d119037e388", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -36,8 +36,8 @@ use crate::util::patch::MirPatch;\n \n pub struct UniformArrayMoveOut;\n \n-impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {\n@@ -184,8 +184,8 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n \n pub struct RestoreSubsliceArrayMoveOut;\n \n-impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {"}, {"sha": "f3e03e7f81daa89c9f5c09bfeb8135c85e92403c", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -897,7 +897,10 @@ where\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n-        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n+        let free_func = tcx.require_lang_item(\n+            lang_items::BoxFreeFnLangItem,\n+            Some(self.source_info.span)\n+        );\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n             let field_ty = f.ty(self.tcx(), substs);"}, {"sha": "5b78727fdd5ad133fff2905eee7a35a299a63053", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -813,8 +813,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_poly_trait_ref(self, t, m);\n     }\n \n-    fn visit_variant_data(&mut self, s: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'a VariantData) {\n         self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n     }\n "}, {"sha": "a30cd8a627fe3e32d0e67a3dbd4e8296b236c86c", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -131,7 +131,7 @@ be taken. Erroneous code example:\n \n ```compile_fail,E0268\n fn some_func() {\n-    break; // error: `break` outside of loop\n+    break; // error: `break` outside of a loop\n }\n ```\n "}, {"sha": "a5924efefc2af57db13ff21a4f8bf48d4a4929bf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -94,9 +94,9 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_arg(&mut self, arg: &'v hir::Arg) {\n-        self.record(\"Arg\", Id::Node(arg.hir_id), arg);\n-        hir_visit::walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v hir::Param) {\n+        self.record(\"Param\", Id::Node(param.hir_id), param);\n+        hir_visit::walk_param(self, param)\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'v> {\n@@ -334,12 +334,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_struct_field(self, s)\n     }\n \n-    fn visit_variant(&mut self,\n-                     v: &'v ast::Variant,\n-                     g: &'v ast::Generics,\n-                     item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'v ast::Variant) {\n         self.record(\"Variant\", Id::None, v);\n-        ast_visit::walk_variant(self, v, g, item_id)\n+        ast_visit::walk_variant(self, v)\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'v ast::Lifetime) {"}, {"sha": "dbfbec32a6fbf53508d9f4cb77b1ccdae11b8f73", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -16,8 +16,8 @@ use errors::Applicability;\n enum Context {\n     Normal,\n     Loop(hir::LoopSource),\n-    Closure,\n-    AsyncClosure,\n+    Closure(Span),\n+    AsyncClosure(Span),\n     LabeledBlock,\n     AnonConst,\n }\n@@ -58,11 +58,11 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Closure(_, ref function_decl, b, _, movability) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, span, movability) => {\n                 let cx = if let Some(GeneratorMovability::Static) = movability {\n-                    AsyncClosure\n+                    AsyncClosure(span)\n                 } else {\n-                    Closure\n+                    Closure(span)\n                 };\n                 self.visit_fn_decl(&function_decl);\n                 self.with_context(cx, |v| v.visit_nested_body(b));\n@@ -170,23 +170,22 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n-        match self.cx {\n-            LabeledBlock | Loop(_) => {}\n-            Closure => {\n-                struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n-                .span_label(span, \"cannot break inside of a closure\")\n+        let err_inside_of = |article, ty, closure_span| {\n+            struct_span_err!(self.sess, span, E0267, \"`{}` inside of {} {}\", name, article, ty)\n+                .span_label(span, format!(\"cannot `{}` inside of {} {}\", name, article, ty))\n+                .span_label(closure_span, &format!(\"enclosing {}\", ty))\n                 .emit();\n-            }\n-            AsyncClosure => {\n-                struct_span_err!(self.sess, span, E0267, \"`{}` inside of an async block\", name)\n-                    .span_label(span, \"cannot break inside of an async block\")\n-                    .emit();\n-            }\n+        };\n+\n+        match self.cx {\n+            LabeledBlock | Loop(_) => {},\n+            Closure(closure_span) => err_inside_of(\"a\", \"closure\", closure_span),\n+            AsyncClosure(closure_span) => err_inside_of(\"an\", \"`async` block\", closure_span),\n             Normal | AnonConst => {\n-                struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n-                .span_label(span, \"cannot break outside of a loop\")\n+                struct_span_err!(self.sess, span, E0268, \"`{}` outside of a loop\", name)\n+                .span_label(span, format!(\"cannot `{}` outside of a loop\", name))\n                 .emit();\n-            }\n+            },\n         }\n     }\n "}, {"sha": "146058963b69dd67e549c6f01ae81dd587194ef6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -508,11 +508,7 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n-    fn update_macro_reachable_mod(\n-        &mut self,\n-        reachable_mod: hir::HirId,\n-        defining_mod: DefId,\n-    ) {\n+    fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in &module.item_ids {\n@@ -524,19 +520,13 @@ impl EmbargoVisitor<'tcx> {\n                 self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n             }\n         }\n-\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n                         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n-                            self.update_macro_reachable_def(\n-                                hir_id,\n-                                def_kind,\n-                                vis,\n-                                defining_mod,\n-                            );\n+                            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n                 }\n@@ -892,10 +882,14 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n         let mut module_id = self.tcx.hir().as_local_hir_id(macro_module_def_id).unwrap();\n+        if !self.tcx.hir().is_hir_id_module(module_id) {\n+            // `module_id` doesn't correspond to a `mod`, return early (#63164).\n+            return;\n+        }\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n         let new_level = self.update(md.hir_id, level);\n         if new_level.is_none() {\n-            return\n+            return;\n         }\n \n         loop {"}, {"sha": "165a4c707bb6db54bf3e156fa719fd52ce9ae9ce", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -145,17 +145,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }\n \n-        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return Some(ext),\n-        };\n+        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item) =>\n+                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+            LoadedMacro::ProcMacro(ext) => ext,\n+        });\n \n-        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n         self.macro_map.insert(def_id, ext.clone());\n         Some(ext)\n     }\n@@ -1104,7 +1104,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let expansion = parent_scope.expansion;\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {\n-                let ext = self.r.compile_macro(item, self.r.session.edition());\n+                let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.legacy)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {"}, {"sha": "875ae449d94e0f0e9d5f47d208b88cf71b208e64", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1647,10 +1647,14 @@ impl<'a> Resolver<'a> {\n             if module.expansion != parent.expansion &&\n             module.expansion.is_descendant_of(parent.expansion) {\n                 // The macro is a proc macro derive\n-                if module.expansion.looks_like_proc_macro_derive() {\n-                    if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n-                        *poisoned = Some(node_id);\n-                        return module.parent;\n+                if let Some(&def_id) = self.macro_defs.get(&module.expansion) {\n+                    if let Some(ext) = self.get_macro_by_def_id(def_id) {\n+                        if !ext.is_builtin && ext.macro_kind() == MacroKind::Derive {\n+                            if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n+                                *poisoned = Some(node_id);\n+                                return module.parent;\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "7224bd74230b399c2619fd42986f6011164b53ca", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -13,7 +13,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n-use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n+use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n@@ -140,9 +140,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         ImportResolver { r: self }.resolve_imports()\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n+    fn resolve_macro_invocation(\n+        &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n+    ) -> Result<InvocationRes, Indeterminate> {\n+        let invoc_id = invoc.expansion_data.id;\n+        let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n+            Some(parent_scope) => *parent_scope,\n+            None => {\n+                // If there's no entry in the table, then we are resolving an eagerly expanded\n+                // macro, which should inherit its parent scope from its eager expansion root -\n+                // the macro that requested this eager expansion.\n+                let parent_scope = *self.invocation_parent_scopes.get(&eager_expansion_root)\n+                    .expect(\"non-eager expansion without a parent scope\");\n+                self.invocation_parent_scopes.insert(invoc_id, parent_scope);\n+                parent_scope\n+            }\n+        };\n+\n         let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n                 (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n@@ -151,25 +165,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n-                // Block expansion of derives in the container until we know whether one of them\n-                // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n-                // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n-                // will automatically knows about itself.\n-                let mut result = Ok(None);\n-                if derives.len() > 1 {\n-                    for path in derives {\n-                        match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n-                            Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n-                                self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n-                                return Ok(None);\n-                            }\n-                            Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n-                            _ => {}\n-                        }\n-                    }\n+                // Block expansion of the container until we resolve all derives in it.\n+                // This is required for two reasons:\n+                // - Derive helper attributes are in scope for the item to which the `#[derive]`\n+                //   is applied, so they have to be produced by the container's expansion rather\n+                //   than by individual derives.\n+                // - Derives in the container need to know whether one of them is a built-in `Copy`.\n+                // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n+                let mut exts = Vec::new();\n+                for path in derives {\n+                    exts.push(match self.resolve_macro_path(\n+                        path, Some(MacroKind::Derive), &parent_scope, true, force\n+                    ) {\n+                        Ok((Some(ext), _)) => ext,\n+                        Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                        Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+                    })\n                 }\n-                return result;\n+                return Ok(InvocationRes::DeriveContainer(exts));\n             }\n         };\n \n@@ -178,22 +191,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_data(\n-            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n-        );\n+        invoc_id.set_expn_data(ext.expn_data(parent_scope.expansion, span, fast_print_path(path)));\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n             }\n-            self.macro_defs.insert(invoc.expansion_data.id, def_id);\n-            let normal_module_def_id =\n-                self.macro_def_scope(invoc.expansion_data.id).normal_ancestor_id;\n-            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.id,\n-                                                            normal_module_def_id);\n+            self.macro_defs.insert(invoc_id, def_id);\n+            let normal_module_def_id = self.macro_def_scope(invoc_id).normal_ancestor_id;\n+            self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        Ok(Some(ext))\n+        Ok(InvocationRes::Single(ext))\n     }\n \n     fn check_unused_macros(&self) {\n@@ -790,7 +799,7 @@ impl<'a> Resolver<'a> {\n \n     /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n     /// extension partially or entirely for built-in macros and legacy plugin macros.\n-    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> Lrc<SyntaxExtension> {\n+    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n         let mut result = macro_rules::compile(\n             &self.session.parse_sess, self.session.features_untracked(), item, edition\n         );\n@@ -812,6 +821,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        Lrc::new(result)\n+        result\n     }\n }"}, {"sha": "d1fd51a97f6834d26ff66b11cd9934bea0cf871e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -230,7 +230,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_formals(&mut self, formals: &'l [ast::Arg], qualname: &str) {\n+    fn process_formals(&mut self, formals: &'l [ast::Param], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n             let mut collector = PathCollector::new();"}, {"sha": "92ccd4f49f6b9b6ca574477e194933c679482d19", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{arg_to_string, ty_to_string};\n+use syntax::print::pprust::{param_to_string, ty_to_string};\n use syntax_pos::*;\n \n use dump_visitor::DumpVisitor;\n@@ -934,7 +934,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig.push('(');\n     sig.push_str(&decl.inputs\n         .iter()\n-        .map(arg_to_string)\n+        .map(param_to_string)\n         .collect::<Vec<_>>()\n         .join(\", \"));\n     sig.push(')');"}, {"sha": "7427ae9ce8de36efaf5ebed3bbae7e66a2efc215", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 24, "deletions": 974, "changes": 998, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,631 +1,12 @@\n use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n-use crate::util::nodemap::FxHashMap;\n-use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat, ExprKind};\n-use rustc::hir::def::{Res, DefKind, CtorKind};\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n-use rustc::infer;\n+use rustc::hir::{self, ExprKind};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Kind;\n-use syntax::ast;\n-use syntax::util::lev_distance::find_best_match_for_name;\n+use rustc::ty::Ty;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::DesugaringKind;\n-\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::cmp;\n-\n-use super::report_unexpected_variant_res;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n-    ///\n-    /// ```text\n-    /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n-    ///   |\n-    /// 4 |    let temp: usize = match a + b {\n-    ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n-    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n-    ///   |\n-    ///   = note: expected type `usize`\n-    ///              found type `std::result::Result<_, _>`\n-    /// ```\n-    pub fn check_pat_walk(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        mut expected: Ty<'tcx>,\n-        mut def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let tcx = self.tcx;\n-\n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n-\n-        let mut path_resolution = None;\n-        let is_non_ref_pat = match pat.node {\n-            PatKind::Struct(..) |\n-            PatKind::TupleStruct(..) |\n-            PatKind::Or(_) |\n-            PatKind::Tuple(..) |\n-            PatKind::Box(_) |\n-            PatKind::Range(..) |\n-            PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.sty {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Path(ref qpath) => {\n-                let resolution = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-                path_resolution = Some(resolution);\n-                match resolution.0 {\n-                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Wild |\n-            PatKind::Binding(..) |\n-            PatKind::Ref(..) => false,\n-        };\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n-\n-            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n-            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type Ref.\n-            //\n-            // For each ampersand peeled off, update the binding mode and push the original\n-            // type into the adjustments vector.\n-            //\n-            // See the examples in `ui/match-defbm*.rs`.\n-            let mut pat_adjustments = vec![];\n-            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?}\", exp_ty);\n-\n-                debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                // Preserve the reference type. We'll need it later during HAIR lowering.\n-                pat_adjustments.push(exp_ty);\n-\n-                exp_ty = inner_ty;\n-                def_bm = match def_bm {\n-                    // If default binding mode is by value, make it `ref` or `ref mut`\n-                    // (depending on whether we observe `&` or `&mut`).\n-                    ty::BindByValue(_) =>\n-                        ty::BindByReference(inner_mutability),\n-\n-                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                    // the underlying value.\n-                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                        ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                    // (on `&`).\n-                    ty::BindByReference(hir::Mutability::MutMutable) =>\n-                        ty::BindByReference(inner_mutability),\n-                };\n-            }\n-            expected = exp_ty;\n-\n-            if pat_adjustments.len() > 0 {\n-                debug!(\"default binding mode is now {:?}\", def_bm);\n-                self.inh.tables.borrow_mut()\n-                    .pat_adjustments_mut()\n-                    .insert(pat.hir_id, pat_adjustments);\n-            }\n-        } else if let PatKind::Ref(..) = pat.node {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            def_bm = ty::BindByValue(hir::MutImmutable);\n-        }\n-\n-        // Lose mutability now that we know binding mode and discriminant type.\n-        let def_bm = def_bm;\n-        let expected = expected;\n-\n-        let ty = match pat.node {\n-            PatKind::Wild => {\n-                expected\n-            }\n-            PatKind::Lit(ref lt) => {\n-                // We've already computed the type above (when checking for a non-ref pat), so\n-                // avoid computing it again.\n-                let ty = self.node_ty(lt.hir_id);\n-\n-                // Byte string patterns behave the same way as array patterns\n-                // They can denote both statically and dynamically-sized byte arrays.\n-                let mut pat_ty = ty;\n-                if let hir::ExprKind::Lit(ref lt) = lt.node {\n-                    if let ast::LitKind::ByteStr(_) = lt.node {\n-                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::Slice(_) = r_ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static,\n-                                                        tcx.mk_slice(tcx.types.u8))\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Somewhat surprising: in this case, the subtyping\n-                // relation goes the opposite way as the other\n-                // cases. Actually what we really want is not a subtyping\n-                // relation at all but rather that there exists a LUB (so\n-                // that they can be compared). However, in practice,\n-                // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `ty` is\n-                // type is `&'static str`, so if we say that\n-                //\n-                //     &'static str <: expected\n-                //\n-                // then that's equivalent to there existing a LUB.\n-                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n-                    err.emit_unless(discrim_span\n-                        .filter(|&s| {\n-                            // In the case of `if`- and `while`-expressions we've already checked\n-                            // that `scrutinee: bool`. We know that the pattern is `true`,\n-                            // so an error here would be a duplicate and from the wrong POV.\n-                            s.is_desugaring(DesugaringKind::CondTemporary)\n-                        })\n-                        .is_some());\n-                }\n-\n-                pat_ty\n-            }\n-            PatKind::Range(ref begin, ref end, _) => {\n-                let lhs_ty = self.check_expr(begin);\n-                let rhs_ty = self.check_expr(end);\n-\n-                // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty<'_>| {\n-                    ty.is_numeric()\n-                    || ty.is_char()\n-                    || ty.references_error()\n-                };\n-                let lhs_compat = numeric_or_char(lhs_ty);\n-                let rhs_compat = numeric_or_char(rhs_ty);\n-\n-                if !lhs_compat || !rhs_compat {\n-                    let span = if !lhs_compat && !rhs_compat {\n-                        pat.span\n-                    } else if !lhs_compat {\n-                        begin.span\n-                    } else {\n-                        end.span\n-                    };\n-\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0029,\n-                        \"only char and numeric types are allowed in range patterns\"\n-                    );\n-                    err.span_label(span, \"ranges require char or numeric types\");\n-                    err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n-                    err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n-                    if tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"In a match expression, only numbers and characters can be matched \\\n-                             against a range. This is because the compiler checks that the range \\\n-                             is non-empty at compile-time, and is unable to evaluate arbitrary \\\n-                             comparison functions. If you want to capture values of an orderable \\\n-                             type between two end-points, you can use a guard.\"\n-                         );\n-                    }\n-                    err.emit();\n-                    return;\n-                }\n-\n-                // Now that we know the types can be unified we find the unified type and use\n-                // it to type the entire expression.\n-                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n-\n-                // Subtyping doesn't matter here, as the value is some kind of scalar.\n-                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n-                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n-                common_type\n-            }\n-            PatKind::Binding(ba, var_id, _, ref sub) => {\n-                let bm = if ba == hir::BindingAnnotation::Unannotated {\n-                    def_bm\n-                } else {\n-                    ty::BindingMode::convert(ba)\n-                };\n-                self.inh\n-                    .tables\n-                    .borrow_mut()\n-                    .pat_binding_modes_mut()\n-                    .insert(pat.hir_id, bm);\n-                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n-                match bm {\n-                    ty::BindByReference(mutbl) => {\n-                        // If the binding is like\n-                        //     ref x | ref const x | ref mut x\n-                        // then `x` is assigned a value of type `&M T` where M is the mutability\n-                        // and T is the expected type.\n-                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n-                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(region_var, mt);\n-\n-                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n-                        // required. However, we use equality, which is stronger. See (*) for\n-                        // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n-                    }\n-                    // Otherwise, the type of x is the expected type `T`.\n-                    ty::BindByValue(_) => {\n-                        // As above, `T <: typeof(x)` is required, but we\n-                        // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n-                    }\n-                }\n-\n-                // If there are multiple arms, make sure they all agree on\n-                // what the type of the binding `x` ought to be.\n-                if var_id != pat.hir_id {\n-                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n-                }\n-\n-                if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n-                }\n-\n-                local_ty\n-            }\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(\n-                    pat,\n-                    qpath,\n-                    &subpats,\n-                    ddpos,\n-                    expected,\n-                    def_bm,\n-                    discrim_span,\n-                )\n-            }\n-            PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n-            }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Or(ref pats) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                for pat in pats {\n-                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-            PatKind::Tuple(ref elements, ddpos) => {\n-                let mut expected_len = elements.len();\n-                if ddpos.is_some() {\n-                    // Require known type only when `..` is present.\n-                    if let ty::Tuple(ref tys) =\n-                            self.structurally_resolved_type(pat.span, expected).sty {\n-                        expected_len = tys.len();\n-                    }\n-                }\n-                let max_len = cmp::max(expected_len, elements.len());\n-\n-                let element_tys_iter = (0..max_len).map(|_| {\n-                    Kind::from(self.next_ty_var(\n-                        // FIXME: `MiscVariable` for now -- obtaining the span and name information\n-                        // from all tuple elements isn't trivial.\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: pat.span,\n-                        },\n-                    ))\n-                });\n-                let element_tys = tcx.mk_substs(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n-                    err.emit();\n-                    // Walk subpatterns with an expected type of `err` in this case to silence\n-                    // further errors being emitted when using the bindings. #50333\n-                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n-                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n-                    }\n-                    tcx.mk_tup(element_tys_iter)\n-                } else {\n-                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(\n-                            elem,\n-                            &element_tys[i].expect_ty(),\n-                            def_bm,\n-                            discrim_span,\n-                        );\n-                    }\n-                    pat_ty\n-                }\n-            }\n-            PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::TypeInference,\n-                    span: inner.span,\n-                });\n-                let uniq_ty = tcx.mk_box(inner_ty);\n-\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // Here, `demand::subtype` is good enough, but I don't\n-                    // think any errors can be introduced by using\n-                    // `demand::eqtype`.\n-                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    uniq_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve(expected);\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // `demand::subtype` would be good enough, but using\n-                    // `eqtype` turns out to be equally general. See (*)\n-                    // below for details.\n-\n-                    // Take region, inner-type from expected type if we\n-                    // can, to avoid creating needless variables.  This\n-                    // also helps with the bad interactions of the given\n-                    // hack detailed in (*) below.\n-                    debug!(\"check_pat_walk: expected={:?}\", expected);\n-                    let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n-                            (expected, r_ty)\n-                        }\n-                        _ => {\n-                            let inner_ty = self.next_ty_var(\n-                                TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::TypeInference,\n-                                    span: inner.span,\n-                                }\n-                            );\n-                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(region, mt);\n-                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n-                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n-\n-                            // Look for a case like `fn foo(&foo: u32)` and suggest\n-                            // `fn foo(foo: &u32)`\n-                            if let Some(mut err) = err {\n-                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n-                                err.emit();\n-                            }\n-                            (rptr_ty, inner_ty)\n-                        }\n-                    };\n-\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    rptr_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                let (inner_ty, slice_ty) = match expected_ty.sty {\n-                    ty::Array(inner_ty, size) => {\n-                        if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n-                            let min_len = before.len() as u64 + after.len() as u64;\n-                            if slice.is_none() {\n-                                if min_len != size {\n-                                    struct_span_err!(\n-                                        tcx.sess, pat.span, E0527,\n-                                        \"pattern requires {} elements but array has {}\",\n-                                        min_len, size)\n-                                        .span_label(pat.span, format!(\"expected {} elements\", size))\n-                                        .emit();\n-                                }\n-                                (inner_ty, tcx.types.err)\n-                            } else if let Some(rest) = size.checked_sub(min_len) {\n-                                (inner_ty, tcx.mk_array(inner_ty, rest))\n-                            } else {\n-                                struct_span_err!(tcx.sess, pat.span, E0528,\n-                                        \"pattern requires at least {} elements but array has {}\",\n-                                        min_len, size)\n-                                    .span_label(pat.span,\n-                                        format!(\"pattern cannot match array of {} elements\", size))\n-                                    .emit();\n-                                (inner_ty, tcx.types.err)\n-                            }\n-                        } else {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                pat.span,\n-                                E0730,\n-                                \"cannot pattern-match on an array without a fixed length\",\n-                            ).emit();\n-                            (inner_ty, tcx.types.err)\n-                        }\n-                    }\n-                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n-                    _ => {\n-                        if !expected_ty.references_error() {\n-                            let mut err = struct_span_err!(\n-                                tcx.sess, pat.span, E0529,\n-                                \"expected an array or slice, found `{}`\",\n-                                expected_ty);\n-                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n-                                match ty.sty {\n-                                    ty::Array(..) | ty::Slice(..) => {\n-                                        err.help(\"the semantics of slice patterns changed \\\n-                                                  recently; see issue #62254\");\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-\n-                            err.span_label( pat.span,\n-                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n-                            ).emit();\n-                        }\n-                        (tcx.types.err, tcx.types.err)\n-                    }\n-                };\n-\n-                for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n-                }\n-                for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-        };\n-\n-        self.write_ty(pat.hir_id, ty);\n-\n-        // (*) In most of the cases above (literals and constants being\n-        // the exception), we relate types using strict equality, even\n-        // though subtyping would be sufficient. There are a few reasons\n-        // for this, some of which are fairly subtle and which cost me\n-        // (nmatsakis) an hour or two debugging to remember, so I thought\n-        // I'd write them down this time.\n-        //\n-        // 1. There is no loss of expressiveness here, though it does\n-        // cause some inconvenience. What we are saying is that the type\n-        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n-        // errors in some cases, such as this one:\n-        //\n-        // ```\n-        // fn foo<'x>(x: &'x int) {\n-        //    let a = 1;\n-        //    let mut z = x;\n-        //    z = &a;\n-        // }\n-        // ```\n-        //\n-        // The reason we might get an error is that `z` might be\n-        // assigned a type like `&'x int`, and then we would have\n-        // a problem when we try to assign `&a` to `z`, because\n-        // the lifetime of `&a` (i.e., the enclosing block) is\n-        // shorter than `'x`.\n-        //\n-        // HOWEVER, this code works fine. The reason is that the\n-        // expected type here is whatever type the user wrote, not\n-        // the initializer's type. In this case the user wrote\n-        // nothing, so we are going to create a type variable `Z`.\n-        // Then we will assign the type of the initializer (`&'x\n-        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n-        // will instantiate `Z` as a type `&'0 int` where `'0` is\n-        // a fresh region variable, with the constraint that `'x :\n-        // '0`.  So basically we're all set.\n-        //\n-        // Note that there are two tests to check that this remains true\n-        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n-        //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n-        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n-    }\n-\n-    fn borrow_pat_suggestion(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        pat: &Pat,\n-        inner: &Pat,\n-        expected: Ty<'tcx>,\n-    ) {\n-        let tcx = self.tcx;\n-        if let PatKind::Binding(..) = inner.node {\n-            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n-            let binding_parent = tcx.hir().get(binding_parent_id);\n-            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n-            match binding_parent {\n-                hir::Node::Arg(hir::Arg { span, .. }) => {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            *span,\n-                            &format!(\"did you mean `{}`\", snippet),\n-                            format!(\" &{}\", expected),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                hir::Node::Arm(_) |\n-                hir::Node::Pat(_) => {\n-                    // rely on match ergonomics or it might be nested `&&pat`\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            pat.span,\n-                            \"you can probably remove the explicit borrow\",\n-                            snippet,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                _ => {} // don't provide suggestions in other cases #55175\n-            }\n-        }\n-    }\n-\n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-        if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.sty {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\"\\\n-This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n-pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n-this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n-pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n-\n-You can read more about trait objects in the Trait Objects section of the Reference: \\\n-https://doc.rust-lang.org/reference/types.html#trait-objects\");\n-                    }\n-                    err.emit();\n-                    return false\n-                }\n-            }\n-        }\n-        true\n-    }\n-\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr,\n@@ -678,8 +59,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n-                self.check_pat_walk(&p, discrim_ty, binding_mode, Some(discrim.span));\n+                self.check_pat_top(&p, discrim_ty, Some(discrim.span));\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -732,19 +112,26 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             }\n \n             self.diverges.set(pats_diverge);\n-            let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            let arm_ty = if source_if && if_no_else && i != 0 && self.if_fallback_coercion(\n+                expr.span,\n+                &arms[0].body,\n+                &mut coercion,\n+            ) {\n+                tcx.types.err\n+            } else {\n+                // Only call this if this is not an `if` expr with an expected type and no `else`\n+                // clause to avoid duplicated type errors. (#60254)\n+                self.check_expr_with_expectation(&arm.body, expected)\n+            };\n             all_arms_diverge &= self.diverges.get();\n-\n-            let span = expr.span;\n-\n             if source_if {\n                 let then_expr = &arms[0].body;\n                 match (i, if_no_else) {\n-                    (0, _) => coercion.coerce(self, &self.misc(span), &arm.body, arm_ty),\n-                    (_, true) => self.if_fallback_coercion(span, then_expr, &mut coercion),\n+                    (0, _) => coercion.coerce(self, &self.misc(expr.span), &arm.body, arm_ty),\n+                    (_, true) => {} // Handled above to avoid duplicated type errors (#60254).\n                     (_, _) => {\n                         let then_ty = prior_arm_ty.unwrap();\n-                        let cause = self.if_cause(span, then_expr, &arm.body, then_ty, arm_ty);\n+                        let cause = self.if_cause(expr.span, then_expr, &arm.body, then_ty, arm_ty);\n                         coercion.coerce(self, &cause, &arm.body, arm_ty);\n                     }\n                 }\n@@ -759,7 +146,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n                     0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                    _ => (span, ObligationCauseCode::MatchExpressionArm {\n+                    _ => (expr.span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n@@ -800,16 +187,19 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     }\n \n     /// Handle the fallback arm of a desugared if(-let) like a missing else.\n+    ///\n+    /// Returns `true` if there was an error forcing the coercion to the `()` type.\n     fn if_fallback_coercion(\n         &self,\n         span: Span,\n         then_expr: &'tcx hir::Expr,\n         coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm>,\n-    ) {\n+    ) -> bool {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n         let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, span);\n         let cause = self.cause(span, ObligationCauseCode::IfExpressionWithNoElse);\n+        let mut error = false;\n         coercion.coerce_forced_unit(self, &cause, &mut |err| {\n             if let Some((span, msg)) = &ret_reason {\n                 err.span_label(*span, msg.as_str());\n@@ -820,7 +210,9 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             }\n             err.note(\"`if` expressions without `else` evaluate to `()`\");\n             err.help(\"consider adding an `else` block that evaluates to the expected type\");\n+            error = true;\n         }, ret_reason.is_none());\n+        error\n     }\n \n     fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, span: Span) -> Option<(Span, String)> {\n@@ -1038,346 +430,4 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             discrim_ty\n         }\n     }\n-\n-    fn check_pat_struct(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        qpath: &hir::QPath,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n-        {\n-            variant_ty\n-        } else {\n-            for field in fields {\n-                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n-            }\n-            return self.tcx.types.err;\n-        };\n-\n-        // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n-\n-        // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n-        {\n-            pat_ty\n-        } else {\n-            self.tcx.types.err\n-        }\n-    }\n-\n-    fn check_pat_path(\n-        &self,\n-        pat: &hir::Pat,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n-        qpath: &hir::QPath,\n-        expected: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-\n-        // We have already resolved the path.\n-        let (res, opt_ty, segments) = path_resolution;\n-        match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Method, _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n-            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        }\n-\n-        // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        self.demand_suptype(pat.span, expected, pat_ty);\n-        pat_ty\n-    }\n-\n-    fn check_pat_tuple_struct(\n-        &self,\n-        pat: &hir::Pat,\n-        qpath: &hir::QPath,\n-        subpats: &'tcx [P<hir::Pat>],\n-        ddpos: Option<usize>,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        match_arm_pat_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        let on_error = || {\n-            for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n-            }\n-        };\n-        let report_unexpected_res = |res: Res| {\n-            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              res.descr(),\n-                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.node) {\n-                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n-                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n-                    err.help(\"for more information, visit \\\n-                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n-                }\n-                _ => {\n-                    err.span_label(pat.span, \"not a tuple variant or struct\");\n-                }\n-            }\n-            err.emit();\n-            on_error();\n-        };\n-\n-        // Resolve the path and check the definition for errors.\n-        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-        if res == Res::Err {\n-            self.set_tainted_by_errors();\n-            on_error();\n-            return self.tcx.types.err;\n-        }\n-\n-        // Type-check the path.\n-        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n-            pat.hir_id);\n-        if !pat_ty.is_fn() {\n-            report_unexpected_res(res);\n-            return self.tcx.types.err;\n-        }\n-\n-        let variant = match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                on_error();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n-                report_unexpected_res(res);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                tcx.expect_variant_res(res)\n-            }\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        };\n-\n-        // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n-\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n-\n-        // Type-check subpatterns.\n-        if subpats.len() == variant.fields.len() ||\n-                subpats.len() < variant.fields.len() && ddpos.is_some() {\n-            let substs = match pat_ty.sty {\n-                ty::Adt(_, substs) => substs,\n-                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n-            };\n-            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n-\n-                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n-            }\n-        } else {\n-            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n-            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n-            struct_span_err!(tcx.sess, pat.span, E0023,\n-                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, res.descr(),\n-                             variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                              variant.fields.len(), fields_ending, subpats.len()))\n-                .emit();\n-            on_error();\n-            return tcx.types.err;\n-        }\n-        pat_ty\n-    }\n-\n-    fn check_struct_pat_fields(\n-        &self,\n-        adt_ty: Ty<'tcx>,\n-        pat_id: hir::HirId,\n-        span: Span,\n-        variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        def_bm: ty::BindingMode,\n-    ) -> bool {\n-        let tcx = self.tcx;\n-\n-        let (substs, adt) = match adt_ty.sty {\n-            ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(span, \"struct pattern is not an ADT\")\n-        };\n-        let kind_name = adt.variant_descr();\n-\n-        // Index the struct fields' types.\n-        let field_map = variant.fields\n-            .iter()\n-            .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        // Keep track of which fields have already appeared in the pattern.\n-        let mut used_fields = FxHashMap::default();\n-        let mut no_field_errors = true;\n-\n-        let mut inexistent_fields = vec![];\n-        // Typecheck each field.\n-        for field in fields {\n-            let span = field.span;\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n-            let field_ty = match used_fields.entry(ident) {\n-                Occupied(occupied) => {\n-                    struct_span_err!(tcx.sess, span, E0025,\n-                                     \"field `{}` bound multiple times \\\n-                                      in the pattern\",\n-                                     field.ident)\n-                        .span_label(span,\n-                                    format!(\"multiple uses of `{}` in pattern\", field.ident))\n-                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.ident))\n-                        .emit();\n-                    no_field_errors = false;\n-                    tcx.types.err\n-                }\n-                Vacant(vacant) => {\n-                    vacant.insert(span);\n-                    field_map.get(&ident)\n-                        .map(|(i, f)| {\n-                            self.write_field_index(field.hir_id, *i);\n-                            self.tcx.check_stability(f.did, Some(pat_id), span);\n-                            self.field_ty(span, f, substs)\n-                        })\n-                        .unwrap_or_else(|| {\n-                            inexistent_fields.push(field.ident);\n-                            no_field_errors = false;\n-                            tcx.types.err\n-                        })\n-                }\n-            };\n-\n-            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n-        }\n-        let mut unmentioned_fields = variant.fields\n-                .iter()\n-                .map(|field| field.ident.modern())\n-                .filter(|ident| !used_fields.contains_key(&ident))\n-                .collect::<Vec<_>>();\n-        if inexistent_fields.len() > 0 && !variant.recovered {\n-            let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n-                (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n-            } else {\n-                (format!(\"fields named {}\",\n-                         inexistent_fields.iter()\n-                            .map(|ident| format!(\"`{}`\", ident))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \")), \"these\", \"s\")\n-            };\n-            let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           spans,\n-                                           E0026,\n-                                           \"{} `{}` does not have {}\",\n-                                           kind_name,\n-                                           tcx.def_path_str(variant.def_id),\n-                                           field_names);\n-            if let Some(ident) = inexistent_fields.last() {\n-                err.span_label(ident.span,\n-                               format!(\"{} `{}` does not have {} field{}\",\n-                                       kind_name,\n-                                       tcx.def_path_str(variant.def_id),\n-                                       t,\n-                                       plural));\n-                if plural == \"\" {\n-                    let input = unmentioned_fields.iter().map(|field| &field.name);\n-                    let suggested_name =\n-                        find_best_match_for_name(input, &ident.as_str(), None);\n-                    if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion(\n-                            ident.span,\n-                            \"a field with a similar name exists\",\n-                            suggested_name.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-\n-                        // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                        unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n-                    }\n-                }\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"This error indicates that a struct pattern attempted to \\\n-                     extract a non-existent field from a struct. Struct fields \\\n-                     are identified by the name used before the colon : so struct \\\n-                     patterns should resemble the declaration of the struct type \\\n-                     being matched.\\n\\n\\\n-                     If you are using shorthand field patterns but want to refer \\\n-                     to the struct field by a different name, you should rename \\\n-                     it explicitly.\"\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        // Require `..` if struct has non_exhaustive attribute.\n-        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n-            span_err!(tcx.sess, span, E0638,\n-                      \"`..` required with {} marked as non-exhaustive\",\n-                      kind_name);\n-        }\n-\n-        // Report an error if incorrect number of the fields were specified.\n-        if kind_name == \"union\" {\n-            if fields.len() != 1 {\n-                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n-            }\n-            if etc {\n-                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n-            }\n-        } else if !etc {\n-            if unmentioned_fields.len() > 0 {\n-                let field_names = if unmentioned_fields.len() == 1 {\n-                    format!(\"field `{}`\", unmentioned_fields[0])\n-                } else {\n-                    format!(\"fields {}\",\n-                            unmentioned_fields.iter()\n-                                .map(|name| format!(\"`{}`\", name))\n-                                .collect::<Vec<String>>()\n-                                .join(\", \"))\n-                };\n-                let mut diag = struct_span_err!(tcx.sess, span, E0027,\n-                                                \"pattern does not mention {}\",\n-                                                field_names);\n-                diag.span_label(span, format!(\"missing {}\", field_names));\n-                if variant.ctor_kind == CtorKind::Fn {\n-                    diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n-                }\n-                if tcx.sess.teach(&diag.get_code().unwrap()) {\n-                    diag.note(\n-                        \"This error indicates that a pattern for a struct fails to specify a \\\n-                         sub-pattern for every one of the struct's fields. Ensure that each field \\\n-                         from the struct's definition is mentioned in the pattern, or use `..` to \\\n-                         ignore unwanted fields.\"\n-                    );\n-                }\n-                diag.emit();\n-            }\n-        }\n-        no_field_errors\n-    }\n }"}, {"sha": "c216cc92b1e58867ad0c41913276eb3091975d06", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -40,6 +40,7 @@ use rustc::ty::{self, Ty, TypeFoldable, TypeAndMut};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n+use rustc::ty::error::TypeError;\n use rustc::middle::lang_items;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -461,6 +462,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                              self.expr_ty,\n                                              fcx.tcx.mk_fn_ptr(f),\n                                              AllowTwoPhase::No);\n+                    if let Err(TypeError::IntrinsicCast) = res {\n+                        return Err(CastError::IllegalCast);\n+                    }\n                     if res.is_err() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -649,7 +653,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn type_is_known_to_be_sized_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n         traits::type_known_to_meet_bound_modulo_regions(self, self.param_env, ty, lang_item, span)\n     }\n }"}, {"sha": "e9370429f3f55af945ce61df84dbe81854068ec4", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -3,7 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n-use crate::middle::region;\n+use crate::middle::{lang_items, region};\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n         let is_fn = tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_some();\n-        let gen_trait = tcx.lang_items().gen_trait().unwrap();\n+        let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");"}, {"sha": "f2e1a6e29d6fca09344839e42f75ea9c9581716f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -70,6 +70,7 @@ use std::ops::Deref;\n use syntax::feature_gate;\n use syntax::symbol::sym;\n use syntax_pos;\n+use rustc_target::spec::abi::Abi;\n \n struct Coerce<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -689,6 +690,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match b.sty {\n             ty::FnPtr(_) => {\n                 let a_sig = a.fn_sig(self.tcx);\n+                // Intrinsics are not coercible to function pointers\n+                if a_sig.abi() == Abi::RustIntrinsic ||\n+                   a_sig.abi() == Abi::PlatformIntrinsic {\n+                   return Err(TypeError::IntrinsicCast);\n+                }\n                 let InferOk { value: a_sig, mut obligations } =\n                     self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n \n@@ -799,12 +805,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// adjusted type of the expression, if successful.\n     /// Adjustments are only recorded if the coercion succeeded.\n     /// The expressions *must not* have any pre-existing adjustments.\n-    pub fn try_coerce(&self,\n-                      expr: &hir::Expr,\n-                      expr_ty: Ty<'tcx>,\n-                      target: Ty<'tcx>,\n-                      allow_two_phase: AllowTwoPhase)\n-                      -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn try_coerce(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_ty: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+        allow_two_phase: AllowTwoPhase,\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n "}, {"sha": "63137bad52ff84e6049991cc4843c6d6fc6f6461", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -224,13 +224,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// fn takes_ref(_: &Foo) {}\n     /// let ref opt = Some(Foo);\n     ///\n-    /// opt.map(|arg| takes_ref(arg));\n+    /// opt.map(|param| takes_ref(param));\n     /// ```\n-    /// Suggest using `opt.as_ref().map(|arg| takes_ref(arg));` instead.\n+    /// Suggest using `opt.as_ref().map(|param| takes_ref(param));` instead.\n     ///\n     /// It only checks for `Option` and `Result` and won't work with\n     /// ```\n-    /// opt.map(|arg| { takes_ref(arg) });\n+    /// opt.map(|param| { takes_ref(param) });\n     /// ```\n     fn can_use_as_ref(\n         &self,\n@@ -247,13 +247,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let local_parent = self.tcx.hir().get_parent_node(local_id);\n-        let arg_hir_id = match self.tcx.hir().find(local_parent) {\n-            Some(Node::Arg(hir::Arg { hir_id, .. })) => hir_id,\n+        let param_hir_id = match self.tcx.hir().find(local_parent) {\n+            Some(Node::Param(hir::Param { hir_id, .. })) => hir_id,\n             _ => return None\n         };\n \n-        let arg_parent = self.tcx.hir().get_parent_node(*arg_hir_id);\n-        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(arg_parent) {\n+        let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n+        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n             Some(Node::Expr(\n                 hir::Expr { hir_id, node: hir::ExprKind::Closure(_, decl, ..), .. }\n             )) => (hir_id, decl),\n@@ -587,6 +587,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n         }\n+        if let hir::ExprKind::Call(path, args) = &expr.node {\n+            if let (\n+                hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)),\n+                1,\n+            ) = (&path.node, args.len()) {\n+                // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n+                if let (\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)),\n+                    sym::from,\n+                ) = (&base_ty.node, path_segment.ident.name) {\n+                    if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n+                        match ident.name {\n+                            sym::i128 | sym::i64 | sym::i32 | sym::i16 | sym::i8 |\n+                            sym::u128 | sym::u64 | sym::u32 | sym::u16 | sym::u8 |\n+                            sym::isize | sym::usize\n+                            if base_ty_path.segments.len() == 1 => {\n+                                return false;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        }\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);"}, {"sha": "fbaa9904d8303c0386954e2de62a0e31ab5bebc6", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -12,7 +12,7 @@ use crate::check::fatally_break_rust;\n use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n-use crate::check::method::SelfSource;\n+use crate::check::method::{probe, SelfSource, MethodError};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -29,6 +29,7 @@ use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n use rustc::ty;\n use rustc::ty::adjustment::{\n@@ -775,35 +776,80 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n-        let method = match self.lookup_method(rcvr_t,\n-                                              segment,\n-                                              span,\n-                                              expr,\n-                                              rcvr) {\n+        let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Invalid {\n-                    self.report_method_error(span,\n-                                             rcvr_t,\n-                                             segment.ident,\n-                                             SelfSource::MethodCall(rcvr),\n-                                             error,\n-                                             Some(args));\n+                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n                 }\n                 Err(())\n             }\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(span,\n-                                         expr.span,\n-                                         method,\n-                                         &args[1..],\n-                                         DontTupleArguments,\n-                                         expected)\n+        self.check_method_argument_types(\n+            span,\n+            expr.span,\n+            method,\n+            &args[1..],\n+            DontTupleArguments,\n+            expected,\n+        )\n+    }\n+\n+    fn report_extended_method_error(\n+        &self,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        rcvr_t: Ty<'tcx>,\n+        error: MethodError<'tcx>\n+    ) {\n+        let rcvr = &args[0];\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n+            if let Ok(pick) = self.lookup_probe(\n+                span,\n+                segment.ident,\n+                new_rcvr_t,\n+                rcvr,\n+                probe::ProbeScope::AllTraits,\n+            ) {\n+                err.span_label(\n+                    pick.item.ident.span,\n+                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                );\n+            }\n+        };\n+\n+        if let Some(mut err) = self.report_method_error(\n+            span,\n+            rcvr_t,\n+            segment.ident,\n+            SelfSource::MethodCall(rcvr),\n+            error,\n+            Some(args),\n+        ) {\n+            if let ty::Adt(..) = rcvr_t.sty {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this whitelist.\n+                let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n+                try_alt_rcvr(&mut err, box_rcvr_t);\n+                let pin_rcvr_t = self.tcx.mk_lang_item(\n+                    rcvr_t,\n+                    lang_items::PinTypeLangItem,\n+                );\n+                try_alt_rcvr(&mut err, pin_rcvr_t);\n+                let arc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Arc);\n+                try_alt_rcvr(&mut err, arc_rcvr_t);\n+                let rc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Rc);\n+                try_alt_rcvr(&mut err, rc_rcvr_t);\n+            }\n+            err.emit();\n+        }\n     }\n \n     fn check_expr_cast(\n@@ -1392,12 +1438,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_did: DefId,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n+        let kind_name = match self.tcx().def_kind(base_did) {\n+            Some(def_kind) => def_kind.descr(base_did),\n+            _ => \" \",\n+        };\n         let mut err = struct_span_err!(\n             self.tcx().sess,\n             expr.span,\n             E0616,\n-            \"field `{}` of struct `{}` is private\",\n+            \"field `{}` of {} `{}` is private\",\n             field,\n+            kind_name,\n             struct_path\n         );\n         // Also check if an accessible method exists, which is often what is meant.\n@@ -1461,8 +1512,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let struct_variant_def = def.non_enum_variant();\n             let field_names = self.available_field_names(struct_variant_def);\n             if !field_names.is_empty() {\n-                err.note(&format!(\"available fields are: {}\",\n-                                    self.name_series_display(field_names)));\n+                err.note(&format!(\n+                    \"available fields are: {}\",\n+                    self.name_series_display(field_names),\n+                ));\n             }\n         }\n     }"}, {"sha": "1509c0f8a219601d66cc51f8d021f2c6f0c56a48", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n-    fn lookup_probe(\n+    pub fn lookup_probe(\n         &self,\n         span: Span,\n         method_name: ast::Ident,"}, {"sha": "72e6f5971596092ab92b2fa39819ee86265089eb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -69,12 +69,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr]>,\n-    ) {\n+    ) -> Option<DiagnosticBuilder<'_>> {\n         let orig_span = span;\n         let mut span = span;\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n-            return;\n+            return None;\n         }\n \n         let print_disambiguation_help = |\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => {}\n                         }\n                         err.emit();\n-                        return;\n+                        return None;\n                     } else {\n                         span = item_name.span;\n                         let mut err = struct_span_err!(\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                err.emit();\n+                return Some(err);\n             }\n \n             MethodError::Ambiguity(sources) => {\n@@ -573,6 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 bug!(\"no return type expectations but got BadReturnType\")\n             }\n         }\n+        None\n     }\n \n     fn suggest_use_candidates(&self,\n@@ -743,8 +744,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                         // instead we suggest `T: Foo + Bar` in that case.\n                         let mut has_bounds = false;\n+                        let mut impl_trait = false;\n                         if let Node::GenericParam(ref param) = hir.get(id) {\n-                            has_bounds = !param.bounds.is_empty();\n+                            match param.kind {\n+                                hir::GenericParamKind::Type { synthetic: Some(_), .. } => {\n+                                    // We've found `fn foo(x: impl Trait)` instead of\n+                                    // `fn foo<T>(x: T)`. We want to suggest the correct\n+                                    // `fn foo(x: impl Trait + TraitBound)` instead of\n+                                    // `fn foo<T: TraitBound>(x: T)`. (#63706)\n+                                    impl_trait = true;\n+                                    has_bounds = param.bounds.len() > 1;\n+                                }\n+                                _ => {\n+                                    has_bounds = !param.bounds.is_empty();\n+                                }\n+                            }\n                         }\n                         let sp = hir.span(id);\n                         // `sp` only covers `T`, change it so that it covers\n@@ -765,8 +779,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             sp,\n                             &msg[..],\n                             candidates.iter().map(|t| format!(\n-                                \"{}: {}{}\",\n+                                \"{}{} {}{}\",\n                                 param,\n+                                if impl_trait { \" +\" } else { \":\" },\n                                 self.tcx.def_path_str(t.def_id),\n                                 if has_bounds { \" +\"} else { \"\" },\n                             )),"}, {"sha": "16903304a142782a8d4f51a86174491ab0ac2b88", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 96, "deletions": 73, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -70,6 +70,7 @@ type parameter).\n mod autoderef;\n pub mod dropck;\n pub mod _match;\n+mod pat;\n pub mod writeback;\n mod regionck;\n pub mod coercion;\n@@ -1101,20 +1102,19 @@ fn check_fn<'a, 'tcx>(\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n     // Add formal parameters.\n-    for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n+    for (param_ty, param) in fn_sig.inputs().iter().zip(&body.params) {\n         // Check the pattern.\n-        let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n-        fcx.check_pat_walk(&arg.pat, arg_ty, binding_mode, None);\n+        fcx.check_pat_top(&param.pat, param_ty, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if arg.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n-            fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::SizedArgumentType);\n+        if param.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+            fcx.require_type_is_sized(param_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n-        fcx.write_ty(arg.hir_id, arg_ty);\n+        fcx.write_ty(param.hir_id, param_ty);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n@@ -1570,7 +1570,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n         } else {\n             bug!(\"Matching on non-ByRef static\")\n         };\n-        if alloc.relocations.len() != 0 {\n+        if alloc.relocations().len() != 0 {\n             let msg = \"statics with a custom `#[link_section]` must be a \\\n                        simple list of bytes on the wasm target with no \\\n                        extra levels of indirection such as references\";\n@@ -1859,14 +1859,18 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n         for attr in tcx.get_attrs(def_id).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n-                    if pack != repr.pack {\n-                        struct_span_err!(tcx.sess, sp, E0634,\n-                                         \"type has conflicting packed representation hints\").emit();\n+                    if let Some(repr_pack) = repr.pack {\n+                        if pack as u64 != repr_pack.bytes() {\n+                            struct_span_err!(\n+                                tcx.sess, sp, E0634,\n+                                \"type has conflicting packed representation hints\"\n+                            ).emit();\n+                        }\n                     }\n                 }\n             }\n         }\n-        if repr.align > 0 {\n+        if repr.align.is_some() {\n             struct_span_err!(tcx.sess, sp, E0587,\n                              \"type has conflicting packed and align representation hints\").emit();\n         }\n@@ -1885,7 +1889,7 @@ fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) ->\n     }\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() || def.is_union() {\n-            if tcx.adt_def(def.did).repr.align > 0 {\n+            if tcx.adt_def(def.did).repr.align.is_some() {\n                 return true;\n             }\n             // push struct def_id before checking fields\n@@ -2622,7 +2626,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  span: Span,\n                                  code: traits::ObligationCauseCode<'tcx>)\n     {\n-        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n         self.require_type_meets(ty, span, code, lang_item);\n     }\n \n@@ -3576,7 +3580,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     SelfSource::QPath(qself),\n                     error,\n                     None,\n-                );\n+                ).map(|mut e| e.emit());\n             }\n             result\n         });\n@@ -3630,12 +3634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_pat_walk(\n-            &local.pat,\n-            t,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-            None,\n-        );\n+        self.check_pat_top(&local.pat, t, None);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n             self.write_ty(local.hir_id, pat_ty);\n@@ -3917,75 +3916,99 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        match found.sty {\n-            ty::FnDef(..) | ty::FnPtr(_) => {}\n-            _ => return false,\n-        }\n         let hir = self.tcx.hir();\n+        let (def_id, sig) = match found.sty {\n+            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n+            ty::Closure(def_id, substs) => {\n+                // We don't use `closure_sig` to account for malformed closures like\n+                // `|_: [_; continue]| {}` and instead we don't suggest anything.\n+                let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+                (def_id, match closure_sig_ty.sty {\n+                    ty::FnPtr(sig) => sig,\n+                    _ => return false,\n+                })\n+            }\n+            _ => return false,\n+        };\n \n-        let sig = found.fn_sig(self.tcx);\n         let sig = self\n             .replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig)\n             .0;\n         let sig = self.normalize_associated_types_in(expr.span, &sig);\n-        if let Ok(_) = self.try_coerce(expr, sig.output(), expected, AllowTwoPhase::No) {\n+        if self.can_coerce(sig.output(), expected) {\n             let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n                 (String::new(), Applicability::MachineApplicable)\n             } else {\n                 (\"...\".to_string(), Applicability::HasPlaceholders)\n             };\n             let mut msg = \"call this function\";\n-            if let ty::FnDef(def_id, ..) = found.sty {\n-                match hir.get_if_local(def_id) {\n-                    Some(Node::Item(hir::Item {\n-                        node: ItemKind::Fn(.., body_id),\n-                        ..\n-                    })) |\n-                    Some(Node::ImplItem(hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(_, body_id),\n-                        ..\n-                    })) |\n-                    Some(Node::TraitItem(hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n-                        ..\n-                    })) => {\n-                        let body = hir.body(*body_id);\n-                        sugg_call = body.arguments.iter()\n-                            .map(|arg| match &arg.pat.node {\n-                                hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower => ident.to_string(),\n-                                _ => \"_\".to_string(),\n-                            }).collect::<Vec<_>>().join(\", \");\n+            match hir.get_if_local(def_id) {\n+                Some(Node::Item(hir::Item {\n+                    node: ItemKind::Fn(.., body_id),\n+                    ..\n+                })) |\n+                Some(Node::ImplItem(hir::ImplItem {\n+                    node: hir::ImplItemKind::Method(_, body_id),\n+                    ..\n+                })) |\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n+                    ..\n+                })) => {\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body.params.iter()\n+                        .map(|param| match &param.pat.node {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                            if ident.name != kw::SelfLower => ident.to_string(),\n+                            _ => \"_\".to_string(),\n+                        }).collect::<Vec<_>>().join(\", \");\n+                }\n+                Some(Node::Expr(hir::Expr {\n+                    node: ExprKind::Closure(_, _, body_id, closure_span, _),\n+                    span: full_closure_span,\n+                    ..\n+                })) => {\n+                    if *full_closure_span == expr.span {\n+                        return false;\n                     }\n-                    Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n-                        sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                        match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n-                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n-                                msg = \"instantiate this tuple variant\";\n-                            }\n-                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n-                                msg = \"instantiate this tuple struct\";\n-                            }\n-                            _ => {}\n+                    err.span_label(*closure_span, \"closure defined here\");\n+                    msg = \"call this closure\";\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body.params.iter()\n+                        .map(|param| match &param.pat.node {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                            if ident.name != kw::SelfLower => ident.to_string(),\n+                            _ => \"_\".to_string(),\n+                        }).collect::<Vec<_>>().join(\", \");\n+                }\n+                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n+                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                    match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n+                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                            msg = \"instantiate this tuple variant\";\n                         }\n+                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n+                            msg = \"instantiate this tuple struct\";\n+                        }\n+                        _ => {}\n                     }\n-                    Some(Node::ForeignItem(hir::ForeignItem {\n-                        node: hir::ForeignItemKind::Fn(_, idents, _),\n-                        ..\n-                    })) |\n-                    Some(Node::TraitItem(hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n-                        ..\n-                    })) => sugg_call = idents.iter()\n-                            .map(|ident| if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }).collect::<Vec<_>>()\n-                            .join(\", \"),\n-                    _ => {}\n                 }\n-            };\n+                Some(Node::ForeignItem(hir::ForeignItem {\n+                    node: hir::ForeignItemKind::Fn(_, idents, _),\n+                    ..\n+                })) |\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n+                    ..\n+                })) => sugg_call = idents.iter()\n+                        .map(|ident| if ident.name != kw::SelfLower {\n+                            ident.to_string()\n+                        } else {\n+                            \"_\".to_string()\n+                        }).collect::<Vec<_>>()\n+                        .join(\", \"),\n+                _ => {}\n+            }\n             if let Ok(code) = self.sess().source_map().span_to_snippet(expr.span) {\n                 err.span_suggestion(\n                     expr.span,"}, {"sha": "4cf0df308fb4c7efec9b19cabef93826b77a2bae", "filename": "src/librustc_typeck/check/pat.rs", "status": "added", "additions": 1123, "deletions": 0, "changes": 1123, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -0,0 +1,1123 @@\n+use crate::check::FnCtxt;\n+use crate::util::nodemap::FxHashMap;\n+use errors::{Applicability, DiagnosticBuilder};\n+use rustc::hir::{self, PatKind, Pat, HirId};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use rustc::hir::ptr::P;\n+use rustc::infer;\n+use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::ty::{self, Ty, BindingMode, TypeFoldable};\n+use rustc::ty::subst::Kind;\n+use syntax::ast;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::Span;\n+use syntax_pos::hygiene::DesugaringKind;\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n+\n+use super::report_unexpected_variant_res;\n+\n+const CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ: &str = \"\\\n+This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n+pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n+this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n+pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n+\n+You can read more about trait objects in the Trait Objects section of the Reference: \\\n+https://doc.rust-lang.org/reference/types.html#trait-objects\";\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+        self.check_pat(pat, expected, def_bm, discrim_span);\n+    }\n+\n+    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n+    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n+    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:5:9\n+    ///   |\n+    /// 4 |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// 5 |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n+    fn check_pat(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) {\n+        debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n+\n+        let path_resolution = match &pat.node {\n+            PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n+            _ => None,\n+        };\n+        let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n+        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n+\n+        let ty = match &pat.node {\n+            PatKind::Wild => expected,\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Range(begin, end, _) => {\n+                match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n+                    None => return,\n+                    Some(ty) => ty,\n+                }\n+            }\n+            PatKind::Binding(ba, var_id, _, sub) => {\n+                let sub = sub.as_deref();\n+                self.check_pat_ident(pat, *ba, *var_id, sub, expected, def_bm, discrim_span)\n+            }\n+            PatKind::TupleStruct(qpath, subpats, ddpos) => {\n+                self.check_pat_tuple_struct(\n+                    pat,\n+                    qpath,\n+                    subpats,\n+                    *ddpos,\n+                    expected,\n+                    def_bm,\n+                    discrim_span,\n+                )\n+            }\n+            PatKind::Path(qpath) => {\n+                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+            }\n+            PatKind::Struct(qpath, fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Or(pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n+            PatKind::Tuple(elements, ddpos) => {\n+                self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Box(inner) => {\n+                self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Ref(inner, mutbl) => {\n+                self.check_pat_ref(pat, inner, *mutbl, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Slice(before, slice, after) => {\n+                let slice = slice.as_deref();\n+                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n+            }\n+        };\n+\n+        self.write_ty(pat.hir_id, ty);\n+\n+        // (note_1): In most of the cases where (note_1) is referenced\n+        // (literals and constants being the exception), we relate types\n+        // using strict equality, even though subtyping would be sufficient.\n+        // There are a few reasons for this, some of which are fairly subtle\n+        // and which cost me (nmatsakis) an hour or two debugging to remember,\n+        // so I thought I'd write them down this time.\n+        //\n+        // 1. There is no loss of expressiveness here, though it does\n+        // cause some inconvenience. What we are saying is that the type\n+        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+        // errors in some cases, such as this one:\n+        //\n+        // ```\n+        // fn foo<'x>(x: &'x int) {\n+        //    let a = 1;\n+        //    let mut z = x;\n+        //    z = &a;\n+        // }\n+        // ```\n+        //\n+        // The reason we might get an error is that `z` might be\n+        // assigned a type like `&'x int`, and then we would have\n+        // a problem when we try to assign `&a` to `z`, because\n+        // the lifetime of `&a` (i.e., the enclosing block) is\n+        // shorter than `'x`.\n+        //\n+        // HOWEVER, this code works fine. The reason is that the\n+        // expected type here is whatever type the user wrote, not\n+        // the initializer's type. In this case the user wrote\n+        // nothing, so we are going to create a type variable `Z`.\n+        // Then we will assign the type of the initializer (`&'x\n+        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+        // will instantiate `Z` as a type `&'0 int` where `'0` is\n+        // a fresh region variable, with the constraint that `'x :\n+        // '0`.  So basically we're all set.\n+        //\n+        // Note that there are two tests to check that this remains true\n+        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+        //\n+        // 2. Things go horribly wrong if we use subtype. The reason for\n+        // THIS is a fairly subtle case involving bound regions. See the\n+        // `givens` field in `region_constraints`, as well as the test\n+        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+        // for details. Short version is that we must sometimes detect\n+        // relationships between specific region variables and regions\n+        // bound in a closure signature, and that detection gets thrown\n+        // off when we substitute fresh region variables here to enable\n+        // subtyping.\n+    }\n+\n+    /// Compute the new expected type and default binding mode from the old ones\n+    /// as well as the pattern form we are currently checking.\n+    fn calc_default_binding_mode(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        is_non_ref_pat: bool,\n+    ) -> (Ty<'tcx>, BindingMode) {\n+        if is_non_ref_pat {\n+            debug!(\"pattern is non reference pattern\");\n+            self.peel_off_references(pat, expected, def_bm)\n+        } else {\n+            // When you encounter a `&pat` pattern, reset to \"by\n+            // value\". This is so that `x` and `y` here are by value,\n+            // as they appear to be:\n+            //\n+            // ```\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n+            // }\n+            // ```\n+            //\n+            // See issue #46688.\n+            let def_bm = match pat.node {\n+                PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n+                _ => def_bm,\n+            };\n+            (expected, def_bm)\n+        }\n+    }\n+\n+    /// Is the pattern a \"non reference pattern\"?\n+    /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n+    fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n+        match pat.node {\n+            PatKind::Struct(..) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n+            PatKind::Tuple(..) |\n+            PatKind::Box(_) |\n+            PatKind::Range(..) |\n+            PatKind::Slice(..) => true,\n+            PatKind::Lit(ref lt) => {\n+                let ty = self.check_expr(lt);\n+                match ty.sty {\n+                    ty::Ref(..) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Path(_) => {\n+                match opt_path_res.unwrap() {\n+                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Wild |\n+            PatKind::Binding(..) |\n+            PatKind::Ref(..) => false,\n+        }\n+    }\n+\n+    /// Peel off as many immediately nested `& mut?` from the expected type as possible\n+    /// and return the new expected type and binding default binding mode.\n+    /// The adjustments vector, if non-empty is stored in a table.\n+    fn peel_off_references(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        mut def_bm: BindingMode,\n+    ) -> (Ty<'tcx>, BindingMode) {\n+        let mut expected = self.resolve_type_vars_with_obligations(&expected);\n+\n+        // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n+        // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n+        // the `Some(5)` which is not of type Ref.\n+        //\n+        // For each ampersand peeled off, update the binding mode and push the original\n+        // type into the adjustments vector.\n+        //\n+        // See the examples in `ui/match-defbm*.rs`.\n+        let mut pat_adjustments = vec![];\n+        while let ty::Ref(_, inner_ty, inner_mutability) = expected.sty {\n+            debug!(\"inspecting {:?}\", expected);\n+\n+            debug!(\"current discriminant is Ref, inserting implicit deref\");\n+            // Preserve the reference type. We'll need it later during HAIR lowering.\n+            pat_adjustments.push(expected);\n+\n+            expected = inner_ty;\n+            def_bm = ty::BindByReference(match def_bm {\n+                // If default binding mode is by value, make it `ref` or `ref mut`\n+                // (depending on whether we observe `&` or `&mut`).\n+                ty::BindByValue(_) |\n+                // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref` (on `&`).\n+                ty::BindByReference(hir::Mutability::MutMutable) => inner_mutability,\n+                // Once a `ref`, always a `ref`.\n+                // This is because a `& &mut` cannot mutate the underlying value.\n+                ty::BindByReference(m @ hir::Mutability::MutImmutable) => m,\n+            });\n+        }\n+\n+        if pat_adjustments.len() > 0 {\n+            debug!(\"default binding mode is now {:?}\", def_bm);\n+            self.inh.tables.borrow_mut()\n+                .pat_adjustments_mut()\n+                .insert(pat.hir_id, pat_adjustments);\n+        }\n+\n+        (expected, def_bm)\n+    }\n+\n+    fn check_pat_lit(\n+        &self,\n+        span: Span,\n+        lt: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // We've already computed the type above (when checking for a non-ref pat),\n+        // so avoid computing it again.\n+        let ty = self.node_ty(lt.hir_id);\n+\n+        // Byte string patterns behave the same way as array patterns\n+        // They can denote both statically and dynamically-sized byte arrays.\n+        let mut pat_ty = ty;\n+        if let hir::ExprKind::Lit(ref lt) = lt.node {\n+            if let ast::LitKind::ByteStr(_) = lt.node {\n+                let expected_ty = self.structurally_resolved_type(span, expected);\n+                if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                    if let ty::Slice(_) = r_ty.sty {\n+                        let tcx = self.tcx;\n+                        pat_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_static,\n+                            tcx.mk_slice(tcx.types.u8),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Somewhat surprising: in this case, the subtyping relation goes the\n+        // opposite way as the other cases. Actually what we really want is not\n+        // a subtyping relation at all but rather that there exists a LUB\n+        // (so that they can be compared). However, in practice, constants are\n+        // always scalars or strings. For scalars subtyping is irrelevant,\n+        // and for strings `ty` is type is `&'static str`, so if we say that\n+        //\n+        //     &'static str <: expected\n+        //\n+        // then that's equivalent to there existing a LUB.\n+        if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n+            err.emit_unless(discrim_span\n+                .filter(|&s| {\n+                    // In the case of `if`- and `while`-expressions we've already checked\n+                    // that `scrutinee: bool`. We know that the pattern is `true`,\n+                    // so an error here would be a duplicate and from the wrong POV.\n+                    s.is_desugaring(DesugaringKind::CondTemporary)\n+                })\n+                .is_some());\n+        }\n+\n+        pat_ty\n+    }\n+\n+    fn check_pat_range(\n+        &self,\n+        span: Span,\n+        begin: &'tcx hir::Expr,\n+        end: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) -> Option<Ty<'tcx>> {\n+        let lhs_ty = self.check_expr(begin);\n+        let rhs_ty = self.check_expr(end);\n+\n+        // Check that both end-points are of numeric or char type.\n+        let numeric_or_char = |ty: Ty<'_>| {\n+            ty.is_numeric()\n+            || ty.is_char()\n+            || ty.references_error()\n+        };\n+        let lhs_compat = numeric_or_char(lhs_ty);\n+        let rhs_compat = numeric_or_char(rhs_ty);\n+\n+        if !lhs_compat || !rhs_compat {\n+            let span = if !lhs_compat && !rhs_compat {\n+                span\n+            } else if !lhs_compat {\n+                begin.span\n+            } else {\n+                end.span\n+            };\n+\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                span,\n+                E0029,\n+                \"only char and numeric types are allowed in range patterns\"\n+            );\n+            err.span_label(span, \"ranges require char or numeric types\");\n+            err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n+            err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\n+                    \"In a match expression, only numbers and characters can be matched \\\n+                        against a range. This is because the compiler checks that the range \\\n+                        is non-empty at compile-time, and is unable to evaluate arbitrary \\\n+                        comparison functions. If you want to capture values of an orderable \\\n+                        type between two end-points, you can use a guard.\"\n+                    );\n+            }\n+            err.emit();\n+            return None;\n+        }\n+\n+        // Now that we know the types can be unified we find the unified type and use\n+        // it to type the entire expression.\n+        let common_type = self.resolve_vars_if_possible(&lhs_ty);\n+\n+        // Subtyping doesn't matter here, as the value is some kind of scalar.\n+        self.demand_eqtype_pat(span, expected, lhs_ty, discrim_span);\n+        self.demand_eqtype_pat(span, expected, rhs_ty, discrim_span);\n+        Some(common_type)\n+    }\n+\n+    fn check_pat_ident(\n+        &self,\n+        pat: &Pat,\n+        ba: hir::BindingAnnotation,\n+        var_id: HirId,\n+        sub: Option<&'tcx Pat>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Determine the binding mode...\n+        let bm = match ba {\n+            hir::BindingAnnotation::Unannotated => def_bm,\n+            _ => BindingMode::convert(ba),\n+        };\n+        // ...and store it in a side table:\n+        self.inh\n+            .tables\n+            .borrow_mut()\n+            .pat_binding_modes_mut()\n+            .insert(pat.hir_id, bm);\n+\n+        debug!(\"check_pat_ident: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+\n+        let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n+        let eq_ty = match bm {\n+            ty::BindByReference(mutbl) => {\n+                // If the binding is like `ref x | ref const x | ref mut x`\n+                // then `x` is assigned a value of type `&M T` where M is the\n+                // mutability and T is the expected type.\n+                let region_ty = self.new_ref_ty(pat.span, mutbl, expected);\n+\n+                // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)`\n+                // is required. However, we use equality, which is stronger.\n+                // See (note_1) for an explanation.\n+                region_ty\n+            }\n+            // Otherwise, the type of x is the expected type `T`.\n+            ty::BindByValue(_) => {\n+                // As above, `T <: typeof(x)` is required, but we use equality, see (note_1).\n+                expected\n+            }\n+        };\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+\n+        // If there are multiple arms, make sure they all agree on\n+        // what the type of the binding `x` ought to be.\n+        if var_id != pat.hir_id {\n+            let vt = self.local_ty(pat.span, var_id).decl_ty;\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+        }\n+\n+        if let Some(p) = sub {\n+            self.check_pat(&p, expected, def_bm, discrim_span);\n+        }\n+\n+        local_ty\n+    }\n+\n+    fn borrow_pat_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: &Pat,\n+        inner: &Pat,\n+        expected: Ty<'tcx>,\n+    ) {\n+        let tcx = self.tcx;\n+        if let PatKind::Binding(..) = inner.node {\n+            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n+            let binding_parent = tcx.hir().get(binding_parent_id);\n+            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n+            match binding_parent {\n+                hir::Node::Param(hir::Param { span, .. }) => {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            &format!(\"did you mean `{}`\", snippet),\n+                            format!(\" &{}\", expected),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                hir::Node::Arm(_) |\n+                hir::Node::Pat(_) => {\n+                    // rely on match ergonomics or it might be nested `&&pat`\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            pat.span,\n+                            \"you can probably remove the explicit borrow\",\n+                            snippet,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                _ => {} // don't provide suggestions in other cases #55175\n+            }\n+        }\n+    }\n+\n+    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+        if let PatKind::Binding(..) = inner.node {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n+                if let ty::Dynamic(..) = mt.ty.sty {\n+                    // This is \"x = SomeTrait\" being reduced from\n+                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                    let type_str = self.ty_to_string(expected);\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0033,\n+                        \"type `{}` cannot be dereferenced\",\n+                        type_str\n+                    );\n+                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n+                    }\n+                    err.emit();\n+                    return false\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n+    fn check_pat_struct(\n+        &self,\n+        pat: &'tcx Pat,\n+        qpath: &hir::QPath,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Resolve the path and check the definition for errors.\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n+        {\n+            variant_ty\n+        } else {\n+            for field in fields {\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+            }\n+            return self.tcx.types.err;\n+        };\n+\n+        // Type-check the path.\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+\n+        // Type-check subpatterns.\n+        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        {\n+            pat_ty\n+        } else {\n+            self.tcx.types.err\n+        }\n+    }\n+\n+    fn check_pat_path(\n+        &self,\n+        pat: &Pat,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n+        qpath: &hir::QPath,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+\n+        // We have already resolved the path.\n+        let (res, opt_ty, segments) = path_resolution;\n+        match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Method, _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n+            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        }\n+\n+        // Type-check the path.\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+        pat_ty\n+    }\n+\n+    fn check_pat_tuple_struct(\n+        &self,\n+        pat: &Pat,\n+        qpath: &hir::QPath,\n+        subpats: &'tcx [P<Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        match_arm_pat_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let on_error = || {\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+            }\n+        };\n+        let report_unexpected_res = |res: Res| {\n+            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                              res.descr(),\n+                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n+            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+            match (res, &pat.node) {\n+                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n+                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n+                    err.help(\"for more information, visit \\\n+                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n+                }\n+                _ => {\n+                    err.span_label(pat.span, \"not a tuple variant or struct\");\n+                }\n+            }\n+            err.emit();\n+            on_error();\n+        };\n+\n+        // Resolve the path and check the definition for errors.\n+        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        if res == Res::Err {\n+            self.set_tainted_by_errors();\n+            on_error();\n+            return self.tcx.types.err;\n+        }\n+\n+        // Type-check the path.\n+        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n+            pat.hir_id);\n+        if !pat_ty.is_fn() {\n+            report_unexpected_res(res);\n+            return tcx.types.err;\n+        }\n+\n+        let variant = match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n+                report_unexpected_res(res);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                tcx.expect_variant_res(res)\n+            }\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        };\n+\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n+\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n+\n+        // Type-check subpatterns.\n+        if subpats.len() == variant.fields.len()\n+            || subpats.len() < variant.fields.len() && ddpos.is_some()\n+        {\n+            let substs = match pat_ty.sty {\n+                ty::Adt(_, substs) => substs,\n+                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n+            };\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n+                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n+\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n+            }\n+        } else {\n+            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n+            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n+            struct_span_err!(tcx.sess, pat.span, E0023,\n+                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                             subpats.len(), subpats_ending, res.descr(),\n+                             variant.fields.len(),  fields_ending)\n+                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n+                                              variant.fields.len(), fields_ending, subpats.len()))\n+                .emit();\n+            on_error();\n+            return tcx.types.err;\n+        }\n+        pat_ty\n+    }\n+\n+    fn check_pat_tuple(\n+        &self,\n+        span: Span,\n+        elements: &'tcx [P<Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let mut expected_len = elements.len();\n+        if ddpos.is_some() {\n+            // Require known type only when `..` is present.\n+            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).sty {\n+                expected_len = tys.len();\n+            }\n+        }\n+        let max_len = cmp::max(expected_len, elements.len());\n+\n+        let element_tys_iter = (0..max_len).map(|_| {\n+            Kind::from(self.next_ty_var(\n+                // FIXME: `MiscVariable` for now -- obtaining the span and name information\n+                // from all tuple elements isn't trivial.\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                },\n+            ))\n+        });\n+        let element_tys = tcx.mk_substs(element_tys_iter);\n+        let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n+        if let Some(mut err) = self.demand_eqtype_diag(span, expected, pat_ty) {\n+            err.emit();\n+            // Walk subpatterns with an expected type of `err` in this case to silence\n+            // further errors being emitted when using the bindings. #50333\n+            let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+            for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n+            }\n+            tcx.mk_tup(element_tys_iter)\n+        } else {\n+            for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n+            }\n+            pat_ty\n+        }\n+    }\n+\n+    fn check_struct_pat_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        pat_id: HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        def_bm: BindingMode,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let (substs, adt) = match adt_ty.sty {\n+            ty::Adt(adt, substs) => (substs, adt),\n+            _ => span_bug!(span, \"struct pattern is not an ADT\")\n+        };\n+        let kind_name = adt.variant_descr();\n+\n+        // Index the struct fields' types.\n+        let field_map = variant.fields\n+            .iter()\n+            .enumerate()\n+            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        // Keep track of which fields have already appeared in the pattern.\n+        let mut used_fields = FxHashMap::default();\n+        let mut no_field_errors = true;\n+\n+        let mut inexistent_fields = vec![];\n+        // Typecheck each field.\n+        for field in fields {\n+            let span = field.span;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n+            let field_ty = match used_fields.entry(ident) {\n+                Occupied(occupied) => {\n+                    self.error_field_already_bound(span, field.ident, *occupied.get());\n+                    no_field_errors = false;\n+                    tcx.types.err\n+                }\n+                Vacant(vacant) => {\n+                    vacant.insert(span);\n+                    field_map.get(&ident)\n+                        .map(|(i, f)| {\n+                            self.write_field_index(field.hir_id, *i);\n+                            self.tcx.check_stability(f.did, Some(pat_id), span);\n+                            self.field_ty(span, f, substs)\n+                        })\n+                        .unwrap_or_else(|| {\n+                            inexistent_fields.push(field.ident);\n+                            no_field_errors = false;\n+                            tcx.types.err\n+                        })\n+                }\n+            };\n+\n+            self.check_pat(&field.pat, field_ty, def_bm, None);\n+        }\n+\n+        let mut unmentioned_fields = variant.fields\n+                .iter()\n+                .map(|field| field.ident.modern())\n+                .filter(|ident| !used_fields.contains_key(&ident))\n+                .collect::<Vec<_>>();\n+\n+        if inexistent_fields.len() > 0 && !variant.recovered {\n+            self.error_inexistent_fields(\n+                kind_name,\n+                &inexistent_fields,\n+                &mut unmentioned_fields,\n+                variant\n+            );\n+        }\n+\n+        // Require `..` if struct has non_exhaustive attribute.\n+        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n+            span_err!(tcx.sess, span, E0638,\n+                      \"`..` required with {} marked as non-exhaustive\",\n+                      kind_name);\n+        }\n+\n+        // Report an error if incorrect number of the fields were specified.\n+        if kind_name == \"union\" {\n+            if fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n+            }\n+            if etc {\n+                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n+            }\n+        } else if !etc && unmentioned_fields.len() > 0 {\n+            self.error_unmentioned_fields(span, &unmentioned_fields, variant);\n+        }\n+        no_field_errors\n+    }\n+\n+    fn error_field_already_bound(&self, span: Span, ident: ast::Ident, other_field: Span) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0025,\n+            \"field `{}` bound multiple times in the pattern\",\n+            ident\n+        )\n+        .span_label(span, format!(\"multiple uses of `{}` in pattern\", ident))\n+        .span_label(other_field, format!(\"first use of `{}`\", ident))\n+        .emit();\n+    }\n+\n+    fn error_inexistent_fields(\n+        &self,\n+        kind_name: &str,\n+        inexistent_fields: &[ast::Ident],\n+        unmentioned_fields: &mut Vec<ast::Ident>,\n+        variant: &ty::VariantDef,\n+    ) {\n+        let tcx = self.tcx;\n+        let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n+            (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n+        } else {\n+            (format!(\"fields named {}\",\n+                        inexistent_fields.iter()\n+                        .map(|ident| format!(\"`{}`\", ident))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \")), \"these\", \"s\")\n+        };\n+        let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n+        let mut err = struct_span_err!(tcx.sess,\n+                                        spans,\n+                                        E0026,\n+                                        \"{} `{}` does not have {}\",\n+                                        kind_name,\n+                                        tcx.def_path_str(variant.def_id),\n+                                        field_names);\n+        if let Some(ident) = inexistent_fields.last() {\n+            err.span_label(ident.span,\n+                            format!(\"{} `{}` does not have {} field{}\",\n+                                    kind_name,\n+                                    tcx.def_path_str(variant.def_id),\n+                                    t,\n+                                    plural));\n+            if plural == \"\" {\n+                let input = unmentioned_fields.iter().map(|field| &field.name);\n+                let suggested_name =\n+                    find_best_match_for_name(input, &ident.as_str(), None);\n+                if let Some(suggested_name) = suggested_name {\n+                    err.span_suggestion(\n+                        ident.span,\n+                        \"a field with a similar name exists\",\n+                        suggested_name.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+\n+                    // we don't want to throw `E0027` in case we have thrown `E0026` for them\n+                    unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n+                }\n+            }\n+        }\n+        if tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"This error indicates that a struct pattern attempted to \\\n+                    extract a non-existent field from a struct. Struct fields \\\n+                    are identified by the name used before the colon : so struct \\\n+                    patterns should resemble the declaration of the struct type \\\n+                    being matched.\\n\\n\\\n+                    If you are using shorthand field patterns but want to refer \\\n+                    to the struct field by a different name, you should rename \\\n+                    it explicitly.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+\n+    fn error_unmentioned_fields(\n+        &self,\n+        span: Span,\n+        unmentioned_fields: &[ast::Ident],\n+        variant: &ty::VariantDef,\n+    ) {\n+        let field_names = if unmentioned_fields.len() == 1 {\n+            format!(\"field `{}`\", unmentioned_fields[0])\n+        } else {\n+            let fields = unmentioned_fields.iter()\n+                .map(|name| format!(\"`{}`\", name))\n+                .collect::<Vec<String>>()\n+                .join(\", \");\n+            format!(\"fields {}\", fields)\n+        };\n+        let mut diag = struct_span_err!(\n+            self.tcx.sess, span, E0027,\n+            \"pattern does not mention {}\",\n+            field_names\n+        );\n+        diag.span_label(span, format!(\"missing {}\", field_names));\n+        if variant.ctor_kind == CtorKind::Fn {\n+            diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n+        }\n+        if self.tcx.sess.teach(&diag.get_code().unwrap()) {\n+            diag.note(\n+                \"This error indicates that a pattern for a struct fails to specify a \\\n+                    sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                    from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                    ignore unwanted fields.\"\n+            );\n+        }\n+        diag.emit();\n+    }\n+\n+    fn check_pat_box(\n+        &self,\n+        span: Span,\n+        inner: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let (box_ty, inner_ty) = if self.check_dereferencable(span, expected, &inner) {\n+            // Here, `demand::subtype` is good enough, but I don't\n+            // think any errors can be introduced by using `demand::eqtype`.\n+            let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span: inner.span,\n+            });\n+            let box_ty = tcx.mk_box(inner_ty);\n+            self.demand_eqtype_pat(span, expected, box_ty, discrim_span);\n+            (box_ty, inner_ty)\n+        } else {\n+            (tcx.types.err, tcx.types.err)\n+        };\n+        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        box_ty\n+    }\n+\n+    fn check_pat_ref(\n+        &self,\n+        pat: &Pat,\n+        inner: &'tcx Pat,\n+        mutbl: hir::Mutability,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected = self.shallow_resolve(expected);\n+        let (rptr_ty, inner_ty) = if self.check_dereferencable(pat.span, expected, &inner) {\n+            // `demand::subtype` would be good enough, but using `eqtype` turns\n+            // out to be equally general. See (note_1) for details.\n+\n+            // Take region, inner-type from expected type if we can,\n+            // to avoid creating needless variables. This also helps with\n+            // the bad  interactions of the given hack detailed in (note_1).\n+            debug!(\"check_pat_ref: expected={:?}\", expected);\n+            match expected.sty {\n+                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n+                _ => {\n+                    let inner_ty = self.next_ty_var(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        }\n+                    );\n+                    let rptr_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n+                    let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+\n+                    // Look for a case like `fn foo(&foo: u32)` and suggest\n+                    // `fn foo(foo: &u32)`\n+                    if let Some(mut err) = err {\n+                        self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n+                        err.emit();\n+                    }\n+                    (rptr_ty, inner_ty)\n+                }\n+            }\n+        } else {\n+            (tcx.types.err, tcx.types.err)\n+        };\n+        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        rptr_ty\n+    }\n+\n+    /// Create a reference type with a fresh region variable.\n+    fn new_ref_ty(&self, span: Span, mutbl: hir::Mutability, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let region = self.next_region_var(infer::PatternRegion(span));\n+        let mt = ty::TypeAndMut { ty, mutbl };\n+        self.tcx.mk_ref(region, mt)\n+    }\n+\n+    fn check_pat_slice(\n+        &self,\n+        span: Span,\n+        before: &'tcx [P<Pat>],\n+        slice: Option<&'tcx Pat>,\n+        after: &'tcx [P<Pat>],\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected_ty = self.structurally_resolved_type(span, expected);\n+        let (inner_ty, slice_ty) = match expected_ty.sty {\n+            ty::Array(inner_ty, size) => {\n+                let slice_ty = if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n+                    let min_len = before.len() as u64 + after.len() as u64;\n+                    if slice.is_none() {\n+                        if min_len != size {\n+                            self.error_scrutinee_inconsistent_length(span, min_len, size)\n+                        }\n+                        tcx.types.err\n+                    } else if let Some(rest) = size.checked_sub(min_len) {\n+                        tcx.mk_array(inner_ty, rest)\n+                    } else {\n+                        self.error_scrutinee_with_rest_inconsistent_length(span, min_len, size);\n+                        tcx.types.err\n+                    }\n+                } else {\n+                    self.error_scrutinee_unfixed_length(span);\n+                    tcx.types.err\n+                };\n+                (inner_ty, slice_ty)\n+            }\n+            ty::Slice(inner_ty) => (inner_ty, expected_ty),\n+            _ => {\n+                if !expected_ty.references_error() {\n+                    self.error_expected_array_or_slice(span, expected_ty);\n+                }\n+                (tcx.types.err, tcx.types.err)\n+            }\n+        };\n+\n+        for elt in before {\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+        }\n+        if let Some(slice) = slice {\n+            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n+        }\n+        for elt in after {\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+        }\n+        expected_ty\n+    }\n+\n+    fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0527,\n+            \"pattern requires {} elements but array has {}\",\n+            min_len, size\n+        )\n+        .span_label(span, format!(\"expected {} elements\", size))\n+        .emit();\n+    }\n+\n+    fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0528,\n+            \"pattern requires at least {} elements but array has {}\",\n+            min_len, size\n+        )\n+        .span_label(span, format!(\"pattern cannot match array of {} elements\", size))\n+        .emit();\n+    }\n+\n+    fn error_scrutinee_unfixed_length(&self, span: Span) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0730,\n+            \"cannot pattern-match on an array without a fixed length\",\n+        )\n+        .emit();\n+    }\n+\n+    fn error_expected_array_or_slice(&self, span: Span, expected_ty: Ty<'tcx>) {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess, span, E0529,\n+            \"expected an array or slice, found `{}`\",\n+            expected_ty\n+        );\n+        if let ty::Ref(_, ty, _) = expected_ty.sty {\n+            if let ty::Array(..) | ty::Slice(..) = ty.sty {\n+                err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n+            }\n+        }\n+        err.span_label(span, format!(\"pattern cannot match with input type `{}`\", expected_ty));\n+        err.emit();\n+    }\n+}"}, {"sha": "fc01a820e23591dcb6a5df0e0b0293f5e65ae6a5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -347,12 +347,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n         self.outlives_environment\n             .save_implied_bounds(body_id.hir_id);\n-        self.link_fn_args(\n+        self.link_fn_params(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n                 data: region::ScopeData::Node,\n             },\n-            &body.arguments,\n+            &body.params,\n         );\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n@@ -1078,16 +1078,16 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: region::Scope, args: &[hir::Arg]) {\n-        debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        for arg in args {\n-            let arg_ty = self.node_ty(arg.hir_id);\n+    fn link_fn_params(&self, body_scope: region::Scope, params: &[hir::Param]) {\n+        debug!(\"regionck::link_fn_params(body_scope={:?})\", body_scope);\n+        for param in params {\n+            let param_ty = self.node_ty(param.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n+            let param_cmt = self.with_mc(|mc| {\n+                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, re_scope, param_ty))\n             });\n-            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\", arg_ty, arg_cmt, arg);\n-            self.link_pattern(arg_cmt, &arg.pat);\n+            debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n+            self.link_pattern(param_cmt, &param.pat);\n         }\n     }\n "}, {"sha": "f95b3e44bf0f7012374d358e5c7002c0c3f37378", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -287,7 +287,7 @@ fn check_type_defn<'tcx, F>(\n                 let last = idx == variant.fields.len() - 1;\n                 fcx.register_bound(\n                     field.ty,\n-                    fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     traits::ObligationCause::new(\n                         field.span,\n                         fcx.body_id,\n@@ -375,7 +375,7 @@ fn check_item_type(\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n-                fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                 traits::ObligationCause::new(ty_span, fcx.body_id, traits::MiscObligation),\n             );\n         }"}, {"sha": "487dc8ec2ae0ca75adc7230e72c3dcb308cee827", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n-        for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n+        for param in &body.params {\n+            wbcx.visit_node_id(param.pat.span, param.hir_id);\n         }\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_id) {\n@@ -245,8 +245,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         match e.node {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir().body(body);\n-                for arg in &body.arguments {\n-                    self.visit_node_id(e.span, arg.hir_id);\n+                for param in &body.params {\n+                    self.visit_node_id(e.span, param.hir_id);\n                 }\n \n                 self.visit_body(body);"}, {"sha": "516be99ed6aad1196879b574edb6030bf1a5d0c2", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -464,7 +464,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         // it is *not* required (i.e., '?Sized')\n         let sized_trait = self.cx\n             .tcx\n-            .require_lang_item(lang_items::SizedTraitLangItem);\n+            .require_lang_item(lang_items::SizedTraitLangItem, None);\n \n         let mut replacer = RegionReplacer {\n             vid_to_region: &vid_to_region,\n@@ -777,9 +777,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     fn is_fn_ty(&self, tcx: TyCtxt<'_>, ty: &Type) -> bool {\n         match &ty {\n             &&Type::ResolvedPath { ref did, .. } => {\n-                *did == tcx.require_lang_item(lang_items::FnTraitLangItem)\n-                    || *did == tcx.require_lang_item(lang_items::FnMutTraitLangItem)\n-                    || *did == tcx.require_lang_item(lang_items::FnOnceTraitLangItem)\n+                *did == tcx.require_lang_item(lang_items::FnTraitLangItem, None)\n+                    || *did == tcx.require_lang_item(lang_items::FnMutTraitLangItem, None)\n+                    || *did == tcx.require_lang_item(lang_items::FnOnceTraitLangItem, None)\n             }\n             _ => false,\n         }"}, {"sha": "cb42ff1c8052fc89a4022de1f2e143f970207fed", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -20,6 +20,7 @@ use crate::clean::{\n     self,\n     GetDefId,\n     ToSource,\n+    TypeKind\n };\n \n use super::Clean;\n@@ -107,15 +108,16 @@ pub fn try_inline(\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n-        // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n-        Res::Def(DefKind::Macro(MacroKind::Bang), did) => {\n+        Res::Def(DefKind::Macro(kind), did) => {\n             let mac = build_macro(cx, did, name);\n-            if let clean::MacroItem(..) = mac {\n-                record_extern_fqn(cx, did, clean::TypeKind::Macro);\n-                mac\n-            } else {\n-                return None;\n-            }\n+\n+            let type_kind = match kind {\n+                MacroKind::Bang => TypeKind::Macro,\n+                MacroKind::Attr => TypeKind::Attr,\n+                MacroKind::Derive => TypeKind::Derive\n+            };\n+            record_extern_fqn(cx, did, type_kind);\n+            mac\n         }\n         _ => return None,\n     };\n@@ -217,8 +219,9 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     };\n \n     let predicates = cx.tcx.predicates_of(did);\n-    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n-    let decl = (did, sig).clean(cx);\n+    let (generics, decl) = clean::enter_impl_trait(cx, || {\n+        ((cx.tcx.generics_of(did), &predicates).clean(cx), (did, sig).clean(cx))\n+    });\n     let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n         decl,\n@@ -372,7 +375,9 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n                     None\n                 }\n             }).collect::<Vec<_>>(),\n-            (tcx.generics_of(did), &predicates).clean(cx),\n+            clean::enter_impl_trait(cx, || {\n+                (tcx.generics_of(did), &predicates).clean(cx)\n+            }),\n         )\n     };\n     let polarity = tcx.impl_polarity(did);"}, {"sha": "49711551132638829779090ae34b732f1ec04c9e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 215, "deletions": 122, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -45,7 +45,7 @@ use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n-use crate::core::{self, DocContext};\n+use crate::core::{self, DocContext, ImplTraitParam};\n use crate::doctree;\n use crate::html::render::{cache, ExternalLocation};\n use crate::html::item_type::ItemType;\n@@ -136,94 +136,88 @@ pub struct Crate {\n     pub collapsed: bool,\n }\n \n-impl Clean<Crate> for hir::Crate {\n-    // note that self here is ignored in favor of `cx.tcx.hir().krate()` since\n-    // that gets around tying self's lifetime to the '_ in cx.\n-    fn clean(&self, cx: &DocContext<'_>) -> Crate {\n-        use crate::visit_lib::LibEmbargoVisitor;\n-\n-        let v = crate::visit_ast::RustdocVisitor::new(&cx);\n-        let module = v.visit(cx.tcx.hir().krate());\n-\n-        {\n-            let mut r = cx.renderinfo.borrow_mut();\n-            r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-            r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-            r.owned_box_did = cx.tcx.lang_items().owned_box();\n-        }\n-\n-        let mut externs = Vec::new();\n-        for &cnum in cx.tcx.crates().iter() {\n-            externs.push((cnum, cnum.clean(cx)));\n-            // Analyze doc-reachability for extern items\n-            LibEmbargoVisitor::new(cx).visit_lib(cnum);\n-        }\n-        externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-        // Clean the crate, translating the entire libsyntax AST to one that is\n-        // understood by rustdoc.\n-        let mut module = module.clean(cx);\n-        let mut masked_crates = FxHashSet::default();\n-\n-        match module.inner {\n-            ModuleItem(ref module) => {\n-                for it in &module.items {\n-                    // `compiler_builtins` should be masked too, but we can't apply\n-                    // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n-                    if it.is_extern_crate()\n-                        && (it.attrs.has_doc_flag(sym::masked)\n-                            || cx.tcx.is_compiler_builtins(it.def_id.krate))\n-                    {\n-                        masked_crates.insert(it.def_id.krate);\n-                    }\n+pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+    use crate::visit_lib::LibEmbargoVisitor;\n+\n+    let krate = cx.tcx.hir().krate();\n+    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n+\n+    let mut r = cx.renderinfo.get_mut();\n+    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+    r.owned_box_did = cx.tcx.lang_items().owned_box();\n+\n+    let mut externs = Vec::new();\n+    for &cnum in cx.tcx.crates().iter() {\n+        externs.push((cnum, cnum.clean(cx)));\n+        // Analyze doc-reachability for extern items\n+        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n+    }\n+    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+    // Clean the crate, translating the entire libsyntax AST to one that is\n+    // understood by rustdoc.\n+    let mut module = module.clean(cx);\n+    let mut masked_crates = FxHashSet::default();\n+\n+    match module.inner {\n+        ModuleItem(ref module) => {\n+            for it in &module.items {\n+                // `compiler_builtins` should be masked too, but we can't apply\n+                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n+                if it.is_extern_crate()\n+                    && (it.attrs.has_doc_flag(sym::masked)\n+                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                {\n+                    masked_crates.insert(it.def_id.krate);\n                 }\n             }\n-            _ => unreachable!(),\n         }\n+        _ => unreachable!(),\n+    }\n \n-        let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n-        {\n-            let m = match module.inner {\n-                ModuleItem(ref mut m) => m,\n-                _ => unreachable!(),\n-            };\n-            m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n-                Item {\n-                    source: Span::empty(),\n-                    name: Some(prim.to_url_str().to_string()),\n-                    attrs: attrs.clone(),\n-                    visibility: Some(Public),\n-                    stability: get_stability(cx, def_id),\n-                    deprecation: get_deprecation(cx, def_id),\n-                    def_id,\n-                    inner: PrimitiveItem(prim),\n-                }\n-            }));\n-            m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n-                Item {\n-                    source: Span::empty(),\n-                    name: Some(kw.clone()),\n-                    attrs: attrs,\n-                    visibility: Some(Public),\n-                    stability: get_stability(cx, def_id),\n-                    deprecation: get_deprecation(cx, def_id),\n-                    def_id,\n-                    inner: KeywordItem(kw),\n-                }\n-            }));\n-        }\n+    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n+    {\n+        let m = match module.inner {\n+            ModuleItem(ref mut m) => m,\n+            _ => unreachable!(),\n+        };\n+        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(prim.to_url_str().to_string()),\n+                attrs: attrs.clone(),\n+                visibility: Some(Public),\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: PrimitiveItem(prim),\n+            }\n+        }));\n+        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(kw.clone()),\n+                attrs: attrs,\n+                visibility: Some(Public),\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: KeywordItem(kw),\n+            }\n+        }));\n+    }\n \n-        Crate {\n-            name,\n-            version: None,\n-            src,\n-            module: Some(module),\n-            externs,\n-            primitives,\n-            external_traits: cx.external_traits.clone(),\n-            masked_crates,\n-            collapsed: false,\n-        }\n+    Crate {\n+        name,\n+        version: None,\n+        src,\n+        module: Some(module),\n+        externs,\n+        primitives,\n+        external_traits: cx.external_traits.clone(),\n+        masked_crates,\n+        collapsed: false,\n     }\n }\n \n@@ -572,23 +566,6 @@ pub enum ItemEnum {\n }\n \n impl ItemEnum {\n-    pub fn generics(&self) -> Option<&Generics> {\n-        Some(match *self {\n-            ItemEnum::StructItem(ref s) => &s.generics,\n-            ItemEnum::EnumItem(ref e) => &e.generics,\n-            ItemEnum::FunctionItem(ref f) => &f.generics,\n-            ItemEnum::TypedefItem(ref t, _) => &t.generics,\n-            ItemEnum::OpaqueTyItem(ref t, _) => &t.generics,\n-            ItemEnum::TraitItem(ref t) => &t.generics,\n-            ItemEnum::ImplItem(ref i) => &i.generics,\n-            ItemEnum::TyMethodItem(ref i) => &i.generics,\n-            ItemEnum::MethodItem(ref i) => &i.generics,\n-            ItemEnum::ForeignFunctionItem(ref f) => &f.generics,\n-            ItemEnum::TraitAliasItem(ref ta) => &ta.generics,\n-            _ => return None,\n-        })\n-    }\n-\n     pub fn is_associated(&self) -> bool {\n         match *self {\n             ItemEnum::TypedefItem(_, _) |\n@@ -1060,7 +1037,7 @@ pub enum GenericBound {\n \n impl GenericBound {\n     fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n-        let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n             Some(did), false, vec![], empty);\n@@ -1540,9 +1517,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n             }\n-            ty::GenericParamDefKind::Type { has_default, .. } => {\n-                cx.renderinfo.borrow_mut().external_param_names\n-                             .insert(self.def_id, self.name.clean(cx));\n+            ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default = if has_default {\n                     Some(cx.tcx.type_of(self.def_id).clean(cx))\n                 } else {\n@@ -1552,7 +1527,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n                     did: self.def_id,\n                     bounds: vec![], // These are filled in from the where-clauses.\n                     default,\n-                    synthetic: None,\n+                    synthetic,\n                 })\n             }\n             ty::GenericParamDefKind::Const { .. } => {\n@@ -1641,7 +1616,7 @@ impl Clean<Generics> for hir::Generics {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.borrow_mut().insert(did, bounds.clone());\n+                        cx.impl_trait_bounds.borrow_mut().insert(did.into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -1693,26 +1668,123 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a &'tcx ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n+        use std::collections::BTreeMap;\n \n         let (gens, preds) = *self;\n \n+        // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n+        // since `Clean for ty::Predicate` would consume them.\n+        let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n+\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n-            ty::GenericParamDefKind::Lifetime => None,\n-            ty::GenericParamDefKind::Type { .. } => {\n-                if param.name.as_symbol() == kw::SelfUpper {\n-                    assert_eq!(param.index, 0);\n-                    return None;\n+        let stripped_typarams = gens.params.iter()\n+            .filter_map(|param| match param.kind {\n+                ty::GenericParamDefKind::Lifetime => None,\n+                ty::GenericParamDefKind::Type { synthetic, .. } => {\n+                    if param.name.as_symbol() == kw::SelfUpper {\n+                        assert_eq!(param.index, 0);\n+                        return None;\n+                    }\n+                    if synthetic == Some(hir::SyntheticTyParamKind::ImplTrait) {\n+                        impl_trait.insert(param.index.into(), vec![]);\n+                        return None;\n+                    }\n+                    Some(param.clean(cx))\n+                }\n+                ty::GenericParamDefKind::Const { .. } => None,\n+            }).collect::<Vec<GenericParamDef>>();\n+\n+        // param index -> [(DefId of trait, associated type name, type)]\n+        let mut impl_trait_proj =\n+            FxHashMap::<u32, Vec<(DefId, String, Ty<'tcx>)>>::default();\n+\n+        let where_predicates = preds.predicates.iter()\n+            .flat_map(|(p, _)| {\n+                let mut projection = None;\n+                let param_idx = (|| {\n+                    if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n+                        if let ty::Param(param) = trait_ref.self_ty().sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let Some(outlives) = p.to_opt_type_outlives() {\n+                        if let ty::Param(param) = outlives.skip_binder().0.sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let ty::Predicate::Projection(p) = p {\n+                        if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().sty {\n+                            projection = Some(p);\n+                            return Some(param.index);\n+                        }\n+                    }\n+\n+                    None\n+                })();\n+\n+                if let Some(param_idx) = param_idx {\n+                    if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n+                        let p = p.clean(cx)?;\n+\n+                        b.extend(\n+                            p.get_bounds()\n+                                .into_iter()\n+                                .flatten()\n+                                .cloned()\n+                                .filter(|b| !b.is_sized_bound(cx))\n+                        );\n+\n+                        let proj = projection\n+                            .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n+                        if let Some(((_, trait_did, name), rhs)) =\n+                            proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                        {\n+                            impl_trait_proj\n+                                .entry(param_idx)\n+                                .or_default()\n+                                .push((trait_did, name.to_string(), rhs));\n+                        }\n+\n+                        return None;\n+                    }\n+                }\n+\n+                Some(p)\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for (param, mut bounds) in impl_trait {\n+            // Move trait bounds to the front.\n+            bounds.sort_by_key(|b| if let GenericBound::TraitBound(..) = b {\n+                false\n+            } else {\n+                true\n+            });\n+\n+            if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n+                if let Some(proj) = impl_trait_proj.remove(&idx) {\n+                    for (trait_did, name, rhs) in proj {\n+                        simplify::merge_bounds(\n+                            cx,\n+                            &mut bounds,\n+                            trait_did,\n+                            &name,\n+                            &rhs.clean(cx),\n+                        );\n+                    }\n                 }\n-                Some(param.clean(cx))\n+            } else {\n+                unreachable!();\n             }\n-            ty::GenericParamDefKind::Const { .. } => None,\n-        }).collect::<Vec<GenericParamDef>>();\n \n-        let mut where_predicates = preds.predicates.iter()\n-            .flat_map(|(p, _)| p.clean(cx))\n+            cx.impl_trait_bounds.borrow_mut().insert(param, bounds);\n+        }\n+\n+        // Now that `cx.impl_trait_bounds` is populated, we can process\n+        // remaining predicates which could contain `impl Trait`.\n+        let mut where_predicates = where_predicates\n+            .into_iter()\n+            .flat_map(|p| p.clean(cx))\n             .collect::<Vec<_>>();\n \n         // Type parameters and have a Sized bound by default unless removed with\n@@ -2023,7 +2095,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].pat),\n+                    name: name_from_pat(&body.params[i].pat),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()\n@@ -2613,6 +2685,21 @@ impl Type {\n             _ => false,\n         }\n     }\n+\n+    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+        let (self_, trait_, name) = match self {\n+            QPath { ref self_type, ref trait_, ref name } => {\n+                (self_type, trait_, name)\n+            }\n+            _ => return None,\n+        };\n+        let trait_did = match **trait_ {\n+            ResolvedPath { did, .. } => did,\n+            _ => return None,\n+        };\n+        Some((&self_, trait_did, name))\n+    }\n+\n }\n \n impl GetDefId for Type {\n@@ -2791,7 +2878,7 @@ impl Clean<Type> for hir::Ty {\n                     if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n                         return new_ty;\n                     }\n-                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n+                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n                         return ImplTrait(bounds);\n                     }\n                 }\n@@ -3082,7 +3169,13 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Projection(ref data) => data.clean(cx),\n \n-            ty::Param(ref p) => Generic(p.name.to_string()),\n+            ty::Param(ref p) => {\n+                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&p.index.into()) {\n+                    ImplTrait(bounds)\n+                } else {\n+                    Generic(p.name.to_string())\n+                }\n+            }\n \n             ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n@@ -3686,7 +3779,7 @@ pub struct BareFunctionDecl {\n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n-            (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n+            (self.generic_params.clean(cx), (&*self.decl, &self.param_names[..]).clean(cx))\n         });\n         BareFunctionDecl {\n             unsafety: self.unsafety,"}, {"sha": "8758ab19691163ab4f93e847ed21d0c31d08b459", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -53,58 +53,21 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // Look for equality predicates on associated types that can be merged into\n     // general bound predicates\n     equalities.retain(|&(ref lhs, ref rhs)| {\n-        let (self_, trait_, name) = match *lhs {\n-            clean::QPath { ref self_type, ref trait_, ref name } => {\n-                (self_type, trait_, name)\n-            }\n-            _ => return true,\n-        };\n-        let generic = match **self_ {\n-            clean::Generic(ref s) => s,\n-            _ => return true,\n+        let (self_, trait_did, name) = if let Some(p) = lhs.projection() {\n+            p\n+        } else {\n+            return true;\n         };\n-        let trait_did = match **trait_ {\n-            clean::ResolvedPath { did, .. } => did,\n+        let generic = match self_ {\n+            clean::Generic(s) => s,\n             _ => return true,\n         };\n         let bounds = match params.get_mut(generic) {\n             Some(bound) => bound,\n             None => return true,\n         };\n-        !bounds.iter_mut().any(|b| {\n-            let trait_ref = match *b {\n-                clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n-                clean::GenericBound::Outlives(..) => return false,\n-            };\n-            let (did, path) = match trait_ref.trait_ {\n-                clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n-                _ => return false,\n-            };\n-            // If this QPath's trait `trait_did` is the same as, or a supertrait\n-            // of, the bound's trait `did` then we can keep going, otherwise\n-            // this is just a plain old equality bound.\n-            if !trait_is_same_or_supertrait(cx, did, trait_did) {\n-                return false\n-            }\n-            let last = path.segments.last_mut().expect(\"segments were empty\");\n-            match last.args {\n-                PP::AngleBracketed { ref mut bindings, .. } => {\n-                    bindings.push(clean::TypeBinding {\n-                        name: name.clone(),\n-                        kind: clean::TypeBindingKind::Equality {\n-                            ty: rhs.clone(),\n-                        },\n-                    });\n-                }\n-                PP::Parenthesized { ref mut output, .. } => {\n-                    assert!(output.is_none());\n-                    if *rhs != clean::Type::Tuple(Vec::new()) {\n-                        *output = Some(rhs.clone());\n-                    }\n-                }\n-            };\n-            true\n-        })\n+\n+        merge_bounds(cx, bounds, trait_did, name, rhs)\n     });\n \n     // And finally, let's reassemble everything\n@@ -127,6 +90,49 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n+pub fn merge_bounds(\n+    cx: &clean::DocContext<'_>,\n+    bounds: &mut Vec<clean::GenericBound>,\n+    trait_did: DefId,\n+    name: &str,\n+    rhs: &clean::Type,\n+) -> bool {\n+    !bounds.iter_mut().any(|b| {\n+        let trait_ref = match *b {\n+            clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n+            clean::GenericBound::Outlives(..) => return false,\n+        };\n+        let (did, path) = match trait_ref.trait_ {\n+            clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n+            _ => return false,\n+        };\n+        // If this QPath's trait `trait_did` is the same as, or a supertrait\n+        // of, the bound's trait `did` then we can keep going, otherwise\n+        // this is just a plain old equality bound.\n+        if !trait_is_same_or_supertrait(cx, did, trait_did) {\n+            return false\n+        }\n+        let last = path.segments.last_mut().expect(\"segments were empty\");\n+        match last.args {\n+            PP::AngleBracketed { ref mut bindings, .. } => {\n+                bindings.push(clean::TypeBinding {\n+                    name: name.to_string(),\n+                    kind: clean::TypeBindingKind::Equality {\n+                        ty: rhs.clone(),\n+                    },\n+                });\n+            }\n+            PP::Parenthesized { ref mut output, .. } => {\n+                assert!(output.is_none());\n+                if *rhs != clean::Type::Tuple(Vec::new()) {\n+                    *output = Some(rhs.clone());\n+                }\n+            }\n+        };\n+        true\n+    })\n+}\n+\n pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericParamDef> {\n     for param in &mut params {\n         match param.kind {"}, {"sha": "d261408fc148ac348b66f1371ce8b9d95d5d90ac", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -6,6 +6,7 @@ use errors;\n use getopts;\n use rustc::lint::Level;\n use rustc::session;\n+use rustc::session::config::{CrateType, parse_crate_types_from_list};\n use rustc::session::config::{CodegenOptions, DebuggingOptions, ErrorOutputType, Externs};\n use rustc::session::config::{nightly_options, build_codegen_options, build_debugging_options,\n                              get_cmd_lint_options, ExternEntry};\n@@ -32,16 +33,24 @@ pub struct Options {\n     pub input: PathBuf,\n     /// The name of the crate being documented.\n     pub crate_name: Option<String>,\n+    /// Whether or not this is a proc-macro crate\n+    pub proc_macro_crate: bool,\n     /// How to format errors and warnings.\n     pub error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n     pub libs: Vec<SearchPath>,\n+    /// Library search paths strings to hand to the compiler.\n+    pub lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n     pub externs: Externs,\n+    /// The list of external crates strings to link against.\n+    pub extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n     pub cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n     pub codegen_options: CodegenOptions,\n+    /// Codegen options strings to hand to the compiler.\n+    pub codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n     pub debugging_options: DebuggingOptions,\n     /// The target used to compile the crate against.\n@@ -51,8 +60,6 @@ pub struct Options {\n     pub edition: Edition,\n     /// The path to the sysroot. Used during the compilation process.\n     pub maybe_sysroot: Option<PathBuf>,\n-    /// Linker to use when building doctests.\n-    pub linker: Option<PathBuf>,\n     /// Lint information passed over the command-line.\n     pub lint_opts: Vec<(String, Level)>,\n     /// Whether to ask rustc to describe the lints it knows. Practically speaking, this will not be\n@@ -111,6 +118,7 @@ impl fmt::Debug for Options {\n         f.debug_struct(\"Options\")\n             .field(\"input\", &self.input)\n             .field(\"crate_name\", &self.crate_name)\n+            .field(\"proc_macro_crate\", &self.proc_macro_crate)\n             .field(\"error_format\", &self.error_format)\n             .field(\"libs\", &self.libs)\n             .field(\"externs\", &FmtExterns(&self.externs))\n@@ -120,7 +128,6 @@ impl fmt::Debug for Options {\n             .field(\"target\", &self.target)\n             .field(\"edition\", &self.edition)\n             .field(\"maybe_sysroot\", &self.maybe_sysroot)\n-            .field(\"linker\", &self.linker)\n             .field(\"lint_opts\", &self.lint_opts)\n             .field(\"describe_lints\", &self.describe_lints)\n             .field(\"lint_cap\", &self.lint_cap)\n@@ -431,11 +438,19 @@ impl Options {\n         };\n         let manual_passes = matches.opt_strs(\"passes\");\n \n+        let crate_types = match parse_crate_types_from_list(matches.opt_strs(\"crate-type\")) {\n+            Ok(types) => types,\n+            Err(e) =>{\n+                diag.struct_err(&format!(\"unknown crate type: {}\", e)).emit();\n+                return Err(1);\n+            }\n+        };\n+\n         let crate_name = matches.opt_str(\"crate-name\");\n+        let proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n         let playground_url = matches.opt_str(\"playground-url\");\n         let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n         let display_warnings = matches.opt_present(\"display-warnings\");\n-        let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n         let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n         let resource_suffix = matches.opt_str(\"resource-suffix\").unwrap_or_default();\n         let enable_minification = !matches.opt_present(\"disable-minification\");\n@@ -448,22 +463,28 @@ impl Options {\n         let generate_search_filter = !matches.opt_present(\"disable-per-crate-search\");\n         let persist_doctests = matches.opt_str(\"persist-doctests\").map(PathBuf::from);\n         let generate_redirect_pages = matches.opt_present(\"generate-redirect-pages\");\n+        let codegen_options_strs = matches.opt_strs(\"C\");\n+        let lib_strs = matches.opt_strs(\"L\");\n+        let extern_strs = matches.opt_strs(\"extern\");\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n         Ok(Options {\n             input,\n             crate_name,\n+            proc_macro_crate,\n             error_format,\n             libs,\n+            lib_strs,\n             externs,\n+            extern_strs,\n             cfgs,\n             codegen_options,\n+            codegen_options_strs,\n             debugging_options,\n             target,\n             edition,\n             maybe_sysroot,\n-            linker,\n             lint_opts,\n             describe_lints,\n             lint_cap,"}, {"sha": "9cfcad4271966b212a72f7bfd8a71d2daf183af2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -30,7 +30,7 @@ use std::rc::Rc;\n \n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::clean;\n-use crate::clean::{Clean, MAX_DEF_ID, AttributesExt};\n+use crate::clean::{MAX_DEF_ID, AttributesExt};\n use crate::html::render::RenderInfo;\n \n use crate::passes;\n@@ -61,8 +61,8 @@ pub struct DocContext<'tcx> {\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n     /// Table `DefId` of const parameter -> substituted const\n     pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n-    /// Table DefId of `impl Trait` in argument position -> bounds\n-    pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::GenericBound>>>,\n+    /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n+    pub impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n@@ -193,6 +193,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n                     source_map.map(|cm| cm as _),\n                     short,\n                     sessopts.debugging_opts.teach,\n+                    sessopts.debugging_opts.terminal_width,\n                 ).ui_testing(ui_testing)\n             )\n         },\n@@ -228,6 +229,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let RustdocOptions {\n         input,\n         crate_name,\n+        proc_macro_crate,\n         error_format,\n         libs,\n         externs,\n@@ -293,11 +295,16 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     }).collect();\n \n     let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let crate_types = if proc_macro_crate {\n+        vec![config::CrateType::ProcMacro]\n+    } else {\n+        vec![config::CrateType::Rlib]\n+    };\n     // plays with error output here!\n     let sessopts = config::Options {\n         maybe_sysroot,\n         search_paths: libs,\n-        crate_types: vec![config::CrateType::Rlib],\n+        crate_types,\n         lint_opts: if !display_warnings {\n             lint_opts\n         } else {\n@@ -363,7 +370,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut renderinfo = RenderInfo::default();\n             renderinfo.access_levels = access_levels;\n \n-            let ctxt = DocContext {\n+            let mut ctxt = DocContext {\n                 tcx,\n                 resolver,\n                 cstore: compiler.cstore().clone(),\n@@ -383,7 +390,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             };\n             debug!(\"crate: {:?}\", tcx.hir().krate());\n \n-            let mut krate = tcx.hir().krate().clean(&ctxt);\n+            let mut krate = clean::krate(&mut ctxt);\n \n             fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n                 let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n@@ -459,3 +466,23 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         })\n     })\n }\n+\n+/// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n+/// for `impl Trait` in argument position.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum ImplTraitParam {\n+    DefId(DefId),\n+    ParamIndex(u32),\n+}\n+\n+impl From<DefId> for ImplTraitParam {\n+    fn from(did: DefId) -> Self {\n+        ImplTraitParam::DefId(did)\n+    }\n+}\n+\n+impl From<u32> for ImplTraitParam {\n+    fn from(idx: u32) -> Self {\n+        ImplTraitParam::ParamIndex(idx)\n+    }\n+}"}, {"sha": "313734e3fdd6b339a85a1f88eafcadff830b0960", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 69, "deletions": 77, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -6,6 +6,7 @@\n //! them in the future to instead emit any format desired.\n \n use std::borrow::Cow;\n+use std::cell::Cell;\n use std::fmt;\n \n use rustc::hir::def_id::DefId;\n@@ -15,7 +16,7 @@ use rustc::hir;\n \n use crate::clean::{self, PrimitiveType};\n use crate::html::item_type::ItemType;\n-use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n+use crate::html::render::{self, cache, CURRENT_DEPTH};\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n@@ -36,13 +37,8 @@ pub struct AsyncSpace(pub hir::IsAsync);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n-/// Similar to VisSpace, but used for mutability\n-#[derive(Copy, Clone)]\n-pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n-/// Wrapper struct for emitting a comma-separated list of items\n-pub struct CommaSep<'a, T>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n pub struct DefaultSpace(pub bool);\n \n@@ -71,11 +67,6 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-pub struct HRef<'a> {\n-    pub did: DefId,\n-    pub text: &'a str,\n-}\n-\n impl<'a> VisSpace<'a> {\n     pub fn get(self) -> &'a Option<clean::Visibility> {\n         let VisSpace(v) = self; v\n@@ -94,14 +85,14 @@ impl ConstnessSpace {\n     }\n }\n \n-impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, item) in self.0.iter().enumerate() {\n+fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        for (i, item) in items.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n             fmt::Display::fmt(item, f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n impl<'a> fmt::Display for GenericBounds<'a> {\n@@ -168,9 +159,9 @@ impl fmt::Display for clean::Generics {\n             return Ok(());\n         }\n         if f.alternate() {\n-            write!(f, \"<{:#}>\", CommaSep(&real_params))\n+            write!(f, \"<{:#}>\", comma_sep(&real_params))\n         } else {\n-            write!(f, \"&lt;{}&gt;\", CommaSep(&real_params))\n+            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n         }\n     }\n }\n@@ -268,9 +259,9 @@ impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n             }\n         }\n         if f.alternate() {\n@@ -407,16 +398,16 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         return None\n     }\n \n-    let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n+    let depth = CURRENT_DEPTH.with(|l| l.get());\n     let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => {\n-            (fqp, shortty, \"../\".repeat(loc.len()))\n+            (fqp, shortty, \"../\".repeat(depth))\n         }\n         None => {\n             let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n             (fqp, shortty, match cache.extern_locations[&did.krate] {\n                 (.., render::Remote(ref s)) => s.to_string(),\n-                (.., render::Local) => \"../\".repeat(loc.len()),\n+                (.., render::Local) => \"../\".repeat(depth),\n                 (.., render::Unknown) => return None,\n             })\n         }\n@@ -452,19 +443,18 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.args)?;\n+        write!(w, \"{}{:#}\", &last.name, last.args)?;\n     } else {\n         let path = if use_absolute {\n-            match href(did) {\n-                Some((_, _, fqp)) => {\n-                    format!(\"{}::{}\",\n-                            fqp[..fqp.len() - 1].join(\"::\"),\n-                            HRef::new(did, fqp.last().unwrap()))\n-                }\n-                None => HRef::new(did, &last.name).to_string(),\n+            if let Some((_, _, fqp)) = href(did) {\n+                format!(\"{}::{}\",\n+                        fqp[..fqp.len() - 1].join(\"::\"),\n+                        anchor(did, fqp.last().unwrap()))\n+            } else {\n+                last.name.to_string()\n             }\n         } else {\n-            HRef::new(did, &last.name).to_string()\n+            anchor(did, &last.name).to_string()\n         };\n         write!(w, \"{}{}\", path, last.args)?;\n     }\n@@ -479,7 +469,7 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n             Some(&def_id) if def_id.is_local() => {\n-                let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                let len = CURRENT_DEPTH.with(|s| s.get());\n                 let len = if len == 0 {0} else {len - 1};\n                 write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n                        \"../\".repeat(len),\n@@ -492,7 +482,7 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n                         Some((cname, s.to_string()))\n                     }\n                     (ref cname, _, render::Local) => {\n-                        let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                        let len = CURRENT_DEPTH.with(|s| s.get());\n                         Some((cname, \"../\".repeat(len)))\n                     }\n                     (.., render::Unknown) => None,\n@@ -516,38 +506,30 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut fmt::Formatter<'_>,\n-            param_names: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n-    match *param_names {\n-        Some(ref params) => {\n-            for param in params {\n-                write!(w, \" + \")?;\n-                fmt::Display::fmt(param, w)?;\n+fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        match *param_names {\n+            Some(ref params) => {\n+                for param in params {\n+                    write!(f, \" + \")?;\n+                    fmt::Display::fmt(param, f)?;\n+                }\n+                Ok(())\n             }\n-            Ok(())\n+            None => Ok(())\n         }\n-        None => Ok(())\n-    }\n-}\n-\n-impl<'a> HRef<'a> {\n-    pub fn new(did: DefId, text: &'a str) -> HRef<'a> {\n-        HRef { did: did, text: text }\n-    }\n+    })\n }\n \n-impl<'a> fmt::Display for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match href(self.did) {\n-            Some((url, shortty, fqp)) => if !f.alternate() {\n-                write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n-                       shortty, url, shortty, fqp.join(\"::\"), self.text)\n-            } else {\n-                write!(f, \"{}\", self.text)\n-            },\n-            _ => write!(f, \"{}\", self.text),\n+pub fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        if let Some((url, short_ty, fqp)) = href(did) {\n+            write!(f, r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n+                short_ty, url, short_ty, fqp.join(\"::\"), text)\n+        } else {\n+            write!(f, \"{}\", text)\n         }\n-    }\n+    })\n }\n \n fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n@@ -561,7 +543,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n-            tybounds(f, param_names)\n+            fmt::Display::fmt(&tybounds(param_names), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n@@ -570,12 +552,12 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n                        UnsafetySpace(decl.unsafety),\n                        AbiSpace(decl.abi),\n-                       CommaSep(&decl.generic_params),\n+                       comma_sep(&decl.generic_params),\n                        decl.decl)\n             } else {\n                 write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", CommaSep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -589,7 +571,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&CommaSep(many), f)?;\n+                    fmt::Display::fmt(&comma_sep(many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n@@ -607,19 +589,22 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n         clean::CVarArgs => primitive_link(f, PrimitiveType::CVarArgs, \"...\"),\n         clean::RawPointer(m, ref t) => {\n+            let m = match m {\n+                clean::Immutable => \"const\",\n+                clean::Mutable => \"mut\",\n+            };\n             match **t {\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                                       &format!(\"*{} {:#}\", m, t))\n                     } else {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                                       &format!(\"*{} {}\", m, t))\n                     }\n                 }\n                 _ => {\n-                    primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                   &format!(\"*{}\", RawMutableSpace(m)))?;\n+                    primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n                     fmt::Display::fmt(t, f)\n                 }\n             }\n@@ -1047,15 +1032,6 @@ impl fmt::Display for MutableSpace {\n     }\n }\n \n-impl fmt::Display for RawMutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n-            RawMutableSpace(clean::Mutable) => write!(f, \"mut \"),\n-        }\n-    }\n-}\n-\n impl fmt::Display for AbiSpace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n@@ -1075,3 +1051,19 @@ impl fmt::Display for DefaultSpace {\n         }\n     }\n }\n+\n+crate fn display_fn(\n+    f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+) -> impl fmt::Display {\n+    WithFormatter(Cell::new(Some(f)))\n+}\n+\n+struct WithFormatter<F>(Cell<Option<F>>);\n+\n+impl<F> fmt::Display for WithFormatter<F>\n+    where F: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0.take()).unwrap()(f)\n+    }\n+}"}, {"sha": "74413a7f905d45fc0bf5c7bc92aac504bcf18efe", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -785,10 +785,6 @@ impl MarkdownSummaryLine<'_> {\n }\n \n pub fn plain_summary_line(md: &str) -> String {\n-    plain_summary_line_full(md, false)\n-}\n-\n-pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n     struct ParserWrapper<'a> {\n         inner: Parser<'a>,\n         is_in: isize,\n@@ -834,21 +830,7 @@ pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n             s.push_str(&t);\n         }\n     }\n-    if limit_length && s.chars().count() > 60 {\n-        let mut len = 0;\n-        let mut ret = s.split_whitespace()\n-                       .take_while(|p| {\n-                           // + 1 for the added character after the word.\n-                           len += p.chars().count() + 1;\n-                           len < 60\n-                       })\n-                       .collect::<Vec<_>>()\n-                       .join(\" \");\n-        ret.push('\u2026');\n-        ret\n-    } else {\n-        s\n-    }\n+    s\n }\n \n pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {"}, {"sha": "d5c47a15948fb4c30538e429c9e89ee2acc17860", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 112, "deletions": 309, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -28,7 +28,7 @@\n pub use self::ExternalLocation::*;\n \n use std::borrow::Cow;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n@@ -72,6 +72,7 @@ use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use crate::html::{highlight, layout, static_files};\n+use crate::html::sources;\n \n use minifier;\n \n@@ -173,7 +174,7 @@ struct Context {\n     playground: Option<markdown::Playground>,\n }\n \n-struct SharedContext {\n+crate struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -218,7 +219,7 @@ struct SharedContext {\n }\n \n impl SharedContext {\n-    fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n+    crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n             try_err!(self.fs.create_dir_all(dst), dst);\n@@ -281,11 +282,6 @@ impl Impl {\n /// rendering threads.\n #[derive(Default)]\n pub struct Cache {\n-    /// Mapping of typaram ids to the name of the type parameter. This is used\n-    /// when pretty-printing a type (so pretty-printing doesn't have to\n-    /// painfully maintain a context like this)\n-    pub param_names: FxHashMap<DefId, String>,\n-\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n@@ -381,26 +377,13 @@ pub struct Cache {\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n     pub external_paths: crate::core::ExternalPaths,\n-    pub external_param_names: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub access_levels: AccessLevels<DefId>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n     pub owned_box_did: Option<DefId>,\n }\n \n-/// Helper struct to render all source code to HTML pages\n-struct SourceCollector<'a> {\n-    scx: &'a mut SharedContext,\n-\n-    /// Root destination to place all HTML output into\n-    dst: PathBuf,\n-}\n-\n-/// Wrapper struct to render the source code of a file. This will do things like\n-/// adding line numbers to the left-hand side.\n-struct Source<'a>(&'a str);\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n@@ -496,7 +479,7 @@ impl ToJson for IndexItemFunctionType {\n }\n \n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n-thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> = RefCell::new(Vec::new()));\n+thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n pub fn initial_ids() -> Vec<String> {\n     [\n@@ -612,7 +595,7 @@ pub fn run(mut krate: clean::Crate,\n     }\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n-    krate = render_sources(&dst, &mut scx, krate)?;\n+    krate = sources::render(&dst, &mut scx, krate)?;\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n@@ -628,7 +611,6 @@ pub fn run(mut krate: clean::Crate,\n     let RenderInfo {\n         inlined: _,\n         external_paths,\n-        external_param_names,\n         exact_paths,\n         access_levels,\n         deref_trait_did,\n@@ -662,7 +644,6 @@ pub fn run(mut krate: clean::Crate,\n         deref_mut_trait_did,\n         owned_box_did,\n         masked_crates: mem::take(&mut krate.masked_crates),\n-        param_names: external_param_names,\n         aliases: Default::default(),\n     };\n \n@@ -714,7 +695,7 @@ pub fn run(mut krate: clean::Crate,\n     // for future parallelization opportunities\n     let cache = Arc::new(cache);\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-    CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n+    CURRENT_DEPTH.with(|s| s.set(0));\n \n     // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n@@ -751,7 +732,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: plain_summary_line_short(item.doc_value()),\n+                desc: shorten(plain_summary_line(item.doc_value())),\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n@@ -789,7 +770,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     }\n \n     let crate_doc = krate.module.as_ref().map(|module| {\n-        plain_summary_line_short(module.doc_value())\n+        shorten(plain_summary_line(module.doc_value()))\n     }).unwrap_or(String::new());\n \n     let mut crate_data = BTreeMap::new();\n@@ -876,22 +857,22 @@ r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n function showThemeButtonState() {{\n-    themes.style.display = \"none\";\n-    themePicker.style.borderBottomRightRadius = \"3px\";\n-    themePicker.style.borderBottomLeftRadius = \"3px\";\n-}}\n-\n-function hideThemeButtonState() {{\n     themes.style.display = \"block\";\n     themePicker.style.borderBottomRightRadius = \"0\";\n     themePicker.style.borderBottomLeftRadius = \"0\";\n }}\n \n+function hideThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n function switchThemeButtonState() {{\n     if (themes.style.display === \"block\") {{\n-        showThemeButtonState();\n-    }} else {{\n         hideThemeButtonState();\n+    }} else {{\n+        showThemeButtonState();\n     }}\n }};\n \n@@ -914,7 +895,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     var but = document.createElement('button');\n     but.innerHTML = item;\n     but.onclick = function(el) {{\n-        switchTheme(currentTheme, mainTheme, item);\n+        switchTheme(currentTheme, mainTheme, item, true);\n     }};\n     but.onblur = handleThemeButtonsBlur;\n     themes.appendChild(but);\n@@ -1293,18 +1274,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n     Ok(())\n }\n \n-fn render_sources(dst: &Path, scx: &mut SharedContext,\n-                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n-    info!(\"emitting source files\");\n-    let dst = dst.join(\"src\").join(&krate.name);\n-    scx.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector {\n-        dst,\n-        scx,\n-    };\n-    Ok(folder.fold_crate(krate))\n-}\n-\n fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bool\n                 ) -> Result<(), Error> {\n     if enable_minification {\n@@ -1384,33 +1353,6 @@ fn write_minify_replacer<W: Write>(\n     }\n }\n \n-/// Takes a path to a source file and cleans the path to it. This canonicalizes\n-/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n-/// static HTML tree. Each component in the cleaned path will be passed as an\n-/// argument to `f`. The very last component of the path (ie the file name) will\n-/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n-where\n-    F: FnMut(&OsStr),\n-{\n-    // make it relative, if possible\n-    let p = p.strip_prefix(src_root).unwrap_or(p);\n-\n-    let mut iter = p.components().peekable();\n-\n-    while let Some(c) = iter.next() {\n-        if !keep_filename && iter.peek().is_none() {\n-            break;\n-        }\n-\n-        match c {\n-            Component::ParentDir => f(\"up\".as_ref()),\n-            Component::Normal(c) => f(c),\n-            _ => continue,\n-        }\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n@@ -1444,102 +1386,6 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n     }).next().unwrap_or(Unknown) // Well, at least we tried.\n }\n \n-impl<'a> DocFolder for SourceCollector<'a> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If we're including source files, and we haven't seen this file yet,\n-        // then we need to render it out to the filesystem.\n-        if self.scx.include_sources\n-            // skip all invalid or macro spans\n-            && item.source.filename.is_real()\n-            // skip non-local items\n-            && item.def_id.is_local() {\n-\n-            // If it turns out that we couldn't read this file, then we probably\n-            // can't read any of the files (generating html output from json or\n-            // something like that), so just don't include sources for the\n-            // entire crate. The other option is maintaining this mapping on a\n-            // per-file basis, but that's probably not worth it...\n-            self.scx\n-                .include_sources = match self.emit_source(&item.source.filename) {\n-                Ok(()) => true,\n-                Err(e) => {\n-                    println!(\"warning: source code was requested to be rendered, \\\n-                              but processing `{}` had an error: {}\",\n-                             item.source.filename, e);\n-                    println!(\"         skipping rendering of source code\");\n-                    false\n-                }\n-            };\n-        }\n-        self.fold_item_recur(item)\n-    }\n-}\n-\n-impl<'a> SourceCollector<'a> {\n-    /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n-        let p = match *filename {\n-            FileName::Real(ref file) => file,\n-            _ => return Ok(()),\n-        };\n-        if self.scx.local_sources.contains_key(&**p) {\n-            // We've already emitted this source\n-            return Ok(());\n-        }\n-\n-        let contents = try_err!(fs::read_to_string(&p), &p);\n-\n-        // Remove the utf-8 BOM if any\n-        let contents = if contents.starts_with(\"\\u{feff}\") {\n-            &contents[3..]\n-        } else {\n-            &contents[..]\n-        };\n-\n-        // Create the intermediate directories\n-        let mut cur = self.dst.clone();\n-        let mut root_path = String::from(\"../../\");\n-        let mut href = String::new();\n-        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n-            cur.push(component);\n-            root_path.push_str(\"../\");\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n-        });\n-        self.scx.ensure_dir(&cur)?;\n-        let mut fname = p.file_name()\n-                         .expect(\"source has no filename\")\n-                         .to_os_string();\n-        fname.push(\".html\");\n-        cur.push(&fname);\n-        href.push_str(&fname.to_string_lossy());\n-\n-        let mut v = Vec::new();\n-        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n-                                               .to_string_lossy());\n-        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n-        let page = layout::Page {\n-            title: &title,\n-            css_class: \"source\",\n-            root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.as_deref(),\n-            description: &desc,\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n-        };\n-        try_err!(layout::render(&mut v, &self.scx.layout,\n-                       &page, &(\"\"), &Source(contents),\n-                       self.scx.css_file_extension.is_some(),\n-                       &self.scx.themes,\n-                       self.scx.generate_search_filter), &cur);\n-        self.scx.fs.write(&cur, &v)?;\n-        self.scx.local_sources.insert(p.clone(), href);\n-        Ok(())\n-    }\n-}\n-\n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n@@ -1565,12 +1411,6 @@ impl DocFolder for Cache {\n             }\n         }\n \n-        // Register any generics to their corresponding string. This is used\n-        // when pretty-printing types.\n-        if let Some(generics) = item.inner.generics() {\n-            self.generics(generics);\n-        }\n-\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = item.inner {\n@@ -1642,7 +1482,7 @@ impl DocFolder for Cache {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n-                            desc: plain_summary_line_short(item.doc_value()),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n@@ -1803,18 +1643,6 @@ impl DocFolder for Cache {\n }\n \n impl Cache {\n-    fn generics(&mut self, generics: &clean::Generics) {\n-        for param in &generics.params {\n-            match param.kind {\n-                clean::GenericParamDefKind::Lifetime => {}\n-                clean::GenericParamDefKind::Type { did, .. } |\n-                clean::GenericParamDefKind::Const { did, .. } => {\n-                    self.param_names.insert(did, param.name.clone());\n-                }\n-            }\n-        }\n-    }\n-\n     fn add_aliases(&mut self, item: &clean::Item) {\n         if item.def_id.index == CRATE_DEF_INDEX {\n             return\n@@ -1836,7 +1664,7 @@ impl Cache {\n                                 ty: item.type_(),\n                                 name: item_name.to_string(),\n                                 path: path.clone(),\n-                                desc: plain_summary_line_short(item.doc_value()),\n+                                desc: shorten(plain_summary_line(item.doc_value())),\n                                 parent: None,\n                                 parent_idx: None,\n                                 search_type: get_index_search_type(&item),\n@@ -2057,31 +1885,6 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Recurse in the directory structure and change the \"root path\" to make\n-    /// sure it always points to the top (relatively).\n-    fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n-        F: FnOnce(&mut Context) -> T,\n-    {\n-        if s.is_empty() {\n-            panic!(\"Unexpected empty destination: {:?}\", self.current);\n-        }\n-        let prev = self.dst.clone();\n-        self.dst.push(&s);\n-        self.current.push(s);\n-\n-        info!(\"Recursing into {}\", self.dst.display());\n-\n-        let ret = f(self);\n-\n-        info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-        // Go back to where we were at\n-        self.dst = prev;\n-        self.current.pop().unwrap();\n-\n-        ret\n-    }\n-\n     /// Main method for rendering a crate.\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n@@ -2175,8 +1978,8 @@ impl Context {\n                    -> io::Result<()> {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n-        CURRENT_LOCATION_KEY.with(|slot| {\n-            *slot.borrow_mut() = self.current.clone();\n+        CURRENT_DEPTH.with(|slot| {\n+            slot.set(self.current.len());\n         });\n \n         let mut title = if it.is_primitive() || it.is_keyword() {\n@@ -2262,42 +2065,50 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             let name = item.name.as_ref().unwrap().to_string();\n-            let mut item = Some(item);\n-            let scx = self.shared.clone();\n-            self.recurse(name, |this| {\n-                let item = item.take().unwrap();\n-\n-                let mut buf = Vec::new();\n-                this.render_item(&mut buf, &item, false).unwrap();\n-                // buf will be empty if the module is stripped and there is no redirect for it\n-                if !buf.is_empty() {\n-                    this.shared.ensure_dir(&this.dst)?;\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    scx.fs.write(&joint_dst, buf)?;\n-                }\n+            let scx = &self.shared;\n+            if name.is_empty() {\n+                panic!(\"Unexpected empty destination: {:?}\", self.current);\n+            }\n+            let prev = self.dst.clone();\n+            self.dst.push(&name);\n+            self.current.push(name);\n \n-                let m = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(m)) |\n-                    clean::ModuleItem(m) => m,\n-                    _ => unreachable!()\n-                };\n+            info!(\"Recursing into {}\", self.dst.display());\n \n-                // Render sidebar-items.js used throughout this module.\n-                if !this.render_redirect_pages {\n-                    let items = this.build_sidebar_items(&m);\n-                    let js_dst = this.dst.join(\"sidebar-items.js\");\n-                    let mut v = Vec::new();\n-                    try_err!(write!(&mut v, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    scx.fs.write(&js_dst, &v)?;\n-                }\n+            let mut buf = Vec::new();\n+            self.render_item(&mut buf, &item, false).unwrap();\n+            // buf will be empty if the module is stripped and there is no redirect for it\n+            if !buf.is_empty() {\n+                self.shared.ensure_dir(&self.dst)?;\n+                let joint_dst = self.dst.join(\"index.html\");\n+                scx.fs.write(&joint_dst, buf)?;\n+            }\n \n-                for item in m.items {\n-                    f(this, item);\n-                }\n+            let m = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) |\n+                clean::ModuleItem(m) => m,\n+                _ => unreachable!()\n+            };\n+\n+            // Render sidebar-items.js used throughout this module.\n+            if !self.render_redirect_pages {\n+                let items = self.build_sidebar_items(&m);\n+                let js_dst = self.dst.join(\"sidebar-items.js\");\n+                let mut v = Vec::new();\n+                try_err!(write!(&mut v, \"initSidebarItems({});\",\n+                                as_json(&items)), &js_dst);\n+                scx.fs.write(&js_dst, &v)?;\n+            }\n+\n+            for item in m.items {\n+                f(self, item);\n+            }\n \n-                Ok(())\n-            })?;\n+            info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+            // Go back to where we were at\n+            self.dst = prev;\n+            self.current.pop().unwrap();\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n             self.render_item(&mut buf, &item, true).unwrap();\n@@ -2399,7 +2210,7 @@ impl<'a> Item<'a> {\n                 (_, _, Unknown) => return None,\n             };\n \n-            clean_srcpath(&src_root, file, false, |component| {\n+            sources::clean_path(&src_root, file, false, |component| {\n                 path.push_str(&component.to_string_lossy());\n                 path.push('/');\n             });\n@@ -2549,29 +2360,39 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n     s\n }\n \n-fn shorter(s: Option<&str>) -> String {\n-    match s {\n-        Some(s) => s.lines()\n-            .skip_while(|s| s.chars().all(|c| c.is_whitespace()))\n-            .take_while(|line|{\n-            (*line).chars().any(|chr|{\n-                !chr.is_whitespace()\n-            })\n-        }).collect::<Vec<_>>().join(\"\\n\"),\n-        None => String::new()\n-    }\n-}\n-\n #[inline]\n fn plain_summary_line(s: Option<&str>) -> String {\n-    let line = shorter(s).replace(\"\\n\", \" \");\n-    markdown::plain_summary_line_full(&line[..], false)\n-}\n-\n-#[inline]\n-fn plain_summary_line_short(s: Option<&str>) -> String {\n-    let line = shorter(s).replace(\"\\n\", \" \");\n-    markdown::plain_summary_line_full(&line[..], true)\n+    let s = s.unwrap_or(\"\");\n+    // This essentially gets the first paragraph of text in one line.\n+    let mut line = s.lines()\n+        .skip_while(|line| line.chars().all(|c| c.is_whitespace()))\n+        .take_while(|line| line.chars().any(|c| !c.is_whitespace()))\n+        .fold(String::new(), |mut acc, line| {\n+            acc.push_str(line);\n+            acc.push(' ');\n+            acc\n+        });\n+    // remove final whitespace\n+    line.pop();\n+    markdown::plain_summary_line(&line[..])\n+}\n+\n+fn shorten(s: String) -> String {\n+    if s.chars().count() > 60 {\n+        let mut len = 0;\n+        let mut ret = s.split_whitespace()\n+                        .take_while(|p| {\n+                            // + 1 for the added character after the word.\n+                            len += p.chars().count() + 1;\n+                            len < 60\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\" \");\n+        ret.push('\u2026');\n+        ret\n+    } else {\n+        s\n+    }\n }\n \n fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt::Result {\n@@ -2584,13 +2405,14 @@ fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(w: &mut fmt::Formatter<'_>,\n-                   cx: &Context,\n-                   md_text: &str,\n-                   links: Vec<(String, String)>,\n-                   prefix: &str,\n-                   is_hidden: bool)\n-                   -> fmt::Result {\n+fn render_markdown(\n+    w: &mut fmt::Formatter<'_>,\n+    cx: &Context,\n+    md_text: &str,\n+    links: Vec<(String, String)>,\n+    prefix: &str,\n+    is_hidden: bool,\n+) -> fmt::Result {\n     let mut ids = cx.id_map.borrow_mut();\n     write!(w, \"<div class='docblock{}'>{}{}</div>\",\n            if is_hidden { \" hidden\" } else { \"\" },\n@@ -2604,7 +2426,8 @@ fn document_short(\n     cx: &Context,\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n-    prefix: &str, is_hidden: bool\n+    prefix: &str,\n+    is_hidden: bool,\n ) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n@@ -2816,19 +2639,19 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n-                use crate::html::format::HRef;\n+                use crate::html::format::anchor;\n \n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, src),\n+                               anchor(myitem.def_id, src),\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, name))?\n+                               anchor(myitem.def_id, name))?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n@@ -4263,9 +4086,10 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n             RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n         };\n \n-        let (is_hidden, extra_class) = if trait_.is_none() ||\n-                                          item.doc_value().is_some() ||\n-                                          item.inner.is_associated() {\n+        let (is_hidden, extra_class) = if (trait_.is_none() ||\n+                                           item.doc_value().is_some() ||\n+                                           item.inner.is_associated()) &&\n+                                          !is_default_item {\n             (false, \"\")\n         } else {\n             (true, \" hidden\")\n@@ -5048,27 +4872,6 @@ fn sidebar_foreign_type(fmt: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::\n     Ok(())\n }\n \n-impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Source(s) = *self;\n-        let lines = s.lines().count();\n-        let mut cols = 0;\n-        let mut tmp = lines;\n-        while tmp > 0 {\n-            cols += 1;\n-            tmp /= 10;\n-        }\n-        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..=lines {\n-            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n-        }\n-        write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None))?;\n-        Ok(())\n-    }\n-}\n-\n fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n@@ -5125,7 +4928,7 @@ fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n     document(w, cx, it)\n }\n \n-const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n+crate const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n \n fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())"}, {"sha": "c1f1f59d9149a715e3d5235f3ede1e2d600a7956", "filename": "src/librustdoc/html/sources.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -0,0 +1,187 @@\n+use crate::clean;\n+use crate::docfs::PathError;\n+use crate::fold::DocFolder;\n+use crate::html::layout;\n+use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n+use crate::html::highlight;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Component, Path, PathBuf};\n+use std::fmt;\n+use syntax::source_map::FileName;\n+\n+crate fn render(dst: &Path, scx: &mut SharedContext,\n+                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n+    info!(\"emitting source files\");\n+    let dst = dst.join(\"src\").join(&krate.name);\n+    scx.ensure_dir(&dst)?;\n+    let mut folder = SourceCollector {\n+        dst,\n+        scx,\n+    };\n+    Ok(folder.fold_crate(krate))\n+}\n+\n+/// Helper struct to render all source code to HTML pages\n+struct SourceCollector<'a> {\n+    scx: &'a mut SharedContext,\n+\n+    /// Root destination to place all HTML output into\n+    dst: PathBuf,\n+}\n+\n+impl<'a> DocFolder for SourceCollector<'a> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're including source files, and we haven't seen this file yet,\n+        // then we need to render it out to the filesystem.\n+        if self.scx.include_sources\n+            // skip all invalid or macro spans\n+            && item.source.filename.is_real()\n+            // skip non-local items\n+            && item.def_id.is_local() {\n+\n+            // If it turns out that we couldn't read this file, then we probably\n+            // can't read any of the files (generating html output from json or\n+            // something like that), so just don't include sources for the\n+            // entire crate. The other option is maintaining this mapping on a\n+            // per-file basis, but that's probably not worth it...\n+            self.scx\n+                .include_sources = match self.emit_source(&item.source.filename) {\n+                Ok(()) => true,\n+                Err(e) => {\n+                    println!(\"warning: source code was requested to be rendered, \\\n+                              but processing `{}` had an error: {}\",\n+                             item.source.filename, e);\n+                    println!(\"         skipping rendering of source code\");\n+                    false\n+                }\n+            };\n+        }\n+        self.fold_item_recur(item)\n+    }\n+}\n+\n+impl<'a> SourceCollector<'a> {\n+    /// Renders the given filename into its corresponding HTML source file.\n+    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n+        let p = match *filename {\n+            FileName::Real(ref file) => file,\n+            _ => return Ok(()),\n+        };\n+        if self.scx.local_sources.contains_key(&**p) {\n+            // We've already emitted this source\n+            return Ok(());\n+        }\n+\n+        let contents = match fs::read_to_string(&p) {\n+            Ok(contents) => contents,\n+            Err(e) => {\n+                return Err(Error::new(e, &p));\n+            }\n+        };\n+\n+        // Remove the utf-8 BOM if any\n+        let contents = if contents.starts_with(\"\\u{feff}\") {\n+            &contents[3..]\n+        } else {\n+            &contents[..]\n+        };\n+\n+        // Create the intermediate directories\n+        let mut cur = self.dst.clone();\n+        let mut root_path = String::from(\"../../\");\n+        let mut href = String::new();\n+        clean_path(&self.scx.src_root, &p, false, |component| {\n+            cur.push(component);\n+            root_path.push_str(\"../\");\n+            href.push_str(&component.to_string_lossy());\n+            href.push('/');\n+        });\n+        self.scx.ensure_dir(&cur)?;\n+        let mut fname = p.file_name()\n+                         .expect(\"source has no filename\")\n+                         .to_os_string();\n+        fname.push(\".html\");\n+        cur.push(&fname);\n+        href.push_str(&fname.to_string_lossy());\n+\n+        let mut v = Vec::new();\n+        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n+                                               .to_string_lossy());\n+        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n+        let page = layout::Page {\n+            title: &title,\n+            css_class: \"source\",\n+            root_path: &root_path,\n+            static_root_path: self.scx.static_root_path.as_deref(),\n+            description: &desc,\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.scx.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n+        };\n+        let result = layout::render(&mut v, &self.scx.layout,\n+                       &page, &(\"\"), &Source(contents),\n+                       self.scx.css_file_extension.is_some(),\n+                       &self.scx.themes,\n+                       self.scx.generate_search_filter);\n+        if let Err(e) = result {\n+            return Err(Error::new(e, &cur));\n+        }\n+        self.scx.fs.write(&cur, &v)?;\n+        self.scx.local_sources.insert(p.clone(), href);\n+        Ok(())\n+    }\n+}\n+\n+/// Takes a path to a source file and cleans the path to it. This canonicalizes\n+/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n+/// static HTML tree. Each component in the cleaned path will be passed as an\n+/// argument to `f`. The very last component of the path (ie the file name) will\n+/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n+pub fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+where\n+    F: FnMut(&OsStr),\n+{\n+    // make it relative, if possible\n+    let p = p.strip_prefix(src_root).unwrap_or(p);\n+\n+    let mut iter = p.components().peekable();\n+\n+    while let Some(c) = iter.next() {\n+        if !keep_filename && iter.peek().is_none() {\n+            break;\n+        }\n+\n+        match c {\n+            Component::ParentDir => f(\"up\".as_ref()),\n+            Component::Normal(c) => f(c),\n+            _ => continue,\n+        }\n+    }\n+}\n+\n+/// Wrapper struct to render the source code of a file. This will do things like\n+/// adding line numbers to the left-hand side.\n+struct Source<'a>(&'a str);\n+\n+impl<'a> fmt::Display for Source<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let Source(s) = *self;\n+        let lines = s.lines().count();\n+        let mut cols = 0;\n+        let mut tmp = lines;\n+        while tmp > 0 {\n+            cols += 1;\n+            tmp /= 10;\n+        }\n+        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n+        for i in 1..=lines {\n+            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n+        }\n+        write!(fmt, \"</pre>\")?;\n+        write!(fmt, \"{}\",\n+               highlight::render_with_highlighting(s, None, None, None))?;\n+        Ok(())\n+    }\n+}"}, {"sha": "637c6ef8e8e0bb893daf117e7d5621687c7e1195", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -3,7 +3,7 @@\n \n // Local js definitions:\n /* global addClass, getCurrentValue, hasClass */\n-/* global isHidden onEach, removeClass, updateLocalStorage */\n+/* global isHidden, onEach, removeClass, updateLocalStorage */\n \n if (!String.prototype.startsWith) {\n     String.prototype.startsWith = function(searchString, position) {\n@@ -105,9 +105,9 @@ if (!DOMTokenList.prototype.remove) {\n                 sidebar.appendChild(div);\n             }\n         }\n-        var themePicker = document.getElementsByClassName(\"theme-picker\");\n-        if (themePicker && themePicker.length > 0) {\n-            themePicker[0].style.display = \"none\";\n+        var themePickers = document.getElementsByClassName(\"theme-picker\");\n+        if (themePickers && themePickers.length > 0) {\n+            themePickers[0].style.display = \"none\";\n         }\n     }\n \n@@ -123,9 +123,9 @@ if (!DOMTokenList.prototype.remove) {\n             filler.remove();\n         }\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n-        var themePicker = document.getElementsByClassName(\"theme-picker\");\n-        if (themePicker && themePicker.length > 0) {\n-            themePicker[0].style.display = null;\n+        var themePickers = document.getElementsByClassName(\"theme-picker\");\n+        if (themePickers && themePickers.length > 0) {\n+            themePickers[0].style.display = null;\n         }\n     }\n \n@@ -445,6 +445,21 @@ if (!DOMTokenList.prototype.remove) {\n         var OUTPUT_DATA = 1;\n         var params = getQueryStringParams();\n \n+        // Set the crate filter from saved storage, if the current page has the saved crate filter.\n+        //\n+        // If not, ignore the crate filter -- we want to support filtering for crates on sites like\n+        // doc.rust-lang.org where the crates may differ from page to page while on the same domain.\n+        var savedCrate = getCurrentValue(\"rustdoc-saved-filter-crate\");\n+        if (savedCrate !== null) {\n+            onEachLazy(document.getElementById(\"crate-search\").getElementsByTagName(\"option\"),\n+                       function(e) {\n+                if (e.value === savedCrate) {\n+                    document.getElementById(\"crate-search\").value = e.value;\n+                    return true;\n+                }\n+            });\n+        }\n+\n         // Populate search bar with query string search term when provided,\n         // but only if the input bar is empty. This avoid the obnoxious issue\n         // where you start trying to do a search, and the index loads, and\n@@ -1658,9 +1673,10 @@ if (!DOMTokenList.prototype.remove) {\n             };\n             search_input.onpaste = search_input.onchange;\n \n-            var selectCrate = document.getElementById('crate-search');\n+            var selectCrate = document.getElementById(\"crate-search\");\n             if (selectCrate) {\n                 selectCrate.onchange = function() {\n+                    updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n                     search(undefined, true);\n                 };\n             }\n@@ -2496,7 +2512,7 @@ if (!DOMTokenList.prototype.remove) {\n     }\n \n     function addSearchOptions(crates) {\n-        var elem = document.getElementById('crate-search');\n+        var elem = document.getElementById(\"crate-search\");\n \n         if (!elem) {\n             return;"}, {"sha": "244b24af43f35b40af552940bd8b3808f91f9085", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -54,6 +54,21 @@\n \t\t  box-sizing: border-box;\n }\n \n+/* This part handles the \"default\" theme being used depending on the system one. */\n+html {\n+\tcontent: \"\";\n+}\n+@media (prefers-color-scheme: light) {\n+\thtml {\n+\t\tcontent: \"light\";\n+\t}\n+}\n+@media (prefers-color-scheme: dark) {\n+\thtml {\n+\t\tcontent: \"dark\";\n+\t}\n+}\n+\n /* General structure and fonts */\n \n body {"}, {"sha": "40a6a156972f62bb1b2a617590e37ae6285b33ea", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -57,7 +57,7 @@ function onEachLazy(lazyArray, func, reversed) {\n \n function usableLocalStorage() {\n     // Check if the browser supports localStorage at all:\n-    if (typeof(Storage) === \"undefined\") {\n+    if (typeof Storage === \"undefined\") {\n         return false;\n     }\n     // Check if we can access it; this access will fail if the browser\n@@ -86,7 +86,7 @@ function getCurrentValue(name) {\n     return null;\n }\n \n-function switchTheme(styleElem, mainStyleElem, newTheme) {\n+function switchTheme(styleElem, mainStyleElem, newTheme, saveTheme) {\n     var fullBasicCss = \"rustdoc\" + resourcesSuffix + \".css\";\n     var fullNewTheme = newTheme + resourcesSuffix + \".css\";\n     var newHref = mainStyleElem.href.replace(fullBasicCss, fullNewTheme);\n@@ -109,8 +109,19 @@ function switchTheme(styleElem, mainStyleElem, newTheme) {\n     });\n     if (found === true) {\n         styleElem.href = newHref;\n-        updateLocalStorage(\"rustdoc-theme\", newTheme);\n+        // If this new value comes from a system setting or from the previously saved theme, no\n+        // need to save it.\n+        if (saveTheme === true) {\n+            updateLocalStorage(\"rustdoc-theme\", newTheme);\n+        }\n     }\n }\n \n-switchTheme(currentTheme, mainTheme, getCurrentValue(\"rustdoc-theme\") || \"light\");\n+function getSystemValue() {\n+    var property = getComputedStyle(document.documentElement).getPropertyValue('content');\n+    return property.replace(/\\\"\\'/g, \"\");\n+}\n+\n+switchTheme(currentTheme, mainTheme,\n+            getCurrentValue(\"rustdoc-theme\") || getSystemValue() || \"light\",\n+            false);"}, {"sha": "dfa0db0d23b74378deb6193dc0b2784d679cb349", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -46,7 +46,7 @@ use std::panic;\n use std::process;\n \n use rustc::session::{early_warn, early_error};\n-use rustc::session::config::{ErrorOutputType, RustcOptGroup};\n+use rustc::session::config::{ErrorOutputType, RustcOptGroup, make_crate_type_option};\n \n #[macro_use]\n mod externalfiles;\n@@ -67,6 +67,7 @@ pub mod html {\n     crate mod render;\n     crate mod static_files;\n     crate mod toc;\n+    crate mod sources;\n }\n mod markdown;\n mod passes;\n@@ -132,6 +133,7 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"crate-name\", |o| {\n             o.optopt(\"\", \"crate-name\", \"specify the name of this crate\", \"NAME\")\n         }),\n+        make_crate_type_option(),\n         stable(\"L\", |o| {\n             o.optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                        \"DIR\")\n@@ -240,9 +242,6 @@ fn opts() -> Vec<RustcOptGroup> {\n         unstable(\"crate-version\", |o| {\n             o.optopt(\"\", \"crate-version\", \"crate version to print into documentation\", \"VERSION\")\n         }),\n-        unstable(\"linker\", |o| {\n-            o.optopt(\"\", \"linker\", \"linker used for building executable test code\", \"PATH\")\n-        }),\n         unstable(\"sort-modules-by-appearance\", |o| {\n             o.optflag(\"\", \"sort-modules-by-appearance\", \"sort modules by where they appear in the \\\n                                                          program, rather than alphabetically\")"}, {"sha": "a30fc05f36acde4e5cfca763bc921d734473ae73", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -142,18 +142,15 @@ pub fn test(mut options: Options, diag: &errors::Handler) -> i32 {\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     opts.display_warnings = options.display_warnings;\n-    let mut collector = Collector::new(options.input.display().to_string(), options.cfgs,\n-                                       options.libs, options.codegen_options, options.externs,\n-                                       true, opts, options.maybe_sysroot, None,\n-                                       Some(options.input),\n-                                       options.linker, options.edition, options.persist_doctests);\n+    let mut collector = Collector::new(options.input.display().to_string(), options.clone(),\n+                                       true, opts, None, Some(options.input));\n     collector.set_position(DUMMY_SP);\n     let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n     find_testable_code(&input_str, &mut collector, codes);\n \n     options.test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&options.test_args, collector.tests,\n-                       testing::Options::new().display_output(options.display_warnings));\n+                       Some(testing::Options::new().display_output(options.display_warnings)));\n     0\n }"}, {"sha": "5c4159433c7b2ee387f6260a7541942c97e65905", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -32,27 +32,39 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             dox[code_block.code].to_owned(),\n         );\n \n-        let has_errors = {\n-            let mut has_errors = false;\n+        let validation_status = {\n+            let mut has_syntax_errors = false;\n+            let mut only_whitespace = true;\n+            // even if there is a syntax error, we need to run the lexer over the whole file\n             let mut lexer = Lexer::new(&sess, source_file, None);\n             loop  {\n                 match lexer.next_token().kind {\n                     token::Eof => break,\n-                    token::Unknown(..) => has_errors = true,\n-                    _ => (),\n+                    token::Whitespace => (),\n+                    token::Unknown(..) => has_syntax_errors = true,\n+                    _ => only_whitespace = false,\n                 }\n             }\n-            has_errors\n+\n+            if has_syntax_errors {\n+                Some(CodeBlockInvalid::SyntaxError)\n+            } else if only_whitespace {\n+                Some(CodeBlockInvalid::Empty)\n+            } else {\n+                None\n+            }\n         };\n \n-        if has_errors {\n+        if let Some(code_block_invalid) = validation_status {\n             let mut diag = if let Some(sp) =\n                 super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n             {\n-                let mut diag = self\n-                    .cx\n-                    .sess()\n-                    .struct_span_warn(sp, \"could not parse code block as Rust code\");\n+                let warning_message = match code_block_invalid {\n+                    CodeBlockInvalid::SyntaxError => \"could not parse code block as Rust code\",\n+                    CodeBlockInvalid::Empty => \"Rust code block is empty\",\n+                };\n+\n+                let mut diag = self.cx.sess().struct_span_warn(sp, warning_message);\n \n                 if code_block.syntax.is_none() && code_block.is_fenced {\n                     let sp = sp.from_inner(InnerSpan::new(0, 3));\n@@ -96,3 +108,8 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n         self.fold_item_recur(item)\n     }\n }\n+\n+enum CodeBlockInvalid {\n+    SyntaxError,\n+    Empty,\n+}"}, {"sha": "adcc9930b6c33f02169154652826aaf627298321", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 75, "deletions": 149, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -2,24 +2,19 @@ use rustc_data_structures::sync::Lrc;\n use rustc_interface::interface;\n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::{self, config, DiagnosticOutput};\n-use rustc::session::config::{OutputType, OutputTypes, Externs, CodegenOptions};\n-use rustc::session::search_paths::SearchPath;\n use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax::with_globals;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use std::env;\n-use std::io::prelude::*;\n-use std::io;\n-use std::panic::{self, AssertUnwindSafe};\n+use std::io::{self, Write};\n+use std::panic;\n use std::path::PathBuf;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n use std::str;\n-use std::sync::{Arc, Mutex};\n use syntax::symbol::sym;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n use tempfile::Builder as TempFileBuilder;\n@@ -43,10 +38,16 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n+    let crate_types = if options.proc_macro_crate {\n+        vec![config::CrateType::ProcMacro]\n+    } else {\n+        vec![config::CrateType::Dylib]\n+    };\n+\n     let sessopts = config::Options {\n         maybe_sysroot: options.maybe_sysroot.clone(),\n         search_paths: options.libs.clone(),\n-        crate_types: vec![config::CrateType::Dylib],\n+        crate_types,\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n@@ -83,18 +84,11 @@ pub fn run(options: Options) -> i32 {\n         opts.display_warnings |= options.display_warnings;\n         let mut collector = Collector::new(\n             compiler.crate_name()?.peek().to_string(),\n-            options.cfgs,\n-            options.libs,\n-            options.codegen_options,\n-            options.externs,\n+            options,\n             false,\n             opts,\n-            options.maybe_sysroot,\n             Some(compiler.source_map().clone()),\n             None,\n-            options.linker,\n-            options.edition,\n-            options.persist_doctests,\n         );\n \n         let mut global_ctxt = compiler.global_ctxt()?.take();\n@@ -120,7 +114,7 @@ pub fn run(options: Options) -> i32 {\n     testing::test_main(\n         &test_args,\n         tests,\n-        testing::Options::new().display_output(display_warnings)\n+        Some(testing::Options::new().display_output(display_warnings))\n     );\n \n     0\n@@ -183,20 +177,14 @@ fn run_test(\n     cratename: &str,\n     filename: &FileName,\n     line: usize,\n-    cfgs: Vec<String>,\n-    libs: Vec<SearchPath>,\n-    cg: CodegenOptions,\n-    externs: Externs,\n+    options: Options,\n     should_panic: bool,\n     no_run: bool,\n     as_test_harness: bool,\n     compile_fail: bool,\n     mut error_codes: Vec<String>,\n     opts: &TestOptions,\n-    maybe_sysroot: Option<PathBuf>,\n-    linker: Option<PathBuf>,\n     edition: Edition,\n-    persist_doctests: Option<PathBuf>,\n ) -> Result<(), TestFailure> {\n     let (test, line_offset) = match panic::catch_unwind(|| {\n         make_test(test, Some(cratename), as_test_harness, opts, edition)\n@@ -217,61 +205,6 @@ fn run_test(\n         _ => PathBuf::from(r\"doctest.rs\"),\n     };\n \n-    let input = config::Input::Str {\n-        name: FileName::DocTest(path, line as isize - line_offset as isize),\n-        input: test,\n-    };\n-    let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n-\n-    let sessopts = config::Options {\n-        maybe_sysroot,\n-        search_paths: libs,\n-        crate_types: vec![config::CrateType::Executable],\n-        output_types: outputs,\n-        externs,\n-        cg: config::CodegenOptions {\n-            linker,\n-            ..cg\n-        },\n-        test: as_test_harness,\n-        unstable_features: UnstableFeatures::from_environment(),\n-        debugging_opts: config::DebuggingOptions {\n-            ..config::basic_debugging_options()\n-        },\n-        edition,\n-        ..config::Options::default()\n-    };\n-\n-    // Shuffle around a few input and output handles here. We're going to pass\n-    // an explicit handle into rustc to collect output messages, but we also\n-    // want to catch the error message that rustc prints when it fails.\n-    //\n-    // We take our thread-local stderr (likely set by the test runner) and replace\n-    // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own thread.\n-    //\n-    // The basic idea is to not use a default Handler for rustc, and then also\n-    // not print things by default to the actual stderr.\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-    struct Bomb(Arc<Mutex<Vec<u8>>>, Option<Box<dyn Write+Send>>);\n-    impl Drop for Bomb {\n-        fn drop(&mut self) {\n-            let mut old = self.1.take().unwrap();\n-            let _ = old.write_all(&self.0.lock().unwrap());\n-            io::set_panic(Some(old));\n-        }\n-    }\n-    let data = Arc::new(Mutex::new(Vec::new()));\n-\n-    let old = io::set_panic(Some(box Sink(data.clone())));\n-    let _bomb = Bomb(data.clone(), Some(old.unwrap_or(box io::stdout())));\n-\n     enum DirState {\n         Temp(tempfile::TempDir),\n         Perm(PathBuf),\n@@ -286,7 +219,7 @@ fn run_test(\n         }\n     }\n \n-    let outdir = if let Some(mut path) = persist_doctests {\n+    let outdir = if let Some(mut path) = options.persist_doctests {\n         path.push(format!(\"{}_{}\",\n             filename\n                 .to_string()\n@@ -308,49 +241,71 @@ fn run_test(\n     };\n     let output_file = outdir.path().join(\"rust_out\");\n \n-    let config = interface::Config {\n-        opts: sessopts,\n-        crate_cfg: config::parse_cfgspecs(cfgs),\n-        input,\n-        input_path: None,\n-        output_file: Some(output_file.clone()),\n-        output_dir: None,\n-        file_loader: None,\n-        diagnostic_output: DiagnosticOutput::Raw(box Sink(data.clone())),\n-        stderr: Some(data.clone()),\n-        crate_name: None,\n-        lint_caps: Default::default(),\n-    };\n+    let mut compiler = Command::new(std::env::current_exe().unwrap().with_file_name(\"rustc\"));\n+    compiler.arg(\"--crate-type\").arg(\"bin\");\n+    for cfg in &options.cfgs {\n+        compiler.arg(\"--cfg\").arg(&cfg);\n+    }\n+    if let Some(sysroot) = options.maybe_sysroot {\n+        compiler.arg(\"--sysroot\").arg(sysroot);\n+    }\n+    compiler.arg(\"--edition\").arg(&edition.to_string());\n+    compiler.env(\"UNSTABLE_RUSTDOC_TEST_PATH\", path);\n+    compiler.env(\"UNSTABLE_RUSTDOC_TEST_LINE\",\n+                 format!(\"{}\", line as isize - line_offset as isize));\n+    compiler.arg(\"-o\").arg(&output_file);\n+    if as_test_harness {\n+        compiler.arg(\"--test\");\n+    }\n+    for lib_str in &options.lib_strs {\n+        compiler.arg(\"-L\").arg(&lib_str);\n+    }\n+    for extern_str in &options.extern_strs {\n+        compiler.arg(\"--extern\").arg(&extern_str);\n+    }\n+    compiler.arg(\"-Ccodegen-units=1\");\n+    for codegen_options_str in &options.codegen_options_strs {\n+        compiler.arg(\"-C\").arg(&codegen_options_str);\n+    }\n+    if no_run {\n+        compiler.arg(\"--emit=metadata\");\n+    }\n \n-    let compile_result = panic::catch_unwind(AssertUnwindSafe(|| {\n-        interface::run_compiler(config, |compiler| {\n-            if no_run {\n-                compiler.global_ctxt().and_then(|global_ctxt| global_ctxt.take().enter(|tcx| {\n-                    tcx.analysis(LOCAL_CRATE)\n-                })).ok();\n-            } else {\n-                compiler.compile().ok();\n-            };\n-            compiler.session().compile_status()\n-        })\n-    })).map_err(|_| ()).and_then(|s| s.map_err(|_| ()));\n+    compiler.arg(\"-\");\n+    compiler.stdin(Stdio::piped());\n+    compiler.stderr(Stdio::piped());\n+\n+    let mut child = compiler.spawn().expect(\"Failed to spawn rustc process\");\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n+        stdin.write_all(test.as_bytes()).expect(\"could write out test sources\");\n+    }\n+    let output = child.wait_with_output().expect(\"Failed to read stdout\");\n+\n+    struct Bomb<'a>(&'a str);\n+    impl Drop for Bomb<'_> {\n+        fn drop(&mut self) {\n+            eprint!(\"{}\",self.0);\n+        }\n+    }\n \n-    match (compile_result, compile_fail) {\n-        (Ok(()), true) => {\n+    let out = str::from_utf8(&output.stderr).unwrap();\n+    let _bomb = Bomb(&out);\n+    match (output.status.success(), compile_fail) {\n+        (true, true) => {\n             return Err(TestFailure::UnexpectedCompilePass);\n         }\n-        (Ok(()), false) => {}\n-        (Err(_), true) => {\n+        (true, false) => {}\n+        (false, true) => {\n             if !error_codes.is_empty() {\n-                let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n \n                 if !error_codes.is_empty() {\n                     return Err(TestFailure::MissingErrorCodes(error_codes));\n                 }\n             }\n         }\n-        (Err(_), false) => {\n+        (false, false) => {\n             return Err(TestFailure::CompileError);\n         }\n     }\n@@ -427,7 +382,7 @@ pub fn make_test(s: &str,\n         // Any errors in parsing should also appear when the doctest is compiled for real, so just\n         // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n         let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false);\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None);\n         // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n         let handler = Handler::with_emitter(false, None, box emitter);\n         let sess = ParseSess::with_span_handler(handler, cm);\n@@ -646,45 +601,28 @@ pub struct Collector {\n     // the `names` vector of that test will be `[\"Title\", \"Subtitle\"]`.\n     names: Vec<String>,\n \n-    cfgs: Vec<String>,\n-    libs: Vec<SearchPath>,\n-    cg: CodegenOptions,\n-    externs: Externs,\n+    options: Options,\n     use_headers: bool,\n     cratename: String,\n     opts: TestOptions,\n-    maybe_sysroot: Option<PathBuf>,\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n-    linker: Option<PathBuf>,\n-    edition: Edition,\n-    persist_doctests: Option<PathBuf>,\n }\n \n impl Collector {\n-    pub fn new(cratename: String, cfgs: Vec<String>, libs: Vec<SearchPath>, cg: CodegenOptions,\n-               externs: Externs, use_headers: bool, opts: TestOptions,\n-               maybe_sysroot: Option<PathBuf>, source_map: Option<Lrc<SourceMap>>,\n-               filename: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n-               persist_doctests: Option<PathBuf>) -> Collector {\n+    pub fn new(cratename: String, options: Options, use_headers: bool, opts: TestOptions,\n+               source_map: Option<Lrc<SourceMap>>, filename: Option<PathBuf>,) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n-            cfgs,\n-            libs,\n-            cg,\n-            externs,\n+            options,\n             use_headers,\n             cratename,\n             opts,\n-            maybe_sysroot,\n             position: DUMMY_SP,\n             source_map,\n             filename,\n-            linker,\n-            edition,\n-            persist_doctests,\n         }\n     }\n \n@@ -719,16 +657,10 @@ impl Tester for Collector {\n     fn add_test(&mut self, test: String, config: LangString, line: usize) {\n         let filename = self.get_filename();\n         let name = self.generate_name(line, &filename);\n-        let cfgs = self.cfgs.clone();\n-        let libs = self.libs.clone();\n-        let cg = self.cg.clone();\n-        let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n         let opts = self.opts.clone();\n-        let maybe_sysroot = self.maybe_sysroot.clone();\n-        let linker = self.linker.clone();\n-        let edition = config.edition.unwrap_or(self.edition);\n-        let persist_doctests = self.persist_doctests.clone();\n+        let edition = config.edition.unwrap_or(self.options.edition.clone());\n+        let options = self.options.clone();\n \n         debug!(\"creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n@@ -745,20 +677,14 @@ impl Tester for Collector {\n                     &cratename,\n                     &filename,\n                     line,\n-                    cfgs,\n-                    libs,\n-                    cg,\n-                    externs,\n+                    options,\n                     config.should_panic,\n                     config.no_run,\n                     config.test_harness,\n                     config.compile_fail,\n                     config.error_codes,\n                     &opts,\n-                    maybe_sysroot,\n-                    linker,\n                     edition,\n-                    persist_doctests\n                 );\n \n                 if let Err(err) = res {"}, {"sha": "ee330cb32111e545d7b24bc1255ccdb1457d6cea", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -41,7 +41,7 @@ fn def_id_to_path(\n // framework from syntax?.\n \n pub struct RustdocVisitor<'a, 'tcx> {\n-    cx: &'a core::DocContext<'tcx>,\n+    cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n@@ -51,7 +51,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a core::DocContext<'tcx>\n+        cx: &'a mut core::DocContext<'tcx>\n     ) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         );\n         module.is_crate = true;\n \n-        self.cx.renderinfo.borrow_mut().exact_paths = self.exact_paths;\n+        self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;\n \n         module\n     }\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 Res::Def(DefKind::ForeignTy, did) |\n                 Res::Def(DefKind::TyAlias, did) if !self_is_hidden => {\n                     self.cx.renderinfo\n-                        .borrow_mut()\n+                        .get_mut()\n                         .access_levels.map\n                         .insert(did, AccessLevel::Public);\n                 },"}, {"sha": "b229b5f6884d82381fd1657f24db7d00162eef2f", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,22 +1,20 @@\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n-use rustc::ty::Visibility;\n+use rustc::ty::{TyCtxt, Visibility};\n use rustc::util::nodemap::FxHashSet;\n use syntax::symbol::sym;\n \n-use std::cell::RefMut;\n-\n use crate::clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'tcx> {\n-    cx: &'a crate::core::DocContext<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n-    access_levels: RefMut<'a, AccessLevels<DefId>>,\n+    access_levels: &'a mut AccessLevels<DefId>,\n     // Previous accessibility level, None means unreachable\n     prev_level: Option<AccessLevel>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n@@ -25,13 +23,13 @@ pub struct LibEmbargoVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a crate::core::DocContext<'tcx>\n+        cx: &'a mut crate::core::DocContext<'tcx>\n     ) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n-            cx,\n-            access_levels: RefMut::map(cx.renderinfo.borrow_mut(), |ri| &mut ri.access_levels),\n+            tcx: cx.tcx,\n+            access_levels: &mut cx.renderinfo.get_mut().access_levels,\n             prev_level: Some(AccessLevel::Public),\n-            visited_mods: FxHashSet::default()\n+            visited_mods: FxHashSet::default(),\n         }\n     }\n \n@@ -43,7 +41,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n+        let is_hidden = self.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow\n@@ -60,9 +58,9 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        for item in self.cx.tcx.item_children(def_id).iter() {\n+        for item in self.tcx.item_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n-                if self.cx.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n+                if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n                     item.vis == Visibility::Public {\n                     self.visit_item(item.res);\n                 }\n@@ -72,7 +70,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, res: Res) {\n         let def_id = res.def_id();\n-        let vis = self.cx.tcx.visibility(def_id);\n+        let vis = self.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n         } else {"}, {"sha": "157faa0af9bca1858689201ecb05e977afc8a17b", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -70,11 +70,6 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n # Make panics and failed asserts immediately abort without formatting any message\n panic_immediate_abort = [\"core/panic_immediate_abort\"]\n \n-# An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n-# interoperate with the host environment. Currently not well documented and\n-# requires rebuilding the standard library to use it.\n-wasm_syscall = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "795830a52c5451a3e190c238c5d8f3615cd319c5", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -236,7 +236,7 @@ impl f32 {\n     /// let b = 60.0_f32;\n     ///\n     /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n+    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -318,7 +318,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n+    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -336,7 +336,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n+    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -600,7 +600,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI/2.0;\n+    /// let x = f32::consts::FRAC_PI_2;\n     ///\n     /// let abs_difference = (x.sin() - 1.0).abs();\n     ///\n@@ -623,7 +623,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = 2.0*f32::consts::PI;\n+    /// let x = 2.0 * f32::consts::PI;\n     ///\n     /// let abs_difference = (x.cos() - 1.0).abs();\n     ///\n@@ -646,7 +646,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI / 4.0;\n+    /// let x = f32::consts::FRAC_PI_4;\n     /// let abs_difference = (x.tan() - 1.0).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n@@ -666,10 +666,10 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let f = f32::consts::PI / 2.0;\n+    /// let f = f32::consts::FRAC_PI_2;\n     ///\n     /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f32::consts::PI / 2.0).abs();\n+    /// let abs_difference = (f.sin().asin() - f32::consts::FRAC_PI_2).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -688,10 +688,10 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let f = f32::consts::PI / 4.0;\n+    /// let f = f32::consts::FRAC_PI_4;\n     ///\n     /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f32::consts::PI / 4.0).abs();\n+    /// let abs_difference = (f.cos().acos() - f32::consts::FRAC_PI_4).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -734,7 +734,6 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let pi = f32::consts::PI;\n     /// // Positive angles measured counter-clockwise\n     /// // from positive x axis\n     /// // -pi/4 radians (45 deg clockwise)\n@@ -745,8 +744,8 @@ impl f32 {\n     /// let x2 = -3.0f32;\n     /// let y2 = 3.0f32;\n     ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n+    /// let abs_difference_1 = (y1.atan2(x1) - (-f32::consts::FRAC_PI_4)).abs();\n+    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f32::consts::FRAC_PI_4)).abs();\n     ///\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// assert!(abs_difference_2 <= f32::EPSILON);\n@@ -765,7 +764,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI/4.0;\n+    /// let x = f32::consts::FRAC_PI_4;\n     /// let f = x.sin_cos();\n     ///\n     /// let abs_difference_0 = (f.0 - x.sin()).abs();\n@@ -834,7 +833,7 @@ impl f32 {\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n+    /// let g = ((e * e) - 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n@@ -856,7 +855,7 @@ impl f32 {\n     /// let x = 1.0f32;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n+    /// let g = ((e * e) + 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// // Same result\n@@ -880,7 +879,7 @@ impl f32 {\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n+    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n@@ -911,7 +910,7 @@ impl f32 {\n         if self == NEG_INFINITY {\n             NEG_INFINITY\n         } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln()\n+            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n     }\n \n@@ -932,9 +931,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        match self {\n-            x if x < 1.0 => crate::f32::NAN,\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        if self < 1.0 {\n+            crate::f32::NAN\n+        } else {\n+            (self + ((self * self) - 1.0).sqrt()).ln()\n         }\n     }\n \n@@ -1488,6 +1488,7 @@ mod tests {\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n+        assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     }"}, {"sha": "44d25f1b476575b5bbe713d9cac9a4743bec4007", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -212,7 +212,7 @@ impl f64 {\n     /// let b = 60.0_f64;\n     ///\n     /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n+    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -244,7 +244,7 @@ impl f64 {\n     pub fn div_euclid(self, rhs: f64) -> f64 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n-            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n         }\n         q\n     }\n@@ -291,7 +291,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n+    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -307,7 +307,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n+    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -437,9 +437,9 @@ impl f64 {\n     pub fn log2(self) -> f64 {\n         self.log_wrapper(|n| {\n             #[cfg(target_os = \"android\")]\n-            return crate::sys::android::log2f64(n);\n+                return crate::sys::android::log2f64(n);\n             #[cfg(not(target_os = \"android\"))]\n-            return unsafe { intrinsics::log2f64(n) };\n+                return unsafe { intrinsics::log2f64(n) };\n         })\n     }\n \n@@ -481,16 +481,16 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     #[rustc_deprecated(since = \"1.10.0\",\n-                       reason = \"you probably meant `(self - other).abs()`: \\\n+    reason = \"you probably meant `(self - other).abs()`: \\\n                                  this operation is `(self - other).max(0.0)` \\\n                                  except that `abs_sub` also propagates NaNs (also \\\n                                  known as `fdim` in C). If you truly need the positive \\\n                                  difference, consider using that expression or the C function \\\n                                  `fdim`, depending on how you wish to handle NaN (please consider \\\n                                  filing an issue describing your use-case too).\")]\n-     pub fn abs_sub(self, other: f64) -> f64 {\n-         unsafe { cmath::fdim(self, other) }\n-     }\n+    pub fn abs_sub(self, other: f64) -> f64 {\n+        unsafe { cmath::fdim(self, other) }\n+    }\n \n     /// Takes the cubic root of a number.\n     ///\n@@ -537,7 +537,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/2.0;\n+    /// let x = f64::consts::FRAC_PI_2;\n     ///\n     /// let abs_difference = (x.sin() - 1.0).abs();\n     ///\n@@ -556,7 +556,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = 2.0*f64::consts::PI;\n+    /// let x = 2.0 * f64::consts::PI;\n     ///\n     /// let abs_difference = (x.cos() - 1.0).abs();\n     ///\n@@ -575,7 +575,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/4.0;\n+    /// let x = f64::consts::FRAC_PI_4;\n     /// let abs_difference = (x.tan() - 1.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-14);\n@@ -595,10 +595,10 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let f = f64::consts::PI / 2.0;\n+    /// let f = f64::consts::FRAC_PI_2;\n     ///\n     /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n+    /// let abs_difference = (f.sin().asin() - f64::consts::FRAC_PI_2).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -617,10 +617,10 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let f = f64::consts::PI / 4.0;\n+    /// let f = f64::consts::FRAC_PI_4;\n     ///\n     /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n+    /// let abs_difference = (f.cos().acos() - f64::consts::FRAC_PI_4).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -661,7 +661,6 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let pi = f64::consts::PI;\n     /// // Positive angles measured counter-clockwise\n     /// // from positive x axis\n     /// // -pi/4 radians (45 deg clockwise)\n@@ -672,8 +671,8 @@ impl f64 {\n     /// let x2 = -3.0_f64;\n     /// let y2 = 3.0_f64;\n     ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n+    /// let abs_difference_1 = (y1.atan2(x1) - (-f64::consts::FRAC_PI_4)).abs();\n+    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f64::consts::FRAC_PI_4)).abs();\n     ///\n     /// assert!(abs_difference_1 < 1e-10);\n     /// assert!(abs_difference_2 < 1e-10);\n@@ -692,7 +691,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/4.0;\n+    /// let x = f64::consts::FRAC_PI_4;\n     /// let f = x.sin_cos();\n     ///\n     /// let abs_difference_0 = (f.0 - x.sin()).abs();\n@@ -759,7 +758,7 @@ impl f64 {\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n+    /// let g = ((e * e) - 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n@@ -781,7 +780,7 @@ impl f64 {\n     /// let x = 1.0_f64;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n+    /// let g = ((e * e) + 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// // Same result\n@@ -805,7 +804,7 @@ impl f64 {\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n+    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n@@ -834,7 +833,7 @@ impl f64 {\n         if self == NEG_INFINITY {\n             NEG_INFINITY\n         } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln()\n+            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n     }\n \n@@ -853,9 +852,10 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        match self {\n-            x if x < 1.0 => NAN,\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        if self < 1.0 {\n+            NAN\n+        } else {\n+            (self + ((self * self) - 1.0).sqrt()).ln()\n         }\n     }\n \n@@ -1188,7 +1188,7 @@ mod tests {\n         assert_eq!((-0f64).abs(), 0f64);\n         assert_eq!((-1f64).abs(), 1f64);\n         assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n+        assert_eq!((1f64 / NEG_INFINITY).abs(), 0f64);\n         assert!(NAN.abs().is_nan());\n     }\n \n@@ -1200,7 +1200,7 @@ mod tests {\n         assert_eq!((-0f64).signum(), -1f64);\n         assert_eq!((-1f64).signum(), -1f64);\n         assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n+        assert_eq!((1f64 / NEG_INFINITY).signum(), -1f64);\n         assert!(NAN.signum().is_nan());\n     }\n \n@@ -1212,7 +1212,7 @@ mod tests {\n         assert!(!(-0f64).is_sign_positive());\n         assert!(!(-1f64).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f64/NEG_INFINITY).is_sign_positive());\n+        assert!(!(1f64 / NEG_INFINITY).is_sign_positive());\n         assert!(NAN.is_sign_positive());\n         assert!(!(-NAN).is_sign_positive());\n     }\n@@ -1225,7 +1225,7 @@ mod tests {\n         assert!((-0f64).is_sign_negative());\n         assert!((-1f64).is_sign_negative());\n         assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f64/NEG_INFINITY).is_sign_negative());\n+        assert!((1f64 / NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n         assert!((-NAN).is_sign_negative());\n     }\n@@ -1434,6 +1434,8 @@ mod tests {\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n+        assert!((-0.0f64).asinh().is_sign_negative());\n+        // issue 63271\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     }"}, {"sha": "65f4e0cafe09e321503233608cd1eb8352f00c91", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -572,8 +572,8 @@ impl CString {\n     /// use std::ffi::{CString, CStr};\n     ///\n     /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n-    /// let c_str = c_string.as_c_str();\n-    /// assert_eq!(c_str,\n+    /// let cstr = c_string.as_c_str();\n+    /// assert_eq!(cstr,\n     ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n     /// ```\n     #[inline]\n@@ -994,17 +994,17 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"hello\");\n-    /// assert!(c_str.is_err());\n+    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n+    /// assert!(cstr.is_err());\n     /// ```\n     ///\n     /// Creating a `CStr` with an interior nul byte is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n-    /// assert!(c_str.is_err());\n+    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n+    /// assert!(cstr.is_err());\n     /// ```\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     pub fn from_bytes_with_nul(bytes: &[u8])\n@@ -1111,8 +1111,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_bytes(), b\"foo\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1137,8 +1137,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1164,8 +1164,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n     /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n@@ -1205,9 +1205,9 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n     ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n+    /// assert_eq!(cstr.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n     /// ```\n     ///\n     /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n@@ -1216,10 +1216,10 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n     ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(\n-    ///     c_str.to_string_lossy(),\n+    ///     cstr.to_string_lossy(),\n     ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<'_, str>\n     /// );\n     /// ```"}, {"sha": "6cf062d4f30c0f5a24e70c4507ad0db39ad03856", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -233,7 +233,7 @@ impl OsString {\n     /// ```\n     /// use std::ffi::OsString;\n     ///\n-    /// let mut os_string = OsString::with_capacity(10);\n+    /// let os_string = OsString::with_capacity(10);\n     /// assert!(os_string.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n@@ -616,7 +616,7 @@ impl OsStr {\n     /// Note that this does **not** return the number of bytes in the string in\n     /// OS string form.\n     ///\n-    /// The length returned is that of the underlying storage used by `OsStr`;\n+    /// The length returned is that of the underlying storage used by `OsStr`.\n     /// As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n     /// store strings in a form best suited for cheap inter-conversion between\n     /// native-platform and Rust string forms, which may differ significantly"}, {"sha": "9593a1bae0a3c5abc2cfbfcbd2fcb5cc40c17e10", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -9,21 +9,21 @@ use crate::io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom,\n         IoSliceMut};\n use crate::memchr;\n \n-/// The `BufReader` struct adds buffering to any reader.\n+/// The `BufReader<R>` struct adds buffering to any reader.\n ///\n /// It can be excessively inefficient to work directly with a [`Read`] instance.\n /// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n-/// results in a system call. A `BufReader` performs large, infrequent reads on\n+/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n /// the underlying [`Read`] and maintains an in-memory buffer of the results.\n ///\n-/// `BufReader` can improve the speed of programs that make *small* and\n+/// `BufReader<R>` can improve the speed of programs that make *small* and\n /// *repeated* read calls to the same file or network socket. It does not\n /// help when reading very large amounts at once, or reading just one or a few\n /// times. It also provides no advantage when reading from a source that is\n /// already in memory, like a `Vec<u8>`.\n ///\n-/// When the `BufReader` is dropped, the contents of its buffer will be\n-/// discarded. Creating multiple instances of a `BufReader` on the same\n+/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n+/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n /// stream can cause data loss.\n ///\n /// [`Read`]: ../../std/io/trait.Read.html\n@@ -56,7 +56,7 @@ pub struct BufReader<R> {\n }\n \n impl<R: Read> BufReader<R> {\n-    /// Creates a new `BufReader` with a default buffer capacity. The default is currently 8 KB,\n+    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n     /// but may change in the future.\n     ///\n     /// # Examples\n@@ -76,7 +76,7 @@ impl<R: Read> BufReader<R> {\n         BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    /// Creates a new `BufReader` with the specified buffer capacity.\n+    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n     ///\n     /// # Examples\n     ///\n@@ -177,7 +177,7 @@ impl<R> BufReader<R> {\n         &self.buf[self.pos..self.cap]\n     }\n \n-    /// Unwraps this `BufReader`, returning the underlying reader.\n+    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n     ///\n     /// Note that any leftover data in the internal buffer is lost.\n     ///\n@@ -304,7 +304,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n     /// The position used for seeking with `SeekFrom::Current(_)` is the\n-    /// position the underlying reader would be at if the `BufReader` had no\n+    /// position the underlying reader would be at if the `BufReader<R>` had no\n     /// internal buffer.\n     ///\n     /// Seeking always discards the internal buffer, even if the seek position\n@@ -355,19 +355,20 @@ impl<R: Seek> Seek for BufReader<R> {\n /// It can be excessively inefficient to work directly with something that\n /// implements [`Write`]. For example, every call to\n /// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n-/// `BufWriter` keeps an in-memory buffer of data and writes it to an underlying\n+/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n /// writer in large, infrequent batches.\n ///\n-/// `BufWriter` can improve the speed of programs that make *small* and\n+/// `BufWriter<W>` can improve the speed of programs that make *small* and\n /// *repeated* write calls to the same file or network socket. It does not\n /// help when writing very large amounts at once, or writing just one or a few\n /// times. It also provides no advantage when writing to a destination that is\n /// in memory, like a `Vec<u8>`.\n ///\n-/// When the `BufWriter` is dropped, the contents of its buffer will be written\n-/// out. However, any errors that happen in the process of flushing the buffer\n-/// when the writer is dropped will be ignored. Code that wishes to handle such\n-/// errors must manually call [`flush`] before the writer is dropped.\n+/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n+/// dropping will attempt to flush the the contents of the buffer, any errors\n+/// that happen in the process of dropping will be ignored. Calling ['flush']\n+/// ensures that the buffer is empty and thus dropping will not even attempt\n+/// file operations.\n ///\n /// # Examples\n ///\n@@ -386,7 +387,7 @@ impl<R: Seek> Seek for BufReader<R> {\n ///\n /// Because we're not buffering, we write each one in turn, incurring the\n /// overhead of a system call per byte written. We can fix this with a\n-/// `BufWriter`:\n+/// `BufWriter<W>`:\n ///\n /// ```no_run\n /// use std::io::prelude::*;\n@@ -398,11 +399,12 @@ impl<R: Seek> Seek for BufReader<R> {\n /// for i in 0..10 {\n ///     stream.write(&[i+1]).unwrap();\n /// }\n+/// stream.flush().unwrap();\n /// ```\n ///\n-/// By wrapping the stream with a `BufWriter`, these ten writes are all grouped\n-/// together by the buffer, and will all be written out in one system call when\n-/// the `stream` is dropped.\n+/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n+/// together by the buffer and will all be written out in one system call when\n+/// the `stream` is flushed.\n ///\n /// [`Write`]: ../../std/io/trait.Write.html\n /// [`TcpStream::write`]: ../../std/net/struct.TcpStream.html#method.write\n@@ -447,7 +449,7 @@ pub struct BufWriter<W: Write> {\n pub struct IntoInnerError<W>(W, Error);\n \n impl<W: Write> BufWriter<W> {\n-    /// Creates a new `BufWriter` with a default buffer capacity. The default is currently 8 KB,\n+    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n     /// but may change in the future.\n     ///\n     /// # Examples\n@@ -463,7 +465,7 @@ impl<W: Write> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    /// Creates a new `BufWriter` with the specified buffer capacity.\n+    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n     ///\n     /// # Examples\n     ///\n@@ -564,7 +566,7 @@ impl<W: Write> BufWriter<W> {\n         &self.buf\n     }\n \n-    /// Unwraps this `BufWriter`, returning the underlying writer.\n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n     ///\n     /// The buffer is written out before returning the writer.\n     ///"}, {"sha": "a8dfe924fdf0698a4ec0002a71534d932ae482f6", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -681,14 +681,15 @@ mod while_keyword { }\n ///     # break;\n /// }\n ///\n-/// let mut i = 0;\n+/// let mut i = 1;\n /// loop {\n ///     println!(\"i is {}\", i);\n-///     if i > 10 {\n+///     if i > 100 {\n ///         break;\n ///     }\n-///     i += 1;\n+///     i *= 2;\n /// }\n+/// assert_eq!(i, 128);\n /// ```\n ///\n /// Unlike the other kinds of loops in Rust (`while`, `while let`, and `for`), loops can be used as"}, {"sha": "45816ffd229f0261a591a58c328607ede4d4ca47", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -655,7 +655,7 @@ mod prim_slice { }\n /// [`len`]: #method.len\n ///\n /// Note: This example shows the internals of `&str`. `unsafe` should not be\n-/// used to get a string slice under normal circumstances. Use `as_slice`\n+/// used to get a string slice under normal circumstances. Use `as_str`\n /// instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_str { }"}, {"sha": "65ce19f2a1b3a5c5a50e1fb2044410f681db829b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -28,14 +28,14 @@ impl WaitTimeoutResult {\n     /// once the boolean has been updated and notified.\n     ///\n     /// ```\n-    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::sync::{Arc, Condvar, Mutex};\n     /// use std::thread;\n     /// use std::time::Duration;\n     ///\n     /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n     /// let pair2 = pair.clone();\n     ///\n-    /// thread::spawn(move|| {\n+    /// thread::spawn(move || {\n     ///     let (lock, cvar) = &*pair2;\n     ///\n     ///     // Let's wait 20 milliseconds before notifying the condvar."}, {"sha": "e6a742bd45d0bb0e8041f89f544ac21c898fe871", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -178,23 +178,22 @@ impl Command {\n             cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n-        if cfg!(not(any(target_os = \"l4re\"))) {\n+        #[cfg(not(target_os = \"l4re\"))]\n+        {\n             if let Some(u) = self.get_gid() {\n                 cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n+                // When dropping privileges from root, the `setgroups` call\n+                // will remove any extraneous groups. If we don't call this,\n+                // then even though our uid has dropped, we may still have\n+                // groups that enable us to do super-user things. This will\n+                // fail if we aren't root, so don't bother checking the\n+                // return value, this is just done as an optimistic\n+                // privilege dropping function.\n                 //FIXME: Redox kernel does not support setgroups yet\n-                if cfg!(not(target_os = \"redox\")) {\n-                    // When dropping privileges from root, the `setgroups` call\n-                    // will remove any extraneous groups. If we don't call this,\n-                    // then even though our uid has dropped, we may still have\n-                    // groups that enable us to do super-user things. This will\n-                    // fail if we aren't root, so don't bother checking the\n-                    // return value, this is just done as an optimistic\n-                    // privilege dropping function.\n-                    let _ = libc::setgroups(0, ptr::null());\n-                }\n-\n+                #[cfg(not(target_os = \"redox\"))]\n+                let _ = libc::setgroups(0, ptr::null());\n                 cvt(libc::setuid(u as uid_t))?;\n             }\n         }\n@@ -203,7 +202,7 @@ impl Command {\n         }\n \n         // emscripten has no signal support.\n-        #[cfg(not(any(target_os = \"emscripten\")))]\n+        #[cfg(not(target_os = \"emscripten\"))]\n         {\n             use crate::mem::MaybeUninit;\n             // Reset signal handling so the child process starts in a"}, {"sha": "0887e5a4df937ed97486ceb77367defe4ab1f833", "filename": "src/libstd/sys/vxworks/backtrace/mod.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,110 +0,0 @@\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on macOS, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering thread\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not macOS, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-\n-pub use self::tracing::unwind_backtrace;\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-\n-// tracing impls:\n-mod tracing;\n-// symbol resolvers:\n-mod printing;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub mod gnu {\n-    use crate::io;\n-    use crate::fs;\n-\n-    use libc::c_char;\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        use crate::env;\n-        use crate::os::unix::ffi::OsStrExt;\n-\n-        let filename = env::current_exe()?;\n-        let file = fs::File::open(&filename)?;\n-        let mut filename_cstr: Vec<_> = filename.as_os_str().as_bytes().iter()\n-            .map(|&x| x as c_char).collect();\n-        filename_cstr.push(0); // Null terminate\n-        Ok((filename_cstr, file))\n-    }\n-}\n-\n-pub struct BacktraceContext;"}, {"sha": "202164dd3c4d7655c0239ffee22891984b4cd18d", "filename": "src/libstd/sys/vxworks/backtrace/printing/dladdr.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,35 +0,0 @@\n-use crate::io;\n-use crate::intrinsics;\n-use crate::ffi::CStr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsafe {\n-        let mut info: Dl_info = intrinsics::init();\n-        let symname = if dladdr(frame.exact_position as *mut _, &mut info) == 0 ||\n-                         info.dli_sname.is_null() {\n-            None\n-        } else {\n-            CStr::from_ptr(info.dli_sname).to_str().ok()\n-        };\n-        callback(symname)\n-    }\n-}\n-\n-#[repr(C)]\n-struct Dl_info {\n-    dli_fname: *const libc::c_char,\n-    dli_fbase: *mut libc::c_void,\n-    dli_sname: *const libc::c_char,\n-    dli_saddr: *mut libc::c_void,\n-}\n-\n-extern {\n-    #[ link_name = \"_rtld_dladdr\" ]\n-    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n-}"}, {"sha": "d090caede437abc25749831a46fe2d99896a7300", "filename": "src/libstd/sys/vxworks/backtrace/printing/mod.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,33 +0,0 @@\n-mod dladdr;\n-\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-use crate::io;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub use self::dladdr::resolve_symname;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    Ok(false)\n-}\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub use crate::sys_common::gnu::libbacktrace::foreach_symbol_fileline;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub fn resolve_symname<F>(frame: Frame, callback: F, bc: &BacktraceContext) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    crate::sys_common::gnu::libbacktrace::resolve_symname(frame, |symname| {\n-        if symname.is_some() {\n-            callback(symname)\n-        } else {\n-            dladdr::resolve_symname(frame, callback, bc)\n-        }\n-    }, bc)\n-}"}, {"sha": "a628d107ad6fbd94f523f7c49a951cdea4c941c6", "filename": "src/libstd/sys/vxworks/backtrace/tracing/backtrace_fn.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,39 +0,0 @@\n-/// As always - iOS on arm uses SjLj exceptions and\n-/// _Unwind_Backtrace is even not available there. Still,\n-/// backtraces could be extracted using a backtrace function,\n-/// which thanks god is public\n-///\n-/// As mentioned in a huge comment block in `super::super`, backtrace\n-/// doesn't play well with green threads, so while it is extremely nice and\n-/// simple to use it should be used only on iOS devices as the only viable\n-/// option.\n-\n-use crate::io;\n-use crate::ptr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    const FRAME_LEN: usize = 100;\n-    assert!(FRAME_LEN >= frames.len());\n-    let mut raw_frames = [ptr::null_mut(); FRAME_LEN];\n-    let nb_frames = unsafe {\n-        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n-    } as usize;\n-    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n-        *to = Frame {\n-            exact_position: *from as *mut u8,\n-            symbol_addr: *from as *mut u8,\n-            inline_context: 0,\n-        };\n-    }\n-    Ok((nb_frames as usize, BacktraceContext))\n-}\n-\n-extern {\n-    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n-}"}, {"sha": "e6379132bafbe35552adac17dd543aaef39accf4", "filename": "src/libstd/sys/vxworks/backtrace/tracing/gcc_s.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,99 +0,0 @@\n-use crate::error::Error;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-use unwind as uw;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    let mut cx = Context {\n-        idx: 0,\n-        frames,\n-    };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context<'_>\n-                              as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               UnwindError(result_unwind)))\n-        }\n-    }\n-}\n-\n-extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe {\n-        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-    };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-    // it appears to work fine without it, so we only use\n-    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-    // slightly more accurate stack trace in the process.\n-    //\n-    // This is often because panic involves the last instruction of a\n-    // function being \"call std::rt::begin_unwind\", with no ret\n-    // instructions after it. This means that the return instruction\n-    // pointer points *outside* of the calling function, and by\n-    // unwinding it we go back to the original function.\n-    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-        ip\n-    } else {\n-        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-    };\n-\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}"}, {"sha": "11863e6454525b2c955b2103ac33dca3799a92ea", "filename": "src/libstd/sys/vxworks/backtrace/tracing/mod.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,8 +0,0 @@\n-pub use self::imp::*;\n-\n-#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-#[path = \"gcc_s.rs\"]\n-mod imp;\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[path = \"backtrace_fn.rs\"]\n-mod imp;"}, {"sha": "2e021980778e54c37420ee0f9caa4f44291b3701", "filename": "src/libstd/sys/vxworks/fast_thread_local.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,33 +1,10 @@\n+// Copyright (c) 2019 Wind River Systems, Inc.\n+\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-// Since what appears to be glibc 2.18 this symbol has been shipped which\n-// GCC and clang both use to invoke destructors in thread_local globals, so\n-// let's do the same!\n-//\n-// Note, however, that we run on lots older linuxes, as well as cross\n-// compiling from a newer linux to an older linux, so we also have a\n-// fallback implementation to use as well.\n-//\n-// Due to rust-lang/rust#18804, make sure this is not generic!\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    use crate::mem;\n     use crate::sys_common::thread_local::register_dtor_fallback;\n-\n-    extern {\n-        #[linkage = \"extern_weak\"]\n-        static __dso_handle: *mut u8;\n-        #[linkage = \"extern_weak\"]\n-        static __cxa_thread_atexit_impl: *const libc::c_void;\n-    }\n-    if !__cxa_thread_atexit_impl.is_null() {\n-        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                  arg: *mut u8,\n-                                  dso_handle: *mut u8) -> libc::c_int;\n-        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-        return\n-    }\n     register_dtor_fallback(t, dtor);\n }\n "}, {"sha": "ef896f6a6e8cfa176ef735fac60e026fb8589680", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -77,7 +77,7 @@ impl Thread {\n     }\n \n     pub fn set_name(_name: &CStr) {\n-        assert!(false, \"FIXME: set_name\");\n+        // VxWorks does not provide a way to set the task name except at creation time\n     }\n \n     pub fn sleep(dur: Duration) {"}, {"sha": "57da81b41e7ca0840b275ef8a5089bb47f3729e3", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -64,8 +64,24 @@ pub fn unsupported_err() -> Error {\n     Error::new(ErrorKind::Other, \"operation not supported on wasm yet\")\n }\n \n-pub fn decode_error_kind(_code: i32) -> ErrorKind {\n-    ErrorKind::Other\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        libc::EADDRINUSE => ErrorKind::AddrInUse,\n+        libc::ENOENT => ErrorKind::NotFound,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::EEXIST => ErrorKind::AlreadyExists,\n+        libc::EAGAIN => ErrorKind::WouldBlock,\n+        _ => ErrorKind::Other,\n+    }\n }\n \n // This enum is used as the storage for a bunch of types which can't actually"}, {"sha": "8279e5280e9249b2c53f69b1843ba5803b1882bd", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,7 +1,6 @@\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::vec;\n-use crate::sys::ArgsSysCall;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n@@ -11,9 +10,8 @@ pub unsafe fn cleanup() {\n }\n \n pub fn args() -> Args {\n-    let v = ArgsSysCall::perform();\n     Args {\n-        iter: v.into_iter(),\n+        iter: Vec::new().into_iter(),\n         _dont_send_or_sync_me: PhantomData,\n     }\n }"}, {"sha": "de0bb38dc319e7c9d0c0067700c39af650ef0888", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 221, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -15,11 +15,6 @@\n //! guaranteed to be a runtime error!\n \n use crate::os::raw::c_char;\n-use crate::ptr;\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{AsInner, FromInner};\n-use crate::ffi::{OsString, OsStr};\n-use crate::time::Duration;\n \n pub mod alloc;\n pub mod args;\n@@ -89,7 +84,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    ExitSysCall::perform(1)\n+    crate::arch::wasm32::unreachable()\n }\n \n // We don't have randomness yet, but I totally used a random number generator to\n@@ -100,218 +95,3 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     (1, 2)\n }\n-\n-// Implement a minimal set of system calls to enable basic IO\n-pub enum SysCallIndex {\n-    Read = 0,\n-    Write = 1,\n-    Exit = 2,\n-    Args = 3,\n-    GetEnv = 4,\n-    SetEnv = 5,\n-    Time = 6,\n-}\n-\n-#[repr(C)]\n-pub struct ReadSysCall {\n-    fd: usize,\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize,\n-}\n-\n-impl ReadSysCall {\n-    pub fn perform(fd: usize, buffer: &mut [u8]) -> usize {\n-        let mut call_record = ReadSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_mut_ptr(),\n-            result: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Read, &mut call_record) } {\n-            call_record.result\n-        } else {\n-            0\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct WriteSysCall {\n-    fd: usize,\n-    ptr: *const u8,\n-    len: usize,\n-}\n-\n-impl WriteSysCall {\n-    pub fn perform(fd: usize, buffer: &[u8]) {\n-        let mut call_record = WriteSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_ptr()\n-        };\n-        unsafe { syscall(SysCallIndex::Write, &mut call_record); }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct ExitSysCall {\n-    code: usize,\n-}\n-\n-impl ExitSysCall {\n-    pub fn perform(code: usize) -> ! {\n-        let mut call_record = ExitSysCall {\n-            code\n-        };\n-        unsafe {\n-            syscall(SysCallIndex::Exit, &mut call_record);\n-            crate::intrinsics::abort();\n-        }\n-    }\n-}\n-\n-fn receive_buffer<E, F: FnMut(&mut [u8]) -> Result<usize, E>>(estimate: usize, mut f: F)\n-    -> Result<Vec<u8>, E>\n-{\n-    let mut buffer = vec![0; estimate];\n-    loop {\n-        let result = f(&mut buffer)?;\n-        if result <= buffer.len() {\n-            buffer.truncate(result);\n-            break;\n-        }\n-        buffer.resize(result, 0);\n-    }\n-    Ok(buffer)\n-}\n-\n-#[repr(C)]\n-pub struct ArgsSysCall {\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize\n-}\n-\n-impl ArgsSysCall {\n-    pub fn perform() -> Vec<OsString> {\n-        receive_buffer(1024, |buffer| -> Result<usize, !> {\n-            let mut call_record = ArgsSysCall {\n-                len: buffer.len(),\n-                ptr: buffer.as_mut_ptr(),\n-                result: 0\n-            };\n-            if unsafe { syscall(SysCallIndex::Args, &mut call_record) } {\n-                Ok(call_record.result)\n-            } else {\n-                Ok(0)\n-            }\n-        })\n-            .unwrap()\n-            .split(|b| *b == 0)\n-            .map(|s| FromInner::from_inner(Buf { inner: s.to_owned() }))\n-            .collect()\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct GetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *mut u8,\n-    value_len: usize,\n-    result: usize\n-}\n-\n-impl GetEnvSysCall {\n-    pub fn perform(key: &OsStr) -> Option<OsString> {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        receive_buffer(64, |buffer| {\n-            let mut call_record = GetEnvSysCall {\n-                key_len: key_buf.len(),\n-                key_ptr: key_buf.as_ptr(),\n-                value_len: buffer.len(),\n-                value_ptr: buffer.as_mut_ptr(),\n-                result: !0usize\n-            };\n-            if unsafe { syscall(SysCallIndex::GetEnv, &mut call_record) } {\n-                if call_record.result == !0usize {\n-                    Err(())\n-                } else {\n-                    Ok(call_record.result)\n-                }\n-            } else {\n-                Err(())\n-            }\n-        }).ok().map(|s| {\n-            FromInner::from_inner(Buf { inner: s })\n-        })\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct SetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *const u8,\n-    value_len: usize\n-}\n-\n-impl SetEnvSysCall {\n-    pub fn perform(key: &OsStr, value: Option<&OsStr>) {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        let value_buf = value.map(|v| &AsInner::as_inner(v).inner);\n-        let mut call_record = SetEnvSysCall {\n-            key_len: key_buf.len(),\n-            key_ptr: key_buf.as_ptr(),\n-            value_len: value_buf.map(|v| v.len()).unwrap_or(!0usize),\n-            value_ptr: value_buf.map(|v| v.as_ptr()).unwrap_or(ptr::null())\n-        };\n-        unsafe { syscall(SysCallIndex::SetEnv, &mut call_record); }\n-    }\n-}\n-\n-pub enum TimeClock {\n-    Monotonic = 0,\n-    System = 1,\n-}\n-\n-#[repr(C)]\n-pub struct TimeSysCall {\n-    clock: usize,\n-    secs_hi: usize,\n-    secs_lo: usize,\n-    nanos: usize\n-}\n-\n-impl TimeSysCall {\n-    pub fn perform(clock: TimeClock) -> Duration {\n-        let mut call_record = TimeSysCall {\n-            clock: clock as usize,\n-            secs_hi: 0,\n-            secs_lo: 0,\n-            nanos: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Time, &mut call_record) } {\n-            Duration::new(\n-                ((call_record.secs_hi as u64) << 32) | (call_record.secs_lo as u64),\n-                call_record.nanos as u32\n-            )\n-        } else {\n-            panic!(\"Time system call is not implemented by WebAssembly host\");\n-        }\n-    }\n-}\n-\n-unsafe fn syscall<T>(index: SysCallIndex, data: &mut T) -> bool {\n-    #[cfg(feature = \"wasm_syscall\")]\n-    extern {\n-        #[no_mangle]\n-        fn rust_wasm_syscall(index: usize, data: *mut Void) -> usize;\n-    }\n-\n-    #[cfg(not(feature = \"wasm_syscall\"))]\n-    unsafe fn rust_wasm_syscall(_index: usize, _data: *mut Void) -> usize { 0 }\n-\n-    rust_wasm_syscall(index as usize, data as *mut T as *mut Void) != 0\n-}"}, {"sha": "890049e8bfae50f0fb7cc815730f4a72d7403efc", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -4,7 +4,7 @@ use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n use crate::str;\n-use crate::sys::{unsupported, Void, ExitSysCall, GetEnvSysCall, SetEnvSysCall};\n+use crate::sys::{unsupported, Void};\n \n pub fn errno() -> i32 {\n     0\n@@ -73,16 +73,16 @@ pub fn env() -> Env {\n     panic!(\"not supported on web assembly\")\n }\n \n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(GetEnvSysCall::perform(k))\n+pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(None)\n }\n \n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, Some(v)))\n+pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on wasm32-unknown-unknown\"))\n }\n \n-pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, None))\n+pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on wasm32-unknown-unknown\"))\n }\n \n pub fn temp_dir() -> PathBuf {\n@@ -94,7 +94,9 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(_code: i32) -> ! {\n-    ExitSysCall::perform(_code as isize as usize)\n+    unsafe {\n+        crate::arch::wasm32::unreachable();\n+    }\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "5a4e4505e93bddce1805a1f163e2df0c66bc7cfd", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,5 +1,4 @@\n use crate::io;\n-use crate::sys::{ReadSysCall, WriteSysCall};\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -12,8 +11,8 @@ impl Stdin {\n }\n \n impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        Ok(ReadSysCall::perform(0, buf))\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n     }\n }\n \n@@ -25,7 +24,6 @@ impl Stdout {\n \n impl io::Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(1, buf);\n         Ok(buf.len())\n     }\n \n@@ -42,7 +40,6 @@ impl Stderr {\n \n impl io::Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(2, buf);\n         Ok(buf.len())\n     }\n \n@@ -57,10 +54,6 @@ pub fn is_ebadf(_err: &io::Error) -> bool {\n     true\n }\n \n-pub fn panic_output() -> Option<impl io::Write> {\n-    if cfg!(feature = \"wasm_syscall\") {\n-        Stderr::new().ok()\n-    } else {\n-        None\n-    }\n+pub fn panic_output() -> Option<Vec<u8>> {\n+    None\n }"}, {"sha": "dd9ad3760b050799dbd200bbcacdfbb03429db83", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,5 +1,4 @@\n use crate::time::Duration;\n-use crate::sys::{TimeSysCall, TimeClock};\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -11,7 +10,7 @@ pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(TimeSysCall::perform(TimeClock::Monotonic))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub const fn zero() -> Instant {\n@@ -37,7 +36,7 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(TimeSysCall::perform(TimeClock::System))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub fn sub_time(&self, other: &SystemTime)"}, {"sha": "6be00bcef45c0eb4018dffd4871faa90b6554ed7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1789,11 +1789,11 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// An argument in a function header.\n+/// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: ThinVec<Attribute>,\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n@@ -1816,7 +1816,7 @@ pub enum SelfKind {\n \n pub type ExplicitSelf = Spanned<SelfKind>;\n \n-impl Arg {\n+impl Param {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n             if ident.name == kw::SelfLower {\n@@ -1843,14 +1843,14 @@ impl Arg {\n         }\n     }\n \n-    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Arg {\n+    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n             span,\n         });\n-        let arg = |mutbl, ty| Arg {\n+        let param = |mutbl, ty| Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n@@ -1862,9 +1862,9 @@ impl Arg {\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n-            SelfKind::Value(mutbl) => arg(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => arg(\n+            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n+            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => param(\n                 Mutability::Immutable,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n@@ -1887,17 +1887,17 @@ impl Arg {\n /// E.g., `fn foo(bar: baz)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Arg>,\n+    pub inputs: Vec<Param>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n }\n \n impl FnDecl {\n     pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Arg::to_self)\n+        self.inputs.get(0).and_then(Param::to_self)\n     }\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+        self.inputs.get(0).map(Param::is_self).unwrap_or(false)\n     }\n }\n "}, {"sha": "0e5cfa73a9e3afc29c5dbbc0b540a5e763107606", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -714,7 +714,7 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant, ast::Arg\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Param\n }\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "53f37bb10bdc0ecfb61bb228826c27c66fea896d", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f", "patch": "@@ -1,93 +0,0 @@\n-//! This module contains utilities for outputting metadata for diagnostic errors.\n-//!\n-//! Each set of errors is mapped to a metadata file by a name, which is\n-//! currently always a crate name.\n-\n-use std::collections::BTreeMap;\n-use std::env;\n-use std::fs::{remove_file, create_dir_all, File};\n-use std::io::Write;\n-use std::path::PathBuf;\n-use std::error::Error;\n-use rustc_serialize::json::as_json;\n-\n-use syntax_pos::{Span, FileName};\n-\n-use crate::ext::base::ExtCtxt;\n-use crate::diagnostics::plugin::{ErrorMap, ErrorInfo};\n-\n-/// JSON encodable/decodable version of `ErrorInfo`.\n-#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ErrorMetadata {\n-    pub description: Option<String>,\n-    pub use_site: Option<ErrorLocation>\n-}\n-\n-/// Mapping from error codes to metadata that can be (de)serialized.\n-pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n-\n-/// JSON encodable error location type with filename and line number.\n-#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ErrorLocation {\n-    pub filename: FileName,\n-    pub line: usize\n-}\n-\n-impl ErrorLocation {\n-    /// Creates an error location from a span.\n-    pub fn from_span(ecx: &ExtCtxt<'_>, sp: Span) -> ErrorLocation {\n-        let loc = ecx.source_map().lookup_char_pos(sp.lo());\n-        ErrorLocation {\n-            filename: loc.file.name.clone(),\n-            line: loc.line\n-        }\n-    }\n-}\n-\n-/// Gets the directory where metadata for a given `prefix` should be stored.\n-///\n-/// See `output_metadata`.\n-pub fn get_metadata_dir(prefix: &str) -> PathBuf {\n-    env::var_os(\"RUSTC_ERROR_METADATA_DST\")\n-        .map(PathBuf::from)\n-        .expect(\"env var `RUSTC_ERROR_METADATA_DST` isn't set\")\n-        .join(prefix)\n-}\n-\n-/// Map `name` to a path in the given directory: <directory>/<name>.json\n-fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n-    directory.join(format!(\"{}.json\", name))\n-}\n-\n-/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `prefix/name`.\n-///\n-/// For our current purposes the prefix is the target architecture and the name is a crate name.\n-/// If an error occurs steps will be taken to ensure that no file is created.\n-pub fn output_metadata(ecx: &ExtCtxt<'_>, prefix: &str, name: &str, err_map: &ErrorMap)\n-    -> Result<(), Box<dyn Error>>\n-{\n-    // Create the directory to place the file in.\n-    let metadata_dir = get_metadata_dir(prefix);\n-    create_dir_all(&metadata_dir)?;\n-\n-    // Open the metadata file.\n-    let metadata_path = get_metadata_path(metadata_dir, name);\n-    let mut metadata_file = File::create(&metadata_path)?;\n-\n-    // Construct a serializable map.\n-    let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n-        let key = k.as_str().to_string();\n-        let value = ErrorMetadata {\n-            description: description.map(|n| n.as_str().to_string()),\n-            use_site: use_site.map(|sp| ErrorLocation::from_span(ecx, sp))\n-        };\n-        (key, value)\n-    }).collect::<ErrorMetadataMap>();\n-\n-    // Write the data to the file, deleting it if the write fails.\n-    let result = write!(&mut metadata_file, \"{}\", as_json(&json_map));\n-    if result.is_err() {\n-        remove_file(&metadata_path)?;\n-    }\n-    Ok(result?)\n-}"}, {"sha": "e9a55af52e8780001625dbd79a97fd9632edbe62", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::env;\n \n use crate::ast::{self, Ident, Name};\n use crate::source_map;\n@@ -12,8 +11,6 @@ use crate::tokenstream::{TokenTree};\n use smallvec::smallvec;\n use syntax_pos::Span;\n \n-use crate::diagnostics::metadata::output_metadata;\n-\n pub use errors::*;\n \n // Maximum width of any line in an extended error description (inclusive).\n@@ -127,36 +124,13 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                           token_tree: &[TokenTree])\n                                           -> Box<dyn MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n-    let (crate_name, ident) = match (&token_tree[0], &token_tree[2]) {\n-        (\n-            // Crate name.\n-            &TokenTree::Token(Token { kind: token::Ident(crate_name, _), .. }),\n-            // DIAGNOSTICS ident.\n-            &TokenTree::Token(Token { kind: token::Ident(name, _), span })\n-        ) => (crate_name, Ident::new(name, span)),\n+    let ident = match &token_tree[2] {\n+        // DIAGNOSTICS ident.\n+        &TokenTree::Token(Token { kind: token::Ident(name, _), span })\n+        => Ident::new(name, span),\n         _ => unreachable!()\n     };\n \n-    // Output error metadata to `tmp/extended-errors/<target arch>/<crate name>.json`\n-    if let Ok(target_triple) = env::var(\"CFG_COMPILER_HOST_TRIPLE\") {\n-        ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n-            if let Err(e) = output_metadata(ecx,\n-                                            &target_triple,\n-                                            &crate_name.as_str(),\n-                                            diagnostics) {\n-                ecx.span_bug(span, &format!(\n-                    \"error writing metadata for triple `{}` and crate `{}`, error: {}, \\\n-                     cause: {:?}\",\n-                    target_triple, crate_name, e.description(), e.source()\n-                ));\n-            }\n-        });\n-    } else {\n-        ecx.span_err(span, &format!(\n-            \"failed to write metadata for crate `{}` because $CFG_COMPILER_HOST_TRIPLE is not set\",\n-            crate_name));\n-    }\n-\n     // Construct the output expression.\n     let (count, expr) =\n         ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {"}, {"sha": "5d68983d7cb66647515c195cda7b9cb3a50d0b4e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 110, "deletions": 35, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,16 +1,17 @@\n use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n-use crate::attr::{HasAttrs, Stability, Deprecation};\n+use crate::attr::{self, HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{ExpnId, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n-use crate::parse::{self, parser, DirectoryOwnership};\n+use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n+use crate::visit::Visitor;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n@@ -72,6 +73,17 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n+        match self {\n+            Annotatable::Item(item) => visitor.visit_item(item),\n+            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n+            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n+            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n+            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -549,8 +561,6 @@ pub struct SyntaxExtension {\n     pub kind: SyntaxExtensionKind,\n     /// Span of the macro definition.\n     pub span: Span,\n-    /// Hygienic properties of spans produced by this macro by default.\n-    pub default_transparency: Transparency,\n     /// Whitelist of unstable features that are treated as stable inside this macro.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     /// Suppresses the `unsafe_code` lint for code produced by this macro.\n@@ -572,22 +582,6 @@ pub struct SyntaxExtension {\n     pub is_derive_copy: bool,\n }\n \n-impl SyntaxExtensionKind {\n-    /// When a syntax extension is constructed,\n-    /// its transparency can often be inferred from its kind.\n-    fn default_transparency(&self) -> Transparency {\n-        match self {\n-            SyntaxExtensionKind::Bang(..) |\n-            SyntaxExtensionKind::Attr(..) |\n-            SyntaxExtensionKind::Derive(..) |\n-            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtensionKind::LegacyBang(..) |\n-            SyntaxExtensionKind::LegacyAttr(..) |\n-            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n-        }\n-    }\n-}\n-\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n     pub fn macro_kind(&self) -> MacroKind {\n@@ -606,7 +600,6 @@ impl SyntaxExtension {\n     pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n         SyntaxExtension {\n             span: DUMMY_SP,\n-            default_transparency: kind.default_transparency(),\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n@@ -620,6 +613,69 @@ impl SyntaxExtension {\n         }\n     }\n \n+    /// Constructs a syntax extension with the given properties\n+    /// and other properties converted from attributes.\n+    pub fn new(\n+        sess: &ParseSess,\n+        kind: SyntaxExtensionKind,\n+        span: Span,\n+        helper_attrs: Vec<Symbol>,\n+        edition: Edition,\n+        name: Name,\n+        attrs: &[ast::Attribute],\n+    ) -> SyntaxExtension {\n+        let allow_internal_unstable =\n+            attr::find_by_name(attrs, sym::allow_internal_unstable).map(|attr| {\n+                attr.meta_item_list()\n+                    .map(|list| {\n+                        list.iter()\n+                            .filter_map(|it| {\n+                                let name = it.ident().map(|ident| ident.name);\n+                                if name.is_none() {\n+                                    sess.span_diagnostic.span_err(\n+                                        it.span(), \"allow internal unstable expects feature names\"\n+                                    )\n+                                }\n+                                name\n+                            })\n+                            .collect::<Vec<Symbol>>()\n+                            .into()\n+                    })\n+                    .unwrap_or_else(|| {\n+                        sess.span_diagnostic.span_warn(\n+                            attr.span,\n+                            \"allow_internal_unstable expects list of feature names. In the future \\\n+                             this will become a hard error. Please use `allow_internal_unstable(\\\n+                             foo, bar)` to only allow the `foo` and `bar` features\",\n+                        );\n+                        vec![sym::allow_internal_unstable_backcompat_hack].into()\n+                    })\n+            });\n+\n+        let mut local_inner_macros = false;\n+        if let Some(macro_export) = attr::find_by_name(attrs, sym::macro_export) {\n+            if let Some(l) = macro_export.meta_item_list() {\n+                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n+            }\n+        }\n+\n+        let is_builtin = attr::contains_name(attrs, sym::rustc_builtin_macro);\n+\n+        SyntaxExtension {\n+            kind,\n+            span,\n+            allow_internal_unstable,\n+            allow_internal_unsafe: attr::contains_name(attrs, sym::allow_internal_unsafe),\n+            local_inner_macros,\n+            stability: attr::find_stability(&sess, attrs, span),\n+            deprecation: attr::find_deprecation(&sess, attrs, span),\n+            helper_attrs,\n+            edition,\n+            is_builtin,\n+            is_derive_copy: is_builtin && name == sym::Copy,\n+        }\n+    }\n+\n     pub fn dummy_bang(edition: Edition) -> SyntaxExtension {\n         fn expander<'cx>(_: &'cx mut ExtCtxt<'_>, span: Span, _: &[TokenTree])\n                          -> Box<dyn MacResult + 'cx> {\n@@ -646,7 +702,6 @@ impl SyntaxExtension {\n             parent,\n             call_site,\n             def_site: self.span,\n-            default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n             allow_internal_unsafe: self.allow_internal_unsafe,\n             local_inner_macros: self.local_inner_macros,\n@@ -657,6 +712,12 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Result of resolving a macro invocation.\n+pub enum InvocationRes {\n+    Single(Lrc<SyntaxExtension>),\n+    DeriveContainer(Vec<Lrc<SyntaxExtension>>),\n+}\n+\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n@@ -682,8 +743,9 @@ pub trait Resolver {\n \n     fn resolve_imports(&mut self);\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n+    fn resolve_macro_invocation(\n+        &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n+    ) -> Result<InvocationRes, Indeterminate>;\n \n     fn check_unused_macros(&self);\n \n@@ -759,23 +821,39 @@ impl<'a> ExtCtxt<'a> {\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site\n     }\n-    pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::root().apply_mark(self.current_expansion.id)\n+\n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Option<Span> {\n-        let mut ctxt = self.backtrace();\n+        let mut expn_id = self.current_expansion.id;\n         let mut last_macro = None;\n         loop {\n-            let expn_data = ctxt.outer_expn_data();\n+            let expn_data = expn_id.expn_data();\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n                 break;\n             }\n-            ctxt = expn_data.call_site.ctxt();\n+            expn_id = expn_data.call_site.ctxt().outer_expn();\n             last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n@@ -864,7 +942,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n-        let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n+        let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n@@ -908,12 +986,9 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns `None`.\n pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n-    mut expr: P<ast::Expr>,\n+    expr: P<ast::Expr>,\n     err_msg: &str,\n ) -> Result<(Symbol, ast::StrStyle, Span), Option<DiagnosticBuilder<'a>>> {\n-    // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n-    expr.span = expr.span.apply_mark(cx.current_expansion.id);\n-\n     // Perform eager expansion on the expression.\n     // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();"}, {"sha": "e894fd17ff5870341a0e4e7c3db35c5a50dc45be", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -655,7 +655,7 @@ impl<'a> ExtCtxt<'a> {\n               body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n-            ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n+            ids.iter().map(|id| self.param(span, *id, self.ty_infer(span))).collect(),\n             ast::FunctionRetTy::Default(span));\n \n         // FIXME -- We are using `span` as the span of the `|...|`\n@@ -693,9 +693,9 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n-    pub fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {\n+    pub fn param(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Param {\n         let arg_pat = self.pat_ident(span, ident);\n-        ast::Arg {\n+        ast::Param {\n             attrs: ThinVec::default(),\n             id: ast::DUMMY_NODE_ID,\n             pat: arg_pat,\n@@ -705,7 +705,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     // FIXME: unused `self`\n-    pub fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: Vec<ast::Param>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs,\n             output,\n@@ -731,7 +731,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: Vec<ast::Arg> ,\n+                    inputs: Vec<ast::Param> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> P<ast::Item> {\n@@ -752,7 +752,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: Vec<ast::Arg> ,\n+               inputs: Vec<ast::Param> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n               ) -> P<ast::Item> {"}, {"sha": "7b4a516744642075301dec2c73e4cb21aacb85e6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::proc_macro::collect_derives;\n+use crate::ext::proc_macro::{collect_derives, MarkAttrs};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -305,10 +305,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue\n             };\n \n-            let scope =\n+            let eager_expansion_root =\n                 if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n-                Ok(ext) => ext,\n+            let res = match self.cx.resolver.resolve_macro_invocation(\n+                &invoc, eager_expansion_root, force\n+            ) {\n+                Ok(res) => res,\n                 Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n@@ -318,57 +320,74 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             progress = true;\n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n-            self.cx.current_expansion.id = scope;\n \n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let fragment = self.expand_invoc(invoc, &ext.kind);\n-                self.collect_invocations(fragment, &[])\n-            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n-                if !item.derive_allowed() {\n-                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                        .expect(\"`derive` attribute should exist\");\n-                    let span = attr.span;\n-                    let mut err = self.cx.mut_span_err(span,\n-                                                        \"`derive` may only be applied to \\\n-                                                        structs, enums and unions\");\n-                    if let ast::AttrStyle::Inner = attr.style {\n-                        let trait_list = traits.iter()\n-                            .map(|t| t.to_string()).collect::<Vec<_>>();\n-                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                        err.span_suggestion(\n-                            span, \"try an outer attribute\", suggestion,\n-                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                            Applicability::MaybeIncorrect\n-                        );\n-                    }\n-                    err.emit();\n+            let (expanded_fragment, new_invocations) = match res {\n+                InvocationRes::Single(ext) => {\n+                    let fragment = self.expand_invoc(invoc, &ext.kind);\n+                    self.collect_invocations(fragment, &[])\n                 }\n+                InvocationRes::DeriveContainer(exts) => {\n+                    let (derives, item) = match invoc.kind {\n+                        InvocationKind::DeriveContainer { derives, item } => (derives, item),\n+                        _ => unreachable!(),\n+                    };\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                            .expect(\"`derive` attribute should exist\");\n+                        let span = attr.span;\n+                        let mut err = self.cx.mut_span_err(span,\n+                            \"`derive` may only be applied to structs, enums and unions\");\n+                        if let ast::AttrStyle::Inner = attr.style {\n+                            let trait_list = derives.iter()\n+                                .map(|t| t.to_string()).collect::<Vec<_>>();\n+                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                            err.span_suggestion(\n+                                span, \"try an outer attribute\", suggestion,\n+                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                                Applicability::MaybeIncorrect\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n \n-                let mut item = self.fully_configure(item);\n-                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derive_placeholders =\n-                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n-\n-                derive_placeholders.reserve(traits.len());\n-                invocations.reserve(traits.len());\n-                for path in traits {\n-                    let expn_id = ExpnId::fresh(None);\n-                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                    invocations.push(Invocation {\n-                        kind: InvocationKind::Derive { path, item: item.clone() },\n-                        fragment_kind: invoc.fragment_kind,\n-                        expansion_data: ExpansionData {\n-                            id: expn_id,\n-                            ..invoc.expansion_data.clone()\n-                        },\n-                    });\n+                    let mut item = self.fully_configure(item);\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                    let mut helper_attrs = Vec::new();\n+                    let mut has_copy = false;\n+                    for ext in exts {\n+                        helper_attrs.extend(&ext.helper_attrs);\n+                        has_copy |= ext.is_derive_copy;\n+                    }\n+                    // Mark derive helpers inside this item as known and used.\n+                    // FIXME: This is a hack, derive helpers should be integrated with regular name\n+                    // resolution instead. For example, helpers introduced by a derive container\n+                    // can be in scope for all code produced by that container's expansion.\n+                    item.visit_with(&mut MarkAttrs(&helper_attrs));\n+                    if has_copy {\n+                        self.cx.resolver.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                    }\n+\n+                    let derive_placeholders =\n+                        all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n+                    derive_placeholders.reserve(derives.len());\n+                    invocations.reserve(derives.len());\n+                    for path in derives {\n+                        let expn_id = ExpnId::fresh(None);\n+                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n+                        invocations.push(Invocation {\n+                            kind: InvocationKind::Derive { path, item: item.clone() },\n+                            fragment_kind: invoc.fragment_kind,\n+                            expansion_data: ExpansionData {\n+                                id: expn_id,\n+                                ..invoc.expansion_data.clone()\n+                            },\n+                        });\n+                    }\n+                    let fragment = invoc.fragment_kind\n+                        .expect_from_annotatables(::std::iter::once(item));\n+                    self.collect_invocations(fragment, derive_placeholders)\n                 }\n-                let fragment = invoc.fragment_kind\n-                    .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derive_placeholders)\n-            } else {\n-                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {\n@@ -564,7 +583,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         return fragment_kind.dummy(span);\n                     }\n                     let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n-                    let span = span.with_ctxt(self.cx.backtrace());\n                     let items = expander.expand(self.cx, span, &meta, item);\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n@@ -1209,9 +1227,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n     }\n \n-    fn visit_generic_params(&mut self, params: &mut Vec<ast::GenericParam>) {\n-        self.cfg.configure_generic_params(params);\n-        noop_visit_generic_params(params, self);\n+   fn flat_map_generic_param(\n+       &mut self,\n+       param: ast::GenericParam\n+    ) -> SmallVec<[ast::GenericParam; 1]>\n+    {\n+        let param = configure!(self, param);\n+        noop_flat_map_generic_param(param, self)\n     }\n \n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n@@ -1388,17 +1410,3 @@ impl<'feat> ExpansionConfig<'feat> {\n         self.features.map_or(false, |features| features.custom_inner_attributes)\n     }\n }\n-\n-// A Marker adds the given mark to the syntax context.\n-#[derive(Debug)]\n-pub struct Marker(pub ExpnId);\n-\n-impl MutVisitor for Marker {\n-    fn visit_span(&mut self, span: &mut Span) {\n-        *span = span.apply_mark(self.0)\n-    }\n-\n-    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-        noop_visit_mac(mac, self)\n-    }\n-}"}, {"sha": "4a44c9a9f1f312d7e690a37780dfea2ebb76a02e", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -78,7 +78,6 @@ pub struct ProcMacroDerive {\n     pub client: proc_macro::bridge::client::Client<\n         fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n-    pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -111,9 +110,6 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n         let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n         let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n \n@@ -164,7 +160,7 @@ impl MultiItemModifier for ProcMacroDerive {\n     }\n }\n \n-struct MarkAttrs<'a>(&'a [ast::Name]);\n+crate struct MarkAttrs<'a>(crate &'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {"}, {"sha": "1a26b17dac782fae18ee1ff86c3b872e17162a33", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -7,7 +7,6 @@ use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint}\n use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n-use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n \n use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n@@ -361,18 +360,11 @@ pub(crate) struct Rustc<'a> {\n \n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n-        // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_data().call_site;\n-        let to_span = |transparency| {\n-            location.with_ctxt(\n-                SyntaxContext::root()\n-                    .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n-            )\n-        };\n+        let expn_data = cx.current_expansion.id.expn_data();\n         Rustc {\n             sess: cx.parse_sess,\n-            def_site: to_span(Transparency::Opaque),\n-            call_site: to_span(Transparency::Transparent),\n+            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n+            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n         }\n     }\n "}, {"sha": "46ffa52f7f5725a1f652948151f23f94ffcd3a49", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 24, "deletions": 64, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,3 +1,5 @@\n+use crate::ast;\n+use crate::attr::{self, TransparencyError};\n use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n@@ -15,10 +17,10 @@ use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n-use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -128,6 +130,7 @@ impl<'a> ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     span: Span,\n+    transparency: Transparency,\n     lhses: Vec<quoted::TokenTree>,\n     rhses: Vec<quoted::TokenTree>,\n     valid: bool,\n@@ -143,7 +146,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx, sp, self.span, self.name, input, &self.lhses, &self.rhses)\n+        generic_extension(\n+            cx, sp, self.span, self.name, self.transparency, input, &self.lhses, &self.rhses\n+        )\n     }\n }\n \n@@ -158,6 +163,7 @@ fn generic_extension<'cx>(\n     sp: Span,\n     def_span: Span,\n     name: ast::Ident,\n+    transparency: Transparency,\n     arg: TokenStream,\n     lhses: &[quoted::TokenTree],\n     rhses: &[quoted::TokenTree],\n@@ -187,7 +193,7 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs);\n+                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -285,6 +291,7 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    let diag = &sess.span_diagnostic;\n     let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n     let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n@@ -415,75 +422,28 @@ pub fn compile(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let expander: Box<_> =\n-        Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n-\n-    let (default_transparency, transparency_error) =\n-        attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n-            sess.span_diagnostic.span_err(\n-                span, &format!(\"unknown macro transparency: `{}`\", value)\n-            ),\n+            diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value)),\n         Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) =>\n-            sess.span_diagnostic.span_err(\n-                vec![old_span, new_span], \"multiple macro transparency attributes\"\n-            ),\n+            diag.span_err(vec![old_span, new_span], \"multiple macro transparency attributes\"),\n         None => {}\n     }\n \n-    let allow_internal_unstable =\n-        attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n-            attr.meta_item_list()\n-                .map(|list| {\n-                    list.iter()\n-                        .filter_map(|it| {\n-                            let name = it.ident().map(|ident| ident.name);\n-                            if name.is_none() {\n-                                sess.span_diagnostic.span_err(\n-                                    it.span(),\n-                                    \"allow internal unstable expects feature names\",\n-                                )\n-                            }\n-                            name\n-                        })\n-                        .collect::<Vec<Symbol>>()\n-                        .into()\n-                })\n-                .unwrap_or_else(|| {\n-                    sess.span_diagnostic.span_warn(\n-                        attr.span,\n-                        \"allow_internal_unstable expects list of feature names. In the \\\n-                         future this will become a hard error. Please use `allow_internal_unstable(\\\n-                         foo, bar)` to only allow the `foo` and `bar` features\",\n-                    );\n-                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n-                })\n-        });\n-\n-    let mut local_inner_macros = false;\n-    if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n-        if let Some(l) = macro_export.meta_item_list() {\n-            local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-        }\n-    }\n+    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+        name: def.ident, span: def.span, transparency, lhses, rhses, valid\n+    });\n \n-    let is_builtin = attr::contains_name(&def.attrs, sym::rustc_builtin_macro);\n-\n-    SyntaxExtension {\n-        kind: SyntaxExtensionKind::LegacyBang(expander),\n-        span: def.span,\n-        default_transparency,\n-        allow_internal_unstable,\n-        allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n-        local_inner_macros,\n-        stability: attr::find_stability(&sess, &def.attrs, def.span),\n-        deprecation: attr::find_deprecation(&sess, &def.attrs, def.span),\n-        helper_attrs: Vec::new(),\n+    SyntaxExtension::new(\n+        sess,\n+        SyntaxExtensionKind::LegacyBang(expander),\n+        def.span,\n+        Vec::new(),\n         edition,\n-        is_builtin,\n-        is_derive_copy: is_builtin && def.ident.name == sym::Copy,\n-    }\n+        def.ident.name,\n+        &def.attrs,\n+    )\n }\n \n fn check_lhs_nt_follows("}, {"sha": "30d5df13dcedb1d3551c2cb337f3d76a25f36b5d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d", "patch": "@@ -1,18 +1,40 @@\n-use crate::ast::Ident;\n+use crate::ast::{Ident, Mac};\n use crate::ext::base::ExtCtxt;\n-use crate::ext::expand::Marker;\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n-use crate::mut_visit::noop_visit_tt;\n+use crate::mut_visit::{self, MutVisitor};\n use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnId, Transparency};\n+use syntax_pos::Span;\n+\n use std::mem;\n \n+// A Marker adds the given mark to the syntax context.\n+struct Marker(ExpnId, Transparency);\n+\n+impl MutVisitor for Marker {\n+    fn visit_span(&mut self, span: &mut Span) {\n+        *span = span.apply_mark(self.0, self.1)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &mut Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n+    }\n+}\n+\n+impl Marker {\n+    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n+        self.visit_span(&mut dspan.open);\n+        self.visit_span(&mut dspan.close);\n+    }\n+}\n+\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n@@ -68,6 +90,7 @@ pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n     interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n+    transparency: Transparency,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n@@ -96,6 +119,7 @@ pub(super) fn transcribe(\n     // again, and we are done transcribing.\n     let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n+    let mut marker = Marker(cx.current_expansion.id, transparency);\n \n     loop {\n         // Look at the last frame on the stack.\n@@ -207,7 +231,7 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            quoted::TokenTree::MetaVar(mut sp, ident) => {\n+            quoted::TokenTree::MetaVar(mut sp, mut ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n@@ -218,7 +242,7 @@ pub(super) fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.id);\n+                            marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -232,9 +256,8 @@ pub(super) fn transcribe(\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n-                    let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n-                    sp = sp.apply_mark(cx.current_expansion.id);\n+                    marker.visit_span(&mut sp);\n+                    marker.visit_ident(&mut ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -246,17 +269,16 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.id);\n+                marker.visit_delim_span(&mut span);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n-                noop_visit_tt(&mut tt, &mut marker);\n+                marker.visit_tt(&mut tt);\n                 result.push(tt.into());\n             }\n "}, {"sha": "bce0b07db1c233b3f84bd207eb78dadf83bbc05c", "filename": "src/libsyntax/feature_gate.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964c37cdecbd1aa0e7870afac9ba38e5168be65f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=964c37cdecbd1aa0e7870afac9ba38e5168be65f"}, {"sha": "6c0b271c6c5e909dec9d18bcdef3796c6fd27d17", "filename": "src/libsyntax/feature_gate/accepted.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "c947b09fdcb57822b6363976ff90bc6567202c7d", "filename": "src/libsyntax/feature_gate/active.rs", "status": "added", "additions": 549, "deletions": 0, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "ee7ac3b15d9550cf651a0a0039f93f72a443f9cd", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "f3a9d135125aee6abe08c123b0753080edb57452", "filename": "src/libsyntax/feature_gate/check.rs", "status": "added", "additions": 958, "deletions": 0, "changes": 958, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "1e41667ea411ec9f495459c440516a6820debcd8", "filename": "src/libsyntax/feature_gate/mod.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "ad7d69b3e7372e61441e6c8cc5f159c064cfdc4d", "filename": "src/libsyntax/feature_gate/removed.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "ada46f7bc5a746f62814866ee3fd37f8565aef33", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "1741932c1b80e30f86abfe47d345b37678f24068", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "e14ca4b06a09e036e1dda4906c0a553bc1c1be98", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 77, "deletions": 49, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "671178223f50377363980a63901b7286984e680b", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "d4e661d1a38b78b2f08df50bc92ac343f7113f48", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "652ae95c8534973587e884d152fc7769fee0d862", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "36233de3cfb576412c524e5ff5ec633f5efe7a6e", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "b1af4806e2d787dde3b9f17b200550fc42931834", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "49b05551bae8694408fc0af1f30367ceb492b5df", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "5b9f0f1df671865804c7e97e52920762551a8169", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "59a3ade9c30e59e2d648b83ebb466f172a9c3e63", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "823f880337d138bc2faeb8c6fb89c8ec9af78171", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 320, "deletions": 123, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "d4b13cc2e0121134676abc43554678bfac421024", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "651ebf6342e715ac136738c9b474d4f483bc7651", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "465e31ac57e64a074bfb3bd80d0efc4f7ea58236", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "fe3b51aa246b8cbddc326c9684ce76d07998184f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "bead941b20d5a1f6cc4235c9756c58be5ad89cb3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "c472212bc20962b6bc202ea8184b3562e46a65b5", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "0d9f3769ce90447133c3e3a548eaaf60406ec789", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "a64fec7096132303f403d2edda33f05674fa949f", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "ce1568316f8d49eac326d1d39ff2113a998d8f67", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "28f907441d872391f8d3eb17aa98b9b3c13fd81c", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "84583d0e5eca7410e2e23a0afd448386c2cc1f1b", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "21cee8ae1cb9c661c630ee9f788450e5d4d93aab", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "ffa5154ca0c36b6cc1b03e2ae57b9be7303b7039", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "96677072d1b80bfc153e2fd2ac96afbc9570665e", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "4dd0ecfebefd41d8ed260dbfd459834469870868", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "32ab47969ada4f6c9f36640d5eac0fb162904852", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}, {"sha": "781645a574e9ac76993e70aa86b86c713b1bfb04", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e316ba3b60433bd703575a00d7fd5e344e29912d/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=e316ba3b60433bd703575a00d7fd5e344e29912d"}]}