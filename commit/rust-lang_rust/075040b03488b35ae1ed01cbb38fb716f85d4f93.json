{"sha": "075040b03488b35ae1ed01cbb38fb716f85d4f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NTA0MGIwMzQ4OGIzNWFlMWVkMDFjYmIzOGZiNzE2Zjg1ZDRmOTM=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-03-17T12:57:09Z"}, "committer": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-03-17T12:57:09Z"}, "message": "Merge pull request #772 from oli-obk/const_int\n\nrefactor clippy-consts to use ConstInt", "tree": {"sha": "d3b6055f3d6156361a19856e35d68be4cc1460be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b6055f3d6156361a19856e35d68be4cc1460be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075040b03488b35ae1ed01cbb38fb716f85d4f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075040b03488b35ae1ed01cbb38fb716f85d4f93", "html_url": "https://github.com/rust-lang/rust/commit/075040b03488b35ae1ed01cbb38fb716f85d4f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075040b03488b35ae1ed01cbb38fb716f85d4f93/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe1ded0228e5dbd3b3bc8ddd8d87474208aaeb1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1ded0228e5dbd3b3bc8ddd8d87474208aaeb1b", "html_url": "https://github.com/rust-lang/rust/commit/fe1ded0228e5dbd3b3bc8ddd8d87474208aaeb1b"}, {"sha": "64110f16dd5fc8b28bcee3f4291f8c4ffb6162aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/64110f16dd5fc8b28bcee3f4291f8c4ffb6162aa", "html_url": "https://github.com/rust-lang/rust/commit/64110f16dd5fc8b28bcee3f4291f8c4ffb6162aa"}], "stats": {"total": 304, "additions": 71, "deletions": 233}, "files": [{"sha": "3e08f1b74ff847a0ad062ae463ce39957960a9db", "filename": "src/consts.rs", "status": "modified", "additions": 55, "deletions": 224, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/075040b03488b35ae1ed01cbb38fb716f85d4f93/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075040b03488b35ae1ed01cbb38fb716f85d4f93/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=075040b03488b35ae1ed01cbb38fb716f85d4f93", "patch": "@@ -4,13 +4,14 @@ use rustc::lint::LateContext;\n use rustc::middle::const_eval::lookup_const_by_id;\n use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n-use std::cmp::Ordering::{self, Greater, Less, Equal};\n+use rustc_const_eval::{ConstInt, ConstUsize, ConstIsize};\n+use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy};\n+use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -29,25 +30,17 @@ impl From<FloatTy> for FloatWidth {\n     }\n }\n \n-#[derive(Copy, Eq, Debug, Clone, PartialEq, Hash)]\n-pub enum Sign {\n-    Plus,\n-    Minus,\n-}\n-\n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\"\n     Str(String, StrStyle),\n     /// a Binary String b\"abc\"\n     Binary(Rc<Vec<u8>>),\n-    /// a single byte b'a'\n-    Byte(u8),\n     /// a single char 'a'\n     Char(char),\n     /// an integer, third argument is whether the value is negated\n-    Int(u64, LitIntType, Sign),\n+    Int(ConstInt),\n     /// a float with given type\n     Float(String, FloatWidth),\n     /// true or false\n@@ -67,21 +60,20 @@ impl Constant {\n     ///\n     /// if the constant could not be converted to u64 losslessly\n     fn as_u64(&self) -> u64 {\n-        if let Constant::Int(val, _, _) = *self {\n-            val // TODO we may want to check the sign if any\n+        if let Constant::Int(val) = *self {\n+            val.to_u64().expect(\"negative constant can't be casted to u64\")\n         } else {\n             panic!(\"Could not convert a {:?} to u64\", self);\n         }\n     }\n \n     /// convert this constant to a f64, if possible\n-    #[allow(cast_precision_loss)]\n+    #[allow(cast_precision_loss, cast_possible_wrap)]\n     pub fn as_float(&self) -> Option<f64> {\n         match *self {\n-            Constant::Byte(b) => Some(b as f64),\n             Constant::Float(ref s, _) => s.parse().ok(),\n-            Constant::Int(i, _, Sign::Minus) => Some(-(i as f64)),\n-            Constant::Int(i, _, Sign::Plus) => Some(i as f64),\n+            Constant::Int(i) if i.is_negative() => Some(i.to_u64_unchecked() as i64 as f64),\n+            Constant::Int(i) => Some(i.to_u64_unchecked() as f64),\n             _ => None,\n         }\n     }\n@@ -92,10 +84,8 @@ impl PartialEq for Constant {\n         match (self, other) {\n             (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n-            (&Constant::Byte(l), &Constant::Byte(r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(0, _, _), &Constant::Int(0, _, _)) => true,\n-            (&Constant::Int(lv, _, lneg), &Constant::Int(rv, _, rneg)) => lv == rv && lneg == rneg,\n+            (&Constant::Int(l), &Constant::Int(r)) => l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked(),\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n@@ -125,15 +115,12 @@ impl Hash for Constant {\n             Constant::Binary(ref b) => {\n                 b.hash(state);\n             }\n-            Constant::Byte(u) => {\n-                u.hash(state);\n-            }\n             Constant::Char(c) => {\n                 c.hash(state);\n             }\n-            Constant::Int(u, _, t) => {\n-                u.hash(state);\n-                t.hash(state);\n+            Constant::Int(i) => {\n+                i.to_u64_unchecked().hash(state);\n+                i.is_negative().hash(state);\n             }\n             Constant::Float(ref f, _) => {\n                 // don\u2019t use the width here because of PartialEq implementation\n@@ -165,13 +152,8 @@ impl PartialOrd for Constant {\n                     None\n                 }\n             }\n-            (&Constant::Byte(ref l), &Constant::Byte(ref r)) => Some(l.cmp(r)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(0, _, _), &Constant::Int(0, _, _)) => Some(Equal),\n-            (&Constant::Int(ref lv, _, Sign::Plus), &Constant::Int(ref rv, _, Sign::Plus)) => Some(lv.cmp(rv)),\n-            (&Constant::Int(ref lv, _, Sign::Minus), &Constant::Int(ref rv, _, Sign::Minus)) => Some(rv.cmp(lv)),\n-            (&Constant::Int(_, _, Sign::Minus), &Constant::Int(_, _, Sign::Plus)) => Some(Less),\n-            (&Constant::Int(_, _, Sign::Plus), &Constant::Int(_, _, Sign::Minus)) => Some(Greater),\n+            (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 match (ls.parse::<f64>(), rs.parse::<f64>()) {\n                     (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n@@ -192,13 +174,24 @@ impl PartialOrd for Constant {\n     }\n }\n \n+#[allow(cast_possible_wrap)]\n fn lit_to_constant(lit: &LitKind) -> Constant {\n     match *lit {\n         LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n-        LitKind::Byte(b) => Constant::Byte(b),\n+        LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n         LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(value, ty) => Constant::Int(value, ty, Sign::Plus),\n+        LitKind::Int(value, LitIntType::Unsuffixed) => Constant::Int(ConstInt::Infer(value)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::U8)) => Constant::Int(ConstInt::U8(value as u8)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32))),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32))),\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -209,44 +202,20 @@ fn constant_not(o: Constant) -> Option<Constant> {\n     use self::Constant::*;\n     match o {\n         Bool(b) => Some(Bool(!b)),\n-        Int(value, LitIntType::Signed(ity), Sign::Plus) if value != ::std::u64::MAX => {\n-            Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus))\n-        }\n-        Int(0, LitIntType::Signed(ity), Sign::Minus) => Some(Int(1, LitIntType::Signed(ity), Sign::Minus)),\n-        Int(value, LitIntType::Signed(ity), Sign::Minus) => Some(Int(value - 1, LitIntType::Signed(ity), Sign::Plus)),\n-        Int(value, LitIntType::Unsigned(ity), Sign::Plus) => {\n-            let mask = match ity {\n-                UintTy::U8 => ::std::u8::MAX as u64,\n-                UintTy::U16 => ::std::u16::MAX as u64,\n-                UintTy::U32 => ::std::u32::MAX as u64,\n-                UintTy::U64 => ::std::u64::MAX,\n-                UintTy::Us => {\n-                    return None;\n-                }  // refuse to guess\n-            };\n-            Some(Int(!value & mask, LitIntType::Unsigned(ity), Sign::Plus))\n-        }\n+        Int(value) => (!value).ok().map(Int),\n         _ => None,\n     }\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n     use self::Constant::*;\n     match o {\n-        Int(value, LitIntType::Signed(ity), sign) => Some(Int(value, LitIntType::Signed(ity), neg_sign(sign))),\n-        Int(value, LitIntType::Unsuffixed, sign) => Some(Int(value, LitIntType::Unsuffixed, neg_sign(sign))),\n+        Int(value) => (-value).ok().map(Int),\n         Float(is, ty) => Some(Float(neg_float_str(is), ty)),\n         _ => None,\n     }\n }\n \n-fn neg_sign(s: Sign) -> Sign {\n-    match s {\n-        Sign::Plus => Sign::Minus,\n-        Sign::Minus => Sign::Plus,\n-    }\n-}\n-\n fn neg_float_str(s: String) -> String {\n     if s.starts_with('-') {\n         s[1..].to_owned()\n@@ -255,32 +224,6 @@ fn neg_float_str(s: String) -> String {\n     }\n }\n \n-fn unify_int_type(l: LitIntType, r: LitIntType) -> Option<LitIntType> {\n-    use syntax::ast::LitIntType::*;\n-    match (l, r) {\n-        (Signed(lty), Signed(rty)) => {\n-            if lty == rty {\n-                Some(LitIntType::Signed(lty))\n-            } else {\n-                None\n-            }\n-        }\n-        (Unsigned(lty), Unsigned(rty)) => {\n-            if lty == rty {\n-                Some(LitIntType::Unsigned(lty))\n-            } else {\n-                None\n-            }\n-        }\n-        (Unsuffixed, Unsuffixed) => Some(Unsuffixed),\n-        (Signed(lty), Unsuffixed) => Some(Signed(lty)),\n-        (Unsigned(lty), Unsuffixed) => Some(Unsigned(lty)),\n-        (Unsuffixed, Signed(rty)) => Some(Signed(rty)),\n-        (Unsuffixed, Unsigned(rty)) => Some(Unsigned(rty)),\n-        _ => None,\n-    }\n-}\n-\n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         lcx: Some(lcx),\n@@ -381,101 +324,36 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n-        match op.node {\n-            BiAdd => {\n-                self.binop_apply(left, right, |l, r| {\n-                    match (l, r) {\n-                        (Constant::Byte(l8), Constant::Byte(r8)) => l8.checked_add(r8).map(Constant::Byte),\n-                        (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n-                            add_ints(l64, r64, lty, rty, lsign, rsign)\n-                        }\n-                        // TODO: float (would need bignum library?)\n-                        _ => None,\n-                    }\n-                })\n-            }\n-            BiSub => {\n-                self.binop_apply(left, right, |l, r| {\n-                    match (l, r) {\n-                        (Constant::Byte(l8), Constant::Byte(r8)) => {\n-                            if r8 > l8 {\n-                                None\n-                            } else {\n-                                Some(Constant::Byte(l8 - r8))\n-                            }\n-                        }\n-                        (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n-                            add_ints(l64, r64, lty, rty, lsign, neg_sign(rsign))\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-            }\n-            BiMul => self.divmul(left, right, u64::checked_mul),\n-            BiDiv => self.divmul(left, right, u64::checked_div),\n-            // BiRem,\n-            BiAnd => self.short_circuit(left, right, false),\n-            BiOr => self.short_circuit(left, right, true),\n-            BiBitXor => self.bitop(left, right, |x, y| x ^ y),\n-            BiBitAnd => self.bitop(left, right, |x, y| x & y),\n-            BiBitOr => self.bitop(left, right, |x, y| (x | y)),\n-            BiShl => self.bitop(left, right, |x, y| x << y),\n-            BiShr => self.bitop(left, right, |x, y| x >> y),\n-            BiEq => self.binop_apply(left, right, |l, r| Some(Constant::Bool(l == r))),\n-            BiNe => self.binop_apply(left, right, |l, r| Some(Constant::Bool(l != r))),\n-            BiLt => self.cmp(left, right, Less, true),\n-            BiLe => self.cmp(left, right, Greater, false),\n-            BiGe => self.cmp(left, right, Less, false),\n-            BiGt => self.cmp(left, right, Greater, true),\n+        let l = if let Some(l) = self.expr(left) { l } else { return None; };\n+        let r = self.expr(right);\n+        match (op.node, l, r) {\n+            (BiAdd, Constant::Int(l), Some(Constant::Int(r))) => (l + r).ok().map(Constant::Int),\n+            (BiSub, Constant::Int(l), Some(Constant::Int(r))) => (l - r).ok().map(Constant::Int),\n+            (BiMul, Constant::Int(l), Some(Constant::Int(r))) => (l * r).ok().map(Constant::Int),\n+            (BiDiv, Constant::Int(l), Some(Constant::Int(r))) => (l / r).ok().map(Constant::Int),\n+            (BiRem, Constant::Int(l), Some(Constant::Int(r))) => (l % r).ok().map(Constant::Int),\n+            (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+            (BiAnd, Constant::Bool(true), Some(r)) => Some(r),\n+            (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+            (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n+            (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+            (BiBitXor, Constant::Int(l), Some(Constant::Int(r))) => (l ^ r).ok().map(Constant::Int),\n+            (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+            (BiBitAnd, Constant::Int(l), Some(Constant::Int(r))) => (l & r).ok().map(Constant::Int),\n+            (BiBitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+            (BiBitOr, Constant::Int(l), Some(Constant::Int(r))) => (l | r).ok().map(Constant::Int),\n+            (BiShl, Constant::Int(l), Some(Constant::Int(r))) => (l << r).ok().map(Constant::Int),\n+            (BiShr, Constant::Int(l), Some(Constant::Int(r))) => (l >> r).ok().map(Constant::Int),\n+            (BiEq, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l == r)),\n+            (BiNe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l != r)),\n+            (BiLt, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l < r)),\n+            (BiLe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l <= r)),\n+            (BiGe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l >= r)),\n+            (BiGt, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l > r)),\n             _ => None,\n         }\n     }\n \n-    fn divmul<F>(&mut self, left: &Expr, right: &Expr, f: F) -> Option<Constant>\n-        where F: Fn(u64, u64) -> Option<u64>\n-    {\n-        self.binop_apply(left, right, |l, r| {\n-            match (l, r) {\n-                (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n-                    f(l64, r64).and_then(|value| {\n-                        let sign = if lsign == rsign {\n-                            Sign::Plus\n-                        } else {\n-                            Sign::Minus\n-                        };\n-                        unify_int_type(lty, rty).map(|ty| Constant::Int(value, ty, sign))\n-                    })\n-                }\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    fn bitop<F>(&mut self, left: &Expr, right: &Expr, f: F) -> Option<Constant>\n-        where F: Fn(u64, u64) -> u64\n-    {\n-        self.binop_apply(left, right, |l, r| {\n-            match (l, r) {\n-                (Constant::Bool(l), Constant::Bool(r)) => Some(Constant::Bool(f(l as u64, r as u64) != 0)),\n-                (Constant::Byte(l8), Constant::Byte(r8)) => Some(Constant::Byte(f(l8 as u64, r8 as u64) as u8)),\n-                (Constant::Int(l, lty, lsign), Constant::Int(r, rty, rsign)) => {\n-                    if lsign == Sign::Plus && rsign == Sign::Plus {\n-                        unify_int_type(lty, rty).map(|ty| Constant::Int(f(l, r), ty, Sign::Plus))\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    fn cmp(&mut self, left: &Expr, right: &Expr, ordering: Ordering, b: bool) -> Option<Constant> {\n-        self.binop_apply(left,\n-                         right,\n-                         |l, r| l.partial_cmp(&r).map(|o| Constant::Bool(b == (o == ordering))))\n-    }\n-\n     fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n         where F: Fn(Constant, Constant) -> Option<Constant>\n     {\n@@ -485,51 +363,4 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             None\n         }\n     }\n-\n-    fn short_circuit(&mut self, left: &Expr, right: &Expr, b: bool) -> Option<Constant> {\n-        self.expr(left).and_then(|left| {\n-            if let Constant::Bool(lbool) = left {\n-                if lbool == b {\n-                    Some(left)\n-                } else {\n-                    self.expr(right).and_then(|right| {\n-                        if let Constant::Bool(_) = right {\n-                            Some(right)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-}\n-\n-fn add_ints(l64: u64, r64: u64, lty: LitIntType, rty: LitIntType, lsign: Sign, rsign: Sign) -> Option<Constant> {\n-    let ty = if let Some(ty) = unify_int_type(lty, rty) {\n-        ty\n-    } else {\n-        return None;\n-    };\n-\n-    match (lsign, rsign) {\n-        (Sign::Plus, Sign::Plus) => l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Plus)),\n-        (Sign::Plus, Sign::Minus) => {\n-            if r64 > l64 {\n-                Some(Constant::Int(r64 - l64, ty, Sign::Minus))\n-            } else {\n-                Some(Constant::Int(l64 - r64, ty, Sign::Plus))\n-            }\n-        }\n-        (Sign::Minus, Sign::Minus) => l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Minus)),\n-        (Sign::Minus, Sign::Plus) => {\n-            if l64 > r64 {\n-                Some(Constant::Int(l64 - r64, ty, Sign::Minus))\n-            } else {\n-                Some(Constant::Int(r64 - l64, ty, Sign::Plus))\n-            }\n-        }\n-    }\n }"}, {"sha": "9ade801abb37a74ece1171021c75cfcb73c3701b", "filename": "src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/075040b03488b35ae1ed01cbb38fb716f85d4f93/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075040b03488b35ae1ed01cbb38fb716f85d4f93/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=075040b03488b35ae1ed01cbb38fb716f85d4f93", "patch": "@@ -1,8 +1,9 @@\n-use consts::{constant_simple, Constant, Sign};\n+use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n use utils::{span_lint, snippet, in_macro};\n+use rustc_const_eval::ConstInt;\n \n /// **What it does:** This lint checks for identity operations, e.g. `x + 0`.\n ///\n@@ -54,11 +55,11 @@ impl LateLintPass for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v, _, sign)) = constant_simple(e) {\n+    if let Some(v @ Constant::Int(_)) = constant_simple(e) {\n         if match m {\n-            0 => v == 0,\n-            -1 => sign == Sign::Minus && v == 1,\n-            1 => sign == Sign::Plus && v == 1,\n+            0 => v == Constant::Int(ConstInt::Infer(0)),\n+            -1 => v == Constant::Int(ConstInt::InferSigned(-1)),\n+            1 => v == Constant::Int(ConstInt::Infer(1)),\n             _ => unreachable!(),\n         } {\n             span_lint(cx,"}, {"sha": "3a774f674734d60cb4f97699a7f42f5928a8bc6f", "filename": "tests/consts.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/075040b03488b35ae1ed01cbb38fb716f85d4f93/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075040b03488b35ae1ed01cbb38fb716f85d4f93/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=075040b03488b35ae1ed01cbb38fb716f85d4f93", "patch": "@@ -5,8 +5,10 @@ extern crate clippy;\n extern crate syntax;\n extern crate rustc;\n extern crate rustc_front;\n+extern crate rustc_const_eval;\n \n use rustc_front::hir::*;\n+use rustc_const_eval::ConstInt;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n@@ -15,7 +17,7 @@ use syntax::ast::LitKind;\n use syntax::ast::LitIntType;\n use syntax::ast::StrStyle;\n \n-use clippy::consts::{constant_simple, Constant, FloatWidth, Sign};\n+use clippy::consts::{constant_simple, Constant, FloatWidth};\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -44,9 +46,9 @@ fn check(expect: Constant, expr: &Expr) {\n \n const TRUE : Constant = Constant::Bool(true);\n const FALSE : Constant = Constant::Bool(false);\n-const ZERO : Constant = Constant::Int(0, LitIntType::Unsuffixed, Sign::Plus);\n-const ONE : Constant = Constant::Int(1, LitIntType::Unsuffixed, Sign::Plus);\n-const TWO : Constant = Constant::Int(2, LitIntType::Unsuffixed, Sign::Plus);\n+const ZERO : Constant = Constant::Int(ConstInt::Infer(0));\n+const ONE : Constant = Constant::Int(ConstInt::Infer(1));\n+const TWO : Constant = Constant::Int(ConstInt::Infer(2));\n \n #[test]\n fn test_lit() {\n@@ -84,4 +86,8 @@ fn test_ops() {\n     assert_eq!(half_any, half32);\n     assert_eq!(half_any, half64);\n     assert_eq!(half32, half64); // for transitivity\n+\n+    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::U8(0)));\n+    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::I8(0)));\n+    assert_eq!(Constant::Int(ConstInt::InferSigned(-1)), Constant::Int(ConstInt::I8(-1)));\n }"}]}