{"sha": "ca2a25d966de0007dea8676833da1c764c9d5e00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMmEyNWQ5NjZkZTAwMDdkZWE4Njc2ODMzZGExYzc2NGM5ZDVlMDA=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2020-08-04T10:06:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-04T10:06:38Z"}, "message": "Rollup merge of #5837 - JarredAllen:needless_collect, r=phansch\n\nneedless_collect: catch x: Vec<_> = iter.collect(); x.into_iter() ...\n\nchangelog: Expand the needless_collect lint as suggested in #5627 (WIP).\n\nThis PR is WIP because I can't figure out how to make the multi-part suggestion include its changes in the source code (the fixed is identical to the source, despite the lint making suggestions). Aside from that one issue, I think this should be good.", "tree": {"sha": "1bd39a72f1de262739acaea0b5ae76f4fa842f42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bd39a72f1de262739acaea0b5ae76f4fa842f42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca2a25d966de0007dea8676833da1c764c9d5e00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfKTMuCRBK7hj4Ov3rIwAAdHIIAHHQ2xhUWrxTu2SjTs0/5IXB\nJVyIdOBqKjAPNljvn/uYPe+qhqV1afBB0eLV+o9YyLdwewm6xaDvOe4O7Li/lZmQ\npnQyttNNS8a7/CxgxmcGvdawXbdeK6sMmV/tCpRGROQBvu1UmJsHgd9KjVEcjBU4\nPn/ZBe9DWiP8IY6gTne1gPrXIp9t2lZdanKoSgk2jb/VTyQE3A/QjuPBoK/MULLt\neMJSuFd8/tj76H+ZdqW2xAbhnOknSIPDBYZttleYEWHwvy7nnWE3cQIvrbF/qWvC\nQVblorE26KNy2/g0Qn31eQPHax9KU4BqBzJPXtQejCR1k4St3m9WYQNYAr2tyQo=\n=DjOv\n-----END PGP SIGNATURE-----\n", "payload": "tree 1bd39a72f1de262739acaea0b5ae76f4fa842f42\nparent 1968aede0f3deab97347bcc936ecee5e3c3471c7\nparent 5e10b039a3f215b48a54ce7dd38f95115f92e55a\nauthor Philipp Krones <hello@philkrones.com> 1596535598 +0200\ncommitter GitHub <noreply@github.com> 1596535598 +0200\n\nRollup merge of #5837 - JarredAllen:needless_collect, r=phansch\n\nneedless_collect: catch x: Vec<_> = iter.collect(); x.into_iter() ...\n\nchangelog: Expand the needless_collect lint as suggested in #5627 (WIP).\n\nThis PR is WIP because I can't figure out how to make the multi-part suggestion include its changes in the source code (the fixed is identical to the source, despite the lint making suggestions). Aside from that one issue, I think this should be good.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2a25d966de0007dea8676833da1c764c9d5e00", "html_url": "https://github.com/rust-lang/rust/commit/ca2a25d966de0007dea8676833da1c764c9d5e00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca2a25d966de0007dea8676833da1c764c9d5e00/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1968aede0f3deab97347bcc936ecee5e3c3471c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1968aede0f3deab97347bcc936ecee5e3c3471c7", "html_url": "https://github.com/rust-lang/rust/commit/1968aede0f3deab97347bcc936ecee5e3c3471c7"}, {"sha": "5e10b039a3f215b48a54ce7dd38f95115f92e55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e10b039a3f215b48a54ce7dd38f95115f92e55a", "html_url": "https://github.com/rust-lang/rust/commit/5e10b039a3f215b48a54ce7dd38f95115f92e55a"}], "stats": {"total": 241, "additions": 235, "deletions": 6}, "files": [{"sha": "e9ce804320fc9969adf9154dde15ae263fc670ad", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 161, "deletions": 6, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ca2a25d966de0007dea8676833da1c764c9d5e00/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2a25d966de0007dea8676833da1c764c9d5e00/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ca2a25d966de0007dea8676833da1c764c9d5e00", "patch": "@@ -1,14 +1,14 @@\n use crate::consts::constant;\n use crate::reexport::Name;\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, last_path_segment, match_trait_method, match_type, match_var,\n-    multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n+    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt, snippet_with_applicability, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -17,7 +17,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n-    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    Local, LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -27,7 +27,7 @@ use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n@@ -2358,6 +2358,10 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n@@ -2425,6 +2429,157 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     }\n }\n \n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => format!(\".any(|x| x == {})\", snippet(cx, *span, \"..\")),\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"Use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"Take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"Check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"Check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Detect the occurences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses)\n+    }\n+}\n+\n fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {\n     let mut current_expr = expr;\n     while let ExprKind::MethodCall(ref path, ref span, ref args, _) = current_expr.kind {"}, {"sha": "4cf03e820352356b84f873cac15c7fd094a8020b", "filename": "tests/ui/needless_collect_indirect.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ca2a25d966de0007dea8676833da1c764c9d5e00/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2a25d966de0007dea8676833da1c764c9d5e00/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=ca2a25d966de0007dea8676833da1c764c9d5e00", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::{HashMap, VecDeque};\n+\n+fn main() {\n+    let sample = [1; 5];\n+    let indirect_iter = sample.iter().collect::<Vec<_>>();\n+    indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+    let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+    indirect_len.len();\n+    let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+    indirect_empty.is_empty();\n+    let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+    indirect_contains.contains(&&5);\n+    let indirect_negative = sample.iter().collect::<Vec<_>>();\n+    indirect_negative.len();\n+    indirect_negative\n+        .into_iter()\n+        .map(|x| (*x, *x + 1))\n+        .collect::<HashMap<_, _>>();\n+}"}, {"sha": "0c1e61d749661c5fb4a00652e75f6165407d08a8", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ca2a25d966de0007dea8676833da1c764c9d5e00/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca2a25d966de0007dea8676833da1c764c9d5e00/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=ca2a25d966de0007dea8676833da1c764c9d5e00", "patch": "@@ -0,0 +1,55 @@\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:5:5\n+   |\n+LL | /     let indirect_iter = sample.iter().collect::<Vec<_>>();\n+LL | |     indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   | |____^\n+   |\n+   = note: `-D clippy::needless-collect` implied by `-D warnings`\n+help: Use the original Iterator instead of collecting it and then producing a new one\n+   |\n+LL |     \n+LL |     sample.iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:7:5\n+   |\n+LL | /     let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_len.len();\n+   | |____^\n+   |\n+help: Take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |     \n+LL |     sample.iter().count();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:9:5\n+   |\n+LL | /     let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_empty.is_empty();\n+   | |____^\n+   |\n+help: Check if the original Iterator has anything instead of collecting it and seeing if it's empty\n+   |\n+LL |     \n+LL |     sample.iter().next().is_none();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:11:5\n+   |\n+LL | /     let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_contains.contains(&&5);\n+   | |____^\n+   |\n+help: Check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL |     \n+LL |     sample.iter().any(|x| x == &&5);\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}]}