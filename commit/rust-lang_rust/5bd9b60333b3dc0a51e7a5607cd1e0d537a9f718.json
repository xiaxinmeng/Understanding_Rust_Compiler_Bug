{"sha": "5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZDliNjAzMzNiM2RjMGE1MWU3YTU2MDdjZDFlMGQ1MzdhOWY3MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T00:23:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T00:23:29Z"}, "message": "Auto merge of #79553 - sexxi-goose:mir_min_cap_writeback, r=nikomatsakis\n\nCapture precise paths in THIR and MIR\n\nThis PR allows THIR and MIR to use the result of the new capture analysis to actually capture precise paths\n\nTo achieve we:\n- Writeback min capture results to TypeckResults\n- Move handling upvars to PlaceBuilder in mir_build\n- Lower precise paths in THIR build by reading min_captures\n- Search for ancestors in min_capture when trying to build a MIR place which starts off of an upvar\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/10\n\nPartly implements: rust-lang/project-rfc-2229#18\n\nWork that remains (not in this PR):\n- [ ] [Known bugs when feature gate is enabled](https://github.com/rust-lang/project-rfc-2229/projects/1?card_filter_query=label%3Abug)\n- [ ] Use min_capure_map for\n  - [ ] Liveness analysis\n  - [ ] rustc_mir/interpret/validity.rs\n  - [ ] regionck\n- [ ] rust-lang/project-rfc-2229#8\n- [ ] remove closure_captures and upvar_capture_map\n\nr? `@ghost`", "tree": {"sha": "c71a54390ab3616674b9825a03b61a3cd9d2a109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c71a54390ab3616674b9825a03b61a3cd9d2a109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "html_url": "https://github.com/rust-lang/rust/commit/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eb3a7ceafd1e2c1924177caa18c7cc0c25b413e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb3a7ceafd1e2c1924177caa18c7cc0c25b413e", "html_url": "https://github.com/rust-lang/rust/commit/9eb3a7ceafd1e2c1924177caa18c7cc0c25b413e"}, {"sha": "01df56343bf1884d5e1d82e813e2930c6d9d5dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/01df56343bf1884d5e1d82e813e2930c6d9d5dd6", "html_url": "https://github.com/rust-lang/rust/commit/01df56343bf1884d5e1d82e813e2930c6d9d5dd6"}], "stats": {"total": 1716, "additions": 1483, "deletions": 233}, "files": [{"sha": "143b3867d9fc754ace4cd74ae2fee40b75a6bc1a", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -4,7 +4,18 @@ use crate::ty::Ty;\n use rustc_hir::HirId;\n use rustc_target::abi::VariantIdx;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum PlaceBase {\n     /// A temporary variable\n     Rvalue,\n@@ -16,7 +27,18 @@ pub enum PlaceBase {\n     Upvar(ty::UpvarId),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub enum ProjectionKind {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref,\n@@ -36,7 +58,18 @@ pub enum ProjectionKind {\n     Subslice,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct Projection<'tcx> {\n     /// Type after the projection is being applied.\n     pub ty: Ty<'tcx>,\n@@ -48,7 +81,7 @@ pub struct Projection<'tcx> {\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n     pub base_ty: Ty<'tcx>,\n@@ -61,7 +94,7 @@ pub struct Place<'tcx> {\n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,"}, {"sha": "a8d007c0be27da05ca8e9f2fe1e22f3828a67f2d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -624,6 +624,19 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n     }\n \n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: DefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }"}, {"sha": "a6d95f74dd53f54aa29192c9c23e19342a3a41ce", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -672,15 +672,26 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n@@ -692,7 +703,7 @@ impl UpvarId {\n     }\n }\n \n-#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -746,7 +757,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -763,7 +774,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -790,7 +801,7 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n /// A `Place` and the corresponding `CaptureInfo`.\n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n     pub place: HirPlace<'tcx>,\n     pub info: CaptureInfo<'tcx>,\n@@ -799,7 +810,7 @@ pub struct CapturedPlace<'tcx> {\n /// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///"}, {"sha": "a90807de99d3e34b462c96ae9c3c108cceba9da5", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -2174,6 +2174,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Get the `i`-th element of a tuple.\n+    /// Panics when called on anything but a tuple.\n+    pub fn tuple_element_ty(&self, i: usize) -> Option<Ty<'tcx>> {\n+        match self.kind() {\n+            Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n+            _ => bug!(\"tuple_fields called on non-tuple\"),\n+        }\n+    }\n+\n     /// If the type contains variants, returns the valid range of variant indices.\n     //\n     // FIXME: This requires the optimized MIR in the case of generators."}, {"sha": "80eabdd9af83001642b269b551533aee1d387034", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::{HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n     PlaceRef,\n@@ -75,6 +76,7 @@ crate use region_infer::RegionInferenceContext;\n crate struct Upvar {\n     name: Symbol,\n \n+    // FIXME(project-rfc-2229#8): This should use Place or something similar\n     var_hir_id: HirId,\n \n     /// If true, the capture is behind a reference.\n@@ -155,13 +157,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n-        .closure_captures\n-        .get(&def.did.to_def_id())\n-        .into_iter()\n-        .flat_map(|v| v.values())\n-        .map(|upvar_id| {\n-            let var_hir_id = upvar_id.var_path.hir_id;\n-            let capture = tables.upvar_capture(*upvar_id);\n+        .closure_min_captures_flattened(def.did.to_def_id())\n+        .map(|captured_place| {\n+            let var_hir_id = match captured_place.place.base {\n+                HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                _ => bug!(\"Expected upvar\"),\n+            };\n+            let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,"}, {"sha": "543b7e7ebaa799f4ee4b9f7e453ccfd4f0128a5f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -749,7 +749,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     (&adt_def.variants[VariantIdx::new(0)], substs)\n                 }\n                 ty::Closure(_, substs) => {\n-                    return match substs.as_closure().upvar_tys().nth(field.index()) {\n+                    return match substs\n+                        .as_closure()\n+                        .tupled_upvars_ty()\n+                        .tuple_element_ty(field.index())\n+                    {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.as_closure().upvar_tys().count(),"}, {"sha": "e1a3dc87c8c8dc696a21971c946295fa7da0b631", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 319, "deletions": 80, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -4,29 +4,303 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_middle::middle::region;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n+/// The \"outermost\" place that holds this value.\n+#[derive(Copy, Clone)]\n+crate enum PlaceBase {\n+    /// Denotes the start of a `Place`.\n+    Local(Local),\n+\n+    /// When building place for an expression within a closure, the place might start off a\n+    /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n+    /// index (within the desugared closure) of the captured path until most of the projections\n+    /// are applied. We use `PlaceBase::Upvar` to keep track of the root variable off of which the\n+    /// captured path starts, the closure the capture belongs to and the trait the closure\n+    /// implements.\n+    ///\n+    /// Once we have figured out the capture index, we can convert the place builder to start from\n+    /// `PlaceBase::Local`.\n+    ///\n+    /// Consider the following example\n+    /// ```rust\n+    /// let t = (10, (10, (10, 10)));\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\", t.0.0.0);\n+    /// };\n+    /// ```\n+    /// Here the THIR expression for `t.0.0.0` will be something like\n+    ///\n+    /// ```\n+    /// * Field(0)\n+    ///     * Field(0)\n+    ///         * Field(0)\n+    ///             * UpvarRef(t)\n+    /// ```\n+    ///\n+    /// When `capture_disjoint_fields` is enabled, `t.0.0.0` is captured and we won't be able to\n+    /// figure out that it is captured until all the `Field` projections are applied.\n+    Upvar {\n+        /// HirId of the upvar\n+        var_hir_id: HirId,\n+        /// DefId of the closure\n+        closure_def_id: DefId,\n+        /// The trait closure implements, `Fn`, `FnMut`, `FnOnce`\n+        closure_kind: ty::ClosureKind },\n+}\n+\n /// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n /// place by pushing more and more projections onto the end, and then convert the final set into a\n /// place using the `into_place` method.\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n-struct PlaceBuilder<'tcx> {\n-    local: Local,\n+crate struct PlaceBuilder<'tcx> {\n+    base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n+/// Given a list of MIR projections, convert them to list of HIR ProjectionKind.\n+/// The projections are truncated to represent a path that might be captured by a\n+/// closure/generator. This implies the vector returned from this function doesn't contain\n+/// ProjectionElems `Downcast`, `ConstantIndex`, `Index`, or `Subslice` because those will never be\n+/// part of a path that is captued by a closure. We stop applying projections once we see the first\n+/// projection that isn't captured by a closure.\n+fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n+    mir_projections: &Vec<PlaceElem<'tcx>>,\n+) -> Vec<HirProjectionKind> {\n+\n+    let mut hir_projections  = Vec::new();\n+\n+    for mir_projection in mir_projections {\n+        let hir_projection = match mir_projection {\n+            ProjectionElem::Deref => HirProjectionKind::Deref,\n+            ProjectionElem::Field(field, _) => {\n+                // We will never encouter this for multivariant enums,\n+                // read the comment for `Downcast`.\n+                HirProjectionKind::Field(field.index() as u32, VariantIdx::new(0))\n+            },\n+            ProjectionElem::Downcast(..) => {\n+                // This projections exist only for enums that have\n+                // multiple variants. Since such enums that are captured\n+                // completely, we can stop here.\n+                break\n+            },\n+            ProjectionElem::Index(..)\n+            | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. } => {\n+                // We don't capture array-access projections.\n+                // We can stop here as arrays are captured completely.\n+                break\n+            },\n+        };\n+\n+        hir_projections.push(hir_projection);\n+    }\n+\n+    hir_projections\n+}\n+\n+/// Return true if the `proj_possible_ancestor` represents an ancestor path\n+/// to `proj_capture` or `proj_possible_ancestor` is same as `proj_capture`,\n+/// assuming they both start off of the same root variable.\n+///\n+/// **Note:** It's the caller's responsibility to ensure that both lists of projections\n+///           start off of the same root variable.\n+///\n+/// Eg: 1. `foo.x` which is represented using `projections=[Field(x)]` is an ancestor of\n+///        `foo.x.y` which is represented using `projections=[Field(x), Field(y)]`.\n+///        Note both `foo.x` and `foo.x.y` start off of the same root variable `foo`.\n+///     2. Since we only look at the projections here function will return `bar.x` as an a valid\n+///        ancestor of `foo.x.y`. It's the caller's responsibility to ensure that both projections\n+///        list are being applied to the same root variable.\n+fn is_ancestor_or_same_capture(\n+    proj_possible_ancestor: &Vec<HirProjectionKind>,\n+    proj_capture: &Vec<HirProjectionKind>,\n+) -> bool {\n+    // We want to make sure `is_ancestor_or_same_capture(\"x.0.0\", \"x.0\")` to return false.\n+    // Therefore we can't just check if all projections are same in the zipped iterator below.\n+    if proj_possible_ancestor.len() > proj_capture.len() {\n+        return false;\n+    }\n+\n+    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n+}\n+\n+/// Computes the index of a capture within the desugared closure provided the closure's\n+/// `closure_min_captures` and the capture's index of the capture in the\n+/// `ty::MinCaptureList` of the root variable `var_hir_id`.\n+fn compute_capture_idx<'tcx>(\n+    closure_min_captures: &ty::RootVariableMinCaptureList<'tcx>,\n+    var_hir_id: HirId,\n+    root_var_idx: usize,\n+) -> usize {\n+    let mut res = 0;\n+    for (var_id, capture_list) in closure_min_captures {\n+        if *var_id == var_hir_id {\n+            res += root_var_idx;\n+            break;\n+        } else {\n+            res += capture_list.len();\n+        }\n+    }\n+\n+    res\n+}\n+\n+/// Given a closure, returns the index of a capture within the desugared closure struct and the\n+/// `ty::CapturedPlace` which is the ancestor of the Place represented using the `var_hir_id`\n+/// and `projection`.\n+///\n+/// Note there will be at most one ancestor for any given Place.\n+///\n+/// Returns None, when the ancestor is not found.\n+fn find_capture_matching_projections<'a, 'tcx>(\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    var_hir_id: HirId,\n+    closure_def_id: DefId,\n+    projections: &Vec<PlaceElem<'tcx>>,\n+) -> Option<(usize, &'a ty::CapturedPlace<'tcx>)> {\n+    let closure_min_captures = typeck_results.closure_min_captures.get(&closure_def_id)?;\n+    let root_variable_min_captures = closure_min_captures.get(&var_hir_id)?;\n+\n+    let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n+\n+    // If an ancestor is found, `idx` is the index within the list of captured places\n+    // for root variable `var_hir_id` and `capture` is the `ty::CapturedPlace` itself.\n+    let (idx, capture) = root_variable_min_captures.iter().enumerate().find(|(_, capture)| {\n+            let possible_ancestor_proj_kinds =\n+                capture.place.projections.iter().map(|proj| proj.kind).collect();\n+            is_ancestor_or_same_capture(&possible_ancestor_proj_kinds, &hir_projections)\n+    })?;\n+\n+    // Convert index to be from the presepective of the entire closure_min_captures map\n+    // instead of just the root variable capture list\n+    Some((compute_capture_idx(closure_min_captures, var_hir_id, idx), capture))\n+}\n+\n+/// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n+/// `PlaceBuilder` now starts from `PlaceBase::Local`.\n+///\n+/// Returns a Result with the error being the HirId of the Upvar that was not found.\n+fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+    from_builder: PlaceBuilder<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> Result<PlaceBuilder<'tcx>, HirId> {\n+    match from_builder.base {\n+        PlaceBase::Local(_) => Ok(from_builder),\n+        PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n+            // Captures are represented using fields inside a structure.\n+            // This represents accessing self in the closure structure\n+            let mut upvar_resolved_place_builder = PlaceBuilder::from(Local::new(1));\n+            match closure_kind {\n+                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                    upvar_resolved_place_builder = upvar_resolved_place_builder.deref();\n+                }\n+                ty::ClosureKind::FnOnce => {}\n+            }\n+\n+            let (capture_index, capture) =\n+                if let Some(capture_details) = find_capture_matching_projections(\n+                    typeck_results,\n+                    var_hir_id,\n+                    closure_def_id,\n+                    &from_builder.projection,\n+                ) {\n+                    capture_details\n+                } else {\n+                    if !tcx.features().capture_disjoint_fields {\n+                        bug!(\n+                            \"No associated capture found for {:?}[{:#?}] even though \\\n+                            capture_disjoint_fields isn't enabled\",\n+                            var_hir_id,\n+                            from_builder.projection\n+                        )\n+                    } else {\n+                        // FIXME(project-rfc-2229#24): Handle this case properly\n+                        debug!(\n+                            \"No associated capture found for {:?}[{:#?}]\",\n+                            var_hir_id,\n+                            from_builder.projection,\n+                        );\n+                    }\n+                    return Err(var_hir_id);\n+                };\n+\n+            let closure_ty =\n+                typeck_results.node_type(tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local()));\n+\n+            let substs = match closure_ty.kind() {\n+                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+                _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty),\n+            };\n+\n+            // Access the capture by accessing the field within the Closure struct.\n+            //\n+            // We must have inferred the capture types since we are building MIR, therefore\n+            // it's safe to call `tuple_element_ty` and we can unwrap here because\n+            // we know that the capture exists and is the `capture_index`-th capture.\n+            let var_ty = substs.tupled_upvars_ty().tuple_element_ty(capture_index).unwrap();\n+\n+            upvar_resolved_place_builder = upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);\n+\n+            // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n+            // we need to deref it\n+            upvar_resolved_place_builder = match capture.info.capture_kind {\n+                ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n+                ty::UpvarCapture::ByValue(_) => upvar_resolved_place_builder,\n+            };\n+\n+            let next_projection = capture.place.projections.len();\n+            let mut curr_projections = from_builder.projection;\n+\n+            // We used some of the projections to build the capture itself,\n+            // now we apply the remaining to the upvar resolved place.\n+            upvar_resolved_place_builder.projection.extend(\n+                curr_projections.drain(next_projection..));\n+\n+            Ok(upvar_resolved_place_builder)\n+        }\n+    }\n+}\n+\n impl<'tcx> PlaceBuilder<'tcx> {\n-    fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n+    crate fn into_place<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> Place<'tcx> {\n+        if let PlaceBase::Local(local) = self.base {\n+            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+        } else {\n+            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+        }\n+    }\n+\n+    fn expect_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n+    }\n+\n+    crate fn base(&self) -> PlaceBase {\n+        self.base\n     }\n \n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n@@ -49,7 +323,13 @@ impl<'tcx> PlaceBuilder<'tcx> {\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { local, projection: Vec::new() }\n+        Self { base: PlaceBase::Local(local), projection: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase) -> Self {\n+        Self { base, projection: Vec::new() }\n     }\n }\n \n@@ -71,12 +351,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n+    crate fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -98,7 +378,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -161,27 +441,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 source_info,\n             ),\n             ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n-                let capture = this\n-                    .hir\n-                    .typeck_results\n-                    .closure_captures\n-                    .get(&closure_def_id)\n-                    .and_then(|captures| captures.get_full(&var_hir_id));\n-\n-                if capture.is_none() {\n-                    if !this.hir.tcx().features().capture_disjoint_fields {\n-                        bug!(\n-                            \"No associated capture found for {:?} even though \\\n-                            capture_disjoint_fields isn't enabled\",\n-                            expr.kind\n-                        )\n-                    }\n-                    // FIXME(project-rfc-2229#24): Handle this case properly\n-                }\n-\n-                // Unwrap until the FIXME has been resolved\n-                let (capture_index, _, upvar_id) = capture.unwrap();\n-                this.lower_closure_capture(block, capture_index, *upvar_id)\n+                let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n+                this.lower_captured_upvar(block, upvar_id)\n             }\n \n             ExprKind::VarRef { id } => {\n@@ -208,7 +469,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.hir.tcx());\n+                    let place =\n+                        place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -293,59 +555,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Lower a closure/generator capture by representing it as a field\n-    /// access within the desugared closure/generator.\n-    ///\n-    /// `capture_index` is the index of the capture within the desugared\n-    /// closure/generator.\n-    fn lower_closure_capture(\n+    /// Lower a captured upvar. Note we might not know the actual capture index,\n+    /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n+    /// once all projections that allow us to indentify a capture have been applied.\n+    fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n-        capture_index: usize,\n         upvar_id: ty::UpvarId,\n-    )  -> BlockAnd<PlaceBuilder<'tcx>> {\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty = self\n             .hir\n             .typeck_results()\n             .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n-        // Captures are represented using fields inside a structure.\n-        // This represents accessing self in the closure structure\n-        let mut place_builder = PlaceBuilder::from(Local::new(1));\n-\n-        // In case of Fn/FnMut closures we must deref to access the fields\n-        // Generators are considered FnOnce, so we ignore this step for them.\n-        if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            match self.hir.infcx().closure_kind(closure_substs).unwrap() {\n-                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                    place_builder = place_builder.deref();\n-                }\n-                ty::ClosureKind::FnOnce => {}\n-            }\n-        }\n-\n-        let substs = match closure_ty.kind() {\n-            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-            _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty)\n+        let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n+            self.hir.infcx().closure_kind(closure_substs).unwrap()\n+        } else {\n+            // Generators are considered FnOnce.\n+            ty::ClosureKind::FnOnce\n         };\n \n-        // Access the capture by accessing the field within the Closure struct.\n-        //\n-        // We must have inferred the capture types since we are building MIR, therefore\n-        // it's safe to call `upvar_tys` and we can unwrap here because\n-        // we know that the capture exists and is the `capture_index`-th capture.\n-        let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n-        place_builder = place_builder.field(Field::new(capture_index), var_ty);\n-\n-        // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n-        // we need to deref it\n-        match self.hir.typeck_results.upvar_capture(upvar_id) {\n-            ty::UpvarCapture::ByRef(_) => {\n-                block.and(place_builder.deref())\n-            }\n-            ty::UpvarCapture::ByValue(_) => block.and(place_builder),\n-        }\n+        block.and(PlaceBuilder::from(PlaceBase::Upvar {\n+            var_hir_id: upvar_id.var_path.hir_id,\n+            closure_def_id: upvar_id.closure_expr_id.to_def_id(),\n+            closure_kind,\n+        }))\n     }\n \n     /// Lower an index expression\n@@ -373,7 +607,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n-        let base_place =\n+        let mut base_place =\n             unpack!(block = self.expr_as_place(block, lhs, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n@@ -383,7 +617,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         block = self.bounds_check(\n             block,\n-            base_place.clone().into_place(self.hir.tcx()),\n+            base_place.clone().into_place(self.hir.tcx(), self.hir.typeck_results()),\n             idx,\n             expr_span,\n             source_info,\n@@ -392,6 +626,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n+            base_place = base_place.expect_upvars_resolved(self.hir.tcx(), self.hir.typeck_results());\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -441,8 +676,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.hir.tcx();\n-        let place_ty =\n-            Place::ty_from(base_place.local, &base_place.projection, &self.local_decls, tcx);\n+        let local = match base_place.base {\n+            PlaceBase::Local(local) => local,\n+            PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\")\n+        };\n+\n+        let place_ty = Place::ty_from(local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -452,7 +691,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -470,14 +709,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { local: base_place.local, projection },\n+                                Place { local, projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "3f381f3f15e8e0907c5e379e2bdf32c1a4fce077", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -4,6 +4,7 @@ use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n+use crate::build::expr::as_place::PlaceBase;\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n@@ -393,51 +394,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         this.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });\n \n-        let arg_place = unpack!(block = this.as_place(block, arg));\n-\n-        let mutability = match arg_place.as_ref() {\n-            PlaceRef { local, projection: &[] } => this.local_decls[local].mutability,\n-            PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n-                debug_assert!(\n-                    this.local_decls[local].is_ref_for_guard(),\n-                    \"Unexpected capture place\",\n-                );\n-                this.local_decls[local].mutability\n-            }\n-            PlaceRef {\n-                local,\n-                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n-            }\n-            | PlaceRef {\n-                local,\n-                projection:\n-                    &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n-            } => {\n-                let place = PlaceRef { local, projection: proj_base };\n-\n-                // Not projected from the implicit `self` in a closure.\n-                debug_assert!(\n-                    match place.local_or_deref_local() {\n-                        Some(local) => local == Local::new(1),\n-                        None => false,\n-                    },\n-                    \"Unexpected capture place\"\n-                );\n-                // Not in a closure\n-                debug_assert!(\n-                    this.upvar_mutbls.len() > upvar_index.index(),\n-                    \"Unexpected capture place\"\n-                );\n-                this.upvar_mutbls[upvar_index.index()]\n+        let arg_place_builder = unpack!(block = this.as_place_builder(block, arg));\n+\n+        let mutability = match arg_place_builder.base() {\n+            // We are capturing a path that starts off a local variable in the parent.\n+            // The mutability of the current capture is same as the mutability\n+            // of the local declaration in the parent.\n+            PlaceBase::Local(local) =>  this.local_decls[local].mutability,\n+            // Parent is a closure and we are capturing a path that is captured\n+            // by the parent itself. The mutability of the current capture\n+            // is same as that of the capture in the parent closure.\n+            PlaceBase::Upvar { .. } => {\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n+                match enclosing_upvars_resolved.as_ref() {\n+                    PlaceRef { local, projection: &[ProjectionElem::Field(upvar_index, _), ..] }\n+                    | PlaceRef {\n+                        local,\n+                        projection: &[ProjectionElem::Deref, ProjectionElem::Field(upvar_index, _), ..] } => {\n+                            // Not in a closure\n+                            debug_assert!(\n+                                local == Local::new(1),\n+                                \"Expected local to be Local(1), found {:?}\",\n+                                local\n+                            );\n+                            // Not in a closure\n+                            debug_assert!(\n+                                this.upvar_mutbls.len() > upvar_index.index(),\n+                                \"Unexpected capture place, upvar_mutbls={:#?}, upvar_index={:?}\",\n+                                this.upvar_mutbls, upvar_index\n+                            );\n+                            this.upvar_mutbls[upvar_index.index()]\n+                        }\n+                    _ => bug!(\"Unexpected capture place\"),\n+                }\n             }\n-            _ => bug!(\"Unexpected capture place\"),\n         };\n \n         let borrow_kind = match mutability {\n             Mutability::Not => BorrowKind::Unique,\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n+        let arg_place = arg_place_builder.into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n         this.cfg.push_assign(\n             block,\n             source_info,"}, {"sha": "d7fce15d99669f8172b2a754d5b8ff3fee622907", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n@@ -823,7 +824,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`.\n-        if let Some(upvars) = hir_typeck_results.closure_captures.get(&fn_def_id) {\n+        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;\n@@ -836,14 +837,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n                 _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n             };\n-            let upvar_tys = upvar_substs.upvar_tys();\n-            let upvars_with_tys = upvars.iter().zip(upvar_tys);\n-            self.upvar_mutbls = upvars_with_tys\n+            let capture_tys = upvar_substs.upvar_tys();\n+            let captures_with_tys = hir_typeck_results\n+                .closure_min_captures_flattened(fn_def_id)\n+                .zip(capture_tys);\n+\n+            self.upvar_mutbls = captures_with_tys\n                 .enumerate()\n-                .map(|(i, ((&var_id, &upvar_id), ty))| {\n-                    let capture = hir_typeck_results.upvar_capture(upvar_id);\n+                .map(|(i, (captured_place, ty))| {\n+                    let capture = captured_place.info.capture_kind;\n+                    let var_id = match captured_place.place.base {\n+                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                        _ => bug!(\"Expected an upvar\")\n+                    };\n \n                     let mut mutability = Mutability::Not;\n+\n+                    // FIXME(project-rfc-2229#8): Store more precise information\n                     let mut name = kw::Invalid;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {"}, {"sha": "fbdadc67b43ba82cab7ea7b4de38dcf77adcd994", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -6,6 +6,8 @@ use crate::thir::*;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::ty::adjustment::{\n@@ -386,14 +388,12 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n+\n             let upvars = cx\n                 .typeck_results()\n-                .closure_captures\n-                .get(&def_id)\n-                .iter()\n-                .flat_map(|upvars| upvars.iter())\n+                .closure_min_captures_flattened(def_id)\n                 .zip(substs.upvar_tys())\n-                .map(|((&var_hir_id, _), ty)| capture_upvar(cx, expr, var_hir_id, ty))\n+                .map(|(captured_place, ty)| capture_upvar(cx, expr, captured_place, ty))\n                 .collect();\n             ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n         }\n@@ -981,27 +981,55 @@ fn overloaded_place<'a, 'tcx>(\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_upvar<'tcx>(\n+fn capture_upvar<'a, 'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n     closure_expr: &'tcx hir::Expr<'tcx>,\n-    var_hir_id: hir::HirId,\n+    captured_place: &'a ty::CapturedPlace<'tcx>,\n     upvar_ty: Ty<'tcx>,\n ) -> ExprRef<'tcx> {\n-    let upvar_id = ty::UpvarId {\n-        var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n-    };\n-    let upvar_capture = cx.typeck_results().upvar_capture(upvar_id);\n+    let upvar_capture = captured_place.info.capture_kind;\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = cx.typeck_results().node_type(var_hir_id);\n-    let captured_var = Expr {\n+    let var_ty = captured_place.place.base_ty;\n+\n+    // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+    // as it's seen for use within the closure and not at the time of closure creation.\n+    //\n+    // That is we see expect to see it start from a captured upvar and not something that is local\n+    // to the closure's parent.\n+    let var_hir_id = match captured_place.place.base {\n+        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+        base => bug!(\"Expected an upvar, found {:?}\", base),\n+    };\n+\n+    let mut captured_place_expr = Expr {\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n         kind: convert_var(cx, var_hir_id),\n     };\n+\n+    for proj in captured_place.place.projections.iter() {\n+        let kind = match proj.kind {\n+            HirProjectionKind::Deref => ExprKind::Deref { arg: captured_place_expr.to_ref() },\n+            HirProjectionKind::Field(field, ..) => {\n+                // Variant index will always be 0, because for multi-variant\n+                // enums, we capture the enum entirely.\n+                ExprKind::Field {\n+                    lhs: captured_place_expr.to_ref(),\n+                    name: Field::new(field as usize),\n+                }\n+            }\n+            HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                // We don't capture these projections, so we can ignore them here\n+                continue;\n+            }\n+        };\n+\n+        captured_place_expr = Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+    }\n+\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),\n+        ty::UpvarCapture::ByValue(_) => captured_place_expr.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n@@ -1012,7 +1040,7 @@ fn capture_upvar<'tcx>(\n                 temp_lifetime,\n                 ty: upvar_ty,\n                 span: closure_expr.span,\n-                kind: ExprKind::Borrow { borrow_kind, arg: captured_var.to_ref() },\n+                kind: ExprKind::Borrow { borrow_kind, arg: captured_place_expr.to_ref() },\n             }\n             .to_ref()\n         }"}, {"sha": "30b4682296c6af22488372550139cebb05061f5e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Equate the type variables for the upvars with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(closure_hir_id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_def_id);\n         debug!(\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n             closure_hir_id, substs, final_upvar_tys\n@@ -222,36 +222,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Returns a list of `Ty`s for each upvar.\n-    fn final_upvar_tys(&self, closure_id: hir::HirId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n         self.typeck_results\n             .borrow()\n-            .closure_captures\n-            .get(&closure_def_id.to_def_id())\n-            .iter()\n-            .flat_map(|upvars| {\n-                upvars.iter().map(|(&var_hir_id, _)| {\n-                    let upvar_ty = self.node_ty(var_hir_id);\n-                    let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n-                    let capture = self.typeck_results.borrow().upvar_capture(upvar_id);\n-\n-                    debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n-\n-                    match capture {\n-                        ty::UpvarCapture::ByValue(_) => upvar_ty,\n-                        ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n-                            borrow.region,\n-                            ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n-                        ),\n-                    }\n-                })\n+            .closure_min_captures_flattened(closure_id)\n+            .map(|captured_place| {\n+                let upvar_ty = captured_place.place.ty();\n+                let capture = captured_place.info.capture_kind;\n+\n+                debug!(\n+                    \"place={:?} upvar_ty={:?} capture={:?}\",\n+                    captured_place.place, upvar_ty, capture\n+                );\n+\n+                match capture {\n+                    ty::UpvarCapture::ByValue(_) => upvar_ty,\n+                    ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n+                        borrow.region,\n+                        ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n+                    ),\n+                }\n             })\n             .collect()\n     }"}, {"sha": "7c9cfe69fc94b4874df12003de13e2224cbe655c", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -55,6 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }\n         wbcx.visit_body(body);\n+        wbcx.visit_min_capture_map();\n         wbcx.visit_upvar_capture_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -331,6 +332,37 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n+    fn visit_min_capture_map(&mut self) {\n+        let mut min_captures_wb = ty::MinCaptureInformationMap::with_capacity_and_hasher(\n+            self.fcx.typeck_results.borrow().closure_min_captures.len(),\n+            Default::default(),\n+        );\n+        for (closure_def_id, root_min_captures) in\n+            self.fcx.typeck_results.borrow().closure_min_captures.iter()\n+        {\n+            let mut root_var_map_wb = ty::RootVariableMinCaptureList::with_capacity_and_hasher(\n+                root_min_captures.len(),\n+                Default::default(),\n+            );\n+            for (var_hir_id, min_list) in root_min_captures.iter() {\n+                let min_list_wb = min_list\n+                    .iter()\n+                    .map(|captured_place| {\n+                        let locatable = captured_place.info.expr_id.unwrap_or(\n+                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n+                        );\n+\n+                        self.resolve(captured_place.clone(), &locatable)\n+                    })\n+                    .collect();\n+                root_var_map_wb.insert(*var_hir_id, min_list_wb);\n+            }\n+            min_captures_wb.insert(*closure_def_id, root_var_map_wb);\n+        }\n+\n+        self.typeck_results.closure_min_captures = min_captures_wb;\n+    }\n+\n     fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {"}, {"sha": "ce9fd5575cf957ff71ad7df3230c628fdcf18c86", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 52, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -15,7 +15,6 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n-use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n@@ -571,38 +570,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    /// Walk closure captures but using `closure_caputes` instead\n-    /// of `closure_min_captures`.\n-    ///\n-    /// This is needed because clippy uses `ExprUseVisitor` after TypeckResults\n-    /// are written back. We don't currently writeback min_captures to\n-    /// TypeckResults.\n-    fn walk_captures_closure_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n-        // FIXME(arora-aman): Remove this function once rust-lang/project-rfc-2229#18\n-        // is completed.\n-        debug!(\"walk_captures_closure_captures({:?}), \", closure_expr);\n-\n-        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n-        let cl_span = self.tcx().hir().span(closure_expr.hir_id);\n-\n-        let captures = &self.mc.typeck_results.closure_captures[&closure_def_id];\n-\n-        for (&var_id, &upvar_id) in captures {\n-            let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n-            let captured_place =\n-                return_if_err!(self.cat_captured_var(closure_expr.hir_id, cl_span, var_id));\n-            match upvar_capture {\n-                ty::UpvarCapture::ByValue(_) => {\n-                    let mode = copy_or_move(&self.mc, &captured_place);\n-                    self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n-                }\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    self.delegate.borrow(&captured_place, captured_place.hir_id, upvar_borrow.kind);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Handle the case where the current body contains a closure.\n     ///\n     /// When the current body being handled is a closure, then we must make sure that\n@@ -646,16 +613,18 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     let place = &captured_place.place;\n                     let capture_info = captured_place.info;\n \n-                    let upvar_id = if body_owner_is_closure {\n+                    let place_base = if body_owner_is_closure {\n                         // Mark the place to be captured by the enclosing closure\n-                        ty::UpvarId::new(*var_hir_id, self.body_owner)\n+                        PlaceBase::Upvar(ty::UpvarId::new(*var_hir_id, self.body_owner))\n                     } else {\n-                        ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local())\n+                        // If the body owner isn't a closure then the variable must\n+                        // be a local variable\n+                        PlaceBase::Local(*var_hir_id)\n                     };\n                     let place_with_id = PlaceWithHirId::new(\n                         capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n                         place.base_ty,\n-                        PlaceBase::Upvar(upvar_id),\n+                        place_base,\n                         place.projections.clone(),\n                     );\n \n@@ -674,23 +643,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-        } else if self.mc.typeck_results.closure_captures.contains_key(&closure_def_id) {\n-            // Handle the case where clippy calls ExprUseVisitor after\n-            self.walk_captures_closure_captures(closure_expr)\n         }\n     }\n-\n-    fn cat_captured_var(\n-        &mut self,\n-        closure_hir_id: hir::HirId,\n-        closure_span: Span,\n-        var_id: hir::HirId,\n-    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n-        // Create the place for the variable being borrowed, from the\n-        // perspective of the creator (parent) of the closure.\n-        let var_ty = self.mc.node_ty(var_id)?;\n-        self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))\n-    }\n }\n \n fn copy_or_move<'a, 'tcx>("}, {"sha": "0b94317fd7136e36badef7c0ef073cd78eed2143", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/arrays.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,86 @@\n+// Test that arrays are completely captured by closures by relying on the borrow check diagnostics\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn arrays_1() {\n+    let mut arr = [1, 2, 3, 4, 5];\n+\n+    let mut c = || {\n+        arr[0] += 10;\n+    };\n+\n+    // c will capture `arr` completely, therefore another index into the\n+    // array can't be modified here\n+    arr[1] += 10;\n+    //~^ ERROR: cannot use `arr` because it was mutably borrowed\n+    //~| ERROR: cannot use `arr[_]` because it was mutably borrowed\n+    c();\n+}\n+\n+fn arrays_2() {\n+    let mut arr = [1, 2, 3, 4, 5];\n+\n+    let c = || {\n+        println!(\"{:#?}\", &arr[3..4]);\n+    };\n+\n+    // c will capture `arr` completely, therefore another index into the\n+    // array can't be modified here\n+    arr[1] += 10;\n+    //~^ ERROR: cannot assign to `arr[_]` because it is borrowed\n+    c();\n+}\n+\n+fn arrays_3() {\n+    let mut arr = [1, 2, 3, 4, 5];\n+\n+    let c = || {\n+        println!(\"{}\", arr[3]);\n+    };\n+\n+    // c will capture `arr` completely, therefore another index into the\n+    // array can't be modified here\n+    arr[1] += 10;\n+    //~^ ERROR: cannot assign to `arr[_]` because it is borrowed\n+    c();\n+}\n+\n+fn arrays_4() {\n+    let mut arr = [1, 2, 3, 4, 5];\n+\n+    let mut c = || {\n+        arr[1] += 10;\n+    };\n+\n+    // c will capture `arr` completely, therefore we cannot borrow another index\n+    // into the array.\n+    println!(\"{}\", arr[3]);\n+    //~^ ERROR: cannot use `arr` because it was mutably borrowed\n+    //~| ERROR: cannot borrow `arr[_]` as immutable because it is also borrowed as mutable\n+\n+    c();\n+}\n+\n+fn arrays_5() {\n+    let mut arr = [1, 2, 3, 4, 5];\n+\n+    let mut c = || {\n+        arr[1] += 10;\n+    };\n+\n+    // c will capture `arr` completely, therefore we cannot borrow other indecies\n+    // into the array.\n+    println!(\"{:#?}\", &arr[3..2]);\n+    //~^ ERROR: cannot borrow `arr` as immutable because it is also borrowed as mutable\n+\n+    c();\n+}\n+\n+fn main() {\n+    arrays_1();\n+    arrays_2();\n+    arrays_3();\n+    arrays_4();\n+    arrays_5();\n+}"}, {"sha": "77e3e71bc6120c2bc3bc0c1d2c467540d530bcd5", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/arrays.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Farrays.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,111 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/arrays.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0503]: cannot use `arr` because it was mutably borrowed\n+  --> $DIR/arrays.rs:15:5\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `arr` occurs here\n+LL |         arr[0] += 10;\n+   |         --- borrow occurs due to use of `arr` in closure\n+...\n+LL |     arr[1] += 10;\n+   |     ^^^^^^ use of borrowed `arr`\n+...\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0503]: cannot use `arr[_]` because it was mutably borrowed\n+  --> $DIR/arrays.rs:15:5\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `arr` occurs here\n+LL |         arr[0] += 10;\n+   |         --- borrow occurs due to use of `arr` in closure\n+...\n+LL |     arr[1] += 10;\n+   |     ^^^^^^^^^^^^ use of borrowed `arr`\n+...\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0506]: cannot assign to `arr[_]` because it is borrowed\n+  --> $DIR/arrays.rs:30:5\n+   |\n+LL |     let c = || {\n+   |             -- borrow of `arr[_]` occurs here\n+LL |         println!(\"{:#?}\", &arr[3..4]);\n+   |                            --- borrow occurs due to use in closure\n+...\n+LL |     arr[1] += 10;\n+   |     ^^^^^^^^^^^^ assignment to borrowed `arr[_]` occurs here\n+LL |\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0506]: cannot assign to `arr[_]` because it is borrowed\n+  --> $DIR/arrays.rs:44:5\n+   |\n+LL |     let c = || {\n+   |             -- borrow of `arr[_]` occurs here\n+LL |         println!(\"{}\", arr[3]);\n+   |                        --- borrow occurs due to use in closure\n+...\n+LL |     arr[1] += 10;\n+   |     ^^^^^^^^^^^^ assignment to borrowed `arr[_]` occurs here\n+LL |\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0503]: cannot use `arr` because it was mutably borrowed\n+  --> $DIR/arrays.rs:58:20\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `arr` occurs here\n+LL |         arr[1] += 10;\n+   |         --- borrow occurs due to use of `arr` in closure\n+...\n+LL |     println!(\"{}\", arr[3]);\n+   |                    ^^^^^^ use of borrowed `arr`\n+...\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0502]: cannot borrow `arr[_]` as immutable because it is also borrowed as mutable\n+  --> $DIR/arrays.rs:58:20\n+   |\n+LL |     let mut c = || {\n+   |                 -- mutable borrow occurs here\n+LL |         arr[1] += 10;\n+   |         --- first borrow occurs due to use of `arr` in closure\n+...\n+LL |     println!(\"{}\", arr[3]);\n+   |                    ^^^^^^ immutable borrow occurs here\n+...\n+LL |     c();\n+   |     - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `arr` as immutable because it is also borrowed as mutable\n+  --> $DIR/arrays.rs:74:24\n+   |\n+LL |     let mut c = || {\n+   |                 -- mutable borrow occurs here\n+LL |         arr[1] += 10;\n+   |         --- first borrow occurs due to use of `arr` in closure\n+...\n+LL |     println!(\"{:#?}\", &arr[3..2]);\n+   |                        ^^^ immutable borrow occurs here\n+...\n+LL |     c();\n+   |     - mutable borrow later used here\n+\n+error: aborting due to 7 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0502, E0503, E0506.\n+For more information about an error, try `rustc --explain E0502`."}, {"sha": "15be1d8c7220dadaded08bf126d1e014131f9526", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/box.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,65 @@\n+// Test borrow checker when we precise capture when using boxes\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+struct MetaData { x: String, name: String }\n+struct Data { m: MetaData }\n+struct BoxedData(Box<Data>);\n+struct EvenMoreBoxedData(Box<BoxedData>);\n+\n+// Check diagnostics when the same path is mutated both inside and outside the closure\n+fn box_1() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let mut c = || {\n+        e.0.0.m.x = format!(\"not-x\");\n+    };\n+\n+    e.0.0.m.x = format!(\"not-x\");\n+    //~^ ERROR: cannot assign to `e.0.0.m.x` because it is borrowed\n+    c();\n+}\n+\n+// Check diagnostics when a path is mutated inside a closure while attempting to read it outside\n+// the closure.\n+fn box_2() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let mut c = || {\n+        e.0.0.m.x = format!(\"not-x\");\n+    };\n+\n+    println!(\"{}\", e.0.0.m.x);\n+    //~^ ERROR: cannot borrow `e.0.0.m.x` as immutable because it is also borrowed as mutable\n+    c();\n+}\n+\n+// Check diagnostics when a path is read inside a closure while attempting to mutate it outside\n+// the closure.\n+fn box_3() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let c = || {\n+        println!(\"{}\", e.0.0.m.x);\n+    };\n+\n+    e.0.0.m.x = format!(\"not-x\");\n+    //~^ ERROR: cannot assign to `e.0.0.m.x` because it is borrowed\n+    c();\n+}\n+\n+fn main() {\n+    box_1();\n+    box_2();\n+    box_3();\n+}"}, {"sha": "17a9332fb3e6c6b53c572477884c531c564a7de9", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/box.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fbox.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,55 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/box.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0506]: cannot assign to `e.0.0.m.x` because it is borrowed\n+  --> $DIR/box.rs:22:5\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `e.0.0.m.x` occurs here\n+LL |         e.0.0.m.x = format!(\"not-x\");\n+   |         - borrow occurs due to use in closure\n+...\n+LL |     e.0.0.m.x = format!(\"not-x\");\n+   |     ^^^^^^^^^ assignment to borrowed `e.0.0.m.x` occurs here\n+LL |\n+LL |     c();\n+   |     - borrow later used here\n+\n+error[E0502]: cannot borrow `e.0.0.m.x` as immutable because it is also borrowed as mutable\n+  --> $DIR/box.rs:39:20\n+   |\n+LL |     let mut c = || {\n+   |                 -- mutable borrow occurs here\n+LL |         e.0.0.m.x = format!(\"not-x\");\n+   |         - first borrow occurs due to use of `e.0.0.m.x` in closure\n+...\n+LL |     println!(\"{}\", e.0.0.m.x);\n+   |                    ^^^^^^^^^ immutable borrow occurs here\n+LL |\n+LL |     c();\n+   |     - mutable borrow later used here\n+\n+error[E0506]: cannot assign to `e.0.0.m.x` because it is borrowed\n+  --> $DIR/box.rs:56:5\n+   |\n+LL |     let c = || {\n+   |             -- borrow of `e.0.0.m.x` occurs here\n+LL |         println!(\"{}\", e.0.0.m.x);\n+   |                        - borrow occurs due to use in closure\n+...\n+LL |     e.0.0.m.x = format!(\"not-x\");\n+   |     ^^^^^^^^^ assignment to borrowed `e.0.0.m.x` occurs here\n+LL |\n+LL |     c();\n+   |     - borrow later used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0502, E0506.\n+For more information about an error, try `rustc --explain E0502`."}, {"sha": "39b04c833e384d3c9baf43541181f3dfd5ebe435", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/multilevel-path.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,28 @@\n+// Test that when a borrow checker diagnostics are emitted, it's as precise\n+// as the capture by the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![allow(unused)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    let mut c = || {\n+        w.p.x += 20;\n+    };\n+\n+    let py = &mut w.p.x;\n+    //~^ ERROR: cannot borrow `w.p.x` as mutable more than once at a time\n+    c();\n+\n+    *py = 20\n+}"}, {"sha": "e5a396c4e98aed0233ba36c49c0eeebecba22e37", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/multilevel-path.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmultilevel-path.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0499]: cannot borrow `w.p.x` as mutable more than once at a time\n+  --> $DIR/multilevel-path.rs:23:14\n+   |\n+LL |     let mut c = || {\n+   |                 -- first mutable borrow occurs here\n+LL |         w.p.x += 20;\n+   |         - first borrow occurs due to use of `w.p.x` in closure\n+...\n+LL |     let py = &mut w.p.x;\n+   |              ^^^^^^^^^^ second mutable borrow occurs here\n+LL |\n+LL |     c();\n+   |     - first borrow later used here\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "e78d8715e4893def8d891f92fdb9de09721c5343", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/simple-struct-min-capture.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,26 @@\n+// Test that borrow checker error is accurate and that min capture pass of the\n+// closure analysis is working as expected.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 10, y: 20 };\n+\n+    // `p` is captured via mutable borrow.\n+    let mut c = || {\n+        p.x += 10;\n+        println!(\"{:?}\", p);\n+    };\n+\n+\n+    println!(\"{:?}\", p);\n+    //~^ ERROR: cannot borrow `p` as immutable because it is also borrowed as mutable\n+    c();\n+}"}, {"sha": "45a61cd98b101d30e6a0596231a55c9ac5ffd943", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/simple-struct-min-capture.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fsimple-struct-min-capture.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/simple-struct-min-capture.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0502]: cannot borrow `p` as immutable because it is also borrowed as mutable\n+  --> $DIR/simple-struct-min-capture.rs:23:22\n+   |\n+LL |     let mut c = || {\n+   |                 -- mutable borrow occurs here\n+LL |         p.x += 10;\n+   |         - first borrow occurs due to use of `p` in closure\n+...\n+LL |     println!(\"{:?}\", p);\n+   |                      ^ immutable borrow occurs here\n+LL |\n+LL |     c();\n+   |     - mutable borrow later used here\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "3a66399d02899bb606e2238f4bab28094ab0d41b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/box.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,97 @@\n+// run-pass\n+\n+// Test precise capture when using boxes\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+\n+struct MetaData { x: String, name: String }\n+struct Data { m: MetaData }\n+struct BoxedData(Box<Data>);\n+struct EvenMoreBoxedData(Box<BoxedData>);\n+\n+// Mutate disjoint paths, one inside one outside the closure\n+fn box_1() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let mut c = || {\n+        e.0.0.m.x = format!(\"not-x\");\n+    };\n+\n+    e.0.0.m.name = format!(\"not-name\");\n+    c();\n+}\n+\n+// Mutate a path inside the closure and read a disjoint path outside the closure\n+fn box_2() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let mut c = || {\n+        e.0.0.m.x = format!(\"not-x\");\n+    };\n+\n+    println!(\"{}\", e.0.0.m.name);\n+    c();\n+}\n+\n+// Read a path inside the closure and mutate a disjoint path outside the closure\n+fn box_3() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let mut e = EvenMoreBoxedData(Box::new(b));\n+\n+    let c = || {\n+        println!(\"{}\", e.0.0.m.name);\n+    };\n+\n+    e.0.0.m.x = format!(\"not-x\");\n+    c();\n+}\n+\n+// Read disjoint paths, one inside the closure and one outside the closure.\n+fn box_4() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let e = EvenMoreBoxedData(Box::new(b));\n+\n+    let c = || {\n+        println!(\"{}\", e.0.0.m.name);\n+    };\n+\n+    println!(\"{}\", e.0.0.m.x);\n+    c();\n+}\n+\n+// Read the same path, once inside the closure and once outside the closure.\n+fn box_5() {\n+    let m = MetaData { x: format!(\"x\"), name: format!(\"name\") };\n+    let d = Data { m };\n+    let b = BoxedData(Box::new(d));\n+    let e = EvenMoreBoxedData(Box::new(b));\n+\n+    let c = || {\n+        println!(\"{}\", e.0.0.m.name);\n+    };\n+\n+    println!(\"{}\", e.0.0.m.name);\n+    c();\n+}\n+\n+fn main() {\n+    box_1();\n+    box_2();\n+    box_3();\n+    box_4();\n+    box_5();\n+}"}, {"sha": "9883c01b946c97287cbfabefb56a39c77fd65967", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/box.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fbox.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/box.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2c359519b769b4a745dbd28fd8abbb658b8e5375", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-struct.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+\n+// Test that we can immutably borrow field of an instance of a structure from within a closure,\n+// while having a mutable borrow to another field of the same instance outside the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 10, y: 10 };\n+\n+    let c = || {\n+        println!(\"{}\", p.x);\n+    };\n+\n+    // `c` should only capture `p.x`, therefore mutating `p.y` is allowed.\n+    let py = &mut p.y;\n+\n+    c();\n+    *py = 20;\n+}"}, {"sha": "9b0dea770fba2cfec72ffcc59fdaab4ab16510c0", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-struct.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-struct.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-disjoint-field-struct.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2c6679feabe46a795656921bb2ccf3fb740e8ce2", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-tuple-mut.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+// Test that we can mutate an element of a tuple from within a closure\n+// while immutably borrowing another element of the same tuple outside the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut t = (10, 10);\n+\n+    let mut c = || {\n+        let t1 = &mut t.1;\n+        *t1 = 20;\n+    };\n+\n+    // Test that `c` only captures t.1, therefore reading t.0 is allowed.\n+    println!(\"{}\", t.0);\n+    c();\n+}"}, {"sha": "28d091539527961af23ba285cb5866fa80e55192", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-tuple-mut.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple-mut.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-disjoint-field-tuple-mut.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "52f5cef9f01c686d47ef5dfbb19947476544c465", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-tuple.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+// Test that we can immutably borrow an element of a tuple from within a closure,\n+// while having a mutable borrow to another element of the same tuple outside the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut t = (10, 10);\n+\n+    let c = || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    // `c` only captures t.0, therefore mutating t.1 is allowed.\n+    let t1 = &mut t.1;\n+\n+    c();\n+    *t1 = 20;\n+}"}, {"sha": "4fb37f85f88b57975f9b3de55cc9bfbe997c1408", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture-disjoint-field-tuple.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture-disjoint-field-tuple.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-disjoint-field-tuple.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "3f8e197b7837d407fdb7ed4209ec4749508088f8", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/disjoint-capture-in-same-closure.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Tests that if a closure uses indivual fields of the same object\n+// then that case is handled properly.\n+\n+#![allow(unused)]\n+\n+struct Struct {\n+    x: i32,\n+    y: i32,\n+    s: String,\n+}\n+\n+fn main() {\n+    let mut s = Struct { x: 10, y: 10, s: String::new() };\n+\n+    let mut c = {\n+        s.x += 10;\n+        s.y += 42;\n+        s.s = String::from(\"new\");\n+    };\n+}"}, {"sha": "bba90f8917accaeea05a860a4f857e01015d2e41", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/disjoint-capture-in-same-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdisjoint-capture-in-same-closure.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/disjoint-capture-in-same-closure.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "8c12593430ef0c38240f5fc96afa8c01da7b0171", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/filter-on-struct-member.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+// Test disjoint capture within an impl block\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+struct Filter {\n+    div: i32,\n+}\n+impl Filter {\n+    fn allowed(&self, x: i32) -> bool {\n+        x % self.div == 1\n+    }\n+}\n+\n+struct Data {\n+    filter: Filter,\n+    list: Vec<i32>,\n+}\n+impl Data {\n+    fn update(&mut self) {\n+        // The closure passed to filter only captures self.filter,\n+        // therefore mutating self.list is allowed.\n+        self.list.retain(\n+            |v| self.filter.allowed(*v),\n+        );\n+    }\n+}\n+\n+fn main() {\n+    let mut d = Data { filter: Filter { div: 3 }, list: Vec::new() };\n+\n+    for i in 1..10 {\n+        d.list.push(i);\n+    }\n+\n+    d.update();\n+}"}, {"sha": "6930e18992ae2fb424ad7be269d8888d75b9d3b2", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/filter-on-struct-member.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ffilter-on-struct-member.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/filter-on-struct-member.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "142c156bd56e723005c80a28ab76ef8e4e3936ab", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-1.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+\n+// Test that closures can catpure paths that are more precise than just one level\n+// from the root variable.\n+//\n+// If the closures can handle such precison we should be able to mutate one path in the closure\n+// while being able to mutate another path outside the closure, where the two paths are disjoint\n+// after applying two projections on the root variable.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![allow(unused)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    let mut c = || {\n+        w.p.x += 20;\n+    };\n+\n+    // `c` only captures `w.p.x`, therefore it's safe to mutate `w.p.y`.\n+    let py = &mut w.p.y;\n+    c();\n+\n+    *py = 20\n+}"}, {"sha": "94b877522f4ae2c56b7896ad878dd4129e5febeb", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-1.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-1.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path-1.rs:10:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d8f7d55d5aa7be204c82e07ae715b2c96866ab9f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,34 @@\n+// run-pass\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![allow(unused)]\n+\n+// If the closures can handle such precison we should be able to read one path in the closure\n+// while being able mutate another path outside the closure, where the two paths are disjoint\n+// after applying two projections on the root variable.\n+\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    let c = || {\n+        println!(\"{}\", w.p.x);\n+    };\n+\n+    // `c` only captures `w.p.x`, therefore it's safe to mutate `w.p.y`.\n+    let py = &mut w.p.y;\n+    c();\n+\n+    *py = 20\n+}"}, {"sha": "100a0e167c5810eb18ccef998b8511b50836dbbf", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-2.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path-2.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "fc3d48ec45810545141efda87cfa047764300b91", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-3.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,31 @@\n+// run-pass\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![allow(unused)]\n+\n+// Test that when `capture_disjoint_fields` is enabled we can read a path\n+// both inside and outside the closure at the same time.\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    let c = || {\n+        println!(\"{}\", w.p.x);\n+    };\n+\n+    let px = &w.p.x;\n+    c();\n+\n+    println!(\"{}\", px);\n+}"}, {"sha": "cf5be6a00e9a4c055878df5c7145419e754f8f87", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/multilevel-path-3.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmultilevel-path-3.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path-3.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "238580929ef110a0705c103048ea446a4ccfd644", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/nested-closure.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.rs?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,40 @@\n+// run-pass\n+\n+// Test whether if we can do precise capture when using nested clsoure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 5, y: 20 };\n+\n+    // c1 should capture `p.x` via immutable borrow and\n+    // `p.y` via mutable borrow.\n+    let mut c1 = || {\n+        println!(\"{}\", p.x);\n+\n+        let incr = 10;\n+\n+        let mut c2 = || p.y += incr;\n+        c2();\n+\n+        println!(\"{}\", p.y);\n+    };\n+\n+    c1();\n+\n+    // This should not throw an error because `p.x` is borrowed via Immutable borrow,\n+    // and multiple immutable borrow of the same place are allowed.\n+    let px = &p.x;\n+\n+    println!(\"{}\", px);\n+\n+    c1();\n+}"}, {"sha": "293aa82ce9feaf73b2e3b996db006a94488e1db0", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/nested-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fnested-closure.stderr?ref=5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/nested-closure.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}]}