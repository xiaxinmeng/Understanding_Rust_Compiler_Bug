{"sha": "d6ec686d379efca7296d6c53abe7968bdfae5723", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZWM2ODZkMzc5ZWZjYTcyOTZkNmM1M2FiZTc5NjhiZGZhZTU3MjM=", "commit": {"author": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2016-12-01T13:10:49Z"}, "committer": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2016-12-01T13:10:49Z"}, "message": "rustdoc: Sort lines in search index and implementors js\n\nThis means the files are generated deterministically even with rustdoc\nrunning in parallel.", "tree": {"sha": "d655cacd924b9b88306a016d1932836602500ada", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d655cacd924b9b88306a016d1932836602500ada"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ec686d379efca7296d6c53abe7968bdfae5723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ec686d379efca7296d6c53abe7968bdfae5723", "html_url": "https://github.com/rust-lang/rust/commit/d6ec686d379efca7296d6c53abe7968bdfae5723", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ec686d379efca7296d6c53abe7968bdfae5723/comments", "author": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3abaf43f770a8bae23da474690e3841041219029", "url": "https://api.github.com/repos/rust-lang/rust/commits/3abaf43f770a8bae23da474690e3841041219029", "html_url": "https://github.com/rust-lang/rust/commit/3abaf43f770a8bae23da474690e3841041219029"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "57fb0aa3f7a509016efbef0986faf73247284dd5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec686d379efca7296d6c53abe7968bdfae5723/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec686d379efca7296d6c53abe7968bdfae5723/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d6ec686d379efca7296d6c53abe7968bdfae5723", "patch": "@@ -40,7 +40,7 @@ use std::cmp::Ordering;\n use std::collections::BTreeMap;\n use std::default::Default;\n use std::error;\n-use std::fmt::{self, Display, Formatter};\n+use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n use std::fs::{self, File, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n@@ -718,18 +718,20 @@ fn write_shared(cx: &Context,\n \n     // Update the search index\n     let dst = cx.dst.join(\"search-index.js\");\n-    let all_indexes = try_err!(collect(&dst, &krate.name, \"searchIndex\"), &dst);\n+    let mut all_indexes = try_err!(collect(&dst, &krate.name, \"searchIndex\"), &dst);\n+    all_indexes.push(search_index);\n+    // Sort the indexes by crate so the file will be generated identically even\n+    // with rustdoc running in parallel.\n+    all_indexes.sort();\n     let mut w = try_err!(File::create(&dst), &dst);\n     try_err!(writeln!(&mut w, \"var searchIndex = {{}};\"), &dst);\n-    try_err!(writeln!(&mut w, \"{}\", search_index), &dst);\n     for index in &all_indexes {\n         try_err!(writeln!(&mut w, \"{}\", *index), &dst);\n     }\n     try_err!(writeln!(&mut w, \"initSearch(searchIndex);\"), &dst);\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    try_err!(mkdir(&dst), &dst);\n     for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n@@ -746,37 +748,37 @@ fn write_shared(cx: &Context,\n             }\n         };\n \n+        let mut implementors = format!(r#\"implementors[\"{}\"] = [\"#, krate.name);\n+        for imp in imps {\n+            // If the trait and implementation are in the same crate, then\n+            // there's no need to emit information about it (there's inlining\n+            // going on). If they're in different crates then the crate defining\n+            // the trait will be interested in our implementation.\n+            if imp.def_id.krate == did.krate { continue }\n+            write!(implementors, r#\"\"{}\",\"#, imp.impl_).unwrap();\n+        }\n+        implementors.push_str(\"];\");\n+\n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n-            try_err!(mkdir(&mydst), &mydst);\n         }\n+        try_err!(fs::create_dir_all(&mydst), &mydst);\n         mydst.push(&format!(\"{}.{}.js\",\n                             remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n-        let all_implementors = try_err!(collect(&mydst, &krate.name,\n-                                                \"implementors\"),\n-                                        &mydst);\n \n-        try_err!(mkdir(mydst.parent().unwrap()),\n-                 &mydst.parent().unwrap().to_path_buf());\n-        let mut f = BufWriter::new(try_err!(File::create(&mydst), &mydst));\n-        try_err!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"), &mydst);\n+        let mut all_implementors = try_err!(collect(&mydst, &krate.name, \"implementors\"), &mydst);\n+        all_implementors.push(implementors);\n+        // Sort the implementors by crate so the file will be generated\n+        // identically even with rustdoc running in parallel.\n+        all_implementors.sort();\n \n+        let mut f = try_err!(File::create(&mydst), &mydst);\n+        try_err!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"), &mydst);\n         for implementor in &all_implementors {\n-            try_err!(write!(&mut f, \"{}\", *implementor), &mydst);\n-        }\n-\n-        try_err!(write!(&mut f, r#\"implementors[\"{}\"] = [\"#, krate.name), &mydst);\n-        for imp in imps {\n-            // If the trait and implementation are in the same crate, then\n-            // there's no need to emit information about it (there's inlining\n-            // going on). If they're in different crates then the crate defining\n-            // the trait will be interested in our implementation.\n-            if imp.def_id.krate == did.krate { continue }\n-            try_err!(write!(&mut f, r#\"\"{}\",\"#, imp.impl_), &mydst);\n+            try_err!(writeln!(&mut f, \"{}\", *implementor), &mydst);\n         }\n-        try_err!(writeln!(&mut f, r\"];\"), &mydst);\n         try_err!(writeln!(&mut f, \"{}\", r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);"}]}