{"sha": "58ea029db2fd9da6eac85456191481b4cbdb9e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZWEwMjlkYjJmZDlkYTZlYWM4NTQ1NjE5MTQ4MWI0Y2JkYjllNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T18:51:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T18:51:34Z"}, "message": "auto merge of #12533 : alexcrichton/rust/svh, r=brson\n\nThese hashes are used to detect changes to upstream crates and generate errors which mention that crates possibly need recompilation.\r\n\r\nMore details can be found in the respective commit messages below. This change is also accompanied with a much needed refactoring of some of the crate loading code to focus more on crate ids instead of name/version pairs.\r\n\r\nCloses #12601", "tree": {"sha": "e6a509363a77afee8d59d236e478e7e43fd52c61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a509363a77afee8d59d236e478e7e43fd52c61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58ea029db2fd9da6eac85456191481b4cbdb9e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58ea029db2fd9da6eac85456191481b4cbdb9e58", "html_url": "https://github.com/rust-lang/rust/commit/58ea029db2fd9da6eac85456191481b4cbdb9e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58ea029db2fd9da6eac85456191481b4cbdb9e58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1be3d182e361697117bf79fadca7697f8b5aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1be3d182e361697117bf79fadca7697f8b5aec", "html_url": "https://github.com/rust-lang/rust/commit/9b1be3d182e361697117bf79fadca7697f8b5aec"}, {"sha": "017c5044895a3f708dee46d64dd3d67dac61145e", "url": "https://api.github.com/repos/rust-lang/rust/commits/017c5044895a3f708dee46d64dd3d67dac61145e", "html_url": "https://github.com/rust-lang/rust/commit/017c5044895a3f708dee46d64dd3d67dac61145e"}], "stats": {"total": 889, "additions": 522, "deletions": 367}, "files": [{"sha": "bc5961a99813165e54e97cdad6f63350f74ca900", "filename": "mk/clean.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -58,6 +58,7 @@ clean-generic-$(2)-$(1):\n          -name '*.[odasS]' -o \\\n          -name '*.so' -o      \\\n          -name '*.dylib' -o   \\\n+         -name '*.rlib' -o   \\\n          -name 'stamp.*' -o   \\\n          -name '*.lib' -o     \\\n          -name '*.dll' -o     \\"}, {"sha": "bacc98a01356aab59aa7de9e0214a800e6ad81cd", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n+use back::svh::Svh;\n use driver::driver::{CrateTranslation, OutputFilenames};\n use driver::session::Session;\n use driver::session;\n@@ -499,28 +499,31 @@ pub mod write {\n  *    system linkers understand.\n  */\n \n-pub fn build_link_meta(attrs: &[ast::Attribute],\n-                       output: &OutputFilenames,\n-                       symbol_hasher: &mut Sha256)\n-                       -> LinkMeta {\n-    // This calculates CMH as defined above\n-    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> ~str {\n-        symbol_hasher.reset();\n-        symbol_hasher.input_str(crateid.to_str());\n-        truncated_hash_result(symbol_hasher)\n-    }\n-\n-    let crateid = match attr::find_crateid(attrs) {\n+pub fn find_crate_id(attrs: &[ast::Attribute],\n+                     output: &OutputFilenames) -> CrateId {\n+    match attr::find_crateid(attrs) {\n         None => from_str(output.out_filestem).unwrap(),\n         Some(s) => s,\n-    };\n+    }\n+}\n \n-    let hash = crate_hash(symbol_hasher, &crateid);\n+pub fn crate_id_hash(crate_id: &CrateId) -> ~str {\n+    // This calculates CMH as defined above. Note that we don't use the path of\n+    // the crate id in the hash because lookups are only done by (name/vers),\n+    // not by path.\n+    let mut s = Sha256::new();\n+    s.input_str(crate_id.short_name_with_version());\n+    truncated_hash_result(&mut s).slice_to(8).to_owned()\n+}\n \n-    LinkMeta {\n-        crateid: crateid,\n-        crate_hash: hash,\n-    }\n+pub fn build_link_meta(krate: &ast::Crate,\n+                       output: &OutputFilenames) -> LinkMeta {\n+    let r = LinkMeta {\n+        crateid: find_crate_id(krate.attrs, output),\n+        crate_hash: Svh::calculate(krate),\n+    };\n+    info!(\"{}\", r);\n+    return r;\n }\n \n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n@@ -539,7 +542,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &mut Sha256,\n     symbol_hasher.reset();\n     symbol_hasher.input_str(link_meta.crateid.name);\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(link_meta.crate_hash);\n+    symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n@@ -712,11 +715,8 @@ pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> ~str\n     mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n }\n \n-pub fn output_lib_filename(lm: &LinkMeta) -> ~str {\n-    format!(\"{}-{}-{}\",\n-            lm.crateid.name,\n-            lm.crate_hash.slice_chars(0, 8),\n-            lm.crateid.version_or_default())\n+pub fn output_lib_filename(id: &CrateId) -> ~str {\n+    format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {\n@@ -779,11 +779,11 @@ fn remove(sess: Session, path: &Path) {\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   lm: &LinkMeta) -> ~[Path] {\n+                   id: &CrateId) -> ~[Path] {\n     let mut out_filenames = ~[];\n     let crate_types = sess.crate_types.borrow();\n     for &crate_type in crate_types.get().iter() {\n-        let out_file = link_binary_output(sess, trans, crate_type, outputs, lm);\n+        let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n         out_filenames.push(out_file);\n     }\n \n@@ -807,8 +807,8 @@ fn is_writeable(p: &Path) -> bool {\n }\n \n pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n-                          lm: &LinkMeta, out_filename: &Path) -> Path {\n-    let libname = output_lib_filename(lm);\n+                          id: &CrateId, out_filename: &Path) -> Path {\n+    let libname = output_lib_filename(id);\n     match crate_type {\n         session::CrateTypeRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n@@ -834,13 +834,13 @@ fn link_binary_output(sess: Session,\n                       trans: &CrateTranslation,\n                       crate_type: session::CrateType,\n                       outputs: &OutputFilenames,\n-                      lm: &LinkMeta) -> Path {\n+                      id: &CrateId) -> Path {\n     let obj_filename = outputs.temp_path(OutputTypeObject);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n         None => {\n             let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(&sess, crate_type, lm, &out_filename)\n+            filename_for_input(&sess, crate_type, id, &out_filename)\n         }\n     };\n "}, {"sha": "5f8a12b022a508ae887bedbff42d4f52eb19ad49", "filename": "src/librustc/back/svh.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation and management of a Strict Version Hash for crates\n+//!\n+//! # Today's ABI problem\n+//!\n+//! In today's implementation of rustc, it is incredibly difficult to achieve\n+//! forward binary compatibility without resorting to C-like interfaces. Within\n+//! rust code itself, abi details such as symbol names suffer from a variety of\n+//! unrelated factors to code changing such as the \"def id drift\" problem. This\n+//! ends up yielding confusing error messages about metadata mismatches and\n+//! such.\n+//!\n+//! The core of this problem is when when an upstream dependency changes and\n+//! downstream dependants are not recompiled. This causes compile errors because\n+//! the upstream crate's metadata has changed but the downstream crates are\n+//! still referencing the older crate's metadata.\n+//!\n+//! This problem exists for many reasons, the primary of which is that rust does\n+//! not currently support forwards ABI compatibility (in place upgrades of a\n+//! crate).\n+//!\n+//! # SVH and how it alleviates the problem\n+//!\n+//! With all of this knowledge on hand, this module contains the implementation\n+//! of a notion of a \"Strict Version Hash\" for a crate. This is essentially a\n+//! hash of all contents of a crate which can somehow be exposed to downstream\n+//! crates.\n+//!\n+//! This hash is currently calculated by just hashing the AST, but this is\n+//! obviously wrong (doc changes should not result in an incompatible ABI).\n+//! Implementation-wise, this is required at this moment in time.\n+//!\n+//! By encoding this strict version hash into all crate's metadata, stale crates\n+//! can be detected immediately and error'd about by rustc itself.\n+//!\n+//! # Relevant links\n+//!\n+//! Original issue: https://github.com/mozilla/rust/issues/10207\n+\n+use std::fmt;\n+use std::hash::Hash;\n+use std::hash::sip::SipState;\n+use std::iter::range_step;\n+use syntax::ast;\n+\n+#[deriving(Clone, Eq)]\n+pub struct Svh {\n+    priv hash: ~str,\n+}\n+\n+impl Svh {\n+    pub fn new(hash: &str) -> Svh {\n+        assert!(hash.len() == 16);\n+        Svh { hash: hash.to_owned() }\n+    }\n+\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        self.hash.as_slice()\n+    }\n+\n+    pub fn calculate(krate: &ast::Crate) -> Svh {\n+        // FIXME: see above for why this is wrong, it shouldn't just hash the\n+        //        crate.  Fixing this would require more in-depth analysis in\n+        //        this function about what portions of the crate are reachable\n+        //        in tandem with bug fixes throughout the rest of the compiler.\n+        //\n+        //        Note that for now we actually exclude some top-level things\n+        //        from the crate like the CrateConfig/span. The CrateConfig\n+        //        contains command-line `--cfg` flags, so this means that the\n+        //        stage1/stage2 AST for libstd and such is different hash-wise\n+        //        when it's actually the exact same representation-wise.\n+        //\n+        //        As a first stab at only hashing the relevant parts of the\n+        //        AST, this only hashes the module/attrs, not the CrateConfig\n+        //        field.\n+        //\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipState::new();\n+        krate.module.hash(&mut state);\n+        krate.attrs.hash(&mut state);\n+\n+        let hash = state.result();\n+        return Svh {\n+            hash: range_step(0, 64, 4).map(|i| hex(hash >> i)).collect()\n+        };\n+\n+        fn hex(b: u64) -> char {\n+            let b = (b & 0xf) as u8;\n+            let b = match b {\n+                0 .. 9 => '0' as u8 + b,\n+                _ => 'a' as u8 + b - 10,\n+            };\n+            b as char\n+        }\n+    }\n+}\n+\n+impl fmt::Show for Svh {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(self.as_str())\n+    }\n+}"}, {"sha": "d5ee736b6fb7f0284401440593d476399bb76c66", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -433,7 +433,7 @@ pub fn phase_6_link_output(sess: Session,\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           &trans.link));\n+                           &trans.link.crateid));\n }\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n@@ -472,8 +472,7 @@ fn write_out_deps(sess: Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n-    let lm = link::build_link_meta(krate.attrs, outputs,\n-                                   &mut ::util::sha2::Sha256::new());\n+    let id = link::find_crate_id(krate.attrs, outputs);\n \n     let mut out_filenames = ~[];\n     for output_type in sess.opts.output_types.iter() {\n@@ -482,7 +481,7 @@ fn write_out_deps(sess: Session,\n             link::OutputTypeExe => {\n                 let crate_types = sess.crate_types.borrow();\n                 for output in crate_types.get().iter() {\n-                    let p = link::filename_for_input(&sess, *output, &lm, &file);\n+                    let p = link::filename_for_input(&sess, *output, &id, &file);\n                     out_filenames.push(p);\n                 }\n             }"}, {"sha": "2e647e5ca82950265e407a90b16aeec061d83722", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -55,7 +55,6 @@ use std::str;\n use std::task;\n use std::vec;\n use syntax::ast;\n-use syntax::attr;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n use syntax::parse;\n@@ -104,16 +103,17 @@ pub mod front {\n }\n \n pub mod back {\n-    pub mod archive;\n-    pub mod link;\n     pub mod abi;\n+    pub mod archive;\n     pub mod arm;\n+    pub mod link;\n+    pub mod lto;\n     pub mod mips;\n-    pub mod x86;\n-    pub mod x86_64;\n     pub mod rpath;\n+    pub mod svh;\n     pub mod target_strs;\n-    pub mod lto;\n+    pub mod x86;\n+    pub mod x86_64;\n }\n \n pub mod metadata;\n@@ -312,28 +312,18 @@ pub fn run_compiler(args: &[~str]) {\n         let attrs = parse_crate_attrs(sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n                                                   attrs, sess);\n-        if crate_id || crate_name {\n-            let crateid = match attr::find_crateid(attrs) {\n-                Some(crateid) => crateid,\n-                None => {\n-                    sess.fatal(\"No crate_id and --crate-id or \\\n-                                --crate-name requested\")\n-                }\n-            };\n-            if crate_id {\n-                println!(\"{}\", crateid.to_str());\n-            }\n-            if crate_name {\n-                println!(\"{}\", crateid.name);\n-            }\n-        }\n+        let id = link::find_crate_id(attrs, &t_outputs);\n \n+        if crate_id {\n+            println!(\"{}\", id.to_str());\n+        }\n+        if crate_name {\n+            println!(\"{}\", id.name);\n+        }\n         if crate_file_name {\n-            let lm = link::build_link_meta(attrs, &t_outputs,\n-                                           &mut ::util::sha2::Sha256::new());\n             let crate_types = session::collect_crate_types(&sess, attrs);\n             for &style in crate_types.iter() {\n-                let fname = link::filename_for_input(&sess, style, &lm,\n+                let fname = link::filename_for_input(&sess, style, &id,\n                                                      &t_outputs.with_extension(\"\"));\n                 println!(\"{}\", fname.filename_display());\n             }"}, {"sha": "7b7d526411c932d709136eedc4d430b60d3bd28d", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -12,6 +12,7 @@\n \n use std::cast;\n use syntax::crateid::CrateId;\n+use back::svh::Svh;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -70,12 +71,12 @@ pub static tag_crate_deps: uint = 0x18;\n pub static tag_crate_dep: uint = 0x19;\n \n pub static tag_crate_hash: uint = 0x1a;\n+pub static tag_crate_crateid: uint = 0x1b;\n \n-pub static tag_parent_item: uint = 0x1b;\n+pub static tag_parent_item: uint = 0x1c;\n \n-pub static tag_crate_dep_name: uint = 0x1c;\n-pub static tag_crate_dep_hash: uint = 0x1d;\n-pub static tag_crate_dep_vers: uint = 0x1e;\n+pub static tag_crate_dep_crateid: uint = 0x1d;\n+pub static tag_crate_dep_hash: uint = 0x1e;\n \n pub static tag_mod_impl: uint = 0x1f;\n \n@@ -207,8 +208,8 @@ pub static tag_macro_registrar_fn: uint = 0x63;\n pub static tag_exported_macros: uint = 0x64;\n pub static tag_macro_def: uint = 0x65;\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct LinkMeta {\n     crateid: CrateId,\n-    crate_hash: ~str,\n+    crate_hash: Svh,\n }"}, {"sha": "165c1abdeedfa96376de205fb94b9ca42bf8b827", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 102, "deletions": 136, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -12,6 +12,8 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n+use back::link;\n+use back::svh::Svh;\n use driver::{driver, session};\n use driver::session::Session;\n use metadata::csearch;\n@@ -78,8 +80,8 @@ impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n-    hash: ~str,\n-    crateid: CrateId,\n+    hash: Svh,\n+    crate_id: CrateId,\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n@@ -95,10 +97,10 @@ fn warn_if_multiple_versions(e: &mut Env,\n                              diag: @SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n-        let name = crate_cache[crate_cache.len() - 1].crateid.name.clone();\n+        let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();\n \n         let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == entry.crateid.name);\n+            name == entry.crate_id.name);\n \n         assert!(!matches.is_empty());\n \n@@ -107,7 +109,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n                 format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n-                loader::note_crateid_attr(diag, &match_.crateid);\n+                loader::note_crateid_attr(diag, &match_.crate_id);\n             }\n         }\n \n@@ -146,14 +148,9 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n         return;\n     }\n \n-    match extract_crate_info(i) {\n+    match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e,\n-                                     None,\n-                                     info.ident.clone(),\n-                                     info.name.clone(),\n-                                     info.version.clone(),\n-                                     ~\"\",\n+            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, None,\n                                      i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -163,38 +160,33 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n struct CrateInfo {\n     ident: ~str,\n-    name: ~str,\n-    version: ~str,\n+    crate_id: CrateId,\n     id: ast::NodeId,\n }\n \n-fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n+fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n         ast::ViewItemExternMod(ident, ref path_opt, id) => {\n             let ident = token::get_ident(ident);\n             debug!(\"resolving extern crate stmt. ident: {:?} path_opt: {:?}\",\n                    ident, path_opt);\n-            let (name, version) = match *path_opt {\n+            let crate_id = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let crateid: Option<CrateId> = from_str(path_str.get());\n                     match crateid {\n-                        None => (~\"\", ~\"\"),\n-                        Some(crateid) => {\n-                            let version = match crateid.version {\n-                                None => ~\"\",\n-                                Some(ref ver) => ver.to_str(),\n-                            };\n-                            (crateid.name.to_str(), version)\n+                        None => {\n+                            e.sess.span_err(i.span, \"malformed crate id\");\n+                            return None\n                         }\n+                        Some(id) => id\n                     }\n                 }\n-                None => (ident.get().to_str(), ~\"\"),\n+                None => from_str(ident.get().to_str()).unwrap()\n             };\n             Some(CrateInfo {\n-                  ident: ident.get().to_str(),\n-                  name: name,\n-                  version: version,\n-                  id: id,\n+                ident: ident.get().to_str(),\n+                crate_id: crate_id,\n+                id: id,\n             })\n         }\n         _ => None\n@@ -285,100 +277,97 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, name: &str, version: &str, hash: &str) -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, crate_id: &CrateId,\n+                  hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n-        let crateid_version = match c.crateid.version {\n-            None => ~\"0.0\",\n-            Some(ref ver) => ver.to_str(),\n-        };\n-        if (name.is_empty() || name == c.crateid.name) &&\n-            (version.is_empty() || version == crateid_version) &&\n-            (hash.is_empty() || hash == c.hash) {\n-            return Some(c.cnum);\n+        if !crate_id.matches(&c.crate_id) { continue }\n+        match hash {\n+            Some(hash) if *hash != c.hash => {}\n+            Some(..) | None => return Some(c.cnum)\n         }\n     }\n     None\n }\n \n fn resolve_crate(e: &mut Env,\n-                 root_ident: Option<~str>,\n-                 ident: ~str,\n-                 name: ~str,\n-                 version: ~str,\n-                 hash: ~str,\n+                 root_ident: Option<&str>,\n+                 ident: &str,\n+                 crate_id: &CrateId,\n+                 hash: Option<&Svh>,\n                  span: Span)\n               -> ast::CrateNum {\n-    match existing_match(e, name, version, hash) {\n-      None => {\n-        let load_ctxt = loader::Context {\n-            sess: e.sess,\n-            span: span,\n-            ident: ident,\n-            name: name,\n-            version: version,\n-            hash: hash,\n-            os: e.os,\n-            intr: e.intr\n-        };\n-        let loader::Library {\n-            dylib, rlib, metadata\n-        } = load_ctxt.load_library_crate(root_ident.clone());\n-\n-        let attrs = decoder::get_crate_attributes(metadata.as_slice());\n-        let crateid = attr::find_crateid(attrs).unwrap();\n-        let hash = decoder::get_crate_hash(metadata.as_slice());\n-\n-        // Claim this crate number and cache it\n-        let cnum = e.next_crate_num;\n-        {\n-            let mut crate_cache = e.crate_cache.borrow_mut();\n-            crate_cache.get().push(cache_entry {\n-                cnum: cnum,\n+    match existing_match(e, crate_id, hash) {\n+        None => {\n+            let id_hash = link::crate_id_hash(crate_id);\n+            let mut load_ctxt = loader::Context {\n+                sess: e.sess,\n                 span: span,\n-                hash: hash,\n-                crateid: crateid,\n-            });\n-        }\n-        e.next_crate_num += 1;\n-\n-        // Maintain a reference to the top most crate.\n-        let root_crate = match root_ident {\n-            Some(c) => c,\n-            None => load_ctxt.ident.clone()\n-        };\n+                ident: ident,\n+                crate_id: crate_id,\n+                id_hash: id_hash,\n+                hash: hash.map(|a| &*a),\n+                os: e.os,\n+                intr: e.intr,\n+                rejected_via_hash: false,\n+            };\n+            let loader::Library {\n+                dylib, rlib, metadata\n+            } = load_ctxt.load_library_crate(root_ident);\n+\n+            let crate_id = decoder::get_crate_id(metadata.as_slice());\n+            let hash = decoder::get_crate_hash(metadata.as_slice());\n+\n+            // Claim this crate number and cache it\n+            let cnum = e.next_crate_num;\n+            {\n+                let mut crate_cache = e.crate_cache.borrow_mut();\n+                crate_cache.get().push(cache_entry {\n+                    cnum: cnum,\n+                    span: span,\n+                    hash: hash,\n+                    crate_id: crate_id,\n+                });\n+            }\n+            e.next_crate_num += 1;\n \n-        // Now resolve the crates referenced by this crate\n-        let cnum_map = resolve_crate_deps(e,\n-                                          Some(root_crate),\n-                                          metadata.as_slice(),\n-                                          span);\n+            // Maintain a reference to the top most crate.\n+            let root_crate = match root_ident {\n+                Some(c) => c,\n+                None => load_ctxt.ident.clone()\n+            };\n \n-        let cmeta = @cstore::crate_metadata {\n-            name: load_ctxt.name,\n-            data: metadata,\n-            cnum_map: cnum_map,\n-            cnum: cnum\n-        };\n+            // Now resolve the crates referenced by this crate\n+            let cnum_map = resolve_crate_deps(e,\n+            Some(root_crate),\n+            metadata.as_slice(),\n+            span);\n+\n+            let cmeta = @cstore::crate_metadata {\n+                name: load_ctxt.crate_id.name.to_owned(),\n+                data: metadata,\n+                cnum_map: cnum_map,\n+                cnum: cnum\n+            };\n \n-        let cstore = e.sess.cstore;\n-        cstore.set_crate_data(cnum, cmeta);\n-        cstore.add_used_crate_source(cstore::CrateSource {\n-            dylib: dylib,\n-            rlib: rlib,\n-            cnum: cnum,\n-        });\n-        return cnum;\n-      }\n-      Some(cnum) => {\n-        return cnum;\n-      }\n+            let cstore = e.sess.cstore;\n+            cstore.set_crate_data(cnum, cmeta);\n+            cstore.add_used_crate_source(cstore::CrateSource {\n+                dylib: dylib,\n+                rlib: rlib,\n+                cnum: cnum,\n+            });\n+            return cnum;\n+        }\n+        Some(cnum) => {\n+            return cnum;\n+        }\n     }\n }\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: &mut Env,\n-                      root_ident: Option<~str>,\n+                      root_ident: Option<&str>,\n                       cdata: &[u8], span : Span)\n                    -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n@@ -388,31 +377,13 @@ fn resolve_crate_deps(e: &mut Env,\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname_str = token::get_ident(dep.name);\n-        debug!(\"resolving dep crate {} ver: {} hash: {}\",\n-               cname_str, dep.vers, dep.hash);\n-        match existing_match(e,\n-                             cname_str.get(),\n-                             dep.vers,\n-                             dep.hash) {\n-          Some(local_cnum) => {\n-            debug!(\"already have it\");\n-            // We've already seen this crate\n-            cnum_map.insert(extrn_cnum, local_cnum);\n-          }\n-          None => {\n-            debug!(\"need to load it\");\n-            // This is a new one so we've got to load it\n-            let local_cnum = resolve_crate(e,\n-                                           root_ident.clone(),\n-                                           cname_str.get().to_str(),\n-                                           cname_str.get().to_str(),\n-                                           dep.vers.clone(),\n-                                           dep.hash.clone(),\n-                                           span);\n-            cnum_map.insert(extrn_cnum, local_cnum);\n-          }\n-        }\n+        debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n+        let local_cnum = resolve_crate(e, root_ident,\n+                                       dep.crate_id.name.as_slice(),\n+                                       &dep.crate_id,\n+                                       Some(&dep.hash),\n+                                       span);\n+        cnum_map.insert(extrn_cnum, local_cnum);\n     }\n     return @RefCell::new(cnum_map);\n }\n@@ -439,14 +410,9 @@ impl Loader {\n \n impl CrateLoader for Loader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n-        let info = extract_crate_info(krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env,\n-                                 None,\n-                                 info.ident.clone(),\n-                                 info.name.clone(),\n-                                 info.version.clone(),\n-                                 ~\"\",\n-                                 krate.span);\n+        let info = extract_crate_info(&self.env, krate).unwrap();\n+        let cnum = resolve_crate(&mut self.env, None, info.ident,\n+                                 &info.crate_id, None, krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "baca85d50ae97c525cc839ccd2aeb0d2cf5f053a", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -13,6 +13,7 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n+use back::svh::Svh;\n use metadata::decoder;\n use metadata::loader;\n \n@@ -21,6 +22,7 @@ use collections::HashMap;\n use extra::c_vec::CVec;\n use syntax::ast;\n use syntax::parse::token::IdentInterner;\n+use syntax::crateid::CrateId;\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -91,14 +93,14 @@ impl CStore {\n         *metas.get().get(&cnum)\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> ~str {\n+    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> ~str {\n+    pub fn get_crate_id(&self, cnum: ast::CrateNum) -> CrateId {\n         let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_vers(cdata.data())\n+        decoder::get_crate_id(cdata.data())\n     }\n \n     pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n@@ -191,41 +193,6 @@ impl CStore {\n         let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n         extern_mod_crate_map.get().find(&emod_id).map(|x| *x)\n     }\n-\n-    // returns hashes of crates directly used by this crate. Hashes are sorted by\n-    // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-    pub fn get_dep_hashes(&self) -> ~[~str] {\n-        let mut result = ~[];\n-\n-        let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n-        for (_, &cnum) in extern_mod_crate_map.get().iter() {\n-            let cdata = self.get_crate_data(cnum);\n-            let hash = decoder::get_crate_hash(cdata.data());\n-            let vers = decoder::get_crate_vers(cdata.data());\n-            debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n-            result.push(crate_hash {\n-                name: cdata.name.clone(),\n-                vers: vers,\n-                hash: hash\n-            });\n-        }\n-\n-        result.sort();\n-\n-        debug!(\"sorted:\");\n-        for x in result.iter() {\n-            debug!(\"  hash[{}]: {}\", x.name, x.hash);\n-        }\n-\n-        result.move_iter().map(|crate_hash { hash, ..}| hash).collect()\n-    }\n-}\n-\n-#[deriving(Clone, TotalEq, TotalOrd)]\n-struct crate_hash {\n-    name: ~str,\n-    vers: ~str,\n-    hash: ~str,\n }\n \n impl crate_metadata {"}, {"sha": "42754aedba704cfd416fe2804464abde439151be", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -12,12 +12,12 @@\n \n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n@@ -44,6 +44,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::crateid::CrateId;\n \n type Cmd = @crate_metadata;\n \n@@ -1089,9 +1090,9 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     return attrs;\n }\n \n-fn list_crate_attributes(md: ebml::Doc, hash: &str,\n+fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n-    try!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n+    try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n@@ -1108,9 +1109,8 @@ pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n #[deriving(Clone)]\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n-    name: ast::Ident,\n-    vers: ~str,\n-    hash: ~str\n+    crate_id: CrateId,\n+    hash: Svh,\n }\n \n pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n@@ -1123,10 +1123,13 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n         d.as_str_slice().to_str()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n-        deps.push(CrateDep {cnum: crate_num,\n-                  name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n-                  vers: docstr(depdoc, tag_crate_dep_vers),\n-                  hash: docstr(depdoc, tag_crate_dep_hash)});\n+        let crate_id = from_str(docstr(depdoc, tag_crate_dep_crateid)).unwrap();\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n+        deps.push(CrateDep {\n+            cnum: crate_num,\n+            crate_id: crate_id,\n+            hash: hash,\n+        });\n         crate_num += 1;\n         true\n     });\n@@ -1135,39 +1138,29 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n \n fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n-\n-    let r = get_crate_deps(data);\n-    for dep in r.iter() {\n-        try!(write!(out,\n-                      \"{} {}-{}-{}\\n\",\n-                      dep.cnum,\n-                      token::get_ident(dep.name),\n-                      dep.hash,\n-                      dep.vers));\n+    for dep in get_crate_deps(data).iter() {\n+        try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.crate_id, dep.hash));\n     }\n-\n     try!(write!(out, \"\\n\"));\n     Ok(())\n }\n \n-pub fn get_crate_hash(data: &[u8]) -> ~str {\n+pub fn get_crate_hash(data: &[u8]) -> Svh {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    hashdoc.as_str_slice().to_str()\n+    Svh::new(hashdoc.as_str_slice())\n }\n \n-pub fn get_crate_vers(data: &[u8]) -> ~str {\n-    let attrs = decoder::get_crate_attributes(data);\n-    match attr::find_crateid(attrs) {\n-        None => ~\"0.0\",\n-        Some(crateid) => crateid.version_or_default().to_str(),\n-    }\n+pub fn get_crate_id(data: &[u8]) -> CrateId {\n+    let cratedoc = reader::Doc(data);\n+    let hashdoc = reader::get_doc(cratedoc, tag_crate_crateid);\n+    from_str(hashdoc.as_str_slice()).unwrap()\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    try!(list_crate_attributes(md, hash, out));\n+    try!(list_crate_attributes(md, &hash, out));\n     list_crate_deps(bytes, out)\n }\n "}, {"sha": "5bcc113ef946ba01b3a8818903cfac6d275559bc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -13,6 +13,7 @@\n #[allow(unused_must_use)]; // everything is just a MemWriter, can't fail\n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n@@ -40,6 +41,7 @@ use syntax::ast_util::*;\n use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n+use syntax::crateid::CrateId;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n@@ -1510,8 +1512,7 @@ fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n         cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {\n                 cnum: key,\n-                name: token::str_to_ident(val.name),\n-                vers: decoder::get_crate_vers(val.data()),\n+                crate_id: decoder::get_crate_id(val.data()),\n                 hash: decoder::get_crate_hash(val.data())\n             };\n             deps.push(dep);\n@@ -1729,22 +1730,24 @@ fn encode_misc_info(ecx: &EncodeContext,\n fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n                     dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_name);\n-    let s = token::get_ident(dep.name);\n-    ebml_w.writer.write(s.get().as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(dep.vers.as_bytes());\n+    ebml_w.start_tag(tag_crate_dep_crateid);\n+    ebml_w.writer.write(dep.crate_id.to_str().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(dep.hash.as_bytes());\n+    ebml_w.writer.write(dep.hash.as_str().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n+fn encode_hash(ebml_w: &mut writer::Encoder, hash: &Svh) {\n     ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(hash.as_bytes());\n+    ebml_w.writer.write(hash.as_str().as_bytes());\n+    ebml_w.end_tag();\n+}\n+\n+fn encode_crate_id(ebml_w: &mut writer::Encoder, crate_id: &CrateId) {\n+    ebml_w.start_tag(tag_crate_crateid);\n+    ebml_w.writer.write(crate_id.to_str().as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -1806,7 +1809,8 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n     let mut ebml_w = writer::Encoder(wr);\n \n-    encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n+    encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n+    encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n \n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);"}, {"sha": "9c61191ff9916da0c8220485075c81e2c52e5446", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -11,6 +11,7 @@\n //! Finds crate binaries and loads their metadata\n \n use back::archive::{ArchiveRO, METADATA_FILENAME};\n+use back::svh::Svh;\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n@@ -21,7 +22,6 @@ use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n-use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n@@ -44,15 +44,16 @@ pub enum Os {\n     OsFreebsd\n }\n \n-pub struct Context {\n+pub struct Context<'a> {\n     sess: Session,\n     span: Span,\n-    ident: ~str,\n-    name: ~str,\n-    version: ~str,\n-    hash: ~str,\n+    ident: &'a str,\n+    crate_id: &'a CrateId,\n+    id_hash: &'a str,\n+    hash: Option<&'a Svh>,\n     os: Os,\n-    intr: @IdentInterner\n+    intr: @IdentInterner,\n+    rejected_via_hash: bool,\n }\n \n pub struct Library {\n@@ -79,30 +80,41 @@ fn realpath(p: &Path) -> Path {\n     }\n }\n \n-impl Context {\n-    pub fn load_library_crate(&self, root_ident: Option<~str>) -> Library {\n+impl<'a> Context<'a> {\n+    pub fn load_library_crate(&mut self, root_ident: Option<&str>) -> Library {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n                 self.sess.abort_if_errors();\n+                let message = if self.rejected_via_hash {\n+                    format!(\"found possibly newer version of crate `{}`\",\n+                            self.ident)\n+                } else {\n+                    format!(\"can't find crate for `{}`\", self.ident)\n+                };\n                 let message = match root_ident {\n-                    None => format!(\"can't find crate for `{}`\", self.ident),\n-                    Some(c) => format!(\"can't find crate for `{}` which `{}` depends on\",\n-                                       self.ident,\n-                                       c)\n+                    None => message,\n+                    Some(c) => format!(\"{} which `{}` depends on\", message, c),\n                 };\n-                self.sess.span_fatal(self.span, message);\n+                self.sess.span_err(self.span, message);\n+\n+                if self.rejected_via_hash {\n+                    self.sess.span_note(self.span, \"perhaps this crate needs \\\n+                                                    to be recompiled?\");\n+                }\n+                self.sess.abort_if_errors();\n+                unreachable!()\n             }\n         }\n     }\n \n-    fn find_library_crate(&self) -> Option<Library> {\n+    fn find_library_crate(&mut self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.name);\n-        let rlib_prefix = format!(\"lib{}-\", self.name);\n+        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.crate_id.name);\n+        let rlib_prefix = format!(\"lib{}-\", self.crate_id.name);\n \n         let mut candidates = HashMap::new();\n \n@@ -196,7 +208,8 @@ impl Context {\n             1 => Some(libraries[0]),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\", self.name));\n+                    format!(\"multiple matching crates for `{}`\",\n+                            self.crate_id.name));\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n@@ -212,13 +225,8 @@ impl Context {\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n-                    let attrs = decoder::get_crate_attributes(data);\n-                    match attr::find_crateid(attrs) {\n-                        None => {}\n-                        Some(crateid) => {\n-                            note_crateid_attr(self.sess.diagnostic(), &crateid);\n-                        }\n-                    }\n+                    let crate_id = decoder::get_crate_id(data);\n+                    note_crateid_attr(self.sess.diagnostic(), &crate_id);\n                 }\n                 None\n             }\n@@ -240,17 +248,21 @@ impl Context {\n         debug!(\"matching -- {}, middle: {}\", file, middle);\n         let mut parts = middle.splitn('-', 1);\n         let hash = match parts.next() { Some(h) => h, None => return None };\n-        debug!(\"matching -- {}, hash: {}\", file, hash);\n+        debug!(\"matching -- {}, hash: {} (want {})\", file, hash, self.id_hash);\n         let vers = match parts.next() { Some(v) => v, None => return None };\n-        debug!(\"matching -- {}, vers: {}\", file, vers);\n-        if !self.version.is_empty() && self.version.as_slice() != vers {\n-            return None\n+        debug!(\"matching -- {}, vers: {} (want {})\", file, vers,\n+               self.crate_id.version);\n+        match self.crate_id.version {\n+            Some(ref version) if version.as_slice() != vers => return None,\n+            Some(..) => {} // check the hash\n+\n+            // hash is irrelevant, no version specified\n+            None => return Some(hash.to_owned())\n         }\n-        debug!(\"matching -- {}, vers ok (requested {})\", file,\n-               self.version);\n+        debug!(\"matching -- {}, vers ok\", file);\n         // hashes in filenames are prefixes of the \"true hash\"\n-        if self.hash.is_empty() || self.hash.starts_with(hash) {\n-            debug!(\"matching -- {}, hash ok (requested {})\", file, self.hash);\n+        if self.id_hash == hash.as_slice() {\n+            debug!(\"matching -- {}, hash ok\", file);\n             Some(hash.to_owned())\n         } else {\n             None\n@@ -269,13 +281,13 @@ impl Context {\n     // FIXME(#10786): for an optimization, we only read one of the library's\n     //                metadata sections. In theory we should read both, but\n     //                reading dylib metadata is quite slow.\n-    fn extract_one(&self, m: HashSet<Path>, flavor: &str,\n+    fn extract_one(&mut self, m: HashSet<Path>, flavor: &str,\n                    slot: &mut Option<MetadataBlob>) -> Option<Path> {\n         if m.len() == 0 { return None }\n         if m.len() > 1 {\n             self.sess.span_err(self.span,\n                                format!(\"multiple {} candidates for `{}` \\\n-                                        found\", flavor, self.name));\n+                                        found\", flavor, self.crate_id.name));\n             for (i, path) in m.iter().enumerate() {\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate \\#{}: {}\", i + 1,\n@@ -289,8 +301,7 @@ impl Context {\n             info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n             match get_metadata_section(self.os, &lib) {\n                 Some(blob) => {\n-                    if crate_matches(blob.as_slice(), self.name,\n-                                     self.version, self.hash) {\n+                    if self.crate_matches(blob.as_slice()) {\n                         *slot = Some(blob);\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -306,6 +317,22 @@ impl Context {\n         return Some(lib);\n     }\n \n+    fn crate_matches(&mut self, crate_data: &[u8]) -> bool {\n+        let other_id = decoder::get_crate_id(crate_data);\n+        if !self.crate_id.matches(&other_id) { return false }\n+        match self.hash {\n+            None => true,\n+            Some(hash) => {\n+                if *hash != decoder::get_crate_hash(crate_data) {\n+                    self.rejected_via_hash = true;\n+                    false\n+                } else {\n+                    true\n+                }\n+            }\n+        }\n+    }\n+\n     // Returns the corresponding (prefix, suffix) that files need to have for\n     // dynamic libraries\n     fn dylibname(&self) -> (&'static str, &'static str) {\n@@ -323,25 +350,6 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n \n-fn crate_matches(crate_data: &[u8],\n-                 name: &str,\n-                 version: &str,\n-                 hash: &str) -> bool {\n-    let attrs = decoder::get_crate_attributes(crate_data);\n-    match attr::find_crateid(attrs) {\n-        None => false,\n-        Some(crateid) => {\n-            if !hash.is_empty() {\n-                let chash = decoder::get_crate_hash(crate_data);\n-                if chash.as_slice() != hash { return false; }\n-            }\n-            name == crateid.name &&\n-                (version.is_empty() ||\n-                 crateid.version_or_default() == version)\n-        }\n-    }\n-}\n-\n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n         let data: &'static [u8] = {"}, {"sha": "683246f3333beb73d0dd3a0ebbd8ba150beadbc2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -2453,7 +2453,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(\"_rust_crate_map_\" + mapmeta.crateid.name, mapmeta.crate_hash,\n+        symname(\"_rust_crate_map_\" + mapmeta.crateid.name,\n+                mapmeta.crate_hash.as_str(),\n                 mapmeta.crateid.version_or_default())\n     };\n \n@@ -2487,8 +2488,8 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     while cstore.have_crate_data(i) {\n         let cdata = cstore.get_crate_data(i);\n         let nm = symname(format!(\"_rust_crate_map_{}\", cdata.name),\n-                         cstore.get_crate_hash(i),\n-                         cstore.get_crate_vers(i));\n+                         cstore.get_crate_hash(i).as_str(),\n+                         cstore.get_crate_id(i).version_or_default());\n         let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n@@ -2609,9 +2610,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n     }\n \n-    let mut symbol_hasher = Sha256::new();\n-    let link_meta = link::build_link_meta(krate.attrs, output,\n-                                          &mut symbol_hasher);\n+    let link_meta = link::build_link_meta(&krate, output);\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n     //\n@@ -2621,16 +2620,16 @@ pub fn trans_crate(sess: session::Session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.crateid.name.clone() + \".rs\";\n+    let llmod_id = link_meta.crateid.name + \".rs\";\n \n     let ccx = @CrateContext::new(sess,\n-                                     llmod_id,\n-                                     analysis.ty_cx,\n-                                     analysis.exp_map2,\n-                                     analysis.maps,\n-                                     symbol_hasher,\n-                                     link_meta,\n-                                     analysis.reachable);\n+                                 llmod_id,\n+                                 analysis.ty_cx,\n+                                 analysis.exp_map2,\n+                                 analysis.maps,\n+                                 Sha256::new(),\n+                                 link_meta,\n+                                 analysis.reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &krate.module);"}, {"sha": "8350b24c451c9b5958cc408c4771404c42fedebf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -329,7 +329,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx,\n                 substs.tys[0],\n-                ccx.link_meta.crate_hash.clone());\n+                &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);"}, {"sha": "2ca19f0b61d82e5bbcb734db0921385c2a4e9810", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -10,6 +10,7 @@\n \n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use driver::session;\n use metadata::csearch;\n use metadata;\n@@ -4882,7 +4883,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n+pub fn hash_crate_independent(tcx: ctxt, t: t, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n@@ -4913,11 +4914,11 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n     };\n     let did = |state: &mut sip::SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n-            local_hash.clone()\n+            svh.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_bytes().hash(state);\n+        h.as_str().hash(state);\n         did.node.hash(state);\n     };\n     let mt = |state: &mut sip::SipState, mt: mt| {"}, {"sha": "b5f02fb7e644106b0e37ab7cb37fd307988575fd", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -107,6 +107,15 @@ impl CrateId {\n     pub fn short_name_with_version(&self) -> ~str {\n         format!(\"{}-{}\", self.name, self.version_or_default())\n     }\n+\n+    pub fn matches(&self, other: &CrateId) -> bool {\n+        // FIXME: why does this not match on `path`?\n+        if self.name != other.name { return false }\n+        match (&self.version, &other.version) {\n+            (&Some(ref v1), &Some(ref v2)) => v1 == v2,\n+            _ => true,\n+        }\n+    }\n }\n \n #[test]"}, {"sha": "4b9925c8d9f3e9a4875d623dac5ba4afe34bc500", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -135,5 +135,6 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // phew, not our responsibility any more!\n     format::expand_preparsed_format_args(cx, span,\n                                          format_closure,\n-                                         format_string, exprs, HashMap::new())\n+                                         format_string, exprs, ~[],\n+                                         HashMap::new())\n }"}, {"sha": "2642ee00458c12015861328f26194e030f5b1cff", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -43,9 +43,13 @@ struct Context<'a> {\n     // them.\n     args: ~[@ast::Expr],\n     arg_types: ~[Option<ArgumentType>],\n-    // Parsed named expressions and the types that we've found for them so far\n+    // Parsed named expressions and the types that we've found for them so far.\n+    // Note that we keep a side-array of the ordering of the named arguments\n+    // found to be sure that we can translate them in the same order that they\n+    // were declared in.\n     names: HashMap<~str, @ast::Expr>,\n     name_types: HashMap<~str, ArgumentType>,\n+    name_ordering: ~[~str],\n \n     // Collection of the compiled `rt::Piece` structures\n     pieces: ~[@ast::Expr],\n@@ -63,12 +67,15 @@ struct Context<'a> {\n ///\n /// If parsing succeeds, the second return value is:\n ///\n-///     Some((fmtstr, unnamed arguments, named arguments))\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span,\n-              tts: &[ast::TokenTree]) -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr],\n-                                                              HashMap<~str, @ast::Expr>)>) {\n+///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n+///           named arguments))\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+    -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr], ~[~str],\n+                            HashMap<~str, @ast::Expr>)>)\n+{\n     let mut args = ~[];\n     let mut names = HashMap::<~str, @ast::Expr>::new();\n+    let mut order = ~[];\n \n     let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n                                              ecx.cfg(),\n@@ -125,12 +132,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span,\n                     continue\n                 }\n             }\n+            order.push(name.to_str());\n             names.insert(name.to_str(), e);\n         } else {\n             args.push(p.parse_expr());\n         }\n     }\n-    return (extra, Some((fmtstr, args, names)));\n+    return (extra, Some((fmtstr, args, order, names)));\n }\n \n impl<'a> Context<'a> {\n@@ -661,10 +669,11 @@ impl<'a> Context<'a> {\n             locals.push(self.format_arg(e.span, Exact(i),\n                                         self.ecx.expr_ident(e.span, name)));\n         }\n-        for (name, &e) in self.names.iter() {\n-            if !self.name_types.contains_key(name) {\n-                continue\n-            }\n+        for name in self.name_ordering.iter() {\n+            let e = match self.names.find(name) {\n+                Some(&e) if self.name_types.contains_key(name) => e,\n+                Some(..) | None => continue\n+            };\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n@@ -810,8 +819,9 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                    tts: &[ast::TokenTree]) -> base::MacResult {\n \n     match parse_args(ecx, sp, tts) {\n-        (extra, Some((efmt, args, names))) => {\n-            MRExpr(expand_preparsed_format_args(ecx, sp, extra, efmt, args, names))\n+        (extra, Some((efmt, args, order, names))) => {\n+            MRExpr(expand_preparsed_format_args(ecx, sp, extra, efmt, args,\n+                                                order, names))\n         }\n         (_, None) => MRExpr(ecx.expr_uint(sp, 2))\n     }\n@@ -823,6 +833,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     extra: @ast::Expr,\n                                     efmt: @ast::Expr, args: ~[@ast::Expr],\n+                                    name_ordering: ~[~str],\n                                     names: HashMap<~str, @ast::Expr>) -> @ast::Expr {\n     let arg_types = vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -832,6 +843,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         names: names,\n         name_positions: HashMap::new(),\n         name_types: HashMap::new(),\n+        name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n         pieces: ~[],"}, {"sha": "c0bdbf81772ac4edcf37c8e9c35d6ae2c6b995f0", "filename": "src/test/auxiliary/changing-crates-a1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"a\"];\n+\n+pub fn foo<T>() {}"}, {"sha": "cc123c0f65ddf9f259e0e1a3aa146563972e73de", "filename": "src/test/auxiliary/changing-crates-a2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"a\"];\n+\n+pub fn foo<T>() { println!(\"hello!\"); }\n+"}, {"sha": "9b80583bb84a03143a1ddb39eed6079aa15b2216", "filename": "src/test/auxiliary/changing-crates-b.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"b\"];\n+\n+extern crate a;\n+\n+pub fn foo() { a::foo::<int>(); }"}, {"sha": "43956752cd9b343fc72ee2f8f375ceab67815498", "filename": "src/test/compile-fail/bad-crate-id.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo = \"\"; //~ ERROR: malformed crate id\n+extern crate bar = \"#a\"; //~ ERROR: malformed crate id\n+\n+fn main() {}"}, {"sha": "ae3ef7606671058d4cf9e314de5b51dbeee861ef", "filename": "src/test/compile-fail/changing-crates.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// note that these aux-build directives must be in this order\n+// aux-build:changing-crates-a1.rs\n+// aux-build:changing-crates-b.rs\n+// aux-build:changing-crates-a2.rs\n+\n+extern crate a;\n+extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n+//~^ NOTE: perhaps this crate needs to be recompiled\n+\n+fn main() {}"}, {"sha": "564f7b43426395d756c2a23b730c8290ac6236b2", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58ea029db2fd9da6eac85456191481b4cbdb9e58/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=58ea029db2fd9da6eac85456191481b4cbdb9e58", "patch": "@@ -139,6 +139,7 @@ pub fn main() {\n \n     test_write();\n     test_print();\n+    test_order();\n \n     // make sure that format! doesn't move out of local variables\n     let a = ~3;\n@@ -202,3 +203,18 @@ fn test_format_args() {\n     let s = format_args!(fmt::format, \"hello {}\", \"world\");\n     t!(s, \"hello world\");\n }\n+\n+fn test_order() {\n+    // Make sure format!() arguments are always evaluated in a left-to-right\n+    // ordering\n+    fn foo() -> int {\n+        static mut FOO: int = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n+                       foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n+               ~\"1 2 4 5 3 6\");\n+}"}]}