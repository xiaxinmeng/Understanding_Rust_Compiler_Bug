{"sha": "04fa9b1b3f947fa66bb3e92702e134c72af9486f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZmE5YjFiM2Y5NDdmYTY2YmIzZTkyNzAyZTEzNGM3MmFmOTQ4NmY=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-09-25T12:58:41Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-09-30T22:41:20Z"}, "message": "async/await: improve obligation errors\n\nThis commit improves obligation errors for async/await:\n\n```\nnote: future does not implement `std::marker::Send` because this value is used across an\n      await\n  --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n   |\nLL |     let g = x.lock().unwrap();\n   |         - has type `std::sync::MutexGuard<'_, u32>`\nLL |     baz().await;\n   |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\nLL | }\n   | - `g` is later dropped here\n```\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "36337f318c51ae0809a55bb34d122ffed380a45a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36337f318c51ae0809a55bb34d122ffed380a45a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04fa9b1b3f947fa66bb3e92702e134c72af9486f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl2ShJEACgkQJZLnbIc4\nH9ncGRAApW/DRPhI4vuQG/mNbGQaH5Pf+nXF1ovb1VHAjqR9qaaZKLQJHFLfrAL5\nWpYXaWQYdk/8yjWyO+KiHYcyUYeXSPOoqM0NBeT9S8wzileuSMx64rtwW0rbWImr\nsfEYDRRe08gYgA+4tIu927tcfyW5nmqvNkrTTkecSt0BghUmK6evVskbjd0WtQ4U\n0SHMJHFg5YgPA2Fez1XSnoCkMq4VjTsl/Jrd0qvu1X01z49nvKWAeSWdmwS3xHd5\nIWVjFa/IvpvlYjhPeEIkinTfw04futEUIz8sBGKFEqwEJSEr7i4NhSA3zfRWReOH\nBsAFwc4mfOuG6x+zbijFaJijtdxB/AvWfgi3vT1597zQZ2VV9u8eXHMU7pa7aylx\noJga+TA7KnOIZnaoDUXTGDhLgv8N8ofT3xV2p0QixXayzVMqC2O1GWqEwisDWktn\nVuM3v9z6wxSmbMNRKHWo+D8SocLumWD6CjDyaqSp2UrnTuJ1YFTQ1XIXihdbw4/v\nq9E5SHzZvX5nhI+98sNadczIwnJ0lcFr019BGSSBRqKN+XNcedGknyJ4wJ79o8KT\n6z9DyIWdPxytNtJJ0jTke5ssYRbwMRbQV4fosthEBMl6O2bB88SjbnVUnBwqLnJy\ni/i7+A8Y6FBs17j8N8+sZ1pKmyHa3UVxH3LoYp98BwDTaG6Phkg=\n=kF+P\n-----END PGP SIGNATURE-----", "payload": "tree 36337f318c51ae0809a55bb34d122ffed380a45a\nparent d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50\nauthor David Wood <david@davidtw.co> 1569416321 +0100\ncommitter David Wood <david@davidtw.co> 1569883280 +0100\n\nasync/await: improve obligation errors\n\nThis commit improves obligation errors for async/await:\n\n```\nnote: future does not implement `std::marker::Send` because this value is used across an\n      await\n  --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n   |\nLL |     let g = x.lock().unwrap();\n   |         - has type `std::sync::MutexGuard<'_, u32>`\nLL |     baz().await;\n   |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\nLL | }\n   | - `g` is later dropped here\n```\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04fa9b1b3f947fa66bb3e92702e134c72af9486f", "html_url": "https://github.com/rust-lang/rust/commit/04fa9b1b3f947fa66bb3e92702e134c72af9486f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04fa9b1b3f947fa66bb3e92702e134c72af9486f/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "url": "https://api.github.com/repos/rust-lang/rust/commits/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "html_url": "https://github.com/rust-lang/rust/commit/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50"}], "stats": {"total": 309, "additions": 281, "deletions": 28}, "files": [{"sha": "05b561a1ed55a655ae0f97e5f8c2dc907a4549c8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 165, "deletions": 12, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -24,7 +24,7 @@ use crate::hir::def_id::DefId;\n use crate::infer::{self, InferCtxt};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::session::DiagnosticMessageId;\n-use crate::ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use crate::ty::GenericParamDefKind;\n use crate::ty::error::ExpectedFound;\n use crate::ty::fast_reject;\n@@ -37,7 +37,7 @@ use errors::{Applicability, DiagnosticBuilder, pluralise};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::{sym, kw};\n-use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(\n@@ -550,7 +550,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        self.note_obligation_cause(&mut err, obligation);\n+        self.note_obligation_cause_code(&mut err, &obligation.predicate, &obligation.cause.code,\n+                                        &mut vec![]);\n \n         err.emit();\n         self.tcx.sess.abort_if_errors();\n@@ -940,7 +941,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 bug!(\"overflow should be handled before the `report_selection_error` path\");\n             }\n         };\n+\n         self.note_obligation_cause(&mut err, obligation);\n+\n         err.emit();\n     }\n \n@@ -1604,15 +1607,165 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn note_obligation_cause<T>(&self,\n-                                err: &mut DiagnosticBuilder<'_>,\n-                                obligation: &Obligation<'tcx, T>)\n-        where T: fmt::Display\n-    {\n-        self.note_obligation_cause_code(err,\n-                                        &obligation.predicate,\n-                                        &obligation.cause.code,\n-                                        &mut vec![]);\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(err, &obligation.predicate, &obligation.cause.code,\n+                                            &mut vec![]);\n+        }\n+    }\n+\n+    /// Adds an async-await specific note to the diagnostic:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// note: future does not implement `std::marker::Send` because this value is used across an\n+    ///       await\n+    ///   --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n+    ///    |\n+    /// LL |     let g = x.lock().unwrap();\n+    ///    |         - has type `std::sync::MutexGuard<'_, u32>`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n+    /// LL | }\n+    ///    | - `g` is later dropped here\n+    /// ```\n+    ///\n+    /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        debug!(\"note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+                obligation.cause.span={:?}\", obligation.predicate, obligation.cause.span);\n+        let source_map = self.tcx.sess.source_map();\n+\n+        // Look into the obligation predicate to determine the type in the generator which meant\n+        // that the predicate was not satisifed.\n+        let (trait_ref, target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(trait_predicate) =>\n+                (trait_predicate.skip_binder().trait_ref, trait_predicate.skip_binder().self_ty()),\n+            _ => return false,\n+        };\n+        debug!(\"note_obligation_cause_for_async_await: target_ty={:?}\", target_ty);\n+\n+        // Attempt to detect an async-await error by looking at the obligation causes, looking\n+        // for only generators, generator witnesses, opaque types or `std::future::GenFuture` to\n+        // be present.\n+        //\n+        // When a future does not implement a trait because of a captured type in one of the\n+        // generators somewhere in the call stack, then the result is a chain of obligations.\n+        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // future is passed as an argument to a function C which requires a `Send` type, then the\n+        // chain looks something like this:\n+        //\n+        // - `BuiltinDerivedObligation` with a generator witness (B)\n+        // - `BuiltinDerivedObligation` with a generator (B)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with a generator witness (A)\n+        // - `BuiltinDerivedObligation` with a generator (A)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BindingObligation` with `impl_send (Send requirement)\n+        //\n+        // The first obligations in the chain can be used to get the details of the type that is\n+        // captured but the entire chain must be inspected to detect this case.\n+        let mut generator = None;\n+        let mut next_code = Some(&obligation.cause.code);\n+        while let Some(code) = next_code {\n+            debug!(\"note_obligation_cause_for_async_await: code={:?}\", code);\n+            match code {\n+                ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) |\n+                ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                    debug!(\"note_obligation_cause_for_async_await: self_ty.kind={:?}\",\n+                           derived_obligation.parent_trait_ref.self_ty().kind);\n+                    match derived_obligation.parent_trait_ref.self_ty().kind {\n+                        ty::Adt(ty::AdtDef { did, .. }, ..) if\n+                            self.tcx.is_diagnostic_item(sym::gen_future, *did) => {},\n+                        ty::Generator(did, ..) => generator = generator.or(Some(did)),\n+                        ty::GeneratorWitness(_) | ty::Opaque(..) => {},\n+                        _ => return false,\n+                    }\n+\n+                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                },\n+                ObligationCauseCode::ItemObligation(_) | ObligationCauseCode::BindingObligation(..)\n+                    if generator.is_some() => break,\n+                _ => return false,\n+            }\n+        }\n+\n+        let generator_did = generator.expect(\"can only reach this if there was a generator\");\n+\n+        // Only continue to add a note if the generator is from an `async` function.\n+        let parent_node = self.tcx.parent(generator_did)\n+            .and_then(|parent_did| self.tcx.hir().get_if_local(parent_did));\n+        debug!(\"note_obligation_cause_for_async_await: parent_node={:?}\", parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(_, header, _, _),\n+            ..\n+        })) = parent_node {\n+            debug!(\"note_obligation_cause_for_async_await: header={:?}\", header);\n+            if header.asyncness != hir::IsAsync::Async {\n+                return false;\n+            }\n+        }\n+\n+        let span = self.tcx.def_span(generator_did);\n+        let tables = self.tcx.typeck_tables_of(generator_did);\n+        debug!(\"note_obligation_cause_for_async_await: generator_did={:?} span={:?} \",\n+               generator_did, span);\n+\n+        // Look for a type inside the generator interior that matches the target type to get\n+        // a span.\n+        let target_span = tables.generator_interior_types.iter()\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty::TyS::same_type(*ty, target_ty))\n+            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, .. }|\n+                 (span, source_map.span_to_snippet(*span), scope_span));\n+        if let Some((target_span, Ok(snippet), scope_span)) = target_span {\n+            // Look at the last interior type to get a span for the `.await`.\n+            let await_span = tables.generator_interior_types.iter().map(|i| i.span).last().unwrap();\n+            let mut span = MultiSpan::from_span(await_span);\n+            span.push_span_label(\n+                await_span, format!(\"await occurs here, with `{}` maybe used later\", snippet));\n+\n+            span.push_span_label(*target_span, format!(\"has type `{}`\", target_ty));\n+\n+            // If available, use the scope span to annotate the drop location.\n+            if let Some(scope_span) = scope_span {\n+                span.push_span_label(\n+                    source_map.end_point(*scope_span),\n+                    format!(\"`{}` is later dropped here\", snippet),\n+                );\n+            }\n+\n+            err.span_note(span, &format!(\n+                \"future does not implement `{}` as this value is used across an await\",\n+                trait_ref,\n+            ));\n+\n+            // Add a note for the item obligation that remains - normally a note pointing to the\n+            // bound that introduced the obligation (e.g. `T: Send`).\n+            debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                next_code.unwrap(),\n+                &mut Vec::new(),\n+            );\n+\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn note_obligation_cause_code<T>(&self,"}, {"sha": "7626ecd424347e7787a8d1afee55fa95f4deb0e1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -288,6 +288,34 @@ pub struct ResolvedOpaqueTy<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n+/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n+/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n+/// captured types that can be useful for diagnostics. In particular, it stores the span that\n+/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n+/// be used to find the await that the value is live across).\n+///\n+/// For example:\n+///\n+/// ```ignore (pseudo-Rust)\n+/// async move {\n+///     let x: T = ...;\n+///     foo.await\n+///     ...\n+/// }\n+/// ```\n+///\n+/// Here, we would store the type `T`, the span of the value `x`, and the \"scope-span\" for\n+/// the scope that contains `x`.\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, HashStable, PartialEq)]\n+pub struct GeneratorInteriorTypeCause<'tcx> {\n+    /// Type of the captured binding.\n+    pub ty: Ty<'tcx>,\n+    /// Span of the binding that was captured.\n+    pub span: Span,\n+    /// Span of the scope of the captured binding.\n+    pub scope_span: Option<Span>,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The HirId::owner all ItemLocalIds in this table are relative to.\n@@ -397,6 +425,10 @@ pub struct TypeckTables<'tcx> {\n     /// leading to the member of the struct or tuple that is used instead of the\n     /// entire variable.\n     pub upvar_list: ty::UpvarListMap,\n+\n+    /// Stores the type, span and optional scope span of all types\n+    /// that are live across the yield of this generator (if a generator).\n+    pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -422,6 +454,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             free_region_map: Default::default(),\n             concrete_opaque_types: Default::default(),\n             upvar_list: Default::default(),\n+            generator_interior_types: Default::default(),\n         }\n     }\n \n@@ -729,6 +762,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref free_region_map,\n             ref concrete_opaque_types,\n             ref upvar_list,\n+            ref generator_interior_types,\n \n         } = *self;\n \n@@ -773,6 +807,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             free_region_map.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             upvar_list.hash_stable(hcx, hasher);\n+            generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "683c977499c6a41f36ea88a1776b924abfddbff8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -75,7 +75,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, CtxtInterners, GlobalCtxt};\n+pub use self::context::{Lift, GeneratorInteriorTypeCause, TypeckTables, CtxtInterners, GlobalCtxt};\n pub use self::context::{\n     UserTypeAnnotationIndex, UserType, CanonicalUserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,"}, {"sha": "4608eb51df74e1fa192f9718647e11d3601bf1ce", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -14,7 +14,7 @@ use crate::util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    types: FxHashMap<Ty<'tcx>, usize>,\n+    types: FxHashMap<ty::GeneratorInteriorTypeCause<'tcx>, usize>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n@@ -83,7 +83,12 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             } else {\n                 // Map the type to the number of types added before it\n                 let entries = self.types.len();\n-                self.types.entry(&ty).or_insert(entries);\n+                let scope_span = scope.map(|s| s.span(self.fcx.tcx, self.region_scope_tree));\n+                self.types.entry(ty::GeneratorInteriorTypeCause {\n+                    span: source_span,\n+                    ty: &ty,\n+                    scope_span\n+                }).or_insert(entries);\n             }\n         } else {\n             debug!(\"no type in expr = {:?}, count = {:?}, span = {:?}\",\n@@ -118,8 +123,12 @@ pub fn resolve_interior<'a, 'tcx>(\n     // Sort types by insertion order\n     types.sort_by_key(|t| t.1);\n \n+    // Store the generator types and spans into the tables for this generator.\n+    let interior_types = types.iter().cloned().map(|t| t.0).collect::<Vec<_>>();\n+    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = interior_types;\n+\n     // Extract type components\n-    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| t.0));\n+    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| (t.0).ty));\n \n     // The types in the generator interior contain lifetimes local to the generator itself,\n     // which should not be exposed outside of the generator. Therefore, we replace these"}, {"sha": "99d62d198a9fd66b5815ff7f972897bb5f8b76fd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -58,6 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n+        wbcx.visit_generator_interior_types();\n \n         let used_trait_imports = mem::replace(\n             &mut self.tables.borrow_mut().used_trait_imports,\n@@ -430,6 +431,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_generator_interior_types(&mut self) {\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        self.tables.generator_interior_types = fcx_tables.generator_interior_types.clone();\n+    }\n+\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();"}, {"sha": "c65f71fb1a4e2fc9a2899a5ebe8a73678e8d8268", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -26,6 +26,7 @@ pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T:\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"gen_future\")]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n \n // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "696bd5c39d2831cbd1d22e7ce41b1d467902e09a", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -9,9 +9,9 @@ LL |     assert_send(local_dropped_before_await());\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `{impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -26,9 +26,9 @@ LL |     assert_send(non_send_temporary_in_match());\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -45,9 +45,9 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut dyn std::fmt::Write`\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -68,9 +68,9 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::slice::Iter<'_, std::fmt::ArgumentV1<'_>>`\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n "}, {"sha": "1936d1a2ed56e7a0acdb8a627c773d8b8f9b2350", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -0,0 +1,25 @@\n+// edition:2018\n+\n+use std::sync::Mutex;\n+\n+fn is_send<T: Send>(t: T) {\n+\n+}\n+\n+async fn foo() {\n+    bar(&Mutex::new(22)).await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+    let g = x.lock().unwrap();\n+    baz().await;\n+}\n+\n+async fn baz() {\n+\n+}\n+\n+fn main() {\n+    is_send(foo());\n+    //~^ ERROR `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely [E0277]\n+}"}, {"sha": "9e9fc52e30b7f069238bca70c52b289c3b1f1c3a", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04fa9b1b3f947fa66bb3e92702e134c72af9486f/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr?ref=04fa9b1b3f947fa66bb3e92702e134c72af9486f", "patch": "@@ -0,0 +1,23 @@\n+error[E0277]: `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n+  --> $DIR/issue-64130-non-send-future-diags.rs:23:5\n+   |\n+LL | fn is_send<T: Send>(t: T) {\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL |     is_send(foo());\n+   |     ^^^^^^^ `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard<'_, u32>`\n+note: future does not implement `std::marker::Send` as this value is used across an await\n+  --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n+   |\n+LL |     let g = x.lock().unwrap();\n+   |         - has type `std::sync::MutexGuard<'_, u32>`\n+LL |     baz().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n+LL | }\n+   | - `g` is later dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}