{"sha": "7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzFhMWM4YTRhYzQyNGExZDc3ZmE5NDc0NmNhM2Q3YWE3MjMzNWU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-08T01:18:02Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:57Z"}, "message": "Add const generics to unification tables\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "854847506fca4c283c514becaf045f1823e7a226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/854847506fca4c283c514becaf045f1823e7a226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e", "html_url": "https://github.com/rust-lang/rust/commit/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9b9994c7258c1411656d69462b582ea4be12227", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9b9994c7258c1411656d69462b582ea4be12227", "html_url": "https://github.com/rust-lang/rust/commit/b9b9994c7258c1411656d69462b582ea4be12227"}], "stats": {"total": 170, "additions": 128, "deletions": 42}, "files": [{"sha": "12321f2e355c3b78c742ec4d29cc081d59e509e8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 128, "deletions": 42, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7d71a1c8a4ac424a1d77fa94746ca3d7aa72335e", "patch": "@@ -13,14 +13,15 @@ use crate::infer::canonical::{Canonical, CanonicalVarValues};\n use crate::middle::free_region::RegionRelations;\n use crate::middle::lang_items;\n use crate::middle::region;\n+use crate::mir::interpret::ConstValue;\n use crate::session::config::BorrowckMode;\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::RelateResult;\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n-use crate::ty::{FloatVid, IntVid, TyVid};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners, InferConst};\n+use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n use crate::util::nodemap::FxHashMap;\n \n use arena::SyncDroplessArena;\n@@ -34,6 +35,7 @@ use syntax_pos::symbol::InternedString;\n use syntax_pos::Span;\n \n use self::combine::CombineFields;\n+use self::const_variable::ConstVariableOrigin;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n@@ -60,6 +62,7 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n+pub mod const_variable;\n pub mod unify_key;\n \n #[must_use]\n@@ -72,7 +75,7 @@ pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n \n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n-pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n+pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n /// A flag that is used to suppress region errors. This is normally\n /// false, but sometimes -- when we are doing region checks that the\n@@ -122,7 +125,10 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// order, represented by its upper and lower bounds.\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n-    /// Map from integral variable to the kind of integer it represents\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: RefCell<const_variable::ConstVariableTable<'tcx>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n     int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n \n     /// Map from floating variable to the kind of float it represents\n@@ -422,10 +428,11 @@ impl NLLRegionVariableOrigin {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum FixupError {\n+pub enum FixupError<'tcx> {\n     UnresolvedIntTy(IntVid),\n     UnresolvedFloatTy(FloatVid),\n     UnresolvedTy(TyVid),\n+    UnresolvedConst(ConstVid<'tcx>),\n }\n \n /// See the `region_obligations` field for more information.\n@@ -436,7 +443,7 @@ pub struct RegionObligation<'tcx> {\n     pub origin: SubregionOrigin<'tcx>,\n }\n \n-impl fmt::Display for FixupError {\n+impl<'tcx> fmt::Display for FixupError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::FixupError::*;\n \n@@ -452,6 +459,7 @@ impl fmt::Display for FixupError {\n                  add a suffix to specify the type explicitly\"\n             ),\n             UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n+            UnresolvedConst(_) => write!(f, \"unconstrained const value\"),\n         }\n     }\n }\n@@ -524,6 +532,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n                 in_progress_tables,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+                const_unification_table: RefCell::new(const_variable::ConstVariableTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 float_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n@@ -589,6 +598,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n+    const_snapshot: const_variable::Snapshot<'tcx>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n@@ -652,6 +662,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut type_variables = self.type_variables.borrow_mut();\n         let mut int_unification_table = self.int_unification_table.borrow_mut();\n         let mut float_unification_table = self.float_unification_table.borrow_mut();\n+        // FIXME(const_generics): should there be an equivalent function for const variables?\n \n         type_variables\n             .unsolved_variables()\n@@ -722,6 +733,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         CombinedSnapshot {\n             projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n+            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n@@ -739,6 +751,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n             type_snapshot,\n+            const_snapshot,\n             int_snapshot,\n             float_snapshot,\n             region_constraints_snapshot,\n@@ -751,28 +764,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n \n-        self.projection_cache\n-            .borrow_mut()\n-            .rollback_to(projection_cache_snapshot);\n+        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n         self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .rollback_to(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .rollback_to(float_snapshot);\n-        self.region_obligations\n-            .borrow_mut()\n-            .truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints()\n-            .rollback_to(region_constraints_snapshot);\n+        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n+        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n+        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n+        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n+        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n             type_snapshot,\n+            const_snapshot,\n             int_snapshot,\n             float_snapshot,\n             region_constraints_snapshot,\n@@ -784,16 +790,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.in_snapshot.set(was_in_snapshot);\n \n-        self.projection_cache\n-            .borrow_mut()\n-            .commit(projection_cache_snapshot);\n+        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n         self.type_variables.borrow_mut().commit(type_snapshot);\n+        self.const_unification_table.borrow_mut().commit(const_snapshot);\n         self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .commit(float_snapshot);\n-        self.borrow_region_constraints()\n-            .commit(region_constraints_snapshot);\n+        self.float_unification_table.borrow_mut().commit(float_snapshot);\n+        self.borrow_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -918,17 +920,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         predicate: &ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve` just ignores anything that is not a type\n+        // `shallow_resolve_type` just ignores anything that is not a type\n         // variable, and because type variable's can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n         // Really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a\n+        // `shallow_resolve_type` here except as a\n         // micro-optimization. Naturally I could not\n         // resist. -nmatsakis\n         let two_unbound_type_vars = {\n-            let a = self.shallow_resolve(predicate.skip_binder().a);\n-            let b = self.shallow_resolve(predicate.skip_binder().b);\n+            let a = self.shallow_resolve_type(predicate.skip_binder().a);\n+            let b = self.shallow_resolve_type(predicate.skip_binder().b);\n             a.is_ty_var() && b.is_ty_var()\n         };\n \n@@ -999,6 +1001,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n     }\n \n+    pub fn next_const_var(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n+    }\n+\n+    pub fn next_const_var_in_universe(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        let vid = self.const_unification_table\n+            .borrow_mut()\n+            .new_var(universe, origin);\n+        self.tcx.mk_const_var(vid, ty)\n+    }\n+\n+    pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n+        self.const_unification_table\n+            .borrow_mut()\n+            .new_var(self.universe(), origin)\n+    }\n+\n     fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table.borrow_mut().new_key(None)\n     }\n@@ -1092,7 +1120,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.mk_ty_var(ty_var_id).into()\n             }\n             GenericParamDefKind::Const { .. } => {\n-                unimplemented!() // FIXME(const_generics)\n+                let const_var_id =\n+                    self.const_unification_table\n+                        .borrow_mut()\n+                        .new_var(\n+                            self.universe(),\n+                            ConstVariableOrigin::ConstParameterDefinition(span, param.name),\n+                        );\n+                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n             }\n         }\n     }\n@@ -1233,11 +1268,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type_vars_if_possible(t).to_string()\n     }\n \n-    // We have this force-inlined variant of shallow_resolve() for the one\n+    // We have this force-inlined variant of `shallow_resolve_type` for the one\n     // callsite that is extremely hot. All other callsites use the normal\n     // variant.\n     #[inline(always)]\n-    pub fn inlined_shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn inlined_shallow_resolve_type(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1253,7 +1288,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     .borrow_mut()\n                     .probe(v)\n                     .known()\n-                    .map(|t| self.shallow_resolve(t))\n+                    .map(|t| self.shallow_resolve_type(t))\n                     .unwrap_or(typ)\n             }\n \n@@ -1284,8 +1319,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve(typ)\n+    pub fn shallow_resolve_type(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+        self.inlined_shallow_resolve_type(typ)\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1323,9 +1358,60 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r.first_unresolved\n     }\n \n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n+    pub fn probe_const_var(\n+        &self,\n+        vid: ty::ConstVid<'tcx>\n+    ) -> Result<&'tcx ty::LazyConst<'tcx>, ty::UniverseIndex> {\n+        use self::const_variable::ConstVariableValue;\n+\n+        match self.const_unification_table.borrow_mut().probe(vid) {\n+            ConstVariableValue::Known { value } => Ok(value),\n+            ConstVariableValue::Unknown { universe } => Err(universe),\n+        }\n+    }\n+\n+    pub fn resolve_const_var(\n+        &self,\n+        ct: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Infer(InferConst::Var(v)),\n+            ..\n+        }) = ct {\n+            self.const_unification_table\n+                .borrow_mut()\n+                .probe(*v)\n+                .known()\n+                .map(|c| self.resolve_const_var(c))\n+                .unwrap_or(ct)\n+        } else {\n+            ct\n+        }\n+    }\n+\n+    pub fn shallow_resolve_const(\n+        &self,\n+        ct: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        match ct {\n+            ty::LazyConst::Evaluated(ty::Const {\n+                val: ConstValue::Infer(InferConst::Var(vid)),\n+                ..\n+            }) => {\n+                self.const_unification_table\n+                    .borrow_mut()\n+                    .probe(*vid)\n+                    .known()\n+                    .map(|c| self.shallow_resolve_const(c))\n+                    .unwrap_or(ct)\n+            }\n+            _ => ct,\n+        }\n+    }\n+\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n         /*!\n-         * Attempts to resolve all type/region variables in\n+         * Attempts to resolve all type/region/const variables in\n          * `value`. Region inference must have been run already (e.g.,\n          * by calling `resolve_regions_and_report_errors`). If some\n          * variable was never unified, an `Err` results.\n@@ -1441,7 +1527,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n-        let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n+        let closure_kind_ty = self.shallow_resolve_type(&closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n@@ -1455,7 +1541,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n-        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+        let closure_sig_ty = self.shallow_resolve_type(&closure_sig_ty);\n         closure_sig_ty.fn_sig(self.tcx)\n     }\n "}]}