{"sha": "def755edab084e971394e9d9ba929e205e9a1baa", "node_id": "C_kwDOAAsO6NoAKGRlZjc1NWVkYWIwODRlOTcxMzk0ZTlkOWJhOTI5ZTIwNWU5YTFiYWE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-22T17:48:31Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-22T17:49:00Z"}, "message": "Clean middle RPITITs correctly in rustdoc", "tree": {"sha": "885792e8c005f6df254232349b95a376cc698083", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/885792e8c005f6df254232349b95a376cc698083"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/def755edab084e971394e9d9ba929e205e9a1baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/def755edab084e971394e9d9ba929e205e9a1baa", "html_url": "https://github.com/rust-lang/rust/commit/def755edab084e971394e9d9ba929e205e9a1baa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/def755edab084e971394e9d9ba929e205e9a1baa/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "289b2b8cf971b1adf132cb5b7f15368837c5e353", "url": "https://api.github.com/repos/rust-lang/rust/commits/289b2b8cf971b1adf132cb5b7f15368837c5e353", "html_url": "https://github.com/rust-lang/rust/commit/289b2b8cf971b1adf132cb5b7f15368837c5e353"}], "stats": {"total": 147, "additions": 94, "deletions": 53}, "files": [{"sha": "6947e8e8e25aa18f0d4862cd26598cf9237b1e71", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/def755edab084e971394e9d9ba929e205e9a1baa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def755edab084e971394e9d9ba929e205e9a1baa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=def755edab084e971394e9d9ba929e205e9a1baa", "patch": "@@ -415,6 +415,16 @@ fn clean_projection<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n+    if cx.tcx.def_kind(ty.item_def_id) == DefKind::ImplTraitPlaceholder {\n+        let bounds = cx\n+            .tcx\n+            .explicit_item_bounds(ty.item_def_id)\n+            .iter()\n+            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.substs))\n+            .collect::<Vec<_>>();\n+        return clean_middle_opaque_bounds(cx, bounds);\n+    }\n+\n     let trait_ = clean_trait_ref_with_bindings(cx, ty.trait_ref(cx.tcx), ThinVec::new());\n     let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n@@ -1715,59 +1725,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 .iter()\n                 .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n                 .collect::<Vec<_>>();\n-            let mut regions = vec![];\n-            let mut has_sized = false;\n-            let mut bounds = bounds\n-                .iter()\n-                .filter_map(|bound| {\n-                    let bound_predicate = bound.kind();\n-                    let trait_ref = match bound_predicate.skip_binder() {\n-                        ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                            if let Some(r) = clean_middle_region(reg) {\n-                                regions.push(GenericBound::Outlives(r));\n-                            }\n-                            return None;\n-                        }\n-                        _ => return None,\n-                    };\n-\n-                    if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                        if trait_ref.def_id() == sized {\n-                            has_sized = true;\n-                            return None;\n-                        }\n-                    }\n-\n-                    let bindings: ThinVec<_> = bounds\n-                        .iter()\n-                        .filter_map(|bound| {\n-                            if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder()\n-                            {\n-                                if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n-                                    Some(TypeBinding {\n-                                        assoc: projection_to_path_segment(proj.projection_ty, cx),\n-                                        kind: TypeBindingKind::Equality {\n-                                            term: clean_middle_term(proj.term, cx),\n-                                        },\n-                                    })\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .collect();\n-\n-                    Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n-                })\n-                .collect::<Vec<_>>();\n-            bounds.extend(regions);\n-            if !has_sized && !bounds.is_empty() {\n-                bounds.insert(0, GenericBound::maybe_sized(cx));\n-            }\n-            ImplTrait(bounds)\n+            clean_middle_opaque_bounds(cx, bounds)\n         }\n \n         ty::Closure(..) => panic!(\"Closure\"),\n@@ -1780,6 +1738,64 @@ pub(crate) fn clean_middle_ty<'tcx>(\n     }\n }\n \n+fn clean_middle_opaque_bounds<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    bounds: Vec<ty::Predicate<'tcx>>,\n+) -> Type {\n+    let mut regions = vec![];\n+    let mut has_sized = false;\n+    let mut bounds = bounds\n+        .iter()\n+        .filter_map(|bound| {\n+            let bound_predicate = bound.kind();\n+            let trait_ref = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                    if let Some(r) = clean_middle_region(reg) {\n+                        regions.push(GenericBound::Outlives(r));\n+                    }\n+                    return None;\n+                }\n+                _ => return None,\n+            };\n+\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n+                if trait_ref.def_id() == sized {\n+                    has_sized = true;\n+                    return None;\n+                }\n+            }\n+\n+            let bindings: ThinVec<_> = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder() {\n+                        if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n+                            Some(TypeBinding {\n+                                assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                kind: TypeBindingKind::Equality {\n+                                    term: clean_middle_term(proj.term, cx),\n+                                },\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+\n+            Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n+        })\n+        .collect::<Vec<_>>();\n+    bounds.extend(regions);\n+    if !has_sized && !bounds.is_empty() {\n+        bounds.insert(0, GenericBound::maybe_sized(cx));\n+    }\n+    ImplTrait(bounds)\n+}\n+\n pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let def_id = cx.tcx.hir().local_def_id(field.hir_id).to_def_id();\n     clean_field_with_def_id(def_id, field.ident.name, clean_ty(field.ty, cx), cx)"}, {"sha": "a473e467473eb3fc4ea89f6661a4673b569b9d81", "filename": "src/test/rustdoc/async-trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/def755edab084e971394e9d9ba929e205e9a1baa/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def755edab084e971394e9d9ba929e205e9a1baa/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-trait.rs?ref=def755edab084e971394e9d9ba929e205e9a1baa", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:async-trait-dep.rs\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+extern crate async_trait_dep;\n+\n+pub struct Oink {}\n+\n+// @has 'async_trait/struct.Oink.html' '//h4[@class=\"code-header\"]' \"async fn woof()\"\n+impl async_trait_dep::Meow for Oink {\n+    async fn woof() {\n+        todo!()\n+    }\n+}"}, {"sha": "10a55dd0260efaf2fddf675c92ce12cd5e27b75b", "filename": "src/test/rustdoc/auxiliary/async-trait-dep.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/def755edab084e971394e9d9ba929e205e9a1baa/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def755edab084e971394e9d9ba929e205e9a1baa/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs?ref=def755edab084e971394e9d9ba929e205e9a1baa", "patch": "@@ -0,0 +1,9 @@\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+pub trait Meow {\n+    /// Who's a good dog?\n+    async fn woof();\n+}"}]}