{"sha": "e6efb24f3fa47462a3febd052e5ccc21e2c3ec63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZWZiMjRmM2ZhNDc0NjJhM2ZlYmQwNTJlNWNjYzIxZTJjM2VjNjM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-23T23:27:44Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-24T00:09:16Z"}, "message": "Add task::task_builder interface for improved spawning (related #2585)", "tree": {"sha": "205f7c9dd961b2bf85d20ce094f6d1878d853325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/205f7c9dd961b2bf85d20ce094f6d1878d853325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63", "html_url": "https://github.com/rust-lang/rust/commit/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7680f504c2c9934a617ff20b1d852ea191c6bc52", "url": "https://api.github.com/repos/rust-lang/rust/commits/7680f504c2c9934a617ff20b1d852ea191c6bc52", "html_url": "https://github.com/rust-lang/rust/commit/7680f504c2c9934a617ff20b1d852ea191c6bc52"}], "stats": {"total": 298, "additions": 220, "deletions": 78}, "files": [{"sha": "288f52919ac6ba97f30dda9140db33995c04a509", "filename": "src/libcore/task.rs", "status": "modified", "additions": 220, "deletions": 78, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6efb24f3fa47462a3febd052e5ccc21e2c3ec63/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e6efb24f3fa47462a3febd052e5ccc21e2c3ec63", "patch": "@@ -35,6 +35,7 @@ export sched_mode;\n export sched_opts;\n export task_opts;\n export builder;\n+export task_builder;\n \n export default_task_opts;\n export get_opts;\n@@ -46,7 +47,6 @@ export run;\n export future_result;\n export future_task;\n export unsupervise;\n-export parent;\n export run_listener;\n export run_with;\n \n@@ -77,7 +77,7 @@ export osmain;\n /* Data types */\n \n /// A handle to a task\n-enum task = task_id;\n+enum task { task_handle(task_id) }\n \n /**\n  * Indicates the manner in which a task exited.\n@@ -192,6 +192,141 @@ enum builder {\n     })\n }\n \n+class dummy { let x: (); new() { self.x = (); } drop { } }\n+\n+// FIXME (#2585): Replace the 'consumed' bit with move mode on self\n+enum task_builder = {\n+    opts: task_opts,\n+    gen_body: fn@(+fn~()) -> fn~(),\n+    can_not_copy: option<dummy>,\n+    mut consumed: bool,\n+};\n+\n+/**\n+ * Generate the base configuration for spawning a task, off of which more\n+ * configuration methods can be chained.\n+ * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n+ */\n+fn task() -> task_builder {\n+    task_builder({\n+        opts: default_task_opts(),\n+        gen_body: |body| body, // Identity function\n+        can_not_copy: none,\n+        mut consumed: false,\n+    })\n+}\n+\n+impl private_methods for task_builder {\n+    fn consume() -> task_builder {\n+        if self.consumed {\n+            fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n+        }\n+        self.consumed = true;\n+        task_builder({ can_not_copy: none, mut consumed: false, with *self })\n+    }\n+}\n+\n+impl task_builder for task_builder {\n+    /**\n+     * Decouple the child task's failure from the parent's. If either fails,\n+     * the other will not be killed.\n+     */\n+    fn unlinked() -> task_builder {\n+        task_builder({\n+            opts: { linked: false with self.opts },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+    /**\n+     * Unidirectionally link the child task's failure with the parent's. The\n+     * child's failure will not kill the parent, but the parent's will kill\n+     * the child.\n+     */\n+    fn supervised() -> task_builder {\n+        task_builder({\n+            opts: { linked: false, parented: true with self.opts },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+    /**\n+     * Link the child task's and parent task's failures. If either fails, the\n+     * other will be killed.\n+     */\n+    fn linked() -> task_builder {\n+        task_builder({\n+            opts: { linked: true, parented: false with self.opts },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+\n+    /// Configure a future result notification for this task.\n+    fn future_result(blk: fn(-future::future<task_result>)) -> task_builder {\n+        // Construct the future and give it to the caller.\n+        let po = comm::port::<notification>();\n+        let ch = comm::chan(po);\n+\n+        blk(do future::from_fn {\n+            alt comm::recv(po) {\n+              exit(_, result) { result }\n+            }\n+        });\n+\n+        // Reconfigure self to use a notify channel.\n+        task_builder({\n+            opts: { notify_chan: some(ch) with self.opts },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+    /// Configure a custom scheduler mode for the task.\n+    fn sched_mode(mode: sched_mode) -> task_builder {\n+        task_builder({\n+            opts: { sched: some({ mode: mode, foreign_stack_size: none})\n+                    with self.opts },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+    fn add_wrapper(wrapper: fn@(+fn~()) -> fn~()) -> task_builder {\n+        let prev_gen_body = self.gen_body;\n+        task_builder({\n+            gen_body: |body| { wrapper(prev_gen_body(body)) },\n+            can_not_copy: none,\n+            with *self.consume()\n+        })\n+    }\n+\n+    /// Run the task.\n+    fn spawn(+f: fn~()) {\n+        let x = self.consume();\n+        spawn_raw(x.opts, x.gen_body(f));\n+    }\n+    /// Runs a task, while transfering ownership of one argument to the child.\n+    fn spawn_with<A: send>(+arg: A, +f: fn~(+A)) {\n+        let arg = ~mut some(arg);\n+        do self.spawn {\n+            let mut my_arg = none;\n+            my_arg <-> *arg;\n+            f(option::unwrap(my_arg))\n+        }\n+    }\n+    /// Runs a task with a listening port, returning the associated channel.\n+    fn spawn_listener<A: send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n+        let setup_po = comm::port();\n+        let setup_ch = comm::chan(setup_po);\n+        do self.spawn {\n+            let po = comm::port();\n+            let ch = comm::chan(po);\n+            comm::send(setup_ch, ch);\n+            f(po);\n+        }\n+        comm::recv(setup_po)\n+    }\n+}\n+\n \n /* Task construction */\n \n@@ -362,11 +497,6 @@ fn unsupervise(builder: builder) {\n     });\n }\n \n-fn parent(builder: builder) {\n-    //! Configures the new task to be killed if the parent group is killed.\n-    set_opts(builder, { parented: true with get_opts(builder) });\n-}\n-\n fn run_with<A:send>(-builder: builder,\n                     +arg: A,\n                     +f: fn~(+A)) {\n@@ -428,7 +558,7 @@ fn spawn(+f: fn~()) {\n      * This function is equivalent to `run(new_builder(), f)`.\n      */\n \n-    run(builder(), f);\n+    task().spawn(f)\n }\n \n fn spawn_unlinked(+f: fn~()) {\n@@ -437,9 +567,16 @@ fn spawn_unlinked(+f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    let b = builder();\n-    unsupervise(b);\n-    run(b, f);\n+    task().unlinked().spawn(f)\n+}\n+\n+fn spawn_supervised(+f: fn~()) {\n+    /*!\n+     * Creates a child task unlinked from the current one. If either this\n+     * task or the child task fails, the other will not be killed.\n+     */\n+\n+    task().supervised().spawn(f)\n }\n \n fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n@@ -453,7 +590,7 @@ fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n      * This function is equivalent to `run_with(builder(), arg, f)`.\n      */\n \n-    run_with(builder(), arg, f)\n+    task().spawn_with(arg, f)\n }\n \n fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n@@ -482,7 +619,7 @@ fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n      * This function is equivalent to `run_listener(builder(), f)`.\n      */\n \n-    run_listener(builder(), f)\n+    task().spawn_listener(f)\n }\n \n fn spawn_sched(mode: sched_mode, +f: fn~()) {\n@@ -499,9 +636,7 @@ fn spawn_sched(mode: sched_mode, +f: fn~()) {\n      * greater than zero.\n      */\n \n-    let mut builder = builder();\n-    set_sched_mode(builder, mode);\n-    run(builder, f);\n+    task().sched_mode(mode).spawn(f)\n }\n \n fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n@@ -518,13 +653,13 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n \n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let mut builder = builder();\n-    unsupervise(builder);\n-    let result = future_result(builder);\n-    do run(builder) {\n+\n+    let mut result = none;\n+\n+    do task().unlinked().future_result(|-r| { result = some(r); }).spawn {\n         comm::send(ch, f());\n     }\n-    alt future::get(result) {\n+    alt future::get(option::unwrap(result)) {\n       success { result::ok(comm::recv(po)) }\n       failure { result::err(()) }\n     }\n@@ -553,7 +688,7 @@ fn failing() -> bool {\n fn get_task() -> task {\n     //! Get a handle to the running task\n \n-    task(rustrt::get_task_id())\n+    task_handle(rustrt::get_task_id())\n }\n \n /**\n@@ -1161,6 +1296,16 @@ fn test_spawn_raw_unsupervise() {\n     }\n }\n \n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_cant_dup_task_builder() {\n+    let b = task().unlinked();\n+    do b.spawn { }\n+    // FIXME(#2585): For now, this is a -runtime- failure, because we haven't\n+    // got modes on self. When 2585 is fixed, this test should fail to compile\n+    // instead, and should go in tests/compile-fail.\n+    do b.spawn { } // b should have been consumed by the previous call\n+}\n+\n // The following 8 tests test the following 2^3 combinations:\n // {un,}linked {un,}supervised failure propagation {up,down}wards.\n \n@@ -1171,8 +1316,8 @@ fn test_spawn_raw_unsupervise() {\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    do task::spawn_unlinked {\n-        do task::spawn_unlinked {\n+    do spawn_unlinked {\n+        do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n             for iter::repeat(8192) { task::yield(); }\n             comm::send(ch, ()); // If killed first, grandparent hangs.\n@@ -1183,55 +1328,67 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    do task::spawn_unlinked { fail; }\n+    do spawn_unlinked { fail; }\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    let builder = task::builder();\n-    task::unsupervise(builder);\n-    task::parent(builder);\n-    do task::run(builder) { fail; }\n+    do spawn_supervised { fail; }\n     // Give child a chance to fail-but-not-kill-us.\n     for iter::repeat(8192) { task::yield(); }\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n-    let builder = task::builder();\n-    task::unsupervise(builder);\n-    task::parent(builder);\n-    do task::run(builder) { loop { task::yield(); } }\n+    do spawn_supervised { loop { task::yield(); } }\n     fail; // Shouldn't leave a child hanging around.\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     let po = comm::port::<()>();\n     let _ch = comm::chan(po);\n-    let builder = task::builder();\n-    task::parent(builder);\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n-    do task::run(builder) { fail; }\n+    // We have to cheat with opts - the interface doesn't support them because\n+    // they don't make sense (redundant with task().supervised()).\n+    let b0 = task();\n+    let b1 = task_builder({\n+        opts: { linked: true, parented: true with b0.opts },\n+        can_not_copy: none,\n+        with *b0\n+    });\n+    do b1.spawn { fail; }\n     comm::recv(po); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    let builder = task::builder();\n-    task::parent(builder);\n-    do task::run(builder) { loop { task::yield(); } }\n+    // We have to cheat with opts - the interface doesn't support them because\n+    // they don't make sense (redundant with task().supervised()).\n+    let b0 = task();\n+    let b1 = task_builder({\n+        opts: { linked: true, parented: true with b0.opts },\n+        can_not_copy: none,\n+        with *b0\n+    });\n+    do b1.spawn { loop { task::yield(); } }\n     fail; // *both* mechanisms would be wrong if this didn't kill the child...\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     let po = comm::port::<()>();\n     let _ch = comm::chan(po);\n     // Default options are to spawn linked & unsupervised.\n-    do task::spawn { fail; }\n+    do spawn { fail; }\n     comm::recv(po); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n     // Default options are to spawn linked & unsupervised.\n-    do task::spawn { loop { task::yield(); } }\n+    do spawn { loop { task::yield(); } }\n+    fail;\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n+    // Make sure the above test is the same as this one.\n+    do task().linked().spawn { loop { task::yield(); } }\n     fail;\n }\n \n@@ -1240,14 +1397,8 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n #[test] #[should_fail] // #[ignore(cfg(windows))]\n #[ignore] // FIXME (#1868) (bblum) make this work\n fn test_spawn_unlinked_sup_propagate_grandchild() {\n-    let builder = task::builder();\n-    task::unsupervise(builder);\n-    task::parent(builder);\n-    do task::run(builder) {\n-        let builder = task::builder();\n-        task::unsupervise(builder);\n-        task::parent(builder);\n-        do task::run(builder) {\n+    do spawn_supervised {\n+        do spawn_supervised {\n             loop { task::yield(); }\n         }\n     }\n@@ -1290,8 +1441,7 @@ fn test_spawn_raw_notify() {\n fn test_run_basic() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let buildr = builder();\n-    do run(buildr) {\n+    do task().spawn {\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -1301,30 +1451,29 @@ fn test_run_basic() {\n fn test_add_wrapper() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let buildr = builder();\n-    do add_wrapper(buildr) |body| {\n+    let b0 = task();\n+    let b1 = do b0.add_wrapper |body| {\n         fn~() {\n             body();\n             comm::send(ch, ());\n         }\n-    }\n-    do run(buildr) { }\n+    };\n+    do b1.spawn { }\n     comm::recv(po);\n }\n \n #[test]\n #[ignore(cfg(windows))]\n fn test_future_result() {\n-    let buildr = builder();\n-    let result = future_result(buildr);\n-    do run(buildr) { }\n-    assert future::get(result) == success;\n+    let mut result = none;\n+    do task().future_result(|-r| { result = some(r); }).spawn { }\n+    assert future::get(option::unwrap(result)) == success;\n \n-    let buildr = builder();\n-    let result = future_result(buildr);\n-    unsupervise(buildr);\n-    do run(buildr) { fail }\n-    assert future::get(result) == failure;\n+    result = none;\n+    do task().future_result(|-r| { result = some(r); }).unlinked().spawn {\n+        fail;\n+    }\n+    assert future::get(option::unwrap(result)) == failure;\n }\n \n #[test]\n@@ -1525,20 +1674,18 @@ fn test_avoid_copying_the_body_spawn_listener() {\n }\n \n #[test]\n-fn test_avoid_copying_the_body_run() {\n+fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        let buildr = builder();\n-        do run(buildr) {\n+        do task().spawn {\n             f();\n         }\n     }\n }\n \n #[test]\n-fn test_avoid_copying_the_body_run_listener() {\n+fn test_avoid_copying_the_body_spawn_listener() {\n     do avoid_copying_the_body |f| {\n-        let buildr = builder();\n-        run_listener(buildr, fn~(move f, _po: comm::port<int>) {\n+        task().spawn_listener(fn~(move f, _po: comm::port<int>) {\n             f();\n         });\n     }\n@@ -1565,24 +1712,19 @@ fn test_avoid_copying_the_body_future_task() {\n }\n \n #[test]\n-fn test_avoid_copying_the_body_unsupervise() {\n+fn test_avoid_copying_the_body_unlinked() {\n     do avoid_copying_the_body |f| {\n-        let buildr = builder();\n-        unsupervise(buildr);\n-        do run(buildr) {\n+        do spawn_unlinked {\n             f();\n         }\n     }\n }\n \n #[test]\n fn test_osmain() {\n-    let buildr = builder();\n-    set_sched_mode(buildr, osmain);\n-\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    do run(buildr) {\n+    do task().sched_mode(osmain).spawn {\n         comm::send(ch, ());\n     }\n     comm::recv(po);"}]}