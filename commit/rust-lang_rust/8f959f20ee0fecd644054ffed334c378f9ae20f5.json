{"sha": "8f959f20ee0fecd644054ffed334c378f9ae20f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOTU5ZjIwZWUwZmVjZDY0NDA1NGZmZWQzMzRjMzc4ZjlhZTIwZjU=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-11T13:21:12Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T15:18:42Z"}, "message": "Trait location draft", "tree": {"sha": "40bddb2a27e91cd7c634c63c6e647ea3854f408d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40bddb2a27e91cd7c634c63c6e647ea3854f408d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f959f20ee0fecd644054ffed334c378f9ae20f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f959f20ee0fecd644054ffed334c378f9ae20f5", "html_url": "https://github.com/rust-lang/rust/commit/8f959f20ee0fecd644054ffed334c378f9ae20f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f959f20ee0fecd644054ffed334c378f9ae20f5/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b6db7bbd416ae233df21e34311cd6efad1f57f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b6db7bbd416ae233df21e34311cd6efad1f57f8", "html_url": "https://github.com/rust-lang/rust/commit/9b6db7bbd416ae233df21e34311cd6efad1f57f8"}], "stats": {"total": 147, "additions": 127, "deletions": 20}, "files": [{"sha": "a9778fab776887c8215d72bab50c4627fd7b3c47", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8f959f20ee0fecd644054ffed334c378f9ae20f5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f959f20ee0fecd644054ffed334c378f9ae20f5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=8f959f20ee0fecd644054ffed334c378f9ae20f5", "patch": "@@ -5,7 +5,13 @@ use crate::{\n     assist_ctx::{Assist, AssistCtx},\n     insert_use_statement, AssistId,\n };\n-use hir::{db::HirDatabase, Adt, ModPath, Module, ModuleDef, PathResolution, SourceAnalyzer};\n+use ast::{FnDefOwner, ModuleItem, ModuleItemOwner};\n+use hir::{\n+    db::{DefDatabase, HirDatabase},\n+    Adt, AssocContainerId, Crate, Function, HasSource, InFile, ModPath, Module, ModuleDef,\n+    PathResolution, SourceAnalyzer, SourceBinder, Trait,\n+};\n+use rustc_hash::FxHashSet;\n use std::collections::BTreeSet;\n \n // Assist: auto_import\n@@ -135,21 +141,88 @@ impl ImportCandidate {\n         ImportsLocator::new(db)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n-            .filter_map(|module_def| match self {\n+            .map(|module_def| match self {\n                 ImportCandidate::TraitFunction(function_callee, _) => {\n-                    if let ModuleDef::Function(function) = module_def {\n-                        dbg!(function);\n-                        todo!()\n-                    } else {\n-                        None\n+                    let mut applicable_traits = Vec::new();\n+                    if let ModuleDef::Function(located_function) = module_def {\n+                        let trait_candidates = Self::get_trait_candidates(\n+                            db,\n+                            located_function,\n+                            module_with_name_to_import.krate(),\n+                        )\n+                        .into_iter()\n+                        .map(|trait_candidate| trait_candidate.into())\n+                        .collect();\n+\n+                        function_callee.ty(db).iterate_path_candidates(\n+                            db,\n+                            module_with_name_to_import.krate(),\n+                            &trait_candidates,\n+                            None,\n+                            |_, assoc| {\n+                                if let AssocContainerId::TraitId(trait_id) = assoc.container(db) {\n+                                    applicable_traits.push(\n+                                        module_with_name_to_import\n+                                            .find_use_path(db, ModuleDef::Trait(trait_id.into())),\n+                                    );\n+                                };\n+                                None::<()>\n+                            },\n+                        );\n                     }\n+                    applicable_traits\n                 }\n-                _ => module_with_name_to_import.find_use_path(db, module_def),\n+                _ => vec![module_with_name_to_import.find_use_path(db, module_def)],\n             })\n+            .flatten()\n+            .filter_map(std::convert::identity)\n             .filter(|use_path| !use_path.segments.is_empty())\n             .take(20)\n             .collect::<BTreeSet<_>>()\n     }\n+\n+    fn get_trait_candidates(\n+        db: &RootDatabase,\n+        called_function: Function,\n+        root_crate: Crate,\n+    ) -> FxHashSet<Trait> {\n+        let mut source_binder = SourceBinder::new(db);\n+        root_crate\n+            .dependencies(db)\n+            .into_iter()\n+            .map(|dependency| db.crate_def_map(dependency.krate.into()))\n+            .chain(std::iter::once(db.crate_def_map(root_crate.into())))\n+            .map(|crate_def_map| {\n+                crate_def_map\n+                    .modules\n+                    .iter()\n+                    .filter_map(|(_, module_data)| module_data.declaration_source(db))\n+                    .filter_map(|in_file_module| {\n+                        Some((in_file_module.file_id, in_file_module.value.item_list()?.items()))\n+                    })\n+                    .map(|(file_id, item_list)| {\n+                        let mut if_file_trait_defs = Vec::new();\n+                        for module_item in item_list {\n+                            if let ModuleItem::TraitDef(trait_def) = module_item {\n+                                if let Some(item_list) = trait_def.item_list() {\n+                                    if item_list\n+                                        .functions()\n+                                        .any(|fn_def| fn_def == called_function.source(db).value)\n+                                    {\n+                                        if_file_trait_defs.push(InFile::new(file_id, trait_def))\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if_file_trait_defs\n+                    })\n+                    .flatten()\n+                    .filter_map(|in_file_trait_def| source_binder.to_def(in_file_trait_def))\n+                    .collect::<FxHashSet<_>>()\n+            })\n+            .flatten()\n+            .collect()\n+    }\n }\n \n #[cfg(test)]\n@@ -452,7 +525,45 @@ mod tests {\n     }\n \n     #[test]\n-    #[ignore] // TODO kb\n+    fn not_applicable_for_imported_trait() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                    fn test_function();\n+                }\n+\n+                pub trait TestTrait2 {\n+                    fn test_method(&self);\n+                    fn test_function();\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+\n+                impl TestTrait2 for TestEnum {\n+                    fn test_method(&self) {}\n+                    fn test_function() {}\n+                }\n+\n+                impl TestTrait for TestEnum {\n+                    fn test_method(&self) {}\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::test_function<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n     fn trait_method() {\n         check_assist(\n             auto_import,"}, {"sha": "73158b8bd4cd654b7e6ca14abb33f7840df59ada", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f959f20ee0fecd644054ffed334c378f9ae20f5/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f959f20ee0fecd644054ffed334c378f9ae20f5/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=8f959f20ee0fecd644054ffed334c378f9ae20f5", "patch": "@@ -123,7 +123,7 @@ impl_froms!(\n );\n \n pub use hir_def::{\n-    attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocItemId, AssocItemLoc,\n+    attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocContainerId, AssocItemId,\n };\n use rustc_hash::FxHashSet;\n \n@@ -696,16 +696,12 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n-    pub fn container(self, db: &impl DefDatabase) -> AssocItemContainer {\n-        let container = match self {\n-            AssocItem::Function(it) => it.id.lookup(db).container,\n-            AssocItem::Const(it) => it.id.lookup(db).container,\n-            AssocItem::TypeAlias(it) => it.id.lookup(db).container,\n-        };\n-        match container {\n-            AssocContainerId::TraitId(id) => AssocItemContainer::Trait(id.into()),\n-            AssocContainerId::ImplId(id) => AssocItemContainer::ImplBlock(id.into()),\n-            AssocContainerId::ContainerId(_) => panic!(\"invalid AssocItem\"),\n+\n+    pub fn container(self, db: &impl DefDatabase) -> AssocContainerId {\n+        match self {\n+            AssocItem::Function(f) => f.id.lookup(db).container,\n+            AssocItem::Const(c) => c.id.lookup(db).container,\n+            AssocItem::TypeAlias(t) => t.id.lookup(db).container,\n         }\n     }\n }"}]}