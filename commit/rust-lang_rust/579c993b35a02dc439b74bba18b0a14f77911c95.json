{"sha": "579c993b35a02dc439b74bba18b0a14f77911c95", "node_id": "C_kwDOAAsO6NoAKDU3OWM5OTNiMzVhMDJkYzQzOWI3NGJiYTE4YjBhMTRmNzc5MTFjOTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T12:11:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T12:11:32Z"}, "message": "Auto merge of #104935 - matthiaskrgr:rollup-nuca86l, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #104121 (Refine `instruction_set` MIR inline rules)\n - #104675 (Unsupported query error now specifies if its unsupported for local or external crate)\n - #104839 (improve array_from_fn documenation)\n - #104880 ([llvm-wrapper] adapt for LLVM API change)\n - #104899 (rustdoc: remove no-op CSS `#help dt { display: block }`)\n - #104906 (Remove AscribeUserTypeCx)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "96295864ecfb4bc5263a954f91f8ac4e2e6b3adb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96295864ecfb4bc5263a954f91f8ac4e2e6b3adb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/579c993b35a02dc439b74bba18b0a14f77911c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/579c993b35a02dc439b74bba18b0a14f77911c95", "html_url": "https://github.com/rust-lang/rust/commit/579c993b35a02dc439b74bba18b0a14f77911c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/579c993b35a02dc439b74bba18b0a14f77911c95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8841bee954ecf0e6820c9990feb3a76cb04e7d96", "url": "https://api.github.com/repos/rust-lang/rust/commits/8841bee954ecf0e6820c9990feb3a76cb04e7d96", "html_url": "https://github.com/rust-lang/rust/commit/8841bee954ecf0e6820c9990feb3a76cb04e7d96"}, {"sha": "1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993", "html_url": "https://github.com/rust-lang/rust/commit/1fe18a5dad0efde1d4dd31afd49fc60f21d3f993"}], "stats": {"total": 278, "additions": 143, "deletions": 135}, "files": [{"sha": "7f4d63eed8bdf225c8e3ea7ea7d3a17a80f790ed", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -627,7 +627,11 @@ LLVMRustOptimize(\n   bool DebugPassManager = false;\n \n   PassInstrumentationCallbacks PIC;\n+#if LLVM_VERSION_LT(16, 0)\n   StandardInstrumentations SI(DebugPassManager);\n+#else\n+  StandardInstrumentations SI(TheModule->getContext(), DebugPassManager);\n+#endif\n   SI.registerCallbacks(PIC);\n \n   if (LlvmSelfProfiler){"}, {"sha": "afbc9eb0512beb11b387d53908ad0076bb54c49b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -276,13 +276,16 @@ macro_rules! define_callbacks {\n \n         impl Default for Providers {\n             fn default() -> Self {\n+                use crate::query::Key;\n+\n                 Providers {\n                     $($name: |_, key| bug!(\n-                        \"`tcx.{}({:?})` is not supported for external or local crate;\\n\n-                        hint: Queries can be either made to the local crate, or the external crate. This error means you tried to use it for one that's not supported (likely the local crate).\\n\n+                        \"`tcx.{}({:?})` is not supported for {} crate;\\n\n+                        hint: Queries can be either made to the local crate, or the external crate. This error means you tried to use it for one that's not supported.\\n\n                         If that's not the case, {} was likely never assigned to a provider function.\\n\",\n                         stringify!($name),\n                         key,\n+                        if key.query_crate_is_local() { \"local\" } else { \"external\" },\n                         stringify!($name),\n                     ),)*\n                 }"}, {"sha": "9174f04887e4229aa9f7596b7c101df5298148d8", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -375,7 +375,12 @@ impl<'tcx> Inliner<'tcx> {\n             return Err(\"incompatible sanitizer set\");\n         }\n \n-        if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set {\n+        // Two functions are compatible if the callee has no attribute (meaning\n+        // that it's codegen agnostic), or sets an attribute that is identical\n+        // to this function's attribute.\n+        if callee_attrs.instruction_set.is_some()\n+            && callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set\n+        {\n             return Err(\"incompatible instruction set\");\n         }\n \n@@ -453,6 +458,15 @@ impl<'tcx> Inliner<'tcx> {\n                 if ty.needs_drop(tcx, self.param_env) && let Some(unwind) = unwind {\n                         work_list.push(unwind);\n                     }\n+            } else if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set\n+                && matches!(term.kind, TerminatorKind::InlineAsm { .. })\n+            {\n+                // During the attribute checking stage we allow a callee with no\n+                // instruction_set assigned to count as compatible with a function that does\n+                // assign one. However, during this stage we require an exact match when any\n+                // inline-asm is detected. LLVM will still possibly do an inline later on\n+                // if the no-attribute function ends up with the same instruction set anyway.\n+                return Err(\"Cannot move inline-asm across instruction sets\");\n             } else {\n                 work_list.extend(term.successors())\n             }"}, {"sha": "d426a2b6b78a0655220e6785f4b390a87f0d4b05", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -20,6 +20,7 @@ extern crate rustc_middle;\n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n+use rustc_middle::query::Key;\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::TyCtxt;\n@@ -32,8 +33,6 @@ use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};\n \n-use rustc_middle::query::Key;\n-\n pub use rustc_query_system::query::QueryConfig;\n pub(crate) use rustc_query_system::query::QueryVTable;\n "}, {"sha": "c6c072ea3d2bdb0e5c249a022914d22d14d36939", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 50, "deletions": 107, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -1,6 +1,4 @@\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCauseCode;\n@@ -57,122 +55,67 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n-    Ok(())\n-}\n+    let span = span.unwrap_or(DUMMY_SP);\n \n-struct AscribeUserTypeCx<'me, 'tcx> {\n-    ocx: &'me ObligationCtxt<'me, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-}\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n+    let cause = ObligationCause::dummy_with_span(span);\n \n-impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n-    }\n+    let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(cause.clone(), param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.ocx.normalize(cause, self.param_env, value)\n-    }\n+    ocx.eq(&cause, param_env, mir_ty, ty)?;\n \n-    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n-    where\n-        T: ToTrace<'tcx>,\n-    {\n-        Ok(self.ocx.eq(&ObligationCause::dummy_with_span(self.span), self.param_env, a, b)?)\n-    }\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n-    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.ocx.register_obligation(Obligation::new(\n-            self.ocx.infcx.tcx,\n-            cause,\n-            self.param_env,\n-            predicate,\n-        ));\n-    }\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in\n+        zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+    {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            hir::CRATE_HIR_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(cause.clone(), param_env, instantiated_predicate);\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.ocx.infcx.tcx\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n-    fn relate_mir_and_user_ty(\n-        &self,\n-        mir_ty: Ty<'tcx>,\n-        def_id: DefId,\n-        user_substs: UserSubsts<'tcx>,\n-    ) -> Result<(), NoSolution> {\n-        let UserSubsts { user_self_ty, substs } = user_substs;\n-        let tcx = self.tcx();\n-\n-        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n-        let ty = self.normalize(ty);\n-        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-        self.eq(mir_ty, ty)?;\n-\n-        // Prove the predicates coming along with `def_id`.\n-        //\n-        // Also, normalize the `instantiated_predicates`\n-        // because otherwise we wind up with duplicate \"type\n-        // outlives\" error messages.\n-        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-        let cause = ObligationCause::dummy_with_span(self.span);\n-\n-        debug!(?instantiated_predicates);\n-        for (instantiated_predicate, predicate_span) in\n-            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n-        {\n-            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n-            let cause = ObligationCause::new(\n-                span,\n-                hir::CRATE_HIR_ID,\n-                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-            );\n-            let instantiated_predicate =\n-                self.normalize_with_cause(instantiated_predicate, cause.clone());\n-            self.prove_predicate(instantiated_predicate, cause);\n-        }\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = ocx.normalize(cause.clone(), param_env, impl_self_ty);\n \n-        if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n-            let impl_self_ty = self.normalize(impl_self_ty);\n+        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n \n-            self.eq(self_ty, impl_self_ty)?;\n-\n-            self.prove_predicate(\n-                ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(tcx),\n-                cause.clone(),\n-            );\n-        }\n-\n-        // In addition to proving the predicates, we have to\n-        // prove that `ty` is well-formed -- this is because\n-        // the WF of `ty` is predicated on the substs being\n-        // well-formed, and we haven't proven *that*. We don't\n-        // want to prove the WF of types from  `substs` directly because they\n-        // haven't been normalized.\n-        //\n-        // FIXME(nmatsakis): Well, perhaps we should normalize\n-        // them?  This would only be relevant if some input\n-        // type were ill-formed but did not appear in `ty`,\n-        // which...could happen with normalization...\n-        self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n-            cause,\n-        );\n-        Ok(())\n+        let predicate: Predicate<'tcx> =\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into())).to_predicate(tcx);\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate: Predicate<'tcx> =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n }\n \n fn type_op_eq<'tcx>("}, {"sha": "94a1a1d32bcd66d7327c2a2a1142774cdcd33973", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -23,7 +23,8 @@ mod iter;\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n pub use iter::IntoIter;\n \n-/// Creates an array `[T; N]` where each array element `T` is returned by the `cb` call.\n+/// Creates an array of type [T; N], where each element `T` is the returned value from `cb`\n+/// using that element's index.\n ///\n /// # Arguments\n ///\n@@ -36,8 +37,18 @@ pub use iter::IntoIter;\n /// // elements to produce is the length of array down there: only arrays of\n /// // equal lengths can be compared, so the const generic parameter `N` is\n /// // inferred to be 5, thus creating array of 5 elements.\n+///\n /// let array = core::array::from_fn(|i| i);\n+/// // indexes are:    0  1  2  3  4\n /// assert_eq!(array, [0, 1, 2, 3, 4]);\n+///\n+/// let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n+/// // indexes are:     0  1  2  3  4  5   6   7\n+/// assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n+///\n+/// let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n+/// // indexes are:       0     1      2     3      4\n+/// assert_eq!(bool_arr, [true, false, true, false, true]);\n /// ```\n #[inline]\n #[stable(feature = \"array_from_fn\", since = \"1.63.0\")]"}, {"sha": "586462c0ef08e2b3693c4aee516551a042a929da", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -949,7 +949,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n #help dt {\n \tfloat: left;\n \tclear: left;\n-\tdisplay: block;\n \tmargin-right: 0.5rem;\n }\n #help span.top, #help span.bottom {"}, {"sha": "f1988ea4bd678f785b4035b2bfb86f0089c0cc31", "filename": "src/test/mir-opt/inline/inline_instruction_set.default.Inline.diff", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -6,14 +6,19 @@\n       let _1: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n       let _2: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n       let _3: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n-+     scope 1 (inlined instruction_set_default) { // at $DIR/inline_instruction_set.rs:53:5: 53:30\n+      let _4: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n++     scope 1 (inlined instruction_set_default) { // at $DIR/inline_instruction_set.rs:59:5: 59:30\n++     }\n++     scope 2 (inlined inline_always_and_using_inline_asm) { // at $DIR/inline_instruction_set.rs:60:5: 60:41\n++         scope 3 {\n++         }\n +     }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n           _1 = instruction_set_a32() -> bb1; // scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n                                            // mir::Constant\n-                                           // + span: $DIR/inline_instruction_set.rs:51:5: 51:24\n+                                           // + span: $DIR/inline_instruction_set.rs:57:5: 57:24\n                                            // + literal: Const { ty: fn() {instruction_set_a32}, val: Value(<ZST>) }\n       }\n   \n@@ -22,7 +27,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n           _2 = instruction_set_t32() -> bb2; // scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n                                            // mir::Constant\n-                                           // + span: $DIR/inline_instruction_set.rs:52:5: 52:24\n+                                           // + span: $DIR/inline_instruction_set.rs:58:5: 58:24\n                                            // + literal: Const { ty: fn() {instruction_set_t32}, val: Value(<ZST>) }\n       }\n   \n@@ -31,14 +36,25 @@\n           StorageLive(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n -         _3 = instruction_set_default() -> bb3; // scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n -                                          // mir::Constant\n--                                          // + span: $DIR/inline_instruction_set.rs:53:5: 53:28\n+-                                          // + span: $DIR/inline_instruction_set.rs:59:5: 59:28\n -                                          // + literal: Const { ty: fn() {instruction_set_default}, val: Value(<ZST>) }\n -     }\n - \n -     bb3: {\n           StorageDead(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+3:30: +3:31\n-          _0 = const ();                   // scope 0 at $DIR/inline_instruction_set.rs:+0:18: +4:2\n-          return;                          // scope 0 at $DIR/inline_instruction_set.rs:+4:2: +4:2\n+          StorageLive(_4);                 // scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n+-         _4 = inline_always_and_using_inline_asm() -> bb4; // scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline_instruction_set.rs:60:5: 60:39\n+-                                          // + literal: Const { ty: fn() {inline_always_and_using_inline_asm}, val: Value(<ZST>) }\n++         asm!(\"/* do nothing */\", options((empty))) -> bb3; // scope 3 at $DIR/inline_instruction_set.rs:43:14: 43:38\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageDead(_4);                 // scope 0 at $DIR/inline_instruction_set.rs:+4:41: +4:42\n+          _0 = const ();                   // scope 0 at $DIR/inline_instruction_set.rs:+0:18: +5:2\n+          return;                          // scope 0 at $DIR/inline_instruction_set.rs:+5:2: +5:2\n       }\n   }\n   "}, {"sha": "5dfb04943e39f1051ccfb22533d39798c5c120c0", "filename": "src/test/mir-opt/inline/inline_instruction_set.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.rs?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -1,5 +1,7 @@\n // Checks that only functions with the compatible instruction_set attributes are inlined.\n //\n+// A function is \"compatible\" when the *callee* has the same attribute or no attribute.\n+//\n // compile-flags: --target thumbv4t-none-eabi\n // needs-llvm-components: arm\n \n@@ -36,19 +38,24 @@ fn instruction_set_t32() {}\n #[inline]\n fn instruction_set_default() {}\n \n+#[inline(always)]\n+fn inline_always_and_using_inline_asm() {\n+    unsafe { asm!(\"/* do nothing */\") };\n+}\n+\n // EMIT_MIR inline_instruction_set.t32.Inline.diff\n #[instruction_set(arm::t32)]\n pub fn t32() {\n     instruction_set_a32();\n     instruction_set_t32();\n-    // The default instruction set is currently\n-    // conservatively assumed to be incompatible.\n     instruction_set_default();\n+    inline_always_and_using_inline_asm();\n }\n \n // EMIT_MIR inline_instruction_set.default.Inline.diff\n pub fn default() {\n     instruction_set_a32();\n     instruction_set_t32();\n     instruction_set_default();\n+    inline_always_and_using_inline_asm();\n }"}, {"sha": "e777b2cc29eb36ff4c8dbd791065517b53da703a", "filename": "src/test/mir-opt/inline/inline_instruction_set.t32.Inline.diff", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/579c993b35a02dc439b74bba18b0a14f77911c95/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff?ref=579c993b35a02dc439b74bba18b0a14f77911c95", "patch": "@@ -5,15 +5,18 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline_instruction_set.rs:+0:14: +0:14\n       let _1: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n       let _2: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n-      let _3: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+5:5: +5:30\n-+     scope 1 (inlined instruction_set_t32) { // at $DIR/inline_instruction_set.rs:43:5: 43:26\n+      let _3: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n+      let _4: ();                          // in scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n++     scope 1 (inlined instruction_set_t32) { // at $DIR/inline_instruction_set.rs:50:5: 50:26\n++     }\n++     scope 2 (inlined instruction_set_default) { // at $DIR/inline_instruction_set.rs:51:5: 51:30\n +     }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n           _1 = instruction_set_a32() -> bb1; // scope 0 at $DIR/inline_instruction_set.rs:+1:5: +1:26\n                                            // mir::Constant\n-                                           // + span: $DIR/inline_instruction_set.rs:42:5: 42:24\n+                                           // + span: $DIR/inline_instruction_set.rs:49:5: 49:24\n                                            // + literal: Const { ty: fn() {instruction_set_a32}, val: Value(<ZST>) }\n       }\n   \n@@ -22,25 +25,34 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n -         _2 = instruction_set_t32() -> bb2; // scope 0 at $DIR/inline_instruction_set.rs:+2:5: +2:26\n -                                          // mir::Constant\n--                                          // + span: $DIR/inline_instruction_set.rs:43:5: 43:24\n+-                                          // + span: $DIR/inline_instruction_set.rs:50:5: 50:24\n -                                          // + literal: Const { ty: fn() {instruction_set_t32}, val: Value(<ZST>) }\n -     }\n - \n -     bb2: {\n           StorageDead(_2);                 // scope 0 at $DIR/inline_instruction_set.rs:+2:26: +2:27\n-          StorageLive(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+5:5: +5:30\n--         _3 = instruction_set_default() -> bb3; // scope 0 at $DIR/inline_instruction_set.rs:+5:5: +5:30\n-+         _3 = instruction_set_default() -> bb2; // scope 0 at $DIR/inline_instruction_set.rs:+5:5: +5:30\n+          StorageLive(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n+-         _3 = instruction_set_default() -> bb3; // scope 0 at $DIR/inline_instruction_set.rs:+3:5: +3:30\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline_instruction_set.rs:51:5: 51:28\n+-                                          // + literal: Const { ty: fn() {instruction_set_default}, val: Value(<ZST>) }\n+-     }\n+- \n+-     bb3: {\n+          StorageDead(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+3:30: +3:31\n+          StorageLive(_4);                 // scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n+-         _4 = inline_always_and_using_inline_asm() -> bb4; // scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n++         _4 = inline_always_and_using_inline_asm() -> bb2; // scope 0 at $DIR/inline_instruction_set.rs:+4:5: +4:41\n                                            // mir::Constant\n-                                           // + span: $DIR/inline_instruction_set.rs:46:5: 46:28\n-                                           // + literal: Const { ty: fn() {instruction_set_default}, val: Value(<ZST>) }\n+                                           // + span: $DIR/inline_instruction_set.rs:52:5: 52:39\n+                                           // + literal: Const { ty: fn() {inline_always_and_using_inline_asm}, val: Value(<ZST>) }\n       }\n   \n--     bb3: {\n+-     bb4: {\n +     bb2: {\n-          StorageDead(_3);                 // scope 0 at $DIR/inline_instruction_set.rs:+5:30: +5:31\n-          _0 = const ();                   // scope 0 at $DIR/inline_instruction_set.rs:+0:14: +6:2\n-          return;                          // scope 0 at $DIR/inline_instruction_set.rs:+6:2: +6:2\n+          StorageDead(_4);                 // scope 0 at $DIR/inline_instruction_set.rs:+4:41: +4:42\n+          _0 = const ();                   // scope 0 at $DIR/inline_instruction_set.rs:+0:14: +5:2\n+          return;                          // scope 0 at $DIR/inline_instruction_set.rs:+5:2: +5:2\n       }\n   }\n   "}]}