{"sha": "e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5OTllN2I4YjJlMzVhNDk1ZDZiOTYzMGFiOTg3YzA3MDNjNmFiNDg=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-10-15T19:37:09Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-07T19:13:19Z"}, "message": "Extract (f32::MAX + 0.5 ULP) constant", "tree": {"sha": "06b54716db8a56a305e9a83f20fb2e21ef3022f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06b54716db8a56a305e9a83f20fb2e21ef3022f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "html_url": "https://github.com/rust-lang/rust/commit/e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/comments", "author": null, "committer": null, "parents": [{"sha": "964ba2a6e731f79d99248d1f0e67eac17e69e368", "url": "https://api.github.com/repos/rust-lang/rust/commits/964ba2a6e731f79d99248d1f0e67eac17e69e368", "html_url": "https://github.com/rust-lang/rust/commit/964ba2a6e731f79d99248d1f0e67eac17e69e368"}], "stats": {"total": 21, "additions": 15, "deletions": 6}, "files": [{"sha": "9d820ea8cbed2990e91ab163aee9416840f8e8b1", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "patch": "@@ -203,3 +203,11 @@ impl ::std::ops::Neg for ConstFloat {\n         ConstFloat { bits, ty: self.ty }\n     }\n }\n+\n+/// This is `f32::MAX + (0.5 ULP)` as an integer. Numbers greater or equal to this\n+/// are rounded to infinity when converted to `f32`.\n+///\n+/// NB: Computed as maximum significand with an extra 1 bit added (for the half ULP)\n+/// shifted by the maximum exponent (accounting for normalization).\n+pub const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n+                                        << (Single::MAX_EXP - Single::PRECISION as i16);"}, {"sha": "6b2342e493321a2c837a0eb2e26386bd61270947", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n-use rustc_const_math::{ConstInt, ConstMathErr};\n+use rustc_const_math::{ConstInt, ConstMathErr, MAX_F32_PLUS_HALF_ULP};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::traits;\n@@ -986,10 +986,10 @@ unsafe fn const_cast_int_to_float(ccx: &CrateContext,\n         panic!(\"could not get z128 value of constant integer {:?}\",\n                Value(llval));\n     });\n-    // If this is an u128 cast and the value is > f32::MAX + 0.5 ULP, round up to infinity.\n     if signed {\n         llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n-    } else if value >= 0xffffff80000000000000000000000000_u128 && float_ty.float_width() == 32 {\n+    } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n+        // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n         let infinity_bits = C_u32(ccx, ieee::Single::INFINITY.to_bits() as u32);\n         consts::bitcast(infinity_bits, float_ty)\n     } else {"}, {"sha": "d16b2048c3fba4242825e4339ef21d63fd4a4b12", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e999e7b8b2e35a495d6b9630ab987c0703c6ab48/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n+use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n use std::{u128, i128};\n \n use base;\n@@ -827,9 +828,9 @@ fn cast_int_to_float(bcx: &Builder,\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n     let is_u128_to_f32 = !signed && int_ty.int_width() == 128 && float_ty.float_width() == 32;\n     if is_u128_to_f32 && bcx.sess().opts.debugging_opts.saturating_float_casts {\n-        // f32::MAX + 0.5 ULP as u128. All inputs greater or equal to this should be\n-        // rounded to infinity, for everything else LLVM's uitofp works just fine.\n-        let max = C_big_integral(int_ty, 0xffffff80000000000000000000000000_u128);\n+        // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n+        // and for everything else LLVM's uitofp works just fine.\n+        let max = C_big_integral(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bcx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);"}]}