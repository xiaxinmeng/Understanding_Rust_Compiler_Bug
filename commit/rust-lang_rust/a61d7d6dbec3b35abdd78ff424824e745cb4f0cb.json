{"sha": "a61d7d6dbec3b35abdd78ff424824e745cb4f0cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MWQ3ZDZkYmVjM2IzNWFiZGQ3OGZmNDI0ODI0ZTc0NWNiNGYwY2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-07T19:37:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-08T01:01:06Z"}, "message": "doc: Syntax highlight the cheatsheet", "tree": {"sha": "775b1ca036af630961bba79fa57eff1c67819b6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/775b1ca036af630961bba79fa57eff1c67819b6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb", "html_url": "https://github.com/rust-lang/rust/commit/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1839bd693176f03f372fb34baa7b19b5030af7", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1839bd693176f03f372fb34baa7b19b5030af7", "html_url": "https://github.com/rust-lang/rust/commit/aa1839bd693176f03f372fb34baa7b19b5030af7"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "2b8698f22e593c2b592b49055f96444d3ba8fc07", "filename": "doc/complement-cheatsheet.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb/doc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/a61d7d6dbec3b35abdd78ff424824e745cb4f0cb/doc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcomplement-cheatsheet.md?ref=a61d7d6dbec3b35abdd78ff424824e745cb4f0cb", "patch": "@@ -6,113 +6,113 @@\n \n Use [`ToStr`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToStr.html).\n \n-```rust\n+~~~\n let x: int = 42;\n let y: ~str = x.to_str();\n-```\n+~~~\n \n **String to int**\n \n Use [`FromStr`](http://static.rust-lang.org/doc/master/std/from_str/trait.FromStr.html), and its helper function, [`from_str`](http://static.rust-lang.org/doc/master/std/from_str/fn.from_str.html).\n \n-```rust\n+~~~\n let x: Option<int> = from_str(\"42\");\n let y: int = x.unwrap();\n-```\n+~~~\n \n **Int to string, in non-base-10**\n \n Use [`ToStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.ToStrRadix.html).\n \n-```rust\n+~~~\n use std::num::ToStrRadix;\n \n let x: int = 42;\n let y: ~str = x.to_str_radix(16);\n-```\n+~~~\n \n **String to int, in non-base-10**\n \n Use [`FromStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.FromStrRadix.html), and its helper function, [`from_str_radix`](http://static.rust-lang.org/doc/master/std/num/fn.from_str_radix.html).\n \n-```rust\n+~~~\n use std::num::from_str_radix;\n \n let x: Option<int> = from_str_radix(\"deadbeef\", 16);\n let y: int = x.unwrap();\n-```\n+~~~\n \n # File operations\n \n ## How do I read from a file?\n \n Use [`File::open`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html#method.open) to create a [`File`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html) struct, which implements the [`Reader`](http://static.rust-lang.org/doc/master/std/io/trait.Reader.html) trait.\n \n-```rust\n+~~~\n use std::path::Path;\n use std::io::fs::File;\n \n let path : Path   = Path::new(\"Doc-FAQ-Cheatsheet.md\");\n let on_error      = || fail!(\"open of {:?} failed\", path);\n let reader : File = File::open(&path).unwrap_or_else(on_error);\n-```\n+~~~\n \n ## How do I iterate over the lines in a file?\n \n Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer.html#method.lines) method on a [`BufferedReader`](http://static.rust-lang.org/doc/master/std/io/buffered/struct.BufferedReader.html).\n \n-```rust\n+~~~\n use std::io::buffered::BufferedReader;\n \n let mut reader = BufferedReader::new(reader);\n for line in reader.lines() {\n     print!(\"line: {}\", line);\n }\n-```\n+~~~\n \n # String operations\n \n ## How do I search for a substring?\n \n Use the [`find_str`](http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html#tymethod.find_str) method.\n \n-```rust\n+~~~\n let str = \"Hello, this is some random string\";\n let index: Option<uint> = str.find_str(\"rand\");\n-```\n+~~~\n \n # Containers\n \n ## How do I get the length of a vector?\n \n The [`Container`](http://static.rust-lang.org/doc/master/std/container/trait.Container.html) trait provides the `len` method.\n \n-```rust\n+~~~\n let u: ~[u32] = ~[0, 1, 2];\n let v: &[u32] = &[0, 1, 2, 3];\n let w: [u32, .. 5] = [0, 1, 2, 3, 4];\n \n println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len()); // 3, 4, 5\n-```\n+~~~\n \n ## How do I iterate over a vector?\n \n Use the [`iter`](http://static.rust-lang.org/doc/master/std/vec/trait.ImmutableVector.html#tymethod.iter) method.\n \n-```rust\n+~~~\n let values: ~[int] = ~[1, 2, 3, 4, 5];\n for value in values.iter() {  // value: &int\n     println!(\"{}\", *value);\n }\n-```\n+~~~\n \n (See also [`mut_iter`](http://static.rust-lang.org/doc/master/std/vec/trait.MutableVector.html#tymethod.mut_iter) which yields `&mut int` and [`move_iter`](http://static.rust-lang.org/doc/master/std/vec/trait.OwnedVector.html#tymethod.move_iter) which yields `int` while consuming the `values` vector.)\n \n # Type system\n \n ## How do I store a function in a struct?\n \n-```rust\n+~~~\n struct Foo {\n     myfunc: fn(int, uint) -> i32\n }\n@@ -131,22 +131,22 @@ fn main() {\n     println!(\"{}\", (f.myfunc)(1, 2));\n     println!(\"{}\", (g.myfunc)(3, 4));\n }\n-```\n+~~~\n \n Note that the parenthesis surrounding `f.myfunc` are necessary: they are how Rust disambiguates field lookup and method call. The `'a` on `FooClosure` is the lifetime of the closure's environment pointer.\n \n ## How do I express phantom types?\n \n [Phantom types](http://www.haskell.org/haskellwiki/Phantom_type) are those that cannot be constructed at compile time. To express these in Rust, zero-variant `enum`s can be used:\n \n-```rust\n+~~~\n enum Open {}\n enum Closed {}\n-```\n+~~~\n \n Phantom types are useful for enforcing state at compile time. For example:\n \n-```rust\n+~~~\n struct Door<State>(~str);\n \n fn close(Door(name): Door<Open>) -> Door<Closed> {\n@@ -159,7 +159,7 @@ fn open(Door(name): Door<Closed>) -> Door<Open> {\n \n let _ = close(Door::<Open>(~\"front\"));   // ok\n let _ = close(Door::<Closed>(~\"front\")); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n-```\n+~~~\n \n # FFI (Foreign Function Interface)\n \n@@ -178,19 +178,19 @@ Note: The Rust signatures should be wrapped in an `extern \"ABI\" { ... }` block.\n \n You might see things like this in C APIs:\n \n-```c\n+~~~ {.notrust}\n typedef struct Window Window;\n Window* createWindow(int width, int height);\n-```\n+~~~\n \n You can use a zero-element `enum` ([phantom type](#how-do-i-express-phantom-types)) to represent the opaque object handle. The FFI would look like this:\n \n-```rust\n+~~~\n enum Window {}\n extern \"C\" {\n     fn createWindow(width: c_int, height: c_int) -> *Window;\n }\n-```\n+~~~\n \n Using a phantom type ensures that the handles cannot be (safely) constructed in client code.\n "}]}