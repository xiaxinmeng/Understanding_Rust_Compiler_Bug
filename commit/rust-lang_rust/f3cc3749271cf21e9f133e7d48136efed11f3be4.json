{"sha": "f3cc3749271cf21e9f133e7d48136efed11f3be4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzY2MzNzQ5MjcxY2YyMWU5ZjEzM2U3ZDQ4MTM2ZWZlZDExZjNiZTQ=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2016-08-24T06:50:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-01T18:04:14Z"}, "message": "introduce fn-ctxt so we can invoke regionck code", "tree": {"sha": "724766df973cac661291d92f5fdacd0090cc5686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/724766df973cac661291d92f5fdacd0090cc5686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3cc3749271cf21e9f133e7d48136efed11f3be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3cc3749271cf21e9f133e7d48136efed11f3be4", "html_url": "https://github.com/rust-lang/rust/commit/f3cc3749271cf21e9f133e7d48136efed11f3be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3cc3749271cf21e9f133e7d48136efed11f3be4/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "html_url": "https://github.com/rust-lang/rust/commit/ac968c466451cb9aafd9e8598ddb396ed0e6fe31"}], "stats": {"total": 143, "additions": 91, "deletions": 52}, "files": [{"sha": "0dc3cf7e46708c97be2e6382379358623087c44a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f3cc3749271cf21e9f133e7d48136efed11f3be4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n@@ -21,6 +20,7 @@ use syntax_pos::Span;\n \n use CrateCtxt;\n use super::assoc;\n+use super::{Inherited, FnCtxt};\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -313,9 +313,6 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return;\n     }\n \n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-\n         // Create obligations for each predicate declared by the impl\n         // definition in the context of the trait's parameter\n         // environment. We can't just use `impl_env.caller_bounds`,\n@@ -341,10 +338,14 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // the new hybrid bounds we computed.\n         let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n         let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n-        let trait_param_env =\n-            traits::normalize_param_env_or_error(tcx, trait_param_env, normalize_cause.clone());\n-        // FIXME(@jroesch) this seems ugly, but is a temporary change\n-        infcx.parameter_environment = trait_param_env;\n+        let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                                   trait_param_env,\n+                                                                   normalize_cause.clone());\n+\n+    tcx.infer_ctxt(None, Some(trait_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+        let inh = Inherited::new(ccx, infcx);\n+        let infcx = &inh.infcx;\n+        let fulfillment_cx = &inh.fulfillment_cx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n                infcx.parameter_environment.caller_bounds);\n@@ -365,7 +366,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 code: traits::ObligationCauseCode::CompareImplMethodObligation,\n             };\n \n-            fulfillment_cx.register_predicate_obligation(\n+            fulfillment_cx.borrow_mut().register_predicate_obligation(\n                 &infcx,\n                 traits::Obligation::new(cause, predicate));\n         }\n@@ -387,30 +388,36 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let tcx = infcx.tcx;\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n-        let (impl_sig, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                       infer::HigherRankedType,\n-                                                       &impl_m.fty.sig);\n-        let impl_sig = impl_sig.subst(tcx, impl_to_skol_substs);\n-        let impl_sig = assoc::normalize_associated_types_in(&infcx,\n-                                                            &mut fulfillment_cx,\n-                                                            impl_m_span,\n-                                                            impl_m_body_id,\n-                                                            &impl_sig);\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx.borrow_mut(),\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n             sig: ty::Binder(impl_sig.clone()),\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = tcx.liberate_late_bound_regions(infcx.parameter_environment.free_id_outlive,\n-                                         &trait_m.fty.sig);\n-        let trait_sig = trait_sig.subst(tcx, trait_to_skol_substs);\n-        let trait_sig = assoc::normalize_associated_types_in(&infcx,\n-                                                             &mut fulfillment_cx,\n-                                                             impl_m_span,\n-                                                             impl_m_body_id,\n-                                                             &trait_sig);\n+        let trait_sig = tcx.liberate_late_bound_regions(\n+            infcx.parameter_environment.free_id_outlive,\n+            &trait_m.fty.sig);\n+        let trait_sig =\n+            trait_sig.subst(tcx, trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx.borrow_mut(),\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n@@ -454,25 +461,15 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+        if let Err(ref errors) = fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n             return;\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters. We have to build up a plausible lifetime\n-        // environment based on what we find in the trait. We could also\n-        // include the obligations derived from the method argument types,\n-        // but I don't think it's necessary -- after all, those are still\n-        // in effect when type-checking the body, and all the\n-        // where-clauses in the header etc should be implied by the trait\n-        // anyway, so it shouldn't be needed there either. Anyway, we can\n-        // always add more relations later (it's backwards compat).\n-        let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(\n-            &infcx.parameter_environment.caller_bounds);\n-\n-        infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+        // lifetime parameters.\n+        let fcx = FnCtxt::new(&inh, tcx.types.err, impl_m_body_id);\n+        fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n     });\n \n     fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "ef127feb042b12ed9049e96458453f22be49552a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f3cc3749271cf21e9f133e7d48136efed11f3be4", "patch": "@@ -407,22 +407,26 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n         let ccx = self.ccx;\n-        self.infcx.enter(|infcx| {\n-            f(Inherited {\n-                ccx: ccx,\n-                infcx: infcx,\n-                fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n-                locals: RefCell::new(NodeMap()),\n-                deferred_call_resolutions: RefCell::new(DefIdMap()),\n-                deferred_cast_checks: RefCell::new(Vec::new()),\n-                anon_types: RefCell::new(DefIdMap()),\n-                deferred_obligations: RefCell::new(Vec::new()),\n-            })\n-        })\n+        self.infcx.enter(|infcx| f(Inherited::new(ccx, infcx)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+    pub fn new(ccx: &'a CrateCtxt<'a, 'gcx>,\n+               infcx: InferCtxt<'a, 'gcx, 'tcx>)\n+               -> Self {\n+        Inherited {\n+            ccx: ccx,\n+            infcx: infcx,\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            locals: RefCell::new(NodeMap()),\n+            deferred_call_resolutions: RefCell::new(DefIdMap()),\n+            deferred_cast_checks: RefCell::new(Vec::new()),\n+            anon_types: RefCell::new(DefIdMap()),\n+            deferred_obligations: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,"}, {"sha": "ea186055147ad28c284aa5d5b92221a2d1f8f471", "filename": "src/test/compile-fail/issue-18937.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3cc3749271cf21e9f133e7d48136efed11f3be4/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs?ref=f3cc3749271cf21e9f133e7d48136efed11f3be4", "patch": "@@ -0,0 +1,38 @@\n+use std::fmt;\n+\n+#[derive(Debug)]\n+struct MyString<'a>(&'a String);\n+\n+struct B {\n+    list: Vec<Box<fmt::Debug>>,\n+}\n+\n+trait A<'a> {\n+    fn foo<F>(&mut self, f: F)\n+        where F: fmt::Debug + 'a,\n+              Self: Sized;\n+}\n+\n+impl<'a> A<'a> for B {\n+    fn foo<F>(&mut self, f: F) //~ ERROR parameter type `F` may not live long enough\n+        where F: fmt::Debug + 'static,\n+    {\n+        self.list.push(Box::new(f));\n+    }\n+}\n+\n+fn main() {\n+    let mut b = B { list: Vec::new() };\n+\n+    // Create a borrowed pointer, put it in `b`, then drop what's borrowing it\n+    let a = \"hello\".to_string();\n+    b.foo(MyString(&a));\n+\n+    // Drop the data which `b` has a reference to\n+    drop(a);\n+\n+    // Use the data, probably segfaulting\n+    for b in b.list.iter() {\n+        println!(\"{:?}\", b);\n+    }\n+}"}]}