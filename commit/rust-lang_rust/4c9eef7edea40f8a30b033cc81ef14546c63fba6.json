{"sha": "4c9eef7edea40f8a30b033cc81ef14546c63fba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOWVlZjdlZGVhNDBmOGEzMGIwMzNjYzgxZWYxNDU0NmM2M2ZiYTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-15T16:36:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-15T16:36:33Z"}, "message": "Merge #10233\n\n10233: fix: add multi-token mapping support to hovers r=Veykril a=spookyvision\n\nimplement #10070 in [`hover`](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide/src/hover.rs)\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>", "tree": {"sha": "3aa0a0e4b5439c1213dc634050d285fbc4d4826c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3aa0a0e4b5439c1213dc634050d285fbc4d4826c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9eef7edea40f8a30b033cc81ef14546c63fba6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhQiESCRBK7hj4Ov3rIwAAY5oIAKsgGaIgnjvkEm7pcn9NRoh9\nwoSmaWMeqIgqVzeno1zu5UNBmErr15iu3Y1voCS7zyfI2E5i7ivmZQGj0ljea9GK\ntdoffSE8WNvZMeetTA1chAwoVl3ywKADgbR/LttId9nYTQ9pFxhOeOIXUX5cRReT\nmgohJM2HSZsaoHz2AKLfBNm8Gt5uwQ8IQe20uKvNWjYhGYvGGitAMLXblyUFrTVb\nU5U9/EmiYd91d+K45ISkpwU8omXtkNbgyNc5L5Nt7tcIn7dHRparhaZelFVRdgvl\nU903chWz2zxhZOyuSVilSw3JyLvtOZHBSV4URsK6v/saHOnypPIwsfLgyR4rd8U=\n=hx/9\n-----END PGP SIGNATURE-----\n", "payload": "tree 3aa0a0e4b5439c1213dc634050d285fbc4d4826c\nparent 67706cdbe062c7dcc5514a17b86e1e8b809bbcab\nparent 45090e4f4b685fbdd0bdb87e39820430ddc449a1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631723793 +0000\ncommitter GitHub <noreply@github.com> 1631723793 +0000\n\nMerge #10233\n\n10233: fix: add multi-token mapping support to hovers r=Veykril a=spookyvision\n\nimplement #10070 in [`hover`](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ide/src/hover.rs)\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9eef7edea40f8a30b033cc81ef14546c63fba6", "html_url": "https://github.com/rust-lang/rust/commit/4c9eef7edea40f8a30b033cc81ef14546c63fba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9eef7edea40f8a30b033cc81ef14546c63fba6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67706cdbe062c7dcc5514a17b86e1e8b809bbcab", "url": "https://api.github.com/repos/rust-lang/rust/commits/67706cdbe062c7dcc5514a17b86e1e8b809bbcab", "html_url": "https://github.com/rust-lang/rust/commit/67706cdbe062c7dcc5514a17b86e1e8b809bbcab"}, {"sha": "45090e4f4b685fbdd0bdb87e39820430ddc449a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/45090e4f4b685fbdd0bdb87e39820430ddc449a1", "html_url": "https://github.com/rust-lang/rust/commit/45090e4f4b685fbdd0bdb87e39820430ddc449a1"}], "stats": {"total": 196, "additions": 175, "deletions": 21}, "files": [{"sha": "506d3ba3c0dbd81a6c335d314ffa87e4a44b38a8", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 175, "deletions": 21, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4c9eef7edea40f8a30b033cc81ef14546c63fba6/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9eef7edea40f8a30b033cc81ef14546c63fba6/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=4c9eef7edea40f8a30b033cc81ef14546c63fba6", "patch": "@@ -1,3 +1,5 @@\n+use std::{collections::HashSet, ops::ControlFlow};\n+\n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n@@ -13,7 +15,7 @@ use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n \n use crate::{\n@@ -111,16 +113,69 @@ pub(crate) fn hover(\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n     })?;\n-    let token = sema.descend_into_macros(token);\n-    let node = token.parent()?;\n+\n+    let mut seen = HashSet::default();\n+\n+    let mut fallback = None;\n+    sema.descend_into_macros_many(token.clone())\n+        .iter()\n+        .filter_map(|token| match token.parent() {\n+            Some(node) => {\n+                match find_hover_result(&sema, file_id, offset, config, token, &node, &mut seen) {\n+                    Some(res) => match res {\n+                        ControlFlow::Break(inner) => Some(inner),\n+                        ControlFlow::Continue(_) => {\n+                            if fallback.is_none() {\n+                                // FIXME we're only taking the first fallback into account that's not `None`\n+                                fallback = hover_for_keyword(&sema, config, &token)\n+                                    .or(type_hover(&sema, config, &token));\n+                            }\n+                            None\n+                        }\n+                    },\n+                    None => None,\n+                }\n+            }\n+            None => None,\n+        })\n+        // reduce all descends into a single `RangeInfo`\n+        // that spans from the earliest start to the latest end (fishy/FIXME),\n+        // concatenates all `Markup`s with `\\n---\\n`,\n+        // and accumulates all actions into its `actions` vector.\n+        .reduce(|mut acc, RangeInfo { range, mut info }| {\n+            let start = acc.range.start().min(range.start());\n+            let end = acc.range.end().max(range.end());\n+\n+            acc.range = TextRange::new(start, end);\n+            acc.info.actions.append(&mut info.actions);\n+            acc.info.markup = Markup::from(format!(\"{}\\n---\\n{}\", acc.info.markup, info.markup));\n+            acc\n+        })\n+        .or(fallback)\n+}\n+\n+fn find_hover_result(\n+    sema: &Semantics<RootDatabase>,\n+    file_id: FileId,\n+    offset: TextSize,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+    node: &SyntaxNode,\n+    seen: &mut HashSet<Definition>,\n+) -> Option<ControlFlow<RangeInfo<HoverResult>>> {\n     let mut range_override = None;\n+\n+    // intra-doc links and attributes are special cased\n+    // so don't add them to the `seen` duplicate check\n+    let mut add_to_seen_definitions = true;\n+\n     let definition = match_ast! {\n         match node {\n-            ast::Name(name) => NameClass::classify(&sema, &name).map(|class| match class {\n+            ast::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n             }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|class| match class {\n+            ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(|class| match class {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n                     Definition::Field(field_ref)\n@@ -137,25 +192,37 @@ pub(crate) fn hover(\n             ),\n             _ => {\n                 // intra-doc links\n+                // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n+                // hopefully simplifying the return type of this function in the process\n+                // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n+                //\n+                // FIXME: hovering the intra doc link to `Foo` not working:\n+                //\n+                // #[identity]\n+                // trait Foo {\n+                //    /// [`Foo`]\n+                // fn foo() {}\n                 if token.kind() == COMMENT {\n+                    add_to_seen_definitions = false;\n                     cov_mark::hit!(no_highlight_on_comment_hover);\n-                    let (attributes, def) = doc_attributes(&sema, &node)?;\n-                    let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n+                    let (attributes, def) = doc_attributes(sema, node)?;\n+                    let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n                     let (idl_range, link, ns) =\n                         extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n                             let mapped = doc_mapping.map(range)?;\n                             (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n                         })?;\n                     range_override = Some(idl_range);\n-                    Some(match resolve_doc_path_for_def(db,def, &link,ns)? {\n+                    Some(match resolve_doc_path_for_def(sema.db,def, &link,ns)? {\n                         Either::Left(it) => Definition::ModuleDef(it),\n                         Either::Right(it) => Definition::Macro(it),\n                     })\n                 // attributes, require special machinery as they are mere ident tokens\n                 } else if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                    add_to_seen_definitions = false;\n                     // lints\n-                    if let res@Some(_) = try_hover_for_lint(&attr, &token) {\n-                        return res;\n+                    if let Some(res) = try_hover_for_lint(&attr, &token) {\n+                        return Some(ControlFlow::Break(res));\n                     // derives\n                     } else {\n                         range_override = Some(token.text_range());\n@@ -169,42 +236,53 @@ pub(crate) fn hover(\n     };\n \n     if let Some(definition) = definition {\n+        // skip duplicates\n+        if seen.contains(&definition) {\n+            return None;\n+        }\n+        if add_to_seen_definitions {\n+            seen.insert(definition);\n+        }\n         let famous_defs = match &definition {\n             Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n                 Some(FamousDefs(&sema, sema.scope(&node).krate()))\n             }\n             _ => None,\n         };\n-        if let Some(markup) = hover_for_definition(db, definition, famous_defs.as_ref(), config) {\n+        if let Some(markup) =\n+            hover_for_definition(sema.db, definition, famous_defs.as_ref(), config)\n+        {\n             let mut res = HoverResult::default();\n             res.markup = process_markup(sema.db, definition, &markup, config);\n-            if let Some(action) = show_implementations_action(db, definition) {\n+            if let Some(action) = show_implementations_action(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = show_fn_references_action(db, definition) {\n+            if let Some(action) = show_fn_references_action(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n             if let Some(action) = runnable_action(&sema, definition, file_id) {\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = goto_type_action_for_def(db, definition) {\n+            if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n             let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n-            return Some(RangeInfo::new(range, res));\n+            return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n         }\n     }\n \n-    if let res @ Some(_) = hover_for_keyword(&sema, config, &token) {\n-        return res;\n-    }\n-\n-    // No definition below cursor, fall back to showing type hovers.\n+    Some(ControlFlow::Continue(()))\n+}\n \n+fn type_hover(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<RangeInfo<HoverResult>> {\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -214,7 +292,7 @@ pub(crate) fn hover(\n         match node {\n             ast::Expr(it) => Either::Left(it),\n             ast::Pat(it) => Either::Right(it),\n-            // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+            // If this node is a MACRO_CALL, it means that `descend_into_macros_many` failed to resolve.\n             // (e.g expanding a builtin macro). So we give up here.\n             ast::MacroCall(_it) => return None,\n             _ => return None,\n@@ -914,6 +992,82 @@ mod tests {\n         assert!(hover.is_none());\n     }\n \n+    #[test]\n+    fn hover_descend_macros_avoids_duplicates() {\n+        check(\n+            r#\"\n+macro_rules! dupe_use {\n+    ($local:ident) => {\n+        {\n+            $local;\n+            $local;\n+        }\n+    }\n+}\n+fn foo() {\n+    let local = 0;\n+    dupe_use!(local$0);\n+}\n+\"#,\n+            expect![[r#\"\n+            *local*\n+\n+            ```rust\n+            let local: i32\n+            ```\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_shows_all_macro_descends() {\n+        check(\n+            r#\"\n+macro_rules! m {\n+    ($name:ident) => {\n+        /// Outer\n+        fn $name() {}\n+\n+        mod module {\n+            /// Inner\n+            fn $name() {}\n+        }\n+    };\n+}\n+\n+m!(ab$0c);\n+            \"#,\n+            expect![[r#\"\n+            *abc*\n+\n+            ```rust\n+            test::module\n+            ```\n+\n+            ```rust\n+            fn abc()\n+            ```\n+\n+            ---\n+\n+            Inner\n+            ---\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            fn abc()\n+            ```\n+\n+            ---\n+\n+            Outer\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_shows_type_of_an_expression() {\n         check("}]}