{"sha": "48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4Y2I5YThhYzBiOTU0MDhhMTQyZWE3YmM5NzY3NDE0ZWJhMmNiYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-12T03:21:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-12T03:21:45Z"}, "message": "auto merge of #5303 : brson/rust/newsched4, r=brson\n\nr?\r\n\r\nFollowup to #5022. This is the same, but everything is in `core::rt` now. `std::uv_ll` is moved to `core::unstable::uvll`, with the intent that it eventually move into its own crate (blocked on #5192 at least). I've had to disable the uv tests because of #2064. All of `core::rt` is disabled on platforms that aren't mac or linux until I complete the windows thread local storage bindings and ARM context switching.\r\n\r\nMy immediate next priorities will be to fix #2064 and clean up the uv bindings, get everything building on all platforms.", "tree": {"sha": "2aa22a3dbbdbf2364a41feba5f358dfd3e979574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aa22a3dbbdbf2364a41feba5f358dfd3e979574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "html_url": "https://github.com/rust-lang/rust/commit/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6bb4a0f1a61ab00e09c4cb24dfff95c6c2481c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6bb4a0f1a61ab00e09c4cb24dfff95c6c2481c7", "html_url": "https://github.com/rust-lang/rust/commit/a6bb4a0f1a61ab00e09c4cb24dfff95c6c2481c7"}, {"sha": "676e0290ed4d306e6d7b517de1409c109309a0b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/676e0290ed4d306e6d7b517de1409c109309a0b2", "html_url": "https://github.com/rust-lang/rust/commit/676e0290ed4d306e6d7b517de1409c109309a0b2"}], "stats": {"total": 3042, "additions": 2789, "deletions": 253}, "files": [{"sha": "026f49cac45b18f635ea381f27efca8d12c1974d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -243,7 +243,8 @@ pub mod unicode;\n #[path = \"num/cmath.rs\"]\n pub mod cmath;\n pub mod stackwalk;\n-\n+#[path = \"rt/mod.rs\"]\n+pub mod rt;\n \n // A curious inner-module that's not exported that contains the binding\n // 'core' so that macro-expanded references to core::error and such"}, {"sha": "6a38eff0343bde50121c75ed10be12fb4046a0a7", "filename": "src/libcore/option.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -130,6 +130,27 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n+pub pure fn get_mut_ref<T>(opt: &r/mut Option<T>) -> &r/mut T {\n+    /*!\n+    Gets a mutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    match *opt {\n+        Some(ref mut x) => x,\n+        None => fail!(~\"option::get_mut_ref none\")\n+    }\n+}\n+\n #[inline(always)]\n pub pure fn map<T, U>(opt: &r/Option<T>, f: &fn(x: &r/T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n@@ -364,6 +385,23 @@ pub impl<T> Option<T> {\n     #[inline(always)]\n     pure fn get_ref(&self) -> &self/T { get_ref(self) }\n \n+    /**\n+    Gets a mutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    #[inline(always)]\n+    pure fn get_mut_ref(&mut self) -> &self/mut T { get_mut_ref(self) }\n+\n     /**\n      * Gets the value out of an option without copying.\n      *"}, {"sha": "de96a7d17932b0e680467096bcbec46aa9c52150", "filename": "src/libcore/rt/context.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::stack::StackSegment;\n+use libc::c_void;\n+use cast::{transmute, transmute_mut_unsafe,\n+           transmute_region, transmute_mut_region};\n+\n+// XXX: Registers is boxed so that it is 16-byte aligned, for storing\n+// SSE regs.  It would be marginally better not to do this. In C++ we\n+// use an attribute on a struct.\n+pub struct Context(~Registers);\n+\n+pub impl Context {\n+    static fn empty() -> Context {\n+        Context(new_regs())\n+    }\n+\n+    /// Create a new context that will resume execution by running ~fn()\n+    /// # Safety Note\n+    /// The `start` closure must remain valid for the life of the Task\n+    static fn new(start: &~fn(), stack: &mut StackSegment) -> Context {\n+\n+        // The C-ABI function that is the task entry point\n+        extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n+\n+        let fp: *c_void = task_start_wrapper as *c_void;\n+        let argp: *c_void = unsafe { transmute::<&~fn(), *c_void>(&*start) };\n+        let sp: *uint = stack.end();\n+        let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n+\n+        // Save and then immediately load the current context,\n+        // which we will then modify to call the given function when restored\n+        let mut regs = new_regs();\n+        unsafe {\n+            swap_registers(transmute_mut_region(&mut *regs),\n+                           transmute_region(&*regs))\n+        };\n+\n+        initialize_call_frame(&mut *regs, fp, argp, sp);\n+\n+        return Context(regs);\n+    }\n+\n+    static fn swap(out_context: &mut Context, in_context: &Context) {\n+        let out_regs: &mut Registers = match out_context {\n+            &Context(~ref mut r) => r\n+        };\n+        let in_regs: &Registers = match in_context {\n+            &Context(~ref r) => r\n+        };\n+\n+        unsafe { swap_registers(out_regs, in_regs) };\n+    }\n+}\n+\n+extern {\n+    fn swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n+}\n+\n+// Definitions of these registers are in rt/arch/x86_64/regs.h\n+#[cfg(target_arch = \"x86_64\")]\n+type Registers = [uint * 22];\n+\n+#[cfg(target_arch = \"x86_64\")]\n+fn new_regs() -> ~Registers { ~[0, .. 22] }\n+\n+#[cfg(target_arch = \"x86_64\")]\n+fn initialize_call_frame(regs: &mut Registers,\n+                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+\n+    // Redefinitions from regs.h\n+    const RUSTRT_ARG0: uint = 3;\n+    const RUSTRT_RSP: uint = 1;\n+    const RUSTRT_IP: uint = 8;\n+    const RUSTRT_RBP: uint = 2;\n+\n+    let sp = align_down(sp);\n+    let sp = mut_offset(sp, -1);\n+\n+    // The final return address. 0 indicates the bottom of the stack\n+    unsafe { *sp = 0; }\n+\n+    rtdebug!(\"creating call frame\");\n+    rtdebug!(\"fptr %x\", fptr as uint);\n+    rtdebug!(\"arg %x\", arg as uint);\n+    rtdebug!(\"sp %x\", sp as uint);\n+\n+    regs[RUSTRT_ARG0] = arg as uint;\n+    regs[RUSTRT_RSP] = sp as uint;\n+    regs[RUSTRT_IP] = fptr as uint;\n+\n+    // Last base pointer on the stack should be 0\n+    regs[RUSTRT_RBP] = 0;\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+struct Registers {\n+    eax: u32, ebx: u32, ecx: u32, edx: u32,\n+    ebp: u32, esi: u32, edi: u32, esp: u32,\n+    cs: u16, ds: u16, ss: u16, es: u16, fs: u16, gs: u16,\n+    eflags: u32, eip: u32\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+fn new_regs() -> ~Registers {\n+    ~Registers {\n+        eax: 0, ebx: 0, ecx: 0, edx: 0,\n+        ebp: 0, esi: 0, edi: 0, esp: 0,\n+        cs: 0, ds: 0, ss: 0, es: 0, fs: 0, gs: 0,\n+        eflags: 0, eip: 0\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+fn initialize_call_frame(regs: &mut Registers,\n+                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+\n+    let sp = align_down(sp);\n+    let sp = mut_offset(sp, -4); // XXX: -4 words? Needs this be done at all?\n+\n+    unsafe { *sp = arg as uint; }\n+    let sp = mut_offset(sp, -1);\n+    unsafe { *sp = 0; } // The final return address\n+\n+    regs.esp = sp as u32;\n+    regs.eip = fptr as u32;\n+\n+    // Last base pointer on the stack is 0\n+    regs.ebp = 0;\n+}\n+\n+fn align_down(sp: *mut uint) -> *mut uint {\n+    unsafe {\n+        let sp = transmute::<*mut uint, uint>(sp);\n+        let sp = sp & !(16 - 1);\n+        transmute::<uint, *mut uint>(sp)\n+    }\n+}\n+\n+// XXX: ptr::offset is positive ints only\n+#[inline(always)]\n+pub pure fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    use core::sys::size_of;\n+    unsafe {\n+        (ptr as int + count * (size_of::<T>() as int)) as *mut T\n+    }\n+}\n+"}, {"sha": "3a94c01e0a4196443073609e02b0d14f11b883a5", "filename": "src/libcore/rt/io.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use result::*;\n+\n+// XXX: ~object doesn't work currently so these are some placeholder\n+// types to use instead\n+pub type EventLoopObject = super::uvio::UvEventLoop;\n+pub type IoFactoryObject = super::uvio::UvIoFactory;\n+pub type StreamObject = super::uvio::UvStream;\n+pub type TcpListenerObject = super::uvio::UvTcpListener;\n+\n+pub trait EventLoop {\n+    fn run(&mut self);\n+    fn callback(&mut self, ~fn());\n+    /// The asynchronous I/O services. Not all event loops may provide one\n+    fn io(&mut self) -> Option<&self/mut IoFactoryObject>;\n+}\n+\n+pub trait IoFactory {\n+    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject>;\n+    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject>;\n+}\n+\n+pub trait TcpListener {\n+    fn listen(&mut self) -> Option<~StreamObject>;\n+}\n+\n+pub trait Stream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n+}\n+\n+pub enum IpAddr {\n+    Ipv4(u8, u8, u8, u8, u16),\n+    Ipv6\n+}"}, {"sha": "772690c8dcdc6ef4564258a5c8ac0a44393c35f2", "filename": "src/libcore/rt/mod.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// XXX: Missing some implementation for other architectures\n+#[cfg(target_os = \"linux\")];\n+#[cfg(target_os = \"mac\")];\n+#[cfg(target_os = \"win32\")];\n+\n+// Some basic logging\n+macro_rules! rtdebug (\n+    ($( $arg:expr),+) => ( {\n+        dumb_println(fmt!( $($arg),+ ));\n+\n+        fn dumb_println(s: &str) {\n+            use str::as_c_str;\n+            use libc::c_char;\n+\n+            extern {\n+                fn printf(s: *c_char);\n+            }\n+\n+            do as_c_str(s.to_str() + \"\\n\") |s| {\n+                unsafe { printf(s); }\n+            }\n+        }\n+\n+    } )\n+)\n+\n+// An alternate version with no output, for turning off logging\n+macro_rules! rtdebug_ (\n+    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n+)\n+\n+mod sched;\n+mod io;\n+mod uvio;\n+mod uv;\n+// FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+pub mod thread_local_storage;\n+mod work_queue;\n+mod stack;\n+mod context;\n+mod thread;"}, {"sha": "8f315452e5e5c9b87355583358819a2e7d987c7c", "filename": "src/libcore/rt/sched.rs", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,564 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use sys;\n+use cast::transmute;\n+use libc::c_void;\n+use ptr::mut_null;\n+\n+use super::work_queue::WorkQueue;\n+use super::stack::{StackPool, StackSegment};\n+use super::io::{EventLoop, EventLoopObject};\n+use super::context::Context;\n+use tls = super::thread_local_storage;\n+\n+#[cfg(test)] use super::uvio::UvEventLoop;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use int;\n+\n+/// The Scheduler is responsible for coordinating execution of Tasks\n+/// on a single thread. When the scheduler is running it is owned by\n+/// thread local storage and the running task is owned by the\n+/// scheduler.\n+pub struct Scheduler {\n+    task_queue: WorkQueue<~Task>,\n+    stack_pool: StackPool,\n+    /// The event loop used to drive the scheduler and perform I/O\n+    event_loop: ~EventLoopObject,\n+    /// The scheduler's saved context.\n+    /// Always valid when a task is executing, otherwise not\n+    priv saved_context: Context,\n+    /// The currently executing task\n+    priv current_task: Option<~Task>,\n+    /// A queue of jobs to perform immediately upon return from task\n+    /// context to scheduler context.\n+    /// XXX: This probably should be a single cleanup action and it\n+    /// should run after a context switch, not on return from the\n+    /// scheduler\n+    priv cleanup_jobs: ~[CleanupJob]\n+}\n+\n+// XXX: Some hacks to put a &fn in Scheduler without borrowck\n+// complaining\n+type UnsafeTaskReceiver = sys::Closure;\n+trait HackAroundBorrowCk {\n+    static fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+}\n+impl HackAroundBorrowCk for UnsafeTaskReceiver {\n+    static fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n+        unsafe { transmute(f) }\n+    }\n+    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) {\n+        unsafe { transmute(self) }\n+    }\n+}\n+\n+enum CleanupJob {\n+    RescheduleTask(~Task),\n+    RecycleTask(~Task),\n+    GiveTask(~Task, UnsafeTaskReceiver)\n+}\n+\n+pub impl Scheduler {\n+\n+    static fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+        Scheduler {\n+            event_loop: event_loop,\n+            task_queue: WorkQueue::new(),\n+            stack_pool: StackPool::new(),\n+            saved_context: Context::empty(),\n+            current_task: None,\n+            cleanup_jobs: ~[]\n+        }\n+    }\n+\n+    // XXX: This may eventually need to be refactored so that\n+    // the scheduler itself doesn't have to call event_loop.run.\n+    // That will be important for embedding the runtime into external\n+    // event loops.\n+    fn run(~self) -> ~Scheduler {\n+        fail_unless!(!self.in_task_context());\n+\n+        // Give ownership of the scheduler (self) to the thread\n+        do self.install |scheduler| {\n+            fn run_scheduler_once() {\n+                do Scheduler::local |scheduler| {\n+                    if scheduler.resume_task_from_queue() {\n+                        // Ok, a task ran. Nice! We'll do it again later\n+                        scheduler.event_loop.callback(run_scheduler_once);\n+                    }\n+                }\n+            }\n+\n+            scheduler.event_loop.callback(run_scheduler_once);\n+            scheduler.event_loop.run();\n+        }\n+    }\n+\n+    fn install(~self, f: &fn(&mut Scheduler)) -> ~Scheduler {\n+        let mut tlsched = ThreadLocalScheduler::new();\n+        tlsched.put_scheduler(self);\n+        {\n+            let sched = tlsched.get_scheduler();\n+            f(sched);\n+        }\n+        return tlsched.take_scheduler();\n+    }\n+\n+    static fn local(f: &fn(&mut Scheduler)) {\n+        let mut tlsched = ThreadLocalScheduler::new();\n+        f(tlsched.get_scheduler());\n+    }\n+\n+    // * Scheduler-context operations\n+\n+    fn resume_task_from_queue(&mut self) -> bool {\n+        fail_unless!(!self.in_task_context());\n+\n+        let mut self = self;\n+        match self.task_queue.pop_front() {\n+            Some(task) => {\n+                self.resume_task_immediately(task);\n+                return true;\n+            }\n+            None => {\n+                rtdebug!(\"no tasks in queue\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    fn resume_task_immediately(&mut self, task: ~Task) {\n+        fail_unless!(!self.in_task_context());\n+\n+        rtdebug!(\"scheduling a task\");\n+\n+        // Store the task in the scheduler so it can be grabbed later\n+        self.current_task = Some(task);\n+        self.swap_in_task();\n+        // The running task should have passed ownership elsewhere\n+        fail_unless!(self.current_task.is_none());\n+\n+        // Running tasks may have asked us to do some cleanup\n+        self.run_cleanup_jobs();\n+    }\n+\n+\n+    // * Task-context operations\n+\n+    /// Called by a running task to end execution, after which it will\n+    /// be recycled by the scheduler for reuse in a new task.\n+    fn terminate_current_task(&mut self) {\n+        fail_unless!(self.in_task_context());\n+\n+        rtdebug!(\"ending running task\");\n+\n+        let dead_task = self.current_task.swap_unwrap();\n+        self.enqueue_cleanup_job(RecycleTask(dead_task));\n+        let dead_task = self.task_from_last_cleanup_job();\n+        self.swap_out_task(dead_task);\n+    }\n+\n+    /// Block a running task, context switch to the scheduler, then pass the\n+    /// blocked task to a closure.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// The closure here is a *stack* closure that lives in the\n+    /// running task.  It gets transmuted to the scheduler's lifetime\n+    /// and called while the task is blocked.\n+    fn block_running_task_and_then(&mut self, f: &fn(&mut Scheduler, ~Task)) {\n+        fail_unless!(self.in_task_context());\n+\n+        rtdebug!(\"blocking task\");\n+\n+        let blocked_task = self.current_task.swap_unwrap();\n+        let f_fake_region = unsafe {\n+            transmute::<&fn(&mut Scheduler, ~Task),\n+                        &fn(&mut Scheduler, ~Task)>(f)\n+        };\n+        let f_opaque = HackAroundBorrowCk::from_fn(f_fake_region);\n+        self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        let blocked_task = self.task_from_last_cleanup_job();\n+\n+        self.swap_out_task(blocked_task);\n+    }\n+\n+    /// Switch directly to another task, without going through the scheduler.\n+    /// You would want to think hard about doing this, e.g. if there are\n+    /// pending I/O events it would be a bad idea.\n+    fn resume_task_from_running_task_direct(&mut self, next_task: ~Task) {\n+        fail_unless!(self.in_task_context());\n+\n+        rtdebug!(\"switching tasks\");\n+\n+        let old_running_task = self.current_task.swap_unwrap();\n+        self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n+        let old_running_task = self.task_from_last_cleanup_job();\n+\n+        self.current_task = Some(next_task);\n+        self.swap_in_task_from_running_task(old_running_task);\n+    }\n+\n+\n+    // * Context switching\n+\n+    // NB: When switching to a task callers are expected to first set\n+    // self.running_task. When switching away from a task likewise move\n+    // out of the self.running_task\n+\n+    priv fn swap_in_task(&mut self) {\n+        // Take pointers to both the task and scheduler's saved registers.\n+        let running_task: &~Task = self.current_task.get_ref();\n+        let task_context = &running_task.saved_context;\n+        let scheduler_context = &mut self.saved_context;\n+\n+        // Context switch to the task, restoring it's registers\n+        // and saving the scheduler's\n+        Context::swap(scheduler_context, task_context);\n+    }\n+\n+    priv fn swap_out_task(&mut self, running_task: &mut Task) {\n+        let task_context = &mut running_task.saved_context;\n+        let scheduler_context = &self.saved_context;\n+        Context::swap(task_context, scheduler_context);\n+    }\n+\n+    priv fn swap_in_task_from_running_task(&mut self,\n+                                           running_task: &mut Task) {\n+        let running_task_context = &mut running_task.saved_context;\n+        let next_context = &self.current_task.get_ref().saved_context;\n+        Context::swap(running_task_context, next_context);\n+    }\n+\n+\n+    // * Other stuff\n+\n+    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n+\n+    fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n+        self.cleanup_jobs.unshift(job);\n+    }\n+\n+    fn run_cleanup_jobs(&mut self) {\n+        fail_unless!(!self.in_task_context());\n+        rtdebug!(\"running cleanup jobs\");\n+\n+        while !self.cleanup_jobs.is_empty() {\n+            match self.cleanup_jobs.pop() {\n+                RescheduleTask(task) => {\n+                    // NB: Pushing to the *front* of the queue\n+                    self.task_queue.push_front(task);\n+                }\n+                RecycleTask(task) => task.recycle(&mut self.stack_pool),\n+                GiveTask(task, f) => (f.to_fn())(self, task)\n+            }\n+        }\n+    }\n+\n+    // XXX: Hack. This should return &self/mut but I don't know how to\n+    // make the borrowcheck happy\n+    fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n+        fail_unless!(!self.cleanup_jobs.is_empty());\n+        let last_job: &self/mut CleanupJob = &mut self.cleanup_jobs[0];\n+        let last_task: &self/Task = match last_job {\n+            &RescheduleTask(~ref task) => task,\n+            &RecycleTask(~ref task) => task,\n+            &GiveTask(~ref task, _) => task,\n+        };\n+        // XXX: Pattern matching mutable pointers above doesn't work\n+        // because borrowck thinks the three patterns are conflicting\n+        // borrows\n+        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n+    }\n+}\n+\n+const TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n+\n+pub struct Task {\n+    /// The task entry point, saved here for later destruction\n+    priv start: ~~fn(),\n+    /// The segment of stack on which the task is currently running or,\n+    /// if the task is blocked, on which the task will resume execution\n+    priv current_stack_segment: StackSegment,\n+    /// These are always valid when the task is not running, unless\n+    /// the task is dead\n+    priv saved_context: Context,\n+}\n+\n+impl Task {\n+    static fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+        // XXX: Putting main into a ~ so it's a thin pointer and can\n+        // be passed to the spawn function.  Another unfortunate\n+        // allocation\n+        let start = ~Task::build_start_wrapper(start);\n+        let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n+        // NB: Context holds a pointer to that ~fn\n+        let initial_context = Context::new(&*start, &mut stack);\n+        return Task {\n+            start: start,\n+            current_stack_segment: stack,\n+            saved_context: initial_context,\n+        };\n+    }\n+\n+    static priv fn build_start_wrapper(start: ~fn()) -> ~fn() {\n+        // XXX: The old code didn't have this extra allocation\n+        let wrapper: ~fn() = || {\n+            start();\n+\n+            let mut sched = ThreadLocalScheduler::new();\n+            let sched = sched.get_scheduler();\n+            sched.terminate_current_task();\n+        };\n+        return wrapper;\n+    }\n+\n+    /// Destroy the task and try to reuse its components\n+    fn recycle(~self, stack_pool: &mut StackPool) {\n+        match self {\n+            ~Task {current_stack_segment, _} => {\n+                stack_pool.give_segment(current_stack_segment);\n+            }\n+        }\n+    }\n+}\n+\n+// NB: This is a type so we can use make use of the &self region.\n+struct ThreadLocalScheduler(tls::Key);\n+\n+impl ThreadLocalScheduler {\n+    static fn new() -> ThreadLocalScheduler {\n+        unsafe {\n+            // NB: This assumes that the TLS key has been created prior.\n+            // Currently done in rust_start.\n+            let key: *mut c_void = rust_get_sched_tls_key();\n+            let key: &mut tls::Key = transmute(key);\n+            ThreadLocalScheduler(*key)\n+        }\n+    }\n+\n+    fn put_scheduler(&mut self, scheduler: ~Scheduler) {\n+        unsafe {\n+            let key = match self { &ThreadLocalScheduler(key) => key };\n+            let value: *mut c_void =\n+                transmute::<~Scheduler, *mut c_void>(scheduler);\n+            tls::set(key, value);\n+        }\n+    }\n+\n+    fn get_scheduler(&mut self) -> &self/mut Scheduler {\n+        unsafe {\n+            let key = match self { &ThreadLocalScheduler(key) => key };\n+            let mut value: *mut c_void = tls::get(key);\n+            fail_unless!(value.is_not_null());\n+            {\n+                let value_ptr = &mut value;\n+                let sched: &mut ~Scheduler =\n+                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr);\n+                let sched: &mut Scheduler = &mut **sched;\n+                return sched;\n+            }\n+        }\n+    }\n+\n+    fn take_scheduler(&mut self) -> ~Scheduler {\n+        unsafe {\n+            let key = match self { &ThreadLocalScheduler(key) => key };\n+            let value: *mut c_void = tls::get(key);\n+            fail_unless!(value.is_not_null());\n+            let sched = transmute(value);\n+            tls::set(key, mut_null());\n+            return sched;\n+        }\n+    }\n+}\n+\n+extern {\n+    fn rust_get_sched_tls_key() -> *mut c_void;\n+}\n+\n+#[test]\n+fn thread_local_scheduler_smoke_test() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    let mut tls_scheduler = ThreadLocalScheduler::new();\n+    tls_scheduler.put_scheduler(scheduler);\n+    {\n+        let _scheduler = tls_scheduler.get_scheduler();\n+    }\n+    let _scheduler = tls_scheduler.take_scheduler();\n+}\n+\n+#[test]\n+fn thread_local_scheduler_two_instances() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    let mut tls_scheduler = ThreadLocalScheduler::new();\n+    tls_scheduler.put_scheduler(scheduler);\n+    {\n+\n+        let _scheduler = tls_scheduler.get_scheduler();\n+    }\n+    {\n+        let scheduler = tls_scheduler.take_scheduler();\n+        tls_scheduler.put_scheduler(scheduler);\n+    }\n+\n+    let mut tls_scheduler = ThreadLocalScheduler::new();\n+    {\n+        let _scheduler = tls_scheduler.get_scheduler();\n+    }\n+    let _scheduler = tls_scheduler.take_scheduler();\n+}\n+\n+#[test]\n+fn test_simple_scheduling() {\n+    do run_in_bare_thread {\n+        let mut task_ran = false;\n+        let task_ran_ptr: *mut bool = &mut task_ran;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            unsafe { *task_ran_ptr = true; }\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+        fail_unless!(task_ran);\n+    }\n+}\n+\n+#[test]\n+fn test_several_tasks() {\n+    do run_in_bare_thread {\n+        let total = 10;\n+        let mut task_count = 0;\n+        let task_count_ptr: *mut int = &mut task_count;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        for int::range(0, total) |_| {\n+            let task = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe { *task_count_ptr = *task_count_ptr + 1; }\n+            };\n+            sched.task_queue.push_back(task);\n+        }\n+        sched.run();\n+        fail_unless!(task_count == total);\n+    }\n+}\n+\n+#[test]\n+fn test_swap_tasks() {\n+    do run_in_bare_thread {\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task1 = ~do Task::new(&mut sched.stack_pool) {\n+            unsafe { *count_ptr = *count_ptr + 1; }\n+            do Scheduler::local |sched| {\n+                let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                    unsafe { *count_ptr = *count_ptr + 1; }\n+                };\n+                // Context switch directly to the new task\n+                sched.resume_task_from_running_task_direct(task2);\n+            }\n+            unsafe { *count_ptr = *count_ptr + 1; }\n+        };\n+        sched.task_queue.push_back(task1);\n+        sched.run();\n+        fail_unless!(count == 3);\n+    }\n+}\n+\n+#[bench] #[test] #[ignore(reason = \"long test\")]\n+fn test_run_a_lot_of_tasks_queued() {\n+    do run_in_bare_thread {\n+        const MAX: int = 1000000;\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+\n+        let start_task = ~do Task::new(&mut sched.stack_pool) {\n+            run_task(count_ptr);\n+        };\n+        sched.task_queue.push_back(start_task);\n+        sched.run();\n+\n+        fail_unless!(count == MAX);\n+\n+        fn run_task(count_ptr: *mut int) {\n+            do Scheduler::local |sched| {\n+                let task = ~do Task::new(&mut sched.stack_pool) {\n+                    unsafe {\n+                        *count_ptr = *count_ptr + 1;\n+                        if *count_ptr != MAX {\n+                            run_task(count_ptr);\n+                        }\n+                    }\n+                };\n+                sched.task_queue.push_back(task);\n+            }\n+        };\n+    }\n+}\n+\n+#[bench] #[test] #[ignore(reason = \"too much stack allocation\")]\n+fn test_run_a_lot_of_tasks_direct() {\n+    do run_in_bare_thread {\n+        const MAX: int = 100000;\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+\n+        let start_task = ~do Task::new(&mut sched.stack_pool) {\n+            run_task(count_ptr);\n+        };\n+        sched.task_queue.push_back(start_task);\n+        sched.run();\n+\n+        fail_unless!(count == MAX);\n+\n+        fn run_task(count_ptr: *mut int) {\n+            do Scheduler::local |sched| {\n+                let task = ~do Task::new(&mut sched.stack_pool) {\n+                    unsafe {\n+                        *count_ptr = *count_ptr + 1;\n+                        if *count_ptr != MAX {\n+                            run_task(count_ptr);\n+                        }\n+                    }\n+                };\n+                // Context switch directly to the new task\n+                sched.resume_task_from_running_task_direct(task);\n+            }\n+        };\n+    }\n+}\n+\n+#[test]\n+fn test_block_task() {\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                fail_unless!(sched.in_task_context());\n+                do sched.block_running_task_and_then() |sched, task| {\n+                    fail_unless!(!sched.in_task_context());\n+                    sched.task_queue.push_back(task);\n+                }\n+            }\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}"}, {"sha": "02c47218ed83f82cfcf81996d917b60da4fd02e4", "filename": "src/libcore/rt/stack.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use vec;\n+\n+pub struct StackSegment {\n+    buf: ~[u8]\n+}\n+\n+pub impl StackSegment {\n+    static fn new(size: uint) -> StackSegment {\n+        // Crate a block of uninitialized values\n+        let mut stack = vec::with_capacity(size);\n+        unsafe {\n+            vec::raw::set_len(&mut stack, size);\n+        }\n+\n+        StackSegment {\n+            buf: stack\n+        }\n+    }\n+\n+    fn end(&self) -> *uint {\n+        unsafe {\n+            vec::raw::to_ptr(self.buf).offset(self.buf.len()) as *uint\n+        }\n+    }\n+}\n+\n+pub struct StackPool(());\n+\n+impl StackPool {\n+\n+    static fn new() -> StackPool { StackPool(()) }\n+\n+    fn take_segment(&self, min_size: uint) -> StackSegment {\n+        StackSegment::new(min_size)\n+    }\n+\n+    fn give_segment(&self, _stack: StackSegment) {\n+    }\n+}"}, {"sha": "cd46127451281f62c37ff02620d16dbe4ba8ea4e", "filename": "src/libcore/rt/thread.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use ops::Drop;\n+\n+#[allow(non_camel_case_types)] // runtime type\n+type raw_thread = libc::c_void;\n+\n+struct Thread {\n+    main: ~fn(),\n+    raw_thread: *raw_thread\n+}\n+\n+impl Thread {\n+    static fn start(main: ~fn()) -> Thread {\n+        fn substart(main: &fn()) -> *raw_thread {\n+            unsafe { rust_raw_thread_start(main) }\n+        }\n+        let raw = substart(main);\n+        Thread {\n+            main: main,\n+            raw_thread: raw\n+        }\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn finalize(&self) {\n+        unsafe { rust_raw_thread_join_delete(self.raw_thread) }\n+    }\n+}\n+\n+extern {\n+    pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n+    pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n+}"}, {"sha": "58b5a5443860690b62be041cbd222c403746445d", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{c_void};\n+#[cfg(unix)]\n+use libc::{c_uint, c_int};\n+#[cfg(unix)]\n+use ptr::null;\n+#[cfg(windows)]\n+use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n+\n+#[cfg(unix)]\n+pub type Key = pthread_key_t;\n+\n+#[cfg(unix)]\n+pub unsafe fn create(key: &mut Key) {\n+    unsafe { fail_unless!(0 == pthread_key_create(key, null())); }\n+}\n+\n+#[cfg(unix)]\n+pub unsafe fn set(key: Key, value: *mut c_void) {\n+    unsafe { fail_unless!(0 == pthread_setspecific(key, value)); }\n+}\n+\n+#[cfg(unix)]\n+pub unsafe fn get(key: Key) -> *mut c_void {\n+    unsafe { pthread_getspecific(key) }\n+}\n+\n+#[cfg(unix)]\n+#[allow(non_camel_case_types)] // foreign type\n+type pthread_key_t = c_uint;\n+\n+#[cfg(unix)]\n+extern {\n+    fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n+    fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n+}\n+\n+#[cfg(windows)]\n+pub type Key = DWORD;\n+\n+#[cfg(windows)]\n+pub unsafe fn create(key: &mut Key) {\n+    const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n+    *key = unsafe { TlsAlloc() };\n+    fail_unless!(*key != TLS_OUT_OF_INDEXES);\n+}\n+\n+#[cfg(windows)]\n+pub unsafe fn set(key: Key, value: *mut c_void) {\n+    unsafe { fail_unless!(0 != TlsSetValue(key, value)) }\n+}\n+\n+#[cfg(windows)]\n+pub unsafe fn get(key: Key) -> *mut c_void {\n+    TlsGetValue(key)\n+}\n+\n+#[cfg(windows)]\n+#[abi = \"stdcall\"]\n+extern {\n+       fn TlsAlloc() -> DWORD;\n+       fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n+       fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+}\n+\n+#[test]\n+fn tls_smoke_test() {\n+    use cast::transmute;\n+    unsafe {\n+        let mut key = 0;\n+        let value = ~20;\n+        create(&mut key);\n+        set(key, transmute(value));\n+        let value: ~int = transmute(get(key));\n+        fail_unless!(value == ~20);\n+        let value = ~30;\n+        set(key, transmute(value));\n+        let value: ~int = transmute(get(key));\n+        fail_unless!(value == ~30);\n+    }\n+}"}, {"sha": "c947e4dde4c152116c736c94c199a75a55fbb9a8", "filename": "src/libcore/rt/uv.rs", "status": "added", "additions": 919, "deletions": 0, "changes": 919, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,919 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Bindings to libuv.\n+\n+UV types consist of the event loop (Loop), Watchers, Requests and\n+Callbacks.\n+\n+Watchers and Requests encapsulate pointers to uv *handles*, which have\n+subtyping relationships with each other.  This subtyping is reflected\n+in the bindings with explicit or implicit coercions. For example, an\n+upcast from TcpWatcher to StreamWatcher is done with\n+`tcp_watcher.as_stream()`. In other cases a callback on a specific\n+type of watcher will be passed a watcher of a supertype.\n+\n+Currently all use of Request types (connect/write requests) are\n+encapsulated in the bindings and don't need to be dealt with by the\n+caller.\n+\n+# Safety note\n+\n+Due to the complex lifecycle of uv handles, as well as compiler bugs,\n+this module is not memory safe and requires explicit memory management,\n+via `close` and `delete` methods.\n+\n+*/\n+\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n+use vec;\n+use ptr;\n+use libc::{c_void, c_int, size_t, malloc, free, ssize_t};\n+use cast::{transmute, transmute_mut_region};\n+use ptr::null;\n+use sys::size_of;\n+use unstable::uvll;\n+use super::io::{IpAddr, Ipv4, Ipv6};\n+\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::thread::Thread;\n+#[cfg(test)] use cell::Cell;\n+\n+fn ip4_to_uv_ip4(addr: IpAddr) -> uvll::sockaddr_in {\n+    match addr {\n+        Ipv4(a, b, c, d, p) => {\n+            unsafe {\n+                uvll::ip4_addr(fmt!(\"%u.%u.%u.%u\",\n+                                    a as uint,\n+                                    b as uint,\n+                                    c as uint,\n+                                    d as uint), p as int)\n+            }\n+        }\n+        Ipv6 => fail!()\n+    }\n+}\n+\n+/// A trait for callbacks to implement. Provides a little extra type safety\n+/// for generic, unsafe interop functions like `set_watcher_callback`.\n+trait Callback { }\n+\n+type NullCallback = ~fn();\n+impl Callback for NullCallback { }\n+\n+/// A type that wraps a native handle\n+trait NativeHandle<T> {\n+    static pub fn from_native_handle(T) -> Self;\n+    pub fn native_handle(&self) -> T;\n+}\n+\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n+\n+pub impl Loop {\n+    static fn new() -> Loop {\n+        let handle = unsafe { uvll::loop_new() };\n+        fail_unless!(handle.is_not_null());\n+        NativeHandle::from_native_handle(handle)\n+    }\n+\n+    fn run(&mut self) {\n+        unsafe { uvll::run(self.native_handle()) };\n+    }\n+\n+    fn close(&mut self) {\n+        unsafe { uvll::loop_delete(self.native_handle()) };\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_loop_t> for Loop {\n+    static fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n+        Loop { handle: handle }\n+    }\n+    fn native_handle(&self) -> *uvll::uv_loop_t {\n+        self.handle\n+    }\n+}\n+\n+/// The trait implemented by uv 'watchers' (handles). Watchers are\n+/// non-owning wrappers around the uv handles and are not completely\n+/// safe - there may be multiple instances for a single underlying\n+/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n+/// and `close`ed, but due to their complex life cycle may not be\n+/// entirely memory safe if used in unanticipated patterns.\n+trait Watcher {\n+    fn event_loop(&self) -> Loop;\n+}\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+\n+impl Watcher for IdleWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+impl Callback for IdleCallback { }\n+\n+pub impl IdleWatcher {\n+    static fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            fail_unless!(handle.is_not_null());\n+            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            uvll::set_data_for_uv_handle(handle, null::<()>());\n+            NativeHandle::from_native_handle(handle)\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+\n+        set_watcher_callback(self, cb);\n+        unsafe {\n+            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let idle_watcher: IdleWatcher =\n+                NativeHandle::from_native_handle(handle);\n+            let cb: &IdleCallback =\n+                borrow_callback_from_watcher(&idle_watcher);\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n+    }\n+\n+    fn close(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n+            drop_watcher_callback::<uvll::uv_idle_t,\n+                                    IdleWatcher,\n+                                    IdleCallback>(&mut idle_watcher);\n+            unsafe { uvll::idle_delete(handle) };\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    static fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}\n+\n+// uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+// and uv_file_t\n+pub struct StreamWatcher(*uvll::uv_stream_t);\n+\n+impl Watcher for StreamWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+impl Callback for ReadCallback { }\n+\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+impl Callback for AllocCallback { }\n+\n+pub impl StreamWatcher {\n+\n+    fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n+        // XXX: Borrowchk problems\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        data.alloc_cb = Some(alloc);\n+        data.read_cb = Some(cb);\n+\n+        let handle = self.native_handle();\n+        unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n+\n+        extern fn alloc_cb(stream: *uvll::uv_stream_t,\n+                           suggested_size: size_t) -> Buf {\n+            let mut stream_watcher: StreamWatcher =\n+                NativeHandle::from_native_handle(stream);\n+            let data = get_watcher_data(&mut stream_watcher);\n+            let alloc_cb = data.alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        extern fn read_cb(stream: *uvll::uv_stream_t,\n+                          nread: ssize_t, ++buf: Buf) {\n+            rtdebug!(\"buf addr: %x\", buf.base as uint);\n+            rtdebug!(\"buf len: %d\", buf.len as int);\n+            let mut stream_watcher: StreamWatcher =\n+                NativeHandle::from_native_handle(stream);\n+            let data = get_watcher_data(&mut stream_watcher);\n+            let cb = data.read_cb.get_ref();\n+            let status = status_to_maybe_uv_error(stream, nread as c_int);\n+            (*cb)(stream_watcher, nread as int, buf, status);\n+        }\n+    }\n+\n+    fn read_stop(&mut self) {\n+        // It would be nice to drop the alloc and read callbacks here,\n+        // but read_stop may be called from inside one of them and we\n+        // would end up freeing the in-use environment\n+        let handle = self.native_handle();\n+        unsafe { uvll::read_stop(handle); }\n+    }\n+\n+    // XXX: Needs to take &[u8], not ~[u8]\n+    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n+        // XXX: Borrowck\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        fail_unless!(data.write_cb.is_none());\n+        data.write_cb = Some(cb);\n+\n+        let req = WriteRequest::new();\n+        let buf = vec_to_uv_buf(msg);\n+        // XXX: Allocation\n+        let bufs = ~[buf];\n+        unsafe {\n+            fail_unless!(0 == uvll::write(req.native_handle(),\n+                                          self.native_handle(),\n+                                          &bufs, write_cb));\n+        }\n+        // XXX: Freeing immediately after write. Is this ok?\n+        let _v = vec_from_uv_buf(buf);\n+\n+        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+            let write_request: WriteRequest =\n+                NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = write_request.stream();\n+            write_request.delete();\n+            let cb = get_watcher_data(&mut stream_watcher)\n+                .write_cb.swap_unwrap();\n+            let status = status_to_maybe_uv_error(\n+                stream_watcher.native_handle(), status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+    fn accept(&mut self, stream: StreamWatcher) {\n+        let self_handle = self.native_handle() as *c_void;\n+        let stream_handle = stream.native_handle() as *c_void;\n+        unsafe {\n+            fail_unless!(0 == uvll::accept(self_handle, stream_handle));\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut self = self;\n+            let data = get_watcher_data(&mut self);\n+            fail_unless!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_stream_t) {\n+            let mut stream_watcher: StreamWatcher =\n+                NativeHandle::from_native_handle(handle);\n+            {\n+                let mut data = get_watcher_data(&mut stream_watcher);\n+                data.close_cb.swap_unwrap()();\n+            }\n+            drop_watcher_data(&mut stream_watcher);\n+            unsafe { free(handle as *c_void) }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n+    static fn from_native_handle(\n+        handle: *uvll::uv_stream_t) -> StreamWatcher {\n+        StreamWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_stream_t {\n+        match self { &StreamWatcher(ptr) => ptr }\n+    }\n+}\n+\n+pub struct TcpWatcher(*uvll::uv_tcp_t);\n+\n+impl Watcher for TcpWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+impl Callback for ConnectionCallback { }\n+\n+pub impl TcpWatcher {\n+    static fn new(loop_: &mut Loop) -> TcpWatcher {\n+        unsafe {\n+            let size = size_of::<uvll::uv_tcp_t>() as size_t;\n+            let handle = malloc(size) as *uvll::uv_tcp_t;\n+            fail_unless!(handle.is_not_null());\n+            fail_unless!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n+            let mut watcher = NativeHandle::from_native_handle(handle);\n+            install_watcher_data(&mut watcher);\n+            return watcher;\n+        }\n+    }\n+\n+    fn bind(&mut self, address: IpAddr) {\n+        match address {\n+            Ipv4(*) => {\n+                let addr = ip4_to_uv_ip4(address);\n+                let result = unsafe {\n+                    uvll::tcp_bind(self.native_handle(), &addr)\n+                };\n+                // XXX: bind is likely to fail. need real error handling\n+                fail_unless!(result == 0);\n+            }\n+            _ => fail!()\n+        }\n+    }\n+\n+    fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n+        unsafe {\n+            fail_unless!(get_watcher_data(self).connect_cb.is_none());\n+            get_watcher_data(self).connect_cb = Some(cb);\n+\n+            let mut connect_watcher = ConnectRequest::new();\n+            let connect_handle = connect_watcher.native_handle();\n+            match address {\n+                Ipv4(*) => {\n+                    let addr = ip4_to_uv_ip4(address);\n+                    rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+                    fail_unless!(0 == uvll::tcp_connect(connect_handle,\n+                                                        self.native_handle(),\n+                                                        &addr, connect_cb));\n+                }\n+                _ => fail!()\n+            }\n+\n+            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+                rtdebug!(\"connect_t: %x\", req as uint);\n+                let connect_request: ConnectRequest =\n+                    NativeHandle::from_native_handle(req);\n+                let mut stream_watcher = connect_request.stream();\n+                connect_request.delete();\n+                let cb: ConnectionCallback = {\n+                    let data = get_watcher_data(&mut stream_watcher);\n+                    data.connect_cb.swap_unwrap()\n+                };\n+                let status = status_to_maybe_uv_error(\n+                    stream_watcher.native_handle(), status);\n+                cb(stream_watcher, status);\n+            }\n+        }\n+    }\n+\n+    fn listen(&mut self, cb: ConnectionCallback) {\n+        // XXX: Borrowck\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        fail_unless!(data.connect_cb.is_none());\n+        data.connect_cb = Some(cb);\n+\n+        unsafe {\n+            const BACKLOG: c_int = 128; // XXX should be configurable\n+            // XXX: This can probably fail\n+            fail_unless!(0 == uvll::listen(self.native_handle(),\n+                                           BACKLOG, connection_cb));\n+        }\n+\n+        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n+            rtdebug!(\"connection_cb\");\n+            let mut stream_watcher: StreamWatcher =\n+                NativeHandle::from_native_handle(handle);\n+            let cb = get_watcher_data(&mut stream_watcher)\n+                .connect_cb.swap_unwrap();\n+            let status = status_to_maybe_uv_error(\n+                stream_watcher.native_handle(), status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+    fn as_stream(&self) -> StreamWatcher {\n+        NativeHandle::from_native_handle(\n+            self.native_handle() as *uvll::uv_stream_t)\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n+    static fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n+        TcpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tcp_t {\n+        match self { &TcpWatcher(ptr) => ptr }\n+    }\n+}\n+\n+trait Request { }\n+\n+type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n+impl Callback for ConnectCallback { }\n+\n+// uv_connect_t is a subclass of uv_req_t\n+struct ConnectRequest(*uvll::uv_connect_t);\n+\n+impl Request for ConnectRequest { }\n+\n+impl ConnectRequest {\n+\n+    static fn new() -> ConnectRequest {\n+        let connect_handle = unsafe {\n+            malloc(size_of::<uvll::uv_connect_t>() as size_t)\n+        };\n+        fail_unless!(connect_handle.is_not_null());\n+        let connect_handle = connect_handle as *uvll::uv_connect_t;\n+        ConnectRequest(connect_handle)\n+    }\n+\n+    fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle =\n+                uvll::get_stream_handle_from_connect_req(\n+                    self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n+    static fn from_native_handle(\n+        handle: *uvll:: uv_connect_t) -> ConnectRequest {\n+        ConnectRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_connect_t {\n+        match self { &ConnectRequest(ptr) => ptr }\n+    }\n+}\n+\n+pub struct WriteRequest(*uvll::uv_write_t);\n+\n+impl Request for WriteRequest { }\n+\n+impl WriteRequest {\n+\n+    static fn new() -> WriteRequest {\n+        let write_handle = unsafe {\n+            malloc(size_of::<uvll::uv_write_t>() as size_t)\n+        };\n+        fail_unless!(write_handle.is_not_null());\n+        let write_handle = write_handle as *uvll::uv_write_t;\n+        WriteRequest(write_handle)\n+    }\n+\n+    fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle =\n+                uvll::get_stream_handle_from_write_req(self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n+    static fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n+        WriteRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_write_t {\n+        match self { &WriteRequest(ptr) => ptr }\n+    }\n+}\n+\n+// XXX: Need to define the error constants like EOF so they can be\n+// compared to the UvError type\n+\n+struct UvError(uvll::uv_err_t);\n+\n+impl UvError {\n+\n+    pure fn name(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let name_str = uvll::err_name(inner);\n+            fail_unless!(name_str.is_not_null());\n+            from_c_str(name_str)\n+        }\n+    }\n+\n+    pure fn desc(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let desc_str = uvll::strerror(inner);\n+            fail_unless!(desc_str.is_not_null());\n+            from_c_str(desc_str)\n+        }\n+    }\n+}\n+\n+impl ToStr for UvError {\n+    pure fn to_str(&self) -> ~str {\n+        fmt!(\"%s: %s\", self.name(), self.desc())\n+    }\n+}\n+\n+#[test]\n+fn error_smoke_test() {\n+    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n+    let err: UvError = UvError(err);\n+    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n+}\n+\n+\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n+\n+/// Get the uv event loop from a Watcher\n+pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &W) -> Loop {\n+\n+    let handle = watcher.native_handle();\n+    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n+    NativeHandle::from_native_handle(loop_)\n+}\n+\n+/// Set the custom data on a handle to a callback Note: This is only\n+/// suitable for watchers that make just one type of callback.  For\n+/// others use WatcherData\n+fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W, cb: CB) {\n+\n+    drop_watcher_callback::<H, W, CB>(watcher);\n+    // XXX: Boxing the callback so it fits into a\n+    // pointer. Unfortunate extra allocation\n+    let boxed_cb = ~cb;\n+    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n+    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n+}\n+\n+/// Delete a callback from a handle's custom data\n+fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        if handle_data.is_not_null() {\n+            // Take ownership of the callback and drop it\n+            let _cb = transmute::<*c_void, ~CB>(handle_data);\n+            // Make sure the pointer is zeroed\n+            uvll::set_data_for_uv_handle(\n+                watcher.native_handle(), null::<()>());\n+        }\n+    }\n+}\n+\n+/// Take a pointer to the callback installed as custom data\n+fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n+                                CB: Callback>(watcher: &W) -> &CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n+        return &**cb;\n+    }\n+}\n+\n+/// Take ownership of the callback installed as custom data\n+fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) -> CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        uvll::set_data_for_uv_handle(handle, null::<()>());\n+        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n+        let cb = match cb { ~cb => cb };\n+        return cb;\n+    }\n+}\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>\n+}\n+\n+fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = ~WatcherData {\n+            read_cb: None,\n+            write_cb: None,\n+            connect_cb: None,\n+            close_cb: None,\n+            alloc_cb: None\n+        };\n+        let data = transmute::<~WatcherData, *c_void>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n+    }\n+}\n+\n+fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &r/mut W) -> &r/mut WatcherData {\n+\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+        return &mut **data;\n+    }\n+}\n+\n+fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let _data = transmute::<*c_void, ~WatcherData>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+    }\n+}\n+\n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    fail_unless!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    fail_unless!(slice[0] == 1);\n+    fail_unless!(slice[1] == 2);\n+}\n+\n+/// The uv buffer type\n+pub type Buf = uvll::uv_buf_t;\n+\n+/// Borrow a slice to a Buf\n+pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n+    let data = unsafe { vec::raw::to_ptr(v) };\n+    unsafe { uvll::buf_init(data, v.len()) }\n+}\n+\n+// XXX: Do these conversions without copying\n+\n+/// Transmute an owned vector to a Buf\n+fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n+    fail_unless!(data.is_not_null());\n+    do vec::as_imm_buf(v) |b, l| {\n+        let data = data as *mut u8;\n+        unsafe { ptr::copy_memory(data, b, l) }\n+    }\n+    let buf = unsafe { uvll::buf_init(data, v.len()) };\n+    return buf;\n+}\n+\n+/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n+fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    if !(buf.len == 0 && buf.base.is_null()) {\n+        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n+        unsafe { free(buf.base as *c_void) };\n+        return Some(v);\n+    } else {\n+        // No buffer\n+        return None;\n+    }\n+}\n+\n+#[test]\n+fn loop_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n+fn idle_new_then_close() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        idle_watcher.close();\n+    }\n+}\n+\n+#[test]\n+fn idle_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        let mut count = 10;\n+        let count_ptr: *mut int = &mut count;\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            if unsafe { *count_ptr == 10 } {\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            } else {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+        fail_unless!(count == 10);\n+    }\n+}\n+\n+#[test]\n+fn idle_start_stop_start() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            idle_watcher.stop();\n+            do idle_watcher.start |idle_watcher, status| {\n+                fail_unless!(status.is_none());\n+                let mut idle_watcher = idle_watcher;\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn connect_close() {\n+    do run_in_bare_thread() {\n+        let mut loop_ = Loop::new();\n+        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        // Connect to a port where nobody is listening\n+        let addr = Ipv4(127, 0, 0, 1, 2923);\n+        do tcp_watcher.connect(addr) |stream_watcher, status| {\n+            rtdebug!(\"tcp_watcher.connect!\");\n+            fail_unless!(status.is_some());\n+            fail_unless!(status.get().name() == ~\"ECONNREFUSED\");\n+            stream_watcher.close(||());\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"need a server to connect to\")]\n+fn connect_read() {\n+    do run_in_bare_thread() {\n+        let mut loop_ = Loop::new();\n+        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        let addr = Ipv4(127, 0, 0, 1, 2924);\n+        do tcp_watcher.connect(addr) |stream_watcher, status| {\n+            let mut stream_watcher = stream_watcher;\n+            rtdebug!(\"tcp_watcher.connect!\");\n+            fail_unless!(status.is_none());\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+            do stream_watcher.read_start(alloc)\n+                |stream_watcher, nread, buf, status| {\n+\n+                let buf = vec_from_uv_buf(buf);\n+                rtdebug!(\"read cb!\");\n+                if status.is_none() {\n+                    let bytes = buf.unwrap();\n+                    rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n+                } else {\n+                    rtdebug!(\"status after read: %s\", status.get().to_str());\n+                    rtdebug!(\"closing\");\n+                    stream_watcher.close(||());\n+                }\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn listen() {\n+    do run_in_bare_thread() {\n+        const MAX: int = 10;\n+        let mut loop_ = Loop::new();\n+        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        let addr = Ipv4(127, 0, 0, 1, 2925);\n+        server_tcp_watcher.bind(addr);\n+        let loop_ = loop_;\n+        rtdebug!(\"listening\");\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            rtdebug!(\"listened!\");\n+            fail_unless!(status.is_none());\n+            let mut server_stream_watcher = server_stream_watcher;\n+            let mut loop_ = loop_;\n+            let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+            server_stream_watcher.accept(client_tcp_watcher);\n+            let count_cell = Cell(0);\n+            let server_stream_watcher = server_stream_watcher;\n+            rtdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+            do client_tcp_watcher.read_start(alloc)\n+                |stream_watcher, nread, buf, status| {\n+\n+                rtdebug!(\"i'm reading!\");\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = count_cell.take();\n+                if status.is_none() {\n+                    rtdebug!(\"got %d bytes\", nread);\n+                    let buf = buf.unwrap();\n+                    for buf.view(0, nread as uint).each |byte| {\n+                        fail_unless!(*byte == count as u8);\n+                        rtdebug!(\"%u\", *byte as uint);\n+                        count += 1;\n+                    }\n+                } else {\n+                    fail_unless!(count == MAX);\n+                    do stream_watcher.close {\n+                        server_stream_watcher.close(||());\n+                    }\n+                }\n+                count_cell.put_back(count);\n+            }\n+        }\n+\n+        let _client_thread = do Thread::start {\n+            rtdebug!(\"starting client thread\");\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"connecting\");\n+                fail_unless!(status.is_none());\n+                let mut stream_watcher = stream_watcher;\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                do stream_watcher.write(msg) |stream_watcher, status| {\n+                    rtdebug!(\"writing\");\n+                    fail_unless!(status.is_none());\n+                    stream_watcher.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        };\n+\n+        let mut loop_ = loop_;\n+        loop_.run();\n+        loop_.close();\n+    }\n+}"}, {"sha": "f7275652e7f398c44eaa9a359569d2d1c40c8ed6", "filename": "src/libcore/rt/uvio.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,475 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use result::*;\n+\n+use super::uv::*;\n+use super::io::*;\n+use ops::Drop;\n+use cell::{Cell, empty_cell};\n+use cast::transmute;\n+use super::StreamObject;\n+use super::sched::Scheduler;\n+use super::IoFactoryObject;\n+\n+#[cfg(test)] use super::sched::Task;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use uint;\n+\n+pub struct UvEventLoop {\n+    uvio: UvIoFactory\n+}\n+\n+pub impl UvEventLoop {\n+    static fn new() -> UvEventLoop {\n+        UvEventLoop {\n+            uvio: UvIoFactory(Loop::new())\n+        }\n+    }\n+\n+    /// A convenience constructor\n+    static fn new_scheduler() -> Scheduler {\n+        Scheduler::new(~UvEventLoop::new())\n+    }\n+}\n+\n+impl Drop for UvEventLoop {\n+    fn finalize(&self) {\n+        // XXX: Need mutable finalizer\n+        let self = unsafe {\n+            transmute::<&UvEventLoop, &mut UvEventLoop>(self)\n+        };\n+        let mut uv_loop = self.uvio.uv_loop();\n+        uv_loop.close();\n+    }\n+}\n+\n+impl EventLoop for UvEventLoop {\n+\n+    fn run(&mut self) {\n+        self.uvio.uv_loop().run();\n+    }\n+\n+    fn callback(&mut self, f: ~fn()) {\n+        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n+        do idle_watcher.start |idle_watcher, status| {\n+            fail_unless!(status.is_none());\n+            let mut idle_watcher = idle_watcher;\n+            idle_watcher.stop();\n+            idle_watcher.close();\n+            f();\n+        }\n+    }\n+\n+    fn io(&mut self) -> Option<&self/mut IoFactoryObject> {\n+        Some(&mut self.uvio)\n+    }\n+}\n+\n+#[test]\n+fn test_callback_run_once() {\n+    do run_in_bare_thread {\n+        let mut event_loop = UvEventLoop::new();\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+        do event_loop.callback {\n+            unsafe { *count_ptr += 1 }\n+        }\n+        event_loop.run();\n+        fail_unless!(count == 1);\n+    }\n+}\n+\n+pub struct UvIoFactory(Loop);\n+\n+pub impl UvIoFactory {\n+    fn uv_loop(&mut self) -> &self/mut Loop {\n+        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    }\n+}\n+\n+impl IoFactory for UvIoFactory {\n+    // Connect to an address and return a new stream\n+    // NB: This blocks the task waiting on the connection.\n+    // It would probably be better to return a future\n+    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n+        // Create a cell in the task to hold the result. We will fill\n+        // the cell before resuming the task.\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+\n+        do Scheduler::local |scheduler| {\n+            fail_unless!(scheduler.in_task_context());\n+\n+            // Block this task and take ownership, switch to scheduler context\n+            do scheduler.block_running_task_and_then |scheduler, task| {\n+\n+                rtdebug!(\"connect: entered scheduler context\");\n+                fail_unless!(!scheduler.in_task_context());\n+                let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+                let task_cell = Cell(task);\n+\n+                // Wait for a connection\n+                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                    rtdebug!(\"connect: in connect callback\");\n+                    let maybe_stream = if status.is_none() {\n+                        rtdebug!(\"status is none\");\n+                        Some(~UvStream(stream_watcher))\n+                    } else {\n+                        rtdebug!(\"status is some\");\n+                        stream_watcher.close(||());\n+                        None\n+                    };\n+\n+                    // Store the stream in the task's stack\n+                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                    // Context switch\n+                    do Scheduler::local |scheduler| {\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+\n+        fail_unless!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n+        let mut watcher = TcpWatcher::new(self.uv_loop());\n+        watcher.bind(addr);\n+        return Some(~UvTcpListener(watcher));\n+    }\n+}\n+\n+pub struct UvTcpListener(TcpWatcher);\n+\n+impl UvTcpListener {\n+    fn watcher(&self) -> TcpWatcher {\n+        match self { &UvTcpListener(w) => w }\n+    }\n+\n+    fn close(&self) {\n+        // XXX: Need to wait until close finishes before returning\n+        self.watcher().as_stream().close(||());\n+    }\n+}\n+\n+impl Drop for UvTcpListener {\n+    fn finalize(&self) {\n+        // XXX: Again, this never gets called. Use .close() instead\n+        //self.watcher().as_stream().close(||());\n+    }\n+}\n+\n+impl TcpListener for UvTcpListener {\n+\n+    fn listen(&mut self) -> Option<~StreamObject> {\n+        rtdebug!(\"entering listen\");\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+\n+        let server_tcp_watcher = self.watcher();\n+\n+        do Scheduler::local |scheduler| {\n+            fail_unless!(scheduler.in_task_context());\n+\n+            do scheduler.block_running_task_and_then |_, task| {\n+                let task_cell = Cell(task);\n+                let mut server_tcp_watcher = server_tcp_watcher;\n+                do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                    let maybe_stream = if status.is_none() {\n+                        let mut server_stream_watcher = server_stream_watcher;\n+                        let mut loop_ =\n+                            loop_from_watcher(&server_stream_watcher);\n+                        let mut client_tcp_watcher =\n+                            TcpWatcher::new(&mut loop_);\n+                        let mut client_tcp_watcher =\n+                            client_tcp_watcher.as_stream();\n+                        // XXX: Need's to be surfaced in interface\n+                        server_stream_watcher.accept(client_tcp_watcher);\n+                        Some(~UvStream::new(client_tcp_watcher))\n+                    } else {\n+                        None\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                    rtdebug!(\"resuming task from listen\");\n+                    // Context switch\n+                    do Scheduler::local |scheduler| {\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+\n+        fail_unless!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+}\n+\n+pub struct UvStream(StreamWatcher);\n+\n+impl UvStream {\n+    static fn new(watcher: StreamWatcher) -> UvStream {\n+        UvStream(watcher)\n+    }\n+\n+    fn watcher(&self) -> StreamWatcher {\n+        match self { &UvStream(w) => w }\n+    }\n+\n+    // XXX: finalize isn't working for ~UvStream???\n+    fn close(&self) {\n+        // XXX: Need to wait until this finishes before returning\n+        self.watcher().close(||());\n+    }\n+}\n+\n+impl Drop for UvStream {\n+    fn finalize(&self) {\n+        rtdebug!(\"closing stream\");\n+        //self.watcher().close(||());\n+    }\n+}\n+\n+impl Stream for UvStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n+\n+        do Scheduler::local |scheduler| {\n+            fail_unless!(scheduler.in_task_context());\n+            let watcher = self.watcher();\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.block_running_task_and_then |scheduler, task| {\n+                rtdebug!(\"read: entered scheduler context\");\n+                fail_unless!(!scheduler.in_task_context());\n+                let mut watcher = watcher;\n+                let task_cell = Cell(task);\n+                // XXX: We shouldn't reallocate these callbacks every\n+                // call to read\n+                let alloc: AllocCallback = |_| unsafe {\n+                    slice_to_uv_buf(*buf_ptr)\n+                };\n+                do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+\n+                    // Stop reading so that no read callbacks are\n+                    // triggered before the user calls `read` again.\n+                    // XXX: Is there a performance impact to calling\n+                    // stop here?\n+                    let mut watcher = watcher;\n+                    watcher.read_stop();\n+\n+                    let result = if status.is_none() {\n+                        fail_unless!(nread >= 0);\n+                        Ok(nread as uint)\n+                    } else {\n+                        Err(())\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    do Scheduler::local |scheduler| {\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+\n+        fail_unless!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n+        do Scheduler::local |scheduler| {\n+            fail_unless!(scheduler.in_task_context());\n+            let watcher = self.watcher();\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.block_running_task_and_then |_, task| {\n+                let mut watcher = watcher;\n+                let task_cell = Cell(task);\n+                let buf = unsafe { &*buf_ptr };\n+                // XXX: OMGCOPIES\n+                let buf = buf.to_vec();\n+                do watcher.write(buf) |_watcher, status| {\n+                    let result = if status.is_none() {\n+                        Ok(())\n+                    } else {\n+                        Err(())\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    do Scheduler::local |scheduler| {\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+\n+        fail_unless!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn test_simple_io_no_connect() {\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let addr = Ipv4(127, 0, 0, 1, 2926);\n+                let maybe_chan = io.connect(addr);\n+                fail_unless!(maybe_chan.is_none());\n+            }\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn test_simple_tcp_server_and_client() {\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let addr = Ipv4(127, 0, 0, 1, 2929);\n+\n+        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n+        };\n+\n+        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let mut listener = io.bind(addr).unwrap();\n+                let mut stream = listener.listen().unwrap();\n+                let mut buf = [0, .. 2048];\n+                let nread = stream.read(buf).unwrap();\n+                fail_unless!(nread == 8);\n+                for uint::range(0, nread) |i| {\n+                    rtdebug!(\"%u\", buf[i] as uint);\n+                    fail_unless!(buf[i] == i as u8);\n+                }\n+                stream.close();\n+                listener.close();\n+            }\n+        };\n+\n+        // Start the server first so it listens before the client connects\n+        sched.task_queue.push_back(server_task);\n+        sched.task_queue.push_back(client_task);\n+        sched.run();\n+    }\n+}\n+\n+#[test] #[ignore(reason = \"busted\")]\n+fn test_read_and_block() {\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let addr = Ipv4(127, 0, 0, 1, 2930);\n+\n+        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n+        };\n+\n+        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let mut listener = io.bind(addr).unwrap();\n+                let mut stream = listener.listen().unwrap();\n+                let mut buf = [0, .. 2048];\n+\n+                let expected = 32;\n+                let mut current = 0;\n+                let mut reads = 0;\n+\n+                while current < expected {\n+                    let nread = stream.read(buf).unwrap();\n+                    for uint::range(0, nread) |i| {\n+                        let val = buf[i] as uint;\n+                        fail_unless!(val == current % 8);\n+                        current += 1;\n+                    }\n+                    reads += 1;\n+\n+                    do Scheduler::local |scheduler| {\n+                        // Yield to the other task in hopes that it\n+                        // will trigger a read callback while we are\n+                        // not ready for it\n+                        do scheduler.block_running_task_and_then\n+                            |scheduler, task| {\n+                            scheduler.task_queue.push_back(task);\n+                        }\n+                    }\n+                }\n+\n+                // Make sure we had multiple reads\n+                fail_unless!(reads > 1);\n+\n+                stream.close();\n+                listener.close();\n+            }\n+        };\n+\n+        // Start the server first so it listens before the client connects\n+        sched.task_queue.push_back(server_task);\n+        sched.task_queue.push_back(client_task);\n+        sched.run();\n+    }\n+}\n+\n+#[test] #[ignore(reason = \"needs server\")]\n+fn test_read_read_read() {\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let addr = Ipv4(127, 0, 0, 1, 2931);\n+\n+        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+            do Scheduler::local |sched| {\n+                let io = sched.event_loop.io().unwrap();\n+                let mut stream = io.connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < 500000000 {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                }\n+                rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n+                stream.close();\n+            }\n+        };\n+\n+        sched.task_queue.push_back(client_task);\n+        sched.run();\n+    }\n+}"}, {"sha": "1be2eb26e62921097cc97771792b362fc6111690", "filename": "src/libcore/rt/work_queue.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+\n+pub struct WorkQueue<T> {\n+    priv queue: ~[T]\n+}\n+\n+pub impl<T> WorkQueue<T> {\n+    static fn new() -> WorkQueue<T> {\n+        WorkQueue {\n+            queue: ~[]\n+        }\n+    }\n+\n+    fn push_back(&mut self, value: T) {\n+        self.queue.push(value)\n+    }\n+\n+    fn pop_back(&mut self) -> Option<T> {\n+        if !self.queue.is_empty() {\n+            Some(self.queue.pop())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn push_front(&mut self, value: T) {\n+        self.queue.unshift(value)\n+    }\n+\n+    fn pop_front(&mut self) -> Option<T> {\n+        if !self.queue.is_empty() {\n+            Some(self.queue.shift())\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "7936b18dbe20c0b027942f48bae1f717f6de575d", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -35,6 +35,8 @@ pub mod extfmt;\n #[path = \"unstable/lang.rs\"]\n #[cfg(notest)]\n pub mod lang;\n+#[path = \"unstable/uvll.rs\"]\n+pub mod uvll;\n \n mod rustrt {\n     use unstable::{raw_thread, rust_little_lock};\n@@ -61,7 +63,7 @@ for it to terminate.\n The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n-pub unsafe fn run_in_bare_thread(f: ~fn()) {\n+pub fn run_in_bare_thread(f: ~fn()) {\n     let (port, chan) = comm::stream();\n     // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n     // necessary since rust_raw_thread_join_delete is blocking\n@@ -80,22 +82,18 @@ pub unsafe fn run_in_bare_thread(f: ~fn()) {\n \n #[test]\n fn test_run_in_bare_thread() {\n-    unsafe {\n-        let i = 100;\n-        do run_in_bare_thread {\n-            fail_unless!(i == 100);\n-        }\n+    let i = 100;\n+    do run_in_bare_thread {\n+        fail_unless!(i == 100);\n     }\n }\n \n #[test]\n fn test_run_in_bare_thread_exchange() {\n-    unsafe {\n-        // Does the exchange heap work without the runtime?\n-        let i = ~100;\n-        do run_in_bare_thread {\n-            fail_unless!(i == ~100);\n-        }\n+    // Does the exchange heap work without the runtime?\n+    let i = ~100;\n+    do run_in_bare_thread {\n+        fail_unless!(i == ~100);\n     }\n }\n "}, {"sha": "0aed2567a220fe45080de932730cbf0470221c1a", "filename": "src/libcore/unstable/uvll.rs", "status": "renamed", "additions": 211, "deletions": 195, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Funstable%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibcore%2Funstable%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fuvll.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -32,14 +32,15 @@\n \n #[allow(non_camel_case_types)]; // C types\n \n-use core::libc::size_t;\n-use core::libc;\n-use core::prelude::*;\n-use core::ptr::to_unsafe_ptr;\n-use core::ptr;\n-use core::str;\n-use core::vec;\n-use core::comm::{stream, Chan, SharedChan, Port};\n+use libc::size_t;\n+use libc::c_void;\n+use prelude::*;\n+use ptr::to_unsafe_ptr;\n+\n+pub type uv_handle_t = c_void;\n+pub type uv_loop_t = c_void;\n+pub type uv_idle_t = c_void;\n+pub type uv_idle_cb = *u8;\n \n // libuv struct mappings\n pub struct uv_ip4_addr {\n@@ -355,7 +356,10 @@ pub struct uv_getaddrinfo_t {\n }\n \n pub mod uv_ll_struct_stubgen {\n-    use uv_ll::{\n+\n+    use ptr;\n+\n+    use super::{\n         uv_async_t,\n         uv_connect_t,\n         uv_getaddrinfo_t,\n@@ -369,15 +373,13 @@ pub mod uv_ll_struct_stubgen {\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    use uv_ll::{\n+    use super::{\n         uv_async_t_32bit_unix_riders,\n         uv_tcp_t_32bit_unix_riders,\n         uv_timer_t_32bit_unix_riders,\n         uv_write_t_32bit_unix_riders,\n     };\n \n-    use core::ptr;\n-\n     pub fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n         return gen_stub_os();\n         #[cfg(target_os = \"linux\")]\n@@ -724,157 +726,157 @@ pub mod uv_ll_struct_stubgen {\n     }\n }\n \n-pub mod rustrt {\n-    use super::{addrinfo, sockaddr_in, sockaddr_in6, uv_async_t, uv_buf_t};\n-    use super::{uv_connect_t, uv_err_t, uv_getaddrinfo_t, uv_stream_t};\n-    use super::{uv_tcp_t, uv_timer_t, uv_write_t};\n-\n-    use core::libc;\n-\n-    #[nolink]\n-    pub extern {\n-        // libuv public API\n-        unsafe fn rust_uv_loop_new() -> *libc::c_void;\n-        unsafe fn rust_uv_loop_delete(lp: *libc::c_void);\n-        unsafe fn rust_uv_run(loop_handle: *libc::c_void);\n-        unsafe fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n-        unsafe fn rust_uv_walk(loop_handle: *libc::c_void, cb: *u8,\n-                               arg: *libc::c_void);\n-        unsafe fn rust_uv_async_send(handle: *uv_async_t);\n-        unsafe fn rust_uv_async_init(loop_handle: *libc::c_void,\n-                              async_handle: *uv_async_t,\n-                              cb: *u8) -> libc::c_int;\n-        unsafe fn rust_uv_tcp_init(\n-            loop_handle: *libc::c_void,\n-            handle_ptr: *uv_tcp_t) -> libc::c_int;\n-        // FIXME ref #2604 .. ?\n-        unsafe fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n-                            len: libc::size_t);\n-        unsafe fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n-        unsafe fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n-            -> sockaddr_in;\n-        unsafe fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n-            -> sockaddr_in6;\n-        unsafe fn rust_uv_ip4_name(src: *sockaddr_in,\n-                                   dst: *u8,\n-                                   size: libc::size_t)\n-                                -> libc::c_int;\n-        unsafe fn rust_uv_ip6_name(src: *sockaddr_in6,\n-                                   dst: *u8,\n-                                   size: libc::size_t)\n-                                -> libc::c_int;\n-        unsafe fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n-        unsafe fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                                      tcp_handle_ptr: *uv_tcp_t,\n-                                      ++after_cb: *u8,\n-                                      ++addr: *sockaddr_in) -> libc::c_int;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n-                                   ++addr: *sockaddr_in) -> libc::c_int;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                                       tcp_handle_ptr: *uv_tcp_t,\n-                                       ++after_cb: *u8,\n-                                       ++addr: *sockaddr_in6) -> libc::c_int;\n-        // FIXME ref #2064\n-        unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n-                                    ++addr: *sockaddr_in6) -> libc::c_int;\n-        unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                                          ++name: *sockaddr_in)\n-                                       -> libc::c_int;\n-        unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                           ++name: *sockaddr_in6)\n-                                        -> libc::c_int;\n-        unsafe fn rust_uv_listen(stream: *libc::c_void,\n-                                 backlog: libc::c_int,\n-                                 cb: *u8) -> libc::c_int;\n-        unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n-                              -> libc::c_int;\n-        unsafe fn rust_uv_write(req: *libc::c_void,\n-                                stream: *libc::c_void,\n-                                ++buf_in: *uv_buf_t,\n-                                buf_cnt: libc::c_int,\n-                                cb: *u8)\n-                             -> libc::c_int;\n-        unsafe fn rust_uv_read_start(stream: *libc::c_void,\n-                                     on_alloc: *u8,\n-                                     on_read: *u8)\n-                                  -> libc::c_int;\n-        unsafe fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n-        unsafe fn rust_uv_timer_init(loop_handle: *libc::c_void,\n-                                     timer_handle: *uv_timer_t)\n-                                  -> libc::c_int;\n-        unsafe fn rust_uv_timer_start(\n-            timer_handle: *uv_timer_t,\n-            cb: *u8,\n-            timeout: libc::c_uint,\n-            repeat: libc::c_uint) -> libc::c_int;\n-        unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n-\n-        unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n-                                      handle: *uv_getaddrinfo_t,\n-                                      cb: *u8,\n-                                      node_name_ptr: *u8,\n-                                      service_name_ptr: *u8,\n-                                      // should probably only pass ptr::null()\n-                                      hints: *addrinfo)\n-                                   -> libc::c_int;\n-        unsafe fn rust_uv_freeaddrinfo(res: *addrinfo);\n-\n-        // data accessors/helpers for rust-mapped uv structs\n-        unsafe fn rust_uv_helper_get_INADDR_NONE() -> u32;\n-        unsafe fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n-        unsafe fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n-        unsafe fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n-        unsafe fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo)\n-                                               -> *sockaddr_in;\n-        unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n-                                                -> *sockaddr_in6;\n-        unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-        unsafe fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n-        unsafe fn rust_uv_get_stream_handle_from_connect_req(\n-            connect_req: *uv_connect_t)\n-            -> *uv_stream_t;\n-        unsafe fn rust_uv_get_stream_handle_from_write_req(\n-            write_req: *uv_write_t)\n-            -> *uv_stream_t;\n-        unsafe fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n-            -> *libc::c_void;\n-        unsafe fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void)\n-                                            -> *libc::c_void;\n-        unsafe fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                               data: *libc::c_void);\n-        unsafe fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n-                                              -> *libc::c_void;\n-        unsafe fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n-                                                 data: *libc::c_void);\n-        unsafe fn rust_uv_get_data_for_req(req: *libc::c_void)\n-                                        -> *libc::c_void;\n-        unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n+#[nolink]\n+extern mod rustrt {\n+\n+    // libuv public API\n+    unsafe fn rust_uv_loop_new() -> *libc::c_void;\n+    unsafe fn rust_uv_loop_delete(lp: *libc::c_void);\n+    unsafe fn rust_uv_run(loop_handle: *libc::c_void);\n+    unsafe fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n+    unsafe fn rust_uv_walk(loop_handle: *libc::c_void, cb: *u8,\n+                           arg: *libc::c_void);\n+\n+    unsafe fn rust_uv_idle_new() -> *uv_idle_t;\n+    unsafe fn rust_uv_idle_delete(handle: *uv_idle_t);\n+    unsafe fn rust_uv_idle_init(loop_handle: *uv_loop_t,\n+                                handle: *uv_idle_t) -> libc::c_int;\n+    unsafe fn rust_uv_idle_start(handle: *uv_idle_t,\n+                                 cb: uv_idle_cb) -> libc::c_int;\n+    unsafe fn rust_uv_idle_stop(handle: *uv_idle_t) -> libc::c_int;\n+\n+    unsafe fn rust_uv_async_send(handle: *uv_async_t);\n+    unsafe fn rust_uv_async_init(loop_handle: *libc::c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_init(\n+        loop_handle: *libc::c_void,\n+        handle_ptr: *uv_tcp_t) -> libc::c_int;\n+    // FIXME ref #2604 .. ?\n+    unsafe fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n+                        len: libc::size_t);\n+    unsafe fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n+    unsafe fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n+        -> sockaddr_in;\n+    unsafe fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n+        -> sockaddr_in6;\n+    unsafe fn rust_uv_ip4_name(src: *sockaddr_in,\n+                               dst: *u8,\n+                               size: libc::size_t)\n+                            -> libc::c_int;\n+    unsafe fn rust_uv_ip6_name(src: *sockaddr_in6,\n+                               dst: *u8,\n+                               size: libc::size_t)\n+                            -> libc::c_int;\n+    unsafe fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n+    unsafe fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                                  tcp_handle_ptr: *uv_tcp_t,\n+                                  ++after_cb: *u8,\n+                                  ++addr: *sockaddr_in) -> libc::c_int;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n+                               ++addr: *sockaddr_in) -> libc::c_int;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                                   tcp_handle_ptr: *uv_tcp_t,\n+                                   ++after_cb: *u8,\n+                                   ++addr: *sockaddr_in6) -> libc::c_int;\n+    // FIXME ref #2064\n+    unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n+                                ++addr: *sockaddr_in6) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                                      ++name: *sockaddr_in) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                                       ++name: *sockaddr_in6) ->libc::c_int;\n+    unsafe fn rust_uv_listen(stream: *libc::c_void,\n+                             backlog: libc::c_int,\n+                             cb: *u8) -> libc::c_int;\n+    unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n+                          -> libc::c_int;\n+    unsafe fn rust_uv_write(req: *libc::c_void,\n+                            stream: *libc::c_void,\n+                            ++buf_in: *uv_buf_t,\n+                            buf_cnt: libc::c_int,\n+                            cb: *u8)\n+        -> libc::c_int;\n+    unsafe fn rust_uv_read_start(stream: *libc::c_void,\n+                                 on_alloc: *u8,\n+                                 on_read: *u8)\n+        -> libc::c_int;\n+    unsafe fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n+    unsafe fn rust_uv_timer_init(loop_handle: *libc::c_void,\n+                                 timer_handle: *uv_timer_t)\n+        -> libc::c_int;\n+    unsafe fn rust_uv_timer_start(\n+        timer_handle: *uv_timer_t,\n+        cb: *u8,\n+        timeout: libc::c_uint,\n+        repeat: libc::c_uint) -> libc::c_int;\n+    unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n+\n+    unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n+                                  handle: *uv_getaddrinfo_t,\n+                                  cb: *u8,\n+                                  node_name_ptr: *u8,\n+                                  service_name_ptr: *u8,\n+                                  // should probably only pass ptr::null()\n+                                  hints: *addrinfo)\n+        -> libc::c_int;\n+    unsafe fn rust_uv_freeaddrinfo(res: *addrinfo);\n+\n+    // data accessors/helpers for rust-mapped uv structs\n+    unsafe fn rust_uv_helper_get_INADDR_NONE() -> u32;\n+    unsafe fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n+    unsafe fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n+    unsafe fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n+    unsafe fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo)\n+        -> *sockaddr_in;\n+    unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n+        -> *sockaddr_in6;\n+    unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n+    unsafe fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    unsafe fn rust_uv_get_stream_handle_from_connect_req(\n+        connect_req: *uv_connect_t)\n+        -> *uv_stream_t;\n+    unsafe fn rust_uv_get_stream_handle_from_write_req(\n+        write_req: *uv_write_t)\n+        -> *uv_stream_t;\n+    unsafe fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    unsafe fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void)\n+        -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n                                            data: *libc::c_void);\n-        unsafe fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-        unsafe fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n-\n-        // sizeof testing helpers\n-        unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n-        unsafe fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n-    }\n+    unsafe fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n+                                             data: *libc::c_void);\n+    unsafe fn rust_uv_get_data_for_req(req: *libc::c_void)\n+        -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n+                                       data: *libc::c_void);\n+    unsafe fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    unsafe fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+\n+    // sizeof testing helpers\n+    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n }\n \n pub unsafe fn loop_new() -> *libc::c_void {\n@@ -897,6 +899,27 @@ pub unsafe fn walk(loop_handle: *libc::c_void, cb: *u8, arg: *libc::c_void) {\n     rustrt::rust_uv_walk(loop_handle, cb, arg);\n }\n \n+pub unsafe fn idle_new() -> *uv_idle_t {\n+    rustrt::rust_uv_idle_new()\n+}\n+\n+pub unsafe fn idle_delete(handle: *uv_idle_t) {\n+    rustrt::rust_uv_idle_delete(handle)\n+}\n+\n+pub unsafe fn idle_init(loop_handle: *uv_loop_t,\n+                        handle: *uv_idle_t) -> libc::c_int {\n+    rustrt::rust_uv_idle_init(loop_handle, handle)\n+}\n+\n+pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> libc::c_int {\n+    rustrt::rust_uv_idle_start(handle, cb)\n+}\n+\n+pub unsafe fn idle_stop(handle: *uv_idle_t) -> libc::c_int {\n+    rustrt::rust_uv_idle_stop(handle)\n+}\n+\n pub unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n     -> libc::c_int {\n     return rustrt::rust_uv_tcp_init(loop_handle, handle);\n@@ -1215,19 +1238,11 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n     rustrt::rust_uv_addrinfo_as_sockaddr_in6(input)\n }\n \n-//#[cfg(test)]\n+#[cfg(test)]\n pub mod test {\n-    use core::prelude::*;\n-\n-    use uv_ll::*;\n-\n-    use core::comm::{SharedChan, stream};\n-    use core::libc;\n-    use core::ptr;\n-    use core::str;\n-    use core::sys;\n-    use core::task;\n-    use core::vec;\n+    use prelude::*;\n+    use super::*;\n+    use comm::{SharedChan, stream, GenericChan, GenericPort};\n \n     enum tcp_read_data {\n         tcp_read_eof,\n@@ -1473,7 +1488,7 @@ pub mod test {\n                 let client_data = get_data_for_uv_handle(\n                     client_stream_ptr as *libc::c_void) as *tcp_server_data;\n \n-                let server_kill_msg = (*client_data).server_kill_msg;\n+                let server_kill_msg = copy (*client_data).server_kill_msg;\n                 let write_req = (*client_data).server_write_req;\n                 if str::contains(request_str, server_kill_msg) {\n                     log(debug, ~\"SERVER: client req contains kill_msg!\");\n@@ -1606,8 +1621,8 @@ pub mod test {\n \n     fn impl_uv_tcp_server(server_ip: &str,\n                           server_port: int,\n-                          +kill_server_msg: ~str,\n-                          +server_resp_msg: ~str,\n+                          kill_server_msg: ~str,\n+                          server_resp_msg: ~str,\n                           server_chan: SharedChan<~str>,\n                           continue_chan: SharedChan<bool>) {\n         unsafe {\n@@ -1725,10 +1740,12 @@ pub mod test {\n             let (continue_port, continue_chan) = stream::<bool>();\n             let continue_chan = SharedChan(continue_chan);\n \n+            let kill_server_msg_copy = copy kill_server_msg;\n+            let server_resp_msg_copy = copy server_resp_msg;\n             do task::spawn_sched(task::ManualThreads(1)) {\n                 impl_uv_tcp_server(bind_ip, port,\n-                                   kill_server_msg,\n-                                   server_resp_msg,\n+                                   copy kill_server_msg_copy,\n+                                   copy server_resp_msg_copy,\n                                    server_chan.clone(),\n                                    continue_chan.clone());\n             };\n@@ -1738,9 +1755,10 @@ pub mod test {\n             continue_port.recv();\n             log(debug, ~\"received on continue port, set up tcp client\");\n \n+            let kill_server_msg_copy = copy kill_server_msg;\n             do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_tcp_request(request_ip, port,\n-                                   kill_server_msg,\n+                                   kill_server_msg_copy,\n                                    client_chan.clone());\n             };\n \n@@ -1760,24 +1778,22 @@ pub mod test {\n     pub mod tcp_and_server_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n         pub mod impl64 {\n-            use uv_ll::test::*;\n             #[test]\n             pub fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n-                    impl_uv_tcp_server_and_request();\n+                    super::super::impl_uv_tcp_server_and_request();\n                 }\n             }\n         }\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         #[cfg(target_arch=\"mips\")]\n         pub mod impl32 {\n-            use uv_ll::test::*;\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n             pub fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n-                    impl_uv_tcp_server_and_request();\n+                    super::super::impl_uv_tcp_server_and_request();\n                 }\n             }\n         }\n@@ -1804,7 +1820,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_tcp_t>(\n                 ~\"uv_tcp_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_tcp_t_size()\n+                super::rustrt::rust_uv_helper_uv_tcp_t_size()\n             );\n         }\n     }\n@@ -1813,7 +1829,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_connect_t>(\n                 ~\"uv_connect_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_connect_t_size()\n+                super::rustrt::rust_uv_helper_uv_connect_t_size()\n             );\n         }\n     }\n@@ -1822,7 +1838,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_buf_t>(\n                 ~\"uv_buf_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_buf_t_size()\n+                super::rustrt::rust_uv_helper_uv_buf_t_size()\n             );\n         }\n     }\n@@ -1831,7 +1847,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_write_t>(\n                 ~\"uv_write_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_write_t_size()\n+                super::rustrt::rust_uv_helper_uv_write_t_size()\n             );\n         }\n     }\n@@ -1841,15 +1857,15 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<sockaddr_in>(\n                 ~\"sockaddr_in\",\n-                ::uv_ll::rustrt::rust_uv_helper_sockaddr_in_size()\n+                super::rustrt::rust_uv_helper_sockaddr_in_size()\n             );\n         }\n     }\n     #[test]\n     fn test_uv_ll_struct_size_sockaddr_in6() {\n         unsafe {\n             let foreign_handle_size =\n-                ::uv_ll::rustrt::rust_uv_helper_sockaddr_in6_size();\n+                super::rustrt::rust_uv_helper_sockaddr_in6_size();\n             let rust_handle_size = sys::size_of::<sockaddr_in6>();\n             let output = fmt!(\"sockaddr_in6 -- foreign: %u rust: %u\",\n                               foreign_handle_size as uint, rust_handle_size);\n@@ -1868,7 +1884,7 @@ pub mod test {\n     fn test_uv_ll_struct_size_addr_in() {\n         unsafe {\n             let foreign_handle_size =\n-                ::uv_ll::rustrt::rust_uv_helper_addr_in_size();\n+                super::rustrt::rust_uv_helper_addr_in_size();\n             let rust_handle_size = sys::size_of::<addr_in>();\n             let output = fmt!(\"addr_in -- foreign: %u rust: %u\",\n                               foreign_handle_size as uint, rust_handle_size);\n@@ -1884,7 +1900,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_async_t>(\n                 ~\"uv_async_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_async_t_size()\n+                super::rustrt::rust_uv_helper_uv_async_t_size()\n             );\n         }\n     }\n@@ -1894,7 +1910,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_timer_t>(\n                 ~\"uv_timer_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_timer_t_size()\n+                super::rustrt::rust_uv_helper_uv_timer_t_size()\n             );\n         }\n     }\n@@ -1905,7 +1921,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_getaddrinfo_t>(\n                 ~\"uv_getaddrinfo_t\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_getaddrinfo_t_size()\n+                super::rustrt::rust_uv_helper_uv_getaddrinfo_t_size()\n             );\n         }\n     }\n@@ -1916,7 +1932,7 @@ pub mod test {\n         unsafe {\n             struct_size_check_common::<uv_timer_t>(\n                 ~\"addrinfo\",\n-                ::uv_ll::rustrt::rust_uv_helper_uv_timer_t_size()\n+                super::rustrt::rust_uv_helper_uv_timer_t_size()\n             );\n         }\n     }", "previous_filename": "src/libstd/uv_ll.rs"}, {"sha": "a5e689077738bdb9037c57953e28129d15607285", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -21,20 +21,20 @@ use core::vec;\n use iotask = uv::iotask::IoTask;\n use interact = uv::iotask::interact;\n \n-use sockaddr_in = uv::ll::sockaddr_in;\n-use sockaddr_in6 = uv::ll::sockaddr_in6;\n-use addrinfo = uv::ll::addrinfo;\n-use uv_getaddrinfo_t = uv::ll::uv_getaddrinfo_t;\n-use uv_ip4_name = uv::ll::ip4_name;\n-use uv_ip4_port = uv::ll::ip4_port;\n-use uv_ip6_name = uv::ll::ip6_name;\n-use uv_ip6_port = uv::ll::ip6_port;\n-use uv_getaddrinfo = uv::ll::getaddrinfo;\n-use uv_freeaddrinfo = uv::ll::freeaddrinfo;\n-use create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n-use set_data_for_req = uv::ll::set_data_for_req;\n-use get_data_for_req = uv::ll::get_data_for_req;\n-use ll = uv::ll;\n+use sockaddr_in = core::unstable::uvll::sockaddr_in;\n+use sockaddr_in6 = core::unstable::uvll::sockaddr_in6;\n+use addrinfo = core::unstable::uvll::addrinfo;\n+use uv_getaddrinfo_t = core::unstable::uvll::uv_getaddrinfo_t;\n+use uv_ip4_name = core::unstable::uvll::ip4_name;\n+use uv_ip4_port = core::unstable::uvll::ip4_port;\n+use uv_ip6_name = core::unstable::uvll::ip6_name;\n+use uv_ip6_port = core::unstable::uvll::ip6_port;\n+use uv_getaddrinfo = core::unstable::uvll::getaddrinfo;\n+use uv_freeaddrinfo = core::unstable::uvll::freeaddrinfo;\n+use create_uv_getaddrinfo_t = core::unstable::uvll::getaddrinfo_t;\n+use set_data_for_req = core::unstable::uvll::set_data_for_req;\n+use get_data_for_req = core::unstable::uvll::get_data_for_req;\n+use ll = core::unstable::uvll;\n \n /// An IP address\n pub enum IpAddr {"}, {"sha": "85e914a60a140fb14717c19899bdda7b32d12dee", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -36,6 +36,8 @@ not required in or otherwise suitable for the core library.\n extern mod core(vers = \"0.6\");\n use core::*;\n \n+pub use uv_ll = core::unstable::uvll;\n+\n // General io and system-services modules\n \n pub mod net;\n@@ -45,7 +47,6 @@ pub mod net_url;\n \n // libuv modules\n pub mod uv;\n-pub mod uv_ll;\n pub mod uv_iotask;\n pub mod uv_global_loop;\n "}, {"sha": "aaddc9b6836f3ae99a9b78ba5d565d5c255ceff6", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -33,6 +33,6 @@\n  * facilities.\n  */\n \n-pub use ll = uv_ll;\n+pub use ll = core::unstable::uvll;\n pub use iotask = uv_iotask;\n pub use global_loop = uv_global_loop;"}, {"sha": "576ab1db8ea03889eb7b2274654afe7c5c867230", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -1 +1 @@\n-Subproject commit 218ab86721eefd7b7e97fa6d9f95a80a1fa8686c\n+Subproject commit 576ab1db8ea03889eb7b2274654afe7c5c867230"}, {"sha": "d8b7281e72b753dc45166e12c8e77783ba537907", "filename": "src/rt/arch/i386/_context.S", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -15,9 +15,15 @@ getcontext.\n The registers_t variable is in (%esp)\n */\n \n+#if defined(__APPLE__) || defined(_WIN32)\n+#define SWAP_REGISTERS _swap_registers\n+#else\n+#define SWAP_REGISTERS swap_registers\n+#endif\n+\n // swap_registers(registers_t *oregs, registers_t *regs)\n-.globl swap_registers\n-swap_registers:\n+.globl SWAP_REGISTERS\n+SWAP_REGISTERS:\n     // save the old context\n     movl 4(%esp), %eax\n     movl %ebx, 4(%eax)"}, {"sha": "94e6f0418d07c230d5153eb8e3eca04e21626389", "filename": "src/rt/arch/i386/context.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.cpp?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -13,8 +13,7 @@\n #include \"../../rust_globals.h\"\n \n extern \"C\" uint32_t CDECL swap_registers(registers_t *oregs,\n-                                         registers_t *regs)\n-  asm (\"swap_registers\");\n+                                         registers_t *regs);\n \n context::context()\n {"}, {"sha": "1f9ae1c83c565d88bb460ba9464e239fe6e9c5cb", "filename": "src/rt/arch/x86_64/_context.S", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -49,9 +49,15 @@ First four arguments:\n         anyhow.\n */\t\n \n+#if defined(__APPLE__) || defined(_WIN32)\n+#define SWAP_REGISTERS _swap_registers\n+#else\n+#define SWAP_REGISTERS swap_registers\n+#endif\n+\n // swap_registers(registers_t *oregs, registers_t *regs)\n-.globl swap_registers\n-swap_registers:\n+.globl SWAP_REGISTERS\n+SWAP_REGISTERS:\n         // n.b. when we enter, the return address is at the top of\n         // the stack (i.e., 0(%RSP)) and the argument is in\n         // RUSTRT_ARG0_S.  We"}, {"sha": "6a265dff76156a7969f2d741829e1d7e119df674", "filename": "src/rt/arch/x86_64/context.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -13,8 +13,7 @@\n #include \"../../rust_globals.h\"\n \n extern \"C\" void CDECL swap_registers(registers_t *oregs,\n-                                     registers_t *regs)\n-asm (\"swap_registers\");\n+                                     registers_t *regs);\n \n context::context()\n {"}, {"sha": "d9ef6a52dbef6ee0bfd729d0f690cfa340aaee6c", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -21,6 +21,17 @@\n \n void* global_crate_map = NULL;\n \n+#ifndef _WIN32\n+pthread_key_t sched_key;\n+#else\n+DWORD sched_key;\n+#endif\n+\n+extern \"C\" void*\n+rust_get_sched_tls_key() {\n+    return &sched_key;\n+}\n+\n /**\n    The runtime entrypoint. The (C ABI) main function generated by rustc calls\n    `rust_start`, providing the address of the Rust ABI main function, the\n@@ -30,6 +41,10 @@ void* global_crate_map = NULL;\n extern \"C\" CDECL int\n rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n+#ifndef _WIN32\n+    pthread_key_create(&sched_key, NULL);\n+#endif\n+\n     // Load runtime configuration options from the environment.\n     // FIXME #1497: Should provide a way to get these from the command\n     // line as well."}, {"sha": "248f851e5b9f8064d2678b0881762eea8b951ef2", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -769,20 +769,20 @@ extern \"C\" CDECL void      record_sp_limit(void *limit);\n \n class raw_thread: public rust_thread {\n public:\n-    fn_env_pair *fn;\n+    fn_env_pair fn;\n \n-    raw_thread(fn_env_pair *fn) : fn(fn) { }\n+    raw_thread(fn_env_pair fn) : fn(fn) { }\n \n     virtual void run() {\n         record_sp_limit(0);\n-        fn->f(NULL, fn->env, NULL);\n+        fn.f(NULL, fn.env, NULL);\n     }\n };\n \n extern \"C\" raw_thread*\n rust_raw_thread_start(fn_env_pair *fn) {\n     assert(fn);\n-    raw_thread *thread = new raw_thread(fn);\n+    raw_thread *thread = new raw_thread(*fn);\n     thread->start();\n     return thread;\n }"}, {"sha": "515943487373329e37d0b4be0adb2f7d90359e9e", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -376,16 +376,7 @@ current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n \n extern \"C\" void\n rust_uv_buf_init(uv_buf_t* out_buf, char* base, size_t len) {\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib,\"rust_uv_buf_init: base: %lu\" \\\n-        \"len: %lu\",\n-        (unsigned long int)base,\n-        (unsigned long int)len);\n     *out_buf = uv_buf_init(base, len);\n-    LOG(task, stdlib, \"rust_uv_buf_init: after: \"\n-        \"result->base: %\" PRIxPTR \" len: %\" PRIxPTR,\n-           (unsigned long int)(*out_buf).base,\n-           (unsigned long int)(*out_buf).len);\n }\n \n extern \"C\" uv_loop_t*\n@@ -481,18 +472,11 @@ rust_uv_free_base_of_buf(uv_buf_t buf) {\n \n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib, \"before creating addr_ptr.. ip %s\" \\\n-        \" port %d\\n\", ip, port);\n     struct sockaddr_in addr = uv_ip4_addr(ip, port);\n-    LOG(task, stdlib, \"after creating .. port: %d\", addr.sin_port);\n     return addr;\n }\n extern \"C\" struct sockaddr_in6\n rust_uv_ip6_addr(const char* ip, int port) {\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib, \"before creating addr_ptr.. ip %s\" \\\n-        \" port %d\\n\", ip, port);\n     return uv_ip6_addr(ip, port);\n }\n extern \"C\" int\n@@ -554,3 +538,28 @@ extern \"C\" sockaddr_in6*\n rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n     return (sockaddr_in6*)input->ai_addr;\n }\n+\n+extern \"C\" uv_idle_t*\n+rust_uv_idle_new() {\n+  return new uv_idle_t;\n+}\n+\n+extern \"C\" void\n+rust_uv_idle_delete(uv_idle_t* handle) {\n+  delete handle;\n+}\n+\n+extern \"C\" int\n+rust_uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n+  return uv_idle_init(loop, idle);\n+}\n+\n+extern \"C\" int\n+rust_uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {\n+  return uv_idle_start(idle, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_idle_stop(uv_idle_t* idle) {\n+  return uv_idle_stop(idle);\n+}"}, {"sha": "e27e0d524050337e37afa7bdbbc0781eab906738", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "patch": "@@ -140,6 +140,11 @@ rust_uv_current_kernel_malloc\n rust_uv_current_kernel_free\n rust_uv_getaddrinfo\n rust_uv_freeaddrinfo\n+rust_uv_idle_new\n+rust_uv_idle_delete\n+rust_uv_idle_init\n+rust_uv_idle_start\n+rust_uv_idle_stop\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock\n@@ -187,3 +192,5 @@ rust_get_global_data_ptr\n rust_inc_kernel_live_count\n rust_dec_kernel_live_count\n rust_get_exchange_count_ptr\n+rust_get_sched_tls_key\n+swap_registers"}]}