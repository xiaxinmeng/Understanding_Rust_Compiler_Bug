{"sha": "34425c8c00e85d3480746ddc1eef466b6fc8a697", "node_id": "C_kwDOAAsO6NoAKDM0NDI1YzhjMDBlODVkMzQ4MDc0NmRkYzFlZWY0NjZiNmZjOGE2OTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-15T09:44:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-15T09:44:10Z"}, "message": "Rollup merge of #104258 - compiler-errors:tait-closure-deduce, r=oli-obk\n\nDeduce closure signature from a type alias `impl Trait`'s supertraits\n\nr? `@oli-obk`\n\nBasically pass the TAIT's bounds through the same method that we're using to deduce a signature from infer var closure bounds.\n\nDoes this need a new FCP? I see it as a logical extension of #101834, but happy to rfcbot a new one if it does.", "tree": {"sha": "d3451e54309b76a71473a69ca684cbb837e8fd33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3451e54309b76a71473a69ca684cbb837e8fd33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34425c8c00e85d3480746ddc1eef466b6fc8a697", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjc19qCRBK7hj4Ov3rIwAAmXIIABOQoiBxUUtAOnk9yf3z4Xw5\nXPMmRXDuEkMJozsMnlFa9DAWBOMelmjHtYbcvf7hq9G6wVJJ2DwqCWur+xGfGXHV\nwmo0lqQNZQE+wpad7UTRMH5iO+6DJJPECXS06cJyMB6aKr2qJ+ZVQ4MEEJ6CJM36\n4ipziWuNWh0Zx5kl82dyM+a8HAvgr8E47+jXV2Khq+hJdGyupniHJ+Bn4aJwFJIL\nBqjCGhBQePf0eJf349/vLt4U1ykclHdPvYJ+ujD4e/THeVbK2GsMogZKRJETZp6X\n0EDcrPs+EaD/iAC9p5fKDXVst+XIF3N0IqtdcsM0yJ9aWuZIys+kNtbuUt3PXZU=\n=QV61\n-----END PGP SIGNATURE-----\n", "payload": "tree d3451e54309b76a71473a69ca684cbb837e8fd33\nparent add6f14fbfbb5dfce58818559cbe6976dfe90c9e\nparent 9c8037c43070ab93bb66d1351901d717319e79c2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668505450 +0100\ncommitter GitHub <noreply@github.com> 1668505450 +0100\n\nRollup merge of #104258 - compiler-errors:tait-closure-deduce, r=oli-obk\n\nDeduce closure signature from a type alias `impl Trait`'s supertraits\n\nr? `@oli-obk`\n\nBasically pass the TAIT's bounds through the same method that we're using to deduce a signature from infer var closure bounds.\n\nDoes this need a new FCP? I see it as a logical extension of #101834, but happy to rfcbot a new one if it does.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34425c8c00e85d3480746ddc1eef466b6fc8a697", "html_url": "https://github.com/rust-lang/rust/commit/34425c8c00e85d3480746ddc1eef466b6fc8a697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34425c8c00e85d3480746ddc1eef466b6fc8a697/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add6f14fbfbb5dfce58818559cbe6976dfe90c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/add6f14fbfbb5dfce58818559cbe6976dfe90c9e", "html_url": "https://github.com/rust-lang/rust/commit/add6f14fbfbb5dfce58818559cbe6976dfe90c9e"}, {"sha": "9c8037c43070ab93bb66d1351901d717319e79c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8037c43070ab93bb66d1351901d717319e79c2", "html_url": "https://github.com/rust-lang/rust/commit/9c8037c43070ab93bb66d1351901d717319e79c2"}], "stats": {"total": 136, "additions": 94, "deletions": 42}, "files": [{"sha": "63062761b500d9ac8ebe62944cf859b0a9b87003", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/34425c8c00e85d3480746ddc1eef466b6fc8a697/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34425c8c00e85d3480746ddc1eef466b6fc8a697/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=34425c8c00e85d3480746ddc1eef466b6fc8a697", "patch": "@@ -173,34 +173,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(def_id, substs) => {\n-                let bounds = self.tcx.bound_explicit_item_bounds(def_id);\n-                let sig =\n-                    bounds.subst_iter_copied(self.tcx, substs).find_map(|(pred, span)| match pred\n-                        .kind()\n-                        .skip_binder()\n-                    {\n-                        ty::PredicateKind::Projection(proj_predicate) => self\n-                            .deduce_sig_from_projection(\n-                                Some(span),\n-                                pred.kind().rebind(proj_predicate),\n-                            ),\n-                        _ => None,\n-                    });\n-\n-                let kind = bounds\n-                    .0\n-                    .iter()\n-                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(tp) => {\n-                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n-                        }\n-                        _ => None,\n-                    })\n-                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n-                trace!(?sig, ?kind);\n-                (sig, kind)\n-            }\n+            ty::Opaque(def_id, substs) => self.deduce_signature_from_predicates(\n+                self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+            ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -211,7 +186,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n                 (sig, kind)\n             }\n-            ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n+                self.obligations_for_self_ty(vid).map(|obl| (obl.predicate, obl.cause.span)),\n+            ),\n             ty::FnPtr(sig) => {\n                 let expected_sig = ExpectedSig { cause_span: None, sig };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n@@ -220,19 +197,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn deduce_expectations_from_obligations(\n+    fn deduce_signature_from_predicates(\n         &self,\n-        expected_vid: ty::TyVid,\n+        predicates: impl DoubleEndedIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for obligation in traits::elaborate_obligations(\n+        for obligation in traits::elaborate_predicates_with_span(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n-            self.obligations_for_self_ty(expected_vid).rev().collect(),\n+            predicates.rev(),\n         ) {\n             debug!(?obligation.predicate);\n             let bound_predicate = obligation.predicate.kind();"}, {"sha": "c1cf7896db59a7df62c678dd2dfc3859481ec71f", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/34425c8c00e85d3480746ddc1eef466b6fc8a697/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34425c8c00e85d3480746ddc1eef466b6fc8a697/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=34425c8c00e85d3480746ddc1eef466b6fc8a697", "patch": "@@ -6,7 +6,6 @@ use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n-use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n@@ -19,7 +18,7 @@ use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n use std::slice;\n \n /// An entity in the Rust type system, which can be one of\n@@ -562,25 +561,86 @@ impl<T, U> EarlyBinder<(T, U)> {\n     }\n }\n \n-impl<'tcx, 's, T: IntoIterator<Item = I>, I: TypeFoldable<'tcx>> EarlyBinder<T> {\n+impl<'tcx, 's, I: IntoIterator> EarlyBinder<I>\n+where\n+    I::Item: TypeFoldable<'tcx>,\n+{\n     pub fn subst_iter(\n         self,\n         tcx: TyCtxt<'tcx>,\n         substs: &'s [GenericArg<'tcx>],\n-    ) -> impl Iterator<Item = I> + Captures<'s> + Captures<'tcx> {\n-        self.0.into_iter().map(move |t| EarlyBinder(t).subst(tcx, substs))\n+    ) -> SubstIter<'s, 'tcx, I> {\n+        SubstIter { it: self.0.into_iter(), tcx, substs }\n+    }\n+}\n+\n+pub struct SubstIter<'s, 'tcx, I: IntoIterator> {\n+    it: I::IntoIter,\n+    tcx: TyCtxt<'tcx>,\n+    substs: &'s [GenericArg<'tcx>],\n+}\n+\n+impl<'tcx, I: IntoIterator> Iterator for SubstIter<'_, 'tcx, I>\n+where\n+    I::Item: TypeFoldable<'tcx>,\n+{\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        Some(EarlyBinder(self.it.next()?).subst(self.tcx, self.substs))\n+    }\n+}\n+\n+impl<'tcx, I: IntoIterator> DoubleEndedIterator for SubstIter<'_, 'tcx, I>\n+where\n+    I::IntoIter: DoubleEndedIterator,\n+    I::Item: TypeFoldable<'tcx>,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        Some(EarlyBinder(self.it.next_back()?).subst(self.tcx, self.substs))\n     }\n }\n \n-impl<'tcx, 's, 'a, T: IntoIterator<Item = &'a I>, I: Copy + TypeFoldable<'tcx> + 'a>\n-    EarlyBinder<T>\n+impl<'tcx, 's, I: IntoIterator> EarlyBinder<I>\n+where\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Copy + TypeFoldable<'tcx>,\n {\n     pub fn subst_iter_copied(\n         self,\n         tcx: TyCtxt<'tcx>,\n         substs: &'s [GenericArg<'tcx>],\n-    ) -> impl Iterator<Item = I> + Captures<'s> + Captures<'tcx> + Captures<'a> {\n-        self.0.into_iter().map(move |t| EarlyBinder(*t).subst(tcx, substs))\n+    ) -> SubstIterCopied<'s, 'tcx, I> {\n+        SubstIterCopied { it: self.0.into_iter(), tcx, substs }\n+    }\n+}\n+\n+pub struct SubstIterCopied<'a, 'tcx, I: IntoIterator> {\n+    it: I::IntoIter,\n+    tcx: TyCtxt<'tcx>,\n+    substs: &'a [GenericArg<'tcx>],\n+}\n+\n+impl<'tcx, I: IntoIterator> Iterator for SubstIterCopied<'_, 'tcx, I>\n+where\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Copy + TypeFoldable<'tcx>,\n+{\n+    type Item = <I::Item as Deref>::Target;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        Some(EarlyBinder(*self.it.next()?).subst(self.tcx, self.substs))\n+    }\n+}\n+\n+impl<'tcx, I: IntoIterator> DoubleEndedIterator for SubstIterCopied<'_, 'tcx, I>\n+where\n+    I::IntoIter: DoubleEndedIterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Copy + TypeFoldable<'tcx>,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        Some(EarlyBinder(*self.it.next_back()?).subst(self.tcx, self.substs))\n     }\n }\n "}, {"sha": "d2c3479203573a74397ee21fd36d9c23c5fd849a", "filename": "src/test/ui/impl-trait/deduce-signature-from-supertrait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34425c8c00e85d3480746ddc1eef466b6fc8a697/src%2Ftest%2Fui%2Fimpl-trait%2Fdeduce-signature-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34425c8c00e85d3480746ddc1eef466b6fc8a697/src%2Ftest%2Fui%2Fimpl-trait%2Fdeduce-signature-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdeduce-signature-from-supertrait.rs?ref=34425c8c00e85d3480746ddc1eef466b6fc8a697", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait SuperExpectation: Fn(i32) {}\n+\n+impl<T: Fn(i32)> SuperExpectation for T {}\n+\n+type Foo = impl SuperExpectation;\n+\n+fn main() {\n+    let _: Foo = |x| {\n+        let _ = x.to_string();\n+    };\n+}"}]}