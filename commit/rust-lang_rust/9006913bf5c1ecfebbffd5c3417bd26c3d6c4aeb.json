{"sha": "9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMDY5MTNiZjVjMWVjZmViYmZmZDVjMzQxN2JkMjZjM2Q2YzRhZWI=", "commit": {"author": {"name": "Felix Rath", "email": "felixr@archlinux.info", "date": "2016-08-05T22:53:10Z"}, "committer": {"name": "Felix Rath", "email": "felixr@archlinux.info", "date": "2016-08-06T09:52:10Z"}, "message": "add warning timeout for tests that run >1min\n\nthis makes it easier to identify hanging tests", "tree": {"sha": "b3bc60306af5bdac979e86f143f93ef1a346c8a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3bc60306af5bdac979e86f143f93ef1a346c8a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "html_url": "https://github.com/rust-lang/rust/commit/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb/comments", "author": null, "committer": null, "parents": [{"sha": "ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa", "html_url": "https://github.com/rust-lang/rust/commit/ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "106c14850ca24582887e26ea33519c885e1ce1f8", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9006913bf5c1ecfebbffd5c3417bd26c3d6c4aeb", "patch": "@@ -42,6 +42,7 @@\n #![feature(staged_api)]\n #![feature(question_mark)]\n #![feature(panic_unwind)]\n+#![feature(mpsc_recv_timeout)]\n \n extern crate getopts;\n extern crate term;\n@@ -73,6 +74,8 @@ use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Instant, Duration};\n \n+const TEST_WARN_TIMEOUT_S: u64 = 60;\n+\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n@@ -592,6 +595,10 @@ impl<T: Write> ConsoleTestState<T> {\n         }\n     }\n \n+    pub fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\", desc.name, TEST_WARN_TIMEOUT_S))\n+    }\n+\n     pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n         match self.log_out {\n             None => Ok(()),\n@@ -709,6 +716,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n+            TeTimeout(ref test) => st.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log(&test, &result)?;\n                 st.write_result(&result)?;\n@@ -830,6 +838,7 @@ enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n+    TeTimeout(TestDesc),\n }\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n@@ -838,6 +847,9 @@ pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n     where F: FnMut(TestEvent) -> io::Result<()>\n {\n+    use std::collections::HashMap;\n+    use std::sync::mpsc::RecvTimeoutError;\n+\n     let mut filtered_tests = filter_tests(opts, tests);\n     if !opts.bench_benchmarks {\n         filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n@@ -867,6 +879,8 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n \n     let (tx, rx) = channel::<MonitorMsg>();\n \n+    let mut running_tests: HashMap<TestDesc, Duration> = HashMap::new();\n+\n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n@@ -876,11 +890,43 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n                 // that hang forever.\n                 callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n             }\n+            running_tests.insert(test.desc.clone(), Duration::from_secs(TEST_WARN_TIMEOUT_S));\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             pending += 1;\n         }\n \n-        let (desc, result, stdout) = rx.recv().unwrap();\n+        let mut res;\n+        if let Some(min_timeout) = running_tests.values().min().cloned() {\n+            loop {\n+                let before = Instant::now();\n+                res = rx.recv_timeout(min_timeout);\n+                let elapsed = Instant::now() - before;\n+\n+                let mut to_remove = Vec::new();\n+                for (desc, time_left) in &mut running_tests {\n+                    if *time_left >= elapsed {\n+                        *time_left -= elapsed;\n+                    } else {\n+                        to_remove.push(desc.clone());\n+                        callback(TeTimeout(desc.clone()))?;\n+                    }\n+                }\n+\n+                for rem in to_remove {\n+                    running_tests.remove(&rem);\n+                }\n+\n+                if res != Err(RecvTimeoutError::Timeout) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n+        }\n+\n+        let (desc, result, stdout) = res.unwrap();\n+        running_tests.remove(&desc);\n+\n         if concurrency != 1 {\n             callback(TeWait(desc.clone(), PadNone))?;\n         }"}]}