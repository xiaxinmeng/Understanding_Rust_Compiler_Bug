{"sha": "e2b337dc57b5309d19e25811d3de340cc7567285", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYjMzN2RjNTdiNTMwOWQxOWUyNTgxMWQzZGUzNDBjYzc1NjcyODU=", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2020-07-17T14:08:04Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2020-07-17T14:08:04Z"}, "message": "Teach bootstrap about target files vs target triples\n\n`rustc` allows passing in predefined target triples as well as JSON\ntarget specification files. This change allows bootstrap to have the\nfirst inkling about those differences. This allows building a\ncross-compiler for an out-of-tree architecture (even though that\ncompiler won't work for other reasons).\n\nEven if no one ever uses this functionality, I think the newtype\naround the `Interned<String>` improves the readability of the code.", "tree": {"sha": "acd36cc56f2b105a4a7aacc588545f84a4c78b7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acd36cc56f2b105a4a7aacc588545f84a4c78b7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2b337dc57b5309d19e25811d3de340cc7567285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b337dc57b5309d19e25811d3de340cc7567285", "html_url": "https://github.com/rust-lang/rust/commit/e2b337dc57b5309d19e25811d3de340cc7567285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2b337dc57b5309d19e25811d3de340cc7567285/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "html_url": "https://github.com/rust-lang/rust/commit/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50"}], "stats": {"total": 706, "additions": 390, "deletions": 316}, "files": [{"sha": "fff92549b341a5c64044f5a142bf0e68d5f39894", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -16,6 +16,7 @@ use build_helper::{output, t};\n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::doc;\n use crate::flags::Subcommand;\n@@ -86,8 +87,8 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub path: PathBuf,\n }\n \n@@ -576,7 +577,7 @@ impl<'a> Builder<'a> {\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n-    pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n+    pub fn compiler(&self, stage: u32, host: TargetSelection) -> Compiler {\n         self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n     }\n \n@@ -594,8 +595,8 @@ impl<'a> Builder<'a> {\n     pub fn compiler_for(\n         &self,\n         stage: u32,\n-        host: Interned<String>,\n-        target: Interned<String>,\n+        host: TargetSelection,\n+        target: TargetSelection,\n     ) -> Compiler {\n         if self.build.force_use_stage1(Compiler { stage, host }, target) {\n             self.compiler(1, self.config.build)\n@@ -610,15 +611,11 @@ impl<'a> Builder<'a> {\n \n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n-    pub fn sysroot_libdir(\n-        &self,\n-        compiler: Compiler,\n-        target: Interned<String>,\n-    ) -> Interned<PathBuf> {\n+    pub fn sysroot_libdir(&self, compiler: Compiler, target: TargetSelection) -> Interned<PathBuf> {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         struct Libdir {\n             compiler: Compiler,\n-            target: Interned<String>,\n+            target: TargetSelection,\n         }\n         impl Step for Libdir {\n             type Output = Interned<PathBuf>;\n@@ -633,7 +630,7 @@ impl<'a> Builder<'a> {\n                     .sysroot(self.compiler)\n                     .join(lib)\n                     .join(\"rustlib\")\n-                    .join(self.target)\n+                    .join(self.target.triple)\n                     .join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n@@ -656,7 +653,7 @@ impl<'a> Builder<'a> {\n                 Some(relative_libdir) if compiler.stage >= 1 => {\n                     self.sysroot(compiler).join(relative_libdir)\n                 }\n-                _ => self.sysroot(compiler).join(libdir(&compiler.host)),\n+                _ => self.sysroot(compiler).join(libdir(compiler.host)),\n             }\n         }\n     }\n@@ -668,11 +665,11 @@ impl<'a> Builder<'a> {\n     /// Windows.\n     pub fn libdir_relative(&self, compiler: Compiler) -> &Path {\n         if compiler.is_snapshot(self) {\n-            libdir(&self.config.build).as_ref()\n+            libdir(self.config.build).as_ref()\n         } else {\n             match self.config.libdir_relative() {\n                 Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n-                _ => libdir(&compiler.host).as_ref(),\n+                _ => libdir(compiler.host).as_ref(),\n             }\n         }\n     }\n@@ -707,7 +704,7 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n     }\n \n@@ -741,7 +738,7 @@ impl<'a> Builder<'a> {\n     ///\n     /// Note that this returns `None` if LLVM is disabled, or if we're in a\n     /// check build or dry-run, where there's no need to build all of LLVM.\n-    fn llvm_config(&self, target: Interned<String>) -> Option<PathBuf> {\n+    fn llvm_config(&self, target: TargetSelection) -> Option<PathBuf> {\n         if self.config.llvm_enabled() && self.kind != Kind::Check && !self.config.dry_run {\n             let llvm_config = self.ensure(native::Llvm { target });\n             if llvm_config.is_file() {\n@@ -763,7 +760,7 @@ impl<'a> Builder<'a> {\n         compiler: Compiler,\n         mode: Mode,\n         source_type: SourceType,\n-        target: Interned<String>,\n+        target: TargetSelection,\n         cmd: &str,\n     ) -> Cargo {\n         let mut cargo = Command::new(&self.initial_cargo);\n@@ -773,7 +770,7 @@ impl<'a> Builder<'a> {\n             let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n                 Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n-                Mode::Std => out_dir.join(target).join(\"doc\"),\n+                Mode::Std => out_dir.join(target.triple).join(\"doc\"),\n                 _ => panic!(\"doc mode {:?} not expected\", mode),\n             };\n             let rustdoc = self.rustdoc(compiler);\n@@ -795,7 +792,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd != \"install\" {\n-            cargo.arg(\"--target\").arg(target);\n+            cargo.arg(\"--target\").arg(target.rustc_target_arg());\n         } else {\n             assert_eq!(target, compiler.host);\n         }\n@@ -821,7 +818,7 @@ impl<'a> Builder<'a> {\n             compiler.stage\n         };\n \n-        let mut rustflags = Rustflags::new(&target);\n+        let mut rustflags = Rustflags::new(target);\n         if stage != 0 {\n             if let Ok(s) = env::var(\"CARGOFLAGS_NOT_BOOTSTRAP\") {\n                 cargo.args(s.split_whitespace());\n@@ -994,7 +991,7 @@ impl<'a> Builder<'a> {\n         // argument manually via `-C link-args=-Wl,-rpath,...`. Plus isn't it\n         // fun to pass a flag to a tool to pass a flag to pass a flag to a tool\n         // to change a flag in a binary?\n-        if self.config.rust_rpath && util::use_host_linker(&target) {\n+        if self.config.rust_rpath && util::use_host_linker(target) {\n             let rpath = if target.contains(\"apple\") {\n                 // Note that we need to take one extra step on macOS to also pass\n                 // `-Wl,-instal_name,@rpath/...` to get things to work right. To\n@@ -1022,7 +1019,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if let Some(target_linker) = self.linker(target, can_use_lld) {\n-            let target = crate::envify(&target);\n+            let target = crate::envify(&target.triple);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n         if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n@@ -1193,21 +1190,23 @@ impl<'a> Builder<'a> {\n                 }\n             };\n             let cc = ccacheify(&self.cc(target));\n-            cargo.env(format!(\"CC_{}\", target), &cc);\n+            cargo.env(format!(\"CC_{}\", target.triple), &cc);\n \n             let cflags = self.cflags(target, GitRepo::Rustc).join(\" \");\n-            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone());\n+            cargo.env(format!(\"CFLAGS_{}\", target.triple), cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo.env(format!(\"AR_{}\", target), ar).env(format!(\"RANLIB_{}\", target), ranlib);\n+                cargo\n+                    .env(format!(\"AR_{}\", target.triple), ar)\n+                    .env(format!(\"RANLIB_{}\", target.triple), ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n                 let cxx = ccacheify(&cxx);\n                 cargo\n-                    .env(format!(\"CXX_{}\", target), &cxx)\n-                    .env(format!(\"CXXFLAGS_{}\", target), cflags);\n+                    .env(format!(\"CXX_{}\", target.triple), &cxx)\n+                    .env(format!(\"CXXFLAGS_{}\", target.triple), cflags);\n             }\n         }\n \n@@ -1241,7 +1240,7 @@ impl<'a> Builder<'a> {\n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n-        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target.triple);\n \n         // Set this for all builds to make sure doc builds also get it.\n         cargo.env(\"CFG_RELEASE_CHANNEL\", &self.config.channel);\n@@ -1397,15 +1396,15 @@ mod tests;\n struct Rustflags(String);\n \n impl Rustflags {\n-    fn new(target: &str) -> Rustflags {\n+    fn new(target: TargetSelection) -> Rustflags {\n         let mut ret = Rustflags(String::new());\n \n         // Inherit `RUSTFLAGS` by default ...\n         ret.env(\"RUSTFLAGS\");\n \n         // ... and also handle target-specific env RUSTFLAGS if they're\n         // configured.\n-        let target_specific = format!(\"CARGO_TARGET_{}_RUSTFLAGS\", crate::envify(target));\n+        let target_specific = format!(\"CARGO_TARGET_{}_RUSTFLAGS\", crate::envify(&target.triple));\n         ret.env(&target_specific);\n \n         ret"}, {"sha": "69a54bec33b678ebbb8a062888100ea5f763f555", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -1,5 +1,5 @@\n use super::*;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use std::thread;\n \n use pretty_assertions::assert_eq;\n@@ -17,16 +17,16 @@ fn configure(host: &[&str], target: &[&str]) -> Config {\n         .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n     t!(fs::create_dir_all(&dir));\n     config.out = dir;\n-    config.build = INTERNER.intern_str(\"A\");\n+    config.build = TargetSelection::from_user(\"A\");\n     config.hosts = vec![config.build]\n         .into_iter()\n-        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .chain(host.iter().map(|s| TargetSelection::from_user(s)))\n         .collect::<Vec<_>>();\n     config.targets = config\n         .hosts\n         .clone()\n         .into_iter()\n-        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .chain(target.iter().map(|s| TargetSelection::from_user(s)))\n         .collect::<Vec<_>>();\n     config\n }\n@@ -41,7 +41,7 @@ fn dist_baseline() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n     assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n@@ -67,8 +67,8 @@ fn dist_with_targets() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -98,8 +98,8 @@ fn dist_with_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -128,8 +128,8 @@ fn dist_with_hosts() {\n \n #[test]\n fn dist_only_cross_host() {\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n     let mut build = Build::new(configure(&[\"B\"], &[]));\n     build.config.docs = false;\n     build.config.extended = true;\n@@ -156,9 +156,9 @@ fn dist_with_targets_and_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -194,9 +194,9 @@ fn dist_with_target_flag() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -224,8 +224,8 @@ fn dist_with_same_targets_and_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -277,9 +277,9 @@ fn build_default() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n@@ -318,9 +318,9 @@ fn build_with_target_flag() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n@@ -374,7 +374,7 @@ fn test_with_no_doc_stage0() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n \n-    let host = INTERNER.intern_str(\"A\");\n+    let host = TargetSelection::from_user(\"A\");\n \n     builder\n         .run_step_descriptions(&[StepDescription::from::<test::Crate>()], &[\"src/libstd\".into()]);\n@@ -428,7 +428,7 @@ fn doc_default() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     // error_index_generator uses stage 1 to share rustdoc artifacts with the\n     // rustdoc tool.\n@@ -466,7 +466,7 @@ fn test_docs() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     // error_index_generator uses stage 1 to share rustdoc artifacts with the\n     // rustdoc tool."}, {"sha": "7ff00d85dd2f24a0ea0d9bc8552e4d6960aadc11", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -28,16 +28,15 @@ use std::{env, iter};\n \n use build_helper::output;\n \n-use crate::cache::Interned;\n-use crate::config::Target;\n+use crate::config::{Target, TargetSelection};\n use crate::{Build, GitRepo};\n \n // The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n // so use some simplified logic here. First we respect the environment variable `AR`, then\n // try to infer the archiver path from the C compiler path.\n // In the future this logic should be replaced by calling into the `cc` crate.\n-fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.replace(\"-\", \"_\"))) {\n+fn cc2ar(cc: &Path, target: TargetSelection) -> Option<PathBuf> {\n+    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.triple.replace(\"-\", \"_\"))) {\n         Some(PathBuf::from(ar))\n     } else if let Some(ar) = env::var_os(\"AR\") {\n         Some(PathBuf::from(ar))\n@@ -79,8 +78,8 @@ pub fn find(build: &mut Build) {\n             .opt_level(2)\n             .warnings(false)\n             .debug(false)\n-            .target(&target)\n-            .host(&build.build);\n+            .target(&target.triple)\n+            .host(&build.build.triple);\n         match build.crt_static(target) {\n             Some(a) => {\n                 cfg.static_crt(a);\n@@ -106,10 +105,10 @@ pub fn find(build: &mut Build) {\n         let ar = if let ar @ Some(..) = config.and_then(|c| c.ar.clone()) {\n             ar\n         } else {\n-            cc2ar(compiler.path(), &target)\n+            cc2ar(compiler.path(), target)\n         };\n \n-        build.cc.insert(target, compiler);\n+        build.cc.insert(target, compiler.clone());\n         let cflags = build.cflags(target, GitRepo::Rustc);\n \n         // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n@@ -120,8 +119,8 @@ pub fn find(build: &mut Build) {\n             .warnings(false)\n             .debug(false)\n             .cpp(true)\n-            .target(&target)\n-            .host(&build.build);\n+            .target(&target.triple)\n+            .host(&build.build.triple);\n \n         let cxx_configured = if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n@@ -138,14 +137,14 @@ pub fn find(build: &mut Build) {\n             build.cxx.insert(target, compiler);\n         }\n \n-        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n-        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, cflags));\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target.triple, build.cc(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target.triple, cflags));\n         if let Ok(cxx) = build.cxx(target) {\n-            build.verbose(&format!(\"CXX_{} = {:?}\", &target, cxx));\n-            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target, cflags));\n+            build.verbose(&format!(\"CXX_{} = {:?}\", &target.triple, cxx));\n+            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target.triple, cflags));\n         }\n         if let Some(ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target.triple, ar));\n             build.ar.insert(target, ar);\n         }\n     }\n@@ -154,17 +153,18 @@ pub fn find(build: &mut Build) {\n fn set_compiler(\n     cfg: &mut cc::Build,\n     compiler: Language,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     config: Option<&Target>,\n     build: &Build,\n ) {\n-    match &*target {\n+    match &*target.triple {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n                 let target = target\n+                    .triple\n                     .replace(\"armv7neon\", \"arm\")\n                     .replace(\"armv7\", \"arm\")\n                     .replace(\"thumbv7neon\", \"arm\")"}, {"sha": "9f34bb4e6ccd73b159ab78cfd2b7112dae06cf62", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -1,15 +1,15 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, std_cargo};\n+use crate::config::TargetSelection;\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::{Compiler, Mode};\n use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n fn args(kind: Kind) -> Vec<String> {\n@@ -71,7 +71,7 @@ impl Step for Std {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rustc {\n@@ -127,7 +127,7 @@ macro_rules! tool_check_step {\n     ($name:ident, $path:expr, $source_type:expr) => {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n         pub struct $name {\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -163,8 +163,8 @@ macro_rules! tool_check_step {\n                 println!(\n                     \"Checking {} artifacts ({} -> {})\",\n                     stringify!($name).to_lowercase(),\n-                    &compiler.host,\n-                    target\n+                    &compiler.host.triple,\n+                    target.triple\n                 );\n                 run_cargo(\n                     builder,\n@@ -184,7 +184,7 @@ macro_rules! tool_check_step {\n                 fn stamp(\n                     builder: &Builder<'_>,\n                     compiler: Compiler,\n-                    target: Interned<String>,\n+                    target: TargetSelection,\n                 ) -> PathBuf {\n                     builder\n                         .cargo_out(compiler, Mode::ToolRustc, target)\n@@ -204,12 +204,12 @@ tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }"}, {"sha": "f83dfe8e635e3a759b9c3a8e82d6d87e28ab318d", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -23,7 +23,7 @@ pub fn clean(build: &Build, all: bool) {\n         rm_rf(&build.out.join(\"dist\"));\n \n         for host in &build.hosts {\n-            let entries = match build.out.join(host).read_dir() {\n+            let entries = match build.out.join(host.triple).read_dir() {\n                 Ok(iter) => iter,\n                 Err(_) => continue,\n             };"}, {"sha": "89b070e15e28699e4c9d0e277c66b2c3f35fd255", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -22,6 +22,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n@@ -30,7 +31,7 @@ use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -129,7 +130,7 @@ fn copy_and_stamp(\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<(PathBuf, DependencyType)> {\n     let mut target_deps = vec![];\n \n@@ -157,7 +158,7 @@ fn copy_third_party_objects(\n fn copy_self_contained_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<(PathBuf, DependencyType)> {\n     let libdir_self_contained = builder.sysroot_libdir(*compiler, target).join(\"self-contained\");\n     t!(fs::create_dir_all(&libdir_self_contained));\n@@ -206,7 +207,7 @@ fn copy_self_contained_objects(\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, cargo: &mut Cargo) {\n+pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -301,7 +302,7 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, ca\n struct StdLink {\n     pub compiler: Compiler,\n     pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for StdLink {\n@@ -337,7 +338,7 @@ impl Step for StdLink {\n fn copy_sanitizers(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<PathBuf> {\n     let runtimes: Vec<native::SanitizerRuntime> = builder.ensure(native::Sanitizers { target });\n \n@@ -372,7 +373,7 @@ fn copy_sanitizers(\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct StartupObjects {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for StartupObjects {\n@@ -419,7 +420,7 @@ impl Step for StartupObjects {\n                         .arg(\"--cfg\")\n                         .arg(\"bootstrap\")\n                         .arg(\"--target\")\n-                        .arg(target)\n+                        .arg(target.rustc_target_arg())\n                         .arg(\"--emit=obj\")\n                         .arg(\"-o\")\n                         .arg(dst_file)\n@@ -438,7 +439,7 @@ impl Step for StartupObjects {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -518,7 +519,7 @@ impl Step for Rustc {\n     }\n }\n \n-pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n+pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n     cargo\n         .arg(\"--features\")\n         .arg(builder.rustc_features())\n@@ -527,7 +528,7 @@ pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<St\n     rustc_cargo_env(builder, cargo, target);\n }\n \n-pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n+pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo\n@@ -608,7 +609,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n struct RustcLink {\n     pub compiler: Compiler,\n     pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustcLink {\n@@ -638,11 +639,7 @@ impl Step for RustcLink {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+pub fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n@@ -651,15 +648,15 @@ pub fn libstd_stamp(\n pub fn librustc_stamp(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n pub fn compiler_file(\n     builder: &Builder<'_>,\n     compiler: &Path,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     file: &str,\n ) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n@@ -690,9 +687,9 @@ impl Step for Sysroot {\n     fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n-            builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n+            builder.out.join(&compiler.host.triple).join(\"stage0-sysroot\")\n         } else {\n-            builder.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n+            builder.out.join(&compiler.host.triple).join(format!(\"stage{}\", compiler.stage))\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n@@ -806,8 +803,8 @@ impl Step for Assemble {\n \n         let libdir = builder.sysroot_libdir(target_compiler, target_compiler.host);\n         if let Some(lld_install) = lld_install {\n-            let src_exe = exe(\"lld\", &target_compiler.host);\n-            let dst_exe = exe(\"rust-lld\", &target_compiler.host);\n+            let src_exe = exe(\"lld\", target_compiler.host);\n+            let dst_exe = exe(\"rust-lld\", target_compiler.host);\n             // we prepend this bin directory to the user PATH when linking Rust binaries. To\n             // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n             let dst = libdir.parent().unwrap().join(\"bin\");\n@@ -822,7 +819,7 @@ impl Step for Assemble {\n \n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n-        let rustc = out_dir.join(exe(\"rustc_binary\", &*host));\n+        let rustc = out_dir.join(exe(\"rustc_binary\", host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);"}, {"sha": "d71f31704209eb1b895956fe5acd46f37589509f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -7,6 +7,7 @@ use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::ffi::OsString;\n+use std::fmt;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -39,7 +40,7 @@ pub struct Config {\n     pub docs: bool,\n     pub locked_deps: bool,\n     pub vendor: bool,\n-    pub target_config: HashMap<Interned<String>, Target>,\n+    pub target_config: HashMap<TargetSelection, Target>,\n     pub full_bootstrap: bool,\n     pub extended: bool,\n     pub tools: Option<HashSet<String>>,\n@@ -112,9 +113,9 @@ pub struct Config {\n     pub rust_thin_lto_import_instr_limit: Option<u32>,\n     pub rust_remap_debuginfo: bool,\n \n-    pub build: Interned<String>,\n-    pub hosts: Vec<Interned<String>>,\n-    pub targets: Vec<Interned<String>>,\n+    pub build: TargetSelection,\n+    pub hosts: Vec<TargetSelection>,\n+    pub targets: Vec<TargetSelection>,\n     pub local_rebuild: bool,\n     pub jemalloc: bool,\n     pub control_flow_guard: bool,\n@@ -158,6 +159,67 @@ pub struct Config {\n     pub out: PathBuf,\n }\n \n+#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct TargetSelection {\n+    pub triple: Interned<String>,\n+    file: Option<Interned<String>>,\n+}\n+\n+impl TargetSelection {\n+    pub fn from_user(selection: &str) -> Self {\n+        let path = Path::new(selection);\n+\n+        let (triple, file) = if path.exists() {\n+            let triple = path\n+                .file_stem()\n+                .expect(\"Target specification file has no file stem\")\n+                .to_str()\n+                .expect(\"Target specification file stem is not UTF-8\");\n+\n+            (triple, Some(selection))\n+        } else {\n+            (selection, None)\n+        };\n+\n+        let triple = INTERNER.intern_str(triple);\n+        let file = file.map(|f| INTERNER.intern_str(f));\n+\n+        Self { triple, file }\n+    }\n+\n+    pub fn rustc_target_arg(&self) -> &str {\n+        self.file.as_ref().unwrap_or(&self.triple)\n+    }\n+\n+    pub fn contains(&self, needle: &str) -> bool {\n+        self.triple.contains(needle)\n+    }\n+\n+    pub fn starts_with(&self, needle: &str) -> bool {\n+        self.triple.starts_with(needle)\n+    }\n+\n+    pub fn ends_with(&self, needle: &str) -> bool {\n+        self.triple.ends_with(needle)\n+    }\n+}\n+\n+impl fmt::Display for TargetSelection {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.triple)?;\n+        if let Some(file) = self.file {\n+            write!(f, \"({})\", file)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl PartialEq<&str> for TargetSelection {\n+    fn eq(&self, other: &&str) -> bool {\n+        self.triple == *other\n+    }\n+}\n+\n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n pub struct Target {\n@@ -403,7 +465,7 @@ impl Config {\n         config.missing_tools = false;\n \n         // set by bootstrap.py\n-        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.build = TargetSelection::from_user(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n         config.src = Config::path_from_python(\"SRC\");\n         config.out = Config::path_from_python(\"BUILD_DIR\");\n \n@@ -464,14 +526,16 @@ impl Config {\n         let build = toml.build.clone().unwrap_or_default();\n         // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n-        for host in build.host.iter() {\n-            let host = INTERNER.intern_str(host);\n+        for host in build.host.iter().map(|h| TargetSelection::from_user(h)) {\n             if !config.hosts.contains(&host) {\n                 config.hosts.push(host);\n             }\n         }\n-        for target in\n-            config.hosts.iter().cloned().chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n+        for target in config\n+            .hosts\n+            .iter()\n+            .copied()\n+            .chain(build.target.iter().map(|h| TargetSelection::from_user(h)))\n         {\n             if !config.targets.contains(&target) {\n                 config.targets.push(target);\n@@ -637,7 +701,7 @@ impl Config {\n                 target.wasi_root = cfg.wasi_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n-                config.target_config.insert(INTERNER.intern_string(triple.clone()), target);\n+                config.target_config.insert(TargetSelection::from_user(triple), target);\n             }\n         }\n "}, {"sha": "af30747a9592e6dcaf4eccaa226ba34f0c1d06cb", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -20,6 +20,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::channel;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n@@ -68,7 +69,7 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for Docs {\n@@ -131,7 +132,7 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for RustcDocs {\n@@ -210,11 +211,11 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n fn make_win_dist(\n     rust_root: &Path,\n     plat_root: &Path,\n-    target_triple: Interned<String>,\n+    target: TargetSelection,\n     builder: &Builder<'_>,\n ) {\n     //Ask gcc where it keeps its stuff\n-    let mut cmd = Command::new(builder.cc(target_triple));\n+    let mut cmd = Command::new(builder.cc(target));\n     cmd.arg(\"-print-search-dirs\");\n     let gcc_out = output(&mut cmd);\n \n@@ -234,16 +235,16 @@ fn make_win_dist(\n         }\n     }\n \n-    let compiler = if target_triple == \"i686-pc-windows-gnu\" {\n+    let compiler = if target == \"i686-pc-windows-gnu\" {\n         \"i686-w64-mingw32-gcc.exe\"\n-    } else if target_triple == \"x86_64-pc-windows-gnu\" {\n+    } else if target == \"x86_64-pc-windows-gnu\" {\n         \"x86_64-w64-mingw32-gcc.exe\"\n     } else {\n         \"gcc.exe\"\n     };\n     let target_tools = [compiler, \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libwinpthread-1.dll\"];\n-    if target_triple.starts_with(\"i686-\") {\n+    if target.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n     } else {\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n@@ -311,7 +312,7 @@ fn make_win_dist(\n     let target_bin_dir = plat_root\n         .join(\"lib\")\n         .join(\"rustlib\")\n-        .join(target_triple)\n+        .join(target.triple)\n         .join(\"bin\")\n         .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n@@ -331,7 +332,7 @@ fn make_win_dist(\n     let target_lib_dir = plat_root\n         .join(\"lib\")\n         .join(\"rustlib\")\n-        .join(target_triple)\n+        .join(target.triple)\n         .join(\"lib\")\n         .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n@@ -342,7 +343,7 @@ fn make_win_dist(\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for Mingw {\n@@ -530,11 +531,11 @@ impl Step for Rustc {\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n-                let exe = exe(\"rust-lld\", &compiler.host);\n+                let exe = exe(\"rust-lld\", compiler.host);\n                 let src =\n                     builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\").join(&exe);\n                 // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n-                let dst = image.join(\"lib/rustlib\").join(&*host).join(\"bin\").join(&exe);\n+                let dst = image.join(\"lib/rustlib\").join(&*host.triple).join(\"bin\").join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n                 builder.copy(&src, &dst);\n             }\n@@ -592,7 +593,7 @@ impl Step for Rustc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct DebuggerScripts {\n     pub sysroot: Interned<PathBuf>,\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for DebuggerScripts {\n@@ -662,8 +663,8 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n }\n \n /// Copy stamped files into an image's `target/lib` directory.\n-fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n-    let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+fn copy_target_libs(builder: &Builder<'_>, target: TargetSelection, image: &Path, stamp: &Path) {\n+    let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"lib\");\n     let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n     t!(fs::create_dir_all(&self_contained_dst));\n@@ -679,7 +680,7 @@ fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &P\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Std {\n@@ -718,7 +719,7 @@ impl Step for Std {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, &target, &image, &stamp);\n+        copy_target_libs(builder, target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -747,7 +748,7 @@ impl Step for Std {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDev {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustcDev {\n@@ -787,7 +788,7 @@ impl Step for RustcDev {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::librustc_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, &target, &image, &stamp);\n+        copy_target_libs(builder, target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -818,7 +819,7 @@ impl Step for RustcDev {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Analysis {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Analysis {\n@@ -861,12 +862,12 @@ impl Step for Analysis {\n \n         let src = builder\n             .stage_out(compiler, Mode::Std)\n-            .join(target)\n+            .join(target.triple)\n             .join(builder.cargo_dir())\n             .join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n-        let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n+        let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n         builder.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n         builder.cp_r(&image_src, &dst);\n@@ -1163,7 +1164,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -1255,7 +1256,7 @@ impl Step for Cargo {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rls {\n@@ -1345,7 +1346,7 @@ impl Step for Rls {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustAnalyzer {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustAnalyzer {\n@@ -1432,7 +1433,7 @@ impl Step for RustAnalyzer {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Clippy {\n@@ -1523,7 +1524,7 @@ impl Step for Clippy {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Miri {\n@@ -1620,7 +1621,7 @@ impl Step for Miri {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rustfmt {\n@@ -1714,8 +1715,8 @@ impl Step for Rustfmt {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n-    host: Interned<String>,\n-    target: Interned<String>,\n+    host: TargetSelection,\n+    target: TargetSelection,\n }\n \n impl Step for Extended {\n@@ -2255,7 +2256,7 @@ impl Step for Extended {\n     }\n }\n \n-fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: TargetSelection) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n         .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n@@ -2266,7 +2267,7 @@ fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n         .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n         .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n         .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n-        .env(\"CFG_BUILD\", target)\n+        .env(\"CFG_BUILD\", target.triple)\n         .env(\"CFG_CHANNEL\", &builder.config.channel);\n \n     if target.contains(\"windows-gnu\") {\n@@ -2348,7 +2349,7 @@ impl Step for HashSign {\n ///\n /// Note: This function does not yet support Windows, but we also don't support\n ///       linking LLVM tools dynamically on Windows yet.\n-fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdir: &Path) {\n+fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir: &Path) {\n     let src_libdir = builder.llvm_out(target).join(\"lib\");\n \n     if target.contains(\"apple-darwin\") {\n@@ -2373,21 +2374,21 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdi\n }\n \n /// Maybe add libLLVM.so to the target lib-dir for linking.\n-pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n-    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target.triple).join(\"lib\");\n     maybe_install_llvm(builder, target, &dst_libdir);\n }\n \n /// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n-pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n     let dst_libdir =\n         sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n     maybe_install_llvm(builder, target, &dst_libdir);\n }\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for LlvmTools {\n@@ -2425,10 +2426,10 @@ impl Step for LlvmTools {\n \n         // Prepare the image directory\n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n-        let dst_bindir = image.join(\"lib/rustlib\").join(&*target).join(\"bin\");\n+        let dst_bindir = image.join(\"lib/rustlib\").join(&*target.triple).join(\"bin\");\n         t!(fs::create_dir_all(&dst_bindir));\n         for tool in LLVM_TOOLS {\n-            let exe = src_bindir.join(exe(tool, &target));\n+            let exe = src_bindir.join(exe(tool, target));\n             builder.install(&exe, &dst_bindir, 0o755);\n         }\n "}, {"sha": "b051390fc2671f73b7fe1f134717b5e8a4bc4dec", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -18,7 +18,7 @@ use build_helper::{t, up_to_date};\n use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use crate::tool::{self, prepare_tool_cargo, SourceType, Tool};\n use crate::util::symlink_dir;\n \n@@ -27,7 +27,7 @@ macro_rules! book {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            target: Interned<String>,\n+            target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -101,7 +101,7 @@ fn is_explicit_request(builder: &Builder<'_>, path: &str) -> bool {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for UnstableBook {\n@@ -129,7 +129,7 @@ impl Step for UnstableBook {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n struct RustbookSrc {\n-    target: Interned<String>,\n+    target: TargetSelection,\n     name: Interned<String>,\n     src: Interned<PathBuf>,\n }\n@@ -169,7 +169,7 @@ impl Step for RustbookSrc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct TheBook {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for TheBook {\n@@ -241,7 +241,7 @@ impl Step for TheBook {\n fn invoke_rustdoc(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     markdown: &str,\n ) {\n     let out = builder.doc_out(target);\n@@ -277,7 +277,7 @@ fn invoke_rustdoc(\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Standalone {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Standalone {\n@@ -386,7 +386,7 @@ impl Step for Standalone {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub stage: u32,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Std {\n@@ -415,7 +415,7 @@ impl Step for Std {\n         let compiler = builder.compiler(stage, builder.config.build);\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Std).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::Std).join(target.triple).join(\"doc\");\n \n         t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n@@ -475,7 +475,7 @@ impl Step for Std {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     stage: u32,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Rustc {\n@@ -522,7 +522,7 @@ impl Step for Rustc {\n         // needed because rustdoc is built in a different directory from\n         // rustc. rustdoc needs to be able to see everything, for example when\n         // merging the search index, or generating local (relative) links.\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target.triple).join(\"doc\");\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         // Build cargo command.\n@@ -559,7 +559,7 @@ impl Step for Rustc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Rustdoc {\n@@ -604,7 +604,7 @@ impl Step for Rustdoc {\n         builder.ensure(tool::Rustdoc { compiler });\n \n         // Symlink compiler docs to the output directory of rustdoc documentation.\n-        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target.triple).join(\"doc\");\n         t!(fs::create_dir_all(&out_dir));\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n@@ -632,7 +632,7 @@ impl Step for Rustdoc {\n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for ErrorIndex {\n@@ -672,7 +672,7 @@ impl Step for ErrorIndex {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBookGen {\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for UnstableBookGen {"}, {"sha": "1055689c81e6a7680d5f4fd1e25c6175e9025ac4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -10,8 +10,7 @@ use std::process;\n use getopts::Options;\n \n use crate::builder::Builder;\n-use crate::cache::{Interned, INTERNER};\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use crate::{Build, DocTests};\n \n /// Deserialized version of all flags for this compile.\n@@ -21,8 +20,8 @@ pub struct Flags {\n     pub stage: Option<u32>,\n     pub keep_stage: Vec<u32>,\n \n-    pub host: Vec<Interned<String>>,\n-    pub target: Vec<Interned<String>>,\n+    pub host: Vec<TargetSelection>,\n+    pub target: Vec<TargetSelection>,\n     pub config: Option<PathBuf>,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n@@ -532,11 +531,11 @@ Arguments:\n                 .collect(),\n             host: split(&matches.opt_strs(\"host\"))\n                 .into_iter()\n-                .map(|x| INTERNER.intern_string(x))\n+                .map(|x| TargetSelection::from_user(&x))\n                 .collect::<Vec<_>>(),\n             target: split(&matches.opt_strs(\"target\"))\n                 .into_iter()\n-                .map(|x| INTERNER.intern_string(x))\n+                .map(|x| TargetSelection::from_user(&x))\n                 .collect::<Vec<_>>(),\n             config: cfg_file,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),"}, {"sha": "7266625ff39f89176dc3b51c7c4a0a562d871345", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -14,46 +14,47 @@ use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n \n-pub fn install_docs(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_docs(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n-pub fn install_std(builder: &Builder<'_>, stage: u32, target: Interned<String>) {\n+pub fn install_std(builder: &Builder<'_>, stage: u32, target: TargetSelection) {\n     install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n }\n \n-pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n }\n \n-pub fn install_rls(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rls(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n-pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+\n+pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rust-analyzer\", \"rust-analyzer\", stage, Some(host));\n }\n-pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+\n+pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n }\n-pub fn install_miri(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_miri(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n }\n \n-pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n }\n \n-pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n \n pub fn install_src(builder: &Builder<'_>, stage: u32) {\n     install_sh(builder, \"src\", \"rust-src\", stage, None);\n }\n-pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n }\n \n@@ -62,7 +63,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>,\n+    host: Option<TargetSelection>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -150,7 +151,7 @@ macro_rules! install {\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl $name {"}, {"sha": "77820ef87e3b470399217ffcbcb9c33128bcfe76", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -123,6 +123,7 @@ use std::os::windows::fs::symlink_file;\n use build_helper::{mtime, output, run, run_suppressed, t, try_run, try_run_suppressed};\n use filetime::FileTime;\n \n+use crate::config::TargetSelection;\n use crate::util::{exe, libdir, CiEnv};\n \n mod builder;\n@@ -187,7 +188,7 @@ const LLVM_TOOLS: &[&str] = &[\n #[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n@@ -236,9 +237,9 @@ pub struct Build {\n     verbosity: usize,\n \n     // Targets for which to build\n-    build: Interned<String>,\n-    hosts: Vec<Interned<String>>,\n-    targets: Vec<Interned<String>>,\n+    build: TargetSelection,\n+    hosts: Vec<TargetSelection>,\n+    targets: Vec<TargetSelection>,\n \n     // Stage 0 (downloaded) compiler, lld and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n@@ -248,18 +249,18 @@ pub struct Build {\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n-    cc: HashMap<Interned<String>, cc::Tool>,\n-    cxx: HashMap<Interned<String>, cc::Tool>,\n-    ar: HashMap<Interned<String>, PathBuf>,\n-    ranlib: HashMap<Interned<String>, PathBuf>,\n+    cc: HashMap<TargetSelection, cc::Tool>,\n+    cxx: HashMap<TargetSelection, cc::Tool>,\n+    ar: HashMap<TargetSelection, PathBuf>,\n+    ranlib: HashMap<TargetSelection, PathBuf>,\n     // Miscellaneous\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n     prerelease_version: Cell<Option<u32>>,\n     tool_artifacts:\n-        RefCell<HashMap<Interned<String>, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,\n+        RefCell<HashMap<TargetSelection, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,\n }\n \n #[derive(Debug)]\n@@ -365,7 +366,7 @@ impl Build {\n             output(\n                 Command::new(&config.initial_rustc)\n                     .arg(\"--target\")\n-                    .arg(config.build)\n+                    .arg(config.build.rustc_target_arg())\n                     .arg(\"--print\")\n                     .arg(\"target-libdir\"),\n             )\n@@ -453,7 +454,7 @@ impl Build {\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n-        unsafe { slice::from_raw_parts(&self.build, 1) }\n+        slice::from_ref(&self.build.triple)\n     }\n \n     /// Executes the entire build, as configured by the flags and configuration.\n@@ -558,7 +559,10 @@ impl Build {\n     }\n \n     fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n-        let out = self.out.join(&*compiler.host).join(format!(\"stage{}-tools-bin\", compiler.stage));\n+        let out = self\n+            .out\n+            .join(&*compiler.host.triple)\n+            .join(format!(\"stage{}-tools-bin\", compiler.stage));\n         t!(fs::create_dir_all(&out));\n         out\n     }\n@@ -575,69 +579,69 @@ impl Build {\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n             Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n-        self.out.join(&*compiler.host).join(format!(\"stage{}{}\", compiler.stage, suffix))\n+        self.out.join(&*compiler.host.triple).join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular compiler, whether or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self, compiler: Compiler, mode: Mode, target: Interned<String>) -> PathBuf {\n-        self.stage_out(compiler, mode).join(&*target).join(self.cargo_dir())\n+    fn cargo_out(&self, compiler: Compiler, mode: Mode, target: TargetSelection) -> PathBuf {\n+        self.stage_out(compiler, mode).join(&*target.triple).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n     ///\n     /// Note that if LLVM is configured externally then the directory returned\n     /// will likely be empty.\n-    fn llvm_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"llvm\")\n+    fn llvm_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"llvm\")\n     }\n \n-    fn lld_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"lld\")\n+    fn lld_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"lld\")\n     }\n \n     /// Output directory for all documentation for a target\n-    fn doc_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"doc\")\n+    fn doc_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"doc\")\n     }\n \n     /// Output directory for all documentation for a target\n-    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"compiler-doc\")\n+    fn compiler_doc_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"compiler-doc\")\n     }\n \n     /// Output directory for some generated md crate documentation for a target (temporary)\n-    fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n-        INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n+    fn md_doc_out(&self, target: TargetSelection) -> Interned<PathBuf> {\n+        INTERNER.intern_path(self.out.join(&*target.triple).join(\"md-doc\"))\n     }\n \n     /// Returns `true` if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n-    fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n+    fn is_rust_llvm(&self, target: TargetSelection) -> bool {\n         match self.config.target_config.get(&target) {\n             Some(ref c) => c.llvm_config.is_none(),\n             None => true,\n         }\n     }\n \n     /// Returns the path to `FileCheck` binary for the specified target\n-    fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n+    fn llvm_filecheck(&self, target: TargetSelection) -> PathBuf {\n         let target_config = self.config.target_config.get(&target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_filecheck.as_ref()) {\n             s.to_path_buf()\n         } else if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n-            let filecheck = Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target));\n+            let filecheck = Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", target));\n             if filecheck.exists() {\n                 filecheck\n             } else {\n                 // On Fedora the system LLVM installs FileCheck in the\n                 // llvm subdirectory of the libdir.\n                 let llvm_libdir = output(Command::new(s).arg(\"--libdir\"));\n                 let lib_filecheck =\n-                    Path::new(llvm_libdir.trim()).join(\"llvm\").join(exe(\"FileCheck\", &*target));\n+                    Path::new(llvm_libdir.trim()).join(\"llvm\").join(exe(\"FileCheck\", target));\n                 if lib_filecheck.exists() {\n                     lib_filecheck\n                 } else {\n@@ -662,18 +666,18 @@ impl Build {\n             } else {\n                 base\n             };\n-            base.join(\"bin\").join(exe(\"FileCheck\", &*target))\n+            base.join(\"bin\").join(exe(\"FileCheck\", target))\n         }\n     }\n \n     /// Directory for libraries built from C/C++ code and shared between stages.\n-    fn native_dir(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"native\")\n+    fn native_dir(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"native\")\n     }\n \n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n-    fn test_helpers_out(&self, target: Interned<String>) -> PathBuf {\n+    fn test_helpers_out(&self, target: TargetSelection) -> PathBuf {\n         self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n@@ -686,7 +690,7 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n-        self.rustc_snapshot_sysroot().join(libdir(&self.config.build))\n+        self.rustc_snapshot_sysroot().join(libdir(self.config.build))\n     }\n \n     /// Returns the sysroot of the snapshot compiler.\n@@ -784,13 +788,13 @@ impl Build {\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n-    fn cc(&self, target: Interned<String>) -> &Path {\n+    fn cc(&self, target: TargetSelection) -> &Path {\n         self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n-    fn cflags(&self, target: Interned<String>, which: GitRepo) -> Vec<String> {\n+    fn cflags(&self, target: TargetSelection, which: GitRepo) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n         let mut base = self.cc[&target]\n@@ -811,7 +815,7 @@ impl Build {\n         // Work around an apparently bad MinGW / GCC optimization,\n         // See: http://lists.llvm.org/pipermail/cfe-dev/2016-December/051980.html\n         // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78936\n-        if &*target == \"i686-pc-windows-gnu\" {\n+        if &*target.triple == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n@@ -829,17 +833,17 @@ impl Build {\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n-    fn ar(&self, target: Interned<String>) -> Option<&Path> {\n+    fn ar(&self, target: TargetSelection) -> Option<&Path> {\n         self.ar.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the `ranlib` utility for the target specified.\n-    fn ranlib(&self, target: Interned<String>) -> Option<&Path> {\n+    fn ranlib(&self, target: TargetSelection) -> Option<&Path> {\n         self.ranlib.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n-    fn cxx(&self, target: Interned<String>) -> Result<&Path, String> {\n+    fn cxx(&self, target: TargetSelection) -> Result<&Path, String> {\n         match self.cxx.get(&target) {\n             Some(p) => Ok(p.path()),\n             None => {\n@@ -849,12 +853,12 @@ impl Build {\n     }\n \n     /// Returns the path to the linker for the given target if it needs to be overridden.\n-    fn linker(&self, target: Interned<String>, can_use_lld: bool) -> Option<&Path> {\n+    fn linker(&self, target: TargetSelection, can_use_lld: bool) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target).and_then(|c| c.linker.as_ref())\n         {\n             Some(linker)\n         } else if target != self.config.build\n-            && util::use_host_linker(&target)\n+            && util::use_host_linker(target)\n             && !target.contains(\"msvc\")\n         {\n             Some(self.cc(target))\n@@ -866,7 +870,7 @@ impl Build {\n     }\n \n     /// Returns if this target should statically link the C runtime, if specified\n-    fn crt_static(&self, target: Interned<String>) -> Option<bool> {\n+    fn crt_static(&self, target: TargetSelection) -> Option<bool> {\n         if target.contains(\"pc-windows-msvc\") {\n             Some(true)\n         } else {\n@@ -875,7 +879,7 @@ impl Build {\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n-    fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n+    fn musl_root(&self, target: TargetSelection) -> Option<&Path> {\n         self.config\n             .target_config\n             .get(&target)\n@@ -885,7 +889,7 @@ impl Build {\n     }\n \n     /// Returns the \"musl libdir\" for this `target`.\n-    fn musl_libdir(&self, target: Interned<String>) -> Option<PathBuf> {\n+    fn musl_libdir(&self, target: TargetSelection) -> Option<PathBuf> {\n         let t = self.config.target_config.get(&target)?;\n         if let libdir @ Some(_) = &t.musl_libdir {\n             return libdir.clone();\n@@ -894,18 +898,18 @@ impl Build {\n     }\n \n     /// Returns the sysroot for the wasi target, if defined\n-    fn wasi_root(&self, target: Interned<String>) -> Option<&Path> {\n+    fn wasi_root(&self, target: TargetSelection) -> Option<&Path> {\n         self.config.target_config.get(&target).and_then(|t| t.wasi_root.as_ref()).map(|p| &**p)\n     }\n \n     /// Returns `true` if this is a no-std `target`, if defined\n-    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+    fn no_std(&self, target: TargetSelection) -> Option<bool> {\n         self.config.target_config.get(&target).map(|t| t.no_std)\n     }\n \n     /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n-    fn remote_tested(&self, target: Interned<String>) -> bool {\n+    fn remote_tested(&self, target: TargetSelection) -> bool {\n         self.qemu_rootfs(target).is_some()\n             || target.contains(\"android\")\n             || env::var_os(\"TEST_DEVICE_ADDR\").is_some()\n@@ -916,7 +920,7 @@ impl Build {\n     ///\n     /// If `Some` is returned then that means that tests for this target are\n     /// emulated with QEMU and binaries will need to be shipped to the emulator.\n-    fn qemu_rootfs(&self, target: Interned<String>) -> Option<&Path> {\n+    fn qemu_rootfs(&self, target: TargetSelection) -> Option<&Path> {\n         self.config.target_config.get(&target).and_then(|t| t.qemu_rootfs.as_ref()).map(|p| &**p)\n     }\n \n@@ -948,7 +952,7 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n+    fn force_use_stage1(&self, compiler: Compiler, target: TargetSelection) -> bool {\n         !self.config.full_bootstrap\n             && compiler.stage >= 2\n             && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n@@ -1058,7 +1062,7 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n+    fn llvm_link_tools_dynamically(&self, target: TargetSelection) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }\n "}, {"sha": "48b2cc24d4cd8bfb22b62e84dab700b320e07046", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -19,8 +19,8 @@ use std::process::Command;\n use build_helper::{output, t};\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::channel;\n+use crate::config::TargetSelection;\n use crate::util::{self, exe};\n use crate::GitRepo;\n use build_helper::up_to_date;\n@@ -41,7 +41,7 @@ pub struct Meta {\n // if not).\n pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Result<PathBuf, Meta> {\n     // If we're using a custom LLVM bail out here, but we can only use a\n     // custom LLVM for the build triple.\n@@ -54,13 +54,14 @@ pub fn prebuilt_llvm_config(\n \n     let root = \"src/llvm-project/llvm\";\n     let out_dir = builder.llvm_out(target);\n+\n     let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n     if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n         llvm_config_ret_dir.push(\"build\");\n     }\n     llvm_config_ret_dir.push(\"bin\");\n \n-    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n+    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", builder.config.build));\n \n     let stamp = out_dir.join(\"llvm-finished-building\");\n     let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n@@ -93,7 +94,7 @@ pub fn prebuilt_llvm_config(\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Llvm {\n@@ -115,9 +116,9 @@ impl Step for Llvm {\n         let target_native = if self.target.starts_with(\"riscv\") {\n             // RISC-V target triples in Rust is not named the same as C compiler target triples.\n             // This converts Rust RISC-V target triples to C compiler triples.\n-            let idx = target.find('-').unwrap();\n+            let idx = target.triple.find('-').unwrap();\n \n-            format!(\"riscv{}{}\", &target[5..7], &target[idx..])\n+            format!(\"riscv{}{}\", &target.triple[5..7], &target.triple[idx..])\n         } else {\n             target.to_string()\n         };\n@@ -359,7 +360,7 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n \n fn configure_cmake(\n     builder: &Builder<'_>,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     cfg: &mut cmake::Config,\n     use_compiler_launcher: bool,\n ) {\n@@ -375,7 +376,7 @@ fn configure_cmake(\n     if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n-    cfg.target(&target).host(&builder.config.build);\n+    cfg.target(&target.triple).host(&builder.config.build.triple);\n \n     let sanitize_cc = |cc: &Path| {\n         if target.contains(\"msvc\") {\n@@ -405,7 +406,7 @@ fn configure_cmake(\n         cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n             .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n         cfg.env(\"SCCACHE_PATH\", builder.config.ccache.as_ref().unwrap())\n-            .env(\"SCCACHE_TARGET\", target)\n+            .env(\"SCCACHE_TARGET\", target.triple)\n             .env(\"SCCACHE_CC\", &cc)\n             .env(\"SCCACHE_CXX\", &cxx);\n \n@@ -505,7 +506,7 @@ fn configure_cmake(\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Lld {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Lld {\n@@ -578,8 +579,8 @@ impl Step for Lld {\n         // brittle and will break over time. If anyone knows better how to\n         // cross-compile LLD it would be much appreciated to fix this!\n         if target != builder.config.build {\n-            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build)\n-                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target)\n+            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build.triple)\n+                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target.triple)\n                 .define(\n                     \"LLVM_TABLEGEN_EXE\",\n                     llvm_config.with_file_name(\"llvm-tblgen\").with_extension(EXE_EXTENSION),\n@@ -599,7 +600,7 @@ impl Step for Lld {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TestHelpers {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for TestHelpers {\n@@ -646,8 +647,8 @@ impl Step for TestHelpers {\n \n         cfg.cargo_metadata(false)\n             .out_dir(&dst)\n-            .target(&target)\n-            .host(&builder.config.build)\n+            .target(&target.triple)\n+            .host(&builder.config.build.triple)\n             .opt_level(0)\n             .warnings(false)\n             .debug(false)\n@@ -658,7 +659,7 @@ impl Step for TestHelpers {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Sanitizers {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Sanitizers {\n@@ -709,7 +710,7 @@ impl Step for Sanitizers {\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n         cfg.profile(\"Release\");\n-        cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target);\n+        cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target.triple);\n         cfg.define(\"COMPILER_RT_BUILD_BUILTINS\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_CRT\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_LIBFUZZER\", \"OFF\");\n@@ -752,7 +753,7 @@ pub struct SanitizerRuntime {\n /// Returns sanitizers available on a given target.\n fn supported_sanitizers(\n     out_dir: &Path,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     channel: &str,\n ) -> Vec<SanitizerRuntime> {\n     let darwin_libs = |os: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n@@ -778,7 +779,7 @@ fn supported_sanitizers(\n             .collect()\n     };\n \n-    match &*target {\n+    match &*target.triple {\n         \"aarch64-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n         \"aarch64-unknown-linux-gnu\" => {\n             common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])"}, {"sha": "f89bef50de982374352a826c163a0b3d70a27542", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -183,7 +183,11 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        build.config.target_config.entry(target.clone()).or_insert(Target::from_triple(target));\n+        build\n+            .config\n+            .target_config\n+            .entry(target.clone())\n+            .or_insert(Target::from_triple(&target.triple));\n \n         if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n             if build.no_std(*target) == Some(false) {"}, {"sha": "b6641180c92c0fb9c421223c247637d406f1c0b2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -16,6 +16,7 @@ use build_helper::{self, output, t};\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::flags::Subcommand;\n use crate::native;\n@@ -93,7 +94,7 @@ fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Linkcheck {\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Linkcheck {\n@@ -115,7 +116,7 @@ impl Step for Linkcheck {\n         let _time = util::timeit(&builder);\n         try_run(\n             builder,\n-            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host).join(\"doc\")),\n+            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host.triple).join(\"doc\")),\n         );\n     }\n \n@@ -132,7 +133,7 @@ impl Step for Linkcheck {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Cargotest {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Cargotest {\n@@ -177,7 +178,7 @@ impl Step for Cargotest {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Cargo {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -230,7 +231,7 @@ impl Step for Cargo {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rls {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Rls {\n@@ -281,7 +282,7 @@ impl Step for Rls {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustfmt {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Rustfmt {\n@@ -338,7 +339,7 @@ impl Step for Rustfmt {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Miri {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Miri {\n@@ -464,7 +465,7 @@ impl Step for Miri {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CompiletestTest {\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for CompiletestTest {\n@@ -501,7 +502,7 @@ impl Step for CompiletestTest {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Clippy {\n@@ -542,8 +543,10 @@ impl Step for Clippy {\n         cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n         let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n-        let target_libs =\n-            builder.stage_out(compiler, Mode::ToolRustc).join(&self.host).join(builder.cargo_dir());\n+        let target_libs = builder\n+            .stage_out(compiler, Mode::ToolRustc)\n+            .join(&self.host.triple)\n+            .join(builder.cargo_dir());\n         cargo.env(\"HOST_LIBS\", host_libs);\n         cargo.env(\"TARGET_LIBS\", target_libs);\n         // clippy tests need to find the driver\n@@ -607,7 +610,7 @@ impl Step for RustdocTheme {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocJSStd {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustdocJSStd {\n@@ -646,8 +649,8 @@ impl Step for RustdocJSStd {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocJSNotStd {\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -683,8 +686,8 @@ impl Step for RustdocJSNotStd {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocUi {\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -785,8 +788,8 @@ impl Step for ExpandYamlAnchors {\n     }\n }\n \n-fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n-    builder.out.join(host).join(\"test\")\n+fn testdir(builder: &Builder<'_>, host: TargetSelection) -> PathBuf {\n+    builder.out.join(host.triple).join(\"test\")\n }\n \n macro_rules! default_test {\n@@ -855,7 +858,7 @@ macro_rules! test_definitions {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -943,7 +946,7 @@ default_test!(Assembly { path: \"src/test/assembly\", mode: \"assembly\", suite: \"as\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     mode: &'static str,\n     suite: &'static str,\n     path: &'static str,\n@@ -1023,8 +1026,8 @@ impl Step for Compiletest {\n         cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n-        cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--target\").arg(target.rustc_target_arg());\n+        cmd.arg(\"--host\").arg(&*compiler.host.triple);\n         cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n \n         if builder.config.cmd.bless() {\n@@ -1543,7 +1546,7 @@ impl Step for RustcGuide {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateLibrustc {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     test_kind: TestKind,\n     krate: Interned<String>,\n }\n@@ -1589,7 +1592,7 @@ impl Step for CrateLibrustc {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateNotDefault {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     test_kind: TestKind,\n     krate: &'static str,\n }\n@@ -1638,7 +1641,7 @@ impl Step for CrateNotDefault {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub mode: Mode,\n     pub test_kind: TestKind,\n     pub krate: Interned<String>,\n@@ -1750,17 +1753,17 @@ impl Step for Crate {\n \n         if target.contains(\"emscripten\") {\n             cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n                 builder.config.nodejs.as_ref().expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n             let node = builder.config.nodejs.as_ref().expect(\"nodejs not configured\");\n             let runner =\n                 format!(\"{} {}/src/etc/wasm32-shim.js\", node.display(), builder.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)), &runner);\n         } else if builder.remote_tested(target) {\n             cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n                 format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n             );\n         }\n@@ -1776,7 +1779,7 @@ impl Step for Crate {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateRustdoc {\n-    host: Interned<String>,\n+    host: TargetSelection,\n     test_kind: TestKind,\n }\n \n@@ -1883,7 +1886,7 @@ impl Step for CrateRustdoc {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct RemoteCopyLibs {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for RemoteCopyLibs {\n@@ -1911,7 +1914,7 @@ impl Step for RemoteCopyLibs {\n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\").arg(target).arg(&server).arg(builder.out.join(\"tmp\"));\n+        cmd.arg(\"spawn-emulator\").arg(target.triple).arg(&server).arg(builder.out.join(\"tmp\"));\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -1966,7 +1969,9 @@ impl Step for Distcheck {\n                 .current_dir(&dir),\n         );\n         builder.run(\n-            Command::new(build_helper::make(&builder.config.build)).arg(\"check\").current_dir(&dir),\n+            Command::new(build_helper::make(&builder.config.build.triple))\n+                .arg(\"check\")\n+                .current_dir(&dir),\n         );\n \n         // Now make sure that rust-src has all of libstd's dependencies"}, {"sha": "f66061975d64d1ecb8ef7e8d432f9e21de81987c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -7,10 +7,10 @@ use std::process::{exit, Command};\n use build_helper::t;\n \n use crate::builder::{Builder, Cargo as CargoCommand, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::channel;\n use crate::channel::GitInfo;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::toolstate::ToolState;\n use crate::util::{add_dylib_path, exe};\n use crate::Compiler;\n@@ -25,7 +25,7 @@ pub enum SourceType {\n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n@@ -111,7 +111,7 @@ impl Step for ToolBuild {\n                             .and_then(|p| p.file_name())\n                             .and_then(|p| p.to_str())\n                             .unwrap();\n-                        if maybe_target != &*target {\n+                        if maybe_target != &*target.triple {\n                             continue;\n                         }\n                     }\n@@ -208,8 +208,8 @@ impl Step for ToolBuild {\n             }\n         } else {\n             let cargo_out =\n-                builder.cargo_out(compiler, self.mode, target).join(exe(tool, &compiler.host));\n-            let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n+                builder.cargo_out(compiler, self.mode, target).join(exe(tool, compiler.host));\n+            let bin = builder.tools_dir(compiler).join(exe(tool, compiler.host));\n             builder.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n@@ -220,7 +220,7 @@ pub fn prepare_tool_cargo(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n     mode: Mode,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     command: &'static str,\n     path: &'static str,\n     source_type: SourceType,\n@@ -303,7 +303,7 @@ macro_rules! bootstrap_tool {\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -416,7 +416,7 @@ impl Step for ErrorIndex {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RemoteTestServer {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RemoteTestServer {\n@@ -476,7 +476,7 @@ impl Step for Rustdoc {\n             if !target_compiler.is_snapshot(builder) {\n                 panic!(\"rustdoc in stage 0 must be snapshot rustdoc\");\n             }\n-            return builder.initial_rustc.with_file_name(exe(\"rustdoc\", &target_compiler.host));\n+            return builder.initial_rustc.with_file_name(exe(\"rustdoc\", target_compiler.host));\n         }\n         let target = target_compiler.host;\n         // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n@@ -514,14 +514,14 @@ impl Step for Rustdoc {\n         // rustdoc a different name.\n         let tool_rustdoc = builder\n             .cargo_out(build_compiler, Mode::ToolRustc, target)\n-            .join(exe(\"rustdoc_tool_binary\", &target_compiler.host));\n+            .join(exe(\"rustdoc_tool_binary\", target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {\n             let sysroot = builder.sysroot(target_compiler);\n             let bindir = sysroot.join(\"bin\");\n             t!(fs::create_dir_all(&bindir));\n-            let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n+            let bin_rustdoc = bindir.join(exe(\"rustdoc\", target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n             builder.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n@@ -534,7 +534,7 @@ impl Step for Rustdoc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -583,7 +583,7 @@ macro_rules! tool_extended {\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n             pub extra_features: Vec<String>,\n         }\n "}, {"sha": "a307ef39d03a8daba772d99b75f62e9958f30131", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b337dc57b5309d19e25811d3de340cc7567285/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=e2b337dc57b5309d19e25811d3de340cc7567285", "patch": "@@ -14,17 +14,16 @@ use std::time::Instant;\n use build_helper::t;\n \n use crate::builder::Builder;\n-use crate::cache::Interned;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n \n /// Returns the `name` as the filename of a static library for `target`.\n-pub fn staticlib(name: &str, target: &str) -> String {\n+pub fn staticlib(name: &str, target: TargetSelection) -> String {\n     if target.contains(\"windows\") { format!(\"{}.lib\", name) } else { format!(\"lib{}.a\", name) }\n }\n \n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n-pub fn exe(name: &str, target: &str) -> String {\n+pub fn exe(name: &str, target: TargetSelection) -> String {\n     if target.contains(\"windows\") { format!(\"{}.exe\", name) } else { name.to_string() }\n }\n \n@@ -35,7 +34,7 @@ pub fn is_dylib(name: &str) -> bool {\n \n /// Returns the corresponding relative library directory that the compiler's\n /// dylibs will be found in.\n-pub fn libdir(target: &str) -> &'static str {\n+pub fn libdir(target: TargetSelection) -> &'static str {\n     if target.contains(\"windows\") { \"bin\" } else { \"lib\" }\n }\n \n@@ -294,7 +293,7 @@ pub fn forcing_clang_based_tests() -> bool {\n     }\n }\n \n-pub fn use_host_linker(target: &Interned<String>) -> bool {\n+pub fn use_host_linker(target: TargetSelection) -> bool {\n     // FIXME: this information should be gotten by checking the linker flavor\n     // of the rustc target\n     !(target.contains(\"emscripten\")"}]}