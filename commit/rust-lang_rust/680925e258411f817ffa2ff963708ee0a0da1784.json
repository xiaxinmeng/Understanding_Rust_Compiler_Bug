{"sha": "680925e258411f817ffa2ff963708ee0a0da1784", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDkyNWUyNTg0MTFmODE3ZmZhMmZmOTYzNzA4ZWUwYTBkYTE3ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T19:16:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T19:16:33Z"}, "message": "auto merge of #12007 : Arcterus/rust/libgetopts, r=cmr\n\nShould help towards finishing #8784.", "tree": {"sha": "5a840256a4b2c71b7a5bfb22c12fbee251c2810c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a840256a4b2c71b7a5bfb22c12fbee251c2810c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/680925e258411f817ffa2ff963708ee0a0da1784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/680925e258411f817ffa2ff963708ee0a0da1784", "html_url": "https://github.com/rust-lang/rust/commit/680925e258411f817ffa2ff963708ee0a0da1784", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/680925e258411f817ffa2ff963708ee0a0da1784/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b9c35654d1e7716ab5ef6236c6cf308818e71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b9c35654d1e7716ab5ef6236c6cf308818e71c", "html_url": "https://github.com/rust-lang/rust/commit/66b9c35654d1e7716ab5ef6236c6cf308818e71c"}, {"sha": "968ce53dff7da4ca258c67436b81b00bd55222e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/968ce53dff7da4ca258c67436b81b00bd55222e6", "html_url": "https://github.com/rust-lang/rust/commit/968ce53dff7da4ca258c67436b81b00bd55222e6"}], "stats": {"total": 1364, "additions": 558, "deletions": 806}, "files": [{"sha": "65fb24257645259170692c0e66b3765ffc7c69bc", "filename": "mk/crates.mk", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -49,19 +49,20 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := std extra green rustuv native flate arena glob term semver uuid serialize sync\n+TARGET_CRATES := std extra green rustuv native flate arena glob term semver \\\n+                 uuid serialize sync getopts\n HOST_CRATES := syntax rustc rustdoc\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_std := native:rustrt\n-DEPS_extra := std serialize sync term\n+DEPS_extra := std term sync serialize getopts\n DEPS_green := std\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std extra term serialize\n-DEPS_rustc := syntax native:rustllvm flate arena serialize sync\n-DEPS_rustdoc := rustc native:sundown serialize sync\n+DEPS_rustc := syntax native:rustllvm flate arena serialize sync getopts\n+DEPS_rustdoc := rustc native:sundown serialize sync getopts\n DEPS_flate := std native:miniz\n DEPS_arena := std extra\n DEPS_glob := std\n@@ -70,8 +71,9 @@ DEPS_term := std\n DEPS_semver := std\n DEPS_uuid := std serialize\n DEPS_sync := std\n+DEPS_getopts := std\n \n-TOOL_DEPS_compiletest := extra green rustuv\n+TOOL_DEPS_compiletest := extra green rustuv getopts\n TOOL_DEPS_rustdoc := rustdoc green rustuv\n TOOL_DEPS_rustc := rustc green rustuv\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs"}, {"sha": "b3151ac99b249b7f94acc762444ba6fd9bf2a37f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -14,13 +14,13 @@\n #[deny(warnings)];\n \n extern mod extra;\n+extern mod getopts;\n \n use std::os;\n use std::io;\n use std::io::fs;\n \n-use extra::getopts;\n-use extra::getopts::groups::{optopt, optflag, reqopt};\n+use getopts::{optopt, optflag, reqopt};\n use extra::test;\n \n use common::config;\n@@ -49,7 +49,7 @@ pub fn main() {\n \n pub fn parse_config(args: ~[~str]) -> config {\n \n-    let groups : ~[getopts::groups::OptGroup] =\n+    let groups : ~[getopts::OptGroup] =\n         ~[reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n           reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\"),\n           reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\"),\n@@ -85,20 +85,20 @@ pub fn parse_config(args: ~[~str]) -> config {\n     let args_ = args.tail();\n     if args[1] == ~\"-h\" || args[1] == ~\"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::groups::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups));\n         println!(\"\");\n         fail!()\n     }\n \n     let matches =\n-        &match getopts::groups::getopts(args_, groups) {\n+        &match getopts::getopts(args_, groups) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::groups::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups));\n         println!(\"\");\n         fail!()\n     }"}, {"sha": "39dc196b6a051bdaecd97372bd615f50a7fe56f2", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -39,6 +39,7 @@ li {list-style-type: none; }\n \n * [The `arena` allocation library](arena/index.html)\n * [The `flate` compression library](flate/index.html)\n+* [The `getopts` argument parsing library](getopts/index.html)\n * [The `glob` file path matching library](glob/index.html)\n * [The `semver` version collation library](semver/index.html)\n * [The `serialize` value encoding/decoding library](serialize/index.html)"}, {"sha": "97c38a59af85b6bc7bf79ff19b69eb10ea6b4b49", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -73,7 +73,6 @@ pub mod lru_cache;\n // And ... other stuff\n \n pub mod url;\n-pub mod getopts;\n pub mod json;\n pub mod tempfile;\n pub mod time;"}, {"sha": "4af0fa162336100dcb48595e57c7124c112fd4f0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -15,10 +15,9 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n+extern mod getopts;\n extern mod term;\n \n-use getopts;\n-use getopts::groups;\n use json::ToJson;\n use json;\n use serialize::Decodable;\n@@ -209,29 +208,29 @@ pub struct TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, ~str>;\n \n-fn optgroups() -> ~[getopts::groups::OptGroup] {\n-    ~[groups::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n-      groups::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n-      groups::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n-      groups::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n-      groups::optopt(\"\", \"save-metrics\", \"Location to save bench metrics\",\n+fn optgroups() -> ~[getopts::OptGroup] {\n+    ~[getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n+      getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n+      getopts::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n+      getopts::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n+      getopts::optopt(\"\", \"save-metrics\", \"Location to save bench metrics\",\n                      \"PATH\"),\n-      groups::optopt(\"\", \"ratchet-metrics\",\n+      getopts::optopt(\"\", \"ratchet-metrics\",\n                      \"Location to load and save metrics from. The metrics \\\n                       loaded are cause benchmarks to fail if they run too \\\n                       slowly\", \"PATH\"),\n-      groups::optopt(\"\", \"ratchet-noise-percent\",\n+      getopts::optopt(\"\", \"ratchet-noise-percent\",\n                      \"Tests within N% of the recorded metrics will be \\\n                       considered as passing\", \"PERCENTAGE\"),\n-      groups::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n+      getopts::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n                           of stdout\", \"PATH\"),\n-      groups::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n+      getopts::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n                      \"A.B\")]\n }\n \n fn usage(binary: &str, helpstr: &str) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(\"{}\", groups::usage(message, optgroups()));\n+    println!(\"{}\", getopts::usage(message, optgroups()));\n     println!(\"\");\n     if helpstr == \"help\" {\n         println!(\"{}\", \"\\\n@@ -261,7 +260,7 @@ Test Attributes:\n pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match groups::getopts(args_, optgroups()) {\n+        match getopts::getopts(args_, optgroups()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_err_msg()))\n         };"}, {"sha": "e5e7c50d2cecd83363dacf8208e34a854ca06923", "filename": "src/libgetopts/lib.rs", "status": "renamed", "additions": 510, "deletions": 755, "changes": 1265, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -30,8 +30,8 @@\n //! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n //!\n //! ~~~{.rust}\n-//! extern mod extra;\n-//! use extra::getopts::{optopt,optflag,getopts,Opt};\n+//! extern mod getopts;\n+//! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n //!\n //! fn do_work(inp: &str, out: Option<~str>) {\n@@ -42,7 +42,7 @@\n //!     }\n //! }\n //!\n-//! fn print_usage(program: &str, _opts: &[Opt]) {\n+//! fn print_usage(program: &str, _opts: &[OptGroup]) {\n //!     println!(\"Usage: {} [options]\", program);\n //!     println!(\"-o\\t\\tOutput\");\n //!     println!(\"-h --help\\tUsage\");\n@@ -54,15 +54,14 @@\n //!     let program = args[0].clone();\n //!\n //!     let opts = ~[\n-//!         optopt(\"o\"),\n-//!         optflag(\"h\"),\n-//!         optflag(\"help\")\n+//!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n+//!         optflag(\"h\", \"help\", \"print this help menu\")\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n //!         Err(f) => { fail!(f.to_err_msg()) }\n //!     };\n-//!     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+//!     if matches.opt_present(\"h\") {\n //!         print_usage(program, opts);\n //!         return;\n //!     }\n@@ -77,6 +76,14 @@\n //! }\n //! ~~~\n \n+#[crate_id = \"getopts#0.10-pre\"];\n+#[crate_type = \"rlib\"];\n+#[crate_type = \"dylib\"];\n+#[license = \"MIT/ASL2\"];\n+#[allow(missing_doc)];\n+\n+#[feature(globs)];\n+\n use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n@@ -122,6 +129,24 @@ pub struct Opt {\n     priv aliases: ~[Opt],\n }\n \n+/// One group of options, e.g., both -h and --help, along with\n+/// their shared description and properties.\n+#[deriving(Clone, Eq)]\n+pub struct OptGroup {\n+    /// Short Name of the `OptGroup`\n+    short_name: ~str,\n+    /// Long Name of the `OptGroup`\n+    long_name: ~str,\n+    /// Hint\n+    hint: ~str,\n+    /// Description\n+    desc: ~str,\n+    /// Whether it has an argument\n+    hasarg: HasArg,\n+    /// How often it can occur\n+    occur: Occur\n+}\n+\n /// Describes wether an option is given at all or has a value.\n #[deriving(Clone, Eq)]\n enum Optval {\n@@ -185,6 +210,50 @@ impl Name {\n     }\n }\n \n+impl OptGroup {\n+    /// Translate OptGroup into Opt.\n+    /// (Both short and long names correspond to different Opts).\n+    pub fn long_to_short(&self) -> Opt {\n+        let OptGroup {\n+            short_name: short_name,\n+            long_name: long_name,\n+            hasarg: hasarg,\n+            occur: occur,\n+            ..\n+        } = (*self).clone();\n+\n+        match (short_name.len(), long_name.len()) {\n+            (0,0) => fail!(\"this long-format option was given no name\"),\n+            (0,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: ~[]\n+            },\n+            (1,0) => Opt {\n+                name: Short(short_name.char_at(0)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: ~[]\n+            },\n+            (1,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur:  occur,\n+                aliases: ~[\n+                    Opt {\n+                        name: Short(short_name.char_at(0)),\n+                        hasarg: hasarg,\n+                        occur:  occur,\n+                        aliases: ~[]\n+                    }\n+                ]\n+            },\n+            (_,_) => fail!(\"something is wrong with the long-form opt\")\n+        }\n+    }\n+}\n+\n impl Matches {\n     fn opt_vals(&self, nm: &str) -> ~[Optval] {\n         match find_opt(self.opts, Name::from_str(nm)) {\n@@ -300,65 +369,89 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     None\n }\n \n-/// Create an option that is required and takes an argument.\n-pub fn reqopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is required and takes an argument.\n+pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Req,\n-        aliases: ~[]\n+        occur: Req\n     }\n }\n \n-/// Create an option that is optional and takes an argument.\n-pub fn optopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and takes an argument.\n+pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional and does not take an argument.\n-pub fn optflag(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and does not take an argument.\n+pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: ~\"\",\n+        desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional, does not take an argument,\n-/// and may occur multiple times.\n-pub fn optflagmulti(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that can occur more than once and does not\n+/// take an argument.\n+pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: ~\"\",\n+        desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Multi,\n-        aliases: ~[]\n+        occur: Multi\n     }\n }\n \n-/// Create an option that is optional and takes an optional argument.\n-pub fn optflagopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and takes an optional argument.\n+pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Maybe,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional, takes an argument, and may occur\n+/// Create a long option that is optional, takes an argument, and may occur\n /// multiple times.\n-pub fn optmulti(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Multi,\n-        aliases: ~[]\n+        occur: Multi\n     }\n }\n \n@@ -390,7 +483,8 @@ impl Fail_ {\n /// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n /// Use `to_err_msg` to get an error message.\n-pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n+pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n+    let opts = optgrps.map(|x| x.long_to_short());\n     let n_opts = opts.len();\n \n     fn f(_x: uint) -> ~[Optval] { return ~[]; }\n@@ -516,393 +610,232 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     })\n }\n \n-/// A module which provides a way to specify descriptions and\n-/// groups of short and long option names, together.\n-pub mod groups {\n-    use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n-    use getopts::{Short, Yes};\n-\n-    /// One group of options, e.g., both -h and --help, along with\n-    /// their shared description and properties.\n-    #[deriving(Clone, Eq)]\n-    pub struct OptGroup {\n-        /// Short Name of the `OptGroup`\n-        short_name: ~str,\n-        /// Long Name of the `OptGroup`\n-        long_name: ~str,\n-        /// Hint\n-        hint: ~str,\n-        /// Description\n-        desc: ~str,\n-        /// Whether it has an argument\n-        hasarg: HasArg,\n-        /// How often it can occur\n-        occur: Occur\n-    }\n-\n-    impl OptGroup {\n-        /// Translate OptGroup into Opt.\n-        /// (Both short and long names correspond to different Opts).\n-        pub fn long_to_short(&self) -> Opt {\n-            let OptGroup {\n-                short_name: short_name,\n-                long_name: long_name,\n-                hasarg: hasarg,\n-                occur: occur,\n-                ..\n-            } = (*self).clone();\n-\n-            match (short_name.len(), long_name.len()) {\n-                (0,0) => fail!(\"this long-format option was given no name\"),\n-                (0,_) => Opt {\n-                    name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n-                    aliases: ~[]\n-                },\n-                (1,0) => Opt {\n-                    name: Short(short_name.char_at(0)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n-                    aliases: ~[]\n-                },\n-                (1,_) => Opt {\n-                    name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur:  occur,\n-                    aliases: ~[\n-                        Opt {\n-                            name: Short(short_name.char_at(0)),\n-                            hasarg: hasarg,\n-                            occur:  occur,\n-                            aliases: ~[]\n-                        }\n-                    ]\n-                },\n-                (_,_) => fail!(\"something is wrong with the long-form opt\")\n-            }\n-        }\n-    }\n+/// Derive a usage message from a set of long options.\n+pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-    /// Create a long option that is required and takes an argument.\n-    pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Req\n-        }\n-    }\n+    let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-    /// Create a long option that is optional and takes an argument.\n-    pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Optional\n-        }\n-    }\n+    let mut rows = opts.iter().map(|optref| {\n+        let OptGroup{short_name: short_name,\n+                     long_name: long_name,\n+                     hint: hint,\n+                     desc: desc,\n+                     hasarg: hasarg,\n+                     ..} = (*optref).clone();\n \n-    /// Create a long option that is optional and does not take an argument.\n-    pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: ~\"\",\n-            desc: desc.to_owned(),\n-            hasarg: No,\n-            occur: Optional\n-        }\n-    }\n+        let mut row = \" \".repeat(4);\n \n-    /// Create a long option that can occur more than once and does not\n-    /// take an argument.\n-    pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: ~\"\",\n-            desc: desc.to_owned(),\n-            hasarg: No,\n-            occur: Multi\n-        }\n-    }\n-\n-    /// Create a long option that is optional and takes an optional argument.\n-    pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Maybe,\n-            occur: Optional\n-        }\n-    }\n-\n-    /// Create a long option that is optional, takes an argument, and may occur\n-    /// multiple times.\n-    pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Multi\n+        // short option\n+        match short_name.len() {\n+            0 => {}\n+            1 => {\n+                row.push_char('-');\n+                row.push_str(short_name);\n+                row.push_char(' ');\n+            }\n+            _ => fail!(\"the short name should only be 1 ascii char long\"),\n         }\n-    }\n \n-    /// Parse command line args with the provided long format options.\n-    pub fn getopts(args: &[~str], opts: &[OptGroup]) -> ::getopts::Result {\n-        ::getopts::getopts(args, opts.map(|x| x.long_to_short()))\n-    }\n-\n-    fn format_option(opt: &OptGroup) -> ~str {\n-        let mut line = ~\"\";\n-\n-        if opt.occur != Req {\n-            line.push_char('[');\n+        // long option\n+        match long_name.len() {\n+            0 => {}\n+            _ => {\n+                row.push_str(\"--\");\n+                row.push_str(long_name);\n+                row.push_char(' ');\n+            }\n         }\n \n-        // Use short_name is possible, but fallback to long_name.\n-        if opt.short_name.len() > 0 {\n-            line.push_char('-');\n-            line.push_str(opt.short_name);\n-        } else {\n-            line.push_str(\"--\");\n-            line.push_str(opt.long_name);\n+        // arg\n+        match hasarg {\n+            No => {}\n+            Yes => row.push_str(hint),\n+            Maybe => {\n+                row.push_char('[');\n+                row.push_str(hint);\n+                row.push_char(']');\n+            }\n         }\n \n-        if opt.hasarg != No {\n-            line.push_char(' ');\n-            if opt.hasarg == Maybe {\n-                line.push_char('[');\n-            }\n-            line.push_str(opt.hint);\n-            if opt.hasarg == Maybe {\n-                line.push_char(']');\n+        // FIXME: #5516 should be graphemes not codepoints\n+        // here we just need to indent the start of the description\n+        let rowlen = row.char_len();\n+        if rowlen < 24 {\n+            for _ in range(0, 24 - rowlen) {\n+                row.push_char(' ');\n             }\n+        } else {\n+            row.push_str(desc_sep)\n         }\n \n-        if opt.occur != Req {\n-            line.push_char(']');\n-        }\n-        if opt.occur == Multi {\n-            line.push_str(\"..\");\n+        // Normalize desc to contain words separated by one space character\n+        let mut desc_normalized_whitespace = ~\"\";\n+        for word in desc.words() {\n+            desc_normalized_whitespace.push_str(word);\n+            desc_normalized_whitespace.push_char(' ');\n         }\n \n-        line\n-    }\n-\n-    /// Derive a short one-line usage summary from a set of long options.\n-    pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n-        let mut line = ~\"Usage: \" + program_name + \" \";\n-        line.push_str(opts.iter().map(format_option).to_owned_vec().connect(\" \"));\n-\n-        line\n-    }\n-\n-    /// Derive a usage message from a set of long options.\n-    pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n-\n-        let desc_sep = \"\\n\" + \" \".repeat(24);\n-\n-        let mut rows = opts.iter().map(|optref| {\n-            let OptGroup{short_name: short_name,\n-                         long_name: long_name,\n-                         hint: hint,\n-                         desc: desc,\n-                         hasarg: hasarg,\n-                         ..} = (*optref).clone();\n-\n-            let mut row = \" \".repeat(4);\n-\n-            // short option\n-            match short_name.len() {\n-                0 => {}\n-                1 => {\n-                    row.push_char('-');\n-                    row.push_str(short_name);\n-                    row.push_char(' ');\n-                }\n-                _ => fail!(\"the short name should only be 1 ascii char long\"),\n-            }\n+        // FIXME: #5516 should be graphemes not codepoints\n+        let mut desc_rows = ~[];\n+        each_split_within(desc_normalized_whitespace, 54, |substr| {\n+            desc_rows.push(substr.to_owned());\n+            true\n+        });\n \n-            // long option\n-            match long_name.len() {\n-                0 => {}\n-                _ => {\n-                    row.push_str(\"--\");\n-                    row.push_str(long_name);\n-                    row.push_char(' ');\n-                }\n-            }\n+        // FIXME: #5516 should be graphemes not codepoints\n+        // wrapped description\n+        row.push_str(desc_rows.connect(desc_sep));\n \n-            // arg\n-            match hasarg {\n-                No => {}\n-                Yes => row.push_str(hint),\n-                Maybe => {\n-                    row.push_char('[');\n-                    row.push_str(hint);\n-                    row.push_char(']');\n-                }\n-            }\n+        row\n+    });\n \n-            // FIXME: #5516 should be graphemes not codepoints\n-            // here we just need to indent the start of the description\n-            let rowlen = row.char_len();\n-            if rowlen < 24 {\n-                for _ in range(0, 24 - rowlen) {\n-                    row.push_char(' ');\n-                }\n-            } else {\n-                row.push_str(desc_sep)\n-            }\n-\n-            // Normalize desc to contain words separated by one space character\n-            let mut desc_normalized_whitespace = ~\"\";\n-            for word in desc.words() {\n-                desc_normalized_whitespace.push_str(word);\n-                desc_normalized_whitespace.push_char(' ');\n-            }\n-\n-            // FIXME: #5516 should be graphemes not codepoints\n-            let mut desc_rows = ~[];\n-            each_split_within(desc_normalized_whitespace, 54, |substr| {\n-                desc_rows.push(substr.to_owned());\n-                true\n-            });\n+    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+}\n \n-            // FIXME: #5516 should be graphemes not codepoints\n-            // wrapped description\n-            row.push_str(desc_rows.connect(desc_sep));\n+fn format_option(opt: &OptGroup) -> ~str {\n+    let mut line = ~\"\";\n \n-            row\n-        });\n+    if opt.occur != Req {\n+        line.push_char('[');\n+    }\n \n-        format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+    // Use short_name is possible, but fallback to long_name.\n+    if opt.short_name.len() > 0 {\n+        line.push_char('-');\n+        line.push_str(opt.short_name);\n+    } else {\n+        line.push_str(\"--\");\n+        line.push_str(opt.long_name);\n     }\n \n-    /// Splits a string into substrings with possibly internal whitespace,\n-    /// each of them at most `lim` bytes long. The substrings have leading and trailing\n-    /// whitespace removed, and are only cut at whitespace boundaries.\n-    ///\n-    /// Note: Function was moved here from `std::str` because this module is the only place that\n-    /// uses it, and because it was to specific for a general string function.\n-    ///\n-    /// #Failure:\n-    ///\n-    /// Fails during iteration if the string contains a non-whitespace\n-    /// sequence longer than the limit.\n-    fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n-                         -> bool {\n-        // Just for fun, let's write this as a state machine:\n-\n-        enum SplitWithinState {\n-            A,  // leading whitespace, initial state\n-            B,  // words\n-            C,  // internal and trailing whitespace\n-        }\n-        enum Whitespace {\n-            Ws, // current char is whitespace\n-            Cr  // current char is not whitespace\n+    if opt.hasarg != No {\n+        line.push_char(' ');\n+        if opt.hasarg == Maybe {\n+            line.push_char('[');\n         }\n-        enum LengthLimit {\n-            UnderLim, // current char makes current substring still fit in limit\n-            OverLim   // current char makes current substring no longer fit in limit\n+        line.push_str(opt.hint);\n+        if opt.hasarg == Maybe {\n+            line.push_char(']');\n         }\n+    }\n \n-        let mut slice_start = 0;\n-        let mut last_start = 0;\n-        let mut last_end = 0;\n-        let mut state = A;\n-        let mut fake_i = ss.len();\n-        let mut lim = lim;\n+    if opt.occur != Req {\n+        line.push_char(']');\n+    }\n+    if opt.occur == Multi {\n+        line.push_str(\"..\");\n+    }\n \n-        let mut cont = true;\n-        let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n+    line\n+}\n \n-        // if the limit is larger than the string, lower it to save cycles\n-        if lim >= fake_i {\n-            lim = fake_i;\n-        }\n+/// Derive a short one-line usage summary from a set of long options.\n+pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n+    let mut line = ~\"Usage: \" + program_name + \" \";\n+    line.push_str(opts.iter().map(format_option).to_owned_vec().connect(\" \"));\n \n-        let machine: |(uint, char)| -> bool = |(i, c)| {\n-            let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n-            let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n-\n-            state = match (state, whitespace, limit) {\n-                (A, Ws, _)        => { A }\n-                (A, Cr, _)        => { slice_start = i; last_start = i; B }\n-\n-                (B, Cr, UnderLim) => { B }\n-                (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                                => fail!(\"word starting with {} longer than limit!\",\n-                                        ss.slice(last_start, i + 1)),\n-                (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n-                (B, Ws, UnderLim) => { last_end = i; C }\n-                (B, Ws, OverLim)  => { last_end = i; slice(); A }\n-\n-                (C, Cr, UnderLim) => { last_start = i; B }\n-                (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n-                (C, Ws, OverLim)  => { slice(); A }\n-                (C, Ws, UnderLim) => { C }\n-            };\n+    line\n+}\n \n-            cont\n+\n+/// Splits a string into substrings with possibly internal whitespace,\n+/// each of them at most `lim` bytes long. The substrings have leading and trailing\n+/// whitespace removed, and are only cut at whitespace boundaries.\n+///\n+/// Note: Function was moved here from `std::str` because this module is the only place that\n+/// uses it, and because it was to specific for a general string function.\n+///\n+/// #Failure:\n+///\n+/// Fails during iteration if the string contains a non-whitespace\n+/// sequence longer than the limit.\n+fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n+                     -> bool {\n+    // Just for fun, let's write this as a state machine:\n+\n+    enum SplitWithinState {\n+        A,  // leading whitespace, initial state\n+        B,  // words\n+        C,  // internal and trailing whitespace\n+    }\n+    enum Whitespace {\n+        Ws, // current char is whitespace\n+        Cr  // current char is not whitespace\n+    }\n+    enum LengthLimit {\n+        UnderLim, // current char makes current substring still fit in limit\n+        OverLim   // current char makes current substring no longer fit in limit\n+    }\n+\n+    let mut slice_start = 0;\n+    let mut last_start = 0;\n+    let mut last_end = 0;\n+    let mut state = A;\n+    let mut fake_i = ss.len();\n+    let mut lim = lim;\n+\n+    let mut cont = true;\n+    let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n+\n+    // if the limit is larger than the string, lower it to save cycles\n+    if lim >= fake_i {\n+        lim = fake_i;\n+    }\n+\n+    let machine: |(uint, char)| -> bool = |(i, c)| {\n+        let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+        let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+\n+        state = match (state, whitespace, limit) {\n+            (A, Ws, _)        => { A }\n+            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n+\n+            (B, Cr, UnderLim) => { B }\n+            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                            => fail!(\"word starting with {} longer than limit!\",\n+                                    ss.slice(last_start, i + 1)),\n+            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n+            (B, Ws, UnderLim) => { last_end = i; C }\n+            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n+\n+            (C, Cr, UnderLim) => { last_start = i; B }\n+            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n+            (C, Ws, OverLim)  => { slice(); A }\n+            (C, Ws, UnderLim) => { C }\n         };\n \n-        ss.char_indices().advance(|x| machine(x));\n+        cont\n+    };\n \n-        // Let the automaton 'run out' by supplying trailing whitespace\n-        while cont && match state { B | C => true, A => false } {\n-            machine((fake_i, ' '));\n-            fake_i += 1;\n-        }\n-        return cont;\n-    }\n+    ss.char_indices().advance(|x| machine(x));\n \n-    #[test]\n-    fn test_split_within() {\n-        fn t(s: &str, i: uint, u: &[~str]) {\n-            let mut v = ~[];\n-            each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"\", 0, []);\n-        t(\"\", 15, []);\n-        t(\"hello\", 15, [~\"hello\"]);\n-        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-            [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n-        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-            [~\"Mary had a little lamb\\nLittle lamb\"]);\n+    // Let the automaton 'run out' by supplying trailing whitespace\n+    while cont && match state { B | C => true, A => false } {\n+        machine((fake_i, ' '));\n+        fake_i += 1;\n     }\n-} // end groups module\n+    return cont;\n+}\n+\n+#[test]\n+fn test_split_within() {\n+    fn t(s: &str, i: uint, u: &[~str]) {\n+        let mut v = ~[];\n+        each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n+        assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n+    }\n+    t(\"\", 0, []);\n+    t(\"\", 15, []);\n+    t(\"hello\", 15, [~\"hello\"]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n+        [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n+        [~\"Mary had a little lamb\\nLittle lamb\"]);\n+}\n \n #[cfg(test)]\n mod tests {\n-\n-    use getopts::groups::OptGroup;\n-    use getopts::*;\n+    use super::*;\n \n     use std::result::{Err, Ok};\n     use std::result;\n@@ -917,73 +850,37 @@ mod tests {\n         }\n     }\n \n-\n     // Tests for reqopt\n     #[test]\n-    fn test_reqopt_long() {\n-        let args = ~[~\"--test=20\"];\n-        let opts = ~[reqopt(\"test\")];\n-        let rs = getopts(args, opts);\n+    fn test_reqopt() {\n+        let long_args = ~[~\"--test=20\"];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert!(m.opt_present(\"t\"));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => { fail!(\"test_reqopt_long failed\"); }\n+          _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_long_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_long_no_arg() {\n-        let args = ~[~\"--test\"];\n-        let opts = ~[reqopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_long_multi() {\n-        let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[reqopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_short() {\n-        let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[reqopt(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n+        let short_args = ~[~\"-t\", ~\"20\"];\n+        match getopts(short_args, opts) {\n           Ok(ref m) => {\n-            assert!(m.opt_present(\"t\"));\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => { fail!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n     #[test]\n-    fn test_reqopt_short_missing() {\n+    fn test_reqopt_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n@@ -992,83 +889,52 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_short_no_arg() {\n-        let args = ~[~\"-t\"];\n-        let opts = ~[reqopt(\"t\")];\n-        let rs = getopts(args, opts);\n+    fn test_reqopt_no_arg() {\n+        let long_args = ~[~\"--test\"];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n+        let short_args = ~[~\"-t\"];\n+        match getopts(short_args, opts) {\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          _ => fail!()\n+        }\n     }\n \n     #[test]\n-    fn test_reqopt_short_multi() {\n-        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[reqopt(\"t\")];\n+    fn test_reqopt_multi() {\n+        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n \n-\n     // Tests for optopt\n     #[test]\n-    fn test_optopt_long() {\n-        let args = ~[~\"--test=20\"];\n-        let opts = ~[optopt(\"test\")];\n-        let rs = getopts(args, opts);\n+    fn test_optopt() {\n+        let long_args = ~[~\"--test=20\"];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n-    }\n-\n-    #[test]\n-    fn test_optopt_long_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_long_no_arg() {\n-        let args = ~[~\"--test\"];\n-        let opts = ~[optopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_long_multi() {\n-        let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optopt(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_short() {\n-        let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optopt(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n+        let short_args = ~[~\"-t\", ~\"20\"];\n+        match getopts(short_args, opts) {\n           Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n@@ -1077,66 +943,87 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_short_missing() {\n+    fn test_optopt_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(\"t\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n-    fn test_optopt_short_no_arg() {\n-        let args = ~[~\"-t\"];\n-        let opts = ~[optopt(\"t\")];\n-        let rs = getopts(args, opts);\n+    fn test_optopt_no_arg() {\n+        let long_args = ~[~\"--test\"];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n+        let short_args = ~[~\"-t\"];\n+        match getopts(short_args, opts) {\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          _ => fail!()\n+        }\n     }\n \n     #[test]\n-    fn test_optopt_short_multi() {\n-        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optopt(\"t\")];\n+    fn test_optopt_multi() {\n+        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n \n-\n     // Tests for optflag\n     #[test]\n-    fn test_optflag_long() {\n-        let args = ~[~\"--test\"];\n-        let opts = ~[optflag(\"test\")];\n-        let rs = getopts(args, opts);\n+    fn test_optflag() {\n+        let long_args = ~[~\"--test\"];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n-          Ok(ref m) => assert!(m.opt_present(\"test\")),\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n+          _ => fail!()\n+        }\n+        let short_args = ~[~\"-t\"];\n+        match getopts(short_args, opts) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n-    fn test_optflag_long_missing() {\n+    fn test_optflag_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n@@ -1148,42 +1035,20 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_long_multi() {\n-        let args = ~[~\"--test\", ~\"--test\"];\n-        let opts = ~[optflag(\"test\")];\n+    fn test_optflag_multi() {\n+        let args = ~[~\"--test\", ~\"-t\"];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n \n-    #[test]\n-    fn test_optflag_short() {\n-        let args = ~[~\"-t\"];\n-        let opts = ~[optflag(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Ok(ref m) => assert!(m.opt_present(\"t\")),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_short_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optflag(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n-        }\n-    }\n-\n     #[test]\n     fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optflag(\"t\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1195,22 +1060,11 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_optflag_short_multi() {\n-        let args = ~[~\"-t\", ~\"-t\"];\n-        let opts = ~[optflag(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n-        }\n-    }\n-\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1223,7 +1077,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1236,7 +1090,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1249,7 +1103,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"verbose\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1262,7 +1116,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"verbose\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1272,67 +1126,40 @@ mod tests {\n         }\n     }\n \n-    // Tests for optmulti\n     #[test]\n-    fn test_optmulti_long() {\n-        let args = ~[~\"--test=20\"];\n-        let opts = ~[optmulti(\"test\")];\n+    fn test_optflagmulti_mix() {\n+        let args = ~[~\"--verbose\", ~\"-v\", ~\"-vv\", ~\"verbose\"];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_count(\"verbose\"), 4);\n+            assert_eq!(m.opt_count(\"v\"), 4);\n           }\n           _ => fail!()\n         }\n     }\n \n+    // Tests for optmulti\n     #[test]\n-    fn test_optmulti_long_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_long_no_arg() {\n-        let args = ~[~\"--test\"];\n-        let opts = ~[optmulti(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_long_multi() {\n-        let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optmulti(\"test\")];\n-        let rs = getopts(args, opts);\n+    fn test_optmulti() {\n+        let long_args = ~[~\"--test=20\"];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n-              let pair = m.opt_strs(\"test\");\n-              assert!(pair[0] == ~\"20\");\n-              assert!(pair[1] == ~\"30\");\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n           _ => fail!()\n         }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_short() {\n-        let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optmulti(\"t\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n+        let short_args = ~[~\"-t\", ~\"20\"];\n+        match getopts(short_args, opts) {\n           Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n@@ -1341,61 +1168,65 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_short_missing() {\n+    fn test_optmulti_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!m.opt_present(\"t\")),\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n-    fn test_optmulti_short_no_arg() {\n-        let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(\"t\")];\n-        let rs = getopts(args, opts);\n+    fn test_optmulti_no_arg() {\n+        let long_args = ~[~\"--test\"];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n+        let short_args = ~[~\"-t\"];\n+        match getopts(short_args, opts) {\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          _ => fail!()\n+        }\n     }\n \n     #[test]\n-    fn test_optmulti_short_multi() {\n-        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optmulti(\"t\")];\n+    fn test_optmulti_multi() {\n+        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n-            let pair = m.opt_strs(\"t\");\n-            assert!(pair[0] == ~\"20\");\n-            assert!(pair[1] == ~\"30\");\n+              assert!(m.opt_present(\"test\"));\n+              assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+              assert!(m.opt_present(\"t\"));\n+              assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+              let pair = m.opt_strs(\"test\");\n+              assert!(pair[0] == ~\"20\");\n+              assert!(pair[1] == ~\"30\");\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n-    fn test_unrecognized_option_long() {\n-        let args = ~[~\"--untest\"];\n-        let opts = ~[optmulti(\"t\")];\n-        let rs = getopts(args, opts);\n+    fn test_unrecognized_option() {\n+        let long_args = ~[~\"--untest\"];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n+        let rs = getopts(long_args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-    }\n-\n-    #[test]\n-    fn test_unrecognized_option_short() {\n-        let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(\"test\")];\n-        let rs = getopts(args, opts);\n-        match rs {\n+        let short_args = ~[~\"-u\"];\n+        match getopts(short_args, opts) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n@@ -1408,9 +1239,13 @@ mod tests {\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n               ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n         let opts =\n-            ~[optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n-             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n-             optopt(\"notpresent\")];\n+            ~[optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n+              optflag(\"\", \"flag\", \"a flag\"),\n+              reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n+              optflag(\"f\", \"\", \"another flag\"),\n+              optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n+              optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n+              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1435,7 +1270,9 @@ mod tests {\n \n     #[test]\n     fn test_multi() {\n-        let opts = ~[optopt(\"e\"), optopt(\"encrypt\"), optopt(\"f\")];\n+        let opts = ~[optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n+                     optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n+                     optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n \n         let args_single = ~[~\"-e\", ~\"foo\"];\n         let matches_single = &match getopts(args_single, opts) {\n@@ -1475,7 +1312,8 @@ mod tests {\n     #[test]\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n-        let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n+        let opts = ~[optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                     optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n@@ -1488,125 +1326,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_reqopt() {\n-        let opt = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n-        assert!(opt == OptGroup { short_name: ~\"b\",\n-                        long_name: ~\"banana\",\n-                        hint: ~\"VAL\",\n-                        desc: ~\"some bananas\",\n-                        hasarg: Yes,\n-                        occur: Req })\n-    }\n-\n-    #[test]\n-    fn test_groups_optopt() {\n-        let opt = groups::optopt(\"a\", \"apple\", \"some apples\", \"VAL\");\n-        assert!(opt == OptGroup { short_name: ~\"a\",\n-                        long_name: ~\"apple\",\n-                        hint: ~\"VAL\",\n-                        desc: ~\"some apples\",\n-                        hasarg: Yes,\n-                        occur: Optional })\n-    }\n-\n-    #[test]\n-    fn test_groups_optflag() {\n-        let opt = groups::optflag(\"k\", \"kiwi\", \"some kiwis\");\n-        assert!(opt == OptGroup { short_name: ~\"k\",\n-                        long_name: ~\"kiwi\",\n-                        hint: ~\"\",\n-                        desc: ~\"some kiwis\",\n-                        hasarg: No,\n-                        occur: Optional })\n-    }\n-\n-    #[test]\n-    fn test_groups_optflagopt() {\n-        let opt = groups::optflagopt(\"p\", \"pineapple\", \"some pineapples\", \"VAL\");\n-        assert!(opt == OptGroup { short_name: ~\"p\",\n-                        long_name: ~\"pineapple\",\n-                        hint: ~\"VAL\",\n-                        desc: ~\"some pineapples\",\n-                        hasarg: Maybe,\n-                        occur: Optional })\n-    }\n-\n-    #[test]\n-    fn test_groups_optmulti() {\n-        let opt = groups::optmulti(\"l\", \"lime\", \"some limes\", \"VAL\");\n-        assert!(opt == OptGroup { short_name: ~\"l\",\n-                        long_name: ~\"lime\",\n-                        hint: ~\"VAL\",\n-                        desc: ~\"some limes\",\n-                        hasarg: Yes,\n-                        occur: Multi })\n-    }\n-\n-    #[test]\n-    fn test_groups_long_to_short() {\n-        let mut short = reqopt(\"banana\");\n-        short.aliases = ~[reqopt(\"b\")];\n-        let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n+    fn test_long_to_short() {\n+        let mut short = Opt { name: Long(~\"banana\"),\n+                              hasarg: Yes,\n+                              occur: Req,\n+                              aliases: ~[] };\n+        short.aliases = ~[Opt { name: Short('b'),\n+                                hasarg: Yes,\n+                                occur: Req,\n+                                aliases: ~[] }];\n+        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(verbose.long_to_short(), short);\n     }\n \n     #[test]\n-    fn test_groups_getopts() {\n-        let mut banana = reqopt(\"banana\");\n-        banana.aliases = ~[reqopt(\"b\")];\n-        let mut apple = optopt(\"apple\");\n-        apple.aliases = ~[optopt(\"a\")];\n-        let mut kiwi = optflag(\"kiwi\");\n-        kiwi.aliases = ~[optflag(\"k\")];\n-        let short = ~[\n-            banana,\n-            apple,\n-            kiwi,\n-            optflagopt(\"p\"),\n-            optmulti(\"l\")\n-        ];\n-\n-        // short and verbose should always be in the same order. if they\n-        // aren't the test will fail (and in mysterious ways)\n-\n-        let verbose = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"apple\", \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n-        ];\n-\n-        let sample_args = ~[~\"--kiwi\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n-                            ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n-\n-        assert!(getopts(sample_args, short)\n-            == groups::getopts(sample_args, verbose));\n-    }\n-\n-    #[test]\n-    fn test_groups_aliases_long_and_short() {\n+    fn test_aliases_long_and_short() {\n         let opts = ~[\n-            groups::optflagmulti(\"a\", \"apple\", \"Desc\"),\n+            optflagmulti(\"a\", \"apple\", \"Desc\"),\n         ];\n \n         let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n \n-        let matches = groups::getopts(args, opts).unwrap();\n+        let matches = getopts(args, opts).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n         assert_eq!(3, matches.opt_count(\"apple\"));\n     }\n \n     #[test]\n-    fn test_groups_usage() {\n+    fn test_usage() {\n         let optgroups = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"012345678901234567890123456789\",\n+            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            optopt(\"a\", \"012345678901234567890123456789\",\n                              \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n+            optflag(\"k\", \"kiwi\", \"Desc\"),\n+            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected =\n@@ -1621,22 +1376,22 @@ Options:\n     -l VAL              Desc\n \";\n \n-        let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let generated_usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);\n         assert_eq!(generated_usage, expected);\n     }\n \n     #[test]\n-    fn test_groups_usage_description_wrapping() {\n+    fn test_usage_description_wrapping() {\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n         let optgroups = ~[\n-            groups::optflag(\"k\", \"kiwi\",\n+            optflag(\"k\", \"kiwi\",\n                 \"This is a long description which won't be wrapped..+..\"), // 54\n-            groups::optflag(\"a\", \"apple\",\n+            optflag(\"a\", \"apple\",\n                 \"This is a long description which _will_ be wrapped..+..\"), // 55\n         ];\n \n@@ -1649,19 +1404,19 @@ Options:\n                         wrapped..+..\n \";\n \n-        let usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n \n     #[test]\n-    fn test_groups_usage_description_multibyte_handling() {\n+    fn test_usage_description_multibyte_handling() {\n         let optgroups = ~[\n-            groups::optflag(\"k\", \"k\\u2013w\\u2013\",\n+            optflag(\"k\", \"k\\u2013w\\u2013\",\n                 \"The word kiwi is normally spelled with two i's\"),\n-            groups::optflag(\"a\", \"apple\",\n+            optflag(\"a\", \"apple\",\n                 \"This \\u201Cdescription\\u201D has some characters that could \\\n confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"),\n         ];\n@@ -1676,7 +1431,7 @@ Options:\n                         some parts of Europe.\n \";\n \n-        let usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1686,16 +1441,16 @@ Options:\n     #[test]\n     fn test_short_usage() {\n         let optgroups = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"012345678901234567890123456789\",\n-                             \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n+            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            optopt(\"a\", \"012345678901234567890123456789\",\n+                     \"Desc\", \"VAL\"),\n+            optflag(\"k\", \"kiwi\", \"Desc\"),\n+            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected = ~\"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\";\n-        let generated_usage = groups::short_usage(\"fruits\", optgroups);\n+        let generated_usage = short_usage(\"fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);", "previous_filename": "src/libextra/getopts.rs"}, {"sha": "70974fae5cc287fba4cda3069cb81d97ba7bc853", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -34,8 +34,8 @@ use std::io::fs;\n use std::io::MemReader;\n use std::os;\n use std::vec;\n-use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n-use extra::getopts;\n+use getopts::{optopt, optmulti, optflag, optflagopt};\n+use getopts;\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -992,7 +992,7 @@ pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n }\n \n // rustc command line options\n-pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n+pub fn optgroups() -> ~[getopts::OptGroup] {\n  ~[\n   optflag(\"c\", \"\",    \"Compile and assemble, but do not link\"),\n   optmulti(\"\", \"cfg\", \"Configure the compilation\n@@ -1188,7 +1188,7 @@ mod test {\n     use driver::driver::{build_configuration, build_session};\n     use driver::driver::{build_session_options, optgroups};\n \n-    use extra::getopts::groups::getopts;\n+    use getopts::getopts;\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n     use syntax::diagnostic;"}, {"sha": "9a6cbcc9b96200f7339d636b7901829f3d8e8161", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -37,6 +37,7 @@ extern mod arena;\n extern mod syntax;\n extern mod serialize;\n extern mod sync;\n+extern mod getopts;\n \n use back::link;\n use driver::session;\n@@ -50,8 +51,6 @@ use std::os;\n use std::str;\n use std::task;\n use std::vec;\n-use extra::getopts::groups;\n-use extra::getopts;\n use syntax::ast;\n use syntax::attr;\n use syntax::diagnostic::Emitter;\n@@ -142,7 +141,7 @@ pub fn usage(argv0: &str) {\n Additional help:\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc\\n\",\n-              groups::usage(message, d::optgroups()));\n+              getopts::usage(message, d::optgroups()));\n }\n \n pub fn describe_warnings() {\n@@ -201,7 +200,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::groups::getopts(args, d::optgroups()) {\n+        &match getopts::getopts(args, d::optgroups()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(demitter, f.to_err_msg());"}, {"sha": "dd96018d4af25e762d6d5feecb7a80c39dd1f8c5", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -23,12 +23,9 @@ use middle::lang_items::{LanguageItems, language_items};\n use middle::ty::{FnTyBase, FnMeta, FnSig};\n use util::ppaux::ty_to_str;\n \n-use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n-use extra::getopts::groups;\n-use extra::getopts::{opt_present};\n-use extra::getopts;\n-use extra::getopts;\n use extra::oldmap::HashMap;\n+use getopts::{optopt, optmulti, optflag, optflagopt, getopts};\n+use getopts::opt_present;\n use syntax::codemap::DUMMY_SP;\n use syntax::parse::parse_crate_from_source_str;\n use syntax::{ast, attr, parse};"}, {"sha": "f659c8646f5e42dd7c450f365f245f86022ac142", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -20,13 +20,12 @@ extern mod rustc;\n extern mod extra;\n extern mod serialize;\n extern mod sync;\n+extern mod getopts;\n \n use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n use std::str;\n-use extra::getopts;\n-use extra::getopts::groups;\n use extra::json;\n use serialize::{Decodable, Encodable};\n use extra::time;\n@@ -80,8 +79,8 @@ pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args()));\n }\n \n-pub fn opts() -> ~[groups::OptGroup] {\n-    use extra::getopts::groups::*;\n+pub fn opts() -> ~[getopts::OptGroup] {\n+    use getopts::*;\n     ~[\n         optflag(\"h\", \"help\", \"show this help message\"),\n         optflag(\"\", \"version\", \"print rustdoc's version\"),\n@@ -107,11 +106,11 @@ pub fn opts() -> ~[groups::OptGroup] {\n }\n \n pub fn usage(argv0: &str) {\n-    println!(\"{}\", groups::usage(format!(\"{} [options] <input>\", argv0), opts()));\n+    println!(\"{}\", getopts::usage(format!(\"{} [options] <input>\", argv0), opts()));\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    let matches = match groups::getopts(args.tail(), opts()) {\n+    let matches = match getopts::getopts(args.tail(), opts()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());"}, {"sha": "12f2f2ca9361c11bc0bdd890332e225c750d01d7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -16,11 +16,11 @@ use std::run;\n use std::str;\n \n use extra::tempfile::TempDir;\n-use extra::getopts;\n use extra::test;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n+use getopts;\n use syntax::diagnostic;\n use syntax::parse;\n "}, {"sha": "86a2043527e21b06f2a59830c01df7d89ba2fb0d", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -19,8 +19,9 @@\n */\n \n extern mod extra;\n+extern mod getopts;\n \n-use extra::{time, getopts};\n+use extra::time;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n@@ -52,7 +53,7 @@ struct Config {\n }\n \n fn parse_opts(argv: ~[~str]) -> Config {\n-    let opts = ~[getopts::optflag(\"stress\")];\n+    let opts = ~[getopts::optflag(\"\", \"stress\", \"\")];\n \n     let opt_args = argv.slice(1, argv.len());\n "}, {"sha": "db8098a79acb9cdd329c27386eb28ff9ad89d8ad", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/680925e258411f817ffa2ff963708ee0a0da1784/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680925e258411f817ffa2ff963708ee0a0da1784/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=680925e258411f817ffa2ff963708ee0a0da1784", "patch": "@@ -10,13 +10,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod extra;\n+extern mod getopts;\n \n-use extra::getopts::{optopt, getopts};\n+use getopts::{optopt, getopts};\n \n pub fn main() {\n     let args = ~[];\n-    let opts = ~[optopt(\"b\")];\n+    let opts = ~[optopt(\"b\", \"\", \"something\", \"SMTHNG\")];\n \n     match getopts(args, opts) {\n         Ok(ref m)  =>"}]}