{"sha": "bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "node_id": "C_kwDOAAsO6NoAKGJiZWUxYzlkMWY1M2ZjODYxNGZhMmRjMjczNzMyOTU1NWJjMDFiMjY", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-22T11:12:07Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-22T11:42:41Z"}, "message": "Apply manual fixes", "tree": {"sha": "dcdb2ddf93d59c7afb842d0af0729209a3b1d681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcdb2ddf93d59c7afb842d0af0729209a3b1d681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "html_url": "https://github.com/rust-lang/rust/commit/bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38bb1a963749ac4e94c13751233bdc61f20e84f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38bb1a963749ac4e94c13751233bdc61f20e84f", "html_url": "https://github.com/rust-lang/rust/commit/e38bb1a963749ac4e94c13751233bdc61f20e84f"}], "stats": {"total": 98, "additions": 53, "deletions": 45}, "files": [{"sha": "b8824024e6c786bffb527a5a9c49fbcf05e95c57", "filename": "lintcheck/src/config.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fconfig.rs?ref=bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "patch": "@@ -73,8 +73,7 @@ impl LintcheckConfig {\n         let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n             clap_config\n                 .get_one::<String>(\"crates-toml\")\n-                .map(|s| &**s)\n-                .unwrap_or(\"lintcheck/lintcheck_crates.toml\")\n+                .map_or(\"lintcheck/lintcheck_crates.toml\", |s| &**s)\n                 .into()\n         });\n "}, {"sha": "47724a2fedb0072c98ae11ec9149d8c7b0152f37", "filename": "lintcheck/src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fdriver.rs?ref=bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "patch": "@@ -5,7 +5,7 @@ use std::net::TcpStream;\n use std::process::{self, Command, Stdio};\n use std::{env, mem};\n \n-/// 1. Sends [DriverInfo] to the [crate::recursive::LintcheckServer] running on `addr`\n+/// 1. Sends [`DriverInfo`] to the [`crate::recursive::LintcheckServer`] running on `addr`\n /// 2. Receives [bool] from the server, if `false` returns `None`\n /// 3. Otherwise sends the stderr of running `clippy-driver` to the server\n fn run_clippy(addr: &str) -> Option<i32> {"}, {"sha": "54c1b80c42dbf0fd320aa06677770d42db78ddf9", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "patch": "@@ -116,12 +116,13 @@ impl ClippyWarning {\n \n         let span = diag.spans.into_iter().find(|span| span.is_primary)?;\n \n-        let file = match Path::new(&span.file_name).strip_prefix(env!(\"CARGO_HOME\")) {\n-            Ok(stripped) => format!(\"$CARGO_HOME/{}\", stripped.display()),\n-            Err(_) => format!(\n+        let file = if let Ok(stripped) = Path::new(&span.file_name).strip_prefix(env!(\"CARGO_HOME\")) {\n+            format!(\"$CARGO_HOME/{}\", stripped.display())\n+        } else {\n+            format!(\n                 \"target/lintcheck/sources/{}-{}/{}\",\n                 crate_name, crate_version, span.file_name\n-            ),\n+            )\n         };\n \n         Some(Self {\n@@ -154,6 +155,7 @@ impl ClippyWarning {\n     }\n }\n \n+#[allow(clippy::result_large_err)]\n fn get(path: &str) -> Result<ureq::Response, ureq::Error> {\n     const MAX_RETRIES: u8 = 4;\n     let mut retries = 0;\n@@ -165,7 +167,7 @@ fn get(path: &str) -> Result<ureq::Response, ureq::Error> {\n             Err(e) => return Err(e),\n         }\n         eprintln!(\"retrying in {retries} seconds...\");\n-        thread::sleep(Duration::from_secs(retries as u64));\n+        thread::sleep(Duration::from_secs(u64::from(retries)));\n         retries += 1;\n     }\n }\n@@ -232,7 +234,7 @@ impl CrateSource {\n                         .expect(\"Failed to clone git repo!\")\n                         .success()\n                     {\n-                        eprintln!(\"Failed to clone {url} into {}\", repo_path.display())\n+                        eprintln!(\"Failed to clone {url} into {}\", repo_path.display());\n                     }\n                 }\n                 // check out the commit/branch/whatever\n@@ -245,7 +247,7 @@ impl CrateSource {\n                     .expect(\"Failed to check out commit\")\n                     .success()\n                 {\n-                    eprintln!(\"Failed to checkout {commit} of repo at {}\", repo_path.display())\n+                    eprintln!(\"Failed to checkout {commit} of repo at {}\", repo_path.display());\n                 }\n \n                 Crate {\n@@ -256,6 +258,12 @@ impl CrateSource {\n                 }\n             },\n             CrateSource::Path { name, path, options } => {\n+                fn is_cache_dir(entry: &DirEntry) -> bool {\n+                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n+                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n+                        .unwrap_or(false)\n+                }\n+\n                 // copy path into the dest_crate_root but skip directories that contain a CACHEDIR.TAG file.\n                 // The target/ directory contains a CACHEDIR.TAG file so it is the most commonly skipped directory\n                 // as a result of this filter.\n@@ -267,12 +275,6 @@ impl CrateSource {\n \n                 println!(\"Copying {path:?} to {dest_crate_root:?}\");\n \n-                fn is_cache_dir(entry: &DirEntry) -> bool {\n-                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n-                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n-                        .unwrap_or(false)\n-                }\n-\n                 for entry in WalkDir::new(path).into_iter().filter_entry(|e| !is_cache_dir(e)) {\n                     let entry = entry.unwrap();\n                     let entry_path = entry.path();\n@@ -301,6 +303,7 @@ impl CrateSource {\n impl Crate {\n     /// Run `cargo clippy` on the `Crate` and collect and return all the lint warnings that clippy\n     /// issued\n+    #[allow(clippy::too_many_arguments)]\n     fn run_clippy_lints(\n         &self,\n         cargo_clippy_path: &Path,\n@@ -345,14 +348,14 @@ impl Crate {\n                 clippy_args.push(opt);\n             }\n         } else {\n-            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"]);\n         }\n \n         if lint_filter.is_empty() {\n             clippy_args.push(\"--cap-lints=warn\");\n         } else {\n             clippy_args.push(\"--cap-lints=allow\");\n-            clippy_args.extend(lint_filter.iter().map(|filter| filter.as_str()))\n+            clippy_args.extend(lint_filter.iter().map(std::string::String::as_str));\n         }\n \n         if let Some(server) = server {\n@@ -463,7 +466,7 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n     // flatten TomlCrates into CrateSources (one TomlCrates may represent several versions of a crate =>\n     // multiple Cratesources)\n     let mut crate_sources = Vec::new();\n-    tomlcrates.into_iter().for_each(|tk| {\n+    for tk in tomlcrates {\n         if let Some(ref path) = tk.path {\n             crate_sources.push(CrateSource::Path {\n                 name: tk.name.clone(),\n@@ -472,13 +475,13 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n             });\n         } else if let Some(ref versions) = tk.versions {\n             // if we have multiple versions, save each one\n-            versions.iter().for_each(|ver| {\n+            for ver in versions.iter() {\n                 crate_sources.push(CrateSource::CratesIo {\n                     name: tk.name.clone(),\n                     version: ver.to_string(),\n                     options: tk.options.clone(),\n                 });\n-            })\n+            }\n         } else if tk.git_url.is_some() && tk.git_hash.is_some() {\n             // otherwise, we should have a git source\n             crate_sources.push(CrateSource::Git {\n@@ -496,15 +499,18 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n             || tk.git_hash.is_some() != tk.git_url.is_some()\n         {\n             eprintln!(\"tomlkrate: {tk:?}\");\n-            if tk.git_hash.is_some() != tk.git_url.is_some() {\n-                panic!(\"Error: Encountered TomlCrate with only one of git_hash and git_url!\");\n-            }\n-            if tk.path.is_some() && (tk.git_hash.is_some() || tk.versions.is_some()) {\n-                panic!(\"Error: TomlCrate can only have one of 'git_.*', 'version' or 'path' fields\");\n-            }\n+            assert_eq!(\n+                tk.git_hash.is_some(),\n+                tk.git_url.is_some(),\n+                \"Error: Encountered TomlCrate with only one of git_hash and git_url!\"\n+            );\n+            assert!(\n+                tk.path.is_none() || (tk.git_hash.is_none() && tk.versions.is_none()),\n+                \"Error: TomlCrate can only have one of 'git_.*', 'version' or 'path' fields\"\n+            );\n             unreachable!(\"Failed to translate TomlCrate into CrateSource!\");\n         }\n-    });\n+    }\n     // sort the crates\n     crate_sources.sort();\n \n@@ -566,6 +572,7 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path, paths: [&Path; 2]) -> bool\n     logs_modified < clippy_modified\n }\n \n+#[allow(clippy::too_many_lines)]\n fn main() {\n     // We're being executed as a `RUSTC_WRAPPER` as part of `--recursive`\n     if let Ok(addr) = env::var(\"LINTCHECK_SERVER\") {\n@@ -671,7 +678,7 @@ fn main() {\n         .unwrap();\n \n     let server = config.recursive.then(|| {\n-        let _ = fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\");\n+        fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\").unwrap_or_default();\n \n         LintcheckServer::spawn(recursive_options)\n     });\n@@ -727,7 +734,7 @@ fn main() {\n     }\n     write!(text, \"{}\", all_msgs.join(\"\")).unwrap();\n     text.push_str(\"\\n\\n### ICEs:\\n\");\n-    for (cratename, msg) in ices.iter() {\n+    for (cratename, msg) in &ices {\n         let _ = write!(text, \"{cratename}: '{msg}'\");\n     }\n \n@@ -780,10 +787,10 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n     let mut new_stats_deduped = new_stats;\n \n     // remove duplicates from both hashmaps\n-    same_in_both_hashmaps.iter().for_each(|(k, v)| {\n+    for (k, v) in &same_in_both_hashmaps {\n         assert!(old_stats_deduped.remove(k) == Some(*v));\n         assert!(new_stats_deduped.remove(k) == Some(*v));\n-    });\n+    }\n \n     println!(\"\\nStats:\");\n \n@@ -821,19 +828,21 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n /// This function panics if creating one of the dirs fails.\n fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n     std::fs::create_dir(\"target/lintcheck/\").unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create lintcheck target dir\");\n-        }\n+        assert_eq!(\n+            err.kind(),\n+            ErrorKind::AlreadyExists,\n+            \"cannot create lintcheck target dir\"\n+        );\n     });\n     std::fs::create_dir(krate_download_dir).unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create crate download dir\");\n-        }\n+        assert_eq!(err.kind(), ErrorKind::AlreadyExists, \"cannot create crate download dir\");\n     });\n     std::fs::create_dir(extract_dir).unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create crate extraction dir\");\n-        }\n+        assert_eq!(\n+            err.kind(),\n+            ErrorKind::AlreadyExists,\n+            \"cannot create crate extraction dir\"\n+        );\n     });\n }\n "}, {"sha": "49072e65192f21c151669b6fad5d5f16d377e8a3", "filename": "lintcheck/src/recursive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Frecursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbee1c9d1f53fc8614fa2dc2737329555bc01b26/lintcheck%2Fsrc%2Frecursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Frecursive.rs?ref=bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "patch": "@@ -1,7 +1,7 @@\n //! In `--recursive` mode we set the `lintcheck` binary as the `RUSTC_WRAPPER` of `cargo check`,\n-//! this allows [crate::driver] to be run for every dependency. The driver connects to\n-//! [LintcheckServer] to ask if it should be skipped, and if not sends the stderr of running clippy\n-//! on the crate to the server\n+//! this allows [`crate::driver`] to be run for every dependency. The driver connects to\n+//! [`LintcheckServer`] to ask if it should be skipped, and if not sends the stderr of running\n+//! clippy on the crate to the server\n \n use crate::ClippyWarning;\n use crate::RecursiveOptions;\n@@ -109,8 +109,8 @@ impl LintcheckServer {\n \n         Self {\n             local_addr,\n-            sender,\n             receiver,\n+            sender,\n         }\n     }\n "}]}