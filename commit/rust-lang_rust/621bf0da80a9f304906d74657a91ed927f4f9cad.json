{"sha": "621bf0da80a9f304906d74657a91ed927f4f9cad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMWJmMGRhODBhOWYzMDQ5MDZkNzQ2NTdhOTFlZDkyN2Y0ZjljYWQ=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-05-24T15:57:30Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-06-03T03:55:29Z"}, "message": "move monoitemext to inherent methods", "tree": {"sha": "df9208e83048b13ad9d1def574336463369415de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df9208e83048b13ad9d1def574336463369415de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/621bf0da80a9f304906d74657a91ed927f4f9cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/621bf0da80a9f304906d74657a91ed927f4f9cad", "html_url": "https://github.com/rust-lang/rust/commit/621bf0da80a9f304906d74657a91ed927f4f9cad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/621bf0da80a9f304906d74657a91ed927f4f9cad/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "html_url": "https://github.com/rust-lang/rust/commit/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35"}], "stats": {"total": 239, "additions": 211, "deletions": 28}, "files": [{"sha": "9ba0bb3eb2d39e8840727433759e4e68cefc9c3e", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 190, "deletions": 1, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -1,15 +1,44 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use crate::hir::HirId;\n use syntax::symbol::InternedString;\n-use crate::ty::{Instance, TyCtxt};\n+use syntax::attr::InlineAttr;\n+use syntax::source_map::Span;\n+use crate::ty::{Instance, TyCtxt, SymbolName, subst::InternalSubsts};\n use crate::util::nodemap::FxHashMap;\n+use crate::ty::print::obsolete::DefPathBasedNames;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n                                            StableHasher};\n use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use crate::session::config::OptLevel;\n use std::fmt;\n use std::hash::Hash;\n \n+/// Describes how a monomorphization will be instantiated in object files.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum InstantiationMode {\n+    /// There will be exactly one instance of the given MonoItem. It will have\n+    /// external linkage so that it can be linked to from other codegen units.\n+    GloballyShared {\n+        /// In some compilation scenarios we may decide to take functions that\n+        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n+        /// to avoid codegenning them a bunch of times. In this situation,\n+        /// however, our local copy may conflict with other crates also\n+        /// inlining the same function.\n+        ///\n+        /// This flag indicates that this situation is occurring, and informs\n+        /// symbol name calculation that some extra mangling is needed to\n+        /// avoid conflicts. Note that this may eventually go away entirely if\n+        /// ThinLTO enables us to *always* have a globally shared instance of a\n+        /// function within one crate's compilation.\n+        may_conflict: bool,\n+    },\n+\n+    /// Each codegen unit containing a reference to the given MonoItem will\n+    /// have its own private copy of the function (with internal linkage).\n+    LocalCopy,\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n@@ -31,6 +60,166 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(_) => 1,\n         }\n     }\n+\n+    pub fn is_generic_fn(&self) -> bool {\n+        match *self {\n+            MonoItem::Fn(ref instance) => {\n+                instance.substs.non_erasable_generics().next().is_some()\n+            }\n+            MonoItem::Static(..) |\n+            MonoItem::GlobalAsm(..) => false,\n+        }\n+    }\n+\n+    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> SymbolName {\n+        match *self {\n+            MonoItem::Fn(instance) => tcx.symbol_name(instance),\n+            MonoItem::Static(def_id) => {\n+                tcx.symbol_name(Instance::mono(tcx, def_id))\n+            }\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n+                SymbolName {\n+                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn instantiation_mode(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> InstantiationMode {\n+        let inline_in_all_cgus =\n+            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n+                tcx.sess.opts.optimize != OptLevel::No\n+            }) && !tcx.sess.opts.cg.link_dead_code;\n+\n+        match *self {\n+            MonoItem::Fn(ref instance) => {\n+                let entry_def_id = tcx.entry_fn(LOCAL_CRATE).map(|(id, _)| id);\n+                // If this function isn't inlined or otherwise has explicit\n+                // linkage, then we'll be creating a globally shared version.\n+                if self.explicit_linkage(tcx).is_some() ||\n+                    !instance.def.requires_local(tcx) ||\n+                    Some(instance.def_id()) == entry_def_id\n+                {\n+                    return InstantiationMode::GloballyShared  { may_conflict: false }\n+                }\n+\n+                // At this point we don't have explicit linkage and we're an\n+                // inlined function. If we're inlining into all CGUs then we'll\n+                // be creating a local copy per CGU\n+                if inline_in_all_cgus {\n+                    return InstantiationMode::LocalCopy\n+                }\n+\n+                // Finally, if this is `#[inline(always)]` we're sure to respect\n+                // that with an inline copy per CGU, but otherwise we'll be\n+                // creating one copy of this `#[inline]` function which may\n+                // conflict with upstream crates as it could be an exported\n+                // symbol.\n+                match tcx.codegen_fn_attrs(instance.def_id()).inline {\n+                    InlineAttr::Always => InstantiationMode::LocalCopy,\n+                    _ => {\n+                        InstantiationMode::GloballyShared  { may_conflict: true }\n+                    }\n+                }\n+            }\n+            MonoItem::Static(..) |\n+            MonoItem::GlobalAsm(..) => {\n+                InstantiationMode::GloballyShared { may_conflict: false }\n+            }\n+        }\n+    }\n+\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+        let def_id = match *self {\n+            MonoItem::Fn(ref instance) => instance.def_id(),\n+            MonoItem::Static(def_id) => def_id,\n+            MonoItem::GlobalAsm(..) => return None,\n+        };\n+\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n+        codegen_fn_attrs.linkage\n+    }\n+\n+    /// Returns `true` if this instance is instantiable - whether it has no unsatisfied\n+    /// predicates.\n+    ///\n+    /// In order to codegen an item, all of its predicates must hold, because\n+    /// otherwise the item does not make sense. Type-checking ensures that\n+    /// the predicates of every item that is *used by* a valid item *do*\n+    /// hold, so we can rely on that.\n+    ///\n+    /// However, we codegen collector roots (reachable items) and functions\n+    /// in vtables when they are seen, even if they are not used, and so they\n+    /// might not be instantiable. For example, a programmer can define this\n+    /// public function:\n+    ///\n+    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n+    ///         <&mut () as Clone>::clone(&s);\n+    ///     }\n+    ///\n+    /// That function can't be codegened, because the method `<&mut () as Clone>::clone`\n+    /// does not exist. Luckily for us, that function can't ever be used,\n+    /// because that would require for `&'a mut (): Clone` to hold, so we\n+    /// can just not emit any code, or even a linker reference for it.\n+    ///\n+    /// Similarly, if a vtable method has such a signature, and therefore can't\n+    /// be used, we can just not emit it and have a placeholder (a null pointer,\n+    /// which will never be accessed) in its place.\n+    pub fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        debug!(\"is_instantiable({:?})\", self);\n+        let (def_id, substs) = match *self {\n+            MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n+            MonoItem::Static(def_id) => (def_id, InternalSubsts::empty()),\n+            // global asm never has predicates\n+            MonoItem::GlobalAsm(..) => return true\n+        };\n+\n+        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n+    }\n+\n+    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n+        return match *self {\n+            MonoItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance, debug)\n+            },\n+            MonoItem::Static(def_id) => {\n+                let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n+                to_string_internal(tcx, \"static \", instance, debug)\n+            },\n+            MonoItem::GlobalAsm(..) => {\n+                \"global_asm\".to_string()\n+            }\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>,\n+                                        debug: bool)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            let printer = DefPathBasedNames::new(tcx, false, false);\n+            printer.push_instance_as_string(instance, &mut result, debug);\n+            result\n+        }\n+    }\n+\n+    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+        match *self {\n+            MonoItem::Fn(Instance { def, .. }) => {\n+                tcx.hir().as_local_hir_id(def.def_id())\n+            }\n+            MonoItem::Static(def_id) => {\n+                tcx.hir().as_local_hir_id(def_id)\n+            }\n+            MonoItem::GlobalAsm(hir_id) => {\n+                Some(hir_id)\n+            }\n+        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {"}, {"sha": "34e5b0681de033552f230a6d3a68f52bd2d518bc", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -20,11 +20,10 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit};\n+use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit, MonoItem};\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n-use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, EntryFnType, Lto};\n@@ -42,7 +41,6 @@ use crate::callee;\n use crate::common::{RealPredicate, TypeKind, IntPredicate};\n use crate::meth;\n use crate::mir;\n-use crate::mono_item::MonoItem;\n \n use crate::traits::*;\n "}, {"sha": "1c9c86a5f5dda56d3806572f6dd37a087fe9bcfa", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -1,19 +1,18 @@\n use rustc::hir;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::layout::HasTyCtxt;\n-use std::fmt;\n use crate::base;\n use crate::traits::*;\n \n-pub use rustc::mir::mono::MonoItem;\n+use rustc::mir::mono::MonoItem;\n \n-pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n+pub trait MonoItemExt<'a, 'tcx: 'a> {\n+    fn as_mono_item(&self) -> &MonoItem<'tcx>;\n \n-pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx(), true),\n-               self.to_raw_string(),\n+               self.as_mono_item().to_string(cx.tcx(), true),\n+               self.as_mono_item().to_raw_string(),\n                cx.codegen_unit().name());\n \n         match *self.as_mono_item() {\n@@ -34,8 +33,8 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx(), true),\n-               self.to_raw_string(),\n+               self.as_mono_item().to_string(cx.tcx(), true),\n+               self.as_mono_item().to_raw_string(),\n                cx.codegen_unit().name());\n     }\n \n@@ -46,11 +45,11 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         visibility: Visibility\n     ) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx(), true),\n-               self.to_raw_string(),\n+               self.as_mono_item().to_string(cx.tcx(), true),\n+               self.as_mono_item().to_raw_string(),\n                cx.codegen_unit().name());\n \n-        let symbol_name = self.symbol_name(cx.tcx()).as_str();\n+        let symbol_name = self.as_mono_item().symbol_name(cx.tcx()).as_str();\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -65,8 +64,8 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx(), true),\n-               self.to_raw_string(),\n+               self.as_mono_item().to_string(cx.tcx(), true),\n+               self.as_mono_item().to_raw_string(),\n                cx.codegen_unit().name());\n     }\n \n@@ -87,4 +86,8 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n+impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n+    fn as_mono_item(&self) -> &MonoItem<'tcx> {\n+        self\n+    }\n+}"}, {"sha": "47dc4e5b2cafe231448b162600b712d6ee4b2c20", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -93,8 +93,7 @@ use rustc::hir::CodegenFnAttrFlags;\n use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, Instance};\n-use rustc::mir::mono::MonoItem;\n-use rustc_mir::monomorphize::item::{InstantiationMode, MonoItemExt};\n+use rustc::mir::mono::{MonoItem, InstantiationMode};\n \n use syntax_pos::symbol::InternedString;\n "}, {"sha": "eed051449e155637663f2a581bb3712d97e156d2", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -187,15 +187,13 @@ use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::session::config::EntryFnType;\n use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::mono::MonoItem;\n+use rustc::mir::mono::{MonoItem, InstantiationMode};\n use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n \n use crate::monomorphize;\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n use rustc::util::common::time;\n \n-use crate::monomorphize::item::{MonoItemExt, InstantiationMode};\n-\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n "}, {"sha": "51bcbff7f3236472e95dc955b6f7e0d2cc971a2c", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -2,10 +2,7 @@ use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-pub use self::item::MonoItemExt;\n-\n pub mod collector;\n-pub mod item;\n pub mod partitioning;\n \n pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "6a7f67da1bf1aabf76baa83bca9b8b51057cb79e", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621bf0da80a9f304906d74657a91ed927f4f9cad/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=621bf0da80a9f304906d74657a91ed927f4f9cad", "patch": "@@ -108,11 +108,10 @@ use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::util::common::time;\n use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};\n-use rustc::mir::mono::MonoItem;\n+use rustc::mir::mono::{MonoItem, InstantiationMode};\n \n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n-use crate::monomorphize::item::{MonoItemExt, InstantiationMode};\n \n pub enum PartitioningStrategy {\n     /// Generates one codegen unit per source-level module."}]}