{"sha": "6c9c2d862dd10718ba2b2a320c3390995ad414bc", "node_id": "C_kwDOAAsO6NoAKDZjOWMyZDg2MmRkMTA3MThiYTJiMmEzMjBjMzM5MDk5NWFkNDE0YmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T03:39:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T03:39:43Z"}, "message": "Auto merge of #102660 - camsteffen:uninhabited-perf, r=oli-obk\n\nRemove ParamEnv from uninhabited query", "tree": {"sha": "221428406f8a567c8b9169e61007ca61efad6103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221428406f8a567c8b9169e61007ca61efad6103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9c2d862dd10718ba2b2a320c3390995ad414bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9c2d862dd10718ba2b2a320c3390995ad414bc", "html_url": "https://github.com/rust-lang/rust/commit/6c9c2d862dd10718ba2b2a320c3390995ad414bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9c2d862dd10718ba2b2a320c3390995ad414bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e95b6da885f42a4e1314595089fa4295e329d11", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e95b6da885f42a4e1314595089fa4295e329d11", "html_url": "https://github.com/rust-lang/rust/commit/6e95b6da885f42a4e1314595089fa4295e329d11"}, {"sha": "2928e9ef2c75e2a654c0bf5afce3762cbb24eb94", "url": "https://api.github.com/repos/rust-lang/rust/commits/2928e9ef2c75e2a654c0bf5afce3762cbb24eb94", "html_url": "https://github.com/rust-lang/rust/commit/2928e9ef2c75e2a654c0bf5afce3762cbb24eb94"}], "stats": {"total": 692, "additions": 338, "deletions": 354}, "files": [{"sha": "8afc061176f0d1f196d8d93c65ea1fbf09d7e926", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -2467,42 +2467,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n-        /// Determines whether the given type is inhabited. `None` means that we don't know.\n-        fn ty_inhabited<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-            use rustc_type_ir::sty::TyKind::*;\n-            if !cx.tcx.type_uninhabited_from(cx.param_env.and(ty)).is_empty() {\n-                // This is definitely uninhabited from some module.\n-                return Some(false);\n-            }\n-            match ty.kind() {\n-                Never => Some(false),\n-                Int(_) | Uint(_) | Float(_) | Bool | Char | RawPtr(_) => Some(true),\n-                // Fallback for more complicated types. (Note that `&!` might be considered\n-                // uninhabited so references are \"complicated\", too.)\n-                _ => None,\n-            }\n-        }\n-        /// Determines whether a product type formed from a list of types is inhabited.\n-        fn tys_inhabited<'tcx>(\n-            cx: &LateContext<'tcx>,\n-            tys: impl Iterator<Item = Ty<'tcx>>,\n-        ) -> Option<bool> {\n-            let mut definitely_inhabited = true; // with no fields, we are definitely inhabited.\n-            for ty in tys {\n-                match ty_inhabited(cx, ty) {\n-                    // If any type is uninhabited, the product is uninhabited.\n-                    Some(false) => return Some(false),\n-                    // Otherwise go searching for a `None`.\n-                    None => {\n-                        // We don't know.\n-                        definitely_inhabited = false;\n-                    }\n-                    Some(true) => {}\n-                }\n-            }\n-            if definitely_inhabited { Some(true) } else { None }\n-        }\n-\n         fn variant_find_init_error<'tcx>(\n             cx: &LateContext<'tcx>,\n             variant: &VariantDef,\n@@ -2599,11 +2563,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                     // And now, enums.\n                     let span = cx.tcx.def_span(adt_def.did());\n                     let mut potential_variants = adt_def.variants().iter().filter_map(|variant| {\n-                        let inhabited = tys_inhabited(\n-                            cx,\n-                            variant.fields.iter().map(|field| field.ty(cx.tcx, substs)),\n-                        );\n-                        let definitely_inhabited = match inhabited {\n+                        let definitely_inhabited = match variant\n+                            .inhabited_predicate(cx.tcx, *adt_def)\n+                            .subst(cx.tcx, substs)\n+                            .apply_any_module(cx.tcx, cx.param_env)\n+                        {\n                             // Entirely skip uninhbaited variants.\n                             Some(false) => return None,\n                             // Forward the others, but remember which ones are definitely inhabited."}, {"sha": "2ab3b0d27c88a3104657381961d43f68a1584802", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -1643,14 +1643,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    /// Computes the set of modules from which this type is visibly uninhabited.\n-    /// To check whether a type is uninhabited at all (not just from a given module), you could\n-    /// check whether the forest is empty.\n-    query type_uninhabited_from(\n-        key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> ty::inhabitedness::DefIdForest<'tcx> {\n-        desc { \"computing the inhabitedness of `{}`\", key.value }\n-        remap_env_constness\n+    query inhabited_predicate_adt(key: DefId) -> ty::inhabitedness::InhabitedPredicate<'tcx> {\n+        desc { \"computing the uninhabited predicate of `{:?}`\", key }\n+    }\n+\n+    /// Do not call this query directly: invoke `Ty::inhabited_predicate` instead.\n+    query inhabited_predicate_type(key: Ty<'tcx>) -> ty::inhabitedness::InhabitedPredicate<'tcx> {\n+        desc { \"computing the uninhabited predicate of `{}`\", key }\n     }\n \n     query dep_kind(_: CrateNum) -> CrateDepKind {"}, {"sha": "c4ad698ba763531896eb8d5e1a633c2c4afb0228", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6e95b6da885f42a4e1314595089fa4295e329d11/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e95b6da885f42a4e1314595089fa4295e329d11/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=6e95b6da885f42a4e1314595089fa4295e329d11", "patch": "@@ -1,145 +0,0 @@\n-use crate::ty::context::TyCtxt;\n-use crate::ty::{DefId, DefIdTree};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use smallvec::SmallVec;\n-use std::mem;\n-\n-use DefIdForest::*;\n-\n-/// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n-/// if a `DefId` representing a module is contained in the forest then all\n-/// `DefId`s defined in that module or submodules are also implicitly contained\n-/// in the forest.\n-///\n-/// This is used to represent a set of modules in which a type is visibly\n-/// uninhabited.\n-///\n-/// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n-/// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n-/// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n-#[derive(Copy, Clone, HashStable, Debug)]\n-pub enum DefIdForest<'a> {\n-    Empty,\n-    Single(DefId),\n-    /// This variant is very rare.\n-    /// Invariant: >1 elements\n-    Multiple(&'a [DefId]),\n-}\n-\n-/// Tests whether a slice of roots contains a given DefId.\n-#[inline]\n-fn slice_contains<'tcx>(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n-    slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n-}\n-\n-impl<'tcx> DefIdForest<'tcx> {\n-    /// Creates an empty forest.\n-    pub fn empty() -> DefIdForest<'tcx> {\n-        DefIdForest::Empty\n-    }\n-\n-    /// Creates a forest consisting of a single tree representing the entire\n-    /// crate.\n-    #[inline]\n-    pub fn full() -> DefIdForest<'tcx> {\n-        DefIdForest::from_id(CRATE_DEF_ID.to_def_id())\n-    }\n-\n-    /// Creates a forest containing a `DefId` and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForest<'tcx> {\n-        DefIdForest::Single(id)\n-    }\n-\n-    fn as_slice(&self) -> &[DefId] {\n-        match self {\n-            Empty => &[],\n-            Single(id) => std::slice::from_ref(id),\n-            Multiple(root_ids) => root_ids,\n-        }\n-    }\n-\n-    // Only allocates in the rare `Multiple` case.\n-    fn from_vec(tcx: TyCtxt<'tcx>, root_ids: SmallVec<[DefId; 1]>) -> DefIdForest<'tcx> {\n-        match &root_ids[..] {\n-            [] => Empty,\n-            [id] => Single(*id),\n-            _ => DefIdForest::Multiple(tcx.arena.alloc_from_iter(root_ids)),\n-        }\n-    }\n-\n-    /// Tests whether the forest is empty.\n-    pub fn is_empty(&self) -> bool {\n-        match self {\n-            Empty => true,\n-            Single(..) | Multiple(..) => false,\n-        }\n-    }\n-\n-    /// Iterate over the set of roots.\n-    fn iter(&self) -> impl Iterator<Item = DefId> + '_ {\n-        self.as_slice().iter().copied()\n-    }\n-\n-    /// Tests whether the forest contains a given DefId.\n-    pub fn contains(&self, tcx: TyCtxt<'tcx>, id: DefId) -> bool {\n-        slice_contains(tcx, self.as_slice(), id)\n-    }\n-\n-    /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n-    where\n-        I: IntoIterator<Item = DefIdForest<'tcx>>,\n-    {\n-        let mut iter = iter.into_iter();\n-        let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n-            SmallVec::from_slice(first.as_slice())\n-        } else {\n-            return DefIdForest::full();\n-        };\n-\n-        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n-        for next_forest in iter {\n-            // No need to continue if the intersection is already empty.\n-            if ret.is_empty() || next_forest.is_empty() {\n-                return DefIdForest::empty();\n-            }\n-\n-            // We keep the elements in `ret` that are also in `next_forest`.\n-            next_ret.extend(ret.iter().copied().filter(|&id| next_forest.contains(tcx, id)));\n-            // We keep the elements in `next_forest` that are also in `ret`.\n-            next_ret.extend(next_forest.iter().filter(|&id| slice_contains(tcx, &ret, id)));\n-\n-            mem::swap(&mut next_ret, &mut ret);\n-            next_ret.clear();\n-        }\n-        DefIdForest::from_vec(tcx, ret)\n-    }\n-\n-    /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n-    where\n-        I: IntoIterator<Item = DefIdForest<'tcx>>,\n-    {\n-        let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n-        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n-        for next_forest in iter {\n-            // Union with the empty set is a no-op.\n-            if next_forest.is_empty() {\n-                continue;\n-            }\n-\n-            // We add everything in `ret` that is not in `next_forest`.\n-            next_ret.extend(ret.iter().copied().filter(|&id| !next_forest.contains(tcx, id)));\n-            // We add everything in `next_forest` that we haven't added yet.\n-            for id in next_forest.iter() {\n-                if !slice_contains(tcx, &next_ret, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n-\n-            mem::swap(&mut next_ret, &mut ret);\n-            next_ret.clear();\n-        }\n-        DefIdForest::from_vec(tcx, ret)\n-    }\n-}"}, {"sha": "b7aa455727dae4b717ff750850f68559a0ad6666", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -0,0 +1,204 @@\n+use crate::ty::context::TyCtxt;\n+use crate::ty::{self, DefId, DefIdTree, ParamEnv, Ty};\n+\n+/// Represents whether some type is inhabited in a given context.\n+/// Examples of uninhabited types are `!`, `enum Void {}`, or a struct\n+/// containing either of those types.\n+/// A type's inhabitedness may depend on the `ParamEnv` as well as what types\n+/// are visible in the current module.\n+#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+pub enum InhabitedPredicate<'tcx> {\n+    /// Inhabited\n+    True,\n+    /// Uninhabited\n+    False,\n+    /// Uninhabited when a const value is non-zero. This occurs when there is an\n+    /// array of uninhabited items, but the array is inhabited if it is empty.\n+    ConstIsZero(ty::Const<'tcx>),\n+    /// Uninhabited if within a certain module. This occurs when an uninhabited\n+    /// type has restricted visibility.\n+    NotInModule(DefId),\n+    /// Inhabited if some generic type is inhabited.\n+    /// These are replaced by calling [`Self::subst`].\n+    GenericType(Ty<'tcx>),\n+    /// A AND B\n+    And(&'tcx [InhabitedPredicate<'tcx>; 2]),\n+    /// A OR B\n+    Or(&'tcx [InhabitedPredicate<'tcx>; 2]),\n+}\n+\n+impl<'tcx> InhabitedPredicate<'tcx> {\n+    /// Returns true if the corresponding type is inhabited in the given\n+    /// `ParamEnv` and module\n+    pub fn apply(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, module_def_id: DefId) -> bool {\n+        let Ok(result) = self\n+            .apply_inner::<!>(tcx, param_env, &|id| Ok(tcx.is_descendant_of(module_def_id, id)));\n+        result\n+    }\n+\n+    /// Same as `apply`, but returns `None` if self contains a module predicate\n+    pub fn apply_any_module(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n+        self.apply_inner(tcx, param_env, &|_| Err(())).ok()\n+    }\n+\n+    fn apply_inner<E>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        in_module: &impl Fn(DefId) -> Result<bool, E>,\n+    ) -> Result<bool, E> {\n+        match self {\n+            Self::False => Ok(false),\n+            Self::True => Ok(true),\n+            Self::ConstIsZero(const_) => match const_.try_eval_usize(tcx, param_env) {\n+                None | Some(0) => Ok(true),\n+                Some(1..) => Ok(false),\n+            },\n+            Self::NotInModule(id) => in_module(id).map(|in_mod| !in_mod),\n+            Self::GenericType(_) => Ok(true),\n+            Self::And([a, b]) => try_and(a, b, |x| x.apply_inner(tcx, param_env, in_module)),\n+            Self::Or([a, b]) => try_or(a, b, |x| x.apply_inner(tcx, param_env, in_module)),\n+        }\n+    }\n+\n+    pub fn and(self, tcx: TyCtxt<'tcx>, other: Self) -> Self {\n+        self.reduce_and(tcx, other).unwrap_or_else(|| Self::And(tcx.arena.alloc([self, other])))\n+    }\n+\n+    pub fn or(self, tcx: TyCtxt<'tcx>, other: Self) -> Self {\n+        self.reduce_or(tcx, other).unwrap_or_else(|| Self::Or(tcx.arena.alloc([self, other])))\n+    }\n+\n+    pub fn all(tcx: TyCtxt<'tcx>, iter: impl IntoIterator<Item = Self>) -> Self {\n+        let mut result = Self::True;\n+        for pred in iter {\n+            if matches!(pred, Self::False) {\n+                return Self::False;\n+            }\n+            result = result.and(tcx, pred);\n+        }\n+        result\n+    }\n+\n+    pub fn any(tcx: TyCtxt<'tcx>, iter: impl IntoIterator<Item = Self>) -> Self {\n+        let mut result = Self::False;\n+        for pred in iter {\n+            if matches!(pred, Self::True) {\n+                return Self::True;\n+            }\n+            result = result.or(tcx, pred);\n+        }\n+        result\n+    }\n+\n+    fn reduce_and(self, tcx: TyCtxt<'tcx>, other: Self) -> Option<Self> {\n+        match (self, other) {\n+            (Self::True, a) | (a, Self::True) => Some(a),\n+            (Self::False, _) | (_, Self::False) => Some(Self::False),\n+            (Self::ConstIsZero(a), Self::ConstIsZero(b)) if a == b => Some(Self::ConstIsZero(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if a == b => Some(Self::NotInModule(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(a, b) => {\n+                Some(Self::NotInModule(b))\n+            }\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(b, a) => {\n+                Some(Self::NotInModule(a))\n+            }\n+            (Self::GenericType(a), Self::GenericType(b)) if a == b => Some(Self::GenericType(a)),\n+            (Self::And(&[a, b]), c) | (c, Self::And(&[a, b])) => {\n+                if let Some(ac) = a.reduce_and(tcx, c) {\n+                    Some(ac.and(tcx, b))\n+                } else if let Some(bc) = b.reduce_and(tcx, c) {\n+                    Some(Self::And(tcx.arena.alloc([a, bc])))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn reduce_or(self, tcx: TyCtxt<'tcx>, other: Self) -> Option<Self> {\n+        match (self, other) {\n+            (Self::True, _) | (_, Self::True) => Some(Self::True),\n+            (Self::False, a) | (a, Self::False) => Some(a),\n+            (Self::ConstIsZero(a), Self::ConstIsZero(b)) if a == b => Some(Self::ConstIsZero(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if a == b => Some(Self::NotInModule(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(a, b) => {\n+                Some(Self::NotInModule(a))\n+            }\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(b, a) => {\n+                Some(Self::NotInModule(b))\n+            }\n+            (Self::GenericType(a), Self::GenericType(b)) if a == b => Some(Self::GenericType(a)),\n+            (Self::Or(&[a, b]), c) | (c, Self::Or(&[a, b])) => {\n+                if let Some(ac) = a.reduce_or(tcx, c) {\n+                    Some(ac.or(tcx, b))\n+                } else if let Some(bc) = b.reduce_or(tcx, c) {\n+                    Some(Self::Or(tcx.arena.alloc([a, bc])))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Replaces generic types with its corresponding predicate\n+    pub fn subst(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Self {\n+        self.subst_opt(tcx, substs).unwrap_or(self)\n+    }\n+\n+    fn subst_opt(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Option<Self> {\n+        match self {\n+            Self::ConstIsZero(c) => {\n+                let c = ty::EarlyBinder(c).subst(tcx, substs);\n+                let pred = match c.kind().try_to_machine_usize(tcx) {\n+                    Some(0) => Self::True,\n+                    Some(1..) => Self::False,\n+                    None => Self::ConstIsZero(c),\n+                };\n+                Some(pred)\n+            }\n+            Self::GenericType(t) => {\n+                Some(ty::EarlyBinder(t).subst(tcx, substs).inhabited_predicate(tcx))\n+            }\n+            Self::And(&[a, b]) => match a.subst_opt(tcx, substs) {\n+                None => b.subst_opt(tcx, substs).map(|b| a.and(tcx, b)),\n+                Some(InhabitedPredicate::False) => Some(InhabitedPredicate::False),\n+                Some(a) => Some(a.and(tcx, b.subst_opt(tcx, substs).unwrap_or(b))),\n+            },\n+            Self::Or(&[a, b]) => match a.subst_opt(tcx, substs) {\n+                None => b.subst_opt(tcx, substs).map(|b| a.or(tcx, b)),\n+                Some(InhabitedPredicate::True) => Some(InhabitedPredicate::True),\n+                Some(a) => Some(a.or(tcx, b.subst_opt(tcx, substs).unwrap_or(b))),\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+// this is basically like `f(a)? && f(b)?` but different in the case of\n+// `Ok(false) && Err(_) -> Ok(false)`\n+fn try_and<T, E>(a: T, b: T, f: impl Fn(T) -> Result<bool, E>) -> Result<bool, E> {\n+    let a = f(a);\n+    if matches!(a, Ok(false)) {\n+        return Ok(false);\n+    }\n+    match (a, f(b)) {\n+        (_, Ok(false)) | (Ok(false), _) => Ok(false),\n+        (Ok(true), Ok(true)) => Ok(true),\n+        (Err(e), _) | (_, Err(e)) => Err(e),\n+    }\n+}\n+\n+fn try_or<T, E>(a: T, b: T, f: impl Fn(T) -> Result<bool, E>) -> Result<bool, E> {\n+    let a = f(a);\n+    if matches!(a, Ok(true)) {\n+        return Ok(true);\n+    }\n+    match (a, f(b)) {\n+        (_, Ok(true)) | (Ok(true), _) => Ok(true),\n+        (Ok(false), Ok(false)) => Ok(false),\n+        (Err(e), _) | (_, Err(e)) => Err(e),\n+    }\n+}"}, {"sha": "279a728ea392257d6ed8afb639122c211079dafe", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 111, "deletions": 147, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -1,57 +1,60 @@\n-pub use self::def_id_forest::DefIdForest;\n+//! This module contains logic for determining whether a type is inhabited or\n+//! uninhabited. The [`InhabitedPredicate`] type captures the minimum\n+//! information needed to determine whether a type is inhabited given a\n+//! `ParamEnv` and module ID.\n+//!\n+//! # Example\n+//! ```rust\n+//! enum Void {}\n+//! mod a {\n+//!     pub mod b {\n+//!         pub struct SecretlyUninhabited {\n+//!             _priv: !,\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! mod c {\n+//!     pub struct AlsoSecretlyUninhabited {\n+//!         _priv: Void,\n+//!     }\n+//!     mod d {\n+//!     }\n+//! }\n+//!\n+//! struct Foo {\n+//!     x: a::b::SecretlyUninhabited,\n+//!     y: c::AlsoSecretlyUninhabited,\n+//! }\n+//! ```\n+//! In this code, the type `Foo` will only be visibly uninhabited inside the\n+//! modules `b`, `c` and `d`. Calling `uninhabited_predicate` on `Foo` will\n+//! return `NotInModule(b) AND NotInModule(c)`.\n+//!\n+//! We need this information for pattern-matching on `Foo` or types that contain\n+//! `Foo`.\n+//!\n+//! # Example\n+//! ```rust\n+//! let foo_result: Result<T, Foo> = ... ;\n+//! let Ok(t) = foo_result;\n+//! ```\n+//! This code should only compile in modules where the uninhabitedness of `Foo`\n+//! is visible.\n \n-use crate::ty;\n use crate::ty::context::TyCtxt;\n-use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n-use crate::ty::{AdtKind, Visibility};\n-use crate::ty::{DefId, SubstsRef};\n+use crate::ty::{self, DefId, Ty, VariantDef, Visibility};\n \n use rustc_type_ir::sty::TyKind::*;\n \n-mod def_id_forest;\n+pub mod inhabited_predicate;\n \n-// The methods in this module calculate `DefIdForest`s of modules in which an\n-// `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n-//\n-// # Example\n-// ```rust\n-// enum Void {}\n-// mod a {\n-//     pub mod b {\n-//         pub struct SecretlyUninhabited {\n-//             _priv: !,\n-//         }\n-//     }\n-// }\n-//\n-// mod c {\n-//     pub struct AlsoSecretlyUninhabited {\n-//         _priv: Void,\n-//     }\n-//     mod d {\n-//     }\n-// }\n-//\n-// struct Foo {\n-//     x: a::b::SecretlyUninhabited,\n-//     y: c::AlsoSecretlyUninhabited,\n-// }\n-// ```\n-// In this code, the type `Foo` will only be visibly uninhabited inside the\n-// modules `b`, `c` and `d`. Calling `uninhabited_from` on `Foo` or its `AdtDef` will\n-// return the forest of modules {`b`, `c`->`d`} (represented in a `DefIdForest` by the\n-// set {`b`, `c`}).\n-//\n-// We need this information for pattern-matching on `Foo` or types that contain\n-// `Foo`.\n-//\n-// # Example\n-// ```rust\n-// let foo_result: Result<T, Foo> = ... ;\n-// let Ok(t) = foo_result;\n-// ```\n-// This code should only compile in modules where the uninhabitedness of `Foo` is\n-// visible.\n+pub use inhabited_predicate::InhabitedPredicate;\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers) {\n+    *providers =\n+        ty::query::Providers { inhabited_predicate_adt, inhabited_predicate_type, ..*providers };\n+}\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n@@ -100,131 +103,92 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty: Ty<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n-        // To check whether this type is uninhabited at all (not just from the\n-        // given node), you could check whether the forest is empty.\n-        // ```\n-        // forest.is_empty()\n-        // ```\n-        ty.uninhabited_from(self, param_env).contains(self, module)\n+        !ty.inhabited_predicate(self).apply(self, param_env, module)\n     }\n }\n \n-impl<'tcx> AdtDef<'tcx> {\n-    /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n-    fn uninhabited_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        // Non-exhaustive ADTs from other crates are always considered inhabited.\n-        if self.is_variant_list_non_exhaustive() && !self.did().is_local() {\n-            DefIdForest::empty()\n-        } else {\n-            DefIdForest::intersection(\n-                tcx,\n-                self.variants()\n-                    .iter()\n-                    .map(|v| v.uninhabited_from(tcx, substs, self.adt_kind(), param_env)),\n-            )\n+/// Returns an `InhabitedPredicate` that is generic over type parameters and\n+/// requires calling [`InhabitedPredicate::subst`]\n+fn inhabited_predicate_adt(tcx: TyCtxt<'_>, def_id: DefId) -> InhabitedPredicate<'_> {\n+    if let Some(def_id) = def_id.as_local() {\n+        if matches!(tcx.representability(def_id), ty::Representability::Infinite) {\n+            return InhabitedPredicate::True;\n         }\n     }\n+    let adt = tcx.adt_def(def_id);\n+    InhabitedPredicate::any(\n+        tcx,\n+        adt.variants().iter().map(|variant| variant.inhabited_predicate(tcx, adt)),\n+    )\n }\n \n impl<'tcx> VariantDef {\n     /// Calculates the forest of `DefId`s from which this variant is visibly uninhabited.\n-    pub fn uninhabited_from(\n+    pub fn inhabited_predicate(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        adt_kind: AdtKind,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        let is_enum = match adt_kind {\n-            // For now, `union`s are never considered uninhabited.\n-            // The precise semantics of inhabitedness with respect to unions is currently undecided.\n-            AdtKind::Union => return DefIdForest::empty(),\n-            AdtKind::Enum => true,\n-            AdtKind::Struct => false,\n-        };\n-        // Non-exhaustive variants from other crates are always considered inhabited.\n+        adt: ty::AdtDef<'_>,\n+    ) -> InhabitedPredicate<'tcx> {\n+        debug_assert!(!adt.is_union());\n         if self.is_field_list_non_exhaustive() && !self.def_id.is_local() {\n-            DefIdForest::empty()\n-        } else {\n-            DefIdForest::union(\n-                tcx,\n-                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum, param_env)),\n-            )\n+            // Non-exhaustive variants from other crates are always considered inhabited.\n+            return InhabitedPredicate::True;\n         }\n-    }\n-}\n-\n-impl<'tcx> FieldDef {\n-    /// Calculates the forest of `DefId`s from which this field is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        is_enum: bool,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n-        if is_enum {\n-            data_uninhabitedness()\n-        } else {\n-            match self.vis {\n-                Visibility::Restricted(from) => {\n-                    let forest = DefIdForest::from_id(from);\n-                    let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));\n-                    DefIdForest::intersection(tcx, iter)\n+        InhabitedPredicate::all(\n+            tcx,\n+            self.fields.iter().map(|field| {\n+                let pred = tcx.type_of(field.did).inhabited_predicate(tcx);\n+                if adt.is_enum() {\n+                    return pred;\n                 }\n-                Visibility::Public => data_uninhabitedness(),\n-            }\n-        }\n+                match field.vis {\n+                    Visibility::Public => pred,\n+                    Visibility::Restricted(from) => {\n+                        pred.or(tcx, InhabitedPredicate::NotInModule(from))\n+                    }\n+                }\n+            }),\n+        )\n     }\n }\n \n impl<'tcx> Ty<'tcx> {\n-    /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        tcx.type_uninhabited_from(param_env.and(self))\n+    pub fn inhabited_predicate(self, tcx: TyCtxt<'tcx>) -> InhabitedPredicate<'tcx> {\n+        match self.kind() {\n+            // For now, union`s are always considered inhabited\n+            Adt(adt, _) if adt.is_union() => InhabitedPredicate::True,\n+            // Non-exhaustive ADTs from other crates are always considered inhabited\n+            Adt(adt, _) if adt.is_variant_list_non_exhaustive() && !adt.did().is_local() => {\n+                InhabitedPredicate::True\n+            }\n+            Never => InhabitedPredicate::False,\n+            Param(_) | Projection(_) => InhabitedPredicate::GenericType(self),\n+            Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n+            // use a query for more complex cases\n+            Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),\n+            // references and other types are inhabited\n+            _ => InhabitedPredicate::True,\n+        }\n     }\n }\n \n-// Query provider for `type_uninhabited_from`.\n-pub(crate) fn type_uninhabited_from<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> DefIdForest<'tcx> {\n-    let ty = key.value;\n-    let param_env = key.param_env;\n+/// N.B. this query should only be called through `Ty::inhabited_predicate`\n+fn inhabited_predicate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> InhabitedPredicate<'tcx> {\n     match *ty.kind() {\n-        Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n+        Adt(adt, substs) => tcx.inhabited_predicate_adt(adt.did()).subst(tcx, substs),\n \n-        Never => DefIdForest::full(),\n-\n-        Tuple(ref tys) => {\n-            DefIdForest::union(tcx, tys.iter().map(|ty| ty.uninhabited_from(tcx, param_env)))\n+        Tuple(tys) => {\n+            InhabitedPredicate::all(tcx, tys.iter().map(|ty| ty.inhabited_predicate(tcx)))\n         }\n \n-        Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n-            Some(0) | None => DefIdForest::empty(),\n-            // If the array is definitely non-empty, it's uninhabited if\n-            // the type of its elements is uninhabited.\n-            Some(1..) => ty.uninhabited_from(tcx, param_env),\n+        // If we can evaluate the array length before having a `ParamEnv`, then\n+        // we can simplify the predicate. This is an optimization.\n+        Array(ty, len) => match len.kind().try_to_machine_usize(tcx) {\n+            Some(0) => InhabitedPredicate::True,\n+            Some(1..) => ty.inhabited_predicate(tcx),\n+            None => ty.inhabited_predicate(tcx).or(tcx, InhabitedPredicate::ConstIsZero(len)),\n         },\n \n-        // References to uninitialised memory are valid for any type, including\n-        // uninhabited types, in unsafe code, so we treat all references as\n-        // inhabited.\n-        // The precise semantics of inhabitedness with respect to references is currently\n-        // undecided.\n-        Ref(..) => DefIdForest::empty(),\n-\n-        _ => DefIdForest::empty(),\n+        _ => bug!(\"unexpected TyKind, use `Ty::inhabited_predicate`\"),\n     }\n }"}, {"sha": "c2aef8178e2c7fe190f18540b051175235c8413b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -2694,14 +2694,14 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     closure::provide(providers);\n     context::provide(providers);\n     erase_regions::provide(providers);\n+    inhabitedness::provide(providers);\n     util::provide(providers);\n     print::provide(providers);\n     super::util::bug::provide(providers);\n     super::middle::provide(providers);\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         incoherent_impls: trait_def::incoherent_impls_provider,\n-        type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n         vtable_allocation: vtable::vtable_allocation_provider,\n         ..*providers"}, {"sha": "924d2f555b9ef4b1e99966a63975eb1628432582", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -264,14 +264,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let irrefutable = adt_def.variants().iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.tcx.features().exhaustive_patterns\n-                            && !v\n-                                .uninhabited_from(\n-                                    self.tcx,\n-                                    substs,\n-                                    adt_def.adt_kind(),\n-                                    self.param_env,\n-                                )\n-                                .is_empty()\n+                            && v.inhabited_predicate(self.tcx, adt_def)\n+                                .subst(self.tcx, substs)\n+                                .apply_any_module(self.tcx, self.param_env)\n+                                != Some(true)\n                     }\n                 }) && (adt_def.did().is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());"}, {"sha": "595abc8f66870d5e6d7be56c88df9dfc0dc2f828", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c2d862dd10718ba2b2a320c3390995ad414bc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=6c9c2d862dd10718ba2b2a320c3390995ad414bc", "patch": "@@ -988,10 +988,12 @@ impl<'tcx> SplitWildcard<'tcx> {\n                     .filter(|(_, v)| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                         // uninhabited.\n-                        let is_uninhabited = is_exhaustive_pat_feature\n-                            && v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n-                                .contains(cx.tcx, cx.module);\n-                        !is_uninhabited\n+                        !is_exhaustive_pat_feature\n+                            || v.inhabited_predicate(cx.tcx, *def).subst(cx.tcx, substs).apply(\n+                                cx.tcx,\n+                                cx.param_env,\n+                                cx.module,\n+                            )\n                     })\n                     .map(|(idx, _)| Variant(idx))\n                     .collect();"}]}