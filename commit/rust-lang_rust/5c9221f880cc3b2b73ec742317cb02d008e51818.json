{"sha": "5c9221f880cc3b2b73ec742317cb02d008e51818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjOTIyMWY4ODBjYzNiMmI3M2VjNzQyMzE3Y2IwMmQwMDhlNTE4MTg=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-03-07T07:14:26Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-03-08T08:01:29Z"}, "message": "Refactor: Cleanup one part of assign_ops lint\n\nRemoves a lot of indentation and separates lint emission from lint\nlogic. Only touches the `hir::ExprKind::AssignOp` part of the lint.", "tree": {"sha": "43874a1258be461bf10a357240ba86c739d0dc53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43874a1258be461bf10a357240ba86c739d0dc53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c9221f880cc3b2b73ec742317cb02d008e51818", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEvUKv4zqIn2RHUgCKtvoGpuDiZlsFAlyCIVsACgkQtvoGpuDi\nZlt3GRAAlXnUWWREruSQntpMuqJCKS36AFqfMSeCjw3alCSyrTRPpGD9Q8JoEGvN\n2lc9zO/PGCtjVdtILSp1vrld9f4MCBAAspLeEEI+LIencpKwTcQGEjsD/zK6Zuz7\n9vd9U8gLTa/k77VWi4NOofQziP3xIQ48HNoZJIvkZSIF+0YJkU+0avkfEr9tRgHP\nPW5wF/y3kxFucA6xYpojt6wM1tJpFiScTh0tberTH8Yxtfi+Xg193OG1hqWccOcv\nUJhbXU7nxe+ndcmqwuqnK2LzNa2KLn4DK5MnQkobyiUDWMI1KVTaLYqGx9yhhDPj\nEhSlDJ4uQqAw+ECIzPFQjVS2mzzA4ele4xGs0p3YtBPeq+mPAaBuoIjuGGQJV7G+\nd692li9PXgMbd3BFDRdAHzS6jZogujUlz5hKTazFK8hrNgjmValIQg30X0Cyl44K\ngmygqyAJhlGv43UShAcV0I/eeq1ErB+MW+czQ5MQ2CPe5oWgePwmjJUBNL3ZOEYh\nPcgrjyTCH/ZUNn/PJalUJrh7qttvtObY1WmKNt+jR79s3l2ZduA7vuMKuPLczURe\nk8vxkKVUO944AFThJtqwJ6RzBx17YSGCKyrhADM5PUldkAyErVGKyfh8Lq+NXrgv\nW7a18as1s3MZiGtJGqx/U1OooCgunXgAsIusO+y1bBrvFlp9ATk=\n=PUUU\n-----END PGP SIGNATURE-----", "payload": "tree 43874a1258be461bf10a357240ba86c739d0dc53\nparent 00baf7a1118f4b8332a47f68e8bebbac963a5dcb\nauthor Philipp Hansch <dev@phansch.net> 1551942866 +0100\ncommitter Philipp Hansch <dev@phansch.net> 1552032089 +0100\n\nRefactor: Cleanup one part of assign_ops lint\n\nRemoves a lot of indentation and separates lint emission from lint\nlogic. Only touches the `hir::ExprKind::AssignOp` part of the lint.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9221f880cc3b2b73ec742317cb02d008e51818", "html_url": "https://github.com/rust-lang/rust/commit/5c9221f880cc3b2b73ec742317cb02d008e51818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c9221f880cc3b2b73ec742317cb02d008e51818/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00baf7a1118f4b8332a47f68e8bebbac963a5dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/00baf7a1118f4b8332a47f68e8bebbac963a5dcb", "html_url": "https://github.com/rust-lang/rust/commit/00baf7a1118f4b8332a47f68e8bebbac963a5dcb"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "63ec98a5b3ae930228a4096eb95b8531f034f762", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5c9221f880cc3b2b73ec742317cb02d008e51818/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9221f880cc3b2b73ec742317cb02d008e51818/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=5c9221f880cc3b2b73ec742317cb02d008e51818", "patch": "@@ -68,52 +68,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n         match &expr.node {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n-                    if op.node == binop.node {\n-                        let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n-                            span_lint_and_then(\n-                                cx,\n-                                MISREFACTORED_ASSIGN_OP,\n-                                expr.span,\n-                                \"variable appears on both sides of an assignment operation\",\n-                                |db| {\n-                                    if let (Some(snip_a), Some(snip_r)) =\n-                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span))\n-                                    {\n-                                        let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                                        let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                                        let long =\n-                                            format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            &format!(\n-                                                \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n-                                                snip_a,\n-                                                snip_a,\n-                                                op.node.as_str(),\n-                                                snip_r,\n-                                                long\n-                                            ),\n-                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            \"or\",\n-                                            long,\n-                                            Applicability::MachineApplicable, // snippet\n-                                        );\n-                                    }\n-                                },\n-                            );\n-                        };\n-                        // lhs op= l op r\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n-                            lint(lhs, r);\n-                        }\n-                        // lhs op= l commutative_op r\n-                        if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n-                            lint(lhs, l);\n-                        }\n+                    if op.node != binop.node { return; }\n+                    // lhs op= l op r\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n+                    }\n+                    // lhs op= l commutative_op r\n+                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n             },\n@@ -234,6 +196,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n+fn lint_misrefactored_assign_op(cx: &LateContext<'_, '_>, expr: &hir::Expr, op: hir::BinOp, rhs: &hir::Expr, assignee: &hir::Expr, rhs_other: &hir::Expr) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |db| {\n+            if let (Some(snip_a), Some(snip_r)) =\n+                (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span))\n+            {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long =\n+                    format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n+                db.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.node.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                    Applicability::MachineApplicable,\n+                );\n+                db.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n fn is_commutative(op: hir::BinOpKind) -> bool {\n     use rustc::hir::BinOpKind::*;\n     match op {"}]}