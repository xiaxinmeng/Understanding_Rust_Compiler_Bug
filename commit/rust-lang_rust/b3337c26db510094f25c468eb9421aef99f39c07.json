{"sha": "b3337c26db510094f25c468eb9421aef99f39c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzM3YzI2ZGI1MTAwOTRmMjVjNDY4ZWI5NDIxYWVmOTlmMzljMDc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-13T16:21:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-13T16:29:57Z"}, "message": "Split main highlighting function up into a few subfunctions", "tree": {"sha": "88698377ff4728ecda2ed8c1fe97a67849fa78e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88698377ff4728ecda2ed8c1fe97a67849fa78e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3337c26db510094f25c468eb9421aef99f39c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3337c26db510094f25c468eb9421aef99f39c07", "html_url": "https://github.com/rust-lang/rust/commit/b3337c26db510094f25c468eb9421aef99f39c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3337c26db510094f25c468eb9421aef99f39c07/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098a8e7b2f61a0d7c6bb1b7ad949969a9bc9356c", "url": "https://api.github.com/repos/rust-lang/rust/commits/098a8e7b2f61a0d7c6bb1b7ad949969a9bc9356c", "html_url": "https://github.com/rust-lang/rust/commit/098a8e7b2f61a0d7c6bb1b7ad949969a9bc9356c"}], "stats": {"total": 263, "additions": 146, "deletions": 117}, "files": [{"sha": "819d6784a5f772bb404d1fb7b35bf6757d811f77", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 146, "deletions": 117, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b3337c26db510094f25c468eb9421aef99f39c07/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3337c26db510094f25c468eb9421aef99f39c07/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=b3337c26db510094f25c468eb9421aef99f39c07", "patch": "@@ -31,129 +31,29 @@ pub(super) fn element(\n             bindings_shadow_count.clear();\n             return None;\n         }\n-\n         // Highlight definitions depending on the \"type\" of the definition.\n         NAME => {\n             let name = element.into_node().and_then(ast::Name::cast).unwrap();\n-            let name_kind = NameClass::classify(sema, &name);\n-\n-            if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n-                if let Some(name) = local.name(db) {\n-                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n-                    *shadow_count += 1;\n-                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                }\n-            };\n-\n-            match name_kind {\n-                Some(NameClass::Definition(def)) => {\n-                    let mut h = highlight_def(db, krate, def) | HlMod::Definition;\n-                    if let Definition::ModuleDef(hir::ModuleDef::Trait(trait_)) = &def {\n-                        if trait_.is_unsafe(db) {\n-                            h |= HlMod::Unsafe;\n-                        }\n-                    }\n-                    h\n-                }\n-                Some(NameClass::ConstReference(def)) => highlight_def(db, krate, def),\n-                Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n-                    let mut h = HlTag::Symbol(SymbolKind::Field).into();\n-                    if let hir::VariantDef::Union(_) = field_ref.parent_def(db) {\n-                        h |= HlMod::Unsafe;\n-                    }\n-                    h\n-                }\n-                None => highlight_name_by_syntax(name) | HlMod::Definition,\n-            }\n+            highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n         }\n         // Highlight references like the definitions they resolve to\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n             // FIXME: We highlight paths in attributes slightly differently to work around this module\n             // currently not knowing about tool attributes and rustc builtin attributes as\n             // we do not want to resolve those to functions that may be defined in scope.\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            match NameRefClass::classify(sema, &name_ref) {\n-                Some(name_class) => match name_class {\n-                    NameRefClass::Definition(Definition::ModuleDef(hir::ModuleDef::Module(_)))\n-                        if name_ref\n-                            .syntax()\n-                            .ancestors()\n-                            .find_map(ast::Path::cast)\n-                            .map_or(false, |it| it.parent_path().is_some()) =>\n-                    {\n-                        HlTag::Symbol(SymbolKind::Module)\n-                    }\n-                    NameRefClass::Definition(Definition::Macro(m))\n-                        if m.kind() == hir::MacroKind::Attr =>\n-                    {\n-                        HlTag::Symbol(SymbolKind::Macro)\n-                    }\n-                    _ => HlTag::BuiltinAttr,\n-                },\n-                None => HlTag::BuiltinAttr,\n-            }\n-            .into()\n+            highlight_name_ref_in_attr(sema, name_ref)\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            highlight_method_call_by_name_ref(sema, krate, &name_ref).unwrap_or_else(|| {\n-                let name_class = match NameRefClass::classify(sema, &name_ref) {\n-                    Some(name_kind) => name_kind,\n-                    None => {\n-                        return if syntactic_name_ref_highlighting {\n-                            highlight_name_ref_by_syntax(name_ref, sema, krate)\n-                        } else {\n-                            HlTag::UnresolvedReference.into()\n-                        }\n-                    }\n-                };\n-                let h = match name_class {\n-                    NameRefClass::Definition(def) => {\n-                        if let Definition::Local(local) = &def {\n-                            if let Some(name) = local.name(db) {\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(name.clone()).or_default();\n-                                binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                            }\n-                        };\n-\n-                        let mut h = highlight_def(db, krate, def);\n-\n-                        match def {\n-                            Definition::Local(local)\n-                                if is_consumed_lvalue(name_ref.syntax(), &local, db) =>\n-                            {\n-                                h |= HlMod::Consuming;\n-                            }\n-                            Definition::ModuleDef(hir::ModuleDef::Trait(trait_))\n-                                if trait_.is_unsafe(db) =>\n-                            {\n-                                if ast::Impl::for_trait_name_ref(&name_ref).is_some() {\n-                                    h |= HlMod::Unsafe;\n-                                }\n-                            }\n-                            Definition::Field(field) => {\n-                                if let Some(parent) = name_ref.syntax().parent() {\n-                                    if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n-                                        if let hir::VariantDef::Union(_) = field.parent_def(db) {\n-                                            h |= HlMod::Unsafe;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            _ => (),\n-                        }\n-\n-                        h\n-                    }\n-                    NameRefClass::FieldShorthand { .. } => SymbolKind::Field.into(),\n-                };\n-                if h.tag == HlTag::Symbol(SymbolKind::Module) && name_ref.self_token().is_some() {\n-                    SymbolKind::SelfParam.into()\n-                } else {\n-                    h\n-                }\n-            })\n+            highlight_name_ref(\n+                sema,\n+                krate,\n+                bindings_shadow_count,\n+                &mut binding_hash,\n+                syntactic_name_ref_highlighting,\n+                name_ref,\n+            )\n         }\n \n         // Simple token-based highlighting\n@@ -309,19 +209,148 @@ pub(super) fn element(\n     };\n \n     return Some((highlight, binding_hash));\n+}\n \n-    fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {\n-        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n-            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+fn highlight_name_ref_in_attr(sema: &Semantics<RootDatabase>, name_ref: ast::NameRef) -> Highlight {\n+    match NameRefClass::classify(sema, &name_ref) {\n+        Some(name_class) => match name_class {\n+            NameRefClass::Definition(Definition::ModuleDef(hir::ModuleDef::Module(_)))\n+                if name_ref\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::Path::cast)\n+                    .map_or(false, |it| it.parent_path().is_some()) =>\n+            {\n+                HlTag::Symbol(SymbolKind::Module)\n+            }\n+            NameRefClass::Definition(Definition::Macro(m)) if m.kind() == hir::MacroKind::Attr => {\n+                HlTag::Symbol(SymbolKind::Macro)\n+            }\n+            _ => HlTag::BuiltinAttr,\n+        },\n+        None => HlTag::BuiltinAttr,\n+    }\n+    .into()\n+}\n \n-            let mut hasher = DefaultHasher::new();\n-            x.hash(&mut hasher);\n-            hasher.finish()\n+fn highlight_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    krate: Option<hir::Crate>,\n+    bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n+    binding_hash: &mut Option<u64>,\n+    syntactic_name_ref_highlighting: bool,\n+    name_ref: ast::NameRef,\n+) -> Highlight {\n+    let db = sema.db;\n+    highlight_method_call_by_name_ref(sema, krate, &name_ref).unwrap_or_else(|| {\n+        let name_class = match NameRefClass::classify(sema, &name_ref) {\n+            Some(name_kind) => name_kind,\n+            None => {\n+                return if syntactic_name_ref_highlighting {\n+                    highlight_name_ref_by_syntax(name_ref, sema, krate)\n+                } else {\n+                    HlTag::UnresolvedReference.into()\n+                }\n+            }\n+        };\n+        let h = match name_class {\n+            NameRefClass::Definition(def) => {\n+                if let Definition::Local(local) = &def {\n+                    if let Some(name) = local.name(db) {\n+                        let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                        *binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                    }\n+                };\n+\n+                let mut h = highlight_def(db, krate, def);\n+\n+                match def {\n+                    Definition::Local(local)\n+                        if is_consumed_lvalue(name_ref.syntax(), &local, db) =>\n+                    {\n+                        h |= HlMod::Consuming;\n+                    }\n+                    Definition::ModuleDef(hir::ModuleDef::Trait(trait_))\n+                        if trait_.is_unsafe(db) =>\n+                    {\n+                        if ast::Impl::for_trait_name_ref(&name_ref).is_some() {\n+                            h |= HlMod::Unsafe;\n+                        }\n+                    }\n+                    Definition::Field(field) => {\n+                        if let Some(parent) = name_ref.syntax().parent() {\n+                            if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n+                                if let hir::VariantDef::Union(_) = field.parent_def(db) {\n+                                    h |= HlMod::Unsafe;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => (),\n+                }\n+\n+                h\n+            }\n+            NameRefClass::FieldShorthand { .. } => SymbolKind::Field.into(),\n+        };\n+        if h.tag == HlTag::Symbol(SymbolKind::Module) && name_ref.self_token().is_some() {\n+            SymbolKind::SelfParam.into()\n+        } else {\n+            h\n+        }\n+    })\n+}\n+\n+fn highlight_name(\n+    sema: &Semantics<RootDatabase>,\n+    bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n+    binding_hash: &mut Option<u64>,\n+    krate: Option<hir::Crate>,\n+    name: ast::Name,\n+) -> Highlight {\n+    let db = sema.db;\n+    let name_kind = NameClass::classify(sema, &name);\n+    if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n+        if let Some(name) = local.name(db) {\n+            let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+            *shadow_count += 1;\n+            *binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+        }\n+    };\n+    match name_kind {\n+        Some(NameClass::Definition(def)) => {\n+            let mut h = highlight_def(db, krate, def) | HlMod::Definition;\n+            if let Definition::ModuleDef(hir::ModuleDef::Trait(trait_)) = &def {\n+                if trait_.is_unsafe(db) {\n+                    h |= HlMod::Unsafe;\n+                }\n+            }\n+            h\n+        }\n+        Some(NameClass::ConstReference(def)) => highlight_def(db, krate, def),\n+        Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n+            let mut h = HlTag::Symbol(SymbolKind::Field).into();\n+            if let hir::VariantDef::Union(_) = field_ref.parent_def(db) {\n+                h |= HlMod::Unsafe;\n+            }\n+            h\n         }\n+        None => highlight_name_by_syntax(name) | HlMod::Definition,\n+    }\n+}\n \n-        hash((name, shadow_count))\n+fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {\n+    fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n+        use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+\n+        let mut hasher = DefaultHasher::new();\n+        x.hash(&mut hasher);\n+        hasher.finish()\n     }\n+\n+    hash((name, shadow_count))\n }\n+\n fn highlight_def(db: &RootDatabase, krate: Option<hir::Crate>, def: Definition) -> Highlight {\n     let mut h = match def {\n         Definition::Macro(_) => Highlight::new(HlTag::Symbol(SymbolKind::Macro)),"}]}