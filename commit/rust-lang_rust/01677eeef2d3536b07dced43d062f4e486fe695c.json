{"sha": "01677eeef2d3536b07dced43d062f4e486fe695c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNjc3ZWVlZjJkMzUzNmIwN2RjZWQ0M2QwNjJmNGU0ODZmZTY5NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-04T04:28:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-04T04:28:15Z"}, "message": "Auto merge of #38707 - redox-os:master, r=brson\n\nAdd socket timeout and ttl support in `sys::redox`\n\nThis adds support for `read_timeout`, `write_timeout`, and `ttl` on `TcpStream`, `TcpListener`, and `UdpSocket` in the `sys::redox` module.\n\nThe DNS lookup has been set to use a 5 second timeout by default.", "tree": {"sha": "254a5c725fd5e0380175dd8746abb0f491748d20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/254a5c725fd5e0380175dd8746abb0f491748d20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01677eeef2d3536b07dced43d062f4e486fe695c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01677eeef2d3536b07dced43d062f4e486fe695c", "html_url": "https://github.com/rust-lang/rust/commit/01677eeef2d3536b07dced43d062f4e486fe695c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01677eeef2d3536b07dced43d062f4e486fe695c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a68622c899883b9871b71d5ed600166e2254d230", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68622c899883b9871b71d5ed600166e2254d230", "html_url": "https://github.com/rust-lang/rust/commit/a68622c899883b9871b71d5ed600166e2254d230"}, {"sha": "c6858a1429895f27b4daafde9295deb494e2e29c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6858a1429895f27b4daafde9295deb494e2e29c", "html_url": "https://github.com/rust-lang/rust/commit/c6858a1429895f27b4daafde9295deb494e2e29c"}], "stats": {"total": 164, "additions": 129, "deletions": 35}, "files": [{"sha": "c5e1e107753ffa80c56b543d5e04e29daa5c689b", "filename": "src/librustc_back/target/redox_base.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=01677eeef2d3536b07dced43d062f4e486fe695c", "patch": "@@ -25,22 +25,14 @@ pub fn opts() -> TargetOptions {\n             \"-Wl,--as-needed\".to_string(),\n \n             // Always enable NX protection when it is available\n-            \"-Wl,-z,noexecstack\".to_string(),\n-\n-            // Static link\n-            \"-static\".to_string()\n-        ],\n-        late_link_args: vec![\n-            \"-lc\".to_string(),\n-            \"-lm\".to_string()\n+            \"-Wl,-z,noexecstack\".to_string()\n         ],\n         executables: true,\n         relocation_model: \"static\".to_string(),\n         disable_redzone: true,\n         eliminate_frame_pointer: false,\n         target_family: None,\n         linker_is_gnu: true,\n-        no_default_libraries: true,\n         lib_allocation_crate: \"alloc_system\".to_string(),\n         exe_allocation_crate: \"alloc_system\".to_string(),\n         has_elf_tls: true,"}, {"sha": "0291d7f0e927a7d3fc03c85b7f24b95dcafaa865", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=01677eeef2d3536b07dced43d062f4e486fe695c", "patch": "@@ -15,7 +15,7 @@ use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n use str::FromStr;\n use string::{String, ToString};\n use sys::syscall::EINVAL;\n-use time;\n+use time::{self, Duration};\n use vec::{IntoIter, Vec};\n \n use self::dns::{Dns, DnsQuery};\n@@ -69,6 +69,8 @@ pub fn lookup_host(host: &str) -> Result<LookupHost> {\n         let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n         let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n         let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0)))?;\n+        socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n+        socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n         socket.connect(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53)))?;\n         socket.send(&packet_data)?;\n "}, {"sha": "a3f202ccd97cbc492c2692c0692bb8e8448f7197", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=01677eeef2d3536b07dced43d062f4e486fe695c", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cmp;\n use io::{Error, ErrorKind, Result};\n+use mem;\n use net::{SocketAddr, Shutdown};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys::syscall::TimeSpec;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n use vec::Vec;\n@@ -77,15 +80,30 @@ impl TcpStream {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::read_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::write_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> {\n@@ -100,16 +118,36 @@ impl TcpStream {\n         Err(Error::new(ErrorKind::Other, \"TcpStream::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_ttl not implemented\"))\n-    }\n-\n-    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_read_timeout not implemented\"))\n-    }\n-\n-    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_write_timeout not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n+    }\n+\n+    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -168,7 +206,10 @@ impl TcpListener {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n@@ -179,8 +220,10 @@ impl TcpListener {\n         Err(Error::new(ErrorKind::Other, \"TcpListener::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::set_ttl not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n     }\n }\n "}, {"sha": "36f0819d308849cb8c087919fe0f4b8ee4fa46d4", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=01677eeef2d3536b07dced43d062f4e486fe695c", "patch": "@@ -9,10 +9,13 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n+use cmp;\n use io::{Error, ErrorKind, Result};\n+use mem;\n use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys::syscall::TimeSpec;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n@@ -109,15 +112,30 @@ impl UdpSocket {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::read_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::write_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> {\n@@ -144,16 +162,36 @@ impl UdpSocket {\n         Err(Error::new(ErrorKind::Other, \"UdpSocket::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_ttl not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n     }\n \n-    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_read_timeout not implemented\"))\n+    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n \n-    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_write_timeout not implemented\"))\n+    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n \n     pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {"}, {"sha": "a6b0ada72b8fb7ef17172df0e645e3964d858d79", "filename": "src/libstd/sys/redox/syscall/data.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01677eeef2d3536b07dced43d062f4e486fe695c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs?ref=01677eeef2d3536b07dced43d062f4e486fe695c", "patch": "@@ -84,3 +84,22 @@ pub struct TimeSpec {\n     pub tv_sec: i64,\n     pub tv_nsec: i32,\n }\n+\n+impl Deref for TimeSpec {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const TimeSpec as *const u8,\n+                                  mem::size_of::<TimeSpec>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for TimeSpec {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut TimeSpec as *mut u8,\n+                                      mem::size_of::<TimeSpec>()) as &mut [u8]\n+        }\n+    }\n+}"}]}