{"sha": "7ddfae74b1e22b4de71f0fe839577b985c545a64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZGZhZTc0YjFlMjJiNGRlNzFmMGZlODM5NTc3Yjk4NWM1NDVhNjQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-27T21:00:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-27T21:00:58Z"}, "message": "Rollup merge of #61878 - RalfJung:pin, r=Dylan-DPC\n\nimprove pinning projection docs\n\nThis tries to improve the explanation of structural pinning and pinning projections based on [this URLO thread](https://users.rust-lang.org/t/when-is-it-safe-to-move-a-member-value-out-of-a-pinned-future/28182).\n\nFixes https://github.com/rust-lang/rust/issues/61272.", "tree": {"sha": "589621b98d28c8fc232c1b18ae881838b2185dea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/589621b98d28c8fc232c1b18ae881838b2185dea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ddfae74b1e22b4de71f0fe839577b985c545a64", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdFS6KCRBK7hj4Ov3rIwAAdHIIAJ6dk1SVgiCy3O5cElnvJ9le\noBdYsTuX6JiMI55LW5givEFhva5gpUwYDeNVvAIrJvJ/gSDTHb+hbSnlIoAEaaro\nu4LQbkjRtJVJlhOyP0xbwJ26DV0gigm4SlbeiZtc2Z05wKp+2mvnz6k8sYWlkVCP\nqgMjz/RUTeWZfuvr8WJBWXipXynhlU+o/H0gqNt7x1sHF47hX03s0OcYdlNJCEYu\nRUrzMBo++q7RiV/3Py+gmyKmWfmuglpDiimdDGGZcSmO0pO7vEkiFEZnVRVQ5uCQ\nOTPhCcZsOrOr9bfqFX7OrPXYmLlj63dvAPsD69UGJxvDV5qi1bxjXxR0MCujHlI=\n=YIIa\n-----END PGP SIGNATURE-----\n", "payload": "tree 589621b98d28c8fc232c1b18ae881838b2185dea\nparent 8ebd67e4ee394cad9441a801f2022724ae7e07db\nparent bf03a3c539c30f518ca66dcd8ad3890a8b414d15\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1561669258 +0200\ncommitter GitHub <noreply@github.com> 1561669258 +0200\n\nRollup merge of #61878 - RalfJung:pin, r=Dylan-DPC\n\nimprove pinning projection docs\n\nThis tries to improve the explanation of structural pinning and pinning projections based on [this URLO thread](https://users.rust-lang.org/t/when-is-it-safe-to-move-a-member-value-out-of-a-pinned-future/28182).\n\nFixes https://github.com/rust-lang/rust/issues/61272.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ddfae74b1e22b4de71f0fe839577b985c545a64", "html_url": "https://github.com/rust-lang/rust/commit/7ddfae74b1e22b4de71f0fe839577b985c545a64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ddfae74b1e22b4de71f0fe839577b985c545a64/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ebd67e4ee394cad9441a801f2022724ae7e07db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebd67e4ee394cad9441a801f2022724ae7e07db", "html_url": "https://github.com/rust-lang/rust/commit/8ebd67e4ee394cad9441a801f2022724ae7e07db"}, {"sha": "bf03a3c539c30f518ca66dcd8ad3890a8b414d15", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf03a3c539c30f518ca66dcd8ad3890a8b414d15", "html_url": "https://github.com/rust-lang/rust/commit/bf03a3c539c30f518ca66dcd8ad3890a8b414d15"}], "stats": {"total": 171, "additions": 130, "deletions": 41}, "files": [{"sha": "c063cee52270ea448f9ae90e486484d17c26a6d3", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 130, "deletions": 41, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7ddfae74b1e22b4de71f0fe839577b985c545a64/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ddfae74b1e22b4de71f0fe839577b985c545a64/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=7ddfae74b1e22b4de71f0fe839577b985c545a64", "patch": "@@ -138,10 +138,11 @@\n //! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n-//! that *its memory will not get invalidated from the moment it gets pinned until\n+//! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n //! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n-//! off of a vector.\n+//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n+//! calling the destructor first.\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n //! section needs to function correctly.\n@@ -166,57 +167,130 @@\n //! implementation as well: if an element of your type could have been pinned,\n //! you must treat Drop as implicitly taking `Pin<&mut Self>`.\n //!\n-//! In particular, if your type is `#[repr(packed)]`, the compiler will automatically\n+//! For example, you could implement `Drop` as follows:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # struct Type { }\n+//! impl Drop for Type {\n+//!     fn drop(&mut self) {\n+//!         // `new_unchecked` is okay because we know this value is never used\n+//!         // again after being dropped.\n+//!         inner_drop(unsafe { Pin::new_unchecked(self)});\n+//!         fn inner_drop(this: Pin<&mut Type>) {\n+//!             // Actual drop code goes here.\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//! The function `inner_drop` has the type that `drop` *should* have, so this makes sure that\n+//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n+//!\n+//! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n //! move fields around to be able to drop them. As a consequence, you cannot use\n //! pinning with a `#[repr(packed)]` type.\n //!\n //! # Projections and Structural Pinning\n //!\n-//! One interesting question arises when considering the interaction of pinning\n-//! and the fields of a struct. When can a struct have a \"pinning projection\",\n-//! i.e., an operation with type `fn(Pin<&Struct>) -> Pin<&Field>`?  In a\n-//! similar vein, when can a generic wrapper type (such as `Vec<T>`, `Box<T>`,\n-//! or `RefCell<T>`) have an operation with type `fn(Pin<&Wrapper<T>>) ->\n-//! Pin<&T>`?\n-//!\n-//! Note: For the entirety of this discussion, the same applies for mutable references as it\n-//! does for shared references.\n+//! When working with pinned structs, the question arises how one can access the\n+//! fields of that struct in a method that takes just `Pin<&mut Struct>`.\n+//! The usual approach is to write helper methods (so called *projections*)\n+//! that turn `Pin<&mut Struct>` into a reference to the field, but what\n+//! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n+//! The same question arises with the fields of an `enum`, and also when considering\n+//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n+//! (This question applies to both mutable and shared references, we just\n+//! use the more common case of mutable references here for illustration.)\n+//!\n+//! It turns out that it is actually up to the author of the data structure\n+//! to decide whether the pinned projection for a particular field turns\n+//! `Pin<&mut Struct>` into `Pin<&mut Field>` or `&mut Field`. There are some\n+//! constraints though, and the most important constraint is *consistency*:\n+//! every field can be *either* projected to a pinned reference, *or* have\n+//! pinning removed as part of the projection. If both are done for the same field,\n+//! that will likely be unsound!\n+//!\n+//! As the author of a data structure you get to decide for each field whether pinning\n+//! \"propagates\" to this field or not. Pinning that propagates is also called \"structural\",\n+//! because it follows the structure of the type.\n+//! In the following subsections, we describe the considerations that have to be made\n+//! for either choice.\n+//!\n+//! ## Pinning *is not* structural for `field`\n+//!\n+//! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n+//! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n+//! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n+//! all you have to ensure is that you never create a pinned reference to that field.\n+//!\n+//! Fields without structural pinning may have a projection method that turns\n+//! `Pin<&mut Struct>` into `&mut Field`:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # type Field = i32;\n+//! # struct Struct { field: Field }\n+//! impl Struct {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!         // This is okay because `field` is never considered pinned.\n+//!         unsafe { &mut self.get_unchecked_mut().field }\n+//!     }\n+//! }\n+//! ```\n //!\n-//! Having a pinning projection for some field means that pinning is \"structural\":\n-//! when the wrapper is pinned, the field must be considered pinned, too.\n-//! After all, the pinning projection lets us get a `Pin<&Field>`.\n+//! You may also `impl Unpin for Struct` *even if* the type of `field`\n+//! is not `Unpin`. What that type thinks about pinning is not relevant\n+//! when no `Pin<&mut Field>` is ever created.\n+//!\n+//! ## Pinning *is* structural for `field`\n+//!\n+//! The other option is to decide that pinning is \"structural\" for `field`,\n+//! meaning that if the struct is pinned then so is the field.\n+//!\n+//! This allows writing a projection that creates a `Pin<&mut Field>`, thus\n+//! witnessing that the field is pinned:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # type Field = i32;\n+//! # struct Struct { field: Field }\n+//! impl Struct {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!         // This is okay because `field` is pinned when `self` is.\n+//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n+//!     }\n+//! }\n+//! ```\n //!\n-//! However, structural pinning comes with a few extra requirements, so not all\n-//! wrappers can be structural and hence not all wrappers can offer pinning projections:\n+//! However, structural pinning comes with a few extra requirements:\n //!\n-//! 1.  The wrapper must only be [`Unpin`] if all the structural fields are\n+//! 1.  The struct must only be [`Unpin`] if all the structural fields are\n //!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n-//!     the wrapper it is your responsibility *not* to add something like\n-//!     `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n+//!     the struct it is your responsibility *not* to add something like\n+//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)\n-//! 2.  The destructor of the wrapper must not move structural fields out of its argument. This\n+//! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n-//!     `&mut self`, but the wrapper (and hence its fields) might have been pinned before.\n+//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n //!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n-//!     In particular, as explained previously, this means that your wrapper type must *not*\n+//!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n+//!     See that section for how to write `drop` in a way that the compiler can help you\n+//!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!     once your wrapper is pinned, the memory that contains the\n+//!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n-//!     to call `drop` on all elements if one of the destructors panics. This violates the\n+//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of `VecDeque<T>`\n+//!     can fail to call `drop` on all elements if one of the destructors panics. This violates the\n //!     `Drop` guarantee, because it can lead to elements being deallocated without\n //!     their destructor being called. (`VecDeque` has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n-//!     the fields when your type is pinned. For example, if the wrapper contains an\n+//!     the structural fields when your type is pinned. For example, if the struct contains an\n //!     `Option<T>` and there is a `take`-like operation with type\n-//!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Wrapper<T>` -- which means\n-//!     pinning cannot be structural.\n+//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n+//!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n+//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n@@ -231,13 +305,16 @@\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n-//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense,\n-//! and the choice is up to the author. A `Vec<T>` with structural pinning could\n-//! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n+//! ## Examples\n+//!\n+//! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n+//! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! pinned references to elements. However, it could *not* allow calling\n //! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n //! Nor could it allow `push`, which might reallocate and thus also move the contents.\n //! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n //! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n@@ -249,16 +326,28 @@\n //! whether the content is pinned is entirely independent of whether the pointer is\n //! pinned, meaning pinning is *not* structural.\n //!\n+//! When implementing a [`Future`] combinator, you will usually need structural pinning\n+//! for the nested futures, as you need to get pinned references to them to call `poll`.\n+//! But if your combinator contains any other data that does not need to be pinned,\n+//! you can make those fields not structural and hence freely access them with a\n+//! mutable reference even when you just have `Pin<&mut Self>` (such as in your own\n+//! `poll` implementation).\n+//!\n //! [`Pin<P>`]: struct.Pin.html\n-//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n-//! [`Deref`]: ../../std/ops/trait.Deref.html\n-//! [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n-//! [`mem::swap`]: ../../std/mem/fn.swap.html\n-//! [`mem::forget`]: ../../std/mem/fn.forget.html\n+//! [`Unpin`]: ../marker/trait.Unpin.html\n+//! [`Deref`]: ../ops/trait.Deref.html\n+//! [`DerefMut`]: ../ops/trait.DerefMut.html\n+//! [`mem::swap`]: ../mem/fn.swap.html\n+//! [`mem::forget`]: ../mem/fn.forget.html\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n-//! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [`Some(v)`]: ../../std/option/enum.Option.html#variant.Some\n+//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+//! [`RefCell<T>`]: ../cell/struct.RefCell.html\n+//! [`None`]: ../option/enum.Option.html#variant.None\n+//! [`Some(v)`]: ../option/enum.Option.html#variant.Some\n+//! [`ptr::write`]: ../ptr/fn.write.html\n+//! [`Future`]: ../future/trait.Future.html\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n "}]}