{"sha": "7f0b9460cbdc16a30971e03593af99d0aaf06b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMGI5NDYwY2JkYzE2YTMwOTcxZTAzNTkzYWY5OWQwYWFmMDZiOTE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T14:27:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-10T14:27:36Z"}, "message": "Merge pull request #138 from oli-obk/master\n\nrefactor lvalue field projection handling to prepare for fewer `force_allocation`s", "tree": {"sha": "dd2b080df52fb46ec6f74b6782a9eaa00747c3e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2b080df52fb46ec6f74b6782a9eaa00747c3e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f0b9460cbdc16a30971e03593af99d0aaf06b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f0b9460cbdc16a30971e03593af99d0aaf06b91", "html_url": "https://github.com/rust-lang/rust/commit/7f0b9460cbdc16a30971e03593af99d0aaf06b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f0b9460cbdc16a30971e03593af99d0aaf06b91/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a2cdc2689a81cd4d1b9e0d43d36e27b6158b44e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2cdc2689a81cd4d1b9e0d43d36e27b6158b44e", "html_url": "https://github.com/rust-lang/rust/commit/5a2cdc2689a81cd4d1b9e0d43d36e27b6158b44e"}, {"sha": "2e185485b34b5ab783d9faa3f17ead6059b6341b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e185485b34b5ab783d9faa3f17ead6059b6341b", "html_url": "https://github.com/rust-lang/rust/commit/2e185485b34b5ab783d9faa3f17ead6059b6341b"}], "stats": {"total": 231, "additions": 121, "deletions": 110}, "files": [{"sha": "739274ce3986c36f4a1233b4f8ffeed212693d78", "filename": "src/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=7f0b9460cbdc16a30971e03593af99d0aaf06b91", "patch": "@@ -816,7 +816,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         } else {\n                             let (def_id, substs) = self.resolve_associated_const(def_id, substs);\n                             let cid = GlobalId { def_id, substs, promoted: None };\n-                            self.read_lvalue(Lvalue::Global(cid))\n+                            self.globals.get(&cid).expect(\"static/const not cached\").value\n                         }\n                     }\n \n@@ -826,7 +826,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             substs: self.substs(),\n                             promoted: Some(index),\n                         };\n-                        self.read_lvalue(Lvalue::Global(cid))\n+                        self.globals.get(&cid).expect(\"promoted not cached\").value\n                     }\n                 };\n "}, {"sha": "5ac5ad78b8aaf19087b025741503b27bcecb9e51", "filename": "src/lvalue.rs", "status": "modified", "additions": 87, "deletions": 69, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=7f0b9460cbdc16a30971e03593af99d0aaf06b91", "patch": "@@ -160,92 +160,103 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(lvalue)\n     }\n \n-    fn eval_lvalue_projection(\n+    pub fn lvalue_field(\n         &mut self,\n-        proj: &mir::LvalueProjection<'tcx>,\n+        base: Lvalue<'tcx>,\n+        field: usize,\n+        base_ty: Ty<'tcx>,\n+        field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n-        let base = self.eval_lvalue(&proj.base)?;\n-        let base_ty = self.lvalue_ty(&proj.base);\n         let base_layout = self.type_layout(base_ty)?;\n+        // FIXME(solson)\n+        let base = self.force_allocation(base)?;\n+        let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+\n+        let field_ty = self.monomorphize(field_ty, self.substs());\n+\n+        use rustc::ty::layout::Layout::*;\n+        let (offset, packed) = match *base_layout {\n+            Univariant { ref variant, .. } => {\n+                (variant.offsets[field], variant.packed)\n+            },\n+\n+            General { ref variants, .. } => {\n+                if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n+                    // +1 for the discriminant, which is field 0\n+                    (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n+                } else {\n+                    bug!(\"field access on enum had no variant index\");\n+                }\n+            }\n \n-        use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match proj.elem {\n-            Field(field, field_ty) => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n-\n-                let field_ty = self.monomorphize(field_ty, self.substs());\n-                let field = field.index();\n-\n-                use rustc::ty::layout::Layout::*;\n-                let (offset, packed) = match *base_layout {\n-                    Univariant { ref variant, .. } => {\n-                        (variant.offsets[field], variant.packed)\n-                    },\n-\n-                    General { ref variants, .. } => {\n-                        if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n-                            // +1 for the discriminant, which is field 0\n-                            (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n-                        } else {\n-                            bug!(\"field access on enum had no variant index\");\n-                        }\n-                    }\n+            RawNullablePointer { .. } => {\n+                assert_eq!(field, 0);\n+                return Ok(base);\n+            }\n \n-                    RawNullablePointer { .. } => {\n-                        assert_eq!(field, 0);\n-                        return Ok(base);\n-                    }\n+            StructWrappedNullablePointer { ref nonnull, .. } => {\n+                (nonnull.offsets[field], nonnull.packed)\n+            }\n \n-                    StructWrappedNullablePointer { ref nonnull, .. } => {\n-                        (nonnull.offsets[field], nonnull.packed)\n-                    }\n+            UntaggedUnion { .. } => return Ok(base),\n \n-                    UntaggedUnion { .. } => return Ok(base),\n+            Vector { element, count } => {\n+                let field = field as u64;\n+                assert!(field < count);\n+                let elem_size = element.size(&self.tcx.data_layout).bytes();\n+                (Size::from_bytes(field * elem_size), false)\n+            }\n \n-                    Vector { element, count } => {\n-                        let field = field as u64;\n-                        assert!(field < count);\n-                        let elem_size = element.size(&self.tcx.data_layout).bytes();\n-                        (Size::from_bytes(field * elem_size), false)\n-                    }\n+            _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n+        };\n \n-                    _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n-                };\n+        let offset = match base_extra {\n+            LvalueExtra::Vtable(tab) => {\n+                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n+                offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n+            }\n+            _ => offset.bytes(),\n+        };\n \n-                let offset = match base_extra {\n-                    LvalueExtra::Vtable(tab) => {\n-                        let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n-                        offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n-                    }\n-                    _ => offset.bytes(),\n-                };\n+        let ptr = base_ptr.offset(offset);\n \n-                let ptr = base_ptr.offset(offset);\n+        if packed {\n+            let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n+            self.memory.mark_packed(ptr, size);\n+        }\n \n-                if packed {\n-                    let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n-                    self.memory.mark_packed(ptr, size);\n-                }\n+        let extra = if self.type_is_sized(field_ty) {\n+            LvalueExtra::None\n+        } else {\n+            match base_extra {\n+                LvalueExtra::None => bug!(\"expected fat pointer\"),\n+                LvalueExtra::DowncastVariant(..) =>\n+                    bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                LvalueExtra::Vtable(_) |\n+                LvalueExtra::Length(_) => {},\n+            }\n+            base_extra\n+        };\n \n-                let extra = if self.type_is_sized(field_ty) {\n-                    LvalueExtra::None\n-                } else {\n-                    match base_extra {\n-                        LvalueExtra::None => bug!(\"expected fat pointer\"),\n-                        LvalueExtra::DowncastVariant(..) =>\n-                            bug!(\"Rust doesn't support unsized fields in enum variants\"),\n-                        LvalueExtra::Vtable(_) |\n-                        LvalueExtra::Length(_) => {},\n-                    }\n-                    base_extra\n-                };\n+        Ok(Lvalue::Ptr { ptr, extra })\n+    }\n \n-                (ptr, extra)\n+    fn eval_lvalue_projection(\n+        &mut self,\n+        proj: &mir::LvalueProjection<'tcx>,\n+    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        let (ptr, extra) = match proj.elem {\n+            Field(field, field_ty) => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n+                return self.lvalue_field(base, field.index(), base_ty, field_ty);\n             }\n \n             Downcast(_, variant) => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n+                let base_layout = self.type_layout(base_ty)?;\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, base_extra) = base.to_ptr_and_extra();\n@@ -260,6 +271,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Deref => {\n+                let base_ty = self.lvalue_ty(&proj.base);\n                 let val = self.eval_and_read_lvalue(&proj.base)?;\n \n                 let pointee_type = match base_ty.sty {\n@@ -285,6 +297,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Index(ref operand) => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n@@ -300,6 +314,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n@@ -319,6 +335,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Subslice { from, to } => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, _) = base.to_ptr_and_extra();"}, {"sha": "5c957f0cdc08b7e69b5c7a627ed2844824eeca29", "filename": "src/step.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=7f0b9460cbdc16a30971e03593af99d0aaf06b91", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::{subst, self};\n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup, MirRef};\n use lvalue::{Global, GlobalId, Lvalue};\n+use value::{Value, PrimVal};\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -89,15 +90,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest_layout = self.type_layout(dest_ty)?;\n \n                 match *dest_layout {\n-                    Layout::General { discr, ref variants, .. } => {\n-                        let discr_size = discr.size().bytes();\n-                        let discr_offset = variants[variant_index].offsets[0].bytes();\n+                    Layout::General { discr, .. } => {\n+                        // FIXME: I (oli-obk) think we need to check the\n+                        // `dest_ty` for the variant's discriminant and write\n+                        // instead of the variant index\n+                        // We don't have any tests actually going through these lines\n+                        let discr_ty = discr.to_ty(&self.tcx, false);\n+                        let discr_lval = self.lvalue_field(dest, 0, dest_ty, discr_ty)?;\n \n-                        // FIXME(solson)\n-                        let dest = self.force_allocation(dest)?;\n-                        let discr_dest = (dest.to_ptr()).offset(discr_offset);\n-\n-                        self.memory.write_uint(discr_dest, variant_index as u128, discr_size)?;\n+                        self.write_value(Value::ByVal(PrimVal::Bytes(variant_index as u128)), discr_lval, discr_ty)?;\n                     }\n \n                     Layout::RawNullablePointer { nndiscr, .. } => {"}, {"sha": "13c851244bfadcf37e58c1156c130d2661e9862b", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f0b9460cbdc16a30971e03593af99d0aaf06b91/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=7f0b9460cbdc16a30971e03593af99d0aaf06b91", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(adt_def, substs) => {\n                 // FIXME: some structs are represented as ByValPair\n-                let lval = self.force_allocation(lval)?;\n+                let mut lval = self.force_allocation(lval)?;\n                 let adt_ptr = match lval {\n                     Lvalue::Ptr { ptr, .. } => ptr,\n                     _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n@@ -104,22 +104,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n-                    },\n-                    Layout::General { ref variants, .. } => {\n+                    Layout::Univariant { .. } => &adt_def.struct_variant().fields,\n+                    Layout::General { .. } => {\n                         let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n+                        let ptr = self.force_allocation(lval)?.to_ptr();\n                         match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n-                            // start at offset 1, to skip over the discriminant\n-                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n+                            Some(i) => {\n+                                lval = Lvalue::Ptr {\n+                                    ptr,\n+                                    extra: LvalueExtra::DowncastVariant(i),\n+                                };\n+                                &adt_def.variants[i].fields\n+                            },\n                             None => return Err(EvalError::InvalidDiscriminant),\n                         }\n                     },\n-                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                    Layout::StructWrappedNullablePointer { nndiscr, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n                         if discr == nndiscr as u128 {\n                             assert_eq!(discr as usize as u128, discr);\n-                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n+                            &adt_def.variants[discr as usize].fields\n                         } else {\n                             // FIXME: the zst variant might contain zst types that impl Drop\n                             return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n@@ -146,18 +150,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let tcx = self.tcx;\n                 self.drop_fields(\n-                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    fields.iter().map(|field| monomorphize_field_ty(tcx, field, substs)),\n                     lval,\n+                    ty,\n                     drop,\n                 )?;\n             },\n-            ty::TyTuple(fields, _) => {\n-                let offsets = match *self.type_layout(ty)? {\n-                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n-                    _ => bug!(\"tuples must be univariant\"),\n-                };\n-                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n-            },\n+            ty::TyTuple(fields, _) => self.drop_fields(fields.into_iter().cloned(), lval, ty, drop)?,\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = match lval {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n@@ -208,25 +207,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn drop_fields<I>(\n         &mut self,\n-        mut fields: I,\n+        fields: I,\n         lval: Lvalue<'tcx>,\n+        ty: Ty<'tcx>,\n         drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n     ) -> EvalResult<'tcx>\n-        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n+        where I: Iterator<Item=Ty<'tcx>>,\n     {\n-        // FIXME: some aggregates may be represented by Value::ByValPair\n-        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n-        // manual iteration, because we need to be careful about the last field if it is unsized\n-        while let Some((field_ty, offset)) = fields.next() {\n-            let ptr = adt_ptr.offset(offset.bytes());\n-            if self.type_is_sized(field_ty) {\n-                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n-            } else {\n-                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n-                break; // if it is not sized, then this is the last field anyway\n-            }\n+        trace!(\"drop_fields: {:?} of type {}\", lval, ty);\n+        for (i, field_ty) in fields.enumerate() {\n+            let field_lval = self.lvalue_field(lval, i, ty, field_ty)?;\n+            self.drop(field_lval, field_ty, drop)?;\n         }\n-        assert!(fields.next().is_none());\n         Ok(())\n     }\n "}]}