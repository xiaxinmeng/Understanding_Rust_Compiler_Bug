{"sha": "1cc410710993d036730c11556039e40109f6ab41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYzQxMDcxMDk5M2QwMzY3MzBjMTE1NTYwMzllNDAxMDlmNmFiNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T22:21:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T22:21:55Z"}, "message": "Auto merge of #79867 - tmandry:rollup-7mubs3b, r=tmandry\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #79732 (minor stylistic clippy cleanups)\n - #79750 (Fix trimming of lint docs)\n - #79777 (Remove `first_merge` from liveness debug logs)\n - #79795 (Privatize some of libcore unicode_internals)\n - #79803 (Update xsv to prevent random CI failures)\n - #79810 (Account for gaps in def path table during decoding)\n - #79818 (Fixes to Rust coverage)\n - #79824 (Strip prefix instead of replacing it with empty string)\n - #79826 (Simplify visit_{foreign,trait}_item)\n - #79844 (Move RWUTable to a separate module)\n - #79861 (Update LLVM submodule)\n - #79862 (Remove tab-lock and replace it with ctrl+up/down arrows to switch between search result tabs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "caecfd6645df9d4f5952048915e8c08936ebb773", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caecfd6645df9d4f5952048915e8c08936ebb773"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc410710993d036730c11556039e40109f6ab41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc410710993d036730c11556039e40109f6ab41", "html_url": "https://github.com/rust-lang/rust/commit/1cc410710993d036730c11556039e40109f6ab41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc410710993d036730c11556039e40109f6ab41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f68778f798d6d34649745b41770829b17ba5b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f68778f798d6d34649745b41770829b17ba5b8", "html_url": "https://github.com/rust-lang/rust/commit/f0f68778f798d6d34649745b41770829b17ba5b8"}, {"sha": "f74f3b2f37aaad4d78b85404ec1cc5e525c550d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74f3b2f37aaad4d78b85404ec1cc5e525c550d1", "html_url": "https://github.com/rust-lang/rust/commit/f74f3b2f37aaad4d78b85404ec1cc5e525c550d1"}], "stats": {"total": 662, "additions": 374, "deletions": 288}, "files": [{"sha": "72ba5bbd5f26928596e8f1bf101267862b3af95f", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -241,7 +241,7 @@ fn save_function_record(\n /// (functions referenced by other \"used\" or public items). Any other functions considered unused,\n /// or \"Unreachable\" were still parsed and processed through the MIR stage.\n ///\n-/// We can find the unreachable functions by the set different of all MIR `DefId`s (`tcx` query\n+/// We can find the unreachable functions by the set difference of all MIR `DefId`s (`tcx` query\n /// `mir_keys`) minus the codegenned `DefId`s (`tcx` query `collect_and_partition_mono_items`).\n ///\n /// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and"}, {"sha": "cdd68d83f22b14fb2a2eacb57ed5886cef6daade", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                 (Some(ret_span), _) => {\n                     let sup_future = self.future_return_type(scope_def_id_sup);\n-                    let (return_type, action) = if let Some(_) = sup_future {\n+                    let (return_type, action) = if sup_future.is_some() {\n                         (\"returned future\", \"held across an await point\")\n                     } else {\n                         (\"return type\", \"returned\")\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 }\n                 (_, Some(ret_span)) => {\n                     let sub_future = self.future_return_type(scope_def_id_sub);\n-                    let (return_type, action) = if let Some(_) = sub_future {\n+                    let (return_type, action) = if sub_future.is_some() {\n                         (\"returned future\", \"held across an await point\")\n                     } else {\n                         (\"return type\", \"returned\")"}, {"sha": "6d61b86f32ef90155f131c86331cb7c0f1af1a70", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -131,7 +131,7 @@ impl NonCamelCaseTypes {\n                 let cc = to_camel_case(name);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Lowercase Letter\".\n-                if name.to_string() != cc {\n+                if *name != cc {\n                     err.span_suggestion(\n                         ident.span,\n                         \"convert the identifier to upper camel case\",\n@@ -271,7 +271,7 @@ impl NonSnakeCase {\n                 let mut err = lint.build(&msg);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Uppercase Letter\".\n-                if name.to_string() != sc {\n+                if *name != sc {\n                     // We have a valid span in almost all cases, but we don't have one when linting a crate\n                     // name provided via the command line.\n                     if !ident.span.is_dummy() {\n@@ -455,7 +455,7 @@ impl NonUpperCaseGlobals {\n                     lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name));\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Lowercase Letter\".\n-                if name.to_string() != uc {\n+                if *name != uc {\n                     err.span_suggestion(\n                         ident.span,\n                         \"convert the identifier to upper case\","}, {"sha": "43f7b2a992838746c54e886e741fb175470d1f4c", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -1553,6 +1553,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             return Some(DefId { krate, index: def_index_guess });\n         }\n \n+        let is_proc_macro = self.is_proc_macro_crate();\n+\n         // Slow path: We need to find out the new `DefIndex` of the provided\n         // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n         // stored in this crate.\n@@ -1561,9 +1563,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             let mut map = FxHashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n             for i in 0..end_id {\n                 let def_index = DefIndex::from_u32(i);\n-                let hash =\n-                    self.root.tables.def_path_hashes.get(self, def_index).unwrap().decode(self);\n-                map.insert(hash, def_index);\n+                // There may be gaps in the encoded table if we're decoding a proc-macro crate\n+                if let Some(hash) = self.root.tables.def_path_hashes.get(self, def_index) {\n+                    map.insert(hash.decode(self), def_index);\n+                } else if !is_proc_macro {\n+                    panic!(\"Missing def_path_hashes entry for {:?}\", def_index);\n+                }\n             }\n             map\n         });"}, {"sha": "6211cf8a9da858839483385e094333a79931a83f", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -445,7 +445,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n-        if type_name.find(&format!(\"'{}\", counter)).is_some() {\n+        if type_name.contains(&format!(\"'{}\", counter)) {\n             // Only add a label if we can confirm that a region was labelled.\n             RegionNameHighlight::CannotMatchHirTy(span, type_name)\n         } else {"}, {"sha": "2408a999c05a3ea587d308b5b5d857e5c1ca3131", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -33,7 +33,7 @@ impl CoverageGraph {\n         // Pre-transform MIR `BasicBlock` successors and predecessors into the BasicCoverageBlock\n         // equivalents. Note that since the BasicCoverageBlock graph has been fully simplified, the\n         // each predecessor of a BCB leader_bb should be in a unique BCB, and each successor of a\n-        // BCB last_bb should bin in its own unique BCB. Therefore, collecting the BCBs using\n+        // BCB last_bb should be in its own unique BCB. Therefore, collecting the BCBs using\n         // `bb_to_bcb` should work without requiring a deduplication step.\n \n         let successors = IndexVec::from_fn_n(\n@@ -283,7 +283,9 @@ rustc_index::newtype_index! {\n     }\n }\n \n-/// A BasicCoverageBlockData (BCB) represents the maximal-length sequence of MIR BasicBlocks without\n+/// `BasicCoverageBlockData` holds the data indexed by a `BasicCoverageBlock`.\n+///\n+/// A `BasicCoverageBlock` (BCB) represents the maximal-length sequence of MIR `BasicBlock`s without\n /// conditional branches, and form a new, simplified, coverage-specific Control Flow Graph, without\n /// altering the original MIR CFG.\n ///"}, {"sha": "f69748db238c08dcf69235ba32919ff35db23d24", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -88,6 +88,7 @@ struct Instrumentor<'a, 'tcx> {\n     pass_name: &'a str,\n     tcx: TyCtxt<'tcx>,\n     mir_body: &'a mut mir::Body<'tcx>,\n+    source_file: Lrc<SourceFile>,\n     fn_sig_span: Span,\n     body_span: Span,\n     basic_coverage_blocks: CoverageGraph,\n@@ -96,9 +97,13 @@ struct Instrumentor<'a, 'tcx> {\n \n impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let source_map = tcx.sess.source_map();\n         let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, mir_body.source.def_id());\n         let body_span = hir_body.value.span;\n-        let fn_sig_span = match some_fn_sig {\n+        let source_file = source_map.lookup_source_file(body_span.lo());\n+        let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n+            Lrc::ptr_eq(&source_file, &source_map.lookup_source_file(fn_sig.span.hi()))\n+        }) {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),\n             None => body_span.shrink_to_lo(),\n         };\n@@ -108,6 +113,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             pass_name,\n             tcx,\n             mir_body,\n+            source_file,\n             fn_sig_span,\n             body_span,\n             basic_coverage_blocks,\n@@ -268,8 +274,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let tcx = self.tcx;\n         let source_map = tcx.sess.source_map();\n         let body_span = self.body_span;\n-        let source_file = source_map.lookup_source_file(body_span.lo());\n-        let file_name = Symbol::intern(&source_file.name.to_string());\n+        let file_name = Symbol::intern(&self.source_file.name.to_string());\n \n         let mut bcb_counters = IndexVec::from_elem_n(None, self.basic_coverage_blocks.num_nodes());\n         for covspan in coverage_spans {\n@@ -285,11 +290,20 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 bug!(\"Every BasicCoverageBlock should have a Counter or Expression\");\n             };\n             graphviz_data.add_bcb_coverage_span_with_counter(bcb, &covspan, &counter_kind);\n+\n+            debug!(\n+                \"Calling make_code_region(file_name={}, source_file={:?}, span={}, body_span={})\",\n+                file_name,\n+                self.source_file,\n+                source_map.span_to_string(span),\n+                source_map.span_to_string(body_span)\n+            );\n+\n             inject_statement(\n                 self.mir_body,\n                 counter_kind,\n                 self.bcb_last_bb(bcb),\n-                Some(make_code_region(file_name, &source_file, span, body_span)),\n+                Some(make_code_region(file_name, &self.source_file, span, body_span)),\n             );\n         }\n     }"}, {"sha": "fd3e782f6df432cd65df46640fcfc367e746414f", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -217,6 +217,27 @@ pub struct CoverageSpans<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n+    /// Generate a minimal set of `CoverageSpan`s, each representing a contiguous code region to be\n+    /// counted.\n+    ///\n+    /// The basic steps are:\n+    ///\n+    /// 1. Extract an initial set of spans from the `Statement`s and `Terminator`s of each\n+    ///    `BasicCoverageBlockData`.\n+    /// 2. Sort the spans by span.lo() (starting position). Spans that start at the same position\n+    ///    are sorted with longer spans before shorter spans; and equal spans are sorted\n+    ///    (deterministically) based on \"dominator\" relationship (if any).\n+    /// 3. Traverse the spans in sorted order to identify spans that can be dropped (for instance,\n+    ///    if another span or spans are already counting the same code region), or should be merged\n+    ///    into a broader combined span (because it represents a contiguous, non-branching, and\n+    ///    uninterrupted region of source code).\n+    ///\n+    ///    Closures are exposed in their enclosing functions as `Assign` `Rvalue`s, and since\n+    ///    closures have their own MIR, their `Span` in their enclosing function should be left\n+    ///    \"uncovered\".\n+    ///\n+    /// Note the resulting vector of `CoverageSpan`s may not be fully sorted (and does not need\n+    /// to be).\n     pub(super) fn generate_coverage_spans(\n         mir_body: &'a mir::Body<'tcx>,\n         fn_sig_span: Span,\n@@ -247,27 +268,6 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n         coverage_spans.to_refined_spans()\n     }\n \n-    /// Generate a minimal set of `CoverageSpan`s, each representing a contiguous code region to be\n-    /// counted.\n-    ///\n-    /// The basic steps are:\n-    ///\n-    /// 1. Extract an initial set of spans from the `Statement`s and `Terminator`s of each\n-    ///    `BasicCoverageBlockData`.\n-    /// 2. Sort the spans by span.lo() (starting position). Spans that start at the same position\n-    ///    are sorted with longer spans before shorter spans; and equal spans are sorted\n-    ///    (deterministically) based on \"dominator\" relationship (if any).\n-    /// 3. Traverse the spans in sorted order to identify spans that can be dropped (for instance,\n-    ///    if another span or spans are already counting the same code region), or should be merged\n-    ///    into a broader combined span (because it represents a contiguous, non-branching, and\n-    ///    uninterrupted region of source code).\n-    ///\n-    ///    Closures are exposed in their enclosing functions as `Assign` `Rvalue`s, and since\n-    ///    closures have their own MIR, their `Span` in their enclosing function should be left\n-    ///    \"uncovered\".\n-    ///\n-    /// Note the resulting vector of `CoverageSpan`s does may not be fully sorted (and does not need\n-    /// to be).\n     fn mir_to_initial_sorted_coverage_spans(&self) -> Vec<CoverageSpan> {\n         let mut initial_spans = Vec::<CoverageSpan>::with_capacity(self.mir_body.num_nodes() * 2);\n         for (bcb, bcb_data) in self.basic_coverage_blocks.iter_enumerated() {"}, {"sha": "00152878d6d9bef999b1cb685d0d20fa44c85c2d", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -423,15 +423,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        match trait_item.kind {\n-            hir::TraitItemKind::Const(_, Some(_))\n-            | hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => {\n-                if has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id, &trait_item.attrs)\n-                {\n-                    self.worklist.push(trait_item.hir_id);\n-                }\n-            }\n-            _ => {}\n+        use hir::TraitItemKind::{Const, Fn};\n+        if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n+            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id, &trait_item.attrs)\n+        {\n+            self.worklist.push(trait_item.hir_id);\n         }\n     }\n \n@@ -440,17 +436,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        match foreign_item.kind {\n-            hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Fn(..) => {\n-                if has_allow_dead_code_or_lang_attr(\n-                    self.tcx,\n-                    foreign_item.hir_id,\n-                    &foreign_item.attrs,\n-                ) {\n-                    self.worklist.push(foreign_item.hir_id);\n-                }\n-            }\n-            _ => {}\n+        use hir::ForeignItemKind::{Fn, Static};\n+        if matches!(foreign_item.kind, Static(..) | Fn(..))\n+            && has_allow_dead_code_or_lang_attr(self.tcx, foreign_item.hir_id, &foreign_item.attrs)\n+        {\n+            self.worklist.push(foreign_item.hir_id);\n         }\n     }\n }"}, {"sha": "a161ad16b8c20ebeeb92a14dfc8f189e9624c0b9", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 11, "deletions": 164, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -105,6 +105,8 @@ use std::io;\n use std::io::prelude::*;\n use std::rc::Rc;\n \n+mod rwu_table;\n+\n rustc_index::newtype_index! {\n     pub struct Variable {\n         DEBUG_FORMAT = \"v({})\",\n@@ -468,149 +470,6 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n-#[derive(Clone, Copy)]\n-struct RWU {\n-    reader: bool,\n-    writer: bool,\n-    used: bool,\n-}\n-\n-/// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n-/// RWU`s can get very large, so it uses a more compact representation.\n-struct RWUTable {\n-    /// Total number of live nodes.\n-    live_nodes: usize,\n-    /// Total number of variables.\n-    vars: usize,\n-\n-    /// A compressed representation of `RWU`s.\n-    ///\n-    /// Each word represents 2 different `RWU`s packed together. Each packed RWU\n-    /// is stored in 4 bits: a reader bit, a writer bit, a used bit and a\n-    /// padding bit.\n-    ///\n-    /// The data for each live node is contiguous and starts at a word boundary,\n-    /// so there might be an unused space left.\n-    words: Vec<u8>,\n-    /// Number of words per each live node.\n-    live_node_words: usize,\n-}\n-\n-impl RWUTable {\n-    const RWU_READER: u8 = 0b0001;\n-    const RWU_WRITER: u8 = 0b0010;\n-    const RWU_USED: u8 = 0b0100;\n-    const RWU_MASK: u8 = 0b1111;\n-\n-    /// Size of packed RWU in bits.\n-    const RWU_BITS: usize = 4;\n-    /// Size of a word in bits.\n-    const WORD_BITS: usize = std::mem::size_of::<u8>() * 8;\n-    /// Number of packed RWUs that fit into a single word.\n-    const WORD_RWU_COUNT: usize = Self::WORD_BITS / Self::RWU_BITS;\n-\n-    fn new(live_nodes: usize, vars: usize) -> RWUTable {\n-        let live_node_words = (vars + Self::WORD_RWU_COUNT - 1) / Self::WORD_RWU_COUNT;\n-        Self { live_nodes, vars, live_node_words, words: vec![0u8; live_node_words * live_nodes] }\n-    }\n-\n-    fn word_and_shift(&self, ln: LiveNode, var: Variable) -> (usize, u32) {\n-        assert!(ln.index() < self.live_nodes);\n-        assert!(var.index() < self.vars);\n-\n-        let var = var.index();\n-        let word = var / Self::WORD_RWU_COUNT;\n-        let shift = Self::RWU_BITS * (var % Self::WORD_RWU_COUNT);\n-        (ln.index() * self.live_node_words + word, shift as u32)\n-    }\n-\n-    fn pick2_rows_mut(&mut self, a: LiveNode, b: LiveNode) -> (&mut [u8], &mut [u8]) {\n-        assert!(a.index() < self.live_nodes);\n-        assert!(b.index() < self.live_nodes);\n-        assert!(a != b);\n-\n-        let a_start = a.index() * self.live_node_words;\n-        let b_start = b.index() * self.live_node_words;\n-\n-        unsafe {\n-            let ptr = self.words.as_mut_ptr();\n-            (\n-                std::slice::from_raw_parts_mut(ptr.add(a_start), self.live_node_words),\n-                std::slice::from_raw_parts_mut(ptr.add(b_start), self.live_node_words),\n-            )\n-        }\n-    }\n-\n-    fn copy(&mut self, dst: LiveNode, src: LiveNode) {\n-        if dst == src {\n-            return;\n-        }\n-\n-        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        dst_row.copy_from_slice(src_row);\n-    }\n-\n-    /// Sets `dst` to the union of `dst` and `src`, returns true if `dst` was\n-    /// changed.\n-    fn union(&mut self, dst: LiveNode, src: LiveNode) -> bool {\n-        if dst == src {\n-            return false;\n-        }\n-\n-        let mut changed = false;\n-        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n-            let old = *dst_word;\n-            let new = *dst_word | src_word;\n-            *dst_word = new;\n-            changed |= old != new;\n-        }\n-        changed\n-    }\n-\n-    fn get_reader(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_READER != 0\n-    }\n-\n-    fn get_writer(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_WRITER != 0\n-    }\n-\n-    fn get_used(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_USED != 0\n-    }\n-\n-    fn get(&self, ln: LiveNode, var: Variable) -> RWU {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        let rwu_packed = self.words[word] >> shift;\n-        RWU {\n-            reader: rwu_packed & Self::RWU_READER != 0,\n-            writer: rwu_packed & Self::RWU_WRITER != 0,\n-            used: rwu_packed & Self::RWU_USED != 0,\n-        }\n-    }\n-\n-    fn set(&mut self, ln: LiveNode, var: Variable, rwu: RWU) {\n-        let mut packed = 0;\n-        if rwu.reader {\n-            packed |= Self::RWU_READER;\n-        }\n-        if rwu.writer {\n-            packed |= Self::RWU_WRITER;\n-        }\n-        if rwu.used {\n-            packed |= Self::RWU_USED;\n-        }\n-\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        let word = &mut self.words[word];\n-        *word = (*word & !(Self::RWU_MASK << shift)) | (packed << shift)\n-    }\n-}\n-\n const ACC_READ: u32 = 1;\n const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n@@ -623,7 +482,7 @@ struct Liveness<'a, 'tcx> {\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     closure_captures: Option<&'tcx FxIndexMap<hir::HirId, ty::UpvarId>>,\n     successors: IndexVec<LiveNode, Option<LiveNode>>,\n-    rwu_table: RWUTable,\n+    rwu_table: rwu_table::RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n     /// after closure exit. Used to calculate liveness of captured variables\n@@ -661,7 +520,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             upvars,\n             closure_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n-            rwu_table: RWUTable::new(num_live_nodes, num_vars),\n+            rwu_table: rwu_table::RWUTable::new(num_live_nodes, num_vars),\n             closure_ln,\n             exit_ln,\n             break_ln: Default::default(),\n@@ -781,19 +640,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"init_from_succ(ln={}, succ={})\", self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    fn merge_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode, first_merge: bool) -> bool {\n+    fn merge_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) -> bool {\n         if ln == succ_ln {\n             return false;\n         }\n \n         let changed = self.rwu_table.union(ln, succ_ln);\n-        debug!(\n-            \"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n-            ln,\n-            self.ln_str(succ_ln),\n-            first_merge,\n-            changed\n-        );\n+        debug!(\"merge_from_succ(ln={:?}, succ={}, changed={})\", ln, self.ln_str(succ_ln), changed);\n         changed\n     }\n \n@@ -802,7 +655,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let used = self.rwu_table.get_used(writer, var);\n-        self.rwu_table.set(writer, var, RWU { reader: false, writer: false, used });\n+        self.rwu_table.set(writer, var, rwu_table::RWU { reader: false, writer: false, used });\n         debug!(\"{:?} defines {:?}: {}\", writer, var, self.ln_str(writer));\n     }\n \n@@ -893,7 +746,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         };\n \n         // Propagate through calls to the closure.\n-        let mut first_merge = true;\n         loop {\n             self.init_from_succ(self.closure_ln, succ);\n             for param in body.params {\n@@ -903,10 +755,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            if !self.merge_from_succ(self.exit_ln, self.closure_ln, first_merge) {\n+            if !self.merge_from_succ(self.exit_ln, self.closure_ln) {\n                 break;\n             }\n-            first_merge = false;\n             assert_eq!(succ, self.propagate_through_expr(&body.value, self.exit_ln));\n         }\n \n@@ -1012,7 +863,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 //\n                 let ln = self.live_node(expr.hir_id, expr.span);\n                 self.init_empty(ln, succ);\n-                let mut first_merge = true;\n                 for arm in arms {\n                     let body_succ = self.propagate_through_expr(&arm.body, succ);\n \n@@ -1021,8 +871,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         body_succ,\n                     );\n                     let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n-                    self.merge_from_succ(ln, arm_succ, first_merge);\n-                    first_merge = false;\n+                    self.merge_from_succ(ln, arm_succ);\n                 }\n                 self.propagate_through_expr(&e, ln)\n             }\n@@ -1133,7 +982,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                 let ln = self.live_node(expr.hir_id, expr.span);\n                 self.init_from_succ(ln, succ);\n-                self.merge_from_succ(ln, r_succ, false);\n+                self.merge_from_succ(ln, r_succ);\n \n                 self.propagate_through_expr(&l, ln)\n             }\n@@ -1377,7 +1226,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         */\n \n         // first iteration:\n-        let mut first_merge = true;\n         let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n         debug!(\"propagate_through_loop: using id for loop body {} {:?}\", expr.hir_id, body);\n@@ -1389,8 +1237,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let body_ln = self.propagate_through_block(body, ln);\n \n         // repeat until fixed point is reached:\n-        while self.merge_from_succ(ln, body_ln, first_merge) {\n-            first_merge = false;\n+        while self.merge_from_succ(ln, body_ln) {\n             assert_eq!(body_ln, self.propagate_through_block(body, ln));\n         }\n "}, {"sha": "a1a6f27398ec86aede95a18945161017376989ae", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -0,0 +1,144 @@\n+use crate::liveness::{LiveNode, Variable};\n+\n+#[derive(Clone, Copy)]\n+pub(super) struct RWU {\n+    pub(super) reader: bool,\n+    pub(super) writer: bool,\n+    pub(super) used: bool,\n+}\n+\n+/// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n+/// RWU`s can get very large, so it uses a more compact representation.\n+pub(super) struct RWUTable {\n+    /// Total number of live nodes.\n+    live_nodes: usize,\n+    /// Total number of variables.\n+    vars: usize,\n+\n+    /// A compressed representation of `RWU`s.\n+    ///\n+    /// Each word represents 2 different `RWU`s packed together. Each packed RWU\n+    /// is stored in 4 bits: a reader bit, a writer bit, a used bit and a\n+    /// padding bit.\n+    ///\n+    /// The data for each live node is contiguous and starts at a word boundary,\n+    /// so there might be an unused space left.\n+    words: Vec<u8>,\n+    /// Number of words per each live node.\n+    live_node_words: usize,\n+}\n+\n+impl RWUTable {\n+    const RWU_READER: u8 = 0b0001;\n+    const RWU_WRITER: u8 = 0b0010;\n+    const RWU_USED: u8 = 0b0100;\n+    const RWU_MASK: u8 = 0b1111;\n+\n+    /// Size of packed RWU in bits.\n+    const RWU_BITS: usize = 4;\n+    /// Size of a word in bits.\n+    const WORD_BITS: usize = std::mem::size_of::<u8>() * 8;\n+    /// Number of packed RWUs that fit into a single word.\n+    const WORD_RWU_COUNT: usize = Self::WORD_BITS / Self::RWU_BITS;\n+\n+    pub(super) fn new(live_nodes: usize, vars: usize) -> RWUTable {\n+        let live_node_words = (vars + Self::WORD_RWU_COUNT - 1) / Self::WORD_RWU_COUNT;\n+        Self { live_nodes, vars, live_node_words, words: vec![0u8; live_node_words * live_nodes] }\n+    }\n+\n+    fn word_and_shift(&self, ln: LiveNode, var: Variable) -> (usize, u32) {\n+        assert!(ln.index() < self.live_nodes);\n+        assert!(var.index() < self.vars);\n+\n+        let var = var.index();\n+        let word = var / Self::WORD_RWU_COUNT;\n+        let shift = Self::RWU_BITS * (var % Self::WORD_RWU_COUNT);\n+        (ln.index() * self.live_node_words + word, shift as u32)\n+    }\n+\n+    fn pick2_rows_mut(&mut self, a: LiveNode, b: LiveNode) -> (&mut [u8], &mut [u8]) {\n+        assert!(a.index() < self.live_nodes);\n+        assert!(b.index() < self.live_nodes);\n+        assert!(a != b);\n+\n+        let a_start = a.index() * self.live_node_words;\n+        let b_start = b.index() * self.live_node_words;\n+\n+        unsafe {\n+            let ptr = self.words.as_mut_ptr();\n+            (\n+                std::slice::from_raw_parts_mut(ptr.add(a_start), self.live_node_words),\n+                std::slice::from_raw_parts_mut(ptr.add(b_start), self.live_node_words),\n+            )\n+        }\n+    }\n+\n+    pub(super) fn copy(&mut self, dst: LiveNode, src: LiveNode) {\n+        if dst == src {\n+            return;\n+        }\n+\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        dst_row.copy_from_slice(src_row);\n+    }\n+\n+    /// Sets `dst` to the union of `dst` and `src`, returns true if `dst` was\n+    /// changed.\n+    pub(super) fn union(&mut self, dst: LiveNode, src: LiveNode) -> bool {\n+        if dst == src {\n+            return false;\n+        }\n+\n+        let mut changed = false;\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n+            let old = *dst_word;\n+            let new = *dst_word | src_word;\n+            *dst_word = new;\n+            changed |= old != new;\n+        }\n+        changed\n+    }\n+\n+    pub(super) fn get_reader(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_READER != 0\n+    }\n+\n+    pub(super) fn get_writer(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_WRITER != 0\n+    }\n+\n+    pub(super) fn get_used(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_USED != 0\n+    }\n+\n+    pub(super) fn get(&self, ln: LiveNode, var: Variable) -> RWU {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let rwu_packed = self.words[word] >> shift;\n+        RWU {\n+            reader: rwu_packed & Self::RWU_READER != 0,\n+            writer: rwu_packed & Self::RWU_WRITER != 0,\n+            used: rwu_packed & Self::RWU_USED != 0,\n+        }\n+    }\n+\n+    pub(super) fn set(&mut self, ln: LiveNode, var: Variable, rwu: RWU) {\n+        let mut packed = 0;\n+        if rwu.reader {\n+            packed |= Self::RWU_READER;\n+        }\n+        if rwu.writer {\n+            packed |= Self::RWU_WRITER;\n+        }\n+        if rwu.used {\n+            packed |= Self::RWU_USED;\n+        }\n+\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let word = &mut self.words[word];\n+        *word = (*word & !(Self::RWU_MASK << shift)) | (packed << shift)\n+    }\n+}"}, {"sha": "aa4d57f7e1d97ef55b90a850a877de8fcda6d27c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -548,11 +548,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n                     if let Ok(src) = sm.span_to_snippet(sp) {\n-                        if let Some(src) = self.replace_prefix(&src, \"&\", \"\") {\n+                        if let Some(src) = src.strip_prefix('&') {\n                             return Some((\n                                 sp,\n                                 \"consider removing the borrow\",\n-                                src,\n+                                src.to_string(),\n                                 Applicability::MachineApplicable,\n                             ));\n                         }"}, {"sha": "578eca7d893d296f5ec8ab7eb8b9256ace62dac8", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -388,7 +388,7 @@ impl str {\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use core::unicode::derived_property::{Case_Ignorable, Cased};\n+            use core::unicode::{Case_Ignorable, Cased};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),\n                 None => false,"}, {"sha": "37ca0a0779b178e7565a6b198ec691300a5a743d", "filename": "library/core/src/unicode/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -18,17 +18,14 @@ mod unicode_data;\n pub const UNICODE_VERSION: (u8, u8, u8) = unicode_data::UNICODE_VERSION;\n \n // For use in liballoc, not re-exported in libstd.\n-pub mod derived_property {\n-    pub use super::{Case_Ignorable, Cased};\n-}\n+pub use unicode_data::{\n+    case_ignorable::lookup as Case_Ignorable, cased::lookup as Cased, conversions,\n+};\n \n-pub use unicode_data::alphabetic::lookup as Alphabetic;\n-pub use unicode_data::case_ignorable::lookup as Case_Ignorable;\n-pub use unicode_data::cased::lookup as Cased;\n-pub use unicode_data::cc::lookup as Cc;\n-pub use unicode_data::conversions;\n-pub use unicode_data::grapheme_extend::lookup as Grapheme_Extend;\n-pub use unicode_data::lowercase::lookup as Lowercase;\n-pub use unicode_data::n::lookup as N;\n-pub use unicode_data::uppercase::lookup as Uppercase;\n-pub use unicode_data::white_space::lookup as White_Space;\n+pub(crate) use unicode_data::alphabetic::lookup as Alphabetic;\n+pub(crate) use unicode_data::cc::lookup as Cc;\n+pub(crate) use unicode_data::grapheme_extend::lookup as Grapheme_Extend;\n+pub(crate) use unicode_data::lowercase::lookup as Lowercase;\n+pub(crate) use unicode_data::n::lookup as N;\n+pub(crate) use unicode_data::uppercase::lookup as Uppercase;\n+pub(crate) use unicode_data::white_space::lookup as White_Space;"}, {"sha": "2d4484c562c40db77f9a715800d9fc31de0f9690", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -198,7 +198,7 @@ simply delete the `pre-commit` file from .git/hooks.\"\n         };\n     };\n \n-    Ok(if should_install {\n+    if should_install {\n         let src = src_path.join(\"src\").join(\"etc\").join(\"pre-commit.sh\");\n         let git = t!(Command::new(\"git\").args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(\n             |output| {\n@@ -217,5 +217,6 @@ simply delete the `pre-commit` file from .git/hooks.\"\n         };\n     } else {\n         println!(\"Ok, skipping installation!\");\n-    })\n+    }\n+    Ok(())\n }"}, {"sha": "6ca5ae40707c57b850b12b4ffa46985bb3a31fa9", "filename": "src/doc/unstable-book/src/compiler-flags/source-based-code-coverage.md", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -213,19 +213,102 @@ Then run the `cov` tool, with the `profdata` file and all test binaries:\n $ cargo cov -- report \\\n     --use-color --ignore-filename-regex='/.cargo/registry' \\\n     --instr-profile=json5format.profdata \\\n-    target/debug/deps/lib-30768f9c53506dc5 \\\n-    target/debug/deps/json5format-fececd4653271682\n+    --object target/debug/deps/lib-30768f9c53506dc5 \\\n+    --object target/debug/deps/json5format-fececd4653271682\n $ cargo cov -- show \\\n     --use-color --ignore-filename-regex='/.cargo/registry' \\\n     --instr-profile=json5format.profdata \\\n-    target/debug/deps/lib-30768f9c53506dc5 \\\n-    target/debug/deps/json5format-fececd4653271682 \\\n+    --object target/debug/deps/lib-30768f9c53506dc5 \\\n+    --object target/debug/deps/json5format-fececd4653271682 \\\n     --show-instantiations --show-line-counts-or-regions \\\n     --Xdemangler=rustfilt | less -R\n ```\n \n _Note the command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results._\n \n+### Tips for listing the binaries automatically\n+\n+For `bash` users, one suggested way to automatically complete the `cov` command with the list of binaries is with a command like:\n+\n+```bash\n+$ cargo cov -- report \\\n+    $( \\\n+      for file in \\\n+        $( \\\n+          RUSTFLAGS=\"-Zinstrument-coverage\" \\\n+            cargo test --tests --no-run --message-format=json \\\n+              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n+              | grep -v dSYM - \\\n+        ); \\\n+      do \\\n+        printf \"%s %s \" -object $file; \\\n+      done \\\n+    ) \\\n+  --instr-profile=json5format.profdata --summary-only # and/or other options\n+```\n+\n+Adding `--no-run --message-format=json` to the _same_ `cargo test` command used to run\n+the tests (including the same environment variables and flags) generates output in a JSON\n+format that `jq` can easily query.\n+\n+The `printf` command takes this list and generates the `--object <binary>` arguments\n+for each listed test binary.\n+\n+### Including doc tests\n+\n+The previous examples run `cargo test` with `--tests`, which excludes doc tests.[^79417]\n+\n+To include doc tests in the coverage results, drop the `--tests` flag, and apply the\n+`-Zinstrument-coverage` flag, and some doc-test-specific options in the\n+`RUSTDOCFLAGS` environment variable. (The `cargo profdata` command does not change.)\n+\n+```bash\n+$ RUSTFLAGS=\"-Zinstrument-coverage\" \\\n+  RUSTDOCFLAGS=\"-Zinstrument-coverage -Zunstable-options --persist-doctests target/debug/doctestbins\" \\\n+  LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n+    cargo test\n+$ cargo profdata -- merge \\\n+    -sparse json5format-*.profraw -o json5format.profdata\n+```\n+\n+The `-Zunstable-options --persist-doctests` flag is required, to save the test binaries\n+(with their coverage maps) for `llvm-cov`.\n+\n+```bash\n+$ cargo cov -- report \\\n+    $( \\\n+      for file in \\\n+        $( \\\n+          RUSTFLAGS=\"-Zinstrument-coverage\" \\\n+          RUSTDOCFLAGS=\"-Zinstrument-coverage -Zunstable-options --persist-doctests target/debug/doctestbins\" \\\n+            cargo test --no-run --message-format=json \\\n+              | jq -r \"select(.profile.test == true) | .filenames[]\" \\\n+              | grep -v dSYM - \\\n+        ) \\\n+        target/debug/doctestbins/*/rust_out; \\\n+      do \\\n+        [[ -x $file ]] && printf \"%s %s \" -object $file; \\\n+      done \\\n+    ) \\\n+  --instr-profile=json5format.profdata --summary-only # and/or other options\n+```\n+\n+Note, the differences in this `cargo cov` command, compared with the version without\n+doc tests, include:\n+\n+* The `cargo test ... --no-run` command is updated with the same environment variables\n+  and flags used to _build_ the tests, _including_ the doc tests. (`LLVM_PROFILE_FILE`\n+  is only used when _running_ the tests.)\n+* The file glob pattern `target/debug/doctestbins/*/rust_out` adds the `rust_out`\n+  binaries generated for doc tests (note, however, that some `rust_out` files may not\n+  be executable binaries).\n+* `[[ -x $file ]] &&` filters the files passed on to the `printf`, to include only\n+  executable binaries.\n+\n+[^79417]: There is ongoing work to resolve a known issue\n+[(#79417)](https://github.com/rust-lang/rust/issues/79417) that doc test coverage\n+generates incorrect source line numbers in `llvm-cov show` results.\n+\n ## Other references\n \n Rust's implementation and workflow for source-based code coverage is based on the same library and tools used to implement [source-based code coverage in Clang]. (This document is partially based on the Clang guide.)"}, {"sha": "bdbb90837c7cd7403332c2d8d7024b640c1b3b98", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -391,7 +391,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n                 _,\n             ))) => {\n                 debug!(\"saw end of shortcut link to {}\", dest);\n-                if self.links.iter().find(|&link| *link.href == **dest).is_some() {\n+                if self.links.iter().any(|link| *link.href == **dest) {\n                     assert!(self.shortcut_link.is_some(), \"saw closing link without opening tag\");\n                     self.shortcut_link = None;\n                 }"}, {"sha": "a0ccb078c4a3ee5ab71976e303055c29234e3f79", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -1469,16 +1469,21 @@ function defocusSearchBar() {\n                 });\n \n                 if (e.which === 38) { // up\n-                    if (!actives[currentTab].length ||\n-                        !actives[currentTab][0].previousElementSibling) {\n-                        return;\n+                    if (e.ctrlKey) { // Going through result tabs.\n+                        printTab(currentTab > 0 ? currentTab - 1 : 2);\n+                    } else {\n+                        if (!actives[currentTab].length ||\n+                            !actives[currentTab][0].previousElementSibling) {\n+                            return;\n+                        }\n+                        addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n+                        removeClass(actives[currentTab][0], \"highlighted\");\n                     }\n-\n-                    addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n-                    removeClass(actives[currentTab][0], \"highlighted\");\n                     e.preventDefault();\n                 } else if (e.which === 40) { // down\n-                    if (!actives[currentTab].length) {\n+                    if (e.ctrlKey) { // Going through result tabs.\n+                        printTab(currentTab > 1 ? 0 : currentTab + 1);\n+                    } else if (!actives[currentTab].length) {\n                         var results = document.getElementById(\"results\").childNodes;\n                         if (results.length > 0) {\n                             var res = results[currentTab].getElementsByClassName(\"result\");\n@@ -1496,13 +1501,6 @@ function defocusSearchBar() {\n                         document.location.href =\n                             actives[currentTab][0].getElementsByTagName(\"a\")[0].href;\n                     }\n-                } else if (e.which === 9) { // tab\n-                    if (e.shiftKey) {\n-                        printTab(currentTab > 0 ? currentTab - 1 : 2);\n-                    } else {\n-                        printTab(currentTab > 1 ? 0 : currentTab + 1);\n-                    }\n-                    e.preventDefault();\n                 } else if (e.which === 16) { // shift\n                     // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n                 } else if (actives[currentTab].length > 0) {\n@@ -2898,11 +2896,14 @@ function defocusSearchBar() {\n             [\"T\", \"Focus the theme picker menu\"],\n             [\"\u2191\", \"Move up in search results\"],\n             [\"\u2193\", \"Move down in search results\"],\n-            [\"\u21b9\", \"Switch tab\"],\n+            [\"ctrl + \u2191 / \u2193\", \"Switch result tab\"],\n             [\"&#9166;\", \"Go to active search result\"],\n             [\"+\", \"Expand all sections\"],\n             [\"-\", \"Collapse all sections\"],\n-        ].map(x => \"<dt><kbd>\" + x[0] + \"</kbd></dt><dd>\" + x[1] + \"</dd>\").join(\"\");\n+        ].map(x => \"<dt>\" +\n+            x[0].split(\" \")\n+                .map((y, index) => (index & 1) === 0 ? \"<kbd>\" + y + \"</kbd>\" : y)\n+                .join(\"\") + \"</dt><dd>\" + x[1] + \"</dd>\").join(\"\");\n         var div_shortcuts = document.createElement(\"div\");\n         addClass(div_shortcuts, \"shortcuts\");\n         div_shortcuts.innerHTML = \"<h2>Keyboard Shortcuts</h2><dl>\" + shortcuts + \"</dl></div>\";"}, {"sha": "8d78ad13896b955f630714f386a95ed91b237e3d", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -1 +1 @@\n-Subproject commit 7ade8dc4b84142abd3e6d1fb8a0f4111b0bbd571\n+Subproject commit 8d78ad13896b955f630714f386a95ed91b237e3d"}, {"sha": "a5d6970009a3b1b7ada4ccaeb4717d1e37489ab5", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -147,13 +147,19 @@ else\n \t# Note `llvm-cov show` output for some programs can vary, but can be ignored\n \t# by inserting `// ignore-llvm-cov-show-diffs` at the top of the source file.\n \t#\n-\t# FIXME(richkadel): It looks like most past variations seem to have been mitigated. None of the\n-\t# Rust test source samples have the `// ignore-llvm-cov-show-diffs` anymore. The main variation\n-\t# I had seen (and is still present in the new `coverage/lib/used_crate.rs`) is the `llvm-cov show`\n-\t# reporting of multiple instantiations of a generic function with different type substitutions.\n-\t# For some reason, `llvm-cov show` can report these in a non-deterministic order, breaking the\n-\t# `diff` comparision. I was able to work around the problem with `diff --ignore-matching-lines=RE`\n+\t# FIXME(richkadel): None of the Rust test source samples have the\n+\t# `// ignore-llvm-cov-show-diffs` anymore. This directive exists to work around a limitation\n+\t# with `llvm-cov show`. When reporting coverage for multiple instantiations of a generic function,\n+\t# with different type substitutions, `llvm-cov show` prints these in a non-deterministic order,\n+\t# breaking the `diff` comparision.\n+\t#\n+\t# A partial workaround is implemented below, with `diff --ignore-matching-lines=RE`\n \t# to ignore each line prefixing each generic instantiation coverage code region.\n+\t#\n+\t# This workaround only works if the coverage counts are identical across all reported\n+\t# instantiations. If there is no way to ensure this, you may need to apply the\n+\t# `// ignore-llvm-cov-show-diffs` directive, and rely on the `.json` and counter\n+\t# files for validating results have not changed.\n \n \t$(DIFF) --ignore-matching-lines='::<.*>.*:$$' \\\n \t\texpected_show_coverage.$@.txt \"$(TMPDIR)\"/actual_show_coverage.$@.txt || \\\n@@ -190,10 +196,6 @@ endif\n \t\t\t$(call BIN,\"$(TMPDIR)\"/$@) \\\n \t\t| \"$(PYTHON)\" $(BASEDIR)/prettify_json.py \\\n \t\t> \"$(TMPDIR)\"/actual_export_coverage.$@.json\n-\t# FIXME(richkadel): With the addition of `--ignore-matching-lines=RE` to ignore the\n-\t# non-deterministically-ordered coverage results for multiple instantiations of generics with\n-\t# differing type substitutions, I probably don't need the `.json` files anymore (and may not\n-\t# need `prettify_json.py` either).\n \n ifdef RUSTC_BLESS_TEST\n \tcp \"$(TMPDIR)\"/actual_export_coverage.$@.json expected_export_coverage.$@.json"}, {"sha": "e14e733fff6d4cbe55f76924985cb802434c4a49", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -19,12 +19,12 @@\n    18|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    19|      2|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}"}, {"sha": "ed91e8898ee98695655294272db60123732f3187", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage_counters.async.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.async.txt?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -35,9 +35,6 @@ Counter in file 0 11:1 -> 11:2, (#2 + (#1 - #2))\n Counter in file 0 21:1 -> 21:23, #1\n Counter in file 0 67:5 -> 67:23, #1\n Counter in file 0 38:1 -> 38:19, #1\n-Counter in file 0 29:1 -> 29:22, #1\n-Counter in file 0 93:1 -> 101:2, #1\n-Counter in file 0 91:1 -> 91:25, #1\n Counter in file 0 38:19 -> 42:12, #1\n Counter in file 0 43:9 -> 43:10, #3\n Counter in file 0 43:14 -> 43:18, (#1 + 0)\n@@ -49,11 +46,14 @@ Counter in file 0 44:27 -> 44:32, #8\n Counter in file 0 44:36 -> 44:38, (#6 + 0)\n Counter in file 0 45:14 -> 45:16, #7\n Counter in file 0 47:1 -> 47:2, (#5 + (#6 + #7))\n+Counter in file 0 29:1 -> 29:22, #1\n+Counter in file 0 93:1 -> 101:2, #1\n+Counter in file 0 91:1 -> 91:25, #1\n Counter in file 0 51:5 -> 52:18, #1\n Counter in file 0 53:13 -> 53:14, #2\n Counter in file 0 63:13 -> 63:14, (#1 - #2)\n Counter in file 0 65:5 -> 65:6, (#2 + (#1 - #2))\n-Counter in file 0 13:20 -> 13:21, #1\n+Counter in file 0 17:20 -> 17:21, #1\n Counter in file 0 49:1 -> 68:12, #1\n Counter in file 0 69:9 -> 69:10, #2\n Counter in file 0 69:14 -> 69:27, (#1 + 0)\n@@ -69,8 +69,8 @@ Counter in file 0 86:14 -> 86:16, #2\n Counter in file 0 87:14 -> 87:16, #3\n Counter in file 0 89:1 -> 89:2, (#3 + (#2 + (#1 - (#3 + #2))))\n Counter in file 0 17:1 -> 17:20, #1\n-Counter in file 0 17:20 -> 17:21, #1\n Counter in file 0 66:5 -> 66:23, #1\n+Counter in file 0 13:20 -> 13:21, #1\n Counter in file 0 17:9 -> 17:10, #1\n Counter in file 0 17:9 -> 17:10, #1\n Counter in file 0 117:17 -> 117:19, #1"}, {"sha": "e2cbf6f709e6ef83654c7ff3b90d742b43f83ccd", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage_counters.generics.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.generics.txt?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -32,12 +32,12 @@ Combined regions:\n   10:5 -> 12:6 (count=1)\n Segment at 10:5 (count = 1), RegionEntry\n Segment at 12:6 (count = 0), Skipped\n-Emitting segments for function: _RNvXs_Cs4fqI2P2rA04_8genericsINtB4_8FireworklENtNtNtCs6HRHKMTmAen_4core3ops4drop4Drop4dropB4_\n+Emitting segments for function: _RNvXs_Cs4fqI2P2rA04_8genericsINtB4_8FireworklENtNtNtCs3rFBWs28XFJ_4core3ops4drop4Drop4dropB4_\n Combined regions:\n   17:5 -> 19:6 (count=1)\n Segment at 17:5 (count = 1), RegionEntry\n Segment at 19:6 (count = 0), Skipped\n-Emitting segments for function: _RNvXs_Cs4fqI2P2rA04_8genericsINtB4_8FireworkdENtNtNtCs6HRHKMTmAen_4core3ops4drop4Drop4dropB4_\n+Emitting segments for function: _RNvXs_Cs4fqI2P2rA04_8genericsINtB4_8FireworkdENtNtNtCs3rFBWs28XFJ_4core3ops4drop4Drop4dropB4_\n Combined regions:\n   17:5 -> 19:6 (count=1)\n Segment at 17:5 (count = 1), RegionEntry"}, {"sha": "b0319cd9e189679630ee4c6c182a9a55ca42ea0e", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage_counters.uses_crate.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage_counters.uses_crate.txt?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -1,5 +1,5 @@\n-Counter in file 0 25:1 -> 27:2, #1\n Counter in file 0 17:1 -> 19:2, #1\n+Counter in file 0 25:1 -> 27:2, #1\n Counter in file 0 17:1 -> 19:2, #1\n Counter in file 0 5:1 -> 12:2, #1\n Counter in file 0 17:1 -> 19:2, 0\n@@ -78,17 +78,17 @@ Segment at 51:1 (count = 0), RegionEntry\n Segment at 51:2 (count = 0), Skipped\n Segment at 53:1 (count = 1), RegionEntry\n Segment at 61:2 (count = 0), Skipped\n-Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate41used_only_from_bin_crate_generic_functionRINtNtCsFAjihUSTht_5alloc3vec3VeclEECs4fqI2P2rA04_10uses_crate\n+Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate41used_only_from_bin_crate_generic_functionReECs4fqI2P2rA04_10uses_crate\n Combined regions:\n   17:1 -> 19:2 (count=1)\n Segment at 17:1 (count = 1), RegionEntry\n Segment at 19:2 (count = 0), Skipped\n-Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate41used_only_from_bin_crate_generic_functionReECs4fqI2P2rA04_10uses_crate\n+Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate41used_only_from_bin_crate_generic_functionRINtNtCs3QflaznQylx_5alloc3vec3VeclEECs4fqI2P2rA04_10uses_crate\n Combined regions:\n   17:1 -> 19:2 (count=1)\n Segment at 17:1 (count = 1), RegionEntry\n Segment at 19:2 (count = 0), Skipped\n-Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate46used_only_from_this_lib_crate_generic_functionINtNtCsFAjihUSTht_5alloc3vec3VeclEEB2_\n+Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate46used_only_from_this_lib_crate_generic_functionINtNtCs3QflaznQylx_5alloc3vec3VeclEEB2_\n Combined regions:\n   21:1 -> 23:2 (count=1)\n Segment at 21:1 (count = 1), RegionEntry\n@@ -98,7 +98,7 @@ Combined regions:\n   21:1 -> 23:2 (count=1)\n Segment at 21:1 (count = 1), RegionEntry\n Segment at 23:2 (count = 0), Skipped\n-Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate50used_from_bin_crate_and_lib_crate_generic_functionINtNtCsFAjihUSTht_5alloc3vec3VeclEECs4fqI2P2rA04_10uses_crate\n+Emitting segments for function: _RINvCsbDqzXfLQacH_10used_crate50used_from_bin_crate_and_lib_crate_generic_functionINtNtCs3QflaznQylx_5alloc3vec3VeclEECs4fqI2P2rA04_10uses_crate\n Combined regions:\n   25:1 -> 27:2 (count=1)\n Segment at 25:1 (count = 1), RegionEntry"}, {"sha": "0a6bac48ebbac81afe275272c01a2e887071114e", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -36,7 +36,7 @@ const TEST_REPOS: &[Test] = &[\n     Test {\n         name: \"xsv\",\n         repo: \"https://github.com/BurntSushi/xsv\",\n-        sha: \"66956b6bfd62d6ac767a6b6499c982eae20a2c9f\",\n+        sha: \"3de6c04269a7d315f7e9864b9013451cd9580a08\",\n         lock: None,\n         packages: &[],\n     },"}, {"sha": "ea54a351e03b5339f52e8e130d7cb415a9da7831", "filename": "src/tools/lint-docs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc410710993d036730c11556039e40109f6ab41/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc410710993d036730c11556039e40109f6ab41/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=1cc410710993d036730c11556039e40109f6ab41", "patch": "@@ -143,8 +143,8 @@ impl<'a> LintExtractor<'a> {\n                     Some((lineno, line)) => {\n                         let line = line.trim();\n                         if let Some(text) = line.strip_prefix(\"/// \") {\n-                            doc_lines.push(text.trim().to_string());\n-                        } else if line.starts_with(\"///\") {\n+                            doc_lines.push(text.to_string());\n+                        } else if line == \"///\" {\n                             doc_lines.push(\"\".to_string());\n                         } else if line.starts_with(\"// \") {\n                             // Ignore comments."}]}