{"sha": "48c2a1ee3a77467f072ee00d451d43b60b13d946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YzJhMWVlM2E3NzQ2N2YwNzJlZTAwZDQ1MWQ0M2I2MGIxM2Q5NDY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T00:52:15Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T00:52:15Z"}, "message": "Replace all uses of `dataflow::state_for_location`\n\nUse the new dataflow cursor.", "tree": {"sha": "e4ed09cad97f6cc0e9e5e9e80cdd0d2458483914", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4ed09cad97f6cc0e9e5e9e80cdd0d2458483914"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48c2a1ee3a77467f072ee00d451d43b60b13d946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48c2a1ee3a77467f072ee00d451d43b60b13d946", "html_url": "https://github.com/rust-lang/rust/commit/48c2a1ee3a77467f072ee00d451d43b60b13d946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48c2a1ee3a77467f072ee00d451d43b60b13d946/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "606a31f46a066ba0d85c1915145703ae7b9d802b", "url": "https://api.github.com/repos/rust-lang/rust/commits/606a31f46a066ba0d85c1915145703ae7b9d802b", "html_url": "https://github.com/rust-lang/rust/commit/606a31f46a066ba0d85c1915145703ae7b9d802b"}], "stats": {"total": 37, "additions": 15, "deletions": 22}, "files": [{"sha": "caf588af851dd3a4fed82162e5e2a090484d3256", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48c2a1ee3a77467f072ee00d451d43b60b13d946/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c2a1ee3a77467f072ee00d451d43b60b13d946/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=48c2a1ee3a77467f072ee00d451d43b60b13d946", "patch": "@@ -67,7 +67,7 @@ use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n-use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n+use crate::dataflow::{do_dataflow, DebugFormatted, DataflowResultsCursor};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals, RequiresStorage};\n use crate::util::dump_mir;\n use crate::util::liveness;\n@@ -436,9 +436,10 @@ fn locals_live_across_suspend_points(\n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let storage_live_analysis = MaybeStorageLive::new(body);\n-    let storage_live =\n+    let storage_live_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, storage_live_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body);\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n@@ -448,17 +449,18 @@ fn locals_live_across_suspend_points(\n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n-    let borrowed_locals_result =\n+    let borrowed_locals_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n-    let requires_storage =\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n+    let requires_storage_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n+    let mut requires_storage_cursor = DataflowResultsCursor::new(&requires_storage_results, body);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -484,10 +486,6 @@ fn locals_live_across_suspend_points(\n             };\n \n             if !movable {\n-                let borrowed_locals = state_for_location(loc,\n-                                                         &borrowed_locals_analysis,\n-                                                         &borrowed_locals_result,\n-                                                         body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n                 // suspension points. However for immovable generators we need to account for\n@@ -498,22 +496,19 @@ fn locals_live_across_suspend_points(\n                 // If a borrow is converted to a raw reference, we must also assume that it lives\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n-                liveness.outs[block].union(&borrowed_locals);\n+                borrowed_locals_cursor.seek(loc);\n+                liveness.outs[block].union(borrowed_locals_cursor.get());\n             }\n \n-            let storage_liveness = state_for_location(loc,\n-                                                      &storage_live_analysis,\n-                                                      &storage_live,\n-                                                      body);\n+            storage_live_cursor.seek(loc);\n+            let storage_liveness = storage_live_cursor.get();\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            let mut storage_required = state_for_location(loc,\n-                                                          &requires_storage_analysis,\n-                                                          &requires_storage,\n-                                                          body);\n+            requires_storage_cursor.seek(loc);\n+            let mut storage_required = requires_storage_cursor.get().clone();\n \n             // Mark locals without storage statements as always requiring storage\n             storage_required.union(&ignored.0);\n@@ -549,8 +544,7 @@ fn locals_live_across_suspend_points(\n         body,\n         &live_locals,\n         &ignored,\n-        requires_storage,\n-        requires_storage_analysis);\n+        requires_storage_results);\n \n     LivenessInfo {\n         live_locals,\n@@ -588,7 +582,6 @@ fn compute_storage_conflicts(\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n     requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n-    _requires_storage_analysis: RequiresStorage<'mir, 'tcx>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());"}]}