{"sha": "bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNmU5ODE1Mzc5ZTMxYWM0MmI0ZDlmZDJiMGUyMGY3MDhjMWNjMWM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-26T20:39:33Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-26T20:39:33Z"}, "message": "Merge branch 'master' of ssh://github.com/graydon/rust", "tree": {"sha": "f9ccd0dac288b2751536a6e552ec8e094e2a6739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9ccd0dac288b2751536a6e552ec8e094e2a6739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "html_url": "https://github.com/rust-lang/rust/commit/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "418b23a5389482c2889c5c01f7f31ba5061c5bc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/418b23a5389482c2889c5c01f7f31ba5061c5bc5", "html_url": "https://github.com/rust-lang/rust/commit/418b23a5389482c2889c5c01f7f31ba5061c5bc5"}, {"sha": "ba3a4f6cc6a9a29c67b325d8a6a5d3b081f97773", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3a4f6cc6a9a29c67b325d8a6a5d3b081f97773", "html_url": "https://github.com/rust-lang/rust/commit/ba3a4f6cc6a9a29c67b325d8a6a5d3b081f97773"}], "stats": {"total": 537, "additions": 401, "deletions": 136}, "files": [{"sha": "2c33bbb28bc893007289a20791669406a5db592d", "filename": "Makefile.in", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -16,13 +16,13 @@ CFG_GCC_LINK_FLAGS :=\n CFG_BOOT_FLAGS := $(BOOT_FLAGS)\n ifdef CFG_DISABLE_OPTIMIZE\n   $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n-  CFG_RUSTC_FLAGS := -nowarn\n+  CFG_RUSTC_FLAGS := --nowarn\n else\n-  CFG_RUSTC_FLAGS := -nowarn -O\n+  CFG_RUSTC_FLAGS := --nowarn -O\n endif\n \n ifdef SAVE_TEMPS\n-  CFG_RUSTC_FLAGS += -save-temps\n+  CFG_RUSTC_FLAGS += --save-temps\n endif\n \n # On Darwin, we need to run dsymutil so the debugging information ends\n@@ -471,7 +471,7 @@ boot/$(CFG_STDLIB): $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n \n stage0/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage0/rustc$(X) $(MKFILES)\n \t@$(call E, compile: $@)\n-\t$(STAGE0) -c -shared -o $@ $<\n+\t$(STAGE0) -c --shared -o $@ $<\n \n stage0/$(CFG_STDLIB): stage0/std.o stage0/glue.o\n \t@$(call E, link: $@)\n@@ -480,7 +480,7 @@ stage0/$(CFG_STDLIB): stage0/std.o stage0/glue.o\n \n stage1/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage1/rustc$(X) $(MKFILES)\n \t@$(call E, compile: $@)\n-\t$(STAGE1) -c -shared -o $@ $<\n+\t$(STAGE1) -c --shared -o $@ $<\n \n stage1/$(CFG_STDLIB): stage1/std.o stage1/glue.o\n \t@$(call E, link: $@)\n@@ -489,7 +489,7 @@ stage1/$(CFG_STDLIB): stage1/std.o stage1/glue.o\n \n stage2/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage2/rustc$(X) $(MKFILES)\n \t@$(call E, compile: $@)\n-\t$(STAGE2) -c -shared -o $@ $<\n+\t$(STAGE2) -c --shared -o $@ $<\n \n stage2/$(CFG_STDLIB): stage2/std.o stage2/glue.o\n \t@$(call E, link: $@)\n@@ -516,17 +516,17 @@ stage2/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ1)\n stage0/glue.o: stage0/rustc$(X) boot/$(CFG_STDLIB) \\\n                 rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n \t@$(call E, generate: $@)\n-\t$(STAGE0) -c -o $@ -glue\n+\t$(STAGE0) -c -o $@ --glue\n \n stage1/glue.o: stage1/rustc$(X) stage0/$(CFG_STDLIB) \\\n                 rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n \t@$(call E, generate: $@)\n-\t$(STAGE1) -c -o $@ -glue\n+\t$(STAGE1) -c -o $@ --glue\n \n stage2/glue.o: stage2/rustc$(X) stage1/$(CFG_STDLIB) \\\n                 rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n \t@$(call E, generate: $@)\n-\t$(STAGE2) -c -o $@ -glue\n+\t$(STAGE2) -c -o $@ --glue\n \n # Due to make not wanting to run the same implicit rules twice on the same\n # rule tree (implicit-rule recursion prevention, see \"Chains of Implicit"}, {"sha": "c321b3a09738abc08dfa71223536804ed569023f", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 78, "deletions": 124, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -20,6 +20,12 @@ import std._str;\n import std._vec;\n import std.io;\n \n+import std.GetOpts;\n+import std.GetOpts.optopt;\n+import std.GetOpts.optmulti;\n+import std.GetOpts.optflag;\n+import std.GetOpts.opt_present;\n+\n fn default_environment(session.session sess,\n                        str argv0,\n                        str input) -> eval.env {\n@@ -105,18 +111,18 @@ fn usage(session.session sess, str argv0) {\n options:\n \n     -o <filename>      write output to <filename>\n-    -nowarn            suppress wrong-compiler warning\n-    -glue              generate glue.bc file\n-    -shared            compile a shared-library crate\n-    -pp                pretty-print the input instead of compiling\n-    -ls                list the symbols defined by a crate file\n+    --nowarn           suppress wrong-compiler warning\n+    --glue             generate glue.bc file\n+    --shared           compile a shared-library crate\n+    --pretty           pretty-print the input instead of compiling\n+    --ls               list the symbols defined by a crate file\n     -L <path>          add a directory to the library search path\n-    -noverify          suppress LLVM verification step (slight speedup)\n-    -parse-only        parse only; do not compile, assemble, or link\n+    --noverify         suppress LLVM verification step (slight speedup)\n+    --parse-only       parse only; do not compile, assemble, or link\n     -O                 optimize\n     -S                 compile only; do not assemble or link\n     -c                 compile and assemble, but do not link\n-    -save-temps        write intermediate files in addition to normal output\n+    --save-temps       write intermediate files in addition to normal output\n     -h                 display this message\\n\\n\");\n }\n \n@@ -142,133 +148,81 @@ fn main(vec[str] args) {\n     auto sess = session.session(target_crate_num, target_cfg, crate_cache,\n                                 md, front.codemap.new_codemap());\n \n-    let option.t[str] input_file = none[str];\n-    let option.t[str] output_file = none[str];\n-    let vec[str] library_search_paths = vec();\n-    let bool do_warn = true;\n-    let bool shared = false;\n-    let bool pretty = false;\n-    let bool ls = false;\n-    auto ot = trans.output_type_bitcode;\n-    let bool glue = false;\n-    let bool verify = true;\n-    let bool save_temps = false;\n+    auto opts = vec(optflag(\"nowarn\"), optflag(\"h\"), optflag(\"glue\"),\n+                    optflag(\"pretty\"), optflag(\"ls\"), optflag(\"parse-only\"),\n+                    optflag(\"O\"), optflag(\"shared\"), optmulti(\"L\"),\n+                    optflag(\"S\"), optflag(\"c\"), optopt(\"o\"),\n+                    optflag(\"save-temps\"), optflag(\"noverify\"));\n+    auto binary = _vec.shift[str](args);\n+    auto match;\n+    alt (GetOpts.getopts(args, opts)) {\n+        case (GetOpts.failure(?f)) { sess.err(GetOpts.fail_str(f)); fail; }\n+        case (GetOpts.success(?m)) { match = m; }\n+    }\n+    if (!opt_present(match, \"nowarn\")) {\n+        warn_wrong_compiler();\n+    }\n+    if (opt_present(match, \"h\")) {\n+        usage(sess, binary);\n+        ret;\n+    }\n \n+    auto pretty = opt_present(match, \"pretty\");\n+    auto ls = opt_present(match, \"ls\");\n+    auto glue = opt_present(match, \"glue\");\n+    auto shared = opt_present(match, \"shared\");\n+    auto output_file = GetOpts.opt_maybe_str(match, \"o\");\n+    auto library_search_paths = GetOpts.opt_strs(match, \"L\");\n+    auto ot = trans.output_type_bitcode;\n+    if (opt_present(match, \"parse-only\")) {\n+        ot = trans.output_type_none;\n+    } else if (opt_present(match, \"S\")) {\n+        ot = trans.output_type_assembly;\n+    } else if (opt_present(match, \"c\")) {\n+        ot = trans.output_type_object;\n+    }\n+    auto verify = !opt_present(match, \"noverify\");\n+    auto save_temps = opt_present(match, \"save-temps\");\n     // FIXME: Maybe we should support -O0, -O1, -Os, etc\n-    let bool optimize = false;\n+    auto optimize = opt_present(match, \"O\");\n+    auto n_inputs = _vec.len[str](match.free);\n \n-    auto i = 1u;\n-    auto len = _vec.len[str](args);\n-\n-    // FIXME: a getopt module would be nice.\n-    while (i < len) {\n-        auto arg = args.(i);\n-        if (_str.byte_len(arg) > 0u && arg.(0) == '-' as u8) {\n-            if (_str.eq(arg, \"-nowarn\")) {\n-                do_warn = false;\n-            } else if (_str.eq(arg, \"-O\")) {\n-                optimize = true;\n-            } else if (_str.eq(arg, \"-glue\")) {\n-                glue = true;\n-            } else if (_str.eq(arg, \"-shared\")) {\n-                shared = true;\n-            } else if (_str.eq(arg, \"-pp\")) {\n-                pretty = true;\n-            } else if (_str.eq(arg, \"-ls\")) {\n-                ls = true;\n-            } else if (_str.eq(arg, \"-parse-only\")) {\n-                ot = trans.output_type_none;\n-            } else if (_str.eq(arg, \"-S\")) {\n-                ot = trans.output_type_assembly;\n-            } else if (_str.eq(arg, \"-c\")) {\n-                ot = trans.output_type_object;\n-            } else if (_str.eq(arg, \"-o\")) {\n-                if (i+1u < len) {\n-                    output_file = some(args.(i+1u));\n-                    i += 1u;\n-                } else {\n-                    usage(sess, args.(0));\n-                    sess.err(\"-o requires an argument\");\n-                }\n-            } else if (_str.eq(arg, \"-save-temps\")) {\n-                save_temps = true;\n-            } else if (_str.eq(arg, \"-L\")) {\n-                if (i+1u < len) {\n-                    library_search_paths += vec(args.(i+1u));\n-                    i += 1u;\n-                } else {\n-                    usage(sess, args.(0));\n-                    sess.err(\"-L requires an argument\");\n-                }\n-            } else if (_str.eq(arg, \"-noverify\")) {\n-                verify = false;\n-            } else if (_str.eq(arg, \"-h\")) {\n-                usage(sess, args.(0));\n-            } else {\n-                usage(sess, args.(0));\n-                sess.err(\"unrecognized option: \" + arg);\n-            }\n-        } else {\n-            alt (input_file) {\n-                case (some[str](_)) {\n-                    usage(sess, args.(0));\n-                    sess.err(\"multiple inputs provided\");\n-                }\n-                case (none[str]) {\n-                    input_file = some[str](arg);\n-                }\n-            }\n+    if (glue) {\n+        if (n_inputs > 0u) {\n+            sess.err(\"No input files allowed with --glue.\");\n         }\n-        i += 1u;\n+        auto out = option.from_maybe[str](\"glue.bc\", output_file);\n+        middle.trans.make_common_glue(out, optimize, verify, save_temps, ot);\n+        ret;\n     }\n \n-    if (do_warn) {\n-        warn_wrong_compiler();\n+    if (n_inputs == 0u) {\n+        sess.err(\"No input filename given.\");\n+    } else if (n_inputs > 1u) {\n+        sess.err(\"Multiple input filenames provided.\");\n     }\n \n-    if (glue) {\n+    auto ifile = match.free.(0);\n+    auto env = default_environment(sess, args.(0), ifile);\n+    if (pretty) {\n+        pretty_print_input(sess, env, ifile);\n+    } else if (ls) {\n+        front.creader.list_file_metadata(ifile, std.io.stdout());\n+    } else {\n         alt (output_file) {\n             case (none[str]) {\n-                middle.trans.make_common_glue(\"glue.bc\", optimize, verify,\n-                                              save_temps, ot);\n-            }\n-            case (some[str](?s)) {\n-                middle.trans.make_common_glue(s, optimize, verify, save_temps,\n-                                              ot);\n+                let vec[str] parts = _str.split(ifile, '.' as u8);\n+                _vec.pop[str](parts);\n+                parts += vec(\".bc\");\n+                auto ofile = _str.concat(parts);\n+                compile_input(sess, env, ifile, ofile, shared,\n+                              optimize, verify, save_temps, ot,\n+                              library_search_paths);\n             }\n-        }\n-        ret;\n-    }\n-\n-    alt (input_file) {\n-        case (none[str]) {\n-            usage(sess, args.(0));\n-            sess.err(\"no input filename\");\n-        }\n-        case (some[str](?ifile)) {\n-\n-            auto env = default_environment(sess, args.(0), ifile);\n-            if (pretty) {\n-                pretty_print_input(sess, env, ifile);\n-            } else if (ls) {\n-                front.creader.list_file_metadata(ifile, std.io.stdout());\n-            } else {\n-                alt (output_file) {\n-                    case (none[str]) {\n-                        let vec[str] parts = _str.split(ifile, '.' as u8);\n-                        _vec.pop[str](parts);\n-                        parts += vec(\".bc\");\n-                        auto ofile = _str.concat(parts);\n-                        compile_input(sess, env, ifile, ofile, shared,\n-                                      optimize, verify, save_temps, ot,\n-                                      library_search_paths);\n-                    }\n-                    case (some[str](?ofile)) {\n-                        compile_input(sess, env, ifile, ofile, shared,\n-                                      optimize, verify, save_temps, ot,\n-                                      library_search_paths);\n-                    }\n-                }\n+            case (some[str](?ofile)) {\n+                compile_input(sess, env, ifile, ofile, shared,\n+                              optimize, verify, save_temps, ot,\n+                              library_search_paths);\n             }\n         }\n     }"}, {"sha": "24078767f197a61da5d81e5b94f6d7802eddd8e9", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -630,7 +630,9 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n fn ty_to_abbrev_str(ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n     auto ecx = @rec(ds=f, tcx=cx);\n-    ret metadata.Encode.ty_str(ecx, typ);\n+    auto s = metadata.Encode.ty_str(ecx, typ);\n+    if (_str.byte_len(s) >= 64u) { s = _str.substr(s, 0u, 64u); }\n+    ret s;\n }\n \n // Type folds"}, {"sha": "f85ce85c136fd2222fae2a1ec1dd35a667762237", "filename": "src/lib/GetOpts.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2FGetOpts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2FGetOpts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FGetOpts.rs?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -0,0 +1,249 @@\n+/* Simple getopt alternative. Construct a vector of options, either by using\n+ * reqopt, optopt, and optflag or by building them from components yourself,\n+ * and pass them to getopts, along with a vector of actual arguments (not\n+ * including argv[0]). You'll either get a failure code back, or a match.\n+ * You'll have to verify whether the amount of 'free' arguments in the match\n+ * is what you expect. Use opt_* accessors (bottom of the file) to get\n+ * argument values out of the match object.\n+ */ \n+\n+import option.some;\n+import option.none;\n+\n+tag name { long(str); short(char); }\n+tag hasarg { yes; no; maybe; }\n+tag occur { req; optional; multi; }\n+\n+type opt = rec(name name, hasarg hasarg, occur occur);\n+\n+fn mkname(str nm) -> name {\n+    if (_str.char_len(nm) == 1u) { ret short(_str.char_at(nm, 0u)); }\n+    else { ret long(nm); }\n+}\n+fn reqopt(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=req);\n+}\n+fn optopt(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=optional);\n+}\n+fn optflag(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=no, occur=optional);\n+}\n+fn optmulti(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=multi);\n+}\n+\n+tag optval {\n+    val(str);\n+    given;\n+}\n+\n+type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n+\n+fn is_arg(str arg) -> bool {\n+    ret _str.byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+}\n+fn name_str(name nm) -> str {\n+    alt (nm) {\n+        case (short(?ch)) {ret _str.from_char(ch);}\n+        case (long(?s)) {ret s;}\n+    }\n+}\n+\n+// FIXME rustboot workaround\n+fn name_eq(name a, name b) -> bool {\n+    alt (a) {\n+        case (long(?a)) {\n+            alt (b) {\n+                case (long(?b)) { ret _str.eq(a, b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (_) { if (a == b) { ret true; } else {ret false; } }\n+    }\n+}\n+fn find_opt(vec[opt] opts, name nm) -> option.t[uint] {\n+    auto i = 0u;\n+    auto l = _vec.len[opt](opts);\n+    while (i < l) {\n+        if (name_eq(opts.(i).name, nm)) { ret some[uint](i); }\n+        i += 1u;\n+    }\n+    ret none[uint];\n+}\n+\n+tag fail_ {\n+    argument_missing(str);\n+    unrecognized_option(str);\n+    option_missing(str);\n+    option_duplicated(str);\n+}\n+\n+fn fail_str(fail_ f) -> str {\n+    alt (f) {\n+        case (argument_missing(?nm)) {\n+            ret \"Argument to option '\" + nm + \"' missing.\";\n+        }\n+        case (unrecognized_option(?nm)) {\n+            ret \"Unrecognized option: '\" + nm + \"'.\";\n+        }\n+        case (option_missing(?nm)) {\n+            ret \"Required option '\" + nm + \"' missing.\";\n+        }\n+        case (option_duplicated(?nm)) {\n+            ret \"Option '\" + nm + \"' given more than once.\";\n+        }\n+    }\n+}\n+\n+tag result {\n+    success(match);\n+    failure(fail_);\n+}\n+\n+fn getopts(vec[str] args, vec[opt] opts) -> result {\n+    auto n_opts = _vec.len[opt](opts);\n+    fn empty_(uint x) -> vec[optval]{ret _vec.empty[optval]();}\n+    auto f = empty_;\n+    auto vals = _vec.init_fn_mut[vec[optval]](f, n_opts);\n+    let vec[str] free = vec();\n+\n+    auto l = _vec.len[str](args);\n+    auto i = 0u;\n+    while (i < l) {\n+        auto cur = args.(i);\n+        auto curlen = _str.byte_len(cur);\n+        if (!is_arg(cur)) {\n+            _vec.push[str](free, cur);\n+        } else if (_str.eq(cur, \"--\")) {\n+            free += _vec.slice[str](args, i + 1u, l);\n+            break;\n+        } else {\n+            auto names;\n+            auto i_arg = option.none[str];\n+            if (cur.(1) == '-' as u8) {\n+                auto tail = _str.slice(cur, 2u, curlen);\n+                auto eq = _str.index(tail, '=' as u8);\n+                if (eq == -1) {\n+                    names = vec(long(tail));\n+                } else {\n+                    names = vec(long(_str.slice(tail, 0u, eq as uint)));\n+                    i_arg = option.some[str]\n+                        (_str.slice(tail, (eq as uint) + 1u, curlen - 2u));\n+                }\n+            } else {\n+                auto j = 1u;\n+                names = vec();\n+                while (j < curlen) {\n+                    auto range = _str.char_range_at(cur, j);\n+                    _vec.push[name](names, short(range._0));\n+                    j = range._1;\n+                }\n+            }\n+            auto name_pos = 0u;\n+            for (name nm in names) {\n+                name_pos += 1u;\n+                auto optid;\n+                alt (find_opt(opts, nm)) {\n+                    case (some[uint](?id)) {optid = id;}\n+                    case (none[uint]) {\n+                        ret failure(unrecognized_option(name_str(nm)));\n+                    }\n+                }\n+                alt (opts.(optid).hasarg) {\n+                    case (no) {\n+                        _vec.push[optval](vals.(optid), given);\n+                    }\n+                    case (maybe) {\n+                        if (!option.is_none[str](i_arg)) {\n+                            _vec.push[optval](vals.(optid),\n+                                              val(option.get[str](i_arg)));\n+                        } else if (name_pos < _vec.len[name](names) ||\n+                                   i + 1u == l || is_arg(args.(i + 1u))) {\n+                            _vec.push[optval](vals.(optid), given);\n+                        } else {\n+                            i += 1u;\n+                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                        }\n+                    }\n+                    case (yes) {\n+                        if (!option.is_none[str](i_arg)) {\n+                            _vec.push[optval](vals.(optid),\n+                                              val(option.get[str](i_arg)));\n+                        } else if (i + 1u == l) {\n+                            ret failure(argument_missing(name_str(nm)));\n+                        } else {\n+                            i += 1u;\n+                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        i += 1u;\n+    }\n+\n+    i = 0u;\n+    while (i < n_opts) {\n+        auto n = _vec.len[optval](vals.(i));\n+        auto occ = opts.(i).occur;\n+        if (occ == req) {if (n == 0u) {\n+            ret failure(option_missing(name_str(opts.(i).name)));\n+        }}\n+        if (occ != multi) {if (n > 1u) {\n+            ret failure(option_duplicated(name_str(opts.(i).name)));\n+        }}\n+        i += 1u;\n+    }\n+\n+    ret success(rec(opts=opts, vals=vals, free=free));\n+}\n+\n+fn opt_vals(match m, str nm) -> vec[optval] {\n+    alt (find_opt(m.opts, mkname(nm))) {\n+        case (some[uint](?id)) { ret m.vals.(id); }\n+        case (none[uint]) {\n+            log_err \"No option '\" + nm + \"' defined.\";\n+            fail;\n+        }\n+    }\n+}\n+fn opt_val(match m, str nm) -> optval {\n+    ret opt_vals(m, nm).(0);\n+}\n+fn opt_present(match m, str nm) -> bool {\n+    ret _vec.len[optval](opt_vals(m, nm)) > 0u;\n+}\n+fn opt_str(match m, str nm) -> str {\n+    alt (opt_val(m, nm)) {\n+        case (val(?s)) { ret s; }\n+        case (_) { fail; }\n+    }\n+}\n+fn opt_strs(match m, str nm) -> vec[str] {\n+    let vec[str] acc = vec();\n+    for (optval v in opt_vals(m, nm)) {\n+        alt (v) {\n+            case (val(?s)) { _vec.push[str](acc, s); }\n+            case (_) {}\n+        }\n+    }\n+    ret acc;\n+}\n+fn opt_maybe_str(match m, str nm) -> option.t[str] {\n+    auto vals = opt_vals(m, nm);\n+    if (_vec.len[optval](vals) == 0u) { ret none[str]; }\n+    alt (vals.(0)) {\n+        case (val(?s)) { ret some[str](s); }\n+        case (_) { ret none[str]; }\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "9bf90b1cdb0346186d4500db355c91a6c11b1e8c", "filename": "src/lib/Term.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2FTerm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2FTerm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FTerm.rs?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -0,0 +1,54 @@\n+// Simple ANSI color library.\n+//\n+// TODO: Windows support.\n+\n+const u8 color_black = 0u8;\n+const u8 color_red = 1u8;\n+const u8 color_green = 2u8;\n+const u8 color_yellow = 3u8;\n+const u8 color_blue = 4u8;\n+const u8 color_magenta = 5u8;\n+const u8 color_cyan = 6u8;\n+const u8 color_light_gray = 7u8;\n+const u8 color_light_grey = 7u8;\n+const u8 color_dark_gray = 8u8;\n+const u8 color_dark_grey = 8u8;\n+const u8 color_bright_red = 9u8;\n+const u8 color_bright_green = 10u8;\n+const u8 color_bright_yellow = 11u8;\n+const u8 color_bright_blue = 12u8;\n+const u8 color_bright_magenta = 13u8;\n+const u8 color_bright_cyan = 14u8;\n+const u8 color_bright_white = 15u8;\n+\n+fn esc(io.buf_writer writer) {\n+    writer.write(vec(0x1bu8, '[' as u8));\n+}\n+\n+fn reset(io.buf_writer writer) {\n+    esc(writer);\n+    writer.write(vec('0' as u8, 'm' as u8));\n+}\n+\n+fn set_color(io.buf_writer writer, u8 first_char, u8 color) {\n+    check (color < 16u8);\n+\n+    esc(writer);\n+    if (color >= 8u8) {\n+        writer.write(vec('1' as u8, ';' as u8));\n+        color -= 8u8;\n+    }\n+    writer.write(vec(first_char, ('0' as u8) + color, 'm' as u8));\n+}\n+\n+fn fg(io.buf_writer writer, u8 color) {\n+    ret set_color(writer, '3' as u8, color);\n+}\n+\n+fn bg(io.buf_writer writer, u8 color) {\n+    ret set_color(writer, '4' as u8, color);\n+}\n+\n+// export fg;\n+// export bg;\n+"}, {"sha": "41a86cf3cbbe922441b750bef061b8b36a9cb6b4", "filename": "src/lib/_str.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -391,10 +391,14 @@ fn ends_with(str haystack, str needle) -> bool {\n }\n \n fn substr(str s, uint begin, uint len) -> str {\n+    ret slice(s, begin, begin + len);\n+}\n+\n+fn slice(str s, uint begin, uint end) -> str {\n     let str accum = \"\";\n     let uint i = begin;\n-    while (i < begin+len) {\n-        accum += unsafe_from_byte(s.(i));\n+    while (i < end) {\n+        push_byte(accum, s.(i));\n         i += 1u;\n     }\n     ret accum;"}, {"sha": "8a9ee42d0da8da4f800edbc170082180eec4c6fe", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=bc6e9815379e31ac42b4d9fd2b0e20f708c1cc1c", "patch": "@@ -70,6 +70,8 @@ mod ebml;\n mod UFind;\n mod ExtFmt;\n mod Box;\n+mod GetOpts;\n+mod Term;\n \n // Local Variables:\n // mode: rust;"}]}