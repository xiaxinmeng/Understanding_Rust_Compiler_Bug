{"sha": "f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZDBlMTgyNjQ3OGQ2ZGE2MDlhNzhlMmE0ZjA1ZmE1YjhiMmVlY2M=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T00:42:28Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T00:42:28Z"}, "message": "report: Fill in most of the language support section, plus data layout and determinism.", "tree": {"sha": "b8bf3a7aadef5b6fd78f7e5b6213b7257fd87464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8bf3a7aadef5b6fd78f7e5b6213b7257fd87464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "html_url": "https://github.com/rust-lang/rust/commit/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb6a1e98bdf1c2197671c2647b2fb345c402d100", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6a1e98bdf1c2197671c2647b2fb345c402d100", "html_url": "https://github.com/rust-lang/rust/commit/cb6a1e98bdf1c2197671c2647b2fb345c402d100"}], "stats": {"total": 218, "additions": 201, "deletions": 17}, "files": [{"sha": "9655dcdaddb07f709d1746d6429817da6c24efb8", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 201, "deletions": 17, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "patch": "@@ -20,10 +20,9 @@\n \\begin{document}\n \n \\title{Miri: \\\\ \\smaller{An interpreter for Rust's mid-level intermediate representation}}\n-% \\subtitle{test}\n \\author{Scott Olson\\footnote{\\href{mailto:scott@solson.me}{scott@solson.me}} \\\\\n   \\smaller{Supervised by Christopher Dutchyn}}\n-\\date{April 8th, 2016}\n+\\date{April 12th, 2016}\n \\maketitle\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n@@ -155,14 +154,15 @@ \\subsection{Flaws}\n \n \\section{Current implementation}\n \n-Roughly halfway through my time working on Miri, Rust compiler team member Eduard\n-Burtescu\\footnote{\\href{https://www.rust-lang.org/team.html\\#Compiler}{The Rust compiler team}} made\n-a post on Rust's internal\n-forums\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n-``Rust Abstract Machine'' forum post}} about a ``Rust Abstract Machine'' specification which could\n-be used to implement more powerful compile-time function execution, similar to what is supported by\n-C++14's \\mintinline{cpp}{constexpr} feature. After clarifying some of the details of the abstract\n-machine's data layout with Burtescu via IRC, I started implementing it in Miri.\n+Roughly halfway through my time working on Miri, Eduard\n+Burtescu\\footnote{\\href{https://github.com/eddyb}{Eduard Burtescu on GitHub}} from the Rust compiler\n+team\\footnote{\\href{https://www.rust-lang.org/team.html\\#Compiler}{The Rust compiler team}} made a\n+post on Rust's internal forums about a ``Rust Abstract Machine''\n+specification\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n+``Rust Abstract Machine'' forum post}} which could be used to implement more powerful compile-time\n+function execution, similar to what is supported by C++14's \\mintinline{cpp}{constexpr} feature.\n+After clarifying some of the details of the abstract machine's data layout with Burtescu via IRC, I\n+started implementing it in Miri.\n \n \\subsection{Raw value representation}\n \n@@ -224,7 +224,7 @@ \\subsubsection{Undefined byte mask}\n \n See \\autoref{fig:undef} for an example undefined byte, represented by underscores. Note that there\n would still be a value for the second byte in the byte array, but we don't care what it is. The\n-bitmask would be $10_2$, i.e. \\rust{[true, false]}.\n+bitmask would be $10_2$, i.e.\\ \\rust{[true, false]}.\n \n \\begin{figure}[hb]\n   \\begin{minted}[autogobble]{rust}\n@@ -237,12 +237,179 @@ \\subsubsection{Undefined byte mask}\n   \\label{fig:undef}\n \\end{figure}\n \n-% TODO(tsion): Find a place for this text.\n-% Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n-% of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n-% unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n-% simulating execution of unsafe code, which allows it to detect when unsafe code does something\n-% invalid.\n+\\subsection{Computing data layout}\n+\n+Currently, the Rust compiler's data layout computations used in translation from MIR to LLVM IR are\n+hidden from Miri, so I do my own basic data layout computation which doesn't generally match what\n+translation does. In the future, the Rust compiler may be modified so that Miri can use the exact\n+same data layout.\n+\n+Miri's data layout calculation is a relatively simple transformation from Rust types to a basic\n+structure with constant size values for primitives and sets of fields with offsets for aggregate\n+types. These layouts are cached for performance.\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\section{Deterministic execution}\n+\\label{sec:deterministic}\n+\n+In order to be effective as a compile-time evaluator, Miri must have \\emph{deterministic execution},\n+as explained by Burtescu in the ``Rust Abstract Machine'' post. That is, given a function and\n+arguments to that function, Miri should always produce identical results. This is important for\n+coherence in the type checker when constant evaluations are involved in types, such as for sizes of\n+array types:\n+\n+\\begin{minted}[autogobble,mathescape]{rust}\n+  const fn get_size() -> usize { /* $\\ldots$ */ }\n+  let array: [i32; get_size()];\n+\\end{minted}\n+\n+Since Miri allows execution of unsafe code\\footnote{In fact, the distinction between safe and unsafe\n+doesn't exist at the MIR level.}, it is specifically designed to remain safe while interpreting\n+potentially unsafe code. When Miri encounters an unrecoverable error, it reports it via the Rust\n+compiler's usual error reporting mechanism, pointing to the part of the original code where the\n+error occurred. For example:\n+\n+\\begin{minted}[autogobble]{rust}\n+  let b = Box::new(42);\n+  let p: *const i32 = &*b;\n+  drop(b);\n+  unsafe { *p }\n+  //       ~~ error: dangling pointer\n+  //            was dereferenced\n+\\end{minted}\n+\\label{dangling-pointer}\n+\n+There are more examples in Miri's\n+repository.\\footnote{\\href{https://github.com/tsion/miri/blob/master/test/errors.rs}{Miri's error\n+tests}}\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\section{Language support}\n+\n+In its current state, Miri supports a large proportion of the Rust language, with a few major\n+exceptions such as the lack of support for FFI\\footnote{Foreign Function Interface, e.g.\\ calling\n+functions defined in Assembly, C, or C++.}, which eliminates possibilities like reading and writing\n+files, user input, graphics, and more. The following is a tour of what is currently supported.\n+\n+\\subsection{Primitives}\n+\n+Miri supports booleans and integers of various sizes and signed-ness (i.e.\\ \\rust{i8}, \\rust{i16},\n+\\rust{i32}, \\rust{i64}, \\rust{isize}, \\rust{u8}, \\rust{u16}, \\rust{u32}, \\rust{u64}, \\rust{usize}),\n+as well as unary and boolean operations over these types. The \\rust{isize} and \\rust{usize} types\n+will be sized according to the target machine's pointer size just like in compiled Rust. The\n+\\rust{char} and float types (\\rust{f32}, \\rust{f64}) are not supported yet, but there are no known\n+barriers to doing so.\n+\n+When examining a boolean in an \\rust{if} condition, Miri will report an error if it is not precisely\n+0 or 1, since this is undefined behaviour in Rust. The \\rust{char} type has similar restrictions to\n+check for once it is implemented.\n+\n+\\subsection{Pointers}\n+\n+Both references and raw pointers are supported, with essentially no difference between them in Miri.\n+It is also possible to do basic pointer comparisons and math. However, a few operations are\n+considered errors and a few require special support.\n+\n+Firstly, pointers into the same allocations may be compared for ordering, but pointers into\n+different allocations are considered unordered and Miri will complain if you attempt this. The\n+reasoning is that different allocations may have different orderings in the global address space at\n+runtime, making this non-deterministic. However, pointers into different allocations \\emph{may} be\n+compared for direct equality (they are always, automatically unequal).\n+\n+Finally, for things like null pointer checks, abstract pointers (the kind represented using\n+relocations) may be compared against pointers casted from integers (e.g.\\ \\rust{0 as *const i32}).\n+To handle these cases, Miri has a concept of ``integer pointers'' which are always unequal to\n+abstract pointers. Integer pointers can be compared and operated upon freely. However, note that it\n+is impossible to go from an integer pointer to an abstract pointer backed by a relocation. It is not\n+valid to dereference an integer pointer.\n+\n+\\subsubsection{Slice pointers}\n+\n+Rust supports pointers to ``dynamically-sized types'' such as \\rust{[T]} and \\rust{str} which\n+represent arrays of indeterminate size. Pointers to such types contain an address \\emph{and} the\n+length of the referenced array. Miri supports these fully.\n+\n+\\subsubsection{Trait objects}\n+\n+Rust also supports pointers to ``trait objects'' which represent some type that implements a trait,\n+with the specific type unknown at compile-time. These are implemented using virtual dispatch with a\n+vtable, similar to virtual methods in C++. Miri does not currently support this at all.\n+\n+\\subsection{Aggregates}\n+\n+Aggregates include types declared as \\rust{struct} or \\rust{enum} as well as tuples, arrays, and\n+closures\\footnote{Closures are essentially structs with a field for each variable captured by the\n+closure.}. Miri supports all common usage of all of these types. The main missing piece is to handle\n+\\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n+\n+\\subsection{Control flow}\n+\n+All of Rust's standard control flow features, including \\rust{loop}, \\rust{while}, \\rust{for},\n+\\rust{if}, \\rust{if let}, \\rust{while let}, \\rust{match}, \\rust{break}, \\rust{continue}, and\n+\\rust{return} are supported. In fact, supporting these were quite easy since the Rust compiler\n+reduces them all down to a comparatively smaller set of control-flow graph primitives in MIR.\n+\n+\\subsection{Closures}\n+\n+Closures are like structs containing a field for each captured variable, but closures also have an\n+associated function. Supporting closure function calls required some extra machinery to get the\n+necessary information from the compiler, but it is all supported except for one edge case on my todo\n+list\\footnote{The edge case is calling a closure that takes a reference to its captures via a\n+closure interface that passes the captures by value.}.\n+\n+\\subsection{Intrinsics}\n+\n+To support unsafe code, and in particular the unsafe code used to implement Rust's standard library,\n+it became clear that Miri would have to support calls to compiler\n+intrinsics\\footnote{\\href{https://doc.rust-lang.org/stable/std/intrinsics/index.html}{Rust\n+intrinsics documentation}}. Intrinsics are function calls which cause the Rust compiler to produce\n+special-purpose code instead of a regular function call. Miri simply recognizes intrinsic calls by\n+their unique ABI\\footnote{Application Binary Interface, which defines calling conventions. Includes\n+``C'', ``Rust'', and ``rust-intrinsic''.} and name and runs special purpose code to handle them.\n+\n+An example of an important intrinsic is \\rust{size_of} which will cause Miri to write the size of\n+the type in question to the return value location. The Rust standard library uses intrinsics heavily\n+to implement various data structures, so this was a major step toward supporting them. So far, I've\n+been implementing intrinsics on a case-by-case basis as I write test cases which require missing\n+ones, so I haven't yet exhaustively implemented them all.\n+\n+\\subsection{Heap allocations}\n+\n+The next piece of the puzzle for supporting interesting programs (and the standard library) was heap\n+allocations. There are two main interfaces for heap allocation in Rust, the built-in \\rust{Box}\n+rvalue in MIR and a set of C ABI foreign functions including \\rust{__rust_allocate},\n+\\rust{__rust_reallocate}, and \\rust{__rust_deallocate}. These correspond approximately to\n+\\mintinline{c}{malloc}, \\mintinline{c}{realloc}, and \\mintinline{c}{free} in C.\n+\n+The \\rust{Box} rvalue allocates enough space for a single value of a given type. This was easy to\n+support in Miri. It simply creates a new abstract allocation in the same manner as for\n+stack-allocated values, since there's no major difference between them in Miri.\n+\n+The allocator functions, which are used to implement things like Rust's standard \\rust{Vec<T>} type,\n+were a bit trickier. Rust declares them as \\rust{extern \"C\" fn} so that different allocator\n+libraries can be linked in at the user's option. Since Miri doesn't actually support FFI and we want\n+full control of allocations for safety, Miri ``cheats'' and recognizes these allocator function in\n+essentially the same way it recognizes compiler intrinsics. Then, a call to \\rust{__rust_allocate}\n+simply creates another abstract allocation with the requested size and \\rust{__rust_reallocate}\n+grows one.\n+\n+In the future, Miri should also track which allocations came from \\rust{__rust_allocate} so it can\n+reject reallocate or deallocate calls on stack allocations.\n+\n+\\subsection{Destructors}\n+\n+Miri doesn't yet support calling user-defined destructors, but it has most of the machinery in place\n+to do so already and it's next on my to-do list. There \\emph{is} support for dropping \\rust{Box<T>}\n+types, including deallocating their associated allocations. This is enough to properly execute the\n+dangling pointer example in \\autoref{sec:deterministic}.\n+\n+\\subsection{Standard library}\n+\\blindtext\n+\n+\\section{Unsupported}\n+\\blindtext\n \n \\begin{figure}[t]\n   \\begin{minted}[autogobble]{rust}\n@@ -280,6 +447,12 @@ \\subsubsection{Undefined byte mask}\n \n \\section{Future work}\n \n+\\subsection{Finishing the implementation}\n+\n+\\blindtext\n+\n+\\subsection{Alternative applications}\n+\n Other possible uses for Miri include:\n \n \\begin{itemize}\n@@ -299,6 +472,17 @@ \\section{Future work}\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n+\\section{Final thoughts}\n+\n+% TODO(tsion): Reword this.\n+Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n+of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n+unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n+simulating execution of unsafe code, which allows it to detect when unsafe code does something\n+invalid.\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n \\section{Thanks}\n \n Eduard Burtescu, Niko Matsakis, and Christopher Dutchyn."}]}