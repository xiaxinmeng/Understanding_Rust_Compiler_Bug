{"sha": "a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyM2RkMGQxZTZkZGZlNjYyNGYxYzU5ZTlhZWZjYjU5ZTQxOTYxMGQ=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-05-13T01:43:23Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-05-13T01:49:22Z"}, "message": "Replace fcntl-based file lock with flock\n\nWSL1 does not support `fcntl`-based lock and will always report success,\ntherefore creating a race condition when multiple rustc processes are\nmodifying shared data such as `search-index.js`. WSL1 does however\nsupport `flock`.\n\n`flock` is supported by all unix-like platforms. The only caveat is that\nLinux 2.6.11 or earlier does not support `flock` on NFS mounts, but as\nthe minimum supported Linux version is 2.6.18, it is not an issue.\n\nFixes #72157", "tree": {"sha": "ded9b674c04e55dcc7a856241b096c666ac33566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ded9b674c04e55dcc7a856241b096c666ac33566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d", "html_url": "https://github.com/rust-lang/rust/commit/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "769d12eec1d0bc3708841dfc149d3ec98b04bec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/769d12eec1d0bc3708841dfc149d3ec98b04bec6", "html_url": "https://github.com/rust-lang/rust/commit/769d12eec1d0bc3708841dfc149d3ec98b04bec6"}], "stats": {"total": 67, "additions": 19, "deletions": 48}, "files": [{"sha": "d6fc552e661490084a6a3b5400ad56542f5bd2e7", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 19, "deletions": 48, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=a23dd0d1e6ddfe6624f1c59e9aefcb59e419610d", "patch": "@@ -12,13 +12,12 @@ use std::path::Path;\n \n cfg_if! {\n     if #[cfg(unix)] {\n-        use std::ffi::{CString, OsStr};\n-        use std::mem;\n         use std::os::unix::prelude::*;\n+        use std::fs::{File, OpenOptions};\n \n         #[derive(Debug)]\n         pub struct Lock {\n-            fd: libc::c_int,\n+            _file: File,\n         }\n \n         impl Lock {\n@@ -27,63 +26,35 @@ cfg_if! {\n                        create: bool,\n                        exclusive: bool)\n                        -> io::Result<Lock> {\n-                let os: &OsStr = p.as_ref();\n-                let buf = CString::new(os.as_bytes()).unwrap();\n-                let open_flags = if create {\n-                    libc::O_RDWR | libc::O_CREAT\n+                let file = OpenOptions::new()\n+                           .read(true)\n+                           .write(true)\n+                           .create(create)\n+                           .mode(libc::S_IRWXU as u32)\n+                           .open(p)?;\n+\n+                let mut operation = if exclusive {\n+                    libc::LOCK_EX\n                 } else {\n-                    libc::O_RDWR\n-                };\n-\n-                let fd = unsafe {\n-                    libc::open(buf.as_ptr(), open_flags,\n-                               libc::S_IRWXU as libc::c_int)\n+                    libc::LOCK_SH\n                 };\n-\n-                if fd < 0 {\n-                    return Err(io::Error::last_os_error());\n+                if !wait {\n+                    operation |= libc::LOCK_NB\n                 }\n \n-                let lock_type = if exclusive {\n-                    libc::F_WRLCK\n-                } else {\n-                    libc::F_RDLCK\n-                };\n-\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = lock_type as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n-                let ret = unsafe {\n-                    libc::fcntl(fd, cmd, &flock)\n-                };\n+                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n                 if ret == -1 {\n                     let err = io::Error::last_os_error();\n-                    unsafe { libc::close(fd); }\n                     Err(err)\n                 } else {\n-                    Ok(Lock { fd })\n+                    Ok(Lock { _file: file })\n                 }\n             }\n         }\n \n-        impl Drop for Lock {\n-            fn drop(&mut self) {\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = libc::F_UNLCK as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                unsafe {\n-                    libc::fcntl(self.fd, libc::F_SETLK, &flock);\n-                    libc::close(self.fd);\n-                }\n-            }\n-        }\n+        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n+        // `flock` is associated with the file descriptor and closing the file release it\n+        // automatically.\n     } else if #[cfg(windows)] {\n         use std::mem;\n         use std::os::windows::prelude::*;"}]}