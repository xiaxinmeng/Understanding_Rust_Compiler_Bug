{"sha": "8492ad2479379d2e07ccf2d3439ec29b19d164b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OTJhZDI0NzkzNzlkMmUwN2NjZjJkMzQzOWVjMjliMTlkMTY0Yjg=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2017-08-22T23:05:01Z"}, "committer": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2017-08-23T03:37:14Z"}, "message": "\"soft\" (warn instead of error) feature-gate for #[must_use] on functions\n\nBefore `#[must_use]` for functions was implemented, a `#[must_use]` attribute\non a function was a no-op. To avoid a breaking change in this behavior, we add\nan option for \"this-and-such feature is experimental\" feature-gate messages to\nbe a mere warning rather than a compilation-halting failure (so old code that\nused to have a useless no-op `#[must_use]` attribute now warns rather than\nbreaking). When we're on stable, we add a help note to clarify that the feature\nisn't \"on.\"\n\nThis is in support of #43302.", "tree": {"sha": "0b689201efb14d9a1dea597ae54ec413ff550aa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b689201efb14d9a1dea597ae54ec413ff550aa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8492ad2479379d2e07ccf2d3439ec29b19d164b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8492ad2479379d2e07ccf2d3439ec29b19d164b8", "html_url": "https://github.com/rust-lang/rust/commit/8492ad2479379d2e07ccf2d3439ec29b19d164b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8492ad2479379d2e07ccf2d3439ec29b19d164b8/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b6e9b4b8424e8ef722a3fa6388fe3bc8414bab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b6e9b4b8424e8ef722a3fa6388fe3bc8414bab0", "html_url": "https://github.com/rust-lang/rust/commit/7b6e9b4b8424e8ef722a3fa6388fe3bc8414bab0"}], "stats": {"total": 76, "additions": 63, "deletions": 13}, "files": [{"sha": "79f15f2fe1958ad1c08c63ad453280cd3a239648", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8492ad2479379d2e07ccf2d3439ec29b19d164b8", "patch": "@@ -918,20 +918,27 @@ struct Context<'a> {\n }\n \n macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n-        let (cx, has_feature, span, name, explain) = ($cx, $has_feature, $span, $name, $explain);\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n+        let (cx, has_feature, span,\n+             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable() {\n-            emit_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain);\n+            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n+                .emit();\n         }\n     }}\n }\n \n macro_rules! gate_feature {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!($cx, |x:&Features| x.$feature, $span, stringify!($feature), $explain)\n-    }\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         stringify!($feature), $explain, GateStrength::Hard)\n+    };\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         stringify!($feature), $explain, $level)\n+    };\n }\n \n impl<'a> Context<'a> {\n@@ -941,7 +948,7 @@ impl<'a> Context<'a> {\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if name == n {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n-                    gate_feature_fn!(self, has_feature, attr.span, name, desc);\n+                    gate_feature_fn!(self, has_feature, attr.span, name, desc, GateStrength::Hard);\n                 }\n                 debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n                 return;\n@@ -1011,24 +1018,42 @@ pub enum GateIssue {\n     Library(Option<u32>)\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum GateStrength {\n+    /// A hard error. (Most feature gates should use this.)\n+    Hard,\n+    /// Only a warning. (Use this only as backwards-compatibility demands.)\n+    Soft,\n+}\n+\n pub fn emit_feature_err(sess: &ParseSess, feature: &str, span: Span, issue: GateIssue,\n                         explain: &str) {\n     feature_err(sess, feature, span, issue, explain).emit();\n }\n \n pub fn feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue: GateIssue,\n                        explain: &str) -> DiagnosticBuilder<'a> {\n+    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n+}\n+\n+fn leveled_feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue: GateIssue,\n+                           explain: &str, level: GateStrength) -> DiagnosticBuilder<'a> {\n     let diag = &sess.span_diagnostic;\n \n     let issue = match issue {\n         GateIssue::Language => find_lang_feature_issue(feature),\n         GateIssue::Library(lib) => lib,\n     };\n \n-    let mut err = if let Some(n) = issue {\n-        diag.struct_span_err(span, &format!(\"{} (see issue #{})\", explain, n))\n+    let explanation = if let Some(n) = issue {\n+        format!(\"{} (see issue #{})\", explain, n)\n     } else {\n-        diag.struct_span_err(span, explain)\n+        explain.to_owned()\n+    };\n+\n+    let mut err = match level {\n+        GateStrength::Hard => diag.struct_span_err(span, &explanation),\n+        GateStrength::Soft => diag.struct_span_warn(span, &explanation),\n     };\n \n     // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n@@ -1038,7 +1063,15 @@ pub fn feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue: Ga\n                           feature));\n     }\n \n+    // If we're on stable and only emitting a \"soft\" warning, add a note to\n+    // clarify that the feature isn't \"on\" (rather than being on but\n+    // warning-worthy).\n+    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n+        err.help(\"a nightly build of the compiler is required to enable this feature\");\n+    }\n+\n     err\n+\n }\n \n const EXPLAIN_BOX_SYNTAX: &'static str =\n@@ -1095,6 +1128,12 @@ macro_rules! gate_feature_post {\n         if !span.allows_unstable() {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n+    }};\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable() {\n+            gate_feature!(cx.context, $feature, span, $explain, $level)\n+        }\n     }}\n }\n \n@@ -1239,7 +1278,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n                 if attr::contains_name(&i.attrs[..], \"must_use\") {\n                     gate_feature_post!(&self, fn_must_use, i.span,\n-                                       \"`#[must_use]` on functions is experimental\");\n+                                       \"`#[must_use]` on functions is experimental\",\n+                                       GateStrength::Soft);\n                 }\n             }\n "}, {"sha": "a222f366145356a496627e0581e23790ed4bdf24", "filename": "src/test/compile-fail/feature-gate-fn_must_use.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Ftest%2Fcompile-fail%2Ffeature-gate-fn_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Ftest%2Fcompile-fail%2Ffeature-gate-fn_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-fn_must_use.rs?ref=8492ad2479379d2e07ccf2d3439ec29b19d164b8", "patch": "@@ -8,7 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n #[must_use]\n-fn need_to_use_it() -> bool { true } //~ ERROR `#[must_use]` on functions is experimental\n+fn need_to_use_it() -> bool { true } //~ WARN `#[must_use]` on functions is experimental\n+\n \n-fn main() {}\n+// Feature gates are tidy-required to have a specially named (or\n+// comment-annotated) compile-fail test (which MUST fail), but for\n+// backwards-compatibility reasons, we want `#[must_use]` on functions to be\n+// compilable even if the `fn_must_use` feature is absent, thus necessitating\n+// the usage of `#[rustc_error]` here, pragmatically if awkwardly solving this\n+// dilemma until a superior solution can be devised.\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "204190d64acc1f61a33a02b7e02a510c52ce464d", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8492ad2479379d2e07ccf2d3439ec29b19d164b8/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs?ref=8492ad2479379d2e07ccf2d3439ec29b19d164b8", "patch": "@@ -680,7 +680,7 @@ mod must_use {\n     mod inner { #![must_use=\"1400\"] }\n \n     #[must_use = \"1400\"] fn f() { }\n-    //~^ ERROR `#[must_use]` on functions is experimental\n+    //~^ WARN `#[must_use]` on functions is experimental\n \n     #[must_use = \"1400\"] struct S;\n "}]}