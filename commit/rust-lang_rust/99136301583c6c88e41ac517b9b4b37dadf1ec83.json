{"sha": "99136301583c6c88e41ac517b9b4b37dadf1ec83", "node_id": "C_kwDOAAsO6NoAKDk5MTM2MzAxNTgzYzZjODhlNDFhYzUxN2I5YjRiMzdkYWRmMWVjODM", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-09T13:54:43Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-09T13:54:43Z"}, "message": "Reduce usage of subst types in the intrinsic code\n\nUsing the arguments often saves a layout_of call", "tree": {"sha": "1263dde02827484b51a47abcdf2d130063ab7f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1263dde02827484b51a47abcdf2d130063ab7f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99136301583c6c88e41ac517b9b4b37dadf1ec83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99136301583c6c88e41ac517b9b4b37dadf1ec83", "html_url": "https://github.com/rust-lang/rust/commit/99136301583c6c88e41ac517b9b4b37dadf1ec83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99136301583c6c88e41ac517b9b4b37dadf1ec83/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4fff03d40ca602d447f3965e1afed2262978640", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4fff03d40ca602d447f3965e1afed2262978640", "html_url": "https://github.com/rust-lang/rust/commit/e4fff03d40ca602d447f3965e1afed2262978640"}], "stats": {"total": 114, "additions": 55, "deletions": 59}, "files": [{"sha": "da9aa45069b837d7297f9f9f25d32d568d47ab24", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/99136301583c6c88e41ac517b9b4b37dadf1ec83/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99136301583c6c88e41ac517b9b4b37dadf1ec83/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=99136301583c6c88e41ac517b9b4b37dadf1ec83", "patch": "@@ -41,29 +41,18 @@ macro intrinsic_arg {\n     }\n }\n \n-macro intrinsic_substs {\n-    ($substs:expr, $index:expr,) => {},\n-    ($substs:expr, $index:expr, $first:ident $(,$rest:ident)*) => {\n-        let $first = $substs.type_at($index);\n-        intrinsic_substs!($substs, $index+1, $($rest),*);\n-    }\n-}\n-\n macro intrinsic_match {\n     ($fx:expr, $intrinsic:expr, $substs:expr, $args:expr,\n     _ => $unknown:block;\n     $(\n-        $($($name:tt).*)|+ $(if $cond:expr)?, $(<$($subst:ident),*>)? ($($a:ident $arg:ident),*) $content:block;\n+        $($($name:tt).*)|+ $(if $cond:expr)?, ($($a:ident $arg:ident),*) $content:block;\n     )*) => {\n         let _ = $substs; // Silence warning when substs is unused.\n         match $intrinsic {\n             $(\n                 $(intrinsic_pat!($($name).*))|* $(if $cond)? => {\n                     #[allow(unused_parens, non_snake_case)]\n                     {\n-                        $(\n-                            intrinsic_substs!($substs, 0, $($subst),*);\n-                        )?\n                         if let [$($arg),*] = $args {\n                             let ($($arg,)*) = (\n                                 $(intrinsic_arg!($a $fx, $arg),)*\n@@ -492,7 +481,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         breakpoint, () {\n             fx.bcx.ins().debugtrap();\n         };\n-        copy | copy_nonoverlapping, <elem_ty> (v src, v dst, v count) {\n+        copy | copy_nonoverlapping, (v src, v dst, v count) {\n+            let elem_ty = substs.type_at(0);\n             let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n             assert_eq!(args.len(), 3);\n             let byte_amount = if elem_size != 1 {\n@@ -510,7 +500,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n-        volatile_copy_memory | volatile_copy_nonoverlapping_memory, <elem_ty> (v dst, v src, v count) {\n+        volatile_copy_memory | volatile_copy_nonoverlapping_memory, (v dst, v src, v count) {\n+            let elem_ty = substs.type_at(0);\n             let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n             assert_eq!(args.len(), 3);\n             let byte_amount = if elem_size != 1 {\n@@ -528,8 +519,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n             }\n         };\n-        size_of_val, <T> (c ptr) {\n-            let layout = fx.layout_of(T);\n+        size_of_val, (c ptr) {\n+            let layout = fx.layout_of(substs.type_at(0));\n             let size = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n@@ -542,8 +533,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             };\n             ret.write_cvalue(fx, CValue::by_val(size, usize_layout));\n         };\n-        min_align_of_val, <T> (c ptr) {\n-            let layout = fx.layout_of(T);\n+        min_align_of_val, (c ptr) {\n+            let layout = fx.layout_of(substs.type_at(0));\n             let align = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n@@ -589,15 +580,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        saturating_add | saturating_sub, <T> (c lhs, c rhs) {\n+        saturating_add | saturating_sub, (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n                 sym::saturating_add => BinOp::Add,\n                 sym::saturating_sub => BinOp::Sub,\n                 _ => unreachable!(),\n             };\n \n-            let signed = type_sign(T);\n+            let signed = type_sign(lhs.layout().ty);\n \n             let checked_res = crate::num::codegen_checked_int_binop(\n                 fx,\n@@ -607,7 +598,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n \n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n-            let clif_ty = fx.clif_type(T).unwrap();\n+            let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n \n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n@@ -629,17 +620,19 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let res = CValue::by_val(val, fx.layout_of(T));\n+            let res = CValue::by_val(val, lhs.layout());\n \n             ret.write_cvalue(fx, res);\n         };\n-        rotate_left, <T>(v x, v y) {\n-            let layout = fx.layout_of(T);\n+        rotate_left, (c x, v y) {\n+            let layout = x.layout();\n+            let x = x.load_scalar(fx);\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n-        rotate_right, <T>(v x, v y) {\n-            let layout = fx.layout_of(T);\n+        rotate_right, (c x, v y) {\n+            let layout = x.layout();\n+            let x = x.load_scalar(fx);\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -675,29 +668,33 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME use emit_small_memset\n             fx.bcx.call_memset(fx.target_config, dst_ptr, val, count);\n         };\n-        ctlz | ctlz_nonzero, <T> (v arg) {\n+        ctlz | ctlz_nonzero, (c arg) {\n+            let val = arg.load_scalar(fx);\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n-            let res = fx.bcx.ins().clz(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+            let res = fx.bcx.ins().clz(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        cttz | cttz_nonzero, <T> (v arg) {\n+        cttz | cttz_nonzero, (c arg) {\n+            let val = arg.load_scalar(fx);\n             // FIXME trap on `cttz_nonzero` with zero arg.\n-            let res = fx.bcx.ins().ctz(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+            let res = fx.bcx.ins().ctz(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        ctpop, <T> (v arg) {\n-            let res = fx.bcx.ins().popcnt(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+        ctpop, (c arg) {\n+            let val = arg.load_scalar(fx);\n+            let res = fx.bcx.ins().popcnt(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        bitreverse, <T> (v arg) {\n-            let res = fx.bcx.ins().bitrev(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+        bitreverse, (c arg) {\n+            let val = arg.load_scalar(fx);\n+            let res = fx.bcx.ins().bitrev(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        bswap, <T> (v arg) {\n+        bswap, (c arg) {\n             // FIXME(CraneStation/cranelift#794) add bswap instruction to cranelift\n             fn swap(bcx: &mut FunctionBuilder<'_>, v: Value) -> Value {\n                 match bcx.func.dfg.value_type(v) {\n@@ -773,15 +770,16 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     ty => unreachable!(\"bswap {}\", ty),\n                 }\n             }\n-            let res = CValue::by_val(swap(&mut fx.bcx, arg), fx.layout_of(T));\n+            let val = arg.load_scalar(fx);\n+            let res = CValue::by_val(swap(&mut fx.bcx, val), arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        assert_inhabited | assert_zero_valid | assert_uninit_valid, <T> () {\n-            let layout = fx.layout_of(T);\n+        assert_inhabited | assert_zero_valid | assert_uninit_valid, () {\n+            let layout = fx.layout_of(substs.type_at(0));\n             if layout.abi.is_uninhabited() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n-                    &format!(\"attempted to instantiate uninhabited type `{}`\", T),\n+                    &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n                     span,\n                 ));\n                 return;\n@@ -790,7 +788,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n-                    &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n+                    &format!(\"attempted to zero-initialize type `{}`, which is invalid\", layout.ty),\n                     span,\n                 ));\n                 return;\n@@ -799,7 +797,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n-                    &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n+                    &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", layout.ty),\n                     span,\n                 ));\n                 return;\n@@ -832,10 +830,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        ptr_offset_from, <T> (v ptr, v base) {\n+        ptr_offset_from, (v ptr, v base) {\n+            let ty = substs.type_at(0);\n             let isize_layout = fx.layout_of(fx.tcx.types.isize);\n \n-            let pointee_size: u64 = fx.layout_of(T).size.bytes();\n+            let pointee_size: u64 = fx.layout_of(ty).size.bytes();\n             let diff = fx.bcx.ins().isub(ptr, base);\n             // FIXME this can be an exact division.\n             let val = CValue::by_val(fx.bcx.ins().sdiv_imm(diff, pointee_size as i64), isize_layout);\n@@ -864,13 +863,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME use a compiler fence once Cranelift supports it\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.as_str().starts_with(\"atomic_load\"), <T> (v ptr) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-            let ty = fx.clif_type(T).unwrap();\n+        _ if intrinsic.as_str().starts_with(\"atomic_load\"), (v ptr) {\n+            let ty = substs.type_at(0);\n+            validate_atomic_type!(fx, intrinsic, span, ty);\n+            let clif_ty = fx.clif_type(ty).unwrap();\n \n-            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n+            let val = fx.bcx.ins().atomic_load(clif_ty, MemFlags::trusted(), ptr);\n \n-            let val = CValue::by_val(val, fx.layout_of(T));\n+            let val = CValue::by_val(val, fx.layout_of(ty));\n             ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_store\"), (v ptr, c val) {\n@@ -1101,18 +1101,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n         };\n \n-        raw_eq, <T>(v lhs_ref, v rhs_ref) {\n-            fn type_by_size(size: Size) -> Option<Type> {\n-                Type::int(size.bits().try_into().ok()?)\n-            }\n-\n-            let size = fx.layout_of(T).layout.size;\n+        raw_eq, (v lhs_ref, v rhs_ref) {\n+            let size = fx.layout_of(substs.type_at(0)).layout.size;\n             // FIXME add and use emit_small_memcmp\n             let is_eq_value =\n                 if size == Size::ZERO {\n                     // No bytes means they're trivially equal\n                     fx.bcx.ins().iconst(types::I8, 1)\n-                } else if let Some(clty) = type_by_size(size) {\n+                } else if let Some(clty) = size.bits().try_into().ok().and_then(Type::int) {\n                     // Can't use `trusted` for these loads; they could be unaligned.\n                     let mut flags = MemFlags::new();\n                     flags.set_notrap();"}]}