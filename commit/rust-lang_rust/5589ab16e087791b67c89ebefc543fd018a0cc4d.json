{"sha": "5589ab16e087791b67c89ebefc543fd018a0cc4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ODlhYjE2ZTA4Nzc5MWI2N2M4OWViZWZjNTQzZmQwMThhMGNjNGQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-20T01:01:06Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-20T01:05:35Z"}, "message": "Clarify immaturity of grammar, add a pile of half-baked grammar rules.", "tree": {"sha": "49bd4e4752db9e53575c6bca0e00da407d6f654c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49bd4e4752db9e53575c6bca0e00da407d6f654c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5589ab16e087791b67c89ebefc543fd018a0cc4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5589ab16e087791b67c89ebefc543fd018a0cc4d", "html_url": "https://github.com/rust-lang/rust/commit/5589ab16e087791b67c89ebefc543fd018a0cc4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5589ab16e087791b67c89ebefc543fd018a0cc4d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "997b29fa7e6d329567a04ba66379126de1ebe6cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/997b29fa7e6d329567a04ba66379126de1ebe6cb", "html_url": "https://github.com/rust-lang/rust/commit/997b29fa7e6d329567a04ba66379126de1ebe6cb"}], "stats": {"total": 135, "additions": 122, "deletions": 13}, "files": [{"sha": "ca7f79e1f31ef9c6669edd17aaa28094972f86f6", "filename": "doc/rust.md", "status": "modified", "additions": 122, "deletions": 13, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5589ab16e087791b67c89ebefc543fd018a0cc4d/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5589ab16e087791b67c89ebefc543fd018a0cc4d/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=5589ab16e087791b67c89ebefc543fd018a0cc4d", "patch": "@@ -42,6 +42,15 @@ If you have suggestions to make, please try to focus them on *reductions* to\n the language: possible features that can be combined or omitted. We aim to\n keep the size and complexity of the language under control.\n \n+**Note on grammar:** The grammar for Rust given in this document is rough and\n+very incomplete; only a modest number of sections have accompanying grammar\n+rules. Formalizing the grammar accepted by the Rust parser is ongoing work,\n+but future versions of this document will contain a complete\n+grammar. Moreover, we hope that this grammar will be be extracted and verified\n+as LL(1) by an automated grammar-analysis tool, and further tested against the\n+Rust sources. Preliminary versions of this automation exist, but are not yet\n+complete.\n+\n # Notation\n \n Rust's grammar is defined over Unicode codepoints, each conventionally\n@@ -81,13 +90,6 @@ Where:\n \n This EBNF dialect should hopefully be familiar to many readers.\n \n-The grammar for Rust given in this document is extracted and verified as LL(1)\n-by an automated grammar-analysis tool, and further tested against the Rust\n-sources. The generated parser is currently *not* the one used by the Rust\n-compiler itself, but in the future we hope to relate the two together more\n-precisely. As of this writing they are only related by testing against\n-existing source code.\n-\n ## Unicode productions\n \n A small number of productions in Rust's grammar permit Unicode codepoints\n@@ -917,7 +919,7 @@ In this example, `nonempty_list` is a predicate---it can be used in a\n typestate constraint---but the auxiliary function `pure_length` is\n not.\n \n-*ToDo:* should actually define referential transparency.\n+*TODO:* should actually define referential transparency.\n \n The effect checking rules previously enumerated are a restricted set of\n typechecking rules meant to approximate the universe of observably\n@@ -933,7 +935,7 @@ blocks, the compiler provides no static guarantee that the code will behave as\n expected at runtime. Rather, the programmer has an independent obligation to\n verify the semantics of the predicates they write.\n \n-*ToDo:* last two sentences are vague.\n+*TODO:* last two sentences are vague.\n \n An example of a predicate that uses an unchecked block:\n \n@@ -1327,6 +1329,12 @@ declaring a function-local item.\n \n #### Slot declarations\n \n+~~~~~~~~{.ebnf .gram}\n+let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n+init : [ '=' | '<-' ] expr ; \n+~~~~~~~~\n+\n+\n A _slot declaration_ has one one of two forms:\n \n * `let` `pattern` `optional-init`;\n@@ -1382,6 +1390,12 @@ values.\n \n ### Record expressions\n \n+~~~~~~~~{.ebnf .gram}\n+rec_expr : '{' ident ':' expr\n+               [ ',' ident ':' expr ] *\n+               [ \"with\" expr ] '}'\n+~~~~~~~~\n+\n A _[record](#record-types) expression_ is one or more comma-separated\n name-value pairs enclosed by braces. A fieldname can be any identifier\n (including reserved words), and is separated from its value expression\n@@ -1414,6 +1428,10 @@ let base = {x: 1, y: 2, z: 3};\n \n ### Field expressions\n \n+~~~~~~~~{.ebnf .gram}\n+field_expr : expr '.' expr\n+~~~~~~~~\n+\n A dot can be used to access a field in a record.\n \n ~~~~~~~~ {.field}\n@@ -1439,6 +1457,10 @@ expression on the left of the dot.\n \n ### Vector expressions\n \n+~~~~~~~~{.ebnf .gram}\n+vec_expr : '[' \"mutable\" ? [ expr [ ',' expr ] * ] ? ']'\n+~~~~~~~~\n+\n A _[vector](#vector-types) expression_ is written by enclosing zero or\n more comma-separated expressions of uniform type in square brackets.\n The keyword `mutable` can be written after the opening bracket to\n@@ -1453,6 +1475,11 @@ When no mutability is specified, the vector is immutable.\n \n ### Index expressions\n \n+~~~~~~~~{.ebnf .gram}\n+idx_expr : expr '[' expr ']'\n+~~~~~~~~\n+\n+\n [Vector](#vector-types)-typed expressions can be indexed by writing a\n square-bracket-enclosed expression (the index) after them. When the\n vector is mutable, the resulting _lval_ can be assigned to.\n@@ -1492,6 +1519,13 @@ operators, before the expression they apply to.\n \n ### Binary operator expressions\n \n+~~~~~~~~{.ebnf .gram}\n+binop_expr : expr binop expr ;\n+~~~~~~~~\n+\n+Binary operators expressions are given in terms of\n+[operator precedence](#operator-precedence).\n+\n #### Arithmetic operators\n \n Binary arithmetic expressions require both their operands to be of the\n@@ -1672,10 +1706,15 @@ as\n == !=\n &&\n ||\n+= <- <->\n ~~~~\n \n ### Unary copy expressions\n \n+~~~~~~~~{.ebnf .gram}\n+copy_expr : \"copy\" expr ;\n+~~~~~~~~\n+\n A _unary copy expression_ consists of the unary `copy` operator applied to\n some argument expression.\n \n@@ -1684,8 +1723,8 @@ copies the resulting value, allocating any memory necessary to hold the new\n copy.\n \n [Shared boxes](#shared-box-types) (type `@`) are, as usual, shallow-copied, as\n-they may be cyclic. [Unique boxes](unique-box-types), [vectors](#vector-types)\n-and similar unique types are deep-copied.\n+they may be cyclic. [Unique boxes](#unique-box-types),\n+[vectors](#vector-types) and similar unique types are deep-copied.\n \n Since the binary [assignment operator](#assignment-operator) `=` performs a\n copy implicitly, the unary copy operator is typically only used to cause an\n@@ -1707,6 +1746,10 @@ assert v[0] == 1; // Original was not modified\n \n ### Unary move expressions\n \n+~~~~~~~~{.ebnf .gram}\n+move_expr : \"move\" expr ;\n+~~~~~~~~\n+\n This is used to indicate that the referenced _lval_ must be moved out,\n rather than copied, when evaluating this expression. It will only have\n an effect when the expression is _stored_ somewhere or passed to a\n@@ -1796,6 +1839,11 @@ way.\n \n ### While expressions\n \n+~~~~~~~~{.ebnf .gram}\n+while_expr : \"while\" expr '{' block '}'\n+           | \"do\" '{' block '}' \"while\" expr ;\n+~~~~~~~~\n+\n A `while` expression is a loop construct. A `while` loop may be either a\n simple `while` or a `do`-`while` loop.\n \n@@ -1813,7 +1861,7 @@ loop body. If it evaluates to `false`, control exits the loop.\n An example of a simple `while` expression:\n \n ~~~~\n-while (i < 10) {\n+while i < 10 {\n     print(\"hello\\n\");\n     i = i + 1;\n }\n@@ -1825,17 +1873,25 @@ An example of a `do`-`while` expression:\n do {\n     print(\"hello\\n\");\n     i = i + 1;\n-} while (i < 10);\n+} while i < 10;\n ~~~~\n \n \n ### Break expressions\n \n+~~~~~~~~{.ebnf .gram}\n+break_expr : \"break\" ;\n+~~~~~~~~\n+\n Executing a `break` expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop.\n \n ### Continue expressions\n \n+~~~~~~~~{.ebnf .gram}\n+break_expr : \"cont\" ;\n+~~~~~~~~\n+\n Evaluating a `cont` expression immediately terminates the current iteration of\n the innermost loop enclosing it, returning control to the loop *head*. In the\n case of a `while` loop, the head is the conditional expression controlling the\n@@ -1847,6 +1903,10 @@ A `cont` expression is only permitted in the body of a loop.\n \n ### For expressions\n \n+~~~~~~~~{.ebnf .gram}\n+for_expr : \"for\" pat \"in\" expr '{' block '}' ;\n+~~~~~~~~\n+\n A _for loop_ is controlled by a vector or string. The for loop bounds-checks\n the underlying sequence *once* when initiating the loop, then repeatedly\n executes the loop body with the loop variable referencing the successive\n@@ -1865,6 +1925,14 @@ for e: foo in v {\n \n ### If expressions\n \n+~~~~~~~~{.ebnf .gram}\n+if_expr : \"if\" expr '{' block '}'\n+          [ \"else\" else_tail ] ? ;\n+          \n+else_tail : \"else\" [ if_expr\n+                   | '{' block '} ] ;\n+~~~~~~~~\n+\n An `if` expression is a conditional branch in program control. The form of\n an `if` expression is a condition expression, followed by a consequent\n block, any number of `else if` conditions and blocks, and an optional\n@@ -1879,6 +1947,15 @@ then any `else` block is executed.\n \n ### Alternative expressions\n \n+~~~~~~~~{.ebnf .gram}\n+alt_expr : \"alt\" expr '{' alt_arm [ '|' alt_arm ] * '}' ;\n+\n+alt_arm : alt_pat '{' block '}' ;\n+\n+alt_pat : pat [ \"to\" pat ] ? [ \"if\" expr ] ;\n+~~~~~~~~\n+\n+\n An `alt` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n literals, destructured tag constructors, records and tuples, variable binding\n@@ -1971,13 +2048,21 @@ let message = alt maybe_digit {\n \n ### Fail expressions\n \n+~~~~~~~~{.ebnf .gram}\n+fail_expr : \"fail\" expr ? ;\n+~~~~~~~~\n+\n Evaluating a `fail` expression causes a task to enter the *failing* state. In\n the *failing* state, a task unwinds its stack, destroying all frames and\n freeing all resources until it reaches its entry frame, at which point it\n halts execution in the *dead* state.\n \n ### Note expressions\n \n+~~~~~~~~{.ebnf .gram}\n+note_expr : \"note\" expr ;\n+~~~~~~~~\n+\n **Note: Note expressions are not yet supported by the compiler.**\n \n A `note` expression has no effect during normal execution. The purpose of a\n@@ -2023,6 +2108,10 @@ expression.\n \n ### Return expressions\n \n+~~~~~~~~{.ebnf .gram}\n+ret_expr : \"ret\" expr ? ;\n+~~~~~~~~\n+\n Return expressions are denoted with the keyword `ret`. Evaluating a `ret`\n expression^[footnote{A `ret` expression is analogous to a `return` expression\n in the C family.] moves its argument into the output slot of the current\n@@ -2042,6 +2131,10 @@ fn max(a: int, b: int) -> int {\n \n ### Log expressions\n \n+~~~~~~~~{.ebnf .gram}\n+log_expr : \"log\" '(' level ',' expr ')' ;\n+~~~~~~~~\n+\n Evaluating a `log` expression may, depending on runtime configuration, cause a\n value to be appended to an internal diagnostic logging buffer provided by the\n runtime or emitted to a system console. Log expressions are enabled or\n@@ -2094,6 +2187,10 @@ when it is changed.\n \n ### Check expressions\n \n+~~~~~~~~{.ebnf .gram}\n+check_expr : \"check\" call_expr ;\n+~~~~~~~~\n+\n A `check` expression connects dynamic assertions made at run-time to the\n static [typestate system](#typestate-system). A `check` expression takes a\n constraint to check at run-time. If the constraint holds at run-time, control\n@@ -2134,13 +2231,21 @@ fn test() {\n \n **Note: Prove expressions are not yet supported by the compiler.**\n \n+~~~~~~~~{.ebnf .gram}\n+prove_expr : \"prove\" call_expr ;\n+~~~~~~~~\n+\n A `prove` expression has no run-time effect. Its purpose is to statically\n check (and document) that its argument constraint holds at its expression\n entry point. If its argument typestate does not hold, under the typestate\n algorithm, the program containing it will fail to compile.\n \n ### Claim expressions\n \n+~~~~~~~~{.ebnf .gram}\n+claim_expr : \"claim\" call_expr ;\n+~~~~~~~~\n+\n A `claim` expression is an unsafe variant on a `check` expression that is not\n actually checked at runtime. Thus, using a `claim` implies a proof obligation\n to ensure---without compiler assistance---that an assertion always holds.\n@@ -2183,6 +2288,10 @@ if check even(x) {\n \n ### Assert expressions\n \n+~~~~~~~~{.ebnf .gram}\n+assert_expr : \"assert\" expr ;\n+~~~~~~~~\n+\n An `assert` expression is similar to a `check` expression, except\n the condition may be any boolean-typed expression, and the compiler makes no\n use of the knowledge that the condition holds if the program continues to"}]}