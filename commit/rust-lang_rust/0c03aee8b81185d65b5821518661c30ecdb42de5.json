{"sha": "0c03aee8b81185d65b5821518661c30ecdb42de5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMDNhZWU4YjgxMTg1ZDY1YjU4MjE1MTg2NjFjMzBlY2RiNDJkZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-05T23:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-05T23:08:08Z"}, "message": "Auto merge of #74073 - Manishearth:rollup-faqo9lx, r=Manishearth\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #72688 (added .collect() into String from Box<str>)\n - #73787 (Add unstable docs for rustc_attrs)\n - #73834 (Some refactoring around intrinsic type checking)\n - #73871 (Fix try_print_visible_def_path for Rust 2018)\n - #73937 (Explain exhaustive matching on {usize,isize} maximum values)\n - #73973 (Use `Span`s to identify unreachable subpatterns in or-patterns)\n - #74000 (add `lazy_normalization_consts` feature gate)\n - #74025 (Remove unnecessary release from Arc::try_unwrap)\n - #74027 (Convert more `DefId`s to `LocalDefId`s)\n - #74055 (Fix spacing in Iterator fold doc)\n - #74057 (expected_found `&T` -> `T`)\n - #74064 (variant_count: avoid incorrect dummy implementation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5d9ea2c252f737710f1a071b08babc537c90ca2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d9ea2c252f737710f1a071b08babc537c90ca2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c03aee8b81185d65b5821518661c30ecdb42de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c03aee8b81185d65b5821518661c30ecdb42de5", "html_url": "https://github.com/rust-lang/rust/commit/0c03aee8b81185d65b5821518661c30ecdb42de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c03aee8b81185d65b5821518661c30ecdb42de5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2753fab7ce3647033146b07c8b6c9f4856a910b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2753fab7ce3647033146b07c8b6c9f4856a910b0", "html_url": "https://github.com/rust-lang/rust/commit/2753fab7ce3647033146b07c8b6c9f4856a910b0"}, {"sha": "e62436333eb4c3d98c23f1a0478e35a843cc4b95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e62436333eb4c3d98c23f1a0478e35a843cc4b95", "html_url": "https://github.com/rust-lang/rust/commit/e62436333eb4c3d98c23f1a0478e35a843cc4b95"}], "stats": {"total": 1128, "additions": 796, "deletions": 332}, "files": [{"sha": "2967200faf80d263be8b152d04da2baa3d84d6c6", "filename": "src/doc/unstable-book/src/language-features/rustc-attrs.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,53 @@\n+# `rustc_attrs`\n+\n+This feature has no tracking issue, and is therefore internal to\n+the compiler, not being intended for general use.\n+\n+Note: `rustc_attrs` enables many rustc-internal attributes and this page\n+only discuss a few of them.\n+\n+------------------------\n+\n+The `rustc_attrs` feature allows debugging rustc type layouts by using\n+`#[rustc_layout(...)]` to debug layout at compile time (it even works\n+with `cargo check`) as an alternative to `rustc -Z print-type-sizes`\n+that is way more verbose.\n+\n+Options provided by `#[rustc_layout(...)]` are `debug`, `size`, `abi`.\n+Note that it only work best with sized type without generics.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout(abi, size)]\n+pub enum X {\n+    Y(u8, u8, u8),\n+    Z(isize),\n+}\n+```\n+\n+When that is compiled, the compiler will error with something like\n+\n+```text\n+error: abi: Aggregate { sized: true }\n+ --> src/lib.rs:4:1\n+  |\n+4 | / pub enum T {\n+5 | |     Y(u8, u8, u8),\n+6 | |     Z(isize),\n+7 | | }\n+  | |_^\n+\n+error: size: Size { raw: 16 }\n+ --> src/lib.rs:4:1\n+  |\n+4 | / pub enum T {\n+5 | |     Y(u8, u8, u8),\n+6 | |     Z(isize),\n+7 | | }\n+  | |_^\n+\n+error: aborting due to 2 previous errors\n+```"}, {"sha": "5b671b41b5bf673f12f5d27ad9d4d3e6ede22db6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1774,6 +1774,15 @@ impl FromIterator<String> for String {\n     }\n }\n \n+#[stable(feature = \"box_str2\", since = \"1.45.0\")]\n+impl FromIterator<Box<str>> for String {\n+    fn from_iter<I: IntoIterator<Item = Box<str>>>(iter: I) -> String {\n+        let mut buf = String::new();\n+        buf.extend(iter);\n+        buf\n+    }\n+}\n+\n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> FromIterator<Cow<'a, str>> for String {\n     fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n@@ -1842,6 +1851,13 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n+#[stable(feature = \"box_str2\", since = \"1.45.0\")]\n+impl Extend<Box<str>> for String {\n+    fn extend<I: IntoIterator<Item = Box<str>>>(&mut self, iter: I) {\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n+    }\n+}\n+\n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {"}, {"sha": "2d6a3917c764e30eb33fb3e60eb47cb0653ddca5", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -419,8 +419,7 @@ impl<T> Arc<T> {\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n-        // See `drop` for why all these atomics are like this\n-        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n+        if this.inner().strong.compare_exchange(1, 0, Relaxed, Relaxed).is_err() {\n             return Err(this);\n         }\n "}, {"sha": "b3e43cd799405a99681f246d336ec7ceec2c4d3d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -2004,12 +2004,6 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n }\n \n-#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n-#[cfg(bootstrap)]\n-pub const fn variant_count<T>() -> usize {\n-    0\n-}\n-\n // Some functions are defined here because they accidentally got made\n // available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n // (`transmute` also falls into this category, but it cannot be wrapped due to the"}, {"sha": "ce4be973140e58fa8a182daad5acbc350e339f38", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1521,7 +1521,7 @@ pub trait Iterator {\n     ///\n     /// let iter = a.iter();\n     ///\n-    /// let sum: i32 = iter.take(5).fold(0, |acc, i| acc + i );\n+    /// let sum: i32 = iter.take(5).fold(0, |acc, i| acc + i);\n     ///\n     /// assert_eq!(sum, 6);\n     ///\n@@ -1535,7 +1535,7 @@ pub trait Iterator {\n     /// let mut iter = a.iter();\n     ///\n     /// // instead, we add in a .by_ref()\n-    /// let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i );\n+    /// let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i);\n     ///\n     /// assert_eq!(sum, 3);\n     ///"}, {"sha": "692d91bd61ddf1fe76bcb6dd1aeff36e036e6b24", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -125,7 +125,7 @@\n #![feature(unsized_locals)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n-#![feature(variant_count)]\n+#![cfg_attr(not(bootstrap), feature(variant_count))]\n #![feature(doc_alias)]\n #![feature(mmx_target_feature)]\n #![feature(tbm_target_feature)]"}, {"sha": "0a976a4ca00c965df512204d608912ceac95a52d", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1037,6 +1037,7 @@ pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// assert_eq!(mem::variant_count::<Result<!, !>>(), 2);\n /// ```\n #[inline(always)]\n+#[cfg(not(bootstrap))]\n #[unstable(feature = \"variant_count\", issue = \"73662\")]\n #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n pub const fn variant_count<T>() -> usize {"}, {"sha": "32481bf2b95746fb0330328e0560984ebf20ffdf", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -570,6 +570,9 @@ declare_features! (\n     /// Allows capturing variables in scope using format_args!\n     (active, format_args_capture, \"1.46.0\", Some(67984), None),\n \n+    /// Lazily evaluate constants. This allows constants to depend on type parameters.\n+    (active, lazy_normalization_consts, \"1.46.0\", Some(72219), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -586,5 +589,6 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::raw_dylib,\n     sym::const_trait_impl,\n     sym::const_trait_bound_opt_out,\n+    sym::lazy_normalization_consts,\n     sym::specialization,\n ];"}, {"sha": "3b564e03d9a94e91ff1fe11b78e4ff7505147402", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -112,7 +112,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n \n             // All other cases of inference are errors\n             (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n             }\n \n             _ => ty::relate::super_relate_tys(relation, a, b),\n@@ -701,21 +701,21 @@ pub fn const_unification_error<'tcx>(\n     a_is_expected: bool,\n     (a, b): (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>),\n ) -> TypeError<'tcx> {\n-    TypeError::ConstMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::ConstMismatch(ty::relate::expected_found_bool(a_is_expected, a, b))\n }\n \n fn int_unification_error<'tcx>(\n     a_is_expected: bool,\n     v: (ty::IntVarValue, ty::IntVarValue),\n ) -> TypeError<'tcx> {\n     let (a, b) = v;\n-    TypeError::IntMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::IntMismatch(ty::relate::expected_found_bool(a_is_expected, a, b))\n }\n \n fn float_unification_error<'tcx>(\n     a_is_expected: bool,\n     v: (ty::FloatVarValue, ty::FloatVarValue),\n ) -> TypeError<'tcx> {\n     let (ty::FloatVarValue(a), ty::FloatVarValue(b)) = v;\n-    TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, a, b))\n }"}, {"sha": "698bef4374545fd292de91e3cbda164dcec01289", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1370,7 +1370,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// we still evaluate them eagerly.\n     #[inline]\n     pub fn lazy_normalization(self) -> bool {\n-        self.features().const_generics\n+        self.features().const_generics || self.features().lazy_normalization_consts\n     }\n \n     #[inline]"}, {"sha": "9dda208b5a0daa16c51579cca8c39eca81f354eb", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -282,26 +282,27 @@ pub trait PrettyPrinter<'tcx>:\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n             match self.tcx().extern_crate(def_id) {\n-                Some(&ExternCrate {\n-                    src: ExternCrateSource::Extern(def_id),\n-                    dependency_of: LOCAL_CRATE,\n-                    span,\n-                    ..\n-                }) => {\n-                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-                    return Ok((\n-                        if !span.is_dummy() {\n-                            self.print_def_path(def_id, &[])?\n-                        } else {\n-                            self.path_crate(cnum)?\n-                        },\n-                        true,\n-                    ));\n-                }\n+                Some(&ExternCrate { src, dependency_of, span, .. }) => match (src, dependency_of) {\n+                    (ExternCrateSource::Extern(def_id), LOCAL_CRATE) => {\n+                        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                        return Ok((\n+                            if !span.is_dummy() {\n+                                self.print_def_path(def_id, &[])?\n+                            } else {\n+                                self.path_crate(cnum)?\n+                            },\n+                            true,\n+                        ));\n+                    }\n+                    (ExternCrateSource::Path, LOCAL_CRATE) => {\n+                        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                        return Ok((self.path_crate(cnum)?, true));\n+                    }\n+                    _ => {}\n+                },\n                 None => {\n                     return Ok((self.path_crate(cnum)?, true));\n                 }\n-                _ => {}\n             }\n         }\n "}, {"sha": "7946a27b4d9686759dca28551903c0a7cd4256a9", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -159,8 +159,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n         if a.c_variadic != b.c_variadic {\n             return Err(TypeError::VariadicMismatch(expected_found(\n                 relation,\n-                &a.c_variadic,\n-                &b.c_variadic,\n+                a.c_variadic,\n+                b.c_variadic,\n             )));\n         }\n         let unsafety = relation.relate(a.unsafety, b.unsafety)?;\n@@ -200,7 +200,7 @@ impl<'tcx> Relate<'tcx> for ast::Unsafety {\n         b: ast::Unsafety,\n     ) -> RelateResult<'tcx, ast::Unsafety> {\n         if a != b {\n-            Err(TypeError::UnsafetyMismatch(expected_found(relation, &a, &b)))\n+            Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n         } else {\n             Ok(a)\n         }\n@@ -213,7 +213,7 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n         a: abi::Abi,\n         b: abi::Abi,\n     ) -> RelateResult<'tcx, abi::Abi> {\n-        if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(relation, &a, &b))) }\n+        if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(relation, a, b))) }\n     }\n }\n \n@@ -226,8 +226,8 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n                 relation,\n-                &a.item_def_id,\n-                &b.item_def_id,\n+                a.item_def_id,\n+                b.item_def_id,\n             )))\n         } else {\n             let substs = relation.relate(a.substs, b.substs)?;\n@@ -245,8 +245,8 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n                 relation,\n-                &a.item_def_id,\n-                &b.item_def_id,\n+                a.item_def_id,\n+                b.item_def_id,\n             )))\n         } else {\n             let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n@@ -264,7 +264,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n-            Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n+            Err(TypeError::Traits(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs })\n@@ -280,7 +280,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n-            Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n+            Err(TypeError::Traits(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs })\n@@ -305,6 +305,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n+    #[inline]\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Ty<'tcx>,\n@@ -421,7 +422,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                     let sz_b = sz_b.try_eval_usize(tcx, relation.param_env());\n                     match (sz_a, sz_b) {\n                         (Some(sz_a_val), Some(sz_b_val)) => Err(TypeError::FixedArraySize(\n-                            expected_found(relation, &sz_a_val, &sz_b_val),\n+                            expected_found(relation, sz_a_val, sz_b_val),\n                         )),\n                         _ => Err(err),\n                     }\n@@ -440,9 +441,9 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                     as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n-                Err(TypeError::TupleSize(expected_found(relation, &as_.len(), &bs.len())))\n+                Err(TypeError::TupleSize(expected_found(relation, as_.len(), bs.len())))\n             } else {\n-                Err(TypeError::Sorts(expected_found(relation, &a, &b)))\n+                Err(TypeError::Sorts(expected_found(relation, a, b)))\n             }\n         }\n \n@@ -471,7 +472,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_opaque(a_def_id, substs))\n         }\n \n-        _ => Err(TypeError::Sorts(expected_found(relation, &a, &b))),\n+        _ => Err(TypeError::Sorts(expected_found(relation, a, b))),\n     }\n }\n \n@@ -521,10 +522,10 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {\n-                            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                            Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n                         }\n                     } else {\n-                        Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                        Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n                     }\n                 }\n \n@@ -534,7 +535,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     if a_bytes == b_bytes {\n                         Ok(a_val)\n                     } else {\n-                        Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                        Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n                     }\n                 }\n \n@@ -554,7 +555,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n \n                                 Ok(a_val)\n                             } else {\n-                                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                                Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n                             }\n                         }\n                         // FIXME(const_generics): There are probably some `TyKind`s\n@@ -564,12 +565,12 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                                 DUMMY_SP,\n                                 &format!(\"unexpected consts: a: {:?}, b: {:?}\", a, b),\n                             );\n-                            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                            Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n                         }\n                     }\n                 }\n \n-                _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n+                _ => Err(TypeError::ConstMismatch(expected_found(relation, a, b))),\n             };\n \n             new_val.map(ty::ConstKind::Value)\n@@ -584,7 +585,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                 relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n             Ok(ty::ConstKind::Unevaluated(a_def_id, substs, a_promoted))\n         }\n-        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n+        _ => Err(TypeError::ConstMismatch(expected_found(relation, a, b))),\n     };\n     new_const_val.map(|val| tcx.mk_const(ty::Const { val, ty: a.ty }))\n }\n@@ -607,7 +608,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         b_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         b_v.dedup();\n         if a_v.len() != b_v.len() {\n-            return Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b)));\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n         let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n@@ -616,7 +617,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                 (Trait(a), Trait(b)) => Ok(Trait(relation.relate(a, b)?)),\n                 (Projection(a), Projection(b)) => Ok(Projection(relation.relate(a, b)?)),\n                 (AutoTrait(a), AutoTrait(b)) if a == b => Ok(AutoTrait(a)),\n-                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b))),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b))),\n             }\n         });\n         Ok(tcx.mk_existential_predicates(v)?)\n@@ -740,20 +741,14 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<R, T>(relation: &mut R, a: &T, b: &T) -> ExpectedFound<T>\n+pub fn expected_found<R, T>(relation: &mut R, a: T, b: T) -> ExpectedFound<T>\n where\n     R: TypeRelation<'tcx>,\n-    T: Clone,\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }\n \n-pub fn expected_found_bool<T>(a_is_expected: bool, a: &T, b: &T) -> ExpectedFound<T>\n-where\n-    T: Clone,\n-{\n-    let a = a.clone();\n-    let b = b.clone();\n+pub fn expected_found_bool<T>(a_is_expected: bool, a: T, b: T) -> ExpectedFound<T> {\n     if a_is_expected {\n         ExpectedFound { expected: a, found: b }\n     } else {"}, {"sha": "8cebd3679345f6e84afe5104eaa3edb6d4c0f34e", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n-            self.mir_def_id.to_def_id(),\n+            self.mir_def_id,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Err(err) = self.eq_opaque_type_and_type(\n                 mir_output_ty,\n                 user_provided_output_ty,\n-                self.mir_def_id.to_def_id(),\n+                self.mir_def_id,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "3532b6de003ba1d24054f8be92b02c48628354cd", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1144,7 +1144,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // When you have `let x: impl Foo = ...` in a closure,\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n-                let parent_def_id = self.tcx().closure_base_def_id(self.mir_def_id.to_def_id());\n+                let parent_def_id =\n+                    self.tcx().closure_base_def_id(self.mir_def_id.to_def_id()).expect_local();\n                 return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n@@ -1208,7 +1209,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n         anon_ty: Ty<'tcx>,\n-        anon_owner_def_id: DefId,\n+        anon_owner_def_id: LocalDefId,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n@@ -1238,8 +1239,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n-        let concrete_opaque_types =\n-            &tcx.typeck_tables_of(anon_owner_def_id.expect_local()).concrete_opaque_types;\n+        let concrete_opaque_types = &tcx.typeck_tables_of(anon_owner_def_id).concrete_opaque_types;\n         let mut opaque_type_values = Vec::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);"}, {"sha": "75067ffa4b338d64b73c627b8d98008325673d22", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -334,9 +334,9 @@ pub fn const_eval_raw_provider<'tcx>(\n                 }\n \n                 v\n-            } else if def_id.is_local() {\n+            } else if let Some(def_id) = def_id.as_local() {\n                 // constant defined in this crate, we can figure out a lint level!\n-                match tcx.def_kind(def_id) {\n+                match tcx.def_kind(def_id.to_def_id()) {\n                     // constants never produce a hard error at the definition site. Anything else is\n                     // a backwards compatibility hazard (and will break old versions of winapi for\n                     // sure)\n@@ -346,7 +346,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n                     DefKind::Const | DefKind::AssocConst => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id);\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def_id)),\n                             \"any use of this value will cause an error\",\n@@ -369,7 +369,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                                 err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id.expect_local()),\n+                                    tcx.hir().as_local_hir_id(def_id),\n                                     Some(err.span),\n                                 )\n                             }"}, {"sha": "81c1b0b5bd49f6443144776f06b11faa79ce72cc", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -22,7 +22,7 @@ pub mod validation;\n pub struct ConstCx<'mir, 'tcx> {\n     pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n-    pub def_id: DefId,\n+    pub def_id: LocalDefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<hir::ConstContext>,\n }\n@@ -40,7 +40,7 @@ impl ConstCx<'mir, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let const_kind = tcx.hir().body_const_context(def_id);\n-        ConstCx { body, tcx, def_id: def_id.to_def_id(), param_env, const_kind }\n+        ConstCx { body, tcx, def_id: def_id, param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.)."}, {"sha": "55075b3ab5e99912e8501ed42b88a82e4b07630f", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -29,13 +29,7 @@ pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<\n         return;\n     }\n \n-    let ccx = ConstCx {\n-        body,\n-        tcx,\n-        def_id: def_id.to_def_id(),\n-        const_kind,\n-        param_env: tcx.param_env(def_id),\n-    };\n+    let ccx = ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n \n     let mut visitor = CheckLiveDrops { ccx: &ccx, qualifs: Qualifs::default() };\n "}, {"sha": "3dddd9c1c1766cea6845b18c7de17dac227fdee9", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -126,7 +126,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n+        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id);\n         traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n     }\n "}, {"sha": "5cb161ebcfb5ea4ca8f3f62a642e4c13b1052780", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -56,7 +56,7 @@ impl Qualifs<'mir, 'tcx> {\n             // without breaking stable code?\n             MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n                 .unsound_ignore_borrow_on_drop()\n-                .into_engine(tcx, &body, def_id)\n+                .into_engine(tcx, &body, def_id.to_def_id())\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n         });\n@@ -83,7 +83,7 @@ impl Qualifs<'mir, 'tcx> {\n             let ConstCx { tcx, body, def_id, .. } = *ccx;\n \n             FlowSensitiveAnalysis::new(NeedsDrop, ccx)\n-                .into_engine(tcx, &body, def_id)\n+                .into_engine(tcx, &body, def_id.to_def_id())\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n         });\n@@ -110,7 +110,7 @@ impl Qualifs<'mir, 'tcx> {\n             let ConstCx { tcx, body, def_id, .. } = *ccx;\n \n             FlowSensitiveAnalysis::new(HasMutInterior, ccx)\n-                .into_engine(tcx, &body, def_id)\n+                .into_engine(tcx, &body, def_id.to_def_id())\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n         });\n@@ -153,7 +153,7 @@ impl Qualifs<'mir, 'tcx> {\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n-                    .into_engine(ccx.tcx, &ccx.body, ccx.def_id)\n+                    .into_engine(ccx.tcx, &ccx.body, ccx.def_id.to_def_id())\n                     .iterate_to_fixpoint()\n                     .into_results_cursor(&ccx.body);\n \n@@ -195,13 +195,13 @@ impl Validator<'mir, 'tcx> {\n         let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n         let use_min_const_fn_checks = (const_kind == Some(hir::ConstContext::ConstFn)\n-            && crate::const_eval::is_min_const_fn(tcx, def_id))\n+            && crate::const_eval::is_min_const_fn(tcx, def_id.to_def_id()))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n         if use_min_const_fn_checks {\n             // Enforce `min_const_fn` for stable `const fn`s.\n             use crate::transform::qualify_min_const_fn::is_min_const_fn;\n-            if let Err((span, err)) = is_min_const_fn(tcx, def_id, &body) {\n+            if let Err((span, err)) = is_min_const_fn(tcx, def_id.to_def_id(), &body) {\n                 error_min_const_fn_violation(tcx, span, err);\n                 return;\n             }\n@@ -212,10 +212,10 @@ impl Validator<'mir, 'tcx> {\n         // Ensure that the end result is `Sync` in a non-thread local `static`.\n         let should_check_for_sync = const_kind\n             == Some(hir::ConstContext::Static(hir::Mutability::Not))\n-            && !tcx.is_thread_local_static(def_id);\n+            && !tcx.is_thread_local_static(def_id.to_def_id());\n \n         if should_check_for_sync {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+            let hir_id = tcx.hir().as_local_hir_id(def_id);\n             check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }\n@@ -535,7 +535,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     // `#[allow_internal_unstable]`.\n                     use crate::transform::qualify_min_const_fn::lib_feature_allowed;\n                     if !self.span.allows_unstable(feature)\n-                        && !lib_feature_allowed(self.tcx, self.def_id, feature)\n+                        && !lib_feature_allowed(self.tcx, self.def_id.to_def_id(), feature)\n                     {\n                         self.check_op(ops::FnCallUnstable(def_id, feature));\n                     }"}, {"sha": "14c3093e1e9a11e784ad1ac75751673b99a7e31f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -203,7 +203,8 @@ pub fn run_passes(\n }\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let const_kind = tcx.hir().body_const_context(def_id.expect_local());\n+    let def_id = def_id.expect_local();\n+    let const_kind = tcx.hir().body_const_context(def_id);\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {\n@@ -214,7 +215,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal.\n-    let body = &tcx.mir_const(def_id).borrow();\n+    let body = &tcx.mir_const(def_id.to_def_id()).borrow();\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");"}, {"sha": "5aa67227994d918a1ac679cf6bee3394b4c65a5b", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -60,15 +60,16 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n             return;\n         }\n \n-        let def_id = src.def_id();\n+        let def_id = src.def_id().expect_local();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let ccx = ConstCx::new(tcx, def_id.expect_local(), body);\n+        let ccx = ConstCx::new(tcx, def_id, body);\n         let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n         let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n \n-        let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n+        let promoted =\n+            promote_candidates(def_id.to_def_id(), body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n     }\n }\n@@ -724,7 +725,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             ty::FnDef(def_id, _) => {\n                 is_const_fn(self.tcx, def_id)\n                     || is_unstable_const_fn(self.tcx, def_id).is_some()\n-                    || is_lang_panic_fn(self.tcx, self.def_id)\n+                    || is_lang_panic_fn(self.tcx, self.def_id.to_def_id())\n             }\n             _ => false,\n         };"}, {"sha": "372cb783f503f7c7b16c5cd7cb2b61450da86f50", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -276,6 +276,7 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::Idx;\n \n use super::{compare_const_vals, PatternFoldable, PatternFolder};\n@@ -1246,15 +1247,15 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-crate enum Usefulness<'tcx, 'p> {\n+crate enum Usefulness<'tcx> {\n     /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n-    Useful(Vec<&'p Pat<'tcx>>),\n+    Useful(Vec<Span>),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n }\n \n-impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n+impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n@@ -1269,7 +1270,7 @@ impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n         }\n     }\n \n-    fn apply_constructor(\n+    fn apply_constructor<'p>(\n         self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n@@ -1828,7 +1829,7 @@ crate fn is_useful<'p, 'tcx>(\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness<'tcx, 'p> {\n+) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n@@ -1852,16 +1853,35 @@ crate fn is_useful<'p, 'tcx>(\n         // We need to push the already-seen patterns into the matrix in order to detect redundant\n         // branches like `Some(_) | Some(0)`. We also keep track of the unreachable subpatterns.\n         let mut matrix = matrix.clone();\n-        let mut unreachable_pats = Vec::new();\n+        // `Vec` of all the unreachable branches of the current or-pattern.\n+        let mut unreachable_branches = Vec::new();\n+        // Subpatterns that are unreachable from all branches. E.g. in the following case, the last\n+        // `true` is unreachable only from one branch, so it is overall reachable.\n+        // ```\n+        // match (true, true) {\n+        //     (true, true) => {}\n+        //     (false | true, false | true) => {}\n+        // }\n+        // ```\n+        let mut unreachable_subpats = FxHashSet::default();\n+        // Whether any branch at all is useful.\n         let mut any_is_useful = false;\n+\n         for v in vs {\n             let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             match res {\n                 Useful(pats) => {\n-                    any_is_useful = true;\n-                    unreachable_pats.extend(pats);\n+                    if !any_is_useful {\n+                        any_is_useful = true;\n+                        // Initialize with the first set of unreachable subpatterns encountered.\n+                        unreachable_subpats = pats.into_iter().collect();\n+                    } else {\n+                        // Keep the patterns unreachable from both this and previous branches.\n+                        unreachable_subpats =\n+                            pats.into_iter().filter(|p| unreachable_subpats.contains(p)).collect();\n+                    }\n                 }\n-                NotUseful => unreachable_pats.push(v.head()),\n+                NotUseful => unreachable_branches.push(v.head().span),\n                 UsefulWithWitness(_) => {\n                     bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n                 }\n@@ -1871,7 +1891,13 @@ crate fn is_useful<'p, 'tcx>(\n                 matrix.push(v);\n             }\n         }\n-        return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n+        if any_is_useful {\n+            // Collect all the unreachable patterns.\n+            unreachable_branches.extend(unreachable_subpats);\n+            return Useful(unreachable_branches);\n+        } else {\n+            return NotUseful;\n+        }\n     }\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n@@ -2014,7 +2040,7 @@ fn is_useful_specialized<'p, 'tcx>(\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n     is_under_guard: bool,\n-) -> Usefulness<'tcx, 'p> {\n+) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, ty);\n \n     // We cache the result of `Fields::wildcards` because it is used a lot."}, {"sha": "2ae20f551be414defa7aa5be8eee6fe60a0e98bb", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::config::nightly_options;\n use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n use rustc_session::parse::feature_err;\n@@ -392,8 +393,8 @@ fn check_arms<'p, 'tcx>(\n                 }\n             }\n             Useful(unreachable_subpatterns) => {\n-                for pat in unreachable_subpatterns {\n-                    unreachable_pattern(cx.tcx, pat.span, id, None);\n+                for span in unreachable_subpatterns {\n+                    unreachable_pattern(cx.tcx, span, id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n@@ -487,9 +488,27 @@ fn check_exhaustive<'p, 'tcx>(\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n-         possibly by adding wildcards or more match arms\",\n+              possibly by adding wildcards or more match arms\",\n     );\n     err.note(&format!(\"the matched value is of type `{}`\", scrut_ty));\n+    if (scrut_ty == cx.tcx.types.usize || scrut_ty == cx.tcx.types.isize)\n+        && !is_empty_match\n+        && witnesses.len() == 1\n+        && witnesses[0].is_wildcard()\n+    {\n+        err.note(&format!(\n+            \"`{}` does not have a fixed maximum value, \\\n+                so a wildcard `_` is necessary to match exhaustively\",\n+            scrut_ty,\n+        ));\n+        if nightly_options::is_nightly_build() {\n+            err.help(&format!(\n+                \"add `#![feature(precise_pointer_size_matching)]` \\\n+                    to the crate attributes to enable precise `{}` matching\",\n+                scrut_ty,\n+            ));\n+        }\n+    }\n     err.emit();\n }\n "}, {"sha": "92afb7dab88c39c17f17ea4fccd8285fbacca5dd", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -152,10 +152,14 @@ symbols! {\n         arm_target_feature,\n         asm,\n         assert,\n+        assert_inhabited,\n+        assert_uninit_valid,\n+        assert_zero_valid,\n         associated_consts,\n         associated_type_bounds,\n         associated_type_defaults,\n         associated_types,\n+        assume,\n         assume_init,\n         async_await,\n         async_closure,\n@@ -181,11 +185,14 @@ symbols! {\n         box_patterns,\n         box_syntax,\n         braced_empty_structs,\n+        breakpoint,\n         bswap,\n         bitreverse,\n         C,\n         caller_location,\n         cdylib,\n+        ceilf32,\n+        ceilf64,\n         cfg,\n         cfg_accessible,\n         cfg_attr,\n@@ -239,8 +246,14 @@ symbols! {\n         convert,\n         Copy,\n         copy_closures,\n+        copy,\n+        copy_nonoverlapping,\n+        copysignf32,\n+        copysignf64,\n         core,\n         core_intrinsics,\n+        cosf32,\n+        cosf64,\n         count_code_region,\n         coverage_counter_add,\n         coverage_counter_subtract,\n@@ -299,6 +312,7 @@ symbols! {\n         dropck_eyepatch,\n         dropck_parametricity,\n         drop_types_in_const,\n+        drop_in_place,\n         dylib,\n         dyn_trait,\n         eh_personality,\n@@ -311,11 +325,16 @@ symbols! {\n         Eq,\n         Equal,\n         enclosing_scope,\n+        exact_div,\n         except,\n         exclusive_range_pattern,\n         exhaustive_integer_patterns,\n         exhaustive_patterns,\n         existential_type,\n+        expf32,\n+        expf64,\n+        exp2f32,\n+        exp2f64,\n         expected,\n         export_name,\n         expr,\n@@ -329,20 +348,32 @@ symbols! {\n         f16c_target_feature,\n         f32,\n         f64,\n+        fadd_fast,\n+        fabsf32,\n+        fabsf64,\n+        fdiv_fast,\n         feature,\n         ffi_const,\n         ffi_pure,\n         ffi_returns_twice,\n         field,\n         field_init_shorthand,\n         file,\n+        float_to_int_unchecked,\n+        floorf64,\n+        floorf32,\n+        fmaf32,\n+        fmaf64,\n         fmt,\n         fmt_internals,\n+        fmul_fast,\n         fn_must_use,\n         forbid,\n+        forget,\n         format_args,\n         format_args_nl,\n         format_args_capture,\n+        frem_fast,\n         from,\n         From,\n         from_desugaring,\n@@ -352,6 +383,7 @@ symbols! {\n         from_ok,\n         from_usize,\n         from_trait,\n+        fsub_fast,\n         fundamental,\n         future,\n         Future,\n@@ -427,6 +459,7 @@ symbols! {\n         label_break_value,\n         lang,\n         lang_items,\n+        lazy_normalization_consts,\n         lateout,\n         let_chains,\n         lhs,\n@@ -448,6 +481,12 @@ symbols! {\n         llvm_asm,\n         local_inner_macros,\n         log_syntax,\n+        logf32,\n+        logf64,\n+        log10f32,\n+        log10f64,\n+        log2f32,\n+        log2f64,\n         loop_break_value,\n         macro_at_most_once_rep,\n         macro_escape,\n@@ -475,10 +514,16 @@ symbols! {\n         message,\n         meta,\n         min_align_of,\n+        min_align_of_val,\n         min_const_fn,\n         min_const_unsafe_fn,\n         min_specialization,\n+        minnumf32,\n+        minnumf64,\n+        maxnumf32,\n+        maxnumf64,\n         mips_target_feature,\n+        miri_start_panic,\n         mmx_target_feature,\n         module,\n         module_path,\n@@ -491,6 +536,8 @@ symbols! {\n         naked,\n         naked_functions,\n         name,\n+        nearbyintf32,\n+        nearbyintf64,\n         needs_allocator,\n         needs_drop,\n         needs_panic_runtime,\n@@ -518,6 +565,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        nontemporal_store,\n         nontrapping_fptoint: \"nontrapping-fptoint\",\n         noreturn,\n         no_niche,\n@@ -577,8 +625,16 @@ symbols! {\n         poll,\n         Poll,\n         powerpc_target_feature,\n+        powf32,\n+        powf64,\n+        powif32,\n+        powif64,\n         precise_pointer_size_matching,\n         pref_align_of,\n+        prefetch_read_data,\n+        prefetch_read_instruction,\n+        prefetch_write_data,\n+        prefetch_write_instruction,\n         prelude,\n         prelude_import,\n         preserves_flags,\n@@ -640,10 +696,14 @@ symbols! {\n         Result,\n         Return,\n         rhs,\n+        rintf32,\n+        rintf64,\n         riscv_target_feature,\n         rlib,\n         rotate_left,\n         rotate_right,\n+        roundf32,\n+        roundf64,\n         rt,\n         rtm_target_feature,\n         rust,\n@@ -726,14 +786,19 @@ symbols! {\n         simd_ffi,\n         simd_insert,\n         since,\n+        sinf32,\n+        sinf64,\n         size,\n         size_of,\n+        size_of_val,\n         slice_patterns,\n         slicing_syntax,\n         soft,\n         Some,\n         specialization,\n         speed,\n+        sqrtf32,\n+        sqrtf64,\n         sse4a_target_feature,\n         stable,\n         staged_api,\n@@ -787,6 +852,8 @@ symbols! {\n         transparent_enums,\n         transparent_unions,\n         trivial_bounds,\n+        truncf32,\n+        truncf64,\n         Try,\n         try_blocks,\n         try_trait,\n@@ -809,6 +876,8 @@ symbols! {\n         u32,\n         u64,\n         u8,\n+        unaligned_volatile_load,\n+        unaligned_volatile_store,\n         unboxed_closures,\n         unchecked_add,\n         unchecked_div,\n@@ -824,6 +893,7 @@ symbols! {\n         universal_impl_trait,\n         unlikely,\n         unmarked_api,\n+        unreachable,\n         unreachable_code,\n         unrestricted_attribute_tokens,\n         unsafe_block_in_unsafe_fn,\n@@ -843,12 +913,21 @@ symbols! {\n         val,\n         var,\n         variant_count,\n+        va_arg,\n+        va_copy,\n+        va_end,\n+        va_start,\n         vec,\n         Vec,\n         version,\n         vis,\n         visible_private_types,\n         volatile,\n+        volatile_copy_memory,\n+        volatile_copy_nonoverlapping_memory,\n+        volatile_load,\n+        volatile_set_memory,\n+        volatile_store,\n         warn,\n         wasm_import_module,\n         wasm_target_feature,\n@@ -858,6 +937,7 @@ symbols! {\n         wrapping_add,\n         wrapping_sub,\n         wrapping_mul,\n+        write_bytes,\n         Yield,\n     }\n }"}, {"sha": "b60531833bd41ae997956f33e7f72a938cb4d4e2", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -108,7 +108,7 @@ pub enum GenerateMemberConstraints {\n pub trait InferCtxtExt<'tcx> {\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_def_id: DefId,\n+        parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `value_span` -- the span where the value came from, used in error reporting\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_def_id: DefId,\n+        parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n@@ -986,7 +986,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n struct Instantiator<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    parent_def_id: DefId,\n+    parent_def_id: LocalDefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     value_span: Span,\n@@ -1043,8 +1043,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id\n-                                == tcx.hir().local_def_id(opaque_parent_hir_id).to_def_id()\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.kind {\n@@ -1053,18 +1052,14 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n-                                }) => (parent == self.parent_def_id, origin),\n+                                }) => (parent == self.parent_def_id.to_def_id(), origin),\n                                 // Named `type Foo = impl Bar;`\n                                 hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: None,\n                                     origin,\n                                     ..\n                                 }) => (\n-                                    may_define_opaque_type(\n-                                        tcx,\n-                                        self.parent_def_id.expect_local(),\n-                                        opaque_hir_id,\n-                                    ),\n+                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n                                     origin,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::Misc),"}, {"sha": "9b3b4a67650a2ab74918a25a8b42ebce711d9697", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 149, "deletions": 114, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -5,25 +5,25 @@ use crate::require_same_types;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n use std::iter;\n \n fn equate_intrinsic_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     it: &hir::ForeignItem<'_>,\n+    def_id: DefId,\n     n_tps: usize,\n     abi: Abi,\n     safety: hir::Unsafety,\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n ) {\n-    let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n     match it.kind {\n         hir::ForeignItemKind::Fn(..) => {}\n         _ => {\n@@ -67,15 +67,43 @@ fn equate_intrinsic_type<'tcx>(\n }\n \n /// Returns `true` if the given intrinsic is unsafe to call or not.\n-pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n+pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n     match intrinsic {\n-        \"abort\" | \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" | \"size_of_val\"\n-        | \"min_align_of_val\" | \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\"\n-        | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"saturating_add\"\n-        | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n-        | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n-        | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n-        | \"maxnumf64\" | \"type_name\" | \"variant_count\" => hir::Unsafety::Normal,\n+        sym::abort\n+        | sym::size_of\n+        | sym::min_align_of\n+        | sym::needs_drop\n+        | sym::caller_location\n+        | sym::size_of_val\n+        | sym::min_align_of_val\n+        | sym::add_with_overflow\n+        | sym::sub_with_overflow\n+        | sym::mul_with_overflow\n+        | sym::wrapping_add\n+        | sym::wrapping_sub\n+        | sym::wrapping_mul\n+        | sym::saturating_add\n+        | sym::saturating_sub\n+        | sym::rotate_left\n+        | sym::rotate_right\n+        | sym::ctpop\n+        | sym::ctlz\n+        | sym::cttz\n+        | sym::bswap\n+        | sym::bitreverse\n+        | sym::discriminant_value\n+        | sym::type_id\n+        | sym::likely\n+        | sym::unlikely\n+        | sym::ptr_guaranteed_eq\n+        | sym::ptr_guaranteed_ne\n+        | sym::minnumf32\n+        | sym::minnumf64\n+        | sym::maxnumf32\n+        | sym::rustc_peek\n+        | sym::maxnumf64\n+        | sym::type_name\n+        | sym::variant_count => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -84,7 +112,9 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let name = it.ident.as_str();\n+    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n+    let intrinsic_name = tcx.item_name(def_id);\n+    let name_str = intrinsic_name.as_str();\n \n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n@@ -98,8 +128,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         })\n     };\n \n-    let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n-        let split: Vec<&str> = name.split('_').collect();\n+    let (n_tps, inputs, output, unsafety) = if name_str.starts_with(\"atomic_\") {\n+        let split: Vec<&str> = name_str.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n \n         //We only care about the operation here\n@@ -129,53 +159,51 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n         };\n         (n_tps, inputs, output, hir::Unsafety::Unsafe)\n-    } else if &name[..] == \"abort\" {\n-        (0, Vec::new(), tcx.types.never, hir::Unsafety::Normal)\n-    } else if &name[..] == \"unreachable\" {\n-        (0, Vec::new(), tcx.types.never, hir::Unsafety::Unsafe)\n     } else {\n-        let unsafety = intrinsic_operation_unsafety(&name[..]);\n-        let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), tcx.mk_unit()),\n-            \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"variant_count\" => {\n+        let unsafety = intrinsic_operation_unsafety(intrinsic_name);\n+        let (n_tps, inputs, output) = match intrinsic_name {\n+            sym::abort => (0, Vec::new(), tcx.types.never),\n+            sym::unreachable => (0, Vec::new(), tcx.types.never),\n+            sym::breakpoint => (0, Vec::new(), tcx.mk_unit()),\n+            sym::size_of | sym::pref_align_of | sym::min_align_of | sym::variant_count => {\n                 (1, Vec::new(), tcx.types.usize)\n             }\n-            \"size_of_val\" | \"min_align_of_val\" => {\n+            sym::size_of_val | sym::min_align_of_val => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], tcx.types.usize)\n             }\n-            \"rustc_peek\" => (1, vec![param(0)], param(0)),\n-            \"caller_location\" => (0, vec![], tcx.caller_location_ty()),\n-            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n+            sym::rustc_peek => (1, vec![param(0)], param(0)),\n+            sym::caller_location => (0, vec![], tcx.caller_location_ty()),\n+            sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n                 (1, Vec::new(), tcx.mk_unit())\n             }\n-            \"forget\" => (1, vec![param(0)], tcx.mk_unit()),\n-            \"transmute\" => (2, vec![param(0)], param(1)),\n-            \"move_val_init\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n-            \"prefetch_read_data\"\n-            | \"prefetch_write_data\"\n-            | \"prefetch_read_instruction\"\n-            | \"prefetch_write_instruction\" => (\n+            sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n+            sym::transmute => (2, vec![param(0)], param(1)),\n+            sym::move_val_init => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n+            sym::prefetch_read_data\n+            | sym::prefetch_write_data\n+            | sym::prefetch_read_instruction\n+            | sym::prefetch_write_instruction => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n                     tcx.types.i32,\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"drop_in_place\" => (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_unit()),\n-            \"needs_drop\" => (1, Vec::new(), tcx.types.bool),\n+            sym::drop_in_place => (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_unit()),\n+            sym::needs_drop => (1, Vec::new(), tcx.types.bool),\n \n-            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), tcx.types.u64),\n-            \"offset\" | \"arith_offset\" => (\n+            sym::type_name => (1, Vec::new(), tcx.mk_static_str()),\n+            sym::type_id => (1, Vec::new(), tcx.types.u64),\n+            sym::offset | sym::arith_offset => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n                     tcx.types.isize,\n                 ],\n                 tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n             ),\n-            \"copy\" | \"copy_nonoverlapping\" => (\n+            sym::copy | sym::copy_nonoverlapping => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n@@ -184,7 +212,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => (\n+            sym::volatile_copy_memory | sym::volatile_copy_nonoverlapping_memory => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Mut }),\n@@ -193,7 +221,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"write_bytes\" | \"volatile_set_memory\" => (\n+            sym::write_bytes | sym::volatile_set_memory => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Mut }),\n@@ -202,93 +230,98 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"sqrtf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"sqrtf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"powif32\" => (0, vec![tcx.types.f32, tcx.types.i32], tcx.types.f32),\n-            \"powif64\" => (0, vec![tcx.types.f64, tcx.types.i32], tcx.types.f64),\n-            \"sinf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"sinf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"cosf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"cosf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"powf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"powf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"expf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"expf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"exp2f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"exp2f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"logf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"logf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"log10f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"log10f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"log2f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"log2f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"fmaf32\" => (0, vec![tcx.types.f32, tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"fmaf64\" => (0, vec![tcx.types.f64, tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"fabsf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"fabsf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"minnumf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"minnumf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"maxnumf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"maxnumf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"copysignf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"copysignf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"floorf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"floorf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"ceilf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"ceilf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"truncf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"truncf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"rintf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"rintf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"nearbyintf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"nearbyintf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"roundf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"roundf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-\n-            \"volatile_load\" | \"unaligned_volatile_load\" => {\n+            sym::sqrtf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::sqrtf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::powif32 => (0, vec![tcx.types.f32, tcx.types.i32], tcx.types.f32),\n+            sym::powif64 => (0, vec![tcx.types.f64, tcx.types.i32], tcx.types.f64),\n+            sym::sinf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::sinf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::cosf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::cosf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::powf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::powf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::expf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::expf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::exp2f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::exp2f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::logf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::logf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::log10f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::log10f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::log2f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::log2f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::fmaf32 => (0, vec![tcx.types.f32, tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::fmaf64 => (0, vec![tcx.types.f64, tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::fabsf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::fabsf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::minnumf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::minnumf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::maxnumf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::maxnumf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::copysignf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::copysignf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::floorf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::floorf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::ceilf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::ceilf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::truncf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::truncf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::rintf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::rintf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::nearbyintf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::nearbyintf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::roundf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::roundf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+\n+            sym::volatile_load | sym::unaligned_volatile_load => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], param(0))\n             }\n-            \"volatile_store\" | \"unaligned_volatile_store\" => {\n+            sym::volatile_store | sym::unaligned_volatile_store => {\n                 (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit())\n             }\n \n-            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"bswap\"\n-            | \"bitreverse\" => (1, vec![param(0)], param(0)),\n+            sym::ctpop\n+            | sym::ctlz\n+            | sym::ctlz_nonzero\n+            | sym::cttz\n+            | sym::cttz_nonzero\n+            | sym::bswap\n+            | sym::bitreverse => (1, vec![param(0)], param(0)),\n \n-            \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n+            sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n-            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n             }\n \n-            \"ptr_offset_from\" => {\n+            sym::ptr_offset_from => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.isize)\n             }\n-            \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" => {\n+            sym::unchecked_div | sym::unchecked_rem | sym::exact_div => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"unchecked_shl\" | \"unchecked_shr\" | \"rotate_left\" | \"rotate_right\" => {\n+            sym::unchecked_shl | sym::unchecked_shr | sym::rotate_left | sym::rotate_right => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" => {\n+            sym::unchecked_add | sym::unchecked_sub | sym::unchecked_mul => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" => {\n+            sym::wrapping_add | sym::wrapping_sub | sym::wrapping_mul => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"saturating_add\" | \"saturating_sub\" => (1, vec![param(0), param(0)], param(0)),\n-            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n+            sym::saturating_add | sym::saturating_sub => (1, vec![param(0), param(0)], param(0)),\n+            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"float_to_int_unchecked\" => (2, vec![param(0)], param(1)),\n+            sym::float_to_int_unchecked => (2, vec![param(0)], param(1)),\n \n-            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_unit()),\n-            \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n-            \"unlikely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n+            sym::assume => (0, vec![tcx.types.bool], tcx.mk_unit()),\n+            sym::likely => (0, vec![tcx.types.bool], tcx.types.bool),\n+            sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n-            \"discriminant_value\" => {\n+            sym::discriminant_value => {\n                 let assoc_items =\n                     tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n                 let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n@@ -303,7 +336,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 )\n             }\n \n-            \"try\" => {\n+            kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n                 let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n@@ -326,51 +359,51 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 )\n             }\n \n-            \"va_start\" | \"va_end\" => match mk_va_list_ty(hir::Mutability::Mut) {\n+            sym::va_start | sym::va_end => match mk_va_list_ty(hir::Mutability::Mut) {\n                 Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"va_copy\" => match mk_va_list_ty(hir::Mutability::Not) {\n+            sym::va_copy => match mk_va_list_ty(hir::Mutability::Not) {\n                 Some((va_list_ref_ty, va_list_ty)) => {\n                     let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n                     (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n                 }\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"va_arg\" => match mk_va_list_ty(hir::Mutability::Mut) {\n+            sym::va_arg => match mk_va_list_ty(hir::Mutability::Mut) {\n                 Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"nontemporal_store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n+            sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n-            \"miri_start_panic\" => {\n+            sym::miri_start_panic => {\n                 // FIXME - the relevant types aren't lang items,\n                 // so it's not trivial to check this\n                 return;\n             }\n \n-            \"count_code_region\" => {\n+            sym::count_code_region => {\n                 (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n             }\n \n-            \"coverage_counter_add\" | \"coverage_counter_subtract\" => (\n+            sym::coverage_counter_add | sym::coverage_counter_subtract => (\n                 0,\n                 vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n                 tcx.mk_unit(),\n             ),\n \n-            \"coverage_unreachable\" => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n+            sym::coverage_unreachable => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n \n-            ref other => {\n+            other => {\n                 struct_span_err!(\n                     tcx.sess,\n                     it.span,\n                     E0093,\n                     \"unrecognized intrinsic function: `{}`\",\n-                    *other\n+                    other,\n                 )\n                 .span_label(it.span, \"unrecognized intrinsic\")\n                 .emit();\n@@ -379,7 +412,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         };\n         (n_tps, inputs, output, unsafety)\n     };\n-    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n+    equate_intrinsic_type(tcx, it, def_id, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -389,6 +422,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         tcx.mk_ty_param(n, name)\n     };\n \n+    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n     let name = it.ident.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -463,6 +497,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n     equate_intrinsic_type(\n         tcx,\n         it,\n+        def_id,\n         n_tps,\n         Abi::PlatformIntrinsic,\n         hir::Unsafety::Unsafe,"}, {"sha": "e564b01b11721e65b70d811a8dc098e2df40335c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1321,8 +1321,8 @@ fn check_fn<'a, 'tcx>(\n         fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n     }\n \n-    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id());\n-    let outer_hir_id = hir.as_local_hir_id(outer_def_id.expect_local());\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id()).expect_local();\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id);\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n@@ -3427,7 +3427,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (value, opaque_type_map) =\n             self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-                parent_def_id.to_def_id(),\n+                parent_def_id,\n                 self.body_id,\n                 self.param_env,\n                 value,"}, {"sha": "cc491c527db0b99c23f7d9372ad42b999fe69326", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -2063,7 +2063,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     ident: Ident,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n-        intrinsic_operation_unsafety(&tcx.item_name(def_id).as_str())\n+        intrinsic_operation_unsafety(tcx.item_name(def_id))\n     } else {\n         hir::Unsafety::Unsafe\n     };"}, {"sha": "048ed18c927bfa25e9a03b76cef939ac5c80f99d", "filename": "src/test/ui/const-generics/issue-71986.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71986.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "previous_filename": "src/test/ui/const-generics/lazy-normalization/issue-71986.rs"}, {"sha": "c7a63e5d50252cc02765ee334de9ee95e727c203", "filename": "src/test/ui/feature-gates/feature-gate-precise_pointer_size_matching.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -6,6 +6,8 @@ LL |     match 0usize {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n+   = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n+   = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/feature-gate-precise_pointer_size_matching.rs:10:11\n@@ -15,6 +17,8 @@ LL |     match 0isize {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n+   = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n+   = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error: aborting due to 2 previous errors\n "}, {"sha": "51a991bef5959d1e410a121af060343ecba72528", "filename": "src/test/ui/issues/auxiliary/reexported-trait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Freexported-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Freexported-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Freexported-trait.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,17 @@\n+mod private {\n+    pub trait Trait {\n+        fn trait_method(&self) {\n+        }\n+    }\n+    pub trait TraitB {\n+        fn trait_method_b(&self) {\n+        }\n+    }\n+}\n+\n+pub struct FooStruct;\n+pub use crate::private::Trait;\n+impl crate::private::Trait for FooStruct {}\n+\n+pub use crate::private::TraitB as TraitBRename;\n+impl crate::private::TraitB for FooStruct {}"}, {"sha": "ca1d0d4310ae9f39015ce91d8f0338bc7ad2af01", "filename": "src/test/ui/issues/issue-56175.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fissue-56175.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fissue-56175.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56175.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+// aux-crate:reexported_trait=reexported-trait.rs\n+\n+fn main() {\n+    reexported_trait::FooStruct.trait_method();\n+    //~^ ERROR\n+    reexported_trait::FooStruct.trait_method_b();\n+    //~^ ERROR\n+}"}, {"sha": "c0799db7c1286f28a3c22d3b40b2c4afa404c8b4", "filename": "src/test/ui/issues/issue-56175.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fissue-56175.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fissues%2Fissue-56175.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56175.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `trait_method` found for struct `reexported_trait::FooStruct` in the current scope\n+  --> $DIR/issue-56175.rs:5:33\n+   |\n+LL |     reexported_trait::FooStruct.trait_method();\n+   |                                 ^^^^^^^^^^^^ method not found in `reexported_trait::FooStruct`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use reexported_trait::Trait;\n+   |\n+\n+error[E0599]: no method named `trait_method_b` found for struct `reexported_trait::FooStruct` in the current scope\n+  --> $DIR/issue-56175.rs:7:33\n+   |\n+LL |     reexported_trait::FooStruct.trait_method_b();\n+   |                                 ^^^^^^^^^^^^^^ method not found in `reexported_trait::FooStruct`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use reexported_trait::TraitBRename;\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "44cb74815c6a04555c3a091281fd04275e7383ce", "filename": "src/test/ui/lazy_normalization_consts/feature-gate-lazy_normalization_consts.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,10 @@\n+pub const fn sof<T>() -> usize {\n+    10\n+}\n+\n+fn test<T>() {\n+    let _: [u8; sof::<T>()];\n+    //~^ ERROR the size for values of type `T`\n+}\n+\n+fn main() {}"}, {"sha": "6e19251c72800067151d91e803dfde45f56d515a", "filename": "src/test/ui/lazy_normalization_consts/feature-gate-lazy_normalization_consts.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ffeature-gate-lazy_normalization_consts.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the size for values of type `T` cannot be known at compilation time\n+  --> $DIR/feature-gate-lazy_normalization_consts.rs:6:23\n+   |\n+LL | pub const fn sof<T>() -> usize {\n+   |                  - required by this bound in `sof`\n+...\n+LL | fn test<T>() {\n+   |         - this type parameter needs to be `std::marker::Sized`\n+LL |     let _: [u8; sof::<T>()];\n+   |                       ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | pub const fn sof<T: ?Sized>() -> usize {\n+   |                   ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1fd0c45841b0d212dd195272e79887570c1f86df", "filename": "src/test/ui/lazy_normalization_consts/issue-47814.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-47814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-47814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-47814.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+#![feature(lazy_normalization_consts)]\n+#![allow(incomplete_features)]\n+pub struct ArpIPv4<'a> {\n+    _s: &'a u8\n+}\n+\n+impl<'a> ArpIPv4<'a> {\n+    const LENGTH: usize = 20;\n+\n+    pub fn to_buffer() -> [u8; Self::LENGTH] {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4607f3e99b51fd122aacfcb4390435215c10f991", "filename": "src/test/ui/lazy_normalization_consts/issue-57739.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,17 @@\n+#![feature(lazy_normalization_consts)]\n+//~^ WARN the feature `lazy_normalization_consts` is incomplete\n+trait ArraySizeTrait {\n+    const SIZE: usize = 0;\n+}\n+\n+impl<T: ?Sized> ArraySizeTrait for T {\n+    const SIZE: usize = 1;\n+}\n+\n+struct SomeArray<T: ArraySizeTrait> {\n+    array: [u8; T::SIZE],\n+    //~^ ERROR constant expression depends on a generic parameter\n+    phantom: std::marker::PhantomData<T>,\n+}\n+\n+fn main() {}"}, {"sha": "1987f5890c0411a700faf4bd8ff4921887e9bca0", "filename": "src/test/ui/lazy_normalization_consts/issue-57739.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-57739.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `lazy_normalization_consts` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-57739.rs:1:12\n+   |\n+LL | #![feature(lazy_normalization_consts)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #72219 <https://github.com/rust-lang/rust/issues/72219> for more information\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-57739.rs:12:5\n+   |\n+LL |     array: [u8; T::SIZE],\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "339b22c0b423d7ce4d7be33c10e1ba30a3a0f790", "filename": "src/test/ui/lazy_normalization_consts/issue-73980.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-73980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-73980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Fissue-73980.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+#![feature(lazy_normalization_consts)]\n+#![allow(incomplete_features)]\n+\n+pub struct X<P, Q>(P, Q);\n+pub struct L<T: ?Sized>(T);\n+\n+impl<T: ?Sized> L<T> {\n+    const S: usize = 1;\n+}\n+\n+impl<T> X<T, [u8; L::<T>::S]> {}\n+\n+fn main() {}"}, {"sha": "30460824a167890b98c57512d5c0f02770e4603e", "filename": "src/test/ui/mir-dataflow/def-inits-1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -11,13 +11,13 @@ struct S(i32);\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;\n     // `ret` starts off uninitialized\n-    unsafe { rustc_peek(&ret); }  //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&ret);  //~ ERROR rustc_peek: bit not set\n \n     // All function formal parameters start off initialized.\n \n-    unsafe { rustc_peek(&x) };\n-    unsafe { rustc_peek(&y) };\n-    unsafe { rustc_peek(&z) };\n+    rustc_peek(&x);\n+    rustc_peek(&y);\n+    rustc_peek(&z);\n \n     ret = if test {\n         ::std::mem::replace(x, y)\n@@ -27,21 +27,21 @@ fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     };\n \n     // `z` may be uninitialized here.\n-    unsafe { rustc_peek(&z); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&z); //~ ERROR rustc_peek: bit not set\n \n     // `y` is definitely uninitialized here.\n-    unsafe { rustc_peek(&y); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&y); //~ ERROR rustc_peek: bit not set\n \n     // `x` is still (definitely) initialized (replace above is a reborrow).\n-    unsafe { rustc_peek(&x); }\n+    rustc_peek(&x);\n \n     ::std::mem::drop(x);\n \n     // `x` is *definitely* uninitialized here\n-    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&x); //~ ERROR rustc_peek: bit not set\n \n     // `ret` is now definitely initialized (via `if` above).\n-    unsafe { rustc_peek(&ret); }\n+    rustc_peek(&ret);\n \n     ret\n }"}, {"sha": "e2bddb54d9ba86154215bada94fb1e89c5e5b480", "filename": "src/test/ui/mir-dataflow/def-inits-1.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fdef-inits-1.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,26 +1,26 @@\n error: rustc_peek: bit not set\n-  --> $DIR/def-inits-1.rs:14:14\n+  --> $DIR/def-inits-1.rs:14:5\n    |\n-LL |     unsafe { rustc_peek(&ret); }\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     rustc_peek(&ret);\n+   |     ^^^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/def-inits-1.rs:30:14\n+  --> $DIR/def-inits-1.rs:30:5\n    |\n-LL |     unsafe { rustc_peek(&z); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&z);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/def-inits-1.rs:33:14\n+  --> $DIR/def-inits-1.rs:33:5\n    |\n-LL |     unsafe { rustc_peek(&y); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&y);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/def-inits-1.rs:41:14\n+  --> $DIR/def-inits-1.rs:41:5\n    |\n-LL |     unsafe { rustc_peek(&x); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&x);\n+   |     ^^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "374a9f75a134b68036aadf51d1d86d8beece9480", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -38,7 +38,7 @@ const BOO: i32 = {\n \n     *rmut_cell = 42;  // Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!\n     let val = *rmut_cell;\n-    unsafe { rustc_peek(x) }; //~ ERROR rustc_peek: bit not set\n+    rustc_peek(x); //~ ERROR rustc_peek: bit not set\n \n     val\n };"}, {"sha": "1d5287c15ab7994983d160f6764fa9b3872b5ab7", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,8 +1,8 @@\n error: rustc_peek: bit not set\n-  --> $DIR/indirect-mutation-offset.rs:41:14\n+  --> $DIR/indirect-mutation-offset.rs:41:5\n    |\n-LL |     unsafe { rustc_peek(x) };\n-   |              ^^^^^^^^^^^^^\n+LL |     rustc_peek(x);\n+   |     ^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "8fb1d4bc736d6be6d4e368d710aca46633b899da", "filename": "src/test/ui/mir-dataflow/inits-1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -11,13 +11,13 @@ struct S(i32);\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;\n     // `ret` starts off uninitialized, so we get an error report here.\n-    unsafe { rustc_peek(&ret); }  //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&ret);  //~ ERROR rustc_peek: bit not set\n \n     // All function formal parameters start off initialized.\n \n-    unsafe { rustc_peek(&x) };\n-    unsafe { rustc_peek(&y) };\n-    unsafe { rustc_peek(&z) };\n+    rustc_peek(&x);\n+    rustc_peek(&y);\n+    rustc_peek(&z);\n \n     ret = if test {\n         ::std::mem::replace(x, y)\n@@ -28,21 +28,21 @@ fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n \n \n     // `z` may be initialized here.\n-    unsafe { rustc_peek(&z); }\n+    rustc_peek(&z);\n \n     // `y` is definitely uninitialized here.\n-    unsafe { rustc_peek(&y); }  //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&y);  //~ ERROR rustc_peek: bit not set\n \n     // `x` is still (definitely) initialized (replace above is a reborrow).\n-    unsafe { rustc_peek(&x); }\n+    rustc_peek(&x);\n \n     ::std::mem::drop(x);\n \n     // `x` is *definitely* uninitialized here\n-    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&x); //~ ERROR rustc_peek: bit not set\n \n     // `ret` is now definitely initialized (via `if` above).\n-    unsafe { rustc_peek(&ret); }\n+    rustc_peek(&ret);\n \n     ret\n }"}, {"sha": "7a00a70af6f84f95b06f8ac1ce166a5f1a536c44", "filename": "src/test/ui/mir-dataflow/inits-1.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Finits-1.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,20 +1,20 @@\n error: rustc_peek: bit not set\n-  --> $DIR/inits-1.rs:14:14\n+  --> $DIR/inits-1.rs:14:5\n    |\n-LL |     unsafe { rustc_peek(&ret); }\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     rustc_peek(&ret);\n+   |     ^^^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/inits-1.rs:34:14\n+  --> $DIR/inits-1.rs:34:5\n    |\n-LL |     unsafe { rustc_peek(&y); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&y);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/inits-1.rs:42:14\n+  --> $DIR/inits-1.rs:42:5\n    |\n-LL |     unsafe { rustc_peek(&x); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&x);\n+   |     ^^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "786da523a339177d6d895108ed361483051fca80", "filename": "src/test/ui/mir-dataflow/liveness-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -10,17 +10,17 @@ fn foo() -> i32 {\n     x = 0;\n \n     // `x` is live here since it is used in the next statement...\n-    unsafe { rustc_peek(x); }\n+    rustc_peek(x);\n \n     p = &x;\n \n     // ... but not here, even while it can be accessed through `p`.\n-    unsafe { rustc_peek(x); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(x); //~ ERROR rustc_peek: bit not set\n     let tmp = unsafe { *p };\n \n     x = tmp + 1;\n \n-    unsafe { rustc_peek(x); }\n+    rustc_peek(x);\n \n     x\n }"}, {"sha": "858cdbac3d312362864fad917cc328c70badf642", "filename": "src/test/ui/mir-dataflow/liveness-ptr.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,8 +1,8 @@\n error: rustc_peek: bit not set\n-  --> $DIR/liveness-ptr.rs:18:14\n+  --> $DIR/liveness-ptr.rs:18:5\n    |\n-LL |     unsafe { rustc_peek(x); }\n-   |              ^^^^^^^^^^^^^\n+LL |     rustc_peek(x);\n+   |     ^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "c2b4284a7b4f8b83aefb9115bac6df58aadd2293", "filename": "src/test/ui/mir-dataflow/uninits-1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -11,13 +11,13 @@ struct S(i32);\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;\n     // `ret` starts off uninitialized\n-    unsafe { rustc_peek(&ret); }\n+    rustc_peek(&ret);\n \n     // All function formal parameters start off initialized.\n \n-    unsafe { rustc_peek(&x) }; //~ ERROR rustc_peek: bit not set\n-    unsafe { rustc_peek(&y) }; //~ ERROR rustc_peek: bit not set\n-    unsafe { rustc_peek(&z) }; //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&x); //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&y); //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&z); //~ ERROR rustc_peek: bit not set\n \n     ret = if test {\n         ::std::mem::replace(x, y)\n@@ -27,21 +27,21 @@ fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     };\n \n     // `z` may be uninitialized here.\n-    unsafe { rustc_peek(&z); }\n+    rustc_peek(&z);\n \n     // `y` is definitely uninitialized here.\n-    unsafe { rustc_peek(&y); }\n+    rustc_peek(&y);\n \n     // `x` is still (definitely) initialized (replace above is a reborrow).\n-    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&x); //~ ERROR rustc_peek: bit not set\n \n     ::std::mem::drop(x);\n \n     // `x` is *definitely* uninitialized here\n-    unsafe { rustc_peek(&x); }\n+    rustc_peek(&x);\n \n     // `ret` is now definitely initialized (via `if` above).\n-    unsafe { rustc_peek(&ret); } //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&ret); //~ ERROR rustc_peek: bit not set\n \n     ret\n }"}, {"sha": "c52f5ac7bd9b66b83af1906b3523d4aa95ded5be", "filename": "src/test/ui/mir-dataflow/uninits-1.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-1.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,32 +1,32 @@\n error: rustc_peek: bit not set\n-  --> $DIR/uninits-1.rs:18:14\n+  --> $DIR/uninits-1.rs:18:5\n    |\n-LL |     unsafe { rustc_peek(&x) };\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&x);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/uninits-1.rs:19:14\n+  --> $DIR/uninits-1.rs:19:5\n    |\n-LL |     unsafe { rustc_peek(&y) };\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&y);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/uninits-1.rs:20:14\n+  --> $DIR/uninits-1.rs:20:5\n    |\n-LL |     unsafe { rustc_peek(&z) };\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&z);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/uninits-1.rs:36:14\n+  --> $DIR/uninits-1.rs:36:5\n    |\n-LL |     unsafe { rustc_peek(&x); }\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&x);\n+   |     ^^^^^^^^^^^^^^\n \n error: rustc_peek: bit not set\n-  --> $DIR/uninits-1.rs:44:14\n+  --> $DIR/uninits-1.rs:44:5\n    |\n-LL |     unsafe { rustc_peek(&ret); }\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     rustc_peek(&ret);\n+   |     ^^^^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "c584ee74afb48418348996301a1097b27d105ebc", "filename": "src/test/ui/mir-dataflow/uninits-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -11,12 +11,12 @@ struct S(i32);\n fn foo(x: &mut S) {\n     // `x` is initialized here, so maybe-uninit bit is 0.\n \n-    unsafe { rustc_peek(&x) }; //~ ERROR rustc_peek: bit not set\n+    rustc_peek(&x); //~ ERROR rustc_peek: bit not set\n \n     ::std::mem::drop(x);\n \n     // `x` definitely uninitialized here, so maybe-uninit bit is 1.\n-    unsafe { rustc_peek(&x) };\n+    rustc_peek(&x);\n }\n fn main() {\n     foo(&mut S(13));"}, {"sha": "0ef954e35a4d807fa4814805d1e745342aa5572f", "filename": "src/test/ui/mir-dataflow/uninits-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Funinits-2.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -1,8 +1,8 @@\n error: rustc_peek: bit not set\n-  --> $DIR/uninits-2.rs:14:14\n+  --> $DIR/uninits-2.rs:14:5\n    |\n-LL |     unsafe { rustc_peek(&x) };\n-   |              ^^^^^^^^^^^^^^\n+LL |     rustc_peek(&x);\n+   |     ^^^^^^^^^^^^^^\n \n error: stop_after_dataflow ended compilation\n "}, {"sha": "a1147cb5cfc9c4d567b85c419e351b0db7cdb3b9", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -29,6 +29,9 @@ fn main() {\n         (1, 4 | 5) => {} //~ ERROR unreachable pattern\n         _ => {}\n     }\n+    match (true, true) {\n+        (false | true, false | true) => (),\n+    }\n     match (Some(0u8),) {\n         (None | Some(1 | 2),) => {}\n         (Some(1),) => {} //~ ERROR unreachable pattern\n@@ -67,4 +70,29 @@ fn main() {\n              | 1) => {}\n         _ => {}\n     }\n+\n+    // A subpattern that is only unreachable in one branch is overall reachable.\n+    match (true, true) {\n+        (true, true) => {}\n+        (false | true, false | true) => {}\n+    }\n+    match (true, true) {\n+        (true, false) => {}\n+        (false, true) => {}\n+        (false | true, false | true) => {}\n+    }\n+    // A subpattern that is unreachable in all branches is overall unreachable.\n+    match (true, true) {\n+        (false, true) => {}\n+        (true, true) => {}\n+        (false | true, false\n+            | true) => {} //~ ERROR unreachable\n+    }\n+    match (true, true) {\n+        (true, false) => {}\n+        (true, true) => {}\n+        (false\n+            | true, //~ ERROR unreachable\n+            false | true) => {}\n+    }\n }"}, {"sha": "d92b545a8694f8332488d1ab9c46822474f423aa", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -53,52 +53,64 @@ LL |         (1, 4 | 5) => {}\n    |         ^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:34:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:37:9\n    |\n LL |         (Some(1),) => {}\n    |         ^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:35:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:38:9\n    |\n LL |         (None,) => {}\n    |         ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:40:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:43:9\n    |\n LL |         ((1..=4,),) => {}\n    |         ^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:45:14\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:48:14\n    |\n LL |         (1 | 1,) => {}\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:52:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:53:15\n    |\n-LL |             | 0] => {}\n+LL |             | 0\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:50:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:55:15\n    |\n-LL |             | 0\n+LL |             | 0] => {}\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:60:10\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:63:10\n    |\n LL |         [1\n    |          ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:66:14\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:69:14\n    |\n LL |         Some(0\n    |              ^\n \n-error: aborting due to 16 previous errors\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:89:15\n+   |\n+LL |             | true) => {}\n+   |               ^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:95:15\n+   |\n+LL |             | true,\n+   |               ^^^^\n+\n+error: aborting due to 18 previous errors\n "}, {"sha": "067e617373a630c6a494418bdb185afdcd036bde", "filename": "src/test/ui/or-patterns/search-via-bindings.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -3,7 +3,6 @@\n // run-pass\n \n #![feature(or_patterns)]\n-#![allow(unreachable_patterns)] // FIXME(or-patterns) this shouldn't trigger\n \n fn search(target: (bool, bool, bool)) -> u32 {\n     let x = ((false, true), (false, true), (false, true));"}, {"sha": "0c52876e21f9519b370765f838445936d98bbec0", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-pointer-size-int.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.rs?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,23 @@\n+use std::{usize, isize};\n+\n+fn main() {\n+    match 0usize {\n+        //~^ ERROR non-exhaustive patterns\n+        //~| NOTE pattern `_` not covered\n+        //~| NOTE the matched value is of type `usize`\n+        //~| NOTE `usize` does not have a fixed maximum value\n+        0 ..= usize::MAX => {}\n+    }\n+\n+    match 0isize {\n+        //~^ ERROR non-exhaustive patterns\n+        //~| NOTE pattern `_` not covered\n+        //~| NOTE the matched value is of type `isize`\n+        //~| NOTE `isize` does not have a fixed maximum value\n+        isize::MIN ..= isize::MAX => {}\n+    }\n+\n+    match 7usize {}\n+    //~^ ERROR non-exhaustive patterns\n+    //~| NOTE the matched value is of type `usize`\n+}"}, {"sha": "d0aa452fd386176ea93435fe1fee7fdbd51fb4de", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-pointer-size-int.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c03aee8b81185d65b5821518661c30ecdb42de5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-pointer-size-int.stderr?ref=0c03aee8b81185d65b5821518661c30ecdb42de5", "patch": "@@ -0,0 +1,34 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/non-exhaustive-pattern-pointer-size-int.rs:4:11\n+   |\n+LL |     match 0usize {\n+   |           ^^^^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `usize`\n+   = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n+   = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/non-exhaustive-pattern-pointer-size-int.rs:12:11\n+   |\n+LL |     match 0isize {\n+   |           ^^^^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `isize`\n+   = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n+   = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+\n+error[E0004]: non-exhaustive patterns: type `usize` is non-empty\n+  --> $DIR/non-exhaustive-pattern-pointer-size-int.rs:20:11\n+   |\n+LL |     match 7usize {}\n+   |           ^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `usize`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}]}