{"sha": "1d5b758bab979b1db723bcc97ecd8398127bd8bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNWI3NThiYWI5NzliMWRiNzIzYmNjOTdlY2Q4Mzk4MTI3YmQ4YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-14T19:28:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-14T19:28:48Z"}, "message": "Auto merge of #35409 - eddyb:mir-storage-stmts, r=nikomatsakis\n\n[MIR] Add Storage{Live,Dead} statements to emit llvm.lifetime.{start,end}.\n\nStorage live ranges are tracked for all MIR variables and temporaries with a drop scope.\n`StorageLive` is lowered to `llvm.lifetime.start` and `StorageDead` to `llvm.lifetime.end`.\n\nThere are some improvements possible here, such as:\n* pack multiple storage liveness statements by using the index of first local + `u64` bitset\n* enforce that locals are not directly accessed outside their storage live range\n* shrink storage live ranges for never-borrowed locals to initialization -> last use\n* emit storage liveness statements for *all* temporaries\n * however, the remaining ones are *always* SSA immediates, so they'd be noop in MIR trans\n * could have a flag on the temporary that its storage is irrelevant (a la C's old `register`)\n   * would also deny borrows if necessary\n    * this seems like an overcompliation and with packing & optimizations it may be pointless\n\nEven in the current state, it helps stage2 `rustc` compile `boiler` without overflowing (see #35408).\n\nA later addition fixes #26764 and closes #27372 by emitting `.section` directives for dylib metadata to avoid them being allocated into memory or read as `.note`. For this PR, those bugs were tripping valgrind.", "tree": {"sha": "3375e24d086cd3d3927471388e8ade7fbf4f9666", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3375e24d086cd3d3927471388e8ade7fbf4f9666"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d5b758bab979b1db723bcc97ecd8398127bd8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5b758bab979b1db723bcc97ecd8398127bd8bc", "html_url": "https://github.com/rust-lang/rust/commit/1d5b758bab979b1db723bcc97ecd8398127bd8bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d5b758bab979b1db723bcc97ecd8398127bd8bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92ae4ceb6c6563b983a046f5f273cc13247eb4b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/92ae4ceb6c6563b983a046f5f273cc13247eb4b1", "html_url": "https://github.com/rust-lang/rust/commit/92ae4ceb6c6563b983a046f5f273cc13247eb4b1"}, {"sha": "1bb14445160329c2ca5ff9c202e791ca0098d944", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb14445160329c2ca5ff9c202e791ca0098d944", "html_url": "https://github.com/rust-lang/rust/commit/1bb14445160329c2ca5ff9c202e791ca0098d944"}], "stats": {"total": 472, "additions": 387, "deletions": 85}, "files": [{"sha": "454c1ff816753cbcbc955048cd111e504891318c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -688,15 +688,26 @@ pub struct Statement<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n+    /// Write the RHS Rvalue to the LHS Lvalue.\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n-    SetDiscriminant{ lvalue: Lvalue<'tcx>, variant_index: usize },\n+\n+    /// Write the discriminant for a variant to the enum Lvalue.\n+    SetDiscriminant { lvalue: Lvalue<'tcx>, variant_index: usize },\n+\n+    /// Start a live range for the storage of the local.\n+    StorageLive(Lvalue<'tcx>),\n+\n+    /// End the current live range for the storage of the local.\n+    StorageDead(Lvalue<'tcx>),\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n+            StorageLive(ref lv) => write!(fmt, \"StorageLive({:?})\", lv),\n+            StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n             }"}, {"sha": "d3526f618a904e142675f76838412ce1ed6523ea", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -326,6 +326,12 @@ macro_rules! make_mir_visitor {\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n                         self.visit_lvalue(lvalue, LvalueContext::Store);\n                     }\n+                    StatementKind::StorageLive(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::StorageLive);\n+                    }\n+                    StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::StorageDead);\n+                    }\n                 }\n             }\n \n@@ -759,4 +765,8 @@ pub enum LvalueContext {\n \n     // Consumed as part of an operand\n     Consume,\n+\n+    // Starting and ending a storage live range\n+    StorageLive,\n+    StorageDead,\n }"}, {"sha": "90858e4e8b8be2c4c717dfe91873d0d34a033a31", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -459,6 +459,8 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                          sets.kill_set.add(&moi);\n                                      });\n             }\n+            repr::StatementKind::StorageLive(_) |\n+            repr::StatementKind::StorageDead(_) => {}\n         }\n     }\n "}, {"sha": "9a4865755e799b6f15f38bb69c0c213ad8752fa5", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -104,6 +104,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 (lvalue, rvalue)\n             }\n+            repr::StatementKind::StorageLive(_) |\n+            repr::StatementKind::StorageDead(_) => continue,\n             repr::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,\n                           \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),"}, {"sha": "d2ef3356afb9d69973c508ecb2924bca70b7ea7a", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -616,6 +616,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                         Rvalue::InlineAsm { .. } => {}\n                     }\n                 }\n+                StatementKind::StorageLive(_) |\n+                StatementKind::StorageDead(_) => {}\n                 StatementKind::SetDiscriminant{ .. } => {\n                     span_bug!(stmt.source_info.span,\n                               \"SetDiscriminant should not exist during borrowck\");"}, {"sha": "dbee0ea9b00e97a870f41cb8b03b0da233d9878f", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -378,6 +378,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                                      move_data.rev_lookup.find(lvalue),\n                                      |moi| callback(moi, DropFlagState::Present))\n             }\n+            repr::StatementKind::StorageLive(_) |\n+            repr::StatementKind::StorageDead(_) => {}\n         },\n         None => {\n             debug!(\"drop_flag_effects: replace {:?}\", block.terminator());"}, {"sha": "cf1dd71a0a12acbc8477f37438d67647dd135f13", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -867,34 +867,29 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n }\n \n pub fn meta_section_name(target: &Target) -> &'static str {\n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, that's another good question...\n+\n     if target.options.is_like_osx {\n-        \"__DATA,__note.rustc\"\n-    } else if target.options.is_like_msvc {\n-        // When using link.exe it was seen that the section name `.note.rustc`\n-        // was getting shortened to `.note.ru`, and according to the PE and COFF\n-        // specification:\n-        //\n-        // > Executable images do not use a string table and do not support\n-        // > section names longer than 8\u00a0characters\n-        //\n-        // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n-        //\n-        // As a result, we choose a slightly shorter name! As to why\n-        // `.note.rustc` works on MinGW, that's another good question...\n-        \".rustc\"\n+        \"__DATA,.rustc\"\n     } else {\n-        \".note.rustc\"\n+        \".rustc\"\n     }\n }\n \n-pub fn read_meta_section_name(target: &Target) -> &'static str {\n-    if target.options.is_like_osx {\n-        \"__note.rustc\"\n-    } else if target.options.is_like_msvc {\n-        \".rustc\"\n-    } else {\n-        \".note.rustc\"\n-    }\n+pub fn read_meta_section_name(_target: &Target) -> &'static str {\n+    \".rustc\"\n }\n \n // A diagnostic function for dumping crate metadata to an output stream"}, {"sha": "34d7973264631deffab395f945e98761f5909a73", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -68,6 +68,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 // FIXME #30046                              ^~~~\n                                 this.expr_into_pattern(block, pattern, init)\n                             }));\n+                        } else {\n+                            this.storage_live_for_bindings(block, &pattern);\n                         }\n \n                         // Enter the visibility scope, after evaluating the initializer."}, {"sha": "85128cbbbafef0e8c6d743f2fb6858b7db4e6e85", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -37,6 +37,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let temp = this.temp(expr_ty.clone());\n         let temp_lifetime = expr.temp_lifetime;\n         let expr_span = expr.span;\n+        let source_info = this.source_info(expr_span);\n+\n+        if temp_lifetime.is_some() {\n+            this.cfg.push(block, Statement {\n+                source_info: source_info,\n+                kind: StatementKind::StorageLive(temp.clone())\n+            });\n+        }\n \n         // Careful here not to cause an infinite cycle. If we always\n         // called `into`, then for lvalues like `x.f`, it would\n@@ -49,7 +57,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Lvalue => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n-                let source_info = this.source_info(expr_span);\n                 this.cfg.push_assign(block, source_info, &temp, rvalue);\n             }\n             _ => {"}, {"sha": "ec390704d078976df454152ab796dba0a014fbfe", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -122,6 +122,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n+                self.storage_live_for_bindings(block, &irrefutable_pat);\n                 let lvalue = Lvalue::Var(self.var_indices[&var]);\n                 return self.into(&lvalue, block, initializer);\n             }\n@@ -206,6 +207,43 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         var_scope\n     }\n+\n+    /// Emit `StorageLive` for every binding in the pattern.\n+    pub fn storage_live_for_bindings(&mut self,\n+                                     block: BasicBlock,\n+                                     pattern: &Pattern<'tcx>) {\n+        match *pattern.kind {\n+            PatternKind::Binding { var, ref subpattern, .. } => {\n+                let lvalue = Lvalue::Var(self.var_indices[&var]);\n+                let source_info = self.source_info(pattern.span);\n+                self.cfg.push(block, Statement {\n+                    source_info: source_info,\n+                    kind: StatementKind::StorageLive(lvalue)\n+                });\n+\n+                if let Some(subpattern) = subpattern.as_ref() {\n+                    self.storage_live_for_bindings(block, subpattern);\n+                }\n+            }\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n+                    self.storage_live_for_bindings(block, subpattern);\n+                }\n+            }\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n+                self.storage_live_for_bindings(block, subpattern);\n+            }\n+            PatternKind::Leaf { ref subpatterns } |\n+            PatternKind::Variant { ref subpatterns, .. } => {\n+                for subpattern in subpatterns {\n+                    self.storage_live_for_bindings(block, &subpattern.pattern);\n+                }\n+            }\n+        }\n+    }\n }\n \n /// List of blocks for each arm (and potentially other metadata in the\n@@ -665,6 +703,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             };\n \n             let source_info = self.source_info(binding.span);\n+            self.cfg.push(block, Statement {\n+                source_info: source_info,\n+                kind: StatementKind::StorageLive(Lvalue::Var(var_index))\n+            });\n             self.cfg.push_assign(block, source_info,\n                                  &Lvalue::Var(var_index), rvalue);\n         }"}, {"sha": "814d56f44ac30430b4a63035824b807b6c60a537", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -238,7 +238,8 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span);\n \n-    let extent = ROOT_CODE_EXTENT;\n+    let extent = tcx.region_maps.temporary_scope(ast_expr.id)\n+                    .unwrap_or(ROOT_CODE_EXTENT);\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);"}, {"sha": "cae9e8379897c5311e44a183d1049bf3bf595d37", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 105, "deletions": 33, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -107,6 +107,17 @@ pub struct Scope<'tcx> {\n     /// `ScopeAuxiliary`, but kept here for convenience\n     extent: CodeExtent,\n \n+    /// Whether there's anything to do for the cleanup path, that is,\n+    /// when unwinding through this scope. This includes destructors,\n+    /// but not StorageDead statements, which don't get emitted at all\n+    /// for unwinding, for several reasons:\n+    ///  * clang doesn't emit llvm.lifetime.end for C++ unwinding\n+    ///  * LLVM's memory dependency analysis can't handle it atm\n+    ///  * pollutting the cleanup MIR with StorageDead creates\n+    ///    landing pads even though there's no actual destructors\n+    ///  * freeing up stack space has no effect during unwinding\n+    needs_cleanup: bool,\n+\n     /// set of lvalues to drop when exiting this scope. This starts\n     /// out empty but grows as variables are declared during the\n     /// building process. This is a stack, so we always drop from the\n@@ -139,11 +150,19 @@ struct DropData<'tcx> {\n     /// lvalue to drop\n     location: Lvalue<'tcx>,\n \n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains code to run the current drop and all the preceding\n-    /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n-    /// array)\n-    cached_block: Option<BasicBlock>\n+    /// Whether this is a full value Drop, or just a StorageDead.\n+    kind: DropKind\n+}\n+\n+enum DropKind {\n+    Value {\n+        /// The cached block for the cleanups-on-diverge path. This block\n+        /// contains code to run the current drop and all the preceding\n+        /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n+        /// array)\n+        cached_block: Option<BasicBlock>\n+    },\n+    Storage\n }\n \n struct FreeData<'tcx> {\n@@ -182,7 +201,9 @@ impl<'tcx> Scope<'tcx> {\n     fn invalidate_cache(&mut self) {\n         self.cached_exits = FnvHashMap();\n         for dropdata in &mut self.drops {\n-            dropdata.cached_block = None;\n+            if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+                *cached_block = None;\n+            }\n         }\n         if let Some(ref mut freedata) = self.free {\n             freedata.cached_block = None;\n@@ -194,8 +215,14 @@ impl<'tcx> Scope<'tcx> {\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n     fn cached_block(&self) -> Option<BasicBlock> {\n-        if let Some(data) = self.drops.last() {\n-            Some(data.cached_block.expect(\"drop cache is not filled\"))\n+        let mut drops = self.drops.iter().rev().filter_map(|data| {\n+            match data.kind {\n+                DropKind::Value { cached_block } => Some(cached_block),\n+                DropKind::Storage => None\n+            }\n+        });\n+        if let Some(cached_block) = drops.next() {\n+            Some(cached_block.expect(\"drop cache is not filled\"))\n         } else if let Some(ref data) = self.free {\n             Some(data.cached_block.expect(\"free cache is not filled\"))\n         } else {\n@@ -265,6 +292,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             id: id,\n             visibility_scope: vis_scope,\n             extent: extent,\n+            needs_cleanup: false,\n             drops: vec![],\n             free: None,\n             cached_exits: FnvHashMap()\n@@ -415,23 +443,37 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                          extent: CodeExtent,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n-        if !self.hir.needs_drop(lvalue_ty) {\n-            return\n-        }\n+        let needs_drop = self.hir.needs_drop(lvalue_ty);\n+        let drop_kind = if needs_drop {\n+            DropKind::Value { cached_block: None }\n+        } else {\n+            // Only temps and vars need their storage dead.\n+            match *lvalue {\n+                Lvalue::Temp(_) | Lvalue::Var(_) => DropKind::Storage,\n+                _ => return\n+            }\n+        };\n+\n         for scope in self.scopes.iter_mut().rev() {\n             if scope.extent == extent {\n+                if let DropKind::Value { .. } = drop_kind {\n+                    scope.needs_cleanup = true;\n+                }\n+\n                 // No need to invalidate any caches here. The just-scheduled drop will branch into\n                 // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n                     span: span,\n                     location: lvalue.clone(),\n-                    cached_block: None\n+                    kind: drop_kind\n                 });\n                 return;\n             } else {\n                 // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n                 // looking for, because all of the blocks in the chain will become incorrect.\n-                scope.invalidate_cache()\n+                if let DropKind::Value { .. } = drop_kind {\n+                    scope.invalidate_cache()\n+                }\n             }\n         }\n         span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n@@ -453,6 +495,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // We also must invalidate the caches in the scope for which the free is scheduled\n                 // because the drops must branch into the free we schedule here.\n                 scope.invalidate_cache();\n+                scope.needs_cleanup = true;\n                 scope.free = Some(FreeData {\n                     span: span,\n                     value: value.clone(),\n@@ -478,10 +521,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n     pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n-        if self.scopes.iter().all(|scope| scope.drops.is_empty() && scope.free.is_none()) {\n+        if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n             return None;\n         }\n-        assert!(!self.scopes.is_empty()); // or `all` above would be true\n+        assert!(!self.scopes.is_empty()); // or `any` above would be false\n \n         let unit_temp = self.get_unit_temp();\n         let Builder { ref mut hir, ref mut cfg, ref mut scopes,\n@@ -510,7 +553,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             resumeblk\n         };\n \n-        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n+        for scope in scopes.iter_mut().filter(|s| s.needs_cleanup) {\n             target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n         Some(target)\n@@ -591,21 +634,44 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            -> BlockAnd<()> {\n     let mut iter = scope.drops.iter().rev().peekable();\n     while let Some(drop_data) = iter.next() {\n-        // Try to find the next block with its cached block for us to diverge into in case the\n-        // drop panics.\n-        let on_diverge = iter.peek().iter().flat_map(|dd| dd.cached_block.into_iter()).next();\n-        // If there\u2019s no `cached_block`s within current scope, we must look for one in the\n-        // enclosing scope.\n-        let on_diverge = on_diverge.or_else(||{\n-            earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n-        });\n-        let next = cfg.start_new_block();\n-        cfg.terminate(block, scope.source_info(drop_data.span), TerminatorKind::Drop {\n-            location: drop_data.location.clone(),\n-            target: next,\n-            unwind: on_diverge\n-        });\n-        block = next;\n+        let source_info = scope.source_info(drop_data.span);\n+        if let DropKind::Value { .. } = drop_data.kind {\n+            // Try to find the next block with its cached block\n+            // for us to diverge into in case the drop panics.\n+            let on_diverge = iter.peek().iter().filter_map(|dd| {\n+                match dd.kind {\n+                    DropKind::Value { cached_block } => cached_block,\n+                    DropKind::Storage => None\n+                }\n+            }).next();\n+            // If there\u2019s no `cached_block`s within current scope,\n+            // we must look for one in the enclosing scope.\n+            let on_diverge = on_diverge.or_else(||{\n+                earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n+            });\n+            let next = cfg.start_new_block();\n+            cfg.terminate(block, source_info, TerminatorKind::Drop {\n+                location: drop_data.location.clone(),\n+                target: next,\n+                unwind: on_diverge\n+            });\n+            block = next;\n+        }\n+        match drop_data.kind {\n+            DropKind::Value { .. } |\n+            DropKind::Storage => {\n+                // Only temps and vars need their storage dead.\n+                match drop_data.location {\n+                    Lvalue::Temp(_) | Lvalue::Var(_) => {}\n+                    _ => continue\n+                }\n+\n+                cfg.push(block, Statement {\n+                    source_info: source_info,\n+                    kind: StatementKind::StorageDead(drop_data.location.clone())\n+                });\n+            }\n+        }\n     }\n     block.unit()\n }\n@@ -653,7 +719,13 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n     for drop_data in &mut scope.drops {\n-        target = if let Some(cached_block) = drop_data.cached_block {\n+        // Only full value drops are emitted in the diverging path,\n+        // not StorageDead.\n+        let cached_block = match drop_data.kind {\n+            DropKind::Value { ref mut cached_block } => cached_block,\n+            DropKind::Storage => continue\n+        };\n+        target = if let Some(cached_block) = *cached_block {\n             cached_block\n         } else {\n             let block = cfg.start_new_cleanup_block();\n@@ -663,7 +735,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               target: target,\n                               unwind: None\n                           });\n-            drop_data.cached_block = Some(block);\n+            *cached_block = Some(block);\n             block\n         };\n     }"}, {"sha": "cb3010a5cf43deb07290b41c0ff1ed5b1d2e589f", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -50,8 +50,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n             let orig_stmt = bb.statements.pop().unwrap();\n             let (lhs, rhs) = match orig_stmt.kind {\n                 StatementKind::Assign(ref lhs, ref rhs) => (lhs, rhs),\n-                StatementKind::SetDiscriminant{ .. } =>\n-                    span_bug!(src_info.span, \"expected aggregate, not {:?}\", orig_stmt.kind),\n+                _ => span_bug!(src_info.span, \"expected assign, not {:?}\", orig_stmt),\n             };\n             let (agg_kind, operands) = match rhs {\n                 &Rvalue::Aggregate(ref agg_kind, ref operands) => (agg_kind, operands),\n@@ -114,7 +113,7 @@ fn get_aggregate_statement_index<'a, 'tcx, 'b>(start: usize,\n         let ref statement = statements[i];\n         let rhs = match statement.kind {\n             StatementKind::Assign(_, ref rhs) => rhs,\n-            StatementKind::SetDiscriminant{ .. } => continue,\n+            _ => continue,\n         };\n         let (kind, operands) = match rhs {\n             &Rvalue::Aggregate(ref kind, ref operands) => (kind, operands),"}, {"sha": "17dd85abd64e371a9fe0289ac668f09e7e51989a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -87,8 +87,12 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n         if let Lvalue::Temp(index) = *lvalue {\n             // Ignore drops, if the temp gets promoted,\n             // then it's constant and thus drop is noop.\n-            if let LvalueContext::Drop = context {\n-                return;\n+            // Storage live ranges are also irrelevant.\n+            match context {\n+                LvalueContext::Drop |\n+                LvalueContext::StorageLive |\n+                LvalueContext::StorageDead => return,\n+                _ => {}\n             }\n \n             let temp = &mut self.temps[index];\n@@ -219,12 +223,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let (mut rvalue, mut call) = (None, None);\n         let source_info = if stmt_idx < no_stmts {\n             let statement = &mut self.source[bb].statements[stmt_idx];\n-            let mut rhs = match statement.kind {\n+            let rhs = match statement.kind {\n                 StatementKind::Assign(_, ref mut rhs) => rhs,\n-                StatementKind::SetDiscriminant{ .. } =>\n-                    span_bug!(statement.source_info.span,\n-                              \"cannot promote SetDiscriminant {:?}\",\n-                              statement),\n+                _ => {\n+                    span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                              statement);\n+                }\n             };\n             if self.keep_original {\n                 rvalue = Some(rhs.clone());\n@@ -311,11 +315,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     StatementKind::Assign(_, ref mut rvalue) => {\n                         mem::replace(rvalue, Rvalue::Use(new_operand))\n                     }\n-                    StatementKind::SetDiscriminant{ .. } => {\n-                        span_bug!(statement.source_info.span,\n-                                  \"cannot promote SetDiscriminant {:?}\",\n-                                  statement);\n-                    }\n+                    _ => bug!()\n                 }\n             }\n             Candidate::ShuffleIndices(bb) => {\n@@ -354,8 +354,10 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 let statement = &mir[bb].statements[stmt_idx];\n                 let dest = match statement.kind {\n                     StatementKind::Assign(ref dest, _) => dest,\n-                    StatementKind::SetDiscriminant{ .. } =>\n-                        panic!(\"cannot promote SetDiscriminant\"),\n+                    _ => {\n+                        span_bug!(statement.source_info.span,\n+                                  \"expected assignment to promote\");\n+                    }\n                 };\n                 if let Lvalue::Temp(index) = *dest {\n                     if temps[index] == TempState::PromotedOut {\n@@ -408,7 +410,9 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Lvalue::Temp(index), _) => {\n+                StatementKind::Assign(Lvalue::Temp(index), _) |\n+                StatementKind::StorageLive(Lvalue::Temp(index)) |\n+                StatementKind::StorageDead(Lvalue::Temp(index)) => {\n                     !promoted(index)\n                 }\n                 _ => true"}, {"sha": "87a10f1bb5bfc749fe808975fa699fb60d882d48", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -854,7 +854,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.nest(|this| this.super_statement(bb, statement));\n+        self.nest(|this| {\n+            this.visit_source_info(&statement.source_info);\n+            match statement.kind {\n+                StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                    this.visit_assign(bb, lvalue, rvalue);\n+                }\n+                StatementKind::SetDiscriminant { .. } |\n+                StatementKind::StorageLive(_) |\n+                StatementKind::StorageDead(_) => {}\n+            }\n+        });\n         self.location.statement_index += 1;\n     }\n "}, {"sha": "79e31167f2f7f5b542bb35b8623b8aed9986701a", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -382,6 +382,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                variant_index);\n                 };\n             }\n+            StatementKind::StorageLive(ref lv) |\n+            StatementKind::StorageDead(ref lv) => {\n+                match *lv {\n+                    Lvalue::Temp(_) | Lvalue::Var(_) => {}\n+                    _ => {\n+                        span_mirbug!(self, stmt, \"bad lvalue: expected temp or var\");\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "df893842337c47a36ff4ab851ea951d550737420", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -2250,10 +2250,17 @@ fn write_metadata(cx: &SharedCrateContext,\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name =\n+        let section_name =\n             cx.tcx().sess.cstore.metadata_section_name(&cx.sess().target.target);\n-        let name = CString::new(name).unwrap();\n-        llvm::LLVMSetSection(llglobal, name.as_ptr())\n+        let name = CString::new(section_name).unwrap();\n+        llvm::LLVMSetSection(llglobal, name.as_ptr());\n+\n+        // Also generate a .section directive to force no\n+        // flags, at least for ELF outputs, so that the\n+        // metadata doesn't get loaded into memory.\n+        let directive = format!(\".section {}\", section_name);\n+        let directive = CString::new(directive).unwrap();\n+        llvm::LLVMSetModuleInlineAsm(cx.metadata_llmod(), directive.as_ptr())\n     }\n     return metadata;\n }"}, {"sha": "de5581af2912d2edda55462de68b85f8d4ab6026", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -161,15 +161,19 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 LvalueContext::Call => {\n                     self.mark_assigned(index);\n                 }\n-                LvalueContext::Consume => {\n-                }\n+\n+                LvalueContext::StorageLive |\n+                LvalueContext::StorageDead |\n+                LvalueContext::Consume => {}\n+\n                 LvalueContext::Store |\n                 LvalueContext::Inspect |\n                 LvalueContext::Borrow { .. } |\n                 LvalueContext::Slice { .. } |\n                 LvalueContext::Projection => {\n                     self.mark_as_lvalue(index);\n                 }\n+\n                 LvalueContext::Drop => {\n                     let ty = lvalue.ty(self.mir, self.bcx.tcx());\n                     let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));"}, {"sha": "31fee560fe36925bde7073a40f0c7d14338dbe02", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -285,6 +285,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n                     }\n+                    mir::StatementKind::StorageLive(_) |\n+                    mir::StatementKind::StorageDead(_) => {}\n                     mir::StatementKind::SetDiscriminant{ .. } => {\n                         span_bug!(span, \"SetDiscriminant should not appear in constants?\");\n                     }"}, {"sha": "1167208955368d3a4bc58752e154eb022db69293", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::mir::repr as mir;\n \n+use base;\n use common::{self, BlockAndBuilder};\n \n use super::MirContext;\n@@ -71,6 +72,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 );\n                 bcx\n             }\n+            mir::StatementKind::StorageLive(ref lvalue) => {\n+                self.trans_storage_liveness(bcx, lvalue, base::Lifetime::Start)\n+            }\n+            mir::StatementKind::StorageDead(ref lvalue) => {\n+                self.trans_storage_liveness(bcx, lvalue, base::Lifetime::End)\n+            }\n+        }\n+    }\n+\n+    fn trans_storage_liveness(&self,\n+                              bcx: BlockAndBuilder<'bcx, 'tcx>,\n+                              lvalue: &mir::Lvalue<'tcx>,\n+                              intrinsic: base::Lifetime)\n+                              -> BlockAndBuilder<'bcx, 'tcx> {\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n+                intrinsic.call(&bcx, tr_lval.llval);\n+            }\n         }\n+        bcx\n     }\n }"}, {"sha": "cf91e7a8bcb660772fd955e6b5cef2a21db8efab", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+#[rustc_mir] // FIXME #27840 MIR has different codegen.\n+pub fn test() {\n+    let a = 0;\n+    &a; // keep variable in an alloca\n+\n+// CHECK: [[S_a:%[0-9]+]] = bitcast i32* %a to i8*\n+// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_a]])\n+\n+    {\n+        let b = &Some(a);\n+        &b; // keep variable in an alloca\n+\n+// CHECK: [[S_b:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"** %b to i8*\n+// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_b]])\n+\n+// CHECK: [[S_tmp2:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %tmp2 to i8*\n+// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_tmp2]])\n+\n+// CHECK: [[E_tmp2:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %tmp2 to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_tmp2]])\n+\n+// CHECK: [[E_b:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"** %b to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_b]])\n+    }\n+\n+    let c = 1;\n+    &c; // keep variable in an alloca\n+\n+// CHECK: [[S_c:%[0-9]+]] = bitcast i32* %c to i8*\n+// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_c]])\n+\n+// CHECK: [[E_c:%[0-9]+]] = bitcast i32* %c to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_c]])\n+\n+// CHECK: [[E_a:%[0-9]+]] = bitcast i32* %a to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_a]])\n+}"}, {"sha": "57654acaf73d8c2e4502c03d79fc64eee41868a8", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -288,8 +288,8 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n-    loop { // #break\n-        x += z;\n+    loop {\n+        x += z; // #break\n \n         if x + y > 1000 {\n             return x;"}, {"sha": "b116d9c3c41cfd114622f1c4701ea2ef073e4070", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5b758bab979b1db723bcc97ecd8398127bd8bc/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=1d5b758bab979b1db723bcc97ecd8398127bd8bc", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a = 0;\n+    {\n+        let b = &Some(a);\n+    }\n+    let c = 1;\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.PreTrans.after.mir\n+//     bb0: {\n+//         StorageLive(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n+//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:12:13: 12:14\n+//         StorageLive(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n+//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n+//         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n+//         tmp2 = var0;                     // scope 1 at storage_ranges.rs:14:23: 14:24\n+//         tmp1 = std::prelude::v1::Some<i32>(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n+//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:14:17: 14:25\n+//         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n+//         tmp0 = ();                       // scope 2 at storage_ranges.rs:13:5: 15:6\n+//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n+//         StorageDead(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n+//         StorageLive(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n+//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:16:13: 16:14\n+//         return = ();                     // scope 3 at storage_ranges.rs:11:11: 17:2\n+//         StorageDead(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n+//         StorageDead(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n+//         goto -> bb1;                     // scope 0 at storage_ranges.rs:11:1: 17:2\n+//     }\n+//\n+//     bb1: {\n+//         return;                          // scope 0 at storage_ranges.rs:11:1: 17:2\n+//     }\n+// END rustc.node4.PreTrans.after.mir"}]}