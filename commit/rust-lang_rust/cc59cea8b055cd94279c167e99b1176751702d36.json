{"sha": "cc59cea8b055cd94279c167e99b1176751702d36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNTljZWE4YjA1NWNkOTQyNzljMTY3ZTk5YjExNzY3NTE3MDJkMzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T00:23:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T00:28:06Z"}, "message": "rustc: Thread an item-to-type mapping throughout the typechecking and translation phases", "tree": {"sha": "9a7c33168ac8845f81e62c43a6a1ae8ee46ace87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a7c33168ac8845f81e62c43a6a1ae8ee46ace87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc59cea8b055cd94279c167e99b1176751702d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc59cea8b055cd94279c167e99b1176751702d36", "html_url": "https://github.com/rust-lang/rust/commit/cc59cea8b055cd94279c167e99b1176751702d36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc59cea8b055cd94279c167e99b1176751702d36/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a154c5b656ea215f136a6f4c3120b315686f4bc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a154c5b656ea215f136a6f4c3120b315686f4bc5", "html_url": "https://github.com/rust-lang/rust/commit/a154c5b656ea215f136a6f4c3120b315686f4bc5"}], "stats": {"total": 748, "additions": 395, "deletions": 353}, "files": [{"sha": "4c6da407b6495924df581189df61a69f952d74b8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -6,6 +6,7 @@ import front.token;\n import front.eval;\n import middle.trans;\n import middle.resolve;\n+import middle.ty;\n import middle.typeck;\n import util.common;\n \n@@ -62,8 +63,12 @@ impure fn compile_input(session.session sess,\n     auto crate = parse_input(sess, p, input);\n     crate = creader.read_crates(sess, crate, library_search_paths);\n     crate = resolve.resolve_crate(sess, crate);\n-    crate = typeck.check_crate(sess, crate);\n-    trans.trans_crate(sess, crate, output, shared);\n+\n+    auto typeck_result = typeck.check_crate(sess, crate);\n+    crate = typeck_result._0;\n+    auto type_cache = typeck_result._1;\n+\n+    trans.trans_crate(sess, crate, type_cache, output, shared);\n }\n \n impure fn pretty_print_input(session.session sess,"}, {"sha": "95a5cceb30e824e07d1187d72bc49075cd493c15", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -395,6 +395,8 @@ tag view_item_ {\n     view_item_export(ident);\n }\n \n+type obj_def_ids = rec(def_id ty, def_id ctor);\n+\n type item = spanned[item_];\n tag item_ {\n     item_const(ident, @ty, @expr, def_id, ann);\n@@ -403,7 +405,7 @@ tag item_ {\n     item_native_mod(ident, native_mod, def_id);\n     item_ty(ident, @ty, vec[ty_param], def_id, ann);\n     item_tag(ident, vec[variant], vec[ty_param], def_id);\n-    item_obj(ident, _obj, vec[ty_param], def_id, ann);\n+    item_obj(ident, _obj, vec[ty_param], obj_def_ids, ann);\n }\n \n type native_item = spanned[native_item_];"}, {"sha": "ea6581e0bb197981b6075e539b5ae9c6b82b926c", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -544,6 +544,23 @@ fn read_crates(session.session sess,\n }\n \n \n+fn kind_has_type_params(u8 kind_ch) -> bool {\n+    // FIXME: It'd be great if we had u8 char literals.\n+    if (kind_ch == ('c' as u8))      { ret false; }\n+    else if (kind_ch == ('f' as u8)) { ret true;  }\n+    else if (kind_ch == ('o' as u8)) { ret true;  }\n+    else if (kind_ch == ('t' as u8)) { ret true;  }\n+    else if (kind_ch == ('m' as u8)) { ret false; }\n+    else if (kind_ch == ('n' as u8)) { ret false; }\n+    else if (kind_ch == ('v' as u8)) { ret true;  }\n+    else {\n+        log #fmt(\"kind_has_type_params(): unknown kind char: %d\",\n+                 kind_ch as int);\n+        fail;\n+    }\n+}\n+\n+\n // Crate metadata queries\n \n fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n@@ -567,7 +584,6 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     auto def;\n     if (kind_ch == ('c' as u8))      { def = ast.def_const(did);        }\n     else if (kind_ch == ('f' as u8)) { def = ast.def_fn(did);           }\n-    else if (kind_ch == ('y' as u8)) { def = ast.def_ty(did);           }\n     else if (kind_ch == ('o' as u8)) { def = ast.def_obj(did);          }\n     else if (kind_ch == ('t' as u8)) { def = ast.def_ty(did);           }\n     else if (kind_ch == ('m' as u8)) { def = ast.def_mod(did);          }\n@@ -584,13 +600,23 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     ret some[ast.def](def);\n }\n \n-fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_and_ty {\n+fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_opt_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id);\n     auto ebml_r = lookup_item(def._1, data);\n     auto t = get_item_type(ebml_r, external_crate_id);\n-    auto tps = get_item_ty_params(ebml_r, external_crate_id);\n-    ret tup(tps, t);\n+\n+    auto tps_opt;\n+    auto kind_ch = get_item_kind(ebml_r);\n+    auto has_ty_params = kind_has_type_params(kind_ch);\n+    if (has_ty_params) {\n+        auto tps = get_item_ty_params(ebml_r, external_crate_id);\n+        tps_opt = some[vec[ast.def_id]](tps);\n+    } else {\n+        tps_opt = none[vec[ast.def_id]];\n+    }\n+\n+    ret tup(tps_opt, t);\n }\n \n fn get_symbol(session.session sess, ast.def_id def) -> str {"}, {"sha": "a247c8249a28dbf65a0043b813e2ada08bddd671", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -1876,8 +1876,8 @@ impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n                           methods=meths,\n                           dtor=dtor);\n \n-    auto item = ast.item_obj(ident, ob, ty_params,\n-                             p.next_def_id(), ast.ann_none);\n+    auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n+    auto item = ast.item_obj(ident, ob, ty_params, odid, ast.ann_none);\n \n     ret @spanned(lo, hi, item);\n }"}, {"sha": "d805c3cb33cd1f7e874ae3415768109ec9ef10e8", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -269,7 +269,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ident ident,\n          &ast._obj ob,\n          vec[ast.ty_param] ty_params,\n-         def_id id, ann a) -> @item)              fold_item_obj,\n+         ast.obj_def_ids odid, ann a) -> @item)   fold_item_obj,\n \n      // View Item folds.\n      (fn(&ENV e, &span sp, ident ident,\n@@ -975,9 +975,9 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n                                   ty_params, id);\n         }\n \n-        case (ast.item_obj(?ident, ?ob, ?tps, ?id, ?ann)) {\n+        case (ast.item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n             let ast._obj ob_ = fold_obj[ENV](env_, fld, ob);\n-            ret fld.fold_item_obj(env_, i.span, ident, ob_, tps, id, ann);\n+            ret fld.fold_item_obj(env_, i.span, ident, ob_, tps, odid, ann);\n         }\n \n     }\n@@ -1429,8 +1429,8 @@ fn identity_fold_item_tag[ENV](&ENV e, &span sp, ident i,\n \n fn identity_fold_item_obj[ENV](&ENV e, &span sp, ident i,\n                                &ast._obj ob, vec[ast.ty_param] ty_params,\n-                               def_id id, ann a) -> @item {\n-    ret @respan(sp, ast.item_obj(i, ob, ty_params, id, a));\n+                               ast.obj_def_ids odid, ann a) -> @item {\n+    ret @respan(sp, ast.item_obj(i, ob, ty_params, odid, a));\n }\n \n // View Item folds."}, {"sha": "4ace1f4ad6a25b4bef677160153e5c7f64f3ca08", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -30,6 +30,7 @@ const uint tag_items_type = 0x0au;\n const uint tag_items_symbol = 0x0bu;\n const uint tag_items_variant = 0x0cu;\n const uint tag_items_tag_id = 0x0du;\n+const uint tag_items_obj_type_id = 0x0eu;\n \n // Type encoding\n \n@@ -237,10 +238,11 @@ fn encode_module_item_paths(&ebml.writer ebml_w, &ast._mod module) {\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n-            case (ast.item_obj(?id, _, ?tps, ?did, ?ann)) {\n+            case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n                 ebml.start_tag(ebml_w, tag_paths_item);\n                 encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_def_id(ebml_w, odid.ctor);\n+                encode_obj_type_id(ebml_w, odid.ty);\n                 ebml.end_tag(ebml_w);\n             }\n         }\n@@ -301,6 +303,12 @@ fn encode_tag_id(&ebml.writer ebml_w, &ast.def_id id) {\n     ebml.end_tag(ebml_w);\n }\n \n+fn encode_obj_type_id(&ebml.writer ebml_w, &ast.def_id id) {\n+    ebml.start_tag(ebml_w, tag_items_obj_type_id);\n+    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n \n fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                            ast.def_id did, vec[ast.variant] variants) {\n@@ -367,13 +375,21 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n \n             encode_tag_variant_info(cx, ebml_w, did, variants);\n         }\n-        case (ast.item_obj(?id, _, ?tps, ?did, ?ann)) {\n+        case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n             ebml.start_tag(ebml_w, tag_items_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, odid.ctor);\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_params(ebml_w, tps);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n-            encode_symbol(cx, ebml_w, did);\n+            auto fn_ty = trans.node_ann_type(cx, ann);\n+            encode_type(ebml_w, fn_ty);\n+            encode_symbol(cx, ebml_w, odid.ctor);\n+            ebml.end_tag(ebml_w);\n+\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, odid.ty);\n+            encode_kind(ebml_w, 'y' as u8);\n+            encode_type_params(ebml_w, tps);\n+            encode_type(ebml_w, ty.ty_fn_ret(fn_ty));\n             ebml.end_tag(ebml_w);\n         }\n     }"}, {"sha": "1ceb7e66744efc74e7ce30480c688ff8770c30d6", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -29,6 +29,11 @@ tag scope {\n type env = rec(list[scope] scopes,\n                session.session sess);\n \n+tag namespace {\n+    ns_value;\n+    ns_type;\n+}\n+\n type import_map = std.map.hashmap[ast.def_id,def_wrap];\n \n // A simple wrapper over defs that stores a bit more information about modules\n@@ -97,8 +102,8 @@ fn unwrap_def(def_wrap d) -> def {\n     }\n }\n \n-fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n-    auto d_ = lookup_name_wrapped(e, i);\n+fn lookup_name(&env e, ast.ident i, namespace ns) -> option.t[def] {\n+    auto d_ = lookup_name_wrapped(e, i, ns);\n     alt (d_) {\n         case (none[tup(@env, def_wrap)]) {\n             ret none[def];\n@@ -138,24 +143,26 @@ fn lookup_external_def(session.session sess, int cnum, vec[ident] idents)\n // If used after imports are resolved, import_id is none.\n \n fn find_final_def(&env e, import_map index,\n-                  &span sp, vec[ident] idents,\n+                  &span sp, vec[ident] idents, namespace ns,\n                   option.t[ast.def_id] import_id) -> def_wrap {\n \n     // We are given a series of identifiers (p.q.r) and we know that\n     // in the environment 'e' the identifier 'p' was resolved to 'd'. We\n     // should return what p.q.r points to in the end.\n     fn found_something(&env e, import_map index,\n-                       &span sp, vec[ident] idents, def_wrap d) -> def_wrap {\n+                       &span sp, vec[ident] idents, namespace ns,\n+                       def_wrap d) -> def_wrap {\n \n         fn found_mod(&env e, &import_map index, &span sp,\n-                     vec[ident] idents, @ast.item i) -> def_wrap {\n+                     vec[ident] idents, namespace ns,\n+                     @ast.item i) -> def_wrap {\n             auto len = _vec.len[ident](idents);\n             auto rest_idents = _vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope],\n                                sess = e.sess);\n             auto tmp_e = update_env_for_item(empty_e, i);\n             auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns);\n             alt (next_) {\n                 case (none[tup(@env, def_wrap)]) {\n                     e.sess.span_err(sp, \"unresolved name: \" + next_i);\n@@ -164,21 +171,22 @@ fn find_final_def(&env e, import_map index,\n                 case (some[tup(@env, def_wrap)](?next)) {\n                     auto combined_e = update_env_for_item(e, i);\n                     ret found_something(combined_e, index, sp,\n-                                        rest_idents, next._1);\n+                                        rest_idents, ns, next._1);\n                 }\n             }\n         }\n \n         // TODO: Refactor with above.\n         fn found_external_mod(&env e, &import_map index, &span sp,\n-                              vec[ident] idents, ast.def_id mod_id)\n+                              vec[ident] idents, namespace ns,\n+                              ast.def_id mod_id)\n                 -> def_wrap {\n             auto len = _vec.len[ident](idents);\n             auto rest_idents = _vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope], sess = e.sess);\n             auto tmp_e = update_env_for_external_mod(empty_e, mod_id, idents);\n             auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns);\n             alt (next_) {\n                 case (none[tup(@env, def_wrap)]) {\n                     e.sess.span_err(sp, \"unresolved name: \" + next_i);\n@@ -189,7 +197,7 @@ fn find_final_def(&env e, import_map index,\n                                                                   mod_id,\n                                                                   idents);\n                     ret found_something(combined_e, index, sp,\n-                                        rest_idents, next._1);\n+                                        rest_idents, ns, next._1);\n                 }\n             }\n         }\n@@ -212,9 +220,9 @@ fn find_final_def(&env e, import_map index,\n             case (def_wrap_import(?imp)) {\n                 alt (imp.node) {\n                     case (ast.view_item_import(_, ?new_idents, ?d, _)) {\n-                        auto x = find_final_def(e, index, sp, new_idents,\n-                                               some(d));\n-                        ret found_something(e, index, sp, idents, x);\n+                        auto x = find_final_def(e, index, sp, new_idents, ns,\n+                                                some(d));\n+                        ret found_something(e, index, sp, idents, ns, x);\n                     }\n                 }\n             }\n@@ -227,16 +235,16 @@ fn find_final_def(&env e, import_map index,\n         }\n         alt (d) {\n             case (def_wrap_mod(?i)) {\n-                ret found_mod(e, index, sp, idents, i);\n+                ret found_mod(e, index, sp, idents, ns, i);\n             }\n             case (def_wrap_native_mod(?i)) {\n-                ret found_mod(e, index, sp, idents, i);\n+                ret found_mod(e, index, sp, idents, ns, i);\n             }\n             case (def_wrap_external_mod(?mod_id)) {\n-                ret found_external_mod(e, index, sp, idents, mod_id);\n+                ret found_external_mod(e, index, sp, idents, ns, mod_id);\n             }\n             case (def_wrap_external_native_mod(?mod_id)) {\n-                ret found_external_mod(e, index, sp, idents, mod_id);\n+                ret found_external_mod(e, index, sp, idents, ns, mod_id);\n             }\n             case (def_wrap_use(?vi)) {\n                 alt (vi.node) {\n@@ -273,14 +281,14 @@ fn find_final_def(&env e, import_map index,\n         index.insert(option.get[ast.def_id](import_id), def_wrap_resolving);\n     }\n     auto first = idents.(0);\n-    auto d_ = lookup_name_wrapped(e, first);\n+    auto d_ = lookup_name_wrapped(e, first, ns);\n     alt (d_) {\n         case (none[tup(@env, def_wrap)]) {\n             e.sess.span_err(sp, \"unresolved name: \" + first);\n             fail;\n         }\n         case (some[tup(@env, def_wrap)](?d)) {\n-            auto x = found_something(*d._0, index, sp, idents, d._1);\n+            auto x = found_something(*d._0, index, sp, idents, ns, d._1);\n             if (import_id != none[ast.def_id]) {\n                 index.insert(option.get[ast.def_id](import_id), x);\n             }\n@@ -289,11 +297,12 @@ fn find_final_def(&env e, import_map index,\n     }\n }\n \n-fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n+fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n+        -> option.t[tup(@env, def_wrap)] {\n \n     // log \"resolving name \" + i;\n \n-    fn found_def_item(@ast.item i) -> def_wrap {\n+    fn found_def_item(@ast.item i, namespace ns) -> def_wrap {\n         alt (i.node) {\n             case (ast.item_const(_, _, _, ?id, _)) {\n                 ret def_wrap_other(ast.def_const(id));\n@@ -313,8 +322,15 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             case (ast.item_tag(_, _, _, ?id)) {\n                 ret def_wrap_other(ast.def_ty(id));\n             }\n-            case (ast.item_obj(_, _, _, ?id, _)) {\n-                ret def_wrap_other(ast.def_obj(id));\n+            case (ast.item_obj(_, _, _, ?odid, _)) {\n+                alt (ns) {\n+                    case (ns_value) {\n+                        ret def_wrap_other(ast.def_obj(odid.ctor));\n+                    }\n+                    case (ns_type) {\n+                        ret def_wrap_other(ast.def_obj(odid.ty));\n+                    }\n+                }\n             }\n         }\n     }\n@@ -330,7 +346,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         }\n     }\n \n-    fn found_decl_stmt(@ast.stmt s) -> def_wrap {\n+    fn found_decl_stmt(@ast.stmt s, namespace ns) -> def_wrap {\n         alt (s.node) {\n             case (ast.stmt_decl(?d)) {\n                 alt (d.node) {\n@@ -339,7 +355,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                         ret def_wrap_other(t);\n                     }\n                     case (ast.decl_item(?it)) {\n-                        ret found_def_item(it);\n+                        ret found_def_item(it, ns);\n                     }\n                 }\n             }\n@@ -359,15 +375,16 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         fail;\n     }\n \n-    fn check_mod(ast.ident i, ast._mod m) -> option.t[def_wrap] {\n+    fn check_mod(ast.ident i, ast._mod m, namespace ns)\n+            -> option.t[def_wrap] {\n         alt (m.index.find(i)) {\n             case (some[ast.mod_index_entry](?ent)) {\n                 alt (ent) {\n                     case (ast.mie_view_item(?view_item)) {\n                         ret some(found_def_view(view_item));\n                     }\n                     case (ast.mie_item(?item)) {\n-                        ret some(found_def_item(item));\n+                        ret some(found_def_item(item, ns));\n                     }\n                     case (ast.mie_tag_variant(?item, ?variant_idx)) {\n                         alt (item.node) {\n@@ -440,12 +457,13 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         }\n     }\n \n-    fn check_block(ast.ident i, &ast.block_ b) -> option.t[def_wrap] {\n+    fn check_block(ast.ident i, &ast.block_ b, namespace ns)\n+            -> option.t[def_wrap] {\n         alt (b.index.find(i)) {\n             case (some[ast.block_index_entry](?ix)) {\n                 alt(ix) {\n                     case (ast.bie_item(?it)) {\n-                        ret some(found_def_item(it));\n+                        ret some(found_def_item(it, ns));\n                     }\n                     case (ast.bie_local(?l)) {\n                         auto t = ast.def_local(l.id);\n@@ -460,12 +478,12 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         }\n     }\n \n-    fn in_scope(&session.session sess, ast.ident i, &scope s)\n+    fn in_scope(&session.session sess, ast.ident i, &scope s, namespace ns)\n             -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n-                ret check_mod(i, c.node.module);\n+                ret check_mod(i, c.node.module, ns);\n             }\n \n             case (scope_item(?it)) {\n@@ -496,7 +514,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(i, m);\n+                        ret check_mod(i, m, ns);\n                     }\n                     case (ast.item_native_mod(_, ?m, _)) {\n                         ret check_native_mod(i, m);\n@@ -537,7 +555,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             }\n \n             case (scope_block(?b)) {\n-                ret check_block(i, b.node);\n+                ret check_block(i, b.node, ns);\n             }\n \n             case (scope_arm(?a)) {\n@@ -558,14 +576,14 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             ret none[tup(@env, def_wrap)];\n         }\n         case (cons[scope](?hd, ?tl)) {\n-            auto x = in_scope(e.sess, i, hd);\n+            auto x = in_scope(e.sess, i, hd, ns);\n             alt (x) {\n                 case (some[def_wrap](?x)) {\n                     ret some(tup(@e, x));\n                 }\n                 case (none[def_wrap]) {\n                     auto outer_env = rec(scopes = *tl with e);\n-                    ret lookup_name_wrapped(outer_env, i);\n+                    ret lookup_name_wrapped(outer_env, i, ns);\n                 }\n             }\n         }\n@@ -579,7 +597,8 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n     auto last_id = p.node.idents.(len - 1u);\n     auto new_def;\n     auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, none[ast.def_id]);\n+    auto d = find_final_def(e, index, sp, p.node.idents, ns_value,\n+                            none[ast.def_id]);\n     alt (unwrap_def(d)) {\n         case (ast.def_variant(?did, ?vid)) {\n             new_def = some[ast.variant_def](tup(did, vid));\n@@ -619,7 +638,8 @@ fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n     check (n_idents != 0u);\n \n     auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, none[ast.def_id]);\n+    auto d = find_final_def(e, index, sp, p.node.idents, ns_value,\n+                            none[ast.def_id]);\n     let uint path_len = 0u;\n     alt (d) {\n         case (def_wrap_expr_field(?remaining, _)) {\n@@ -655,7 +675,7 @@ fn fold_view_item_import(&env e, &span sp,\n     // Produce errors for invalid imports\n     auto len = _vec.len[ast.ident](is);\n     auto last_id = is.(len - 1u);\n-    auto d = find_final_def(e, index, sp, is, some(id));\n+    auto d = find_final_def(e, index, sp, is, ns_value, some(id));\n     alt (d) {\n         case (def_wrap_expr_field(?remain, _)) {\n             auto ident = is.(len - remain);\n@@ -671,7 +691,8 @@ fn fold_view_item_import(&env e, &span sp,\n \n fn fold_ty_path(&env e, &span sp, ast.path p, &option.t[def] d) -> @ast.ty {\n     auto index = new_def_hash[def_wrap]();\n-    auto d = find_final_def(e, index, sp, p.node.idents, none[ast.def_id]);\n+    auto d = find_final_def(e, index, sp, p.node.idents, ns_type,\n+                            none[ast.def_id]);\n \n     ret @fold.respan[ast.ty_](sp, ast.ty_path(p, some(unwrap_def(d))));\n }"}, {"sha": "eea22185ea2b0d5ee6d36ff41b9a6978cd4d8479", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -95,6 +95,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n                                     @ast.native_item] native_items,\n+                            ty.type_cache type_cache,\n                             hashmap[ast.def_id, str] item_symbols,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[@ty.t, uint] tag_sizes,\n@@ -3610,6 +3611,7 @@ fn lval_generic_fn(@block_ctxt cx,\n \n fn trans_external_path(@block_ctxt cx, &ast.path p,\n                        ast.def def, ast.ann a) -> lval_result {\n+    // FIXME: This isn't generic-safe.\n     auto ccx = cx.fcx.ccx;\n     auto ty = node_ann_type(ccx, a);\n     auto name = creader.get_symbol(ccx.sess, ast.def_id_of_def(def));\n@@ -3618,20 +3620,11 @@ fn trans_external_path(@block_ctxt cx, &ast.path p,\n     ret lval_mem(cx, v);\n }\n \n-fn def_is_external(@crate_ctxt cx, ast.def d) -> bool {\n-    auto id = ast.def_id_of_def(d);\n-    ret id._0 != cx.sess.get_targ_crate_num();\n-}\n-\n fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n               &ast.ann ann) -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n \n-            if (def_is_external(cx.fcx.ccx, def)) {\n-                ret trans_external_path(cx, p, def, ann);\n-            }\n-\n             alt (def) {\n                 case (ast.def_arg(?did)) {\n                     alt (cx.fcx.llargs.find(did)) {\n@@ -3665,15 +3658,18 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_fn(?did)) {\n                     check (cx.fcx.ccx.items.contains_key(did));\n-                    auto fn_item = cx.fcx.ccx.items.get(did);\n-                    ret lval_generic_fn(cx, ty.item_ty(fn_item), did, ann);\n+                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                        cx.fcx.ccx.type_cache, did);\n+                    ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n                     check (cx.fcx.ccx.items.contains_key(did));\n-                    auto fn_item = cx.fcx.ccx.items.get(did);\n-                    ret lval_generic_fn(cx, ty.item_ty(fn_item), did, ann);\n+                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                        cx.fcx.ccx.type_cache, did);\n+                    ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n+                    // TODO: externals\n                     if (cx.fcx.ccx.fn_pairs.contains_key(vid)) {\n                         check (cx.fcx.ccx.items.contains_key(tid));\n                         auto tag_item = cx.fcx.ccx.items.get(tid);\n@@ -3716,14 +3712,15 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     }\n                 }\n                 case (ast.def_const(?did)) {\n+                    // TODO: externals\n                     check (cx.fcx.ccx.consts.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.ccx.consts.get(did));\n                 }\n                 case (ast.def_native_fn(?did)) {\n                     check (cx.fcx.ccx.native_items.contains_key(did));\n-                    auto fn_item = cx.fcx.ccx.native_items.get(did);\n-                    ret lval_generic_fn(cx, ty.native_item_ty(fn_item),\n-                                        did, ann);\n+                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                        cx.fcx.ccx.type_cache, did);\n+                    ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n@@ -5829,7 +5826,7 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n             auto sub_cx = @rec(obj_typarams=tps,\n                                obj_fields=ob.fields with\n                                *extend_path(cx, name));\n-            trans_obj(sub_cx, ob, oid, tps, ann);\n+            trans_obj(sub_cx, ob, oid.ctor, tps, ann);\n         }\n         case (ast.item_mod(?name, ?m, _)) {\n             auto sub_cx = extend_path(cx, name);\n@@ -6125,9 +6122,9 @@ fn collect_item_pass2(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         }\n \n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n-            cx.items.insert(oid, i);\n+            cx.items.insert(oid.ctor, i);\n             decl_fn_and_pair(extend_path(cx, name), \"obj_ctor\",\n-                             tps, ann, oid);\n+                             tps, ann, oid.ctor);\n             for (@ast.method m in ob.methods) {\n                 cx.obj_methods.insert(m.node.id, ());\n             }\n@@ -6782,8 +6779,8 @@ fn make_common_glue(str output) {\n     llvm.LLVMDisposeModule(llmod);\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate, str output,\n-               bool shared) {\n+fn trans_crate(session.session sess, @ast.crate crate,\n+               &ty.type_cache type_cache, str output, bool shared) {\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());\n@@ -6816,6 +6813,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),\n+                   type_cache = type_cache,\n                    item_symbols = new_def_hash[str](),\n                    tag_sizes = tag_sizes,\n                    discrims = new_def_hash[ValueRef](),"}, {"sha": "4e4cf34c13a5a2c32d5972b3730272e0a23fcb86", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -10,6 +10,7 @@ import std.option.some;\n import driver.session;\n import front.ast;\n import front.ast.mutability;\n+import front.creader;\n import util.common;\n import util.common.new_def_hash;\n import util.common.span;\n@@ -86,6 +87,11 @@ tag unify_result {\n     ures_err(type_err, @ty.t, @ty.t);\n }\n \n+\n+type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n+type type_cache = hashmap[ast.def_id,ty_params_opt_and_ty];\n+\n+\n // Stringification\n \n fn path_to_str(&ast.path pth) -> str {\n@@ -1673,6 +1679,55 @@ fn substitute_ty_params(vec[ast.ty_param] ty_params, vec[@t] bound, @t ty)\n     ret replace_type_params(ty, bindings);\n }\n \n+\n+fn def_has_ty_params(&ast.def def) -> bool {\n+    alt (def) {\n+        case (ast.def_fn(_))            { ret true;  }\n+        case (ast.def_obj(_))           { ret true;  }\n+        case (ast.def_obj_field(_))     { ret false; }\n+        case (ast.def_mod(_))           { ret false; }\n+        case (ast.def_const(_))         { ret false; }\n+        case (ast.def_arg(_))           { ret false; }\n+        case (ast.def_local(_))         { ret false; }\n+        case (ast.def_variant(_, _))    { ret true;  }\n+        case (ast.def_ty(_))            { ret false; }\n+        case (ast.def_ty_arg(_))        { ret false; }\n+        case (ast.def_binding(_))       { ret false; }\n+        case (ast.def_use(_))           { ret false; }\n+        case (ast.def_native_ty(_))     { ret false; }\n+        case (ast.def_native_fn(_))     { ret true;  }\n+    }\n+}\n+\n+// If the given item is in an external crate, looks up its type and adds it to\n+// the type cache. Returns the type parameters and type.\n+fn lookup_item_type(session.session sess, &type_cache cache,\n+                    ast.def_id did) -> ty_params_opt_and_ty {\n+    if (did._0 == sess.get_targ_crate_num()) {\n+        // The item is in this crate. The caller should have added it to the\n+        // type cache already; we simply return it.\n+        check (cache.contains_key(did));\n+        ret cache.get(did);\n+    }\n+\n+    if (cache.contains_key(did)) {\n+        ret cache.get(did);\n+    }\n+\n+    auto tyt = creader.get_type(sess, did);\n+    cache.insert(did, tyt);\n+    ret tyt;\n+}\n+\n+// A convenience function to retrive type parameters and a type when it's\n+// known that the item supports generics (functions, variants, objects).\n+fn lookup_generic_item_type(session.session sess, &type_cache cache,\n+                            ast.def_id did) -> ty_params_and_ty {\n+    auto tp_opt_and_ty = lookup_item_type(sess, cache, did);\n+    ret tup(option.get[vec[ast.def_id]](tp_opt_and_ty._0), tp_opt_and_ty._1);\n+}\n+\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "bf1b6c39a537c6f492a6ac87e0e7a675b0db2068", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 192, "deletions": 273, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc59cea8b055cd94279c167e99b1176751702d36/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cc59cea8b055cd94279c167e99b1176751702d36", "patch": "@@ -21,6 +21,7 @@ import middle.ty.plain_ty;\n import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n+import middle.ty.ty_params_opt_and_ty;\n \n import std._str;\n import std._uint;\n@@ -39,12 +40,10 @@ tag any_item {\n }\n \n type ty_item_table = hashmap[ast.def_id,any_item];\n-type ty_param_table = hashmap[ast.def_id,vec[ast.def_id]];\n \n type crate_ctxt = rec(session.session sess,\n-                      @ty_table item_types,\n+                      ty.type_cache type_cache,\n                       @ty_item_table item_items,\n-                      @ty_param_table item_ty_params,\n                       vec[ast.obj_field] obj_fields,\n                       mutable int next_var_id);\n \n@@ -53,7 +52,7 @@ type fn_ctxt = rec(@ty.t ret_ty,\n                    @crate_ctxt ccx);\n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(ast.def_id) -> ty.ty_params_and_ty;\n+type ty_getter = fn(ast.def_id) -> ty.ty_params_opt_and_ty;\n \n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n@@ -128,24 +127,6 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n }\n \n \n-// Looks up the type of the given item in an external crate.\n-fn lookup_item_type_if_necessary(@crate_ctxt ccx, ast.def_id did) {\n-    if (did._0 == ccx.sess.get_targ_crate_num()) {\n-        ret;    // Nothing to do; it should already be in the tables.\n-    }\n-\n-    if (ccx.item_types.contains_key(did)) {\n-        ret;    // Nothing to do; we already looked up this item's type.\n-    }\n-\n-    auto tyt = creader.get_type(ccx.sess, did);\n-    ccx.item_types.insert(did, tyt._1);\n-    ccx.item_ty_params.insert(did, tyt._0);\n-}\n-\n-\n-type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n-\n // Returns the type parameters and the type for the given definition.\n fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         -> ty_params_opt_and_ty {\n@@ -167,38 +148,23 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n-            lookup_item_type_if_necessary(fcx.ccx, id);\n-            check (fcx.ccx.item_types.contains_key(id));\n-            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n-                    fcx.ccx.item_types.get(id));\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n         }\n         case (ast.def_native_fn(?id)) {\n-            lookup_item_type_if_necessary(fcx.ccx, id);\n-            check (fcx.ccx.item_types.contains_key(id));\n-            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n-                    fcx.ccx.item_types.get(id));\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n         }\n         case (ast.def_const(?id)) {\n-            lookup_item_type_if_necessary(fcx.ccx, id);\n-            check (fcx.ccx.item_types.contains_key(id));\n-            ret tup(none[vec[ast.def_id]], fcx.ccx.item_types.get(id));\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n         }\n-        case (ast.def_variant(?tag_id, ?variant_id)) {\n-            lookup_item_type_if_necessary(fcx.ccx, tag_id);\n-            lookup_item_type_if_necessary(fcx.ccx, variant_id);\n-            check (fcx.ccx.item_types.contains_key(variant_id));\n-            ret tup(some(fcx.ccx.item_ty_params.get(tag_id)),\n-                    fcx.ccx.item_types.get(variant_id));\n+        case (ast.def_variant(_, ?vid)) {\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n             check (fcx.locals.contains_key(id));\n             ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n-            lookup_item_type_if_necessary(fcx.ccx, id);\n-            check (fcx.ccx.item_types.contains_key(id));\n-            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n-                    fcx.ccx.item_types.get(id));\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n         }\n \n         case (ast.def_mod(_)) {\n@@ -266,33 +232,31 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n \n // Returns the type parameters and polytype of an item, if it's an item that\n // supports type parameters.\n+//\n+// TODO: This function is a little silly in the presence of the new\n+// lookup_item_type(); remove this in favor of lookup_item_type() if possible.\n fn ty_params_for_item(@crate_ctxt ccx, &ast.def d)\n         -> option.t[ty.ty_params_and_ty] {\n-    auto params_id;\n-    auto types_id;\n+    auto did;\n     alt (d) {\n-        case (ast.def_fn(?id))          { params_id = id; types_id = id; }\n-        case (ast.def_obj(?id))         { params_id = id; types_id = id; }\n+        case (ast.def_fn(?id))          { did = id;                      }\n+        case (ast.def_obj(?id))         { did = id;                      }\n         case (ast.def_obj_field(_))     { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_mod(_))           { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_const(_))         { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_arg(_))           { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_local(_))         { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_variant(?tid, ?vid)) {\n-            params_id = tid;\n-            types_id = vid;\n-        }\n+        case (ast.def_variant(_, ?vid)) { did = vid;                     }\n         case (ast.def_ty(_))            { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_ty_arg(_))        { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_binding(_))       { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_use(_))           { ret none[ty.ty_params_and_ty]; }\n         case (ast.def_native_ty(_))     { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_native_fn(?id))   { params_id = id; types_id = id; }\n+        case (ast.def_native_fn(?id))   { did = id;                      }\n     }\n \n-    auto tps = ccx.item_ty_params.get(params_id);\n-    auto polyty = ccx.item_types.get(types_id);\n-    ret some[ty.ty_params_and_ty](tup(tps, polyty));\n+    auto tpt = ty.lookup_generic_item_type(ccx.sess, ccx.type_cache, did);\n+    ret some[ty.ty_params_and_ty](tpt);\n }\n \n // Parses the programmer's textual representation of a type into our internal\n@@ -312,18 +276,26 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n                    vec[@ast.ty] args) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n-        auto ty_and_params = getter(id);\n-        auto params = ty_and_params._0;\n-        auto num_type_args = _vec.len[@ast.ty](args);\n-        check(num_type_args == _vec.len[ast.def_id](params));\n-\n-        auto param_map = common.new_def_hash[@ty.t]();\n-        for each (uint i in _uint.range(0u, num_type_args)) {\n-            auto arg = args.(i);\n-            auto param = params.(i);\n-            param_map.insert(param, ast_ty_to_ty(getter, arg));\n-        }\n-        ret ty.replace_type_params(ty_and_params._1, param_map);\n+        auto params_opt_and_ty = getter(id);\n+        alt (params_opt_and_ty._0) {\n+            case (none[vec[ast.def_id]]) {\n+                // FIXME: Session error. This is completely user-unfriendly.\n+                log \"item has no type parameters\";\n+                fail;\n+            }\n+            case (some[vec[ast.def_id]](?params)) {\n+                auto num_type_args = _vec.len[@ast.ty](args);\n+                check(num_type_args == _vec.len[ast.def_id](params));\n+\n+                auto param_map = common.new_def_hash[@ty.t]();\n+                for each (uint i in _uint.range(0u, num_type_args)) {\n+                    auto arg = args.(i);\n+                    auto param = params.(i);\n+                    param_map.insert(param, ast_ty_to_ty(getter, arg));\n+                }\n+                ret ty.replace_type_params(params_opt_and_ty._1, param_map);\n+            }\n+        }\n     }\n \n     auto mut = ast.imm;\n@@ -378,7 +350,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n                     sty = instantiate(getter, id, path.node.types).struct;\n                 }\n                 case (ast.def_native_ty(?id)) {\n-                    sty = instantiate(getter, id, path.node.types).struct;\n+                    sty = getter(id)._1.struct;\n                 }\n                 case (ast.def_obj(?id))     {\n                     sty = instantiate(getter, id, path.node.types).struct;\n@@ -410,87 +382,16 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n     ret @rec(struct=sty, cname=cname);\n }\n \n-fn actual_type(@ty.t t, @ast.item item) -> @ty.t {\n-    alt (item.node) {\n-        case (ast.item_obj(_,_,_,_,_)) {\n-            // An obj used as a type name refers to the output type of the\n-            // item (constructor).\n-            ret middle.ty.ty_fn_ret(t);\n-        }\n-        case (_) { }\n-    }\n-\n-    ret t;\n-}\n-\n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n-    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_params_and_ty {\n-\n-        if (id._0 != ccx.sess.get_targ_crate_num()) {\n-            // This is a type we need to load in from the crate reader.\n-            ret creader.get_type(ccx.sess, id);\n-        }\n-\n-        check (ccx.item_items.contains_key(id));\n-        check (ccx.item_types.contains_key(id));\n-        auto it = ccx.item_items.get(id);\n-        auto ty = ccx.item_types.get(id);\n-        auto params;\n-        alt (it) {\n-            case (any_item_rust(?item)) {\n-                ty = actual_type(ty, item);\n-                params = ty_params_of_item(item);\n-            }\n-            case (any_item_native(?native_item, _)) {\n-                params = ty_params_of_native_item(native_item);\n-           }\n-        }\n-\n-        let vec[ast.def_id] param_ids = vec();\n-        for (ast.ty_param tp in params) {\n-            param_ids += vec(tp.id);\n-        }\n-\n-        ret tup(param_ids, ty);\n+    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_params_opt_and_ty {\n+        ret ty.lookup_item_type(ccx.sess, ccx.type_cache, id);\n     }\n     auto f = bind getter(ccx, _);\n     ret ast_ty_to_ty(f, ast_ty);\n }\n \n-fn ty_params_of_item(@ast.item item) -> vec[ast.ty_param] {\n-    alt (item.node) {\n-        case (ast.item_fn(_, _, ?p, _, _)) {\n-            ret p;\n-        }\n-        case (ast.item_ty(_, _, ?p, _, _)) {\n-            ret p;\n-        }\n-        case (ast.item_tag(_, _, ?p, _)) {\n-            ret p;\n-        }\n-        case (ast.item_obj(_, _, ?p, _, _)) {\n-            ret p;\n-        }\n-        case (_) {\n-            let vec[ast.ty_param] r = vec();\n-            ret r;\n-        }\n-    }\n-}\n-\n-fn ty_params_of_native_item(@ast.native_item item) -> vec[ast.ty_param] {\n-    alt (item.node) {\n-        case (ast.native_item_fn(_, _, _, ?p, _, _)) {\n-            ret p;\n-        }\n-        case (_) {\n-            let vec[ast.ty_param] r = vec();\n-            ret r;\n-        }\n-    }\n-}\n \n // Item collection - a pair of bootstrap passes:\n //\n@@ -503,41 +404,55 @@ fn ty_params_of_native_item(@ast.native_item item) -> vec[ast.ty_param] {\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n \n+fn ty_params_to_def_ids(vec[ast.ty_param] tps) -> vec[ast.def_id] {\n+    let vec[ast.def_id] result = vec();\n+    for (ast.ty_param tp in tps) {\n+        result += vec(tp.id);\n+    }\n+    ret result;\n+}\n+\n fn ty_of_fn_decl(@ty_item_table id_to_ty_item,\n-                 @ty_table item_to_ty,\n+                 ty.type_cache type_cache,\n                  fn(&@ast.ty ast_ty) -> @ty.t convert,\n                  fn(&ast.arg a) -> arg ty_of_arg,\n                  &ast.fn_decl decl,\n                  ast.proto proto,\n-                 ast.def_id def_id) -> @ty.t {\n+                 vec[ast.ty_param] ty_params,\n+                 ast.def_id def_id) -> ty.ty_params_opt_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n     auto t_fn = plain_ty(ty.ty_fn(proto, input_tys, output_ty));\n-    item_to_ty.insert(def_id, t_fn);\n-    ret t_fn;\n+    auto params_opt = some[vec[ast.def_id]](ty_params_to_def_ids(ty_params));\n+    auto tpt = tup(params_opt, t_fn);\n+    type_cache.insert(def_id, tpt);\n+    ret tpt;\n }\n \n fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n-                 @ty_table item_to_ty,\n+                 ty.type_cache type_cache,\n                  fn(&@ast.ty ast_ty) -> @ty.t convert,\n                  fn(&ast.arg a) -> arg ty_of_arg,\n                  &ast.fn_decl decl,\n                  ast.native_abi abi,\n-                 ast.def_id def_id) -> @ty.t {\n+                 vec[ast.ty_param] ty_params,\n+                 ast.def_id def_id) -> ty.ty_params_opt_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n     auto t_fn = plain_ty(ty.ty_native_fn(abi, input_tys, output_ty));\n-    item_to_ty.insert(def_id, t_fn);\n-    ret t_fn;\n+    auto params_opt = some[vec[ast.def_id]](ty_params_to_def_ids(ty_params));\n+    auto tpt = tup(params_opt, t_fn);\n+    type_cache.insert(def_id, tpt);\n+    ret tpt;\n }\n \n fn collect_item_types(session.session sess, @ast.crate crate)\n-    -> tup(@ast.crate, @ty_table, @ty_item_table, @ty_param_table) {\n+    -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n \n     fn getter(session.session sess,\n               @ty_item_table id_to_ty_item,\n-              @ty_table item_to_ty,\n-              ast.def_id id) -> ty.ty_params_and_ty {\n+              ty.type_cache type_cache,\n+              ast.def_id id) -> ty.ty_params_opt_and_ty {\n \n         if (id._0 != sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n@@ -547,44 +462,35 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         check (id_to_ty_item.contains_key(id));\n \n         auto it = id_to_ty_item.get(id);\n-        auto ty;\n-        auto params;\n+        auto tpt;\n         alt (it) {\n             case (any_item_rust(?item)) {\n-                ty = ty_of_item(sess, id_to_ty_item, item_to_ty, item);\n-                ty = actual_type(ty, item);\n-                params = ty_params_of_item(item);\n+                tpt = ty_of_item(sess, id_to_ty_item, type_cache, item);\n             }\n             case (any_item_native(?native_item, ?abi)) {\n-                ty = ty_of_native_item(sess, id_to_ty_item, item_to_ty,\n-                                       native_item, abi);\n-                params = ty_params_of_native_item(native_item);\n+                tpt = ty_of_native_item(sess, id_to_ty_item, type_cache,\n+                                        native_item, abi);\n             }\n         }\n \n-        let vec[ast.def_id] param_ids = vec();\n-        for (ast.ty_param tp in params) {\n-            param_ids += vec(tp.id);\n-        }\n-\n-        ret tup(param_ids, ty);\n+        ret tpt;\n     }\n \n     fn ty_of_arg(session.session sess,\n                  @ty_item_table id_to_ty_item,\n-                 @ty_table item_to_ty,\n+                 ty.type_cache type_cache,\n                  &ast.arg a) -> arg {\n-        auto f = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+        auto f = bind getter(sess, id_to_ty_item, type_cache, _);\n         ret rec(mode=a.mode, ty=ast_ty_to_ty(f, a.ty));\n     }\n \n     fn ty_of_method(session.session sess,\n                     @ty_item_table id_to_ty_item,\n-                    @ty_table item_to_ty,\n+                    ty.type_cache type_cache,\n                     &@ast.method m) -> method {\n-        auto get = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+        auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n-        auto f = bind ty_of_arg(sess, id_to_ty_item, item_to_ty, _);\n+        auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n         auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n@@ -593,77 +499,91 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     fn ty_of_obj(session.session sess,\n                  @ty_item_table id_to_ty_item,\n-                 @ty_table item_to_ty,\n+                 ty.type_cache type_cache,\n                  &ast.ident id,\n-                 &ast._obj obj_info) -> @ty.t {\n-        auto f = bind ty_of_method(sess, id_to_ty_item, item_to_ty, _);\n+                 &ast._obj obj_info,\n+                 vec[ast.ty_param] ty_params) -> ty.ty_params_opt_and_ty {\n+        auto f = bind ty_of_method(sess, id_to_ty_item, type_cache, _);\n         auto methods =\n             _vec.map[@ast.method,method](f, obj_info.methods);\n \n         auto t_obj = @rec(struct=ty.ty_obj(ty.sort_methods(methods)),\n                           cname=some[str](id));\n-        ret t_obj;\n+        auto params = ty_params_to_def_ids(ty_params);\n+        auto params_opt = some[vec[ast.def_id]](params);\n+        ret tup(params_opt, t_obj);\n     }\n \n     fn ty_of_obj_ctor(session.session sess,\n                       @ty_item_table id_to_ty_item,\n-                      @ty_table item_to_ty,\n+                      ty.type_cache type_cache,\n                       &ast.ident id,\n-                      &ast._obj obj_info) -> @ty.t {\n-        auto t_obj = ty_of_obj(sess, id_to_ty_item, item_to_ty,\n-                               id, obj_info);\n+                      &ast._obj obj_info,\n+                      ast.def_id obj_ty_id,\n+                      vec[ast.ty_param] ty_params)\n+            -> ty.ty_params_opt_and_ty {\n+        auto t_obj = ty_of_obj(sess, id_to_ty_item, type_cache,\n+                               id, obj_info, ty_params);\n         let vec[arg] t_inputs = vec();\n         for (ast.obj_field f in obj_info.fields) {\n-            auto g = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+            auto g = bind getter(sess, id_to_ty_item, type_cache, _);\n             auto t_field = ast_ty_to_ty(g, f.ty);\n             _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n-        auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj));\n-        ret t_fn;\n+\n+        type_cache.insert(obj_ty_id, t_obj);\n+\n+        auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj._1));\n+        ret tup(t_obj._0, t_fn);\n     }\n \n     fn ty_of_item(session.session sess,\n                   @ty_item_table id_to_ty_item,\n-                  @ty_table item_to_ty,\n-                  @ast.item it) -> @ty.t {\n+                  ty.type_cache type_cache,\n+                  @ast.item it) -> ty.ty_params_opt_and_ty {\n \n-        auto get = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+        auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n \n         alt (it.node) {\n \n             case (ast.item_const(?ident, ?t, _, ?def_id, _)) {\n-                item_to_ty.insert(def_id, convert(t));\n+                auto typ = convert(t);\n+                type_cache.insert(def_id, tup(none[vec[ast.def_id]], typ));\n             }\n \n-            case (ast.item_fn(?ident, ?fn_info, _, ?def_id, _)) {\n-                auto f = bind ty_of_arg(sess, id_to_ty_item, item_to_ty, _);\n-                ret ty_of_fn_decl(id_to_ty_item, item_to_ty, convert,\n-                                  f, fn_info.decl, fn_info.proto, def_id);\n+            case (ast.item_fn(?ident, ?fn_info, ?tps, ?def_id, _)) {\n+                auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n+                ret ty_of_fn_decl(id_to_ty_item, type_cache, convert, f,\n+                                  fn_info.decl, fn_info.proto, tps, def_id);\n             }\n \n-            case (ast.item_obj(?ident, ?obj_info, _, ?def_id, _)) {\n-                // TODO: handle ty-params\n+            case (ast.item_obj(?ident, ?obj_info, ?tps, ?odid, _)) {\n                 auto t_ctor = ty_of_obj_ctor(sess,\n                                              id_to_ty_item,\n-                                             item_to_ty,\n+                                             type_cache,\n                                              ident,\n-                                             obj_info);\n-                item_to_ty.insert(def_id, t_ctor);\n-                ret t_ctor;\n+                                             obj_info,\n+                                             odid.ty,\n+                                             tps);\n+                type_cache.insert(odid.ctor, t_ctor);\n+                ret type_cache.get(odid.ty);\n             }\n \n-            case (ast.item_ty(?ident, ?ty, _, ?def_id, _)) {\n-                if (item_to_ty.contains_key(def_id)) {\n+            case (ast.item_ty(?ident, ?ty, ?tps, ?def_id, _)) {\n+                if (type_cache.contains_key(def_id)) {\n                     // Avoid repeating work.\n-                    ret item_to_ty.get(def_id);\n+                    ret type_cache.get(def_id);\n                 }\n \n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n-                auto ty_ = convert(ty);\n-                item_to_ty.insert(def_id, ty_);\n-                ret ty_;\n+                auto typ = convert(ty);\n+                auto params = ty_params_to_def_ids(tps);\n+                auto params_opt = some[vec[ast.def_id]](params);\n+                auto tpt = tup(params_opt, typ);\n+                type_cache.insert(def_id, tpt);\n+                ret tpt;\n             }\n \n             case (ast.item_tag(_, _, ?tps, ?def_id)) {\n@@ -673,8 +593,12 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     subtys += vec(plain_ty(ty.ty_param(tp.id)));\n                 }\n                 auto t = plain_ty(ty.ty_tag(def_id, subtys));\n-                item_to_ty.insert(def_id, t);\n-                ret t;\n+\n+                auto params = ty_params_to_def_ids(tps);\n+                auto params_opt = some[vec[ast.def_id]](params);\n+                auto tpt = tup(params_opt, t);\n+                type_cache.insert(def_id, tpt);\n+                ret tpt;\n             }\n \n             case (ast.item_mod(_, _, _)) { fail; }\n@@ -684,33 +608,35 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     fn ty_of_native_item(session.session sess,\n                          @ty_item_table id_to_ty_item,\n-                         @ty_table item_to_ty,\n+                         ty.type_cache type_cache,\n                          @ast.native_item it,\n-                         ast.native_abi abi) -> @ty.t {\n+                         ast.native_abi abi) -> ty.ty_params_opt_and_ty {\n         alt (it.node) {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n                                      ?params, ?def_id, _)) {\n-                auto get = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+                auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n                 auto convert = bind ast_ty_to_ty(get, _);\n-                auto f = bind ty_of_arg(sess, id_to_ty_item, item_to_ty, _);\n-                ret ty_of_native_fn_decl(id_to_ty_item, item_to_ty,\n-                                         convert, f, fn_decl, abi, def_id);\n+                auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n+                ret ty_of_native_fn_decl(id_to_ty_item, type_cache, convert,\n+                                         f, fn_decl, abi, params, def_id);\n             }\n             case (ast.native_item_ty(_, ?def_id)) {\n-                if (item_to_ty.contains_key(def_id)) {\n+                if (type_cache.contains_key(def_id)) {\n                     // Avoid repeating work.\n-                    ret item_to_ty.get(def_id);\n+                    ret type_cache.get(def_id);\n                 }\n-                auto x = @rec(struct=ty.ty_native, cname=none[str]);\n-                item_to_ty.insert(def_id, x);\n-                ret x;\n+\n+                auto t = @rec(struct=ty.ty_native, cname=none[str]);\n+                auto tpt = tup(none[vec[ast.def_id]], t);\n+                type_cache.insert(def_id, tpt);\n+                ret tpt;\n             }\n         }\n     }\n \n     fn get_tag_variant_types(session.session sess,\n                              @ty_item_table id_to_ty_item,\n-                             @ty_table item_to_ty,\n+                             ty.type_cache type_cache,\n                              &ast.def_id tag_id,\n                              &vec[ast.variant] variants,\n                              &vec[ast.ty_param] ty_params)\n@@ -723,6 +649,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             ty_param_tys += vec(plain_ty(ty.ty_param(tp.id)));\n         }\n \n+        auto params = ty_params_to_def_ids(ty_params);\n+        auto params_opt = some[vec[ast.def_id]](params);\n+\n         for (ast.variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n@@ -732,7 +661,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n-                auto f = bind getter(sess, id_to_ty_item, item_to_ty, _);\n+                auto f = bind getter(sess, id_to_ty_item, type_cache, _);\n \n                 let vec[arg] args = vec();\n                 for (ast.variant_arg va in variant.args) {\n@@ -743,7 +672,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 result_ty = plain_ty(ty.ty_fn(ast.proto_fn, args, tag_t));\n             }\n \n-            item_to_ty.insert(variant.id, result_ty);\n+            auto tpt = tup(params_opt, result_ty);\n+            type_cache.insert(variant.id, tpt);\n \n             auto variant_t = rec(\n                 ann=ast.ann_type(result_ty, none[vec[@ty.t]])\n@@ -767,8 +697,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             case (ast.item_tag(_, _, _, ?def_id)) {\n                 id_to_ty_item.insert(def_id, any_item_rust(i));\n             }\n-            case (ast.item_obj(_, _, _, ?def_id, _)) {\n-                id_to_ty_item.insert(def_id, any_item_rust(i));\n+            case (ast.item_obj(_, _, _, ?odid, _)) {\n+                id_to_ty_item.insert(odid.ty, any_item_rust(i));\n             }\n             case (_) { /* empty */ }\n         }\n@@ -797,30 +727,17 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n \n     // Second pass: translate the types of all items.\n-    let @ty_table item_to_ty = @common.new_def_hash[@ty.t]();\n-    auto item_ty_params = @common.new_def_hash[vec[ast.def_id]]();\n+    auto type_cache = common.new_def_hash[ty.ty_params_opt_and_ty]();\n \n     type env = rec(session.session sess,\n                    @ty_item_table id_to_ty_item,\n-                   @ty_table item_to_ty,\n-                   @ty_param_table item_ty_params,\n+                   ty.type_cache type_cache,\n                    ast.native_abi abi);\n     let @env e = @rec(sess=sess,\n                       id_to_ty_item=id_to_ty_item,\n-                      item_to_ty=item_to_ty,\n-                      item_ty_params=item_ty_params,\n+                      type_cache=type_cache,\n                       abi=ast.native_abi_cdecl);\n \n-    // Inserts the given type parameters into the type parameter table of the\n-    // environment.\n-    fn collect_ty_params(&@env e, &ast.def_id id, vec[ast.ty_param] tps) {\n-        let vec[ast.def_id] result = vec();\n-        for (ast.ty_param tp in tps) {\n-            result += vec(tp.id);\n-        }\n-        e.item_ty_params.insert(id, result);\n-    }\n-\n     fn convert(&@env e, @ast.item i) -> @env {\n         auto abi = e.abi;\n         alt (i.node) {\n@@ -834,22 +751,22 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             case (_) {\n                 // This call populates the ty_table with the converted type of\n                 // the item in passing; we don't need to do anything else.\n-                ty_of_item(e.sess, e.id_to_ty_item, e.item_to_ty, i);\n+                ty_of_item(e.sess, e.id_to_ty_item, e.type_cache, i);\n             }\n         }\n         ret @rec(abi=abi with *e);\n     }\n \n     fn convert_native(&@env e, @ast.native_item i) -> @env {\n-        ty_of_native_item(e.sess, e.id_to_ty_item, e.item_to_ty, i, e.abi);\n+        ty_of_native_item(e.sess, e.id_to_ty_item, e.type_cache, i, e.abi);\n         ret e;\n     }\n \n     fn fold_item_const(&@env e, &span sp, ast.ident i,\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.item_to_ty.contains_key(id));\n-        auto typ = e.item_to_ty.get(id);\n+        check (e.type_cache.contains_key(id));\n+        auto typ = e.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id,\n                                    ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -858,10 +775,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        collect_ty_params(e, id, ty_params);\n-\n-        check (e.item_to_ty.contains_key(id));\n-        auto typ = e.item_to_ty.get(id);\n+        check (e.type_cache.contains_key(id));\n+        auto typ = e.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id,\n                                 ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -870,10 +785,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n-        collect_ty_params(e, id, ty_params);\n-\n-        check (e.item_to_ty.contains_key(id));\n-        auto typ = e.item_to_ty.get(id);\n+        check (e.type_cache.contains_key(id));\n+        auto typ = e.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.native_item_](sp, item);\n@@ -902,11 +815,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n-                    ast.def_id id, ast.ann a) -> @ast.item {\n-        collect_ty_params(e, id, ty_params);\n-\n-        check (e.item_to_ty.contains_key(id));\n-        auto t = e.item_to_ty.get(id);\n+                    ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n+        check (e.type_cache.contains_key(odid.ctor));\n+        auto t = e.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(t);\n         let vec[@ast.method] methods = vec();\n         let vec[ast.obj_field] fields = vec();\n@@ -928,7 +839,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             m = @rec(node=m_ with *meth);\n             _vec.push[@ast.method](methods, m);\n         }\n-        auto g = bind getter(e.sess, e.id_to_ty_item, e.item_to_ty, _);\n+        auto g = bind getter(e.sess, e.id_to_ty_item, e.type_cache, _);\n         for (ast.obj_field fld in ob.fields) {\n             let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n             let ast.obj_field f = rec(\n@@ -941,18 +852,16 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto ob_ = rec(methods = methods,\n                        fields = fields\n                        with ob);\n-        auto item = ast.item_obj(i, ob_, ty_params, id,\n+        auto item = ast.item_obj(i, ob_, ty_params, odid,\n                                  ast.ann_type(t, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        collect_ty_params(e, id, ty_params);\n-\n-        check (e.item_to_ty.contains_key(id));\n-        auto typ = e.item_to_ty.get(id);\n+        check (e.type_cache.contains_key(id));\n+        auto typ = e.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id,\n                                 ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -962,11 +871,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                      vec[ast.variant] variants,\n                      vec[ast.ty_param] ty_params,\n                      ast.def_id id) -> @ast.item {\n-        collect_ty_params(e, id, ty_params);\n-\n         auto variants_t = get_tag_variant_types(e.sess,\n                                                 e.id_to_ty_item,\n-                                                e.item_to_ty,\n+                                                e.type_cache,\n                                                 id,\n                                                 variants,\n                                                 ty_params);\n@@ -986,7 +893,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n              fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_)\n              with *fld_2);\n     auto crate_ = fold.fold_crate[@env](e, fld_2, crate);\n-    ret tup(crate_, item_to_ty, id_to_ty_item, item_ty_params);\n+    ret tup(crate_, type_cache, id_to_ty_item);\n }\n \n fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n@@ -1139,9 +1046,15 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n \n+            // FIXME: This is probably more convoluted than it has to be.\n+            // Refactor to use the type cache.\n+\n             // Figure out the type parameters of the tag.\n             auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n-            auto ty_params = fcx.ccx.item_ty_params.get(tag_id);\n+\n+            auto tpt = ty.lookup_generic_item_type(fcx.ccx.sess,\n+                fcx.ccx.type_cache, tag_id);\n+            auto ty_params = tpt._0;\n \n             // Take the type parameters out of the expected type.\n             auto ty_param_substs;\n@@ -1161,7 +1074,9 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n             // variants.\n \n             auto vdef = option.get[ast.variant_def](vdef_opt);\n-            auto variant_ty = fcx.ccx.item_types.get(vdef._1);\n+            auto variant_ty = ty.lookup_item_type(fcx.ccx.sess,\n+                                                  fcx.ccx.type_cache,\n+                                                  vdef._1)._1;\n \n             auto subpats_len = _vec.len[@ast.pat](subpats);\n             alt (variant_ty.struct) {\n@@ -1598,13 +1513,13 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n-            auto t = fcx.ccx.item_types.get(vdef._1);\n+            auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache,\n+                                         vdef._1)._1;\n             auto len = _vec.len[ast.ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n-            auto ty_params = fcx.ccx.item_ty_params.get(vdef._0);\n-            auto tag_ty = fcx.ccx.item_types.get(vdef._0);\n-            auto tpt = tup(some(ty_params), tag_ty);\n+            auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache,\n+                                           vdef._0);\n             auto ann = instantiate_path(fcx, p, tpt, pat.span);\n \n             alt (t.struct) {\n@@ -2673,15 +2588,17 @@ fn update_obj_fields(&@crate_ctxt ccx, @ast.item i) -> @crate_ctxt {\n     ret ccx;\n }\n \n-fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n+\n+type typecheck_result = tup(@ast.crate, ty.type_cache);\n+\n+fn check_crate(session.session sess, @ast.crate crate) -> typecheck_result {\n     auto result = collect_item_types(sess, crate);\n \n     let vec[ast.obj_field] fields = vec();\n \n     auto ccx = @rec(sess=sess,\n-                    item_types=result._1,\n+                    type_cache=result._1,\n                     item_items=result._2,\n-                    item_ty_params=result._3,\n                     obj_fields=fields,\n                     mutable next_var_id=0);\n \n@@ -2691,7 +2608,9 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n                fold_fn      = bind check_fn(_,_,_,_),\n                fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n                with *fld);\n-    ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);\n+\n+    auto crate_1 = fold.fold_crate[@crate_ctxt](ccx, fld, result._0);\n+    ret tup(crate_1, ccx.type_cache);\n }\n \n //"}]}