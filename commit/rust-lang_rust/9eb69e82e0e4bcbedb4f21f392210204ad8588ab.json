{"sha": "9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "node_id": "C_kwDOAAsO6NoAKDllYjY5ZTgyZTBlNGJjYmVkYjRmMjFmMzkyMjEwMjA0YWQ4NTg4YWI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-27T11:37:10Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-10-07T19:43:46Z"}, "message": "Move ReverseMapper logic onto OpaqueHiddenType", "tree": {"sha": "f68b031cf2ce7d9fd5b44373de6f4e0f6ed0826f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f68b031cf2ce7d9fd5b44373de6f4e0f6ed0826f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "html_url": "https://github.com/rust-lang/rust/commit/9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d643ae1bbf4da44c00c2aff87cb3081a93ec44bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d643ae1bbf4da44c00c2aff87cb3081a93ec44bb", "html_url": "https://github.com/rust-lang/rust/commit/d643ae1bbf4da44c00c2aff87cb3081a93ec44bb"}], "stats": {"total": 480, "additions": 247, "deletions": 233}, "files": [{"sha": "aa751927ba7135683b46f80b31fff36f8f8a7080", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 224, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "patch": "@@ -5,8 +5,7 @@ use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n@@ -15,8 +14,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n-use crate::session_diagnostics::ConstNotUsedTraitAlias;\n-\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -228,29 +225,9 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            map,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n+        let definition_ty = instantiated_ty\n+            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx)\n+            .ty;\n \n         if !check_opaque_type_parameter_valid(\n             self.tcx,\n@@ -266,6 +243,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let OpaqueTyOrigin::TyAlias = origin else {\n             return definition_ty;\n         };\n+        let def_id = opaque_type_key.def_id;\n         // This logic duplicates most of `check_opaque_meets_bounds`.\n         // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n         let param_env = self.tcx.param_env(def_id);\n@@ -281,6 +259,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             .to_predicate(infcx.tcx);\n         let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n+\n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n         match infcx.register_hidden_type(\n@@ -421,200 +401,3 @@ fn check_opaque_type_parameter_valid(\n     }\n     true\n }\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    do_not_error: bool,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        span: Span,\n-    ) -> Self {\n-        Self { tcx, map, do_not_error: false, span }\n-    }\n-\n-    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        self.do_not_error = true;\n-        let kind = kind.fold_with(self);\n-        self.do_not_error = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n-\n-            ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.do_not_error => self.tcx.lifetimes.re_static,\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n-                            ct: ct.to_string(),\n-                            span: self.span,\n-                        });\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}"}, {"sha": "ff667896eb1076244981405606ffa01ee5cc3141", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "patch": "@@ -52,15 +52,6 @@ pub(crate) struct VarNeedNotMut {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(borrowck::const_not_used_in_type_alias)]\n-pub(crate) struct ConstNotUsedTraitAlias {\n-    pub ct: String,\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(borrowck::var_cannot_escape_closure)]\n #[note]"}, {"sha": "ffade628e53b5f645ce1fb93dc4810f55ef441ef", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "patch": "@@ -511,3 +511,11 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck::const_not_used_in_type_alias)]\n+pub(super) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "7438a58be71dc7c593152e53bbe23daba5d98275", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "patch": "@@ -131,6 +131,7 @@ mod generics;\n mod impls_ty;\n mod instance;\n mod list;\n+mod opaque_types;\n mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n@@ -1300,6 +1301,32 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n             sub: sub_diag,\n         });\n     }\n+\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n+    pub fn remap_generic_params_to_declaration_params(\n+        self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Self {\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        debug!(?id_substs);\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        self.fold_with(&mut opaque_types::ReverseMapper::new(tcx, map, self.span))\n+    }\n }\n \n /// The \"placeholder index\" fully defines a placeholder region, type, or const. Placeholders are"}, {"sha": "9bea4e431224cbe41626f852e06aab0785572611", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb69e82e0e4bcbedb4f21f392210204ad8588ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=9eb69e82e0e4bcbedb4f21f392210204ad8588ab", "patch": "@@ -0,0 +1,205 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::Span;\n+\n+/// Converts generic params of a TypeFoldable from one\n+/// item's generics to another. Usually from a function's generics\n+/// list to the opaque type's own generics.\n+pub(super) struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+    do_not_error: bool,\n+\n+    /// Span of function being checked.\n+    span: Span,\n+}\n+\n+impl<'tcx> ReverseMapper<'tcx> {\n+    pub(super) fn new(\n+        tcx: TyCtxt<'tcx>,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+        span: Span,\n+    ) -> Self {\n+        Self { tcx, map, do_not_error: false, span }\n+    }\n+\n+    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        self.do_not_error = true;\n+        let kind = kind.fold_with(self);\n+        self.do_not_error = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaration.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n+\n+            ty::RePlaceholder(_) | ty::ReVar(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n+        }\n+\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.do_not_error => self.tcx.lifetimes.re_static,\n+            None => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        self.span,\n+                        format!(\n+                            \"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of the `impl Trait` type alias\",\n+                            r\n+                        ),\n+                    )\n+                    .emit();\n+\n+                self.tcx().lifetimes.re_static\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Closure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an opaque type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during codegen.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_no_missing_regions_error(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_closure(def_id, substs)\n+            }\n+\n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_no_missing_regions_error(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_generator(def_id, substs, movability)\n+            }\n+\n+            ty::Param(param) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        debug!(?param, ?self.map);\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ty\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().ty_error()\n+                    }\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.kind() {\n+            ty::ConstKind::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx.sess.emit_err(ty::ConstNotUsedTraitAlias {\n+                            ct: ct.to_string(),\n+                            span: self.span,\n+                        });\n+\n+                        self.tcx().const_error(ct.ty())\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n+}"}]}