{"sha": "4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODFlNjZiNDRmNmU3ZGJiZDg3NDFiNTYyZWE3ZjZhYzRkNzk5YmM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-23T21:05:43Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-23T21:05:43Z"}, "message": "Rollup merge of #22954 - ches:docs, r=steveklabnik\n\nGreetings Rustaceans!\r\n\r\nI've just been getting acquainted with Rust through the guide. First let me say that it's already in great shape, chapters are kept a good length to be digestible and paced to move the reader along fluidly, so my compliments to contributors!\r\n\r\nAlong the way I noticed a few minor copy errors, and also a few areas that I thought more subjectively could stand to be improved. My commits here are divided so that minor edits unlikely to be very contentious could be cherry-picked, and then topically on parts that might generate more discussion.\r\n\r\nI also have some comments and questions that aren't directly associated with any changes on this branch yet. I'm not sure how you like to triage this sort of thing but I'll present them below and if it's appropriate they could be moved to separate issues or I might be able to help work some of them out within the scope of this PR. Sorry that these are a lot to take in, pretty much everything below here can be digested independently of the current changes in this PR so you could read the rest later :smile:\r\n\r\n### Questions and Comments\r\n\r\nI'll give stable links to doc revisions as of this writing.\r\n\r\n1. The [example using `PartialEq` in the Traits chapter][1] is poor\u2014we have no idea how `PartialEq` works at this point in the text (or at any point, AFAICT), so it isn't clear why it won't work as a trait bound in this situation and `Float` almost magically does, with the aid of existing tailor-made identity functions that seem unlikely to be so conveniently available when we encounter a scenario like this in our real-world code.\r\n\r\n   This section just seems glossed over, or perhaps content has moved around over time or there's an assumption that implementing equality with `PartialEq` should be covered in the guide eventually so this example will be less foreign. As it stands the text is hard to follow and not very meaningful.\r\n2. I found treatment of the relationship of trait objects to pointers in the *Static and Dynamic Dispatch* chapter unclear. [The \"Why Pointers?\" section][2] opens with this line:\r\n\r\n   > The use of language like \"fat pointer\" implies that a trait object is always a pointer of some form, but why?\r\n\r\n   But the phrase \"fat pointer\" hasn't been used anywhere before. This is some of the more complex material in the guide, but this section nevertheless feels displaced, not clearly connecting preceding subject matter. Earlier we've covered the internal representation of trait objects and significance of pointers they contain, but it hasn't been spelled out (other than what `&Foo` syntax suggests) that trait objects are references (and why). That's what the \"Why Pointers?\" section is aiming to do I gather, but it seems out of place, I think it'd make more sense to cover this before the gory details of their internals.\r\n3. Suggestion: move the *Error Handling* chapter much earlier in the Intermediate section of the guide, or even into the Basics section. I know the Intermediate section isn't intended to be read in order per se, but plenty of people like me are just going to read it straight through anyway :grin: These are pretty fundamental concepts to understand and `Option`, `Result`, and idioms like `unwrap()` and `.ok().expect()` are referenced numerous times throughout the rest of the guide. They feature pretty prominently as early as *Standard Input* and *Guessing Game* chapters in Basics, in fact. I happen to have a good understanding of these already through encountering their analogs in typed functional languages, but if I didn't I believe I really would have appreciated reading *Error Handling* much earlier.\r\n4. In the `rustdoc` chapter, a [comment at the beginning of the first source example][3] refers to a \"link\" crate attribute being needed. There seems to be no such attribute present in the source. I believe this refers to `crate_type` [according to the reference][4], but it'd be nice if this example were updated/clarified (I think `crate_id` is deprecated/obsolete too).\r\n\r\n   This brings me to a related comment also: after encountering crate attributes in the reference and also docs on Cargo configuration like `crate-type = [\"dylib\"]`, I'm uncertain about the relationship/redundancy between these. I'm sure this is the kind of thing where docs are simply struggling to keep pace with rapid changes in Rust and Cargo, just wanted to flag that this distinction ought to be clearly covered in the docs for one or the other at some point, it's presently hard to track down.\r\n5. Minor: link to sample editor configurations in [the introductory chapter][5] is broken, probably the generator automatically translates `.md` links to `.html`. Perhaps it shouldn't do that for absolute URLs.\r\n6. Following from my changes to the enums coverage in [*Compound Data Types*][6] in this PR: sum types are an important topic and I tried to make some improvements, but I think the motivating example of `Character` with `Digit(i32)` and `Other` variants is a pretty weak one, and a better example could greatly improve cohesion with the `Ordering` coverage later in the section and how that ties into pattern matching in the subsequent chapter. I just haven't thought of a better example to suggest yet.\r\n\r\n   In particular, the text states:\r\n\r\n   > This may seem rather limiting, but it's a limitation which we can overcome.\r\n\r\n   This is referring to `Character`, and actually to more than one limitation: the preceding admonition that its variants aren't comparable/don't have ordering, and don't support binary operators like `*` and `+`. Overcoming these limitations actually never gets explained\u2014we next cover how `Ordering` works as an enum itself for plain `i32`s, but never get around to showing how this might be applied to our `Digit` variant type.\r\n\r\n   Since the coverage of enums already segues into pattern matching and this could be even tighter with a stronger example, it might be nice if our example enum were somehow connected to the final example program for the Basics section too, where `Ordering` reappears. I don't see how it would fit with the current guessing game example, but food for thought.\r\n7. `#[derive]` seems conspicuously missing from the guide. It would probably make sense to introduce after showing simple examples of implementing equality and/or ordering traits by hand, which have been mentioned as possibilities above. Perhaps it's too much to breach this as early as the Basic section though without traits being introduced. `#[derive]` itself and the derivable traits can certainly be saved for Intermediate and referenced as covered later, in any case.\r\n\r\nr? @steveklabnik for docs.\r\n\r\n[1]: https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src/doc/trpl/traits.md#our-inverse-example\r\n[2]: https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src/doc/trpl/static-and-dynamic-dispatch.md#why-pointers\r\n[3]: https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src/doc/trpl/documentation.md#creating-documentation\r\n[4]: http://doc.rust-lang.org/reference.html#linkage\r\n[5]: https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src/doc/trpl/hello-world.md\r\n[6]: https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src/doc/trpl/compound-data-types.md#enums", "tree": {"sha": "4549168a264b813324b9c07c6e462a6fbe565393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4549168a264b813324b9c07c6e462a6fbe565393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "html_url": "https://github.com/rust-lang/rust/commit/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809a554fca2d0ebc2ba50077016fe282a4064752", "url": "https://api.github.com/repos/rust-lang/rust/commits/809a554fca2d0ebc2ba50077016fe282a4064752", "html_url": "https://github.com/rust-lang/rust/commit/809a554fca2d0ebc2ba50077016fe282a4064752"}, {"sha": "92294e7aedf26c1b276b4a721e18b7a43217848d", "url": "https://api.github.com/repos/rust-lang/rust/commits/92294e7aedf26c1b276b4a721e18b7a43217848d", "html_url": "https://github.com/rust-lang/rust/commit/92294e7aedf26c1b276b4a721e18b7a43217848d"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "d531a22d0e0dd55d2b2a0d5d913b88f9d3912c73", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "patch": "@@ -47,7 +47,7 @@ This pattern is very powerful, and we'll see it repeated more later.\n \n There are also a few things you can do with a tuple as a whole, without\n destructuring. You can assign one tuple into another, if they have the same\n-contained types and arity. Tuples have the same arity when they have the same\n+contained types and [arity]. Tuples have the same arity when they have the same\n length.\n \n ```rust\n@@ -196,8 +196,9 @@ Now, we have actual names, rather than positions. Good names are important,\n and with a struct, we have actual names.\n \n There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this a *newtype*, because it lets\n-you create a new type that's similar to another one:\n+tuple struct with only one element. We call this the *newtype* pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n \n ```{rust}\n struct Inches(i32);\n@@ -216,7 +217,7 @@ destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n \n Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which ties a set of alternates to a specific name. For example, below\n+a type which relates a set of alternates to a specific name. For example, below\n we define `Character` to be either a `Digit` or something else. These\n can be used via their fully scoped names: `Character::Other` (more about `::`\n below).\n@@ -228,8 +229,8 @@ enum Character {\n }\n ```\n \n-An `enum` variant can be defined as most normal types. Below are some example\n-types which also would be allowed in an `enum`.\n+Most normal types are allowed as the variant components of an `enum`. Here are\n+some examples:\n \n ```rust\n struct Empty;\n@@ -239,15 +240,15 @@ struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n-So you see that depending on the sub-datastructure, the `enum` variant, same as\n-a struct, may or may not hold data. That is, in `Character`, `Digit` is a name\n-tied to an `i32` where `Other` is just a name. However, the fact that they are\n-distinct makes this very useful.\n+You see that, depending on its type, an `enum` variant may or may not hold data.\n+In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n+value, where `Other` is only a name. However, the fact that they represent\n+distinct categories of `Character` is a very useful property.\n \n-As with structures, enums don't by default have access to operators such as\n-compare ( `==` and `!=`), binary operations (`*` and `+`), and order\n-(`<` and `>=`). As such, using the previous `Character` type, the\n-following code is invalid:\n+As with structures, the variants of an enum by default are not comparable with\n+equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n+support other binary operations such as `*` and `+`. As such, the following code\n+is invalid for the example `Character` type:\n \n ```{rust,ignore}\n // These assignments both succeed\n@@ -265,9 +266,10 @@ let four_equals_ten = four == ten;\n ```\n \n This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by using the\n-[`match`][match] keyword. We don't know enough about Rust to implement equality\n-yet, but we can use the `Ordering` enum from the standard library, which does:\n+There are two ways: by implementing equality ourselves, or by pattern matching\n+variants with [`match`][match] expressions, which you'll learn in the next\n+chapter. We don't know enough about Rust to implement equality yet, but we can\n+use the `Ordering` enum from the standard library, which does:\n \n ```\n enum Ordering {\n@@ -277,9 +279,8 @@ enum Ordering {\n }\n ```\n \n-Because we did not define `Ordering`, we must import it (from the std\n-library) with the `use` keyword. Here's an example of how `Ordering` is\n-used:\n+Because `Ordering` has already been defined for us, we will import it with the\n+`use` keyword. Here's an example of how it is used:\n \n ```{rust}\n use std::cmp::Ordering;\n@@ -313,17 +314,17 @@ the standard library if you need them.\n \n Okay, let's talk about the actual code in the example. `cmp` is a function that\n compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n-the two values are less, greater, or equal. Note that each variant of the\n-`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n-`Greater`.\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n+whether the first value is less than, greater than, or equal to the second. Note\n+that each variant of the `enum` is namespaced under the `enum` itself: it's\n+`Ordering::Greater`, not `Greater`.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n three values. We then do a bunch of `if`/`else` comparisons to check which\n one it is.\n \n-This `Ordering::Greater` notation is too long. Let's use `use` to import the\n-`enum` variants instead. This will avoid full scoping:\n+This `Ordering::Greater` notation is too long. Let's use another form of `use`\n+to import the `enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n use std::cmp::Ordering::{self, Equal, Less, Greater};\n@@ -347,16 +348,18 @@ fn main() {\n ```\n \n Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. It's considered good style to rarely import variants\n-for this reason.\n+so do this with caution. For this reason, it's normally considered better style\n+to `use` an enum rather than its variants directly.\n \n-As you can see, `enum`s are quite a powerful tool for data representation, and are\n-even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use them with pattern matching, a\n-tool that will let us deconstruct this sum type (the type theory term for enums)\n-in a very elegant way and avoid all these messy `if`/`else`s.\n+As you can see, `enum`s are quite a powerful tool for data representation, and\n+are even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use enums with pattern\n+matching, a tool that will let us deconstruct sum types (the type theory term\n+for enums) like `Ordering` in a very elegant way that avoids all these messy\n+and brittle `if`/`else`s.\n \n \n+[arity]: ./glossary.html#arity\n [match]: ./match.html\n [game]: ./guessing-game.html#comparing-guesses\n [generics]: ./generics.html"}, {"sha": "5d301cc0aef6ebbd31d1b78148ade07f75cdfd80", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "patch": "@@ -40,14 +40,14 @@ us enforce that it can't leave the current thread.\n \n ### `Sync`\n \n-The second of these two trait is called [`Sync`](../std/marker/trait.Sync.html).\n+The second of these traits is called [`Sync`](../std/marker/trait.Sync.html).\n When a type `T` implements `Sync`, it indicates to the compiler that something\n of this type has no possibility of introducing memory unsafety when used from\n multiple threads concurrently.\n \n For example, sharing immutable data with an atomic reference count is\n threadsafe. Rust provides a type like this, `Arc<T>`, and it implements `Sync`,\n-so that it could be safely shared between threads.\n+so it is safe to share between threads.\n \n These two traits allow you to use the type system to make strong guarantees\n about the properties of your code under concurrency. Before we demonstrate\n@@ -69,7 +69,7 @@ fn main() {\n }\n ```\n \n-The `Thread::scoped()` method accepts a closure, which is executed in a new\n+The `thread::scoped()` method accepts a closure, which is executed in a new\n thread. It's called `scoped` because this thread returns a join guard:\n \n ```\n@@ -208,10 +208,10 @@ Here's the error:\n \n ```text\n <anon>:11:9: 11:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n-<anon>:11         Thread::spawn(move || {\n+<anon>:11         thread::spawn(move || {\n                   ^~~~~~~~~~~~~\n <anon>:11:9: 11:22 note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n-<anon>:11         Thread::spawn(move || {\n+<anon>:11         thread::spawn(move || {\n                   ^~~~~~~~~~~~~\n ```\n \n@@ -322,7 +322,6 @@ While this channel is just sending a generic signal, we can send any data that\n is `Send` over the channel!\n \n ```\n-use std::sync::{Arc, Mutex};\n use std::thread;\n use std::sync::mpsc;\n "}, {"sha": "37785c030e6e5e4acc29b044690e1836089ffbef", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "patch": "@@ -430,7 +430,7 @@ fn main() {\n }\n ```\n \n-But it is not idiomatic. This is significantly more likely to introducing a\n+But it is not idiomatic. This is significantly more likely to introduce a\n naming conflict. In our short program, it's not a big deal, but as it grows, it\n becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do"}, {"sha": "228891f9f052b3a33a59c5f5862155f933562ce8", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=4a81e66b44f6e7dbbd8741b562ea7f6ac4d799bc", "patch": "@@ -115,8 +115,9 @@ doesn't work, so we're okay with that. In most cases, we would want to handle\n the error case explicitly. `expect()` allows us to give an error message if\n this crash happens.\n \n-We will cover the exact details of how all of this works later in the Guide.\n-For now, this gives you enough of a basic understanding to work with.\n+We will cover the exact details of how all of this works later in the Guide in\n+[Error Handling]. For now, this gives you enough of a basic understanding to\n+work with.\n \n Back to the code we were working on! Here's a refresher:\n \n@@ -157,3 +158,6 @@ here.\n \n That's all you need to get basic input from the standard input! It's not too\n complicated, but there are a number of small parts.\n+\n+\n+[Error Handling]: ./error-handling.html"}]}