{"sha": "a17de6980ac3289e2929da86f1e7259e83eef125", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExN2RlNjk4MGFjMzI4OWUyOTI5ZGE4NmYxZTcyNTllODNlZWYxMjU=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-03T18:59:43Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:10:24Z"}, "message": "Separate codepaths for fat and thin LTO in write.rs\n\nThese are going to have different intermediate artifacts, so\ncreate separate codepaths for them.", "tree": {"sha": "cb09e459dfcf7ea7b4f7a7db1a0bfc7957946376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb09e459dfcf7ea7b4f7a7db1a0bfc7957946376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17de6980ac3289e2929da86f1e7259e83eef125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17de6980ac3289e2929da86f1e7259e83eef125", "html_url": "https://github.com/rust-lang/rust/commit/a17de6980ac3289e2929da86f1e7259e83eef125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17de6980ac3289e2929da86f1e7259e83eef125/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "html_url": "https://github.com/rust-lang/rust/commit/2c1883c1a6c0e74cffb752bb36e735042b84d4fe"}], "stats": {"total": 83, "additions": 56, "deletions": 27}, "files": [{"sha": "aaaaf169f156026211f9a0b0af0fe62d14f78894", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a17de6980ac3289e2929da86f1e7259e83eef125/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17de6980ac3289e2929da86f1e7259e83eef125/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=a17de6980ac3289e2929da86f1e7259e83eef125", "patch": "@@ -252,30 +252,35 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n-    modules: Vec<ModuleCodegen<B::Module>>,\n+    needs_fat_lto: Vec<ModuleCodegen<B::Module>>,\n+    needs_thin_lto: Vec<ModuleCodegen<B::Module>>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n     let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n         tg.start(CODEGEN_WORKER_TIMELINE,\n                  CODEGEN_WORK_PACKAGE_KIND,\n                  \"generate lto\")\n     }).unwrap_or(Timeline::noop());\n-    let (lto_modules, copy_jobs) = B::run_lto(cgcx, modules, import_only_modules, &mut timeline)\n-        .unwrap_or_else(|e| e.raise());\n \n-    let lto_modules = lto_modules.into_iter().map(|module| {\n+    let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n+        assert!(needs_thin_lto.is_empty());\n+        B::run_lto(cgcx, needs_fat_lto, import_only_modules, &mut timeline)\n+            .unwrap_or_else(|e| e.raise())\n+    } else {\n+        assert!(needs_fat_lto.is_empty());\n+        B::run_lto(cgcx, needs_thin_lto, import_only_modules, &mut timeline)\n+            .unwrap_or_else(|e| e.raise())\n+    };\n+\n+    lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n         (WorkItem::LTO(module), cost)\n-    });\n-\n-    let copy_jobs = copy_jobs.into_iter().map(|wp| {\n+    }).chain(copy_jobs.into_iter().map(|wp| {\n         (WorkItem::CopyPostLtoArtifacts(CachedModuleCodegen {\n             name: wp.cgu_name.clone(),\n             source: wp,\n         }), 0)\n-    });\n-\n-    lto_modules.chain(copy_jobs).collect()\n+    })).collect()\n }\n \n pub struct CompiledModules {\n@@ -673,7 +678,8 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n \n enum WorkItemResult<M> {\n     Compiled(CompiledModule),\n-    NeedsLTO(ModuleCodegen<M>),\n+    NeedsFatLTO(ModuleCodegen<M>),\n+    NeedsThinLTO(ModuleCodegen<M>),\n }\n \n fn execute_work_item<B: ExtraBackendMethods>(\n@@ -757,12 +763,16 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         }\n     };\n \n-    if let ComputedLtoType::No = lto_type {\n-        let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config, timeline)? };\n-        Ok(WorkItemResult::Compiled(module))\n-    } else {\n-        Ok(WorkItemResult::NeedsLTO(module))\n-    }\n+    Ok(match lto_type {\n+        ComputedLtoType::No => {\n+            let module = unsafe {\n+                B::codegen(cgcx, &diag_handler, module, module_config, timeline)?\n+            };\n+            WorkItemResult::Compiled(module)\n+        }\n+        ComputedLtoType::Thin => WorkItemResult::NeedsThinLTO(module),\n+        ComputedLtoType::Fat => WorkItemResult::NeedsFatLTO(module),\n+    })\n }\n \n fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n@@ -844,7 +854,11 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n \n pub enum Message<B: WriteBackendMethods> {\n     Token(io::Result<Acquired>),\n-    NeedsLTO {\n+    NeedsFatLTO {\n+        result: ModuleCodegen<B::Module>,\n+        worker_id: usize,\n+    },\n+    NeedsThinLTO {\n         result: ModuleCodegen<B::Module>,\n         worker_id: usize,\n     },\n@@ -1143,7 +1157,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n-        let mut needs_lto = Vec::new();\n+        let mut needs_fat_lto = Vec::new();\n+        let mut needs_thin_lto = Vec::new();\n         let mut lto_import_only_modules = Vec::new();\n         let mut started_lto = false;\n         let mut codegen_aborted = false;\n@@ -1172,7 +1187,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n               running > 0 ||\n               (!codegen_aborted && (\n                   work_items.len() > 0 ||\n-                  needs_lto.len() > 0 ||\n+                  needs_fat_lto.len() > 0 ||\n+                  needs_thin_lto.len() > 0 ||\n                   lto_import_only_modules.len() > 0 ||\n                   main_thread_worker_state != MainThreadWorkerState::Idle\n               ))\n@@ -1218,12 +1234,17 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                    running == 0 &&\n                    main_thread_worker_state == MainThreadWorkerState::Idle {\n                     assert!(!started_lto);\n-                    assert!(needs_lto.len() + lto_import_only_modules.len() > 0);\n                     started_lto = true;\n-                    let modules = mem::replace(&mut needs_lto, Vec::new());\n+\n+                    let needs_fat_lto =\n+                        mem::replace(&mut needs_fat_lto, Vec::new());\n+                    let needs_thin_lto =\n+                        mem::replace(&mut needs_thin_lto, Vec::new());\n                     let import_only_modules =\n                         mem::replace(&mut lto_import_only_modules, Vec::new());\n-                    for (work, cost) in generate_lto_work(&cgcx, modules, import_only_modules) {\n+\n+                    for (work, cost) in generate_lto_work(&cgcx, needs_fat_lto,\n+                                                          needs_thin_lto, import_only_modules) {\n                         let insertion_index = work_items\n                             .binary_search_by_key(&cost, |&(_, cost)| cost)\n                             .unwrap_or_else(|e| e);\n@@ -1395,10 +1416,15 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         }\n                     }\n                 }\n-                Message::NeedsLTO { result, worker_id } => {\n+                Message::NeedsFatLTO { result, worker_id } => {\n                     assert!(!started_lto);\n                     free_worker(worker_id);\n-                    needs_lto.push(result);\n+                    needs_fat_lto.push(result);\n+                }\n+                Message::NeedsThinLTO { result, worker_id } => {\n+                    assert!(!started_lto);\n+                    free_worker(worker_id);\n+                    needs_thin_lto.push(result);\n                 }\n                 Message::AddImportOnlyModule { module_data, work_product } => {\n                     assert!(!started_lto);\n@@ -1496,8 +1522,11 @@ fn spawn_work<B: ExtraBackendMethods>(\n                     Some(WorkItemResult::Compiled(m)) => {\n                         Message::Done::<B> { result: Ok(m), worker_id }\n                     }\n-                    Some(WorkItemResult::NeedsLTO(m)) => {\n-                        Message::NeedsLTO::<B> { result: m, worker_id }\n+                    Some(WorkItemResult::NeedsFatLTO(m)) => {\n+                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                    }\n+                    Some(WorkItemResult::NeedsThinLTO(m)) => {\n+                        Message::NeedsThinLTO::<B> { result: m, worker_id }\n                     }\n                     None => Message::Done::<B> { result: Err(()), worker_id }\n                 };"}]}