{"sha": "79252ff4e25d82f9fe856cb66f127b79cdace163", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MjUyZmY0ZTI1ZDgyZjlmZTg1NmNiNjZmMTI3Yjc5Y2RhY2UxNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-29T16:25:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-29T16:25:04Z"}, "message": "Auto merge of #48605 - KiChjang:unused-mut-warning, r=nikomatsakis\n\nAllow MIR borrowck to catch unused mutable locals\n\nFixes #47279.\n\nr? @nikomatsakis", "tree": {"sha": "a34c17b2313ffc870950c2421c6f18b805988862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a34c17b2313ffc870950c2421c6f18b805988862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79252ff4e25d82f9fe856cb66f127b79cdace163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79252ff4e25d82f9fe856cb66f127b79cdace163", "html_url": "https://github.com/rust-lang/rust/commit/79252ff4e25d82f9fe856cb66f127b79cdace163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79252ff4e25d82f9fe856cb66f127b79cdace163/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e182833b5c17da2481e6edf5bfdb75ad004e6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e182833b5c17da2481e6edf5bfdb75ad004e6e", "html_url": "https://github.com/rust-lang/rust/commit/96e182833b5c17da2481e6edf5bfdb75ad004e6e"}, {"sha": "0a1cb9b91422e38baf352993ad78446a29160ed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1cb9b91422e38baf352993ad78446a29160ed8", "html_url": "https://github.com/rust-lang/rust/commit/0a1cb9b91422e38baf352993ad78446a29160ed8"}], "stats": {"total": 533, "additions": 414, "deletions": 119}, "files": [{"sha": "437626ff5369abd40814b959d38b2cb2b8a434d6", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -563,6 +563,11 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n+impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {\n+    closure_requirements,\n+    used_mut_upvars\n+});\n+\n impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n     num_external_vids,\n     outlives_requirements"}, {"sha": "c26b3014e53dd05dae5f815bb4e7d7e3c5e4e75b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n@@ -247,6 +248,22 @@ impl<'tcx> Mir<'tcx> {\n         })\n     }\n \n+    /// Returns an iterator over all user-declared mutable arguments and locals.\n+    #[inline]\n+    pub fn mut_vars_and_args_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n+        (1..self.local_decls.len()).filter_map(move |index| {\n+            let local = Local::new(index);\n+            let decl = &self.local_decls[local];\n+            if (decl.is_user_variable || index < self.arg_count + 1)\n+               && decl.mutability == Mutability::Mut\n+            {\n+                Some(local)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n     /// Returns an iterator over all function arguments.\n     #[inline]\n     pub fn args_iter(&self) -> impl Iterator<Item=Local> {\n@@ -2029,6 +2046,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct BorrowCheckResult<'gcx> {\n+    pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n+    pub used_mut_upvars: SmallVec<[Field; 8]>,\n+}\n+\n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n /// appear in the closure's signature or on its field types.  These"}, {"sha": "d89846a75ef51a8050c0af043e60045f2830666f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -211,7 +211,7 @@ define_maps! { <'tcx>\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements<'tcx>>,\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "519dd574e5afe1f73d13b294252c14b2186243b4", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -144,7 +144,10 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     {\n         check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n-    unused::check(&mut bccx, body);\n+\n+    if !tcx.use_mir_borrowck() {\n+        unused::check(&mut bccx, body);\n+    }\n \n     Lrc::new(BorrowCheckResult {\n         used_mut_nodes: bccx.used_mut_nodes.into_inner(),"}, {"sha": "3145be7df851ef6dacc1f0bc096944ef00a968a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 279, "deletions": 98, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -17,15 +17,17 @@ use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Place};\n-use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n-use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n-use rustc::mir::{ClosureRegionRequirements, Local};\n+use rustc::lint::builtin::UNUSED_MUT;\n+use rustc::mir::{AssertMessage, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n+use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind};\n \n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::small_vec::SmallVec;\n \n use std::rc::Rc;\n \n@@ -69,12 +71,15 @@ pub fn provide(providers: &mut Providers) {\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'tcx>> {\n+) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir_borrowck() {\n-        return None;\n+        return BorrowCheckResult {\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+        };\n     }\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n@@ -90,7 +95,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'gcx>> {\n+) -> BorrowCheckResult<'gcx> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -237,6 +242,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: regioncx,\n+        used_mut: FxHashSet(),\n+        used_mut_upvars: SmallVec::new(),\n         nonlexical_cause_info: None,\n         borrow_set,\n         dominators,\n@@ -252,7 +259,66 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n-    opt_closure_req\n+    // For each non-user used mutable variable, check if it's been assigned from\n+    // a user-declared local. If so, then put that local into the used_mut set.\n+    // Note that this set is expected to be small - only upvars from closures\n+    // would have a chance of erroneously adding non-user-defined mutable vars\n+    // to the set.\n+    let temporary_used_locals: FxHashSet<Local> =\n+        mbcx.used_mut.iter()\n+            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable)\n+            .cloned()\n+            .collect();\n+\n+    for local in temporary_used_locals {\n+        for location in mbcx.mir.find_assignments(local) {\n+            for moi in &mbcx.move_data.loc_map[location] {\n+                let mpi = &mbcx.move_data.moves[*moi].path;\n+                let path = &mbcx.move_data.move_paths[*mpi];\n+                debug!(\"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n+                       path.place, local, path.place);\n+                if let Place::Local(user_local) = path.place {\n+                    mbcx.used_mut.insert(user_local);\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n+\n+    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n+        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.visibility_scope_info {\n+            let local_decl = &mbcx.mir.local_decls[local];\n+\n+            // Skip implicit `self` argument for closures\n+            if local.index() == 1 && tcx.is_closure(mbcx.mir_def_id) {\n+                continue;\n+            }\n+\n+            // Skip over locals that begin with an underscore\n+            match local_decl.name {\n+                Some(name) if name.as_str().starts_with(\"_\") => continue,\n+                _ => {},\n+            }\n+\n+            let source_info = local_decl.source_info;\n+            let mut_span = tcx.sess.codemap().span_until_non_whitespace(source_info.span);\n+\n+            tcx.struct_span_lint_node(\n+                UNUSED_MUT,\n+                vsi[local_decl.syntactic_scope].lint_root,\n+                source_info.span,\n+                \"variable does not need to be mutable\"\n+            )\n+            .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+            .emit();\n+        }\n+    }\n+\n+    BorrowCheckResult {\n+        closure_requirements: opt_closure_req,\n+        used_mut_upvars: mbcx.used_mut_upvars,\n+    }\n }\n \n #[allow(dead_code)]\n@@ -287,6 +353,12 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// This field keeps track of errors reported in the checking of moved variables,\n     /// so that we don't report report seemingly duplicate errors.\n     moved_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This field keeps track of all the local variables that are declared mut and are mutated.\n+    /// Used for the warning issued by an unused mutable local variable.\n+    used_mut: FxHashSet<Local>,\n+    /// If the function we're checking is a closure, then we'll need to report back the list of\n+    /// mutable upvars that have been used. This field keeps track of them.\n+    used_mut_upvars: SmallVec<[Field; 8]>,\n     /// Non-lexical region inference context, if NLL is enabled.  This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n@@ -684,6 +756,11 @@ enum InitializationRequiringAction {\n     Assignment,\n }\n \n+struct RootPlace<'d, 'tcx: 'd> {\n+    place: &'d Place<'tcx>,\n+    is_local_mutation_allowed: LocalMutationIsAllowed,\n+}\n+\n impl InitializationRequiringAction {\n     fn as_noun(self) -> &'static str {\n         match self {\n@@ -830,7 +907,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         let mutability_error =\n-            self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n+            self.check_access_permissions(place_span, rw, is_local_mutation_allowed, flow_state);\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n@@ -1097,9 +1174,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // `NullOp::Box`?\n             }\n \n-            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => for operand in operands {\n-                self.consume_operand(context, (operand, span), flow_state);\n-            },\n+            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+                // We need to report back the list of mutable upvars that were\n+                // moved into the closure and subsequently used by the closure,\n+                // in order to populate our used_mut set.\n+                if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n+                    let BorrowCheckResult { used_mut_upvars, .. } = self.tcx.mir_borrowck(*def_id);\n+                    debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n+                    for field in used_mut_upvars {\n+                        match operands[field.index()] {\n+                            Operand::Move(Place::Local(local)) => {\n+                                self.used_mut.insert(local);\n+                            }\n+                            Operand::Move(ref place @ Place::Projection(_)) => {\n+                                if let Some(field) = self.is_upvar_field_projection(place) {\n+                                    self.used_mut_upvars.push(field);\n+                                }\n+                            }\n+                            Operand::Move(Place::Static(..)) |\n+                            Operand::Copy(..) |\n+                            Operand::Constant(..) => {}\n+                        }\n+                    }\n+                }\n+\n+                for operand in operands {\n+                    self.consume_operand(context, (operand, span), flow_state);\n+                }\n+            }\n         }\n     }\n \n@@ -1300,7 +1402,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n+        if let Ok(..) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n         debug!(\n@@ -1594,10 +1696,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// Returns true if an error is reported, false otherwise.\n     fn check_access_permissions(\n-        &self,\n+        &mut self,\n         (place, span): (&Place<'tcx>, Span),\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n         debug!(\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n@@ -1612,90 +1715,93 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => if let Err(place_err) =\n-                self.is_mutable(place, is_local_mutation_allowed)\n-            {\n-                error_reported = true;\n-                let item_msg = self.get_default_err_msg(place);\n-                let mut err = self.tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                err.span_label(span, \"cannot borrow as mutable\");\n-\n-                if place != place_err {\n-                    if let Some(name) = self.describe_place(place_err) {\n-                        err.note(&format!(\"the value which is causing this path not to be mutable \\\n-                                           is...: `{}`\", name));\n-                    }\n-                }\n-\n-                err.emit();\n-            },\n-            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-\n-                if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n-                    error_reported = true;\n-                    let mut err_info = None;\n-                    match *place_err {\n-\n-                        Place::Projection(box Projection {\n-                        ref base, elem:ProjectionElem::Deref}) => {\n-                            match *base {\n-                                Place::Local(local) => {\n-                                    let locations = self.mir.find_assignments(local);\n-                                        if locations.len() > 0 {\n-                                            let item_msg = if error_reported {\n-                                                self.get_secondary_err_msg(base)\n-                                            } else {\n-                                                self.get_default_err_msg(place)\n-                                            };\n-                                            let sp = self.mir.source_info(locations[0]).span;\n-                                            let mut to_suggest_span = String::new();\n-                                            if let Ok(src) =\n-                                                self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                                    to_suggest_span = src[1..].to_string();\n-                                            };\n-                                            err_info = Some((\n-                                                    sp,\n-                                                    \"consider changing this to be a \\\n-                                                    mutable reference\",\n-                                                    to_suggest_span,\n-                                                    item_msg,\n-                                                    self.get_primary_err_msg(base)));\n-                                        }\n-                                },\n-                            _ => {},\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Err(place_err) => {\n+                        error_reported = true;\n+                        let item_msg = self.get_default_err_msg(place);\n+                        let mut err = self.tcx\n+                            .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                        err.span_label(span, \"cannot borrow as mutable\");\n \n-                    if let Some((err_help_span,\n-                                 err_help_stmt,\n-                                 to_suggest_span,\n-                                 item_msg,\n-                                 sec_span)) = err_info {\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                        err.span_suggestion(err_help_span,\n-                                            err_help_stmt,\n-                                            format!(\"&mut {}\", to_suggest_span));\n-                        if place != place_err {\n-                            err.span_label(span, sec_span);\n-                        }\n-                        err.emit()\n-                    } else {\n-                        let item_msg_ = self.get_default_err_msg(place);\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg_, Origin::Mir);\n-                        err.span_label(span, \"cannot mutate\");\n                         if place != place_err {\n                             if let Some(name) = self.describe_place(place_err) {\n                                 err.note(&format!(\"the value which is causing this path not to be \\\n-                                                   mutable is...: `{}`\", name));\n+                                    mutable is...: `{}`\", name));\n                             }\n                         }\n+\n                         err.emit();\n                     }\n                 }\n             }\n+            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Err(place_err) => {\n+                        error_reported = true;\n+\n+                        let err_info = if let Place::Projection(\n+                            box Projection {\n+                                base: Place::Local(local),\n+                                elem: ProjectionElem::Deref\n+                            }\n+                        ) = *place_err {\n+                            let locations = self.mir.find_assignments(local);\n+                            if locations.len() > 0 {\n+                                let item_msg = if error_reported {\n+                                    self.get_secondary_err_msg(&Place::Local(local))\n+                                } else {\n+                                    self.get_default_err_msg(place)\n+                                };\n+                                let sp = self.mir.source_info(locations[0]).span;\n+                                let mut to_suggest_span = String::new();\n+                                if let Ok(src) =\n+                                    self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                        to_suggest_span = src[1..].to_string();\n+                                };\n+                                Some((sp,\n+                                      \"consider changing this to be a \\\n+                                      mutable reference\",\n+                                      to_suggest_span,\n+                                      item_msg,\n+                                      self.get_primary_err_msg(&Place::Local(local))))\n+                            } else {\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        };\n+\n+                        if let Some((err_help_span,\n+                                     err_help_stmt,\n+                                     to_suggest_span,\n+                                     item_msg,\n+                                     sec_span)) = err_info {\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_suggestion(err_help_span,\n+                                                err_help_stmt,\n+                                                format!(\"&mut {}\", to_suggest_span));\n+                            if place != place_err {\n+                                err.span_label(span, sec_span);\n+                            }\n+                            err.emit()\n+                        } else {\n+                            let item_msg = self.get_default_err_msg(place);\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_label(span, \"cannot mutate\");\n+                            if place != place_err {\n+                                if let Some(name) = self.describe_place(place_err) {\n+                                    err.note(&format!(\"the value which is causing this path not \\\n+                                                       to be mutable is...: `{}`\", name));\n+                                }\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n             Reservation(WriteKind::Move)\n             | Reservation(WriteKind::StorageDeadOrDrop)\n             | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n@@ -1722,30 +1828,76 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         error_reported\n     }\n \n-    /// Can this value be written or borrowed mutably\n+    /// Adds the place into the used mutable variables set\n+    fn add_used_mut<'d>(\n+        &mut self,\n+        root_place: RootPlace<'d, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>\n+    ) {\n+        match root_place {\n+            RootPlace {\n+                place: Place::Local(local),\n+                is_local_mutation_allowed,\n+            } => {\n+                if is_local_mutation_allowed != LocalMutationIsAllowed::Yes {\n+                    // If the local may be initialized, and it is now currently being\n+                    // mutated, then it is justified to be annotated with the `mut`\n+                    // keyword, since the mutation may be a possible reassignment.\n+                    let mpi = self.move_data.rev_lookup.find_local(*local);\n+                    if flow_state.inits.contains(&mpi) {\n+                        self.used_mut.insert(*local);\n+                    }\n+                }\n+            }\n+            RootPlace {\n+                place: place @ Place::Projection(_),\n+                is_local_mutation_allowed: _,\n+            } => {\n+                if let Some(field) = self.is_upvar_field_projection(&place) {\n+                    self.used_mut_upvars.push(field);\n+                }\n+            }\n+            RootPlace {\n+                place: Place::Static(..),\n+                is_local_mutation_allowed: _,\n+            } => {}\n+        }\n+    }\n+\n+    /// Whether this value be written or borrowed mutably.\n+    /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n         place: &'d Place<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<(), &'d Place<'tcx>> {\n+    ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n         match *place {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes | LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok(())\n+                        LocalMutationIsAllowed::Yes => {\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::Yes\n+                            })\n+                        }\n+                        LocalMutationIsAllowed::ExceptUpvars => {\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars\n+                            })\n                         }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok(()),\n+                    Mutability::Mut => Ok(RootPlace { place, is_local_mutation_allowed }),\n                 }\n             }\n             Place::Static(ref static_) =>\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok(())\n+                    Ok(RootPlace { place, is_local_mutation_allowed })\n                 },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1781,9 +1933,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n                                     hir::MutImmutable => return Err(place),\n-                                    // `*mut` raw pointers are always mutable, regardless of context\n-                                    // The users have to check by themselve.\n-                                    hir::MutMutable => return Ok(()),\n+                                    // `*mut` raw pointers are always mutable, regardless of\n+                                    // context. The users have to check by themselves.\n+                                    hir::MutMutable => {\n+                                        return Ok(RootPlace { place, is_local_mutation_allowed });\n+                                    }\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n@@ -1814,7 +1968,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes)\n                                 | (Mutability::Mut, _) => {\n-                                    self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                    // Subtle: this is an upvar\n+                                    // reference, so it looks like\n+                                    // `self.foo` -- we want to double\n+                                    // check that the context `*self`\n+                                    // is mutable (i.e., this is not a\n+                                    // `Fn` closure).  But if that\n+                                    // check succeeds, we want to\n+                                    // *blame* the mutability on\n+                                    // `place` (that is,\n+                                    // `self.foo`). This is used to\n+                                    // propagate the info about\n+                                    // whether mutability declarations\n+                                    // are used outwards, so that we register\n+                                    // the outer variable as mutable. Otherwise a\n+                                    // test like this fails to record the `mut`\n+                                    // as needed:\n+                                    //\n+                                    // ```\n+                                    // fn foo<F: FnOnce()>(_f: F) { }\n+                                    // fn main() {\n+                                    //     let var = Vec::new();\n+                                    //     foo(move || {\n+                                    //         var.push(1);\n+                                    //     });\n+                                    // }\n+                                    // ```\n+                                    let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n+                                    Ok(RootPlace { place, is_local_mutation_allowed })\n                                 }\n                             }\n                         } else {"}, {"sha": "a811b2c147e98d392a696490f6455622e1718637", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -1426,7 +1426,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // these extra requirements are basically like where\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs) => {\n-                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                if let Some(closure_region_requirements) =\n+                    tcx.mir_borrowck(*def_id).closure_requirements\n+                {\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n                         self.body_id,"}, {"sha": "14d836074dca377123a891ccae19858d03dab41c", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: lexical nll\n+#![cfg_attr(nll, feature(nll))]\n+\n // Exercise the unused_mut attribute in some positive and negative cases\n \n #![allow(unused_assignments)]\n@@ -18,53 +21,68 @@\n \n fn main() {\n     // negative cases\n-    let mut a = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = 2; //~ ERROR: variable does not need to be mutable\n-    let mut b = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n-    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n-    let mut a; //~ ERROR: variable does not need to be mutable\n+    let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n+                         //[nll]~^ ERROR: variable does not need to be mutable\n+    let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n+                             //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n+               //[nll]~^ ERROR: variable does not need to be mutable\n     a = 3;\n \n-    let mut b; //~ ERROR: variable does not need to be mutable\n+    let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n+               //[nll]~^ ERROR: variable does not need to be mutable\n     if true {\n         b = 3;\n     } else {\n         b = 4;\n     }\n \n     match 30 {\n-        mut x => {} //~ ERROR: variable does not need to be mutable\n+        mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n+                    //[nll]~^ ERROR: variable does not need to be mutable\n     }\n     match (30, 2) {\n-      (mut x, 1) | //~ ERROR: variable does not need to be mutable\n+      (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n       (mut x, 2) |\n       (mut x, 3) => {\n       }\n       _ => {}\n     }\n \n-    let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n-    fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n+    let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n+                               //[nll]~^ ERROR: variable does not need to be mutable\n+    fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n+                               //[nll]~^ ERROR: variable does not need to be mutable\n \n-    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n+    let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n+                        //[nll]~^ ERROR: variable does not need to be mutable\n     *a = 4;\n \n     let mut a = 5;\n-    let mut b = (&mut a,);\n-    *b.0 = 4; //~^ ERROR: variable does not need to be mutable\n+    let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n+    *b.0 = 4;              //[nll]~^ ERROR: variable does not need to be mutable\n \n-    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n+    let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n+                        //[nll]~^ ERROR: variable does not need to be mutable\n     let mut f = || {\n       *x += 1;\n     };\n     f();\n \n     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+        &mut arg[..] //[lexical]~^ ERROR: variable does not need to be mutable\n+                     //[nll]~^^ ERROR: variable does not need to be mutable\n     }\n \n-    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+    let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n+                                            //[nll]~^ ERROR: variable does not need to be mutable\n     v.push(());\n \n     // positive cases\n@@ -76,6 +94,12 @@ fn main() {\n     callback(|| {\n         a.push(3);\n     });\n+    let mut a = Vec::new();\n+    callback(|| {\n+        callback(|| {\n+            a.push(3);\n+        });\n+    });\n     let (mut a, b) = (1, 2);\n     a = 34;\n \n@@ -116,5 +140,6 @@ fn foo(mut a: isize) {\n fn bar() {\n     #[allow(unused_mut)]\n     let mut a = 3;\n-    let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n+    let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n+                         //[nll]~^ ERROR: variable does not need to be mutable\n }"}, {"sha": "7f1b6ed1701683d316d41f75254a09c5e7056080", "filename": "src/test/run-pass/borrowck/borrowck-unused-mut-locals.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79252ff4e25d82f9fe856cb66f127b79cdace163/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs?ref=79252ff4e25d82f9fe856cb66f127b79cdace163", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![deny(unused_mut)]\n+\n+#[derive(Debug)]\n+struct A {}\n+\n+fn init_a() -> A {\n+    A {}\n+}\n+\n+#[derive(Debug)]\n+struct B<'a> {\n+    ed: &'a mut A,\n+}\n+\n+fn init_b<'a>(ed: &'a mut A) -> B<'a> {\n+    B { ed }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    pd: &'a mut B<'a>,\n+}\n+\n+fn init_c<'a>(pd: &'a mut B<'a>) -> C<'a> {\n+    C { pd }\n+}\n+\n+#[derive(Debug)]\n+struct D<'a> {\n+    sd: &'a mut C<'a>,\n+}\n+\n+fn init_d<'a>(sd: &'a mut C<'a>) -> D<'a> {\n+    D { sd }\n+}\n+\n+fn main() {\n+    let mut a = init_a();\n+    let mut b = init_b(&mut a);\n+    let mut c = init_c(&mut b);\n+\n+    let d = init_d(&mut c);\n+\n+    println!(\"{:?}\", d)\n+}"}]}