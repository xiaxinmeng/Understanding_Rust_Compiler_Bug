{"sha": "19f9181654ec71754c8528dd37075643d95947c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZjkxODE2NTRlYzcxNzU0Yzg1MjhkZDM3MDc1NjQzZDk1OTQ3YzQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-05T12:19:38Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-15T13:04:09Z"}, "message": "test: allow the test filter to be a regex.\n\nThis is fully backwards compatible, since test names are Rust\nidentifiers + `:`, and hence not special regex characters.\n\nFixes #2866.", "tree": {"sha": "a33cd1d9aabbd0d0fd3a24906dff62bb8e1506a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a33cd1d9aabbd0d0fd3a24906dff62bb8e1506a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f9181654ec71754c8528dd37075643d95947c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f9181654ec71754c8528dd37075643d95947c4", "html_url": "https://github.com/rust-lang/rust/commit/19f9181654ec71754c8528dd37075643d95947c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f9181654ec71754c8528dd37075643d95947c4/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0f017d3e6a34a956c8d969b12a3905934a649b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0f017d3e6a34a956c8d969b12a3905934a649b", "html_url": "https://github.com/rust-lang/rust/commit/2f0f017d3e6a34a956c8d969b12a3905934a649b"}], "stats": {"total": 147, "additions": 100, "deletions": 47}, "files": [{"sha": "0b923cca7a2b950dff8ab40b683fd54c45246716", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19f9181654ec71754c8528dd37075643d95947c4/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/19f9181654ec71754c8528dd37075643d95947c4/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=19f9181654ec71754c8528dd37075643d95947c4", "patch": "@@ -80,7 +80,7 @@ DEPS_collections := std rand\n DEPS_fourcc := syntax std\n DEPS_hexfloat := syntax std\n DEPS_num := std rand\n-DEPS_test := std collections getopts serialize term time\n+DEPS_test := std collections getopts serialize term time regex\n DEPS_time := std serialize\n DEPS_rand := std\n DEPS_url := std collections"}, {"sha": "b1f1e69c5a1874da7e6e877bfef2b31892c34d7a", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19f9181654ec71754c8528dd37075643d95947c4/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9181654ec71754c8528dd37075643d95947c4/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=19f9181654ec71754c8528dd37075643d95947c4", "patch": "@@ -10,6 +10,7 @@\n \n use std::from_str::FromStr;\n use std::fmt;\n+use regex::Regex;\n \n #[deriving(Clone, Eq)]\n pub enum Mode {\n@@ -88,7 +89,7 @@ pub struct Config {\n     pub run_ignored: bool,\n \n     // Only run tests that match this filter\n-    pub filter: Option<~str>,\n+    pub filter: Option<Regex>,\n \n     // Write out a parseable log of tests that were run\n     pub logfile: Option<Path>,"}, {"sha": "3b57e3e98ca05707bf3d6fc7828a98567de35909", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/19f9181654ec71754c8528dd37075643d95947c4/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9181654ec71754c8528dd37075643d95947c4/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=19f9181654ec71754c8528dd37075643d95947c4", "patch": "@@ -23,6 +23,8 @@ extern crate log;\n extern crate green;\n extern crate rustuv;\n \n+extern crate regex;\n+\n use std::os;\n use std::io;\n use std::io::fs;\n@@ -113,6 +115,19 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n         Path::new(m.opt_str(nm).unwrap())\n     }\n \n+    let filter = if !matches.free.is_empty() {\n+        let s = matches.free.get(0).as_slice();\n+        match regex::Regex::new(s) {\n+            Ok(re) => Some(re),\n+            Err(e) => {\n+                println!(\"failed to parse filter /{}/: {}\", s, e);\n+                fail!()\n+            }\n+        }\n+    } else {\n+        None\n+    };\n+\n     Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n@@ -125,12 +140,7 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n-        filter:\n-            if !matches.free.is_empty() {\n-                 Some((*matches.free.get(0)).clone())\n-            } else {\n-                None\n-            },\n+        filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n         save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n@@ -169,7 +179,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\", opt_str(&config.filter)));\n+    logv(c, format!(\"filter: {}\", opt_str(&config.filter.as_ref().map(|re| re.to_str()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)));\n     logv(c, format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)));\n@@ -238,7 +248,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n         filter: match config.filter {\n             None => None,\n-            Some(ref filter) => Some(filter.to_strbuf()),\n+            Some(ref filter) => Some(filter.clone()),\n         },\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.clone(),"}, {"sha": "057849f1bca736cae83af409610a135909cd0820", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19f9181654ec71754c8528dd37075643d95947c4/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/19f9181654ec71754c8528dd37075643d95947c4/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=19f9181654ec71754c8528dd37075643d95947c4", "patch": "@@ -90,10 +90,15 @@ fn test_out_of_bounds_failure() {\n ~~~\n \n A test runner built with the `--test` flag supports a limited set of\n-arguments to control which tests are run: the first free argument\n-passed to a test runner specifies a filter used to narrow down the set\n-of tests being run; the `--ignored` flag tells the test runner to run\n-only tests with the `ignore` attribute.\n+arguments to control which tests are run:\n+\n+- the first free argument passed to a test runner is interpreted as a\n+  regular expression\n+  ([syntax reference](regex/index.html#syntax))\n+  and is used to narrow down the set of tests being run. Note: a plain\n+  string is a valid regular expression that matches itself.\n+- the `--ignored` flag tells the test runner to run only tests with the\n+  `ignore` attribute.\n \n ## Parallelism\n \n@@ -146,16 +151,31 @@ result: FAILED. 1 passed; 1 failed; 0 ignored\n \n ### Running a subset of tests\n \n+Using a plain string:\n+\n+~~~ {.notrust}\n+$ mytests mytest23\n+\n+running 1 tests\n+running driver::tests::mytest23 ... ok\n+\n+result: ok. 1 passed; 0 failed; 0 ignored\n+~~~\n+\n+Using some regular expression features:\n+\n ~~~ {.notrust}\n-$ mytests mytest1\n+$ mytests 'mytest[145]'\n \n-running 11 tests\n+running 13 tests\n running driver::tests::mytest1 ... ok\n+running driver::tests::mytest4 ... ok\n+running driver::tests::mytest5 ... ok\n running driver::tests::mytest10 ... ignored\n ... snip ...\n running driver::tests::mytest19 ... ok\n \n-result: ok. 11 passed; 0 failed; 1 ignored\n+result: ok. 13 passed; 0 failed; 1 ignored\n ~~~\n \n # Microbenchmarking"}, {"sha": "793657e7e886312e67f81dcf4b1eba555ad5c276", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/19f9181654ec71754c8528dd37075643d95947c4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9181654ec71754c8528dd37075643d95947c4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=19f9181654ec71754c8528dd37075643d95947c4", "patch": "@@ -37,6 +37,7 @@\n \n extern crate collections;\n extern crate getopts;\n+extern crate regex;\n extern crate serialize;\n extern crate term;\n extern crate time;\n@@ -45,6 +46,7 @@ use collections::TreeMap;\n use stats::Stats;\n use time::precise_time_ns;\n use getopts::{OptGroup, optflag, optopt};\n+use regex::Regex;\n use serialize::{json, Decodable};\n use serialize::json::{Json, ToJson};\n use term::Terminal;\n@@ -263,7 +265,7 @@ pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n }\n \n pub struct TestOpts {\n-    pub filter: Option<StrBuf>,\n+    pub filter: Option<Regex>,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub run_benchmarks: bool,\n@@ -324,8 +326,8 @@ fn usage(binary: &str, helpstr: &str) {\n     println!(\"\");\n     if helpstr == \"help\" {\n         println!(\"{}\", \"\\\n-The FILTER is matched against the name of all tests to run, and if any tests\n-have a substring match, only those tests are run.\n+The FILTER regex is matched against the name of all tests to run, and\n+only those tests that match are run.\n \n By default, all tests are run in parallel. This can be altered with the\n RUST_TEST_TASKS environment variable when running tests (set it to 1).\n@@ -372,12 +374,15 @@ pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n         return None;\n     }\n \n-    let filter =\n-        if matches.free.len() > 0 {\n-            Some((*matches.free.get(0)).to_strbuf())\n-        } else {\n-            None\n-        };\n+    let filter = if matches.free.len() > 0 {\n+        let s = matches.free.get(0).as_slice();\n+        match Regex::new(s) {\n+            Ok(re) => Some(re),\n+            Err(e) => return Some(Err(format_strbuf!(\"could not parse /{}/: {}\", s, e)))\n+        }\n+    } else {\n+        None\n+    };\n \n     let run_ignored = matches.opt_present(\"ignored\");\n \n@@ -945,26 +950,12 @@ pub fn filter_tests(\n     let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n-    filtered = if opts.filter.is_none() {\n-        filtered\n-    } else {\n-        let filter_str = match opts.filter {\n-          Some(ref f) => (*f).clone(),\n-          None => \"\".to_strbuf()\n-        };\n-\n-        fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n-            Option<TestDescAndFn> {\n-            if test.desc.name.to_str().contains(filter_str) {\n-                return Some(test);\n-            } else {\n-                return None;\n-            }\n+    filtered = match opts.filter {\n+        None => filtered,\n+        Some(ref re) => {\n+            filtered.move_iter()\n+                .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n         }\n-\n-        filtered.move_iter()\n-                .filter_map(|x| filter_fn(x, filter_str.as_slice()))\n-                .collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -1451,12 +1442,12 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(\"progname\".to_strbuf(), \"filter\".to_strbuf());\n+        let args = vec!(\"progname\".to_strbuf(), \"some_regex_filter\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().unwrap().as_slice());\n+        assert!(opts.filter.expect(\"should've found filter\").is_match(\"some_regex_filter\"))\n     }\n \n     #[test]\n@@ -1555,6 +1546,37 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    pub fn filter_tests_regex() {\n+        let mut opts = TestOpts::new();\n+        opts.filter = Some(::regex::Regex::new(\"a.*b.+c\").unwrap());\n+\n+        let mut names = [\"yes::abXc\", \"yes::aXXXbXXXXc\",\n+                         \"no::XYZ\", \"no::abc\"];\n+        names.sort();\n+\n+        fn test_fn() {}\n+        let tests = names.iter().map(|name| {\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: DynTestName(name.to_strbuf()),\n+                    ignore: false,\n+                    should_fail: false\n+                },\n+                testfn: DynTestFn(test_fn)\n+            }\n+        }).collect();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        let expected: Vec<&str> =\n+            names.iter().map(|&s| s).filter(|name| name.starts_with(\"yes\")).collect();\n+\n+        assert_eq!(filtered.len(), expected.len());\n+        for (test, expected_name) in filtered.iter().zip(expected.iter()) {\n+            assert_eq!(test.desc.name.as_slice(), *expected_name);\n+        }\n+    }\n+\n     #[test]\n     pub fn test_metricmap_compare() {\n         let mut m1 = MetricMap::new();"}]}