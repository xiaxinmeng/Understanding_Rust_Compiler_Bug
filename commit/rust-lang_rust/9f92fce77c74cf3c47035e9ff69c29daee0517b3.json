{"sha": "9f92fce77c74cf3c47035e9ff69c29daee0517b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOTJmY2U3N2M3NGNmM2M0NzAzNWU5ZmY2OWMyOWRhZWUwNTE3YjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-24T22:00:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-29T22:53:32Z"}, "message": "Fortify dummy span checking", "tree": {"sha": "e724e8e72a43d71053f4de32fa893a661ee163bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e724e8e72a43d71053f4de32fa893a661ee163bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f92fce77c74cf3c47035e9ff69c29daee0517b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f92fce77c74cf3c47035e9ff69c29daee0517b3", "html_url": "https://github.com/rust-lang/rust/commit/9f92fce77c74cf3c47035e9ff69c29daee0517b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f92fce77c74cf3c47035e9ff69c29daee0517b3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297109ea3263a4ea90a7143a82e46903a8890269", "url": "https://api.github.com/repos/rust-lang/rust/commits/297109ea3263a4ea90a7143a82e46903a8890269", "html_url": "https://github.com/rust-lang/rust/commit/297109ea3263a4ea90a7143a82e46903a8890269"}], "stats": {"total": 118, "additions": 59, "deletions": 59}, "files": [{"sha": "820b0906a7554cf4487654ba43f9a2c121e96c5e", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -177,8 +177,6 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub mod token_stream {\n     use syntax::tokenstream;\n-    use syntax_pos::DUMMY_SP;\n-\n     use {TokenTree, TokenStream, Delimiter};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n@@ -207,7 +205,7 @@ pub mod token_stream {\n                 // need to flattened during iteration over stream's token trees.\n                 // Eventually this needs to be removed in favor of keeping original token trees\n                 // and not doing the roundtrip through AST.\n-                if tree.span().0 == DUMMY_SP {\n+                if tree.span().0.is_dummy() {\n                     if let TokenTree::Group(ref group) = tree {\n                         if group.delimiter() == Delimiter::None {\n                             self.cursor.insert(group.stream.clone().0);"}, {"sha": "e262c951e391df25668a75e642a6bd7fb0e5f5f6", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -486,12 +486,7 @@ impl Definitions {\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n-            let span = self.def_index_to_span.get(&def_id.index).cloned().unwrap_or(DUMMY_SP);\n-            if span != DUMMY_SP {\n-                Some(span)\n-            } else {\n-                None\n-            }\n+            self.def_index_to_span.get(&def_id.index).cloned()\n         } else {\n             None\n         }\n@@ -588,8 +583,8 @@ impl Definitions {\n             self.opaque_expansions_that_defined.insert(index, expansion);\n         }\n \n-        // The span is added if it isn't DUMMY_SP\n-        if span != DUMMY_SP {\n+        // The span is added if it isn't dummy\n+        if !span.is_dummy() {\n             self.def_index_to_span.insert(index, span);\n         }\n "}, {"sha": "9bf5c4d72b70cb05f8b6977c78291029e0f0961a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -20,7 +20,7 @@ use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n use session::DiagnosticMessageId;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n@@ -687,7 +687,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let msp: MultiSpan = span.into();\n                 let cm = &self.sess.parse_sess.codemap();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n-                    if sp != DUMMY_SP {\n+                    if !sp.is_dummy() {\n                         let file = cm.lookup_char_pos(sp.lo()).file;\n                         if file.name.is_macros() {\n                             None\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match item.node {\n             hir::ItemExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n-                if item.span == DUMMY_SP { return }\n+                if item.span.is_dummy() { return }\n \n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {"}, {"sha": "d783b9574efb2fdbe21bcbd1d22d23fbf369a286", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -708,7 +708,7 @@ macro_rules! define_queries {\n \n             // FIXME(eddyb) Get more valid Span's on queries.\n             pub fn default_span(&self, tcx: TyCtxt<'_, $tcx, '_>, span: Span) -> Span {\n-                if span != DUMMY_SP {\n+                if !span.is_dummy() {\n                     return span;\n                 }\n                 // The def_span query is used to calculate default_span,"}, {"sha": "6d727f7b048c6541276c85ac3129c3793dd6faaa", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -1662,7 +1662,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n     let var_scope = get_namespace_for_item(cx, def_id);\n     let span = tcx.def_span(def_id);\n \n-    let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n+    let (file_metadata, line_number) = if !span.is_dummy() {\n         let loc = span_start(cx, span);\n         (file_metadata(cx, &loc.file.name, LOCAL_CRATE), loc.line as c_uint)\n     } else {"}, {"sha": "068dd9821ac97029dad1295b389a0555d5057bc9", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -219,7 +219,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let span = mir.span;\n \n     // This can be the case for functions inlined from another crate\n-    if span == syntax_pos::DUMMY_SP {\n+    if span.is_dummy() {\n         // FIXME(simulacrum): Probably can't happen; remove.\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }"}, {"sha": "e79a3a87738ec407903ecb1690f515d797659442", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{DUMMY_SP, FileMap, Span, MultiSpan};\n+use syntax_pos::{FileMap, Span, MultiSpan};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n@@ -216,7 +216,7 @@ impl EmitterWriter {\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n-                if span_label.span == DUMMY_SP {\n+                if span_label.span.is_dummy() {\n                     continue;\n                 }\n \n@@ -730,7 +730,7 @@ impl EmitterWriter {\n         let mut max = 0;\n         if let Some(ref cm) = self.cm {\n             for primary_span in msp.primary_spans() {\n-                if primary_span != &DUMMY_SP {\n+                if !primary_span.is_dummy() {\n                     let hi = cm.lookup_char_pos(primary_span.hi());\n                     if hi.line > max {\n                         max = hi.line;\n@@ -739,7 +739,7 @@ impl EmitterWriter {\n             }\n             if !self.short_message {\n                 for span_label in msp.span_labels() {\n-                    if span_label.span != DUMMY_SP {\n+                    if !span_label.span.is_dummy() {\n                         let hi = cm.lookup_char_pos(span_label.span.hi());\n                         if hi.line > max {\n                             max = hi.line;\n@@ -778,7 +778,7 @@ impl EmitterWriter {\n \n             // First, find all the spans in <*macros> and point instead at their use site\n             for sp in span.primary_spans() {\n-                if *sp == DUMMY_SP {\n+                if sp.is_dummy() {\n                     continue;\n                 }\n                 let call_sp = cm.call_span_if_macro(*sp);\n@@ -790,7 +790,7 @@ impl EmitterWriter {\n                     // Only show macro locations that are local\n                     // and display them like a span_note\n                     if let Some(def_site) = trace.def_site_span {\n-                        if def_site == DUMMY_SP {\n+                        if def_site.is_dummy() {\n                             continue;\n                         }\n                         if always_backtrace {\n@@ -830,7 +830,7 @@ impl EmitterWriter {\n                 span.push_span_label(label_span, label_text);\n             }\n             for sp_label in span.span_labels() {\n-                if sp_label.span == DUMMY_SP {\n+                if sp_label.span.is_dummy() {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp_label.span.clone()).is_macros() &&\n@@ -1003,7 +1003,7 @@ impl EmitterWriter {\n         // Make sure our primary file comes first\n         let (primary_lo, cm) = if let (Some(cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n-            if primary_span != &&DUMMY_SP {\n+            if !primary_span.is_dummy() {\n                 (cm.lookup_char_pos(primary_span.lo()), cm)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;"}, {"sha": "93294075272584cdc4de217562d9c797f577b3bd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -41,7 +41,7 @@ use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n use syntax::symbol::keywords;\n-use syntax_pos::{self, hygiene, FileName, FileMap, Span, DUMMY_SP};\n+use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if *span == DUMMY_SP {\n+        if span.is_dummy() {\n             return TAG_INVALID_SPAN.encode(self)\n         }\n "}, {"sha": "9b6e3e0cab6baa5c8ba650f585fc54c80e7db08b", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -190,7 +190,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n \n impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n-        if *span != DUMMY_SP {\n+        if !span.is_dummy() {\n             self.last_span = *span;\n         }\n     }\n@@ -1601,7 +1601,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 statement_index: 0,\n             };\n             for stmt in &block_data.statements {\n-                if stmt.source_info.span != DUMMY_SP {\n+                if !stmt.source_info.span.is_dummy() {\n                     self.last_span = stmt.source_info.span;\n                 }\n                 self.check_stmt(mir, stmt, location);"}, {"sha": "0c4b9a546cbd18617a52bdb3d9f670d08638f985", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if let ast::ItemKind::Use(..) = item.node {\n-            if item.vis.node == ast::VisibilityKind::Public || item.span.source_equal(&DUMMY_SP) {\n+            if item.vis.node == ast::VisibilityKind::Public || item.span.is_dummy() {\n                 return;\n             }\n         }\n@@ -129,7 +129,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         match directive.subclass {\n             _ if directive.used.get() ||\n                  directive.vis.get() == ty::Visibility::Public ||\n-                 directive.span.source_equal(&DUMMY_SP) => {}\n+                 directive.span.is_dummy() => {}\n             ImportDirectiveSubclass::ExternCrate(_) => {\n                 resolver.maybe_unused_extern_crates.push((directive.id, directive.span));\n             }"}, {"sha": "9887abd60bf1d9131dd2428c8260a2e841335dfe", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -2861,7 +2861,7 @@ impl<'a> Resolver<'a> {\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n                 for (sp, variant_path, enum_path) in enum_candidates {\n-                    if sp == DUMMY_SP {\n+                    if sp.is_dummy() {\n                         let msg = format!(\"there is an enum variant `{}`, \\\n                                         try using `{}`?\",\n                                         variant_path,\n@@ -4285,7 +4285,7 @@ impl<'a> Resolver<'a> {\n             let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n             err.span_note(b1.span, &msg1);\n             match b2.def() {\n-                Def::Macro(..) if b2.span == DUMMY_SP =>\n+                Def::Macro(..) if b2.span.is_dummy() =>\n                     err.note(&format!(\"`{}` is also a builtin macro\", name)),\n                 _ => err.span_note(b2.span, &msg2),\n             };\n@@ -4398,14 +4398,14 @@ impl<'a> Resolver<'a> {\n                           container));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        if old_binding.span != DUMMY_SP {\n+        if !old_binding.span.is_dummy() {\n             err.span_label(self.session.codemap().def_span(old_binding.span),\n                            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name));\n         }\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         if old_binding.is_import() || new_binding.is_import() {\n-            let binding = if new_binding.is_import() && new_binding.span != DUMMY_SP {\n+            let binding = if new_binding.is_import() && !new_binding.span.is_dummy() {\n                 new_binding\n             } else {\n                 old_binding"}, {"sha": "c07db44b36ccfd9e0001225890a8244bdddc7be6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -1157,7 +1157,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt() != NO_EXPANSION || span == DUMMY_SP\n+    span.ctxt() != NO_EXPANSION || span.is_dummy()\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "ae5ca5441adf67675d3d3df6d23edc592d04f518", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -12,7 +12,7 @@ use lint;\n use rustc::ty::TyCtxt;\n \n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -39,7 +39,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if item.vis == hir::Public || item.span == DUMMY_SP {\n+        if item.vis == hir::Public || item.span.is_dummy() {\n             return;\n         }\n         if let hir::ItemUse(ref path, _) = item.node {"}, {"sha": "65babbffffef11e93d0c83e3cf234a5602d4a222", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -3464,7 +3464,7 @@ impl Span {\n \n impl Clean<Span> for syntax_pos::Span {\n     fn clean(&self, cx: &DocContext) -> Span {\n-        if *self == DUMMY_SP {\n+        if self.is_dummy() {\n             return Span::empty();\n         }\n "}, {"sha": "ea6b39504e81d72463c90b4fd32d1fce8490c6dc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -443,7 +443,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().file_maps.is_empty() && sp.source_equal(&DUMMY_SP) {\n+        if self.files.borrow().file_maps.is_empty() && sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n "}, {"sha": "f29bff20f3dd6a4d671c81a472375d1210786ef5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -1297,7 +1297,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner == DUMMY_SP;\n+                let inline_module = item.span.contains(inner) || inner.is_dummy();\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {"}, {"sha": "82b0fae3e9c68e7ce93e82ca7d0d8926d56799b1", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -14,7 +14,7 @@ use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n-use syntax_pos::{BytePos, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span};\n use tokenstream;\n \n use std::iter::Peekable;\n@@ -41,8 +41,8 @@ impl Delimited {\n \n     /// Return a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let open_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.lo() + BytePos(self.delim.len() as u32))\n         };\n@@ -51,8 +51,8 @@ impl Delimited {\n \n     /// Return a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let close_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };"}, {"sha": "c443f240780317ef2671b3c1ecfdd4fbf22b1e2a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -13,7 +13,7 @@\n use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig};\n use codemap::{CodeMap, FilePathMapping};\n-use syntax_pos::{self, Span, FileMap, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileMap, FileName};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -188,8 +188,8 @@ fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<FileMap>) -> Parser {\n     let end_pos = filemap.end_pos;\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n \n-    if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n-        parser.span = Span::new(end_pos, end_pos, NO_EXPANSION);\n+    if parser.token == token::Eof && parser.span.is_dummy() {\n+        parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n     }\n \n     parser"}, {"sha": "96053f988fa265fad224142e4fb4f42356065da1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP, edition::Edition};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -567,7 +567,7 @@ impl<'a> Parser<'a> {\n \n         if let Some(directory) = directory {\n             parser.directory = directory;\n-        } else if !parser.span.source_equal(&DUMMY_SP) {\n+        } else if !parser.span.is_dummy() {\n             if let FileName::Real(mut path) = sess.codemap().span_to_unmapped_path(parser.span) {\n                 path.pop();\n                 parser.directory.path = Cow::from(path);\n@@ -584,7 +584,7 @@ impl<'a> Parser<'a> {\n         } else {\n             self.token_cursor.next()\n         };\n-        if next.sp == syntax_pos::DUMMY_SP {\n+        if next.sp.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n             next.sp = self.prev_span.with_ctxt(next.sp.ctxt());\n         }\n@@ -6137,7 +6137,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         }\n \n-        let hi = if self.span == syntax_pos::DUMMY_SP {\n+        let hi = if self.span.is_dummy() {\n             inner_lo\n         } else {\n             self.prev_span\n@@ -6368,7 +6368,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let mut err = self.diagnostic().struct_span_err(id_sp,\n                     \"cannot declare a new module at this location\");\n-                if id_sp != syntax_pos::DUMMY_SP {\n+                if !id_sp.is_dummy() {\n                     let src_path = self.sess.codemap().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n                         if let Some(stem) = src_path.file_stem() {"}, {"sha": "8736fcf9729a634d2f78a2f601abba147c938282", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -57,8 +57,8 @@ impl Delimited {\n \n     /// Returns the opening delimiter as a token tree.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let open_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n         };\n@@ -67,8 +67,8 @@ impl Delimited {\n \n     /// Returns the closing delimiter as a token tree.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = if span == DUMMY_SP {\n-            DUMMY_SP\n+        let close_span = if span.is_dummy() {\n+            span\n         } else {\n             span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };"}, {"sha": "491ce720f36c5f0eacd0408dd07a6c99f5e1a65e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f92fce77c74cf3c47035e9ff69c29daee0517b3/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=9f92fce77c74cf3c47035e9ff69c29daee0517b3", "patch": "@@ -248,6 +248,13 @@ impl Span {\n         self.data().with_ctxt(ctxt)\n     }\n \n+    /// Returns `true` if this is a dummy span with any hygienic context.\n+    #[inline]\n+    pub fn is_dummy(self) -> bool {\n+        let span = self.data();\n+        span.lo.0 == 0 && span.hi.0 == 0\n+    }\n+\n     /// Returns a new span representing an empty span at the beginning of this span\n     #[inline]\n     pub fn shrink_to_lo(self) -> Span {\n@@ -263,7 +270,7 @@ impl Span {\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n-        if self.source_equal(&DUMMY_SP) { other } else { self }\n+        if self.is_dummy() { other } else { self }\n     }\n \n     /// Return true if `self` fully encloses `other`."}]}