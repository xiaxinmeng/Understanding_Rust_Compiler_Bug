{"sha": "47f92a58a412fed5555eb120f963bcf6a35a9da8", "node_id": "C_kwDOAAsO6NoAKDQ3ZjkyYTU4YTQxMmZlZDU1NTVlYjEyMGY5NjNiY2Y2YTM1YTlkYTg", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-29T20:05:19Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-30T19:53:11Z"}, "message": "Accommodate yield points in the format_args expansion", "tree": {"sha": "4b302c9b55bc09e2d52d9d0b96b28eb3a8d6bc8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b302c9b55bc09e2d52d9d0b96b28eb3a8d6bc8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f92a58a412fed5555eb120f963bcf6a35a9da8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmH27KcACgkQ+boUO5X/\nbYLNew//aeAyrklCQH/QDMomvO13F2f26yU7uX7bhKVBROyPXJll0A4lg5CDDXYv\nBo8xZtcAC3oSCfD4x2/AYJf6HhROC6o2qOgEadOFeJXtgLILAsaVCPsD5jnnnNIG\nteZfNcKcEKPFgWHmzqnGBYjPe39+KF0LjS3zSFkjyqE/m2dzm6al6aN4/LlRaZfP\nBobsegISSjiXrosH7ZzhH9Mp4TFgbCYYHc0Dhk1kam0dtLID7ZFhYOxUdYzAhXPy\n9VbGOIlJycLlKVo0gwyqNWTUrgD2J5xZnIpybjOK11l17HAPClyqhXcLKHkhyFRl\ncFFm5ZiodcbeqrwoFAv9tWML6lv0Gz40KtYpSVm8ndbzuVJkjdSvS7l3O0AyPDw+\n3jqQ+/pBaNfZ8bsqtK8CM4M/gzb8j0aeVAd/ZLxpRL2rWWAIOCJqP9C521/iFdQe\nm7hnGwpxpB43hgQWE8z2cE6cz+ZZeLDh7rlXQeSKZZ6LV+7wlutjBZ/KdzP23qWp\nFMeTXRMgHyY7g3OevxaU7Okn1C7+pkwwfO5MfdjZd9cBAbtQ+L8uYu+P7kyA1dTe\nWk1/As8YiPOaLBym5UOUznKLwuEKXB4joCFaJaMTfy5kbrCOalGOW9yc6HFZm/vJ\nmOHcJCSUCGjmMFunMz9YUIJAU9s0rvwd8Tv5SMMbbTk5mhMnhwM=\n=ocVI\n-----END PGP SIGNATURE-----", "payload": "tree 4b302c9b55bc09e2d52d9d0b96b28eb3a8d6bc8f\nparent 1dd02e32a360f64c6fedbd5f1eecaced9f9f08a1\nauthor David Tolnay <dtolnay@gmail.com> 1643486719 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1643572391 -0800\n\nAccommodate yield points in the format_args expansion\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f92a58a412fed5555eb120f963bcf6a35a9da8", "html_url": "https://github.com/rust-lang/rust/commit/47f92a58a412fed5555eb120f963bcf6a35a9da8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f92a58a412fed5555eb120f963bcf6a35a9da8/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dd02e32a360f64c6fedbd5f1eecaced9f9f08a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd02e32a360f64c6fedbd5f1eecaced9f9f08a1", "html_url": "https://github.com/rust-lang/rust/commit/1dd02e32a360f64c6fedbd5f1eecaced9f9f08a1"}], "stats": {"total": 53, "additions": 49, "deletions": 4}, "files": [{"sha": "d1696816666a2a55df95917a9214835663f2c10c", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47f92a58a412fed5555eb120f963bcf6a35a9da8/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f92a58a412fed5555eb120f963bcf6a35a9da8/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=47f92a58a412fed5555eb120f963bcf6a35a9da8", "patch": "@@ -4,6 +4,7 @@ use Position::*;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n@@ -788,17 +789,31 @@ impl<'a, 'b> Context<'a, 'b> {\n         // the order provided to fmt::Arguments. When arguments are repeated, we\n         // want the expression evaluated only once.\n         //\n-        // Thus in the not nicely ordered case we emit the following instead:\n+        // Further, if any arg _after the first one_ contains a yield point such\n+        // as `await` or `yield`, the above short form is inconvenient for the\n+        // caller because it would keep a temporary of type ArgumentV1 alive\n+        // across the yield point. ArgumentV1 can't implement Send since it\n+        // holds a type-erased arbitrary type.\n+        //\n+        // Thus in the not nicely ordered case, and in the yielding case, we\n+        // emit the following instead:\n         //\n         //     match (&$arg0, &$arg1, \u2026) {\n         //         args => [ArgumentV1::new(args.$i, \u2026), ArgumentV1::new(args.$j, \u2026), \u2026]\n         //     }\n         //\n         // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n+        // This more verbose representation ensures that all arguments are\n+        // evaluated a single time each, in the order written by the programmer,\n+        // and that the surrounding future/generator (if any) is Send whenever\n+        // possible.\n+        let no_need_for_match =\n+            nicely_ordered && !original_args.iter().skip(1).any(|e| may_contain_yield_point(e));\n+\n         for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n             let e = &mut original_args[arg_index];\n             let span = e.span;\n-            let arg = if nicely_ordered {\n+            let arg = if no_need_for_match {\n                 let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n                 // The indices are strictly ordered so e has not been taken yet.\n                 self.ecx.expr_addr_of(expansion_span, P(e.take()))\n@@ -814,10 +829,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         let args_array = self.ecx.expr_vec(self.macsp, fmt_args);\n         let args_slice = self.ecx.expr_addr_of(\n             self.macsp,\n-            if nicely_ordered {\n+            if no_need_for_match {\n                 args_array\n             } else {\n-                // In the !nicely_ordered case, none of the exprs were moved\n+                // In the !no_need_for_match case, none of the exprs were moved\n                 // away in the previous loop.\n                 //\n                 // This uses the arg span for `&arg` so that borrowck errors\n@@ -1216,3 +1231,33 @@ pub fn expand_preparsed_format_args(\n \n     cx.into_expr()\n }\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) | ast::ExprKind::MacCall(_) =\n+                e.kind\n+            {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_attribute(&mut self, _: &ast::Attribute) {\n+            // Conservatively assume this may be a proc macro attribute in\n+            // expression position.\n+            self.0 = true;\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}]}