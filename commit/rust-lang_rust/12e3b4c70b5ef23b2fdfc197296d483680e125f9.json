{"sha": "12e3b4c70b5ef23b2fdfc197296d483680e125f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZTNiNGM3MGI1ZWYyM2IyZmRmYzE5NzI5NmQ0ODM2ODBlMTI1Zjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-08T11:49:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-08T11:49:43Z"}, "message": "reformat the world", "tree": {"sha": "71baa0e0a62f9f6b61450501c5f821f67badf9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71baa0e0a62f9f6b61450501c5f821f67badf9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12e3b4c70b5ef23b2fdfc197296d483680e125f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12e3b4c70b5ef23b2fdfc197296d483680e125f9", "html_url": "https://github.com/rust-lang/rust/commit/12e3b4c70b5ef23b2fdfc197296d483680e125f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12e3b4c70b5ef23b2fdfc197296d483680e125f9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cb1d41a30d25cbe136402644bf5434dd667f1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cb1d41a30d25cbe136402644bf5434dd667f1e5", "html_url": "https://github.com/rust-lang/rust/commit/5cb1d41a30d25cbe136402644bf5434dd667f1e5"}], "stats": {"total": 3238, "additions": 728, "deletions": 2510}, "files": [{"sha": "02c7a18585c51331c0df666b6aa22b3795319941", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -80,10 +80,7 @@ impl RawMessage {\n             #[serde(flatten)]\n             msg: RawMessage,\n         }\n-        let text = to_string(&JsonRpc {\n-            jsonrpc: \"2.0\",\n-            msg: self,\n-        })?;\n+        let text = to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n         write_msg_text(w, &text)?;\n         Ok(())\n     }\n@@ -95,11 +92,7 @@ impl RawRequest {\n         R: Request,\n         R::Params: serde::Serialize,\n     {\n-        RawRequest {\n-            id,\n-            method: R::METHOD.to_string(),\n-            params: to_value(params).unwrap(),\n-        }\n+        RawRequest { id, method: R::METHOD.to_string(), params: to_value(params).unwrap() }\n     }\n     pub fn cast<R>(self) -> ::std::result::Result<(u64, R::Params), RawRequest>\n     where\n@@ -121,23 +114,11 @@ impl RawResponse {\n         R: Request,\n         R::Result: serde::Serialize,\n     {\n-        RawResponse {\n-            id,\n-            result: Some(to_value(&result).unwrap()),\n-            error: None,\n-        }\n+        RawResponse { id, result: Some(to_value(&result).unwrap()), error: None }\n     }\n     pub fn err(id: u64, code: i32, message: String) -> RawResponse {\n-        let error = RawResponseError {\n-            code,\n-            message,\n-            data: None,\n-        };\n-        RawResponse {\n-            id,\n-            result: None,\n-            error: Some(error),\n-        }\n+        let error = RawResponseError { code, message, data: None };\n+        RawResponse { id, result: None, error: Some(error) }\n     }\n }\n \n@@ -147,10 +128,7 @@ impl RawNotification {\n         N: Notification,\n         N::Params: serde::Serialize,\n     {\n-        RawNotification {\n-            method: N::METHOD.to_string(),\n-            params: to_value(params).unwrap(),\n-        }\n+        RawNotification { method: N::METHOD.to_string(), params: to_value(params).unwrap() }\n     }\n     pub fn is<N>(&self) -> bool\n     where\n@@ -187,9 +165,8 @@ fn read_msg_text(inp: &mut impl BufRead) -> Result<Option<String>> {\n         }\n         let mut parts = buf.splitn(2, \": \");\n         let header_name = parts.next().unwrap();\n-        let header_value = parts\n-            .next()\n-            .ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n+        let header_value =\n+            parts.next().ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n         if header_name == \"Content-Length\" {\n             size = Some(header_value.parse::<usize>()?);\n         }"}, {"sha": "dab2d8da8f022eafe2d327758f7b81f00f90b7e0", "filename": "crates/gen_lsp_server/src/stdio.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -13,9 +13,7 @@ pub fn stdio_transport() -> (Receiver<RawMessage>, Sender<RawMessage>, Threads)\n     let writer = thread::spawn(move || {\n         let stdout = stdout();\n         let mut stdout = stdout.lock();\n-        writer_receiver\n-            .into_iter()\n-            .try_for_each(|it| it.write(&mut stdout))?;\n+        writer_receiver.into_iter().try_for_each(|it| it.write(&mut stdout))?;\n         Ok(())\n     });\n     let (reader_sender, reader_receiver) = bounded::<RawMessage>(16);"}, {"sha": "1c97c2662db354ef5fc703b30013f918329b7545", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -44,10 +44,7 @@ pub struct Arena<ID: ArenaId, T> {\n \n impl<ID: ArenaId, T: fmt::Debug> fmt::Debug for Arena<ID, T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_struct(\"Arena\")\n-            .field(\"len\", &self.len())\n-            .field(\"data\", &self.data)\n-            .finish()\n+        fmt.debug_struct(\"Arena\").field(\"len\", &self.len()).field(\"data\", &self.data).finish()\n     }\n }\n \n@@ -80,19 +77,13 @@ impl<ID: ArenaId, T> Arena<ID, T> {\n         ID::from_raw(id)\n     }\n     pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n-        self.data\n-            .iter()\n-            .enumerate()\n-            .map(|(idx, value)| (ID::from_raw(RawId(idx as u32)), value))\n+        self.data.iter().enumerate().map(|(idx, value)| (ID::from_raw(RawId(idx as u32)), value))\n     }\n }\n \n impl<ID: ArenaId, T> Default for Arena<ID, T> {\n     fn default() -> Arena<ID, T> {\n-        Arena {\n-            data: Vec::new(),\n-            _ty: PhantomData,\n-        }\n+        Arena { data: Vec::new(), _ty: PhantomData }\n     }\n }\n \n@@ -116,9 +107,6 @@ impl<ID: ArenaId, T> FromIterator<T> for Arena<ID, T> {\n     where\n         I: IntoIterator<Item = T>,\n     {\n-        Arena {\n-            data: Vec::from_iter(iter),\n-            _ty: PhantomData,\n-        }\n+        Arena { data: Vec::from_iter(iter), _ty: PhantomData }\n     }\n }"}, {"sha": "b73d4e3651b03112f01f5b8e90d182a6fe4c284f", "filename": "crates/ra_arena/src/map.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Fmap.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -42,10 +42,7 @@ impl<ID: ArenaId, T> ArenaMap<ID, T> {\n     }\n \n     pub fn iter(&self) -> impl Iterator<Item = (ID, &T)> {\n-        self.v\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n+        self.v.iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n     }\n \n     fn to_idx(id: ID) -> usize {\n@@ -66,9 +63,6 @@ impl<ID: ArenaId, T> std::ops::Index<ID> for ArenaMap<ID, T> {\n \n impl<ID, T> Default for ArenaMap<ID, T> {\n     fn default() -> Self {\n-        ArenaMap {\n-            v: Vec::new(),\n-            _ty: PhantomData,\n-        }\n+        ArenaMap { v: Vec::new(), _ty: PhantomData }\n     }\n }"}, {"sha": "caf21e079179000e857e9ce8029d61b0b94d87a2", "filename": "crates/ra_assists/src/add_derive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -30,10 +30,8 @@ pub(crate) fn add_derive(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n \n // Insert `derive` after doc comments.\n fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n-    let non_ws_child = nominal\n-        .syntax()\n-        .children()\n-        .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n+    let non_ws_child =\n+        nominal.syntax().children().find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n     Some(non_ws_child.range().start())\n }\n "}, {"sha": "f2360bc89124f37def8ccd2bb85ca079a81e2ca7", "filename": "crates/ra_assists/src/add_impl.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -21,17 +21,11 @@ pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         buf.push_str(\" \");\n         buf.push_str(name.text().as_str());\n         if let Some(type_params) = type_params {\n-            let lifetime_params = type_params\n-                .lifetime_params()\n-                .filter_map(|it| it.lifetime())\n-                .map(|it| it.text());\n-            let type_params = type_params\n-                .type_params()\n-                .filter_map(|it| it.name())\n-                .map(|it| it.text());\n-            join(lifetime_params.chain(type_params))\n-                .surround_with(\"<\", \">\")\n-                .to_buf(&mut buf);\n+            let lifetime_params =\n+                type_params.lifetime_params().filter_map(|it| it.lifetime()).map(|it| it.text());\n+            let type_params =\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text());\n+            join(lifetime_params.chain(type_params)).surround_with(\"<\", \">\").to_buf(&mut buf);\n         }\n         buf.push_str(\" {\\n\");\n         edit.set_cursor(start_offset + TextUnit::of_str(&buf));\n@@ -47,11 +41,7 @@ mod tests {\n \n     #[test]\n     fn test_add_impl() {\n-        check_assist(\n-            add_impl,\n-            \"struct Foo {<|>}\\n\",\n-            \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n-        );\n+        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\");\n         check_assist(\n             add_impl,\n             \"struct Foo<T: Clone> {<|>}\","}, {"sha": "0bf640241be5fe1a31951e39ea66cad045929053", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -69,12 +69,7 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         F: FnOnce(AssistCtx<DB>) -> T,\n     {\n         let source_file = &db.parse(frange.file_id);\n-        let ctx = AssistCtx {\n-            db,\n-            frange,\n-            source_file,\n-            should_compute_edit,\n-        };\n+        let ctx = AssistCtx { db, frange, source_file, should_compute_edit };\n         f(ctx)\n     }\n \n@@ -83,9 +78,7 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         label: impl Into<String>,\n         f: impl FnOnce(&mut AssistBuilder),\n     ) -> Option<Assist> {\n-        let label = AssistLabel {\n-            label: label.into(),\n-        };\n+        let label = AssistLabel { label: label.into() };\n         if !self.should_compute_edit {\n             return Some(Assist::Unresolved(label));\n         }\n@@ -146,9 +139,6 @@ impl AssistBuilder {\n     }\n \n     fn build(self) -> AssistAction {\n-        AssistAction {\n-            edit: self.edit.finish(),\n-            cursor_position: self.cursor_position,\n-        }\n+        AssistAction { edit: self.edit.finish(), cursor_position: self.cursor_position }\n     }\n }"}, {"sha": "fa5f231c88901d502b033f9510ef62f80fa9de10", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -81,31 +81,11 @@ mod tests {\n \n     #[test]\n     fn change_visibility_adds_pub_crate_to_items() {\n-        check_assist(\n-            change_visibility,\n-            \"<|>fn foo() {}\",\n-            \"<|>pub(crate) fn foo() {}\",\n-        );\n-        check_assist(\n-            change_visibility,\n-            \"f<|>n foo() {}\",\n-            \"<|>pub(crate) fn foo() {}\",\n-        );\n-        check_assist(\n-            change_visibility,\n-            \"<|>struct Foo {}\",\n-            \"<|>pub(crate) struct Foo {}\",\n-        );\n-        check_assist(\n-            change_visibility,\n-            \"<|>mod foo {}\",\n-            \"<|>pub(crate) mod foo {}\",\n-        );\n-        check_assist(\n-            change_visibility,\n-            \"<|>trait Foo {}\",\n-            \"<|>pub(crate) trait Foo {}\",\n-        );\n+        check_assist(change_visibility, \"<|>fn foo() {}\", \"<|>pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"f<|>n foo() {}\", \"<|>pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"<|>struct Foo {}\", \"<|>pub(crate) struct Foo {}\");\n+        check_assist(change_visibility, \"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\");\n+        check_assist(change_visibility, \"<|>trait Foo {}\", \"<|>pub(crate) trait Foo {}\");\n         check_assist(change_visibility, \"m<|>od {}\", \"<|>pub(crate) mod {}\");\n         check_assist(\n             change_visibility,\n@@ -125,20 +105,12 @@ mod tests {\n \n     #[test]\n     fn change_visibility_pub_to_pub_crate() {\n-        check_assist(\n-            change_visibility,\n-            \"<|>pub fn foo() {}\",\n-            \"<|>pub(crate) fn foo() {}\",\n-        )\n+        check_assist(change_visibility, \"<|>pub fn foo() {}\", \"<|>pub(crate) fn foo() {}\")\n     }\n \n     #[test]\n     fn change_visibility_pub_crate_to_pub() {\n-        check_assist(\n-            change_visibility,\n-            \"<|>pub(crate) fn foo() {}\",\n-            \"<|>pub fn foo() {}\",\n-        )\n+        check_assist(change_visibility, \"<|>pub(crate) fn foo() {}\", \"<|>pub fn foo() {}\")\n     }\n \n     #[test]"}, {"sha": "741f75e2a76740e1f1bf17e3b0faebb87583edf7", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -27,10 +27,7 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n     let node_expr = syntax_mapping.node_expr(expr)?;\n     let match_expr_ty = infer_result[node_expr].clone();\n     let enum_def = match match_expr_ty {\n-        Ty::Adt {\n-            def_id: AdtDef::Enum(e),\n-            ..\n-        } => e,\n+        Ty::Adt { def_id: AdtDef::Enum(e), .. } => e,\n         _ => return None,\n     };\n     let enum_name = enum_def.name(ctx.db)?;"}, {"sha": "4f7c9f3c2302d78fb69e75a9b34888b09c297796", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -81,11 +81,7 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n             return Some((node, false));\n         }\n \n-        if let Some(expr) = node\n-            .parent()\n-            .and_then(ast::Block::cast)\n-            .and_then(|it| it.expr())\n-        {\n+        if let Some(expr) = node.parent().and_then(ast::Block::cast).and_then(|it| it.expr()) {\n             if expr.syntax() == node {\n                 return Some((node, false));\n             }"}, {"sha": "881db6347ff7a62e38a68cedc06adc0ef2a4b535", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -89,9 +89,7 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n }\n \n fn non_trivia_sibling(node: &SyntaxNode, direction: Direction) -> Option<&SyntaxNode> {\n-    node.siblings(direction)\n-        .skip(1)\n-        .find(|node| !node.kind().is_trivia())\n+    node.siblings(direction).skip(1).find(|node| !node.kind().is_trivia())\n }\n \n #[cfg(test)]\n@@ -110,10 +108,8 @@ mod helpers {\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n-        let frange = FileRange {\n-            file_id,\n-            range: TextRange::offset_len(before_cursor_pos, 0.into()),\n-        };\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n         let action = match assist {\n@@ -161,10 +157,8 @@ mod helpers {\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n-        let frange = FileRange {\n-            file_id,\n-            range: TextRange::offset_len(before_cursor_pos, 0.into()),\n-        };\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n     }"}, {"sha": "683f0d119d961b05ea3180d1c307c81bd764f897", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -30,11 +30,7 @@ fn build_match_expr(\n ) -> String {\n     let mut buf = String::new();\n     buf.push_str(&format!(\"match {} {{\\n\", expr.syntax().text()));\n-    buf.push_str(&format!(\n-        \"    {} => {}\\n\",\n-        pat1.syntax().text(),\n-        format_arm(arm1)\n-    ));\n+    buf.push_str(&format!(\"    {} => {}\\n\", pat1.syntax().text(), format_arm(arm1)));\n     buf.push_str(&format!(\"    _ => {}\\n\", format_arm(arm2)));\n     buf.push_str(\"}\");\n     buf"}, {"sha": "fb69cef9c5eca6d3875a82b77c8ea1e2d6b3d68d", "filename": "crates/ra_assists/src/split_import.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -8,9 +8,7 @@ use ra_syntax::{\n use crate::{AssistCtx, Assist};\n \n pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let colon_colon = ctx\n-        .leaf_at_offset()\n-        .find(|leaf| leaf.kind() == COLONCOLON)?;\n+    let colon_colon = ctx.leaf_at_offset().find(|leaf| leaf.kind() == COLONCOLON)?;\n     let path = colon_colon.parent().and_then(ast::Path::cast)?;\n     let top_path = generate(Some(path), |it| it.parent_path()).last()?;\n "}, {"sha": "a4debeb48e4401f62c96a3c6dfe810e948c38e26", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -13,18 +13,8 @@ fn main() -> Result<()> {\n         .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n         .subcommand(\n             SubCommand::with_name(\"render-test\")\n-                .arg(\n-                    Arg::with_name(\"line\")\n-                        .long(\"--line\")\n-                        .required(true)\n-                        .takes_value(true),\n-                )\n-                .arg(\n-                    Arg::with_name(\"file\")\n-                        .long(\"--file\")\n-                        .required(true)\n-                        .takes_value(true),\n-                ),\n+                .arg(Arg::with_name(\"line\").long(\"--line\").required(true).takes_value(true))\n+                .arg(Arg::with_name(\"file\").long(\"--file\").required(true).takes_value(true)),\n         )\n         .subcommand(SubCommand::with_name(\"parse\").arg(Arg::with_name(\"no-dump\").long(\"--no-dump\")))\n         .subcommand(SubCommand::with_name(\"symbols\"))\n@@ -108,8 +98,5 @@ fn selections(file: &SourceFile, start: u32, end: u32) -> String {\n         .iter()\n         .map(|r| (1 + u32::from(r.start()), 1 + u32::from(r.end())))\n         .map(|(s, e)| format!(\"({} {})\", s, e));\n-    join(ranges)\n-        .separator(\" \")\n-        .surround_with(\"(\", \")\")\n-        .to_string()\n+    join(ranges).separator(\" \").surround_with(\"(\", \")\").to_string()\n }"}, {"sha": "614325a0f668b678005399d6de230a8a952d3be9", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -64,10 +64,7 @@ struct CrateData {\n \n impl CrateData {\n     fn new(file_id: FileId) -> CrateData {\n-        CrateData {\n-            file_id,\n-            dependencies: Vec::new(),\n-        }\n+        CrateData { file_id, dependencies: Vec::new() }\n     }\n \n     fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n@@ -112,10 +109,7 @@ impl CrateGraph {\n         self.arena[&crate_id].file_id\n     }\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n-        let (&crate_id, _) = self\n-            .arena\n-            .iter()\n-            .find(|(_crate_id, data)| data.file_id == file_id)?;\n+        let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;\n         Some(crate_id)\n     }\n     pub fn dependencies<'a>(\n@@ -153,15 +147,9 @@ mod tests {\n         let crate1 = graph.add_crate_root(FileId(1u32));\n         let crate2 = graph.add_crate_root(FileId(2u32));\n         let crate3 = graph.add_crate_root(FileId(3u32));\n-        assert!(graph\n-            .add_dep(crate1, SmolStr::new(\"crate2\"), crate2)\n-            .is_ok());\n-        assert!(graph\n-            .add_dep(crate2, SmolStr::new(\"crate3\"), crate3)\n-            .is_ok());\n-        assert!(graph\n-            .add_dep(crate3, SmolStr::new(\"crate1\"), crate1)\n-            .is_err());\n+        assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n+        assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n+        assert!(graph.add_dep(crate3, SmolStr::new(\"crate1\"), crate1).is_err());\n     }\n \n     #[test]\n@@ -170,11 +158,7 @@ mod tests {\n         let crate1 = graph.add_crate_root(FileId(1u32));\n         let crate2 = graph.add_crate_root(FileId(2u32));\n         let crate3 = graph.add_crate_root(FileId(3u32));\n-        assert!(graph\n-            .add_dep(crate1, SmolStr::new(\"crate2\"), crate2)\n-            .is_ok());\n-        assert!(graph\n-            .add_dep(crate2, SmolStr::new(\"crate3\"), crate3)\n-            .is_ok());\n+        assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n+        assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n     }\n }"}, {"sha": "31442713df24c04419f67101ff3f4d2dbb240ac3", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -94,11 +94,8 @@ pub trait SourceDatabase: CheckCanceled + std::fmt::Debug {\n fn source_root_crates(db: &impl SourceDatabase, id: SourceRootId) -> Arc<Vec<CrateId>> {\n     let root = db.source_root(id);\n     let graph = db.crate_graph();\n-    let res = root\n-        .files\n-        .values()\n-        .filter_map(|&it| graph.crate_id_for_crate_root(it))\n-        .collect::<Vec<_>>();\n+    let res =\n+        root.files.values().filter_map(|&it| graph.crate_id_for_crate_root(it)).collect::<Vec<_>>();\n     Arc::new(res)\n }\n "}, {"sha": "d27fa76822ce7311da0b7d033628eb3adcbb4e77", "filename": "crates/ra_db/src/loc2id.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_db%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Floc2id.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -30,10 +30,7 @@ where\n     LOC: Clone + Eq + Hash,\n {\n     fn default() -> Self {\n-        Loc2IdMap {\n-            id2loc: Arena::default(),\n-            loc2id: FxHashMap::default(),\n-        }\n+        Loc2IdMap { id2loc: Arena::default(), loc2id: FxHashMap::default() }\n     }\n }\n \n@@ -85,9 +82,7 @@ where\n     LOC: Clone + Eq + Hash,\n {\n     fn default() -> Self {\n-        LocationIntener {\n-            map: Default::default(),\n-        }\n+        LocationIntener { map: Default::default() }\n     }\n }\n "}, {"sha": "6d917bb1b6fd678fa25d18b61e4250e0e9574cfd", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -62,10 +62,7 @@ impl StructData {\n }\n \n fn variants(enum_def: &ast::EnumDef) -> impl Iterator<Item = &ast::EnumVariant> {\n-    enum_def\n-        .variant_list()\n-        .into_iter()\n-        .flat_map(|it| it.variants())\n+    enum_def.variant_list().into_iter().flat_map(|it| it.variants())\n }\n \n impl EnumVariant {\n@@ -83,9 +80,7 @@ impl EnumVariant {\n         (file_id, var)\n     }\n     pub(crate) fn variant_data(&self, db: &impl PersistentHirDatabase) -> Arc<VariantData> {\n-        db.enum_data(self.parent).variants[self.id]\n-            .variant_data\n-            .clone()\n+        db.enum_data(self.parent).variants[self.id].variant_data.clone()\n     }\n }\n \n@@ -222,14 +217,12 @@ impl StructField {\n         };\n \n         let field_sources = match struct_flavor {\n-            ast::StructFlavor::Tuple(fl) => fl\n-                .fields()\n-                .map(|it| FieldSource::Pos(it.to_owned()))\n-                .collect(),\n-            ast::StructFlavor::Named(fl) => fl\n-                .fields()\n-                .map(|it| FieldSource::Named(it.to_owned()))\n-                .collect(),\n+            ast::StructFlavor::Tuple(fl) => {\n+                fl.fields().map(|it| FieldSource::Pos(it.to_owned())).collect()\n+            }\n+            ast::StructFlavor::Named(fl) => {\n+                fl.fields().map(|it| FieldSource::Named(it.to_owned())).collect()\n+            }\n             ast::StructFlavor::Unit => Vec::new(),\n         };\n         let field = field_sources"}, {"sha": "cafc5279d56e5b04d2a85e07894b499752300c36", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 13, "deletions": 58, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -71,17 +71,7 @@ pub enum ModuleDef {\n     Trait(Trait),\n     Type(Type),\n }\n-impl_froms!(\n-    ModuleDef: Module,\n-    Function,\n-    Struct,\n-    Enum,\n-    EnumVariant,\n-    Const,\n-    Static,\n-    Trait,\n-    Type\n-);\n+impl_froms!(ModuleDef: Module, Function, Struct, Enum, EnumVariant, Const, Static, Trait, Type);\n \n pub enum ModuleSource {\n     SourceFile(TreeArc<ast::SourceFile>),\n@@ -90,13 +80,8 @@ pub enum ModuleSource {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    },\n+    UnresolvedModule { candidate: RelativePathBuf },\n+    NotDirOwner { move_to: RelativePathBuf, candidate: RelativePathBuf },\n }\n \n impl Module {\n@@ -187,8 +172,7 @@ impl Module {\n \n impl Docs for Module {\n     fn docs(&self, db: &impl HirDatabase) -> Option<Documentation> {\n-        self.declaration_source(db)\n-            .and_then(|it| docs_from_ast(&*it.1))\n+        self.declaration_source(db).and_then(|it| docs_from_ast(&*it.1))\n     }\n }\n \n@@ -206,9 +190,7 @@ pub enum FieldSource {\n \n impl StructField {\n     pub fn name(&self, db: &impl HirDatabase) -> Name {\n-        self.parent.variant_data(db).fields().unwrap()[self.id]\n-            .name\n-            .clone()\n+        self.parent.variant_data(db).fields().unwrap()[self.id].name.clone()\n     }\n \n     pub fn source(&self, db: &impl PersistentHirDatabase) -> (HirFileId, FieldSource) {\n@@ -257,10 +239,7 @@ impl Struct {\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n-            .map(|(id, _)| StructField {\n-                parent: (*self).into(),\n-                id,\n-            })\n+            .map(|(id, _)| StructField { parent: (*self).into(), id })\n             .collect()\n     }\n \n@@ -271,10 +250,7 @@ impl Struct {\n             .into_iter()\n             .flat_map(|it| it.iter())\n             .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField {\n-                parent: (*self).into(),\n-                id,\n-            })\n+            .map(|(id, _)| StructField { parent: (*self).into(), id })\n     }\n \n     pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n@@ -292,11 +268,7 @@ impl Struct {\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n         let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() {\n-            r.push_generic_params_scope(p)\n-        } else {\n-            r\n-        };\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n }\n@@ -356,11 +328,7 @@ impl Enum {\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n         let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() {\n-            r.push_generic_params_scope(p)\n-        } else {\n-            r\n-        };\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n }\n@@ -400,10 +368,7 @@ impl EnumVariant {\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n-            .map(|(id, _)| StructField {\n-                parent: (*self).into(),\n-                id,\n-            })\n+            .map(|(id, _)| StructField { parent: (*self).into(), id })\n             .collect()\n     }\n \n@@ -413,10 +378,7 @@ impl EnumVariant {\n             .into_iter()\n             .flat_map(|it| it.iter())\n             .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField {\n-                parent: (*self).into(),\n-                id,\n-            })\n+            .map(|(id, _)| StructField { parent: (*self).into(), id })\n     }\n }\n \n@@ -488,10 +450,7 @@ impl Function {\n     pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSyntaxMapping {\n         let scopes = db.expr_scopes(*self);\n         let syntax_mapping = db.body_syntax_mapping(*self);\n-        ScopesWithSyntaxMapping {\n-            scopes,\n-            syntax_mapping,\n-        }\n+        ScopesWithSyntaxMapping { scopes, syntax_mapping }\n     }\n \n     pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n@@ -516,11 +475,7 @@ impl Function {\n             .unwrap_or_else(|| self.module(db).resolver(db));\n         // ...and add generic params, if present\n         let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() {\n-            r.push_generic_params_scope(p)\n-        } else {\n-            r\n-        };\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n }"}, {"sha": "b9438fdb79c68a8775a3144e2a5e9c9ff69ea8db", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -25,10 +25,7 @@ impl FnSignature {\n         func: Function,\n     ) -> Arc<FnSignature> {\n         let (_, node) = func.source(db);\n-        let name = node\n-            .name()\n-            .map(|n| n.as_name())\n-            .unwrap_or_else(Name::missing);\n+        let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n         let mut params = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = node.param_list() {\n@@ -61,12 +58,7 @@ impl FnSignature {\n             TypeRef::unit()\n         };\n \n-        let sig = FnSignature {\n-            name,\n-            params,\n-            ret_type,\n-            has_self_param,\n-        };\n+        let sig = FnSignature { name, params, ret_type, has_self_param };\n         Arc::new(sig)\n     }\n }"}, {"sha": "161ae6e1895d4a908bb2fb73a4786506c0e99212", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -11,9 +11,7 @@ impl Crate {\n         crate_graph\n             .dependencies(self.crate_id)\n             .map(|dep| {\n-                let krate = Crate {\n-                    crate_id: dep.crate_id(),\n-                };\n+                let krate = Crate { crate_id: dep.crate_id() };\n                 let name = dep.as_name();\n                 CrateDependency { krate, name }\n             })\n@@ -23,10 +21,7 @@ impl Crate {\n         let module_tree = db.module_tree(*self);\n         let module_id = module_tree.modules().next()?;\n \n-        let module = Module {\n-            krate: *self,\n-            module_id,\n-        };\n+        let module = Module { krate: *self, module_id };\n         Some(module)\n     }\n }"}, {"sha": "1425fa693db739d2d3c218dd4a9b5bb205293de7", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -12,10 +12,7 @@ use crate::{\n \n impl Module {\n     fn with_module_id(&self, module_id: ModuleId) -> Module {\n-        Module {\n-            module_id,\n-            krate: self.krate,\n-        }\n+        Module { module_id, krate: self.krate }\n     }\n \n     pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n@@ -42,10 +39,7 @@ impl Module {\n     ) -> Option<(FileId, TreeArc<ast::Module>)> {\n         let module_tree = db.module_tree(self.krate);\n         let link = self.module_id.parent_link(&module_tree)?;\n-        let file_id = link\n-            .owner(&module_tree)\n-            .file_id(&module_tree)\n-            .as_original_file();\n+        let file_id = link.owner(&module_tree).file_id(&module_tree).as_original_file();\n         let src = link.source(&module_tree, db);\n         Some((file_id, src))\n     }"}, {"sha": "4e61d87ff04505076057ddd57e8ca58490c87f83", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 27, "deletions": 123, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -121,9 +121,7 @@ impl BodySyntaxMapping {\n     }\n \n     pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n-        self.expr_syntax_mapping\n-            .get(&SyntaxNodePtr::new(node.syntax()))\n-            .cloned()\n+        self.expr_syntax_mapping.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n \n     pub fn pat_syntax(&self, pat: PatId) -> Option<SyntaxNodePtr> {\n@@ -135,9 +133,7 @@ impl BodySyntaxMapping {\n     }\n \n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n-        self.pat_syntax_mapping\n-            .get(&SyntaxNodePtr::new(node.syntax()))\n-            .cloned()\n+        self.pat_syntax_mapping.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n \n     pub fn body(&self) -> &Arc<Body> {\n@@ -262,11 +258,7 @@ pub struct StructLitField {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Statement {\n-    Let {\n-        pat: PatId,\n-        type_ref: Option<TypeRef>,\n-        initializer: Option<ExprId>,\n-    },\n+    Let { pat: PatId, type_ref: Option<TypeRef>, initializer: Option<ExprId> },\n     Expr(ExprId),\n }\n \n@@ -275,11 +267,7 @@ impl Expr {\n         match self {\n             Expr::Missing => {}\n             Expr::Path(_) => {}\n-            Expr::If {\n-                condition,\n-                then_branch,\n-                else_branch,\n-            } => {\n+            Expr::If { condition, then_branch, else_branch } => {\n                 f(*condition);\n                 f(*then_branch);\n                 if let Some(else_branch) = else_branch {\n@@ -457,11 +445,7 @@ impl Pat {\n                 args.iter().map(|pat| *pat).for_each(f);\n             }\n             Pat::Ref { pat, .. } => f(*pat),\n-            Pat::Slice {\n-                prefix,\n-                rest,\n-                suffix,\n-            } => {\n+            Pat::Slice { prefix, rest, suffix } => {\n                 let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n                 total_iter.map(|pat| *pat).for_each(f);\n             }\n@@ -520,10 +504,7 @@ impl ExprCollector {\n     }\n \n     fn empty_block(&mut self) -> ExprId {\n-        let block = Expr::Block {\n-            statements: Vec::new(),\n-            tail: None,\n-        };\n+        let block = Expr::Block { statements: Vec::new(), tail: None };\n         self.exprs.alloc(block)\n     }\n \n@@ -549,24 +530,10 @@ impl ExprCollector {\n                         .unwrap_or_else(|| self.empty_block());\n                     let placeholder_pat = self.pats.alloc(Pat::Missing);\n                     let arms = vec![\n-                        MatchArm {\n-                            pats: vec![pat],\n-                            expr: then_branch,\n-                            guard: None,\n-                        },\n-                        MatchArm {\n-                            pats: vec![placeholder_pat],\n-                            expr: else_branch,\n-                            guard: None,\n-                        },\n+                        MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                        MatchArm { pats: vec![placeholder_pat], expr: else_branch, guard: None },\n                     ];\n-                    self.alloc_expr(\n-                        Expr::Match {\n-                            expr: match_expr,\n-                            arms,\n-                        },\n-                        syntax_ptr,\n-                    )\n+                    self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n                 } else {\n                     let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n                     let then_branch = self.collect_block_opt(e.then_branch());\n@@ -577,14 +544,7 @@ impl ExprCollector {\n                             self.collect_expr(expr)\n                         }\n                     });\n-                    self.alloc_expr(\n-                        Expr::If {\n-                            condition,\n-                            then_branch,\n-                            else_branch,\n-                        },\n-                        syntax_ptr,\n-                    )\n+                    self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n                 }\n             }\n             ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n@@ -610,14 +570,7 @@ impl ExprCollector {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(\n-                    Expr::For {\n-                        iterable,\n-                        pat,\n-                        body,\n-                    },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n             }\n             ast::ExprKind::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -635,18 +588,8 @@ impl ExprCollector {\n                 } else {\n                     Vec::new()\n                 };\n-                let method_name = e\n-                    .name_ref()\n-                    .map(|nr| nr.as_name())\n-                    .unwrap_or_else(Name::missing);\n-                self.alloc_expr(\n-                    Expr::MethodCall {\n-                        receiver,\n-                        method_name,\n-                        args,\n-                    },\n-                    syntax_ptr,\n-                )\n+                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                self.alloc_expr(Expr::MethodCall { receiver, method_name, args }, syntax_ptr)\n             }\n             ast::ExprKind::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -668,11 +611,8 @@ impl ExprCollector {\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n             ast::ExprKind::PathExpr(e) => {\n-                let path = e\n-                    .path()\n-                    .and_then(Path::from_ast)\n-                    .map(Expr::Path)\n-                    .unwrap_or(Expr::Missing);\n+                let path =\n+                    e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n             ast::ExprKind::ContinueExpr(_e) => {\n@@ -721,21 +661,11 @@ impl ExprCollector {\n                     Vec::new()\n                 };\n                 let spread = e.spread().map(|s| self.collect_expr(s));\n-                self.alloc_expr(\n-                    Expr::StructLit {\n-                        path,\n-                        fields,\n-                        spread,\n-                    },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr)\n             }\n             ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let name = e\n-                    .name_ref()\n-                    .map(|nr| nr.as_name())\n-                    .unwrap_or_else(Name::missing);\n+                let name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n             ast::ExprKind::TryExpr(e) => {\n@@ -772,14 +702,7 @@ impl ExprCollector {\n                     }\n                 }\n                 let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(\n-                    Expr::Lambda {\n-                        args,\n-                        arg_types,\n-                        body,\n-                    },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n             }\n             ast::ExprKind::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n@@ -804,9 +727,8 @@ impl ExprCollector {\n \n                 let lit = match child.flavor() {\n                     LiteralFlavor::IntNumber { suffix } => {\n-                        let known_name = suffix\n-                            .map(Name::new)\n-                            .and_then(|name| UncertainIntTy::from_name(&name));\n+                        let known_name =\n+                            suffix.map(Name::new).and_then(|name| UncertainIntTy::from_name(&name));\n \n                         Literal::Int(\n                             Default::default(),\n@@ -857,22 +779,15 @@ impl ExprCollector {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.type_ref().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let {\n-                        pat,\n-                        type_ref,\n-                        initializer,\n-                    }\n+                    Statement::Let { pat, type_ref, initializer }\n                 }\n                 ast::StmtKind::ExprStmt(stmt) => {\n                     Statement::Expr(self.collect_expr_opt(stmt.expr()))\n                 }\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(\n-            Expr::Block { statements, tail },\n-            SyntaxNodePtr::new(block.syntax()),\n-        )\n+        self.alloc_expr(Expr::Block { statements, tail }, SyntaxNodePtr::new(block.syntax()))\n     }\n \n     fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n@@ -886,17 +801,10 @@ impl ExprCollector {\n     fn collect_pat(&mut self, pat: &ast::Pat) -> PatId {\n         let pattern = match pat.kind() {\n             ast::PatKind::BindPat(bp) => {\n-                let name = bp\n-                    .name()\n-                    .map(|nr| nr.as_name())\n-                    .unwrap_or_else(Name::missing);\n+                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n                 let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n-                Pat::Bind {\n-                    name,\n-                    mode: annotation,\n-                    subpat,\n-                }\n+                Pat::Bind { name, mode: annotation, subpat }\n             }\n             ast::PatKind::TupleStructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n@@ -919,9 +827,8 @@ impl ExprCollector {\n             ast::PatKind::PlaceholderPat(_) => Pat::Wild,\n             ast::PatKind::StructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n-                let field_pat_list = p\n-                    .field_pat_list()\n-                    .expect(\"every struct should have a field list\");\n+                let field_pat_list =\n+                    p.field_pat_list().expect(\"every struct should have a field list\");\n                 let mut fields: Vec<_> = field_pat_list\n                     .bind_pats()\n                     .map(|bind_pat| {\n@@ -961,10 +868,7 @@ impl ExprCollector {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_param = SyntaxNodePtr::new(\n-                    self_param\n-                        .self_kw()\n-                        .expect(\"self param without self keyword\")\n-                        .syntax(),\n+                    self_param.self_kw().expect(\"self param without self keyword\").syntax(),\n                 );\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {"}, {"sha": "44d5c2429333123960edc6c7b5f9b17cece17909", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 11, "deletions": 41, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -74,28 +74,19 @@ impl ExprScopes {\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: None,\n-            entries: vec![],\n-        })\n+        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n     }\n \n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: Some(parent),\n-            entries: vec![],\n-        })\n+        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n     }\n \n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n         match &body[pat] {\n             Pat::Bind { name, .. } => {\n                 // bind can have a subpattern, but it's actually not allowed\n                 // to bind to things in there\n-                let entry = ScopeEntry {\n-                    name: name.clone(),\n-                    pat,\n-                };\n+                let entry = ScopeEntry { name: name.clone(), pat };\n                 self.scopes[scope].entries.push(entry)\n             }\n             p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n@@ -104,9 +95,7 @@ impl ExprScopes {\n \n     fn add_params_bindings(&mut self, scope: ScopeId, params: &[PatId]) {\n         let body = Arc::clone(&self.body);\n-        params\n-            .iter()\n-            .for_each(|pat| self.add_bindings(&body, scope, *pat));\n+        params.iter().for_each(|pat| self.add_bindings(&body, scope, *pat));\n     }\n \n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n@@ -142,9 +131,7 @@ impl ScopeEntryWithSyntax {\n \n impl ScopesWithSyntaxMapping {\n     fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| {\n-            self.scopes.scopes[scope].parent\n-        })\n+        generate(self.scope_for(node), move |&scope| self.scopes.scopes[scope].parent)\n     }\n \n     pub fn scope_for_offset(&self, offset: TextUnit) -> Option<ScopeId> {\n@@ -154,10 +141,7 @@ impl ScopesWithSyntaxMapping {\n             .filter_map(|(id, scope)| Some((self.syntax_mapping.expr_syntax(*id)?, scope)))\n             // find containing scope\n             .min_by_key(|(ptr, _scope)| {\n-                (\n-                    !(ptr.range().start() <= offset && offset <= ptr.range().end()),\n-                    ptr.range().len(),\n-                )\n+                (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n             })\n             .map(|(ptr, scope)| self.adjust(ptr, *scope, offset))\n     }\n@@ -251,9 +235,7 @@ fn compute_block_scopes(\n ) {\n     for stmt in statements {\n         match stmt {\n-            Statement::Let {\n-                pat, initializer, ..\n-            } => {\n+            Statement::Let { pat, initializer, .. } => {\n                 if let Some(expr) = initializer {\n                     scopes.set_scope(*expr, scope);\n                     compute_expr_scopes(*expr, body, scopes, scope);\n@@ -278,21 +260,13 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         Expr::Block { statements, tail } => {\n             compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n-        Expr::For {\n-            iterable,\n-            pat,\n-            body: body_expr,\n-        } => {\n+        Expr::For { iterable, pat, body: body_expr } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let scope = scopes.new_scope(scope);\n             scopes.add_bindings(body, scope, *pat);\n             compute_expr_scopes(*body_expr, body, scopes, scope);\n         }\n-        Expr::Lambda {\n-            args,\n-            body: body_expr,\n-            ..\n-        } => {\n+        Expr::Lambda { args, body: body_expr, .. } => {\n             let scope = scopes.new_scope(scope);\n             scopes.add_params_bindings(scope, &args);\n             compute_expr_scopes(*body_expr, body, scopes, scope);\n@@ -341,9 +315,7 @@ mod tests {\n         let file = SourceFile::parse(&code);\n         let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let irrelevant_function = Function {\n-            id: crate::ids::FunctionId::from_raw(0.into()),\n-        };\n+        let irrelevant_function = Function { id: crate::ids::FunctionId::from_raw(0.into()) };\n         let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n@@ -444,9 +416,7 @@ mod tests {\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n-        let irrelevant_function = Function {\n-            id: crate::ids::FunctionId::from_raw(0.into()),\n-        };\n+        let irrelevant_function = Function { id: crate::ids::FunctionId::from_raw(0.into()) };\n         let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {"}, {"sha": "c72360f44220613130078e92e03c4dd882f2899b", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -58,14 +58,8 @@ impl GenericParams {\n \n     fn fill_params(&mut self, params: &ast::TypeParamList) {\n         for (idx, type_param) in params.type_params().enumerate() {\n-            let name = type_param\n-                .name()\n-                .map(AsName::as_name)\n-                .unwrap_or_else(Name::missing);\n-            let param = GenericParam {\n-                idx: idx as u32,\n-                name,\n-            };\n+            let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n+            let param = GenericParam { idx: idx as u32, name };\n             self.params.push(param);\n         }\n     }"}, {"sha": "ea13c1196da431772f3f495afc5ac1220caafb86", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -169,11 +169,7 @@ impl<N: AstNode> Hash for ItemLoc<N> {\n \n impl<N: AstNode> Clone for ItemLoc<N> {\n     fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc {\n-            module: self.module,\n-            raw: self.raw,\n-            _ty: PhantomData,\n-        }\n+        ItemLoc { module: self.module, raw: self.raw, _ty: PhantomData }\n     }\n }\n \n@@ -186,11 +182,7 @@ pub(crate) struct LocationCtx<DB> {\n \n impl<'a, DB: PersistentHirDatabase> LocationCtx<&'a DB> {\n     pub(crate) fn new(db: &'a DB, module: Module, file_id: HirFileId) -> LocationCtx<&'a DB> {\n-        LocationCtx {\n-            db,\n-            module,\n-            file_id,\n-        }\n+        LocationCtx { db, module, file_id }\n     }\n     pub(crate) fn to_def<N, DEF>(self, ast: &N) -> DEF\n     where\n@@ -205,25 +197,18 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl PersistentHirDatabase>, ast: &N) -> Self {\n         let items = ctx.db.file_items(ctx.file_id);\n-        let raw = SourceItemId {\n-            file_id: ctx.file_id,\n-            item_id: items.id_of(ctx.file_id, ast.syntax()),\n-        };\n-        let loc = ItemLoc {\n-            module: ctx.module,\n-            raw,\n-            _ty: PhantomData,\n-        };\n+        let raw =\n+            SourceItemId { file_id: ctx.file_id, item_id: items.id_of(ctx.file_id, ast.syntax()) };\n+        let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n \n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n     }\n     fn source(self, db: &impl PersistentHirDatabase) -> (HirFileId, TreeArc<N>) {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n         let syntax = db.file_item(loc.raw);\n-        let ast = N::cast(&syntax)\n-            .unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw))\n-            .to_owned();\n+        let ast =\n+            N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n         (loc.raw.file_id, ast)\n     }\n     fn module(self, db: &impl HirDatabase) -> Module {\n@@ -317,10 +302,7 @@ pub struct SourceFileItems {\n \n impl SourceFileItems {\n     pub(crate) fn new(file_id: HirFileId, source_file: &SourceFile) -> SourceFileItems {\n-        let mut res = SourceFileItems {\n-            file_id,\n-            arena: Arena::default(),\n-        };\n+        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n         res.init(source_file);\n         res\n     }"}, {"sha": "b2fbee8d70be0a37defeb292bc56debda26e3a76", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -50,17 +50,11 @@ impl ImplBlock {\n         item: ImplItem,\n     ) -> Option<ImplBlock> {\n         let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n-        Some(ImplBlock {\n-            module_impl_blocks,\n-            impl_id,\n-        })\n+        Some(ImplBlock { module_impl_blocks, impl_id })\n     }\n \n     pub(crate) fn from_id(module_impl_blocks: Arc<ModuleImplBlocks>, impl_id: ImplId) -> ImplBlock {\n-        ImplBlock {\n-            module_impl_blocks,\n-            impl_id,\n-        }\n+        ImplBlock { module_impl_blocks, impl_id }\n     }\n \n     pub fn id(&self) -> ImplId {\n@@ -144,11 +138,7 @@ impl ImplData {\n         } else {\n             Vec::new()\n         };\n-        ImplData {\n-            target_trait,\n-            target_type,\n-            items,\n-        }\n+        ImplData { target_trait, target_type, items }\n     }\n \n     pub fn target_trait(&self) -> Option<&TypeRef> {\n@@ -212,10 +202,9 @@ impl ModuleImplBlocks {\n         let file_id: HirFileId = file_id.into();\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n-            ModuleSource::Module(node) => node\n-                .item_list()\n-                .expect(\"inline module should have item list\")\n-                .syntax(),\n+            ModuleSource::Module(node) => {\n+                node.item_list().expect(\"inline module should have item list\").syntax()\n+            }\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {"}, {"sha": "95925159f7428db52012910b7bc81fd547201aaf", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -48,9 +48,7 @@ impl MacroDef {\n \n         let input = {\n             let arg = macro_call.token_tree()?.syntax();\n-            MacroInput {\n-                text: arg.text().to_string(),\n-            }\n+            MacroInput { text: arg.text().to_string() }\n         };\n         Some((def, input))\n     }\n@@ -68,20 +66,14 @@ impl MacroDef {\n         let ptr = SyntaxNodePtr::new(array_expr.syntax());\n         let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n         let ranges_map = vec![(src_range, array_expr.syntax().range())];\n-        let res = MacroExpansion {\n-            text,\n-            ranges_map,\n-            ptr,\n-        };\n+        let res = MacroExpansion { text, ranges_map, ptr };\n         Some(res)\n     }\n     fn expand_query_group(self, input: MacroInput) -> Option<MacroExpansion> {\n         let anchor = \"trait \";\n         let pos = input.text.find(anchor)? + anchor.len();\n-        let trait_name = input.text[pos..]\n-            .chars()\n-            .take_while(|c| c.is_alphabetic())\n-            .collect::<String>();\n+        let trait_name =\n+            input.text[pos..].chars().take_while(|c| c.is_alphabetic()).collect::<String>();\n         if trait_name.is_empty() {\n             return None;\n         }\n@@ -92,11 +84,7 @@ impl MacroDef {\n         let name = trait_def.name()?;\n         let ptr = SyntaxNodePtr::new(trait_def.syntax());\n         let ranges_map = vec![(src_range, name.syntax().range())];\n-        let res = MacroExpansion {\n-            text,\n-            ranges_map,\n-            ptr,\n-        };\n+        let res = MacroExpansion { text, ranges_map, ptr };\n         Some(res)\n     }\n }"}, {"sha": "950f89948f540f8a34eeba329f455ef3fec2d619", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -64,10 +64,7 @@ impl MockDatabase {\n         let mut source_root = SourceRoot::default();\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n-                assert!(\n-                    position.is_none(),\n-                    \"only one marker (<|>) per fixture is allowed\"\n-                );\n+                assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n                 position = Some(self.add_file_with_position(\n                     source_root_id,\n                     &mut source_root,"}, {"sha": "1f19ee1913b7259c4621626105f285c77c7a4a17", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -153,10 +153,8 @@ impl ModuleTree {\n         file_id: HirFileId,\n         decl_id: Option<SourceFileItemId>,\n     ) -> Option<ModuleId> {\n-        let (res, _) = self\n-            .mods\n-            .iter()\n-            .find(|(_, m)| (m.file_id, m.decl_id) == (file_id, decl_id))?;\n+        let (res, _) =\n+            self.mods.iter().find(|(_, m)| (m.file_id, m.decl_id) == (file_id, decl_id))?;\n         Some(res)\n     }\n \n@@ -178,18 +176,10 @@ impl ModuleTree {\n         decl_id: Option<SourceFileItemId>,\n     ) -> ModuleId {\n         let is_root = parent.is_none();\n-        let id = self.alloc_mod(ModuleData {\n-            file_id,\n-            decl_id,\n-            parent,\n-            children: Vec::new(),\n-        });\n+        let id = self.alloc_mod(ModuleData { file_id, decl_id, parent, children: Vec::new() });\n         for sub in db.submodules(file_id, decl_id).iter() {\n             let link = self.alloc_link(LinkData {\n-                source: SourceItemId {\n-                    file_id,\n-                    item_id: sub.decl_id,\n-                },\n+                source: SourceItemId { file_id, item_id: sub.decl_id },\n                 name: sub.name.clone(),\n                 owner: id,\n                 points_to: Vec::new(),\n@@ -244,9 +234,7 @@ impl ModuleId {\n         Some(tree.links[link].owner)\n     }\n     pub(crate) fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n-        generate(Some(self), move |it| it.parent(tree))\n-            .last()\n-            .unwrap()\n+        generate(Some(self), move |it| it.parent(tree)).last().unwrap()\n     }\n     pub(crate) fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n         let link = tree.mods[self]"}, {"sha": "b7382d9c3104f4ebb412c2a4124d6b7a4af6fc7d", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 21, "deletions": 74, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -83,40 +83,25 @@ pub struct PerNs<T> {\n \n impl<T> Default for PerNs<T> {\n     fn default() -> Self {\n-        PerNs {\n-            types: None,\n-            values: None,\n-        }\n+        PerNs { types: None, values: None }\n     }\n }\n \n impl<T> PerNs<T> {\n     pub fn none() -> PerNs<T> {\n-        PerNs {\n-            types: None,\n-            values: None,\n-        }\n+        PerNs { types: None, values: None }\n     }\n \n     pub fn values(t: T) -> PerNs<T> {\n-        PerNs {\n-            types: None,\n-            values: Some(t),\n-        }\n+        PerNs { types: None, values: Some(t) }\n     }\n \n     pub fn types(t: T) -> PerNs<T> {\n-        PerNs {\n-            types: Some(t),\n-            values: None,\n-        }\n+        PerNs { types: Some(t), values: None }\n     }\n \n     pub fn both(types: T, values: T) -> PerNs<T> {\n-        PerNs {\n-            types: Some(types),\n-            values: Some(values),\n-        }\n+        PerNs { types: Some(types), values: Some(values) }\n     }\n \n     pub fn is_none(&self) -> bool {\n@@ -147,31 +132,19 @@ impl<T> PerNs<T> {\n     }\n \n     pub fn as_ref(&self) -> PerNs<&T> {\n-        PerNs {\n-            types: self.types.as_ref(),\n-            values: self.values.as_ref(),\n-        }\n+        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n     }\n \n     pub fn combine(self, other: PerNs<T>) -> PerNs<T> {\n-        PerNs {\n-            types: self.types.or(other.types),\n-            values: self.values.or(other.values),\n-        }\n+        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n     }\n \n     pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n-        PerNs {\n-            types: self.types.and_then(&f),\n-            values: self.values.and_then(&f),\n-        }\n+        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n     }\n \n     pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n-        PerNs {\n-            types: self.types.map(&f),\n-            values: self.values.map(&f),\n-        }\n+        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n     }\n }\n \n@@ -233,9 +206,7 @@ where\n         for dep in self.krate.dependencies(self.db) {\n             log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n             if let Some(module) = dep.krate.root_module(self.db) {\n-                self.result\n-                    .extern_prelude\n-                    .insert(dep.name.clone(), module.into());\n+                self.result.extern_prelude.insert(dep.name.clone(), module.into());\n             }\n         }\n     }\n@@ -245,17 +216,11 @@ where\n         for (import_id, import_data) in input.imports.iter() {\n             if let Some(last_segment) = import_data.path.segments.iter().last() {\n                 if !import_data.is_glob {\n-                    let name = import_data\n-                        .alias\n-                        .clone()\n-                        .unwrap_or_else(|| last_segment.name.clone());\n-                    module_items.items.insert(\n-                        name,\n-                        Resolution {\n-                            def: PerNs::none(),\n-                            import: Some(import_id),\n-                        },\n-                    );\n+                    let name =\n+                        import_data.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n+                    module_items\n+                        .items\n+                        .insert(name, Resolution { def: PerNs::none(), import: Some(import_id) });\n                 }\n             }\n         }\n@@ -267,10 +232,7 @@ where\n \n         // Populate modules\n         for (name, module_id) in module_id.children(&self.module_tree) {\n-            let module = Module {\n-                module_id,\n-                krate: self.krate,\n-            };\n+            let module = Module { module_id, krate: self.krate };\n             self.add_module_item(&mut module_items, name, PerNs::types(module.into()));\n         }\n \n@@ -305,20 +267,13 @@ where\n         if import.is_glob {\n             return ReachedFixedPoint::Yes;\n         };\n-        let original_module = Module {\n-            krate: self.krate,\n-            module_id,\n-        };\n+        let original_module = Module { krate: self.krate, module_id };\n         let (def, reached_fixedpoint) =\n-            self.result\n-                .resolve_path_fp(self.db, original_module, &import.path);\n+            self.result.resolve_path_fp(self.db, original_module, &import.path);\n \n         if reached_fixedpoint == ReachedFixedPoint::Yes {\n             let last_segment = import.path.segments.last().unwrap();\n-            let name = import\n-                .alias\n-                .clone()\n-                .unwrap_or_else(|| last_segment.name.clone());\n+            let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n             log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n             // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n@@ -330,10 +285,7 @@ where\n                 }\n             }\n             self.update(module_id, |items| {\n-                let res = Resolution {\n-                    def,\n-                    import: Some(import_id),\n-                };\n+                let res = Resolution { def, import: Some(import_id) };\n                 items.items.insert(name, res);\n             });\n         }\n@@ -358,12 +310,7 @@ impl ItemMap {\n         let module_tree = db.module_tree(krate);\n         let input = module_tree\n             .modules()\n-            .map(|module_id| {\n-                (\n-                    module_id,\n-                    db.lower_module_module(Module { krate, module_id }),\n-                )\n-            })\n+            .map(|module_id| (module_id, db.lower_module_module(Module { krate, module_id })))\n             .collect::<FxHashMap<_, _>>();\n \n         let resolver = Resolver::new(db, &input, krate);"}, {"sha": "7e9a3de2bf208f129174d03b9217a80737d06ed3", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -82,13 +82,9 @@ impl LoweredModule {\n         let mut source_map = ImportSourceMap::default();\n         let mut res = LoweredModule::default();\n         match source {\n-            ModuleSource::SourceFile(it) => res.fill(\n-                &mut source_map,\n-                db,\n-                module,\n-                file_id,\n-                &mut it.items_with_macros(),\n-            ),\n+            ModuleSource::SourceFile(it) => {\n+                res.fill(&mut source_map, db, module, file_id, &mut it.items_with_macros())\n+            }\n             ModuleSource::Module(it) => {\n                 if let Some(item_list) = it.item_list() {\n                     res.fill(\n@@ -121,10 +117,8 @@ impl LoweredModule {\n                 }\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     let item_id = file_items.id_of_unchecked(macro_call.syntax());\n-                    let loc = MacroCallLoc {\n-                        module,\n-                        source_item_id: SourceItemId { file_id, item_id },\n-                    };\n+                    let loc =\n+                        MacroCallLoc { module, source_item_id: SourceItemId { file_id, item_id } };\n                     let id = loc.id(db);\n                     let file_id = HirFileId::from(id);\n                     //FIXME: expand recursively\n@@ -163,22 +157,19 @@ impl LoweredModule {\n             ast::ModuleItemKind::FnDef(it) => {\n                 if let Some(name) = it.name() {\n                     let func = Function { id: ctx.to_def(it) };\n-                    self.declarations\n-                        .insert(name.as_name(), PerNs::values(func.into()));\n+                    self.declarations.insert(name.as_name(), PerNs::values(func.into()));\n                 }\n             }\n             ast::ModuleItemKind::TraitDef(it) => {\n                 if let Some(name) = it.name() {\n                     let t = Trait { id: ctx.to_def(it) };\n-                    self.declarations\n-                        .insert(name.as_name(), PerNs::types(t.into()));\n+                    self.declarations.insert(name.as_name(), PerNs::types(t.into()));\n                 }\n             }\n             ast::ModuleItemKind::TypeDef(it) => {\n                 if let Some(name) = it.name() {\n                     let t = Type { id: ctx.to_def(it) };\n-                    self.declarations\n-                        .insert(name.as_name(), PerNs::types(t.into()));\n+                    self.declarations.insert(name.as_name(), PerNs::types(t.into()));\n                 }\n             }\n             ast::ModuleItemKind::ImplBlock(_) => {\n@@ -207,15 +198,13 @@ impl LoweredModule {\n             ast::ModuleItemKind::ConstDef(it) => {\n                 if let Some(name) = it.name() {\n                     let c = Const { id: ctx.to_def(it) };\n-                    self.declarations\n-                        .insert(name.as_name(), PerNs::values(c.into()));\n+                    self.declarations.insert(name.as_name(), PerNs::values(c.into()));\n                 }\n             }\n             ast::ModuleItemKind::StaticDef(it) => {\n                 if let Some(name) = it.name() {\n                     let s = Static { id: ctx.to_def(it) };\n-                    self.declarations\n-                        .insert(name.as_name(), PerNs::values(s.into()));\n+                    self.declarations.insert(name.as_name(), PerNs::values(s.into()));\n                 }\n             }\n             ast::ModuleItemKind::Module(_) => {"}, {"sha": "3dfad6bf2aef7869bec062faa109f92318907643", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -42,19 +42,11 @@ fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n         .collect::<Vec<_>>();\n     lines.sort();\n     let actual = lines.join(\"\\n\");\n-    let expected = expected\n-        .trim()\n-        .lines()\n-        .map(|it| it.trim())\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n+    let expected = expected.trim().lines().map(|it| it.trim()).collect::<Vec<_>>().join(\"\\n\");\n     assert_eq_text!(&expected, &actual);\n \n     fn dump_resolution(resolution: &Resolution) -> &'static str {\n-        match (\n-            resolution.def.types.is_some(),\n-            resolution.def.values.is_some(),\n-        ) {\n+        match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n             (true, true) => \"t v\",\n             (true, false) => \"t\",\n             (false, true) => \"v\",\n@@ -314,9 +306,7 @@ fn item_map_across_crates() {\n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n     let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph\n-        .add_dep(main_crate, \"test_crate\".into(), lib_crate)\n-        .unwrap();\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n \n     db.set_crate_graph(Arc::new(crate_graph));\n \n@@ -357,9 +347,7 @@ fn extern_crate_rename() {\n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n     let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph\n-        .add_dep(main_crate, \"alloc\".into(), lib_crate)\n-        .unwrap();\n+    crate_graph.add_dep(main_crate, \"alloc\".into(), lib_crate).unwrap();\n \n     db.set_crate_graph(Arc::new(crate_graph));\n \n@@ -406,9 +394,7 @@ fn import_across_source_roots() {\n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n     let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph\n-        .add_dep(main_crate, \"test_crate\".into(), lib_crate)\n-        .unwrap();\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n \n     db.set_crate_graph(Arc::new(crate_graph));\n \n@@ -447,9 +433,7 @@ fn reexport_across_crates() {\n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n     let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph\n-        .add_dep(main_crate, \"test_crate\".into(), lib_crate)\n-        .unwrap();\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n \n     db.set_crate_graph(Arc::new(crate_graph));\n \n@@ -482,11 +466,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n         let events = db.log_executed(|| {\n             db.item_map(krate);\n         });\n-        assert!(\n-            !format!(\"{:?}\", events).contains(\"item_map\"),\n-            \"{:#?}\",\n-            events\n-        )\n+        assert!(!format!(\"{:?}\", events).contains(\"item_map\"), \"{:#?}\", events)\n     }\n }\n "}, {"sha": "6a24c8aa768193605e1e5ebc7e5946347365d828", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -66,14 +66,9 @@ impl Path {\n \n             match segment.kind()? {\n                 ast::PathSegmentKind::Name(name) => {\n-                    let args = segment\n-                        .type_arg_list()\n-                        .and_then(GenericArgs::from_ast)\n-                        .map(Arc::new);\n-                    let segment = PathSegment {\n-                        name: name.as_name(),\n-                        args_and_bindings: args,\n-                    };\n+                    let args =\n+                        segment.type_arg_list().and_then(GenericArgs::from_ast).map(Arc::new);\n+                    let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n                     segments.push(segment);\n                 }\n                 ast::PathSegmentKind::CrateKw => {\n@@ -153,10 +148,7 @@ impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             kind: PathKind::Plain,\n-            segments: vec![PathSegment {\n-                name,\n-                args_and_bindings: None,\n-            }],\n+            segments: vec![PathSegment { name, args_and_bindings: None }],\n         }\n     }\n }\n@@ -209,18 +201,13 @@ fn expand_use_tree<'a>(\n }\n \n fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n-    let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual)?)\n-    } else {\n-        prefix\n-    };\n+    let prefix =\n+        if let Some(qual) = path.qualifier() { Some(convert_path(prefix, qual)?) } else { prefix };\n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name) => {\n-            let mut res = prefix.unwrap_or_else(|| Path {\n-                kind: PathKind::Plain,\n-                segments: Vec::with_capacity(1),\n-            });\n+            let mut res = prefix\n+                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n             res.segments.push(PathSegment {\n                 name: name.as_name(),\n                 args_and_bindings: None, // no type args in use\n@@ -231,28 +218,19 @@ fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path {\n-                kind: PathKind::Crate,\n-                segments: Vec::new(),\n-            }\n+            Path { kind: PathKind::Crate, segments: Vec::new() }\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path {\n-                kind: PathKind::Self_,\n-                segments: Vec::new(),\n-            }\n+            Path { kind: PathKind::Self_, segments: Vec::new() }\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path {\n-                kind: PathKind::Super,\n-                segments: Vec::new(),\n-            }\n+            Path { kind: PathKind::Super, segments: Vec::new() }\n         }\n     };\n     Some(res)"}, {"sha": "03113e7cc217bcd7824c250c6c33f47821b99727", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -23,7 +23,5 @@ pub(super) fn file_item(\n     source_item_id: SourceItemId,\n ) -> TreeArc<SyntaxNode> {\n     let source_file = db.hir_parse(source_item_id.file_id);\n-    db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-        .to_node(&source_file)\n-        .to_owned()\n+    db.file_items(source_item_id.file_id)[source_item_id.item_id].to_node(&source_file).to_owned()\n }"}, {"sha": "3d7ec5683d2760698d395018dd687a82623e137c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -138,10 +138,7 @@ impl Resolver {\n         expr_scopes: Arc<ExprScopes>,\n         scope_id: ScopeId,\n     ) -> Resolver {\n-        self.push_scope(Scope::ExprScope(ExprScope {\n-            expr_scopes,\n-            scope_id,\n-        }))\n+        self.push_scope(Scope::ExprScope(ExprScope { expr_scopes, scope_id }))\n     }\n }\n \n@@ -170,11 +167,8 @@ impl Scope {\n                 }\n             }\n             Scope::ExprScope(e) => {\n-                let entry = e\n-                    .expr_scopes\n-                    .entries(e.scope_id)\n-                    .iter()\n-                    .find(|entry| entry.name() == name);\n+                let entry =\n+                    e.expr_scopes.entries(e.scope_id).iter().find(|entry| entry.name() == name);\n                 match entry {\n                     Some(e) => PerNs::values(Resolution::LocalBinding(e.pat())),\n                     None => PerNs::none(),\n@@ -193,35 +187,24 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.item_map[m.module.module_id]\n-                    .entries()\n-                    .for_each(|(name, res)| {\n-                        f(name.clone(), res.def.map(Resolution::Def));\n-                    });\n+                m.item_map[m.module.module_id].entries().for_each(|(name, res)| {\n+                    f(name.clone(), res.def.map(Resolution::Def));\n+                });\n                 m.item_map.extern_prelude.iter().for_each(|(name, def)| {\n                     f(name.clone(), PerNs::types(Resolution::Def(*def)));\n                 });\n             }\n             Scope::GenericParams(gp) => {\n                 for param in &gp.params {\n-                    f(\n-                        param.name.clone(),\n-                        PerNs::types(Resolution::GenericParam(param.idx)),\n-                    )\n+                    f(param.name.clone(), PerNs::types(Resolution::GenericParam(param.idx)))\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(\n-                    Name::self_type(),\n-                    PerNs::types(Resolution::SelfType(i.clone())),\n-                );\n+                f(Name::self_type(), PerNs::types(Resolution::SelfType(i.clone())));\n             }\n             Scope::ExprScope(e) => {\n                 e.expr_scopes.entries(e.scope_id).iter().for_each(|e| {\n-                    f(\n-                        e.name().clone(),\n-                        PerNs::values(Resolution::LocalBinding(e.pat())),\n-                    );\n+                    f(e.name().clone(), PerNs::values(Resolution::LocalBinding(e.pat())));\n                 });\n             }\n         }"}, {"sha": "625a2ce45a923fc9a35b795cd873e3f223b495ce", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -65,11 +65,7 @@ pub fn module_from_child_node(\n     file_id: FileId,\n     child: &SyntaxNode,\n ) -> Option<Module> {\n-    if let Some(m) = child\n-        .ancestors()\n-        .filter_map(ast::Module::cast)\n-        .find(|it| !it.has_semi())\n-    {\n+    if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n         module_from_inline(db, file_id.into(), m)\n     } else {\n         module_from_file_id(db, file_id.into())\n@@ -82,14 +78,13 @@ fn module_from_source(\n     decl_id: Option<SourceFileItemId>,\n ) -> Option<Module> {\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n-    db.source_root_crates(source_root_id)\n-        .iter()\n-        .map(|&crate_id| Crate { crate_id })\n-        .find_map(|krate| {\n+    db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map(\n+        |krate| {\n             let module_tree = db.module_tree(krate);\n             let module_id = module_tree.find_module_by_source(file_id, decl_id)?;\n             Some(Module { krate, module_id })\n-        })\n+        },\n+    )\n }\n \n pub fn function_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Function> {\n@@ -116,9 +111,7 @@ pub fn function_from_module(\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n     let ctx = LocationCtx::new(db, module, file_id);\n-    Function {\n-        id: ctx.to_def(fn_def),\n-    }\n+    Function { id: ctx.to_def(fn_def) }\n }\n \n pub fn function_from_child_node(\n@@ -138,18 +131,14 @@ pub fn struct_from_module(\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n     let ctx = LocationCtx::new(db, module, file_id);\n-    Struct {\n-        id: ctx.to_def(struct_def),\n-    }\n+    Struct { id: ctx.to_def(struct_def) }\n }\n \n pub fn enum_from_module(db: &impl HirDatabase, module: Module, enum_def: &ast::EnumDef) -> Enum {\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n     let ctx = LocationCtx::new(db, module, file_id);\n-    Enum {\n-        id: ctx.to_def(enum_def),\n-    }\n+    Enum { id: ctx.to_def(enum_def) }\n }\n \n pub fn trait_from_module(\n@@ -160,9 +149,7 @@ pub fn trait_from_module(\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n     let ctx = LocationCtx::new(db, module, file_id);\n-    Trait {\n-        id: ctx.to_def(trait_def),\n-    }\n+    Trait { id: ctx.to_def(trait_def) }\n }\n \n pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, TextRange)> {"}, {"sha": "453520bbe31ee2efa1f98bb6b0640aeff823a049", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 62, "deletions": 187, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -305,10 +305,8 @@ impl Ty {\n         match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n-                let inner_tys = inner\n-                    .iter()\n-                    .map(|tr| Ty::from_hir(db, resolver, tr))\n-                    .collect::<Vec<_>>();\n+                let inner_tys =\n+                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n@@ -330,17 +328,11 @@ impl Ty {\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n-                let mut inner_tys = params\n-                    .iter()\n-                    .map(|tr| Ty::from_hir(db, resolver, tr))\n-                    .collect::<Vec<_>>();\n-                let return_ty = inner_tys\n-                    .pop()\n-                    .expect(\"TypeRef::Fn should always have at least return type\");\n-                let sig = FnSig {\n-                    input: inner_tys,\n-                    output: return_ty,\n-                };\n+                let mut inner_tys =\n+                    params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n+                let return_ty =\n+                    inner_tys.pop().expect(\"TypeRef::Fn should always have at least return type\");\n+                let sig = FnSig { input: inner_tys, output: return_ty };\n                 Ty::FnPtr(Arc::new(sig))\n             }\n             TypeRef::Error => Ty::Unknown,\n@@ -407,10 +399,7 @@ impl Ty {\n         resolved: TypableDef,\n     ) -> Substs {\n         let mut substs = Vec::new();\n-        let last = path\n-            .segments\n-            .last()\n-            .expect(\"path should have at least one segment\");\n+        let last = path.segments.last().expect(\"path should have at least one segment\");\n         let (def_generics, segment) = match resolved {\n             TypableDef::Function(func) => (func.generic_params(db), last),\n             TypableDef::Struct(s) => (s.generic_params(db), last),\n@@ -447,11 +436,8 @@ impl Ty {\n         }\n         // add placeholders for args that were not provided\n         // TODO: handle defaults\n-        let supplied_params = segment\n-            .args_and_bindings\n-            .as_ref()\n-            .map(|ga| ga.args.len())\n-            .unwrap_or(0);\n+        let supplied_params =\n+            segment.args_and_bindings.as_ref().map(|ga| ga.args.len()).unwrap_or(0);\n         for _ in supplied_params..def_generics.params.len() {\n             substs.push(Ty::Unknown);\n         }\n@@ -531,17 +517,8 @@ impl Ty {\n     /// `Option<u32>` afterwards.)\n     pub fn apply_substs(self, substs: Substs) -> Ty {\n         match self {\n-            Ty::Adt { def_id, name, .. } => Ty::Adt {\n-                def_id,\n-                name,\n-                substs,\n-            },\n-            Ty::FnDef { def, name, sig, .. } => Ty::FnDef {\n-                def,\n-                name,\n-                sig,\n-                substs,\n-            },\n+            Ty::Adt { def_id, name, .. } => Ty::Adt { def_id, name, substs },\n+            Ty::FnDef { def, name, sig, .. } => Ty::FnDef { def, name, sig, substs },\n             _ => self,\n         }\n     }\n@@ -591,42 +568,25 @@ impl fmt::Display for Ty {\n                 if ts.len() == 1 {\n                     write!(f, \"({},)\", ts[0])\n                 } else {\n-                    join(ts.iter())\n-                        .surround_with(\"(\", \")\")\n-                        .separator(\", \")\n-                        .to_fmt(f)\n+                    join(ts.iter()).surround_with(\"(\", \")\").separator(\", \").to_fmt(f)\n                 }\n             }\n             Ty::FnPtr(sig) => {\n-                join(sig.input.iter())\n-                    .surround_with(\"fn(\", \")\")\n-                    .separator(\", \")\n-                    .to_fmt(f)?;\n+                join(sig.input.iter()).surround_with(\"fn(\", \")\").separator(\", \").to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n-            Ty::FnDef {\n-                name, substs, sig, ..\n-            } => {\n+            Ty::FnDef { name, substs, sig, .. } => {\n                 write!(f, \"fn {}\", name)?;\n                 if substs.0.len() > 0 {\n-                    join(substs.0.iter())\n-                        .surround_with(\"<\", \">\")\n-                        .separator(\", \")\n-                        .to_fmt(f)?;\n+                    join(substs.0.iter()).surround_with(\"<\", \">\").separator(\", \").to_fmt(f)?;\n                 }\n-                join(sig.input.iter())\n-                    .surround_with(\"(\", \")\")\n-                    .separator(\", \")\n-                    .to_fmt(f)?;\n+                join(sig.input.iter()).surround_with(\"(\", \")\").separator(\", \").to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n             Ty::Adt { name, substs, .. } => {\n                 write!(f, \"{}\", name)?;\n                 if substs.0.len() > 0 {\n-                    join(substs.0.iter())\n-                        .surround_with(\"<\", \">\")\n-                        .separator(\", \")\n-                        .to_fmt(f)?;\n+                    join(substs.0.iter()).surround_with(\"<\", \">\").separator(\", \").to_fmt(f)?;\n                 }\n                 Ok(())\n             }\n@@ -646,31 +606,16 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let resolver = def.resolver(db);\n     let generics = def.generic_params(db);\n     let name = def.name(db);\n-    let input = signature\n-        .params()\n-        .iter()\n-        .map(|tr| Ty::from_hir(db, &resolver, tr))\n-        .collect::<Vec<_>>();\n+    let input =\n+        signature.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n     let output = Ty::from_hir(db, &resolver, signature.ret_type());\n     let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n-    Ty::FnDef {\n-        def,\n-        sig,\n-        name,\n-        substs,\n-    }\n+    Ty::FnDef { def, sig, name, substs }\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n-    Substs(\n-        generics\n-            .params\n-            .iter()\n-            .map(|_p| Ty::Unknown)\n-            .collect::<Vec<_>>()\n-            .into(),\n-    )\n+    Substs(generics.params.iter().map(|_p| Ty::Unknown).collect::<Vec<_>>().into())\n }\n \n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n@@ -935,11 +880,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs) -> bool {\n-        substs1\n-            .0\n-            .iter()\n-            .zip(substs2.0.iter())\n-            .all(|(t1, t2)| self.unify(t1, t2))\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify(t1, t2))\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -961,25 +902,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             },\n             (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n             (\n-                Ty::Adt {\n-                    def_id: def_id1,\n-                    substs: substs1,\n-                    ..\n-                },\n-                Ty::Adt {\n-                    def_id: def_id2,\n-                    substs: substs2,\n-                    ..\n-                },\n+                Ty::Adt { def_id: def_id1, substs: substs1, .. },\n+                Ty::Adt { def_id: def_id2, substs: substs2, .. },\n             ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2),\n             (Ty::Slice(t1), Ty::Slice(t2)) => self.unify(t1, t2),\n             (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n             (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n             (Ty::FnPtr(sig1), Ty::FnPtr(sig2)) if sig1 == sig2 => true,\n-            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => ts1\n-                .iter()\n-                .zip(ts2.iter())\n-                .all(|(t1, t2)| self.unify(t1, t2)),\n+            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => {\n+                ts1.iter().zip(ts2.iter()).all(|(t1, t2)| self.unify(t1, t2))\n+            }\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n             | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n@@ -994,30 +926,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             | (Ty::Infer(InferTy::FloatVar(tv)), other)\n             | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n-                self.var_unification_table\n-                    .union_value(*tv, TypeVarValue::Known(other.clone()));\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true\n             }\n             _ => false,\n         }\n     }\n \n     fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n+        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n     }\n \n     fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n+        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n     }\n \n     fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n+        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n     }\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n@@ -1207,9 +1132,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         for subpat in subpats {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty = matching_field\n-                .map_or(Ty::Unknown, |field| field.ty(self.db))\n-                .subst(&substs);\n+            let expected_ty =\n+                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n             self.infer_pat(subpat.pat, &expected_ty);\n         }\n \n@@ -1249,25 +1173,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let subty = self.infer_pat(*pat, expectation);\n                 Ty::Ref(subty.into(), *mutability)\n             }\n-            Pat::TupleStruct {\n-                path: ref p,\n-                args: ref subpats,\n-            } => self.infer_tuple_struct_pat(p.as_ref(), subpats, expected),\n-            Pat::Struct {\n-                path: ref p,\n-                args: ref fields,\n-            } => self.infer_struct_pat(p.as_ref(), fields, expected),\n+            Pat::TupleStruct { path: ref p, args: ref subpats } => {\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected)\n+            }\n+            Pat::Struct { path: ref p, args: ref fields } => {\n+                self.infer_struct_pat(p.as_ref(), fields, expected)\n+            }\n             Pat::Path(path) => {\n                 // TODO use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n-                self.infer_path_expr(&resolver, &path)\n-                    .unwrap_or(Ty::Unknown)\n-            }\n-            Pat::Bind {\n-                mode,\n-                name: _name,\n-                subpat,\n-            } => {\n+                self.infer_path_expr(&resolver, &path).unwrap_or(Ty::Unknown)\n+            }\n+            Pat::Bind { mode, name: _name, subpat } => {\n                 let subty = if let Some(subpat) = subpat {\n                     self.infer_pat(*subpat, expected)\n                 } else {\n@@ -1294,11 +1211,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n-            Expr::If {\n-                condition,\n-                then_branch,\n-                else_branch,\n-            } => {\n+            Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n                 let then_ty = self.infer_expr(*then_branch, expected);\n@@ -1325,21 +1238,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n-            Expr::For {\n-                iterable,\n-                body,\n-                pat,\n-            } => {\n+            Expr::For { iterable, body, pat } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n                 self.infer_pat(*pat, &Ty::Unknown);\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n-            Expr::Lambda {\n-                body,\n-                args,\n-                arg_types,\n-            } => {\n+            Expr::Lambda { body, args, arg_types } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n@@ -1362,11 +1267,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n                     Ty::FnDef { substs, sig, .. } => {\n                         let ret_ty = sig.output.clone().subst(&substs);\n-                        let param_tys = sig\n-                            .input\n-                            .iter()\n-                            .map(|ty| ty.clone().subst(&substs))\n-                            .collect();\n+                        let param_tys =\n+                            sig.input.iter().map(|ty| ty.clone().subst(&substs)).collect();\n                         (param_tys, ret_ty)\n                     }\n                     _ => {\n@@ -1381,11 +1283,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall {\n-                receiver,\n-                args,\n-                method_name,\n-            } => {\n+            Expr::MethodCall { receiver, args, method_name } => {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n@@ -1399,11 +1297,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::FnPtr(sig) => {\n                         if !sig.input.is_empty() {\n-                            (\n-                                sig.input[0].clone(),\n-                                sig.input[1..].to_vec(),\n-                                sig.output.clone(),\n-                            )\n+                            (sig.input[0].clone(), sig.input[1..].to_vec(), sig.output.clone())\n                         } else {\n                             (Ty::Unknown, Vec::new(), sig.output.clone())\n                         }\n@@ -1469,11 +1363,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 Ty::Never\n             }\n-            Expr::StructLit {\n-                path,\n-                fields,\n-                spread,\n-            } => {\n+            Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 for field in fields {\n@@ -1497,14 +1387,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             let i = name.to_string().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                         }\n-                        Ty::Adt {\n-                            def_id: AdtDef::Struct(s),\n-                            ref substs,\n-                            ..\n-                        } => s.field(self.db, name).map(|field| {\n-                            self.write_field_resolution(tgt_expr, field);\n-                            field.ty(self.db).subst(substs)\n-                        }),\n+                        Ty::Adt { def_id: AdtDef::Struct(s), ref substs, .. } => {\n+                            s.field(self.db, name).map(|field| {\n+                                self.write_field_resolution(tgt_expr, field);\n+                                field.ty(self.db).subst(substs)\n+                            })\n+                        }\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -1635,15 +1523,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ) -> Ty {\n         for stmt in statements {\n             match stmt {\n-                Statement::Let {\n-                    pat,\n-                    type_ref,\n-                    initializer,\n-                } => {\n-                    let decl_ty = type_ref\n-                        .as_ref()\n-                        .map(|tr| self.make_ty(tr))\n-                        .unwrap_or(Ty::Unknown);\n+                Statement::Let { pat, type_ref, initializer } => {\n+                    let decl_ty =\n+                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n                         let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n@@ -1659,11 +1541,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n         }\n-        let ty = if let Some(expr) = tail {\n-            self.infer_expr(expr, expected)\n-        } else {\n-            Ty::unit()\n-        };\n+        let ty = if let Some(expr) = tail { self.infer_expr(expr, expected) } else { Ty::unit() };\n         ty\n     }\n \n@@ -1678,10 +1556,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr(\n-            self.body.body_expr(),\n-            &Expectation::has_type(self.return_ty.clone()),\n-        );\n+        self.infer_expr(self.body.body_expr(), &Expectation::has_type(self.return_ty.clone()));\n     }\n }\n "}, {"sha": "da7587f015aea457d21b7fa0f616d2914dc34e2e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -46,18 +46,13 @@ impl CrateImplBlocks {\n         ty: &Ty,\n     ) -> impl Iterator<Item = (Module, ImplBlock)> + 'a {\n         let fingerprint = TyFingerprint::for_impl(ty);\n-        fingerprint\n-            .and_then(|f| self.impls.get(&f))\n-            .into_iter()\n-            .flat_map(|i| i.iter())\n-            .map(move |(module_id, impl_id)| {\n-                let module = Module {\n-                    krate: self.krate,\n-                    module_id: *module_id,\n-                };\n+        fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n+            move |(module_id, impl_id)| {\n+                let module = Module { krate: self.krate, module_id: *module_id };\n                 let module_impl_blocks = db.impls_in_module(module);\n                 (module, ImplBlock::from_id(module_impl_blocks, *impl_id))\n-            })\n+            },\n+        )\n     }\n \n     pub fn lookup_impl_blocks_for_trait<'a>(\n@@ -66,18 +61,13 @@ impl CrateImplBlocks {\n         tr: &Trait,\n     ) -> impl Iterator<Item = (Module, ImplBlock)> + 'a {\n         let id = tr.id;\n-        self.impls_by_trait\n-            .get(&id)\n-            .into_iter()\n-            .flat_map(|i| i.iter())\n-            .map(move |(module_id, impl_id)| {\n-                let module = Module {\n-                    krate: self.krate,\n-                    module_id: *module_id,\n-                };\n+        self.impls_by_trait.get(&id).into_iter().flat_map(|i| i.iter()).map(\n+            move |(module_id, impl_id)| {\n+                let module = Module { krate: self.krate, module_id: *module_id };\n                 let module_impl_blocks = db.impls_in_module(module);\n                 (module, ImplBlock::from_id(module_impl_blocks, *impl_id))\n-            })\n+            },\n+        )\n     }\n \n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {"}, {"sha": "2621d1b55211d12bf530c19cf3a0dc7c347fb050", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -634,11 +634,7 @@ fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);\n     let mut acc = String::new();\n-    for fn_def in source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::FnDef::cast)\n-    {\n+    for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n         let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap();\n         let inference_result = func.infer(&db);\n         let body_syntax_mapping = func.body_syntax_mapping(&db);\n@@ -725,8 +721,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     \"\n     .to_string();\n \n-    db.query_mut(ra_db::FileTextQuery)\n-        .set(pos.file_id, Arc::new(new_text));\n+    db.query_mut(ra_db::FileTextQuery).set(pos.file_id, Arc::new(new_text));\n \n     {\n         let events = db.log_executed(|| {"}, {"sha": "ee8b7376aba63087428fa2ee0272bc3dcc494699", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -62,11 +62,9 @@ impl TypeRef {\n             ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n             TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n             NeverType(..) => TypeRef::Never,\n-            PathType(inner) => inner\n-                .path()\n-                .and_then(Path::from_ast)\n-                .map(TypeRef::Path)\n-                .unwrap_or(TypeRef::Error),\n+            PathType(inner) => {\n+                inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n+            }\n             PointerType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.is_mut());\n@@ -83,10 +81,7 @@ impl TypeRef {\n             FnPointerType(inner) => {\n                 let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n                 let mut params = if let Some(pl) = inner.param_list() {\n-                    pl.params()\n-                        .map(|p| p.type_ref())\n-                        .map(TypeRef::from_ast_opt)\n-                        .collect()\n+                    pl.params().map(|p| p.type_ref()).map(TypeRef::from_ast_opt).collect()\n                 } else {\n                     Vec::new()\n                 };"}, {"sha": "7a9c6668174453dc6bdaeb142ac86570e8c0500d", "filename": "crates/ra_ide_api/src/assists.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fassists.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,10 +7,7 @@ pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<SourceChange>\n         .into_iter()\n         .map(|(label, action)| {\n             let file_id = frange.file_id;\n-            let file_edit = SourceFileEdit {\n-                file_id,\n-                edit: action.edit,\n-            };\n+            let file_edit = SourceFileEdit { file_id, edit: action.edit };\n             SourceChange {\n                 label: label.label,\n                 source_file_edits: vec![file_edit],"}, {"sha": "1b279615c5178e71ac3351d137b5b3cc50016b08", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -21,9 +21,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n \n     // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n     let file_symbols = crate::symbol_index::index_resolve(db, name_ref);\n-    let symbol = file_symbols\n-        .into_iter()\n-        .find(|it| it.ptr.kind() == FN_DEF)?;\n+    let symbol = file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF)?;\n     let fn_file = db.parse(symbol.file_id);\n     let fn_def = symbol.ptr.to_node(&fn_file);\n     let fn_def = ast::FnDef::cast(fn_def).unwrap();\n@@ -53,13 +51,8 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n             let start = arg_list_range.start();\n \n             let range_search = TextRange::from_to(start, position.offset);\n-            let mut commas: usize = arg_list\n-                .syntax()\n-                .text()\n-                .slice(range_search)\n-                .to_string()\n-                .matches(',')\n-                .count();\n+            let mut commas: usize =\n+                arg_list.syntax().text().slice(range_search).to_string().matches(',').count();\n \n             // If we have a method call eat the first param since it's just self.\n             if has_self {\n@@ -96,11 +89,9 @@ impl<'a> FnCallNode<'a> {\n                 _ => return None,\n             }),\n \n-            FnCallNode::MethodCallExpr(call_expr) => call_expr\n-                .syntax()\n-                .children()\n-                .filter_map(ast::NameRef::cast)\n-                .nth(0),\n+            FnCallNode::MethodCallExpr(call_expr) => {\n+                call_expr.syntax().children().filter_map(ast::NameRef::cast).nth(0)\n+            }\n         }\n     }\n \n@@ -117,12 +108,7 @@ impl CallInfo {\n         let label = crate::completion::function_label(node)?;\n         let doc = function.docs(db);\n \n-        Some(CallInfo {\n-            parameters: param_list(node),\n-            label,\n-            doc,\n-            active_parameter: None,\n-        })\n+        Some(CallInfo { parameters: param_list(node), label, doc, active_parameter: None })\n     }\n }\n \n@@ -136,10 +122,7 @@ fn param_list(node: &ast::FnDef) -> Vec<String> {\n         // Maybe use param.pat here? See if we can just extract the name?\n         //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n         res.extend(\n-            param_list\n-                .params()\n-                .filter_map(|p| p.pat())\n-                .map(|pat| pat.syntax().text().to_string()),\n+            param_list.params().filter_map(|p| p.pat()).map(|pat| pat.syntax().text().to_string()),\n         );\n     }\n     res\n@@ -378,10 +361,7 @@ pub fn foo() {\n \"#,\n         );\n \n-        assert_eq!(\n-            info.parameters,\n-            vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n-        );\n+        assert_eq!(info.parameters, vec![\"&mut self\".to_string(), \"ctx\".to_string()]);\n         assert_eq!(info.active_parameter, Some(1));\n         assert_eq!(\n             info.doc.map(|it| it.into()),"}, {"sha": "3f041f9c3ad72624910dacf1410e81c23413912a", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -65,16 +65,8 @@ impl AnalysisChange {\n         path: RelativePathBuf,\n         text: Arc<String>,\n     ) {\n-        let file = AddFile {\n-            file_id,\n-            path,\n-            text,\n-        };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .added\n-            .push(file);\n+        let file = AddFile { file_id, path, text };\n+        self.roots_changed.entry(root_id).or_default().added.push(file);\n     }\n \n     pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n@@ -83,11 +75,7 @@ impl AnalysisChange {\n \n     pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n         let file = RemoveFile { file_id, path };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .removed\n-            .push(file);\n+        self.roots_changed.entry(root_id).or_default().removed.push(file);\n     }\n \n     pub fn add_library(&mut self, data: LibraryData) {\n@@ -155,17 +143,9 @@ impl LibraryData {\n         let mut root_change = RootChange::default();\n         root_change.added = files\n             .into_iter()\n-            .map(|(file_id, path, text)| AddFile {\n-                file_id,\n-                path,\n-                text,\n-            })\n+            .map(|(file_id, path, text)| AddFile { file_id, path, text })\n             .collect();\n-        LibraryData {\n-            root_id,\n-            root_change,\n-            symbol_index,\n-        }\n+        LibraryData { root_id, root_change, symbol_index }\n     }\n }\n \n@@ -226,10 +206,7 @@ impl RootDatabase {\n             self.last_gc_check = time::Instant::now();\n             let retained_trees = syntax_tree_stats(self).retained;\n             if retained_trees > 100 {\n-                log::info!(\n-                    \"automatic garbadge collection, {} retained trees\",\n-                    retained_trees\n-                );\n+                log::info!(\"automatic garbadge collection, {} retained trees\", retained_trees);\n                 self.collect_garbage();\n             }\n         }\n@@ -238,9 +215,7 @@ impl RootDatabase {\n     pub(crate) fn collect_garbage(&mut self) {\n         self.last_gc = time::Instant::now();\n \n-        let sweep = SweepStrategy::default()\n-            .discard_values()\n-            .sweep_all_revisions();\n+        let sweep = SweepStrategy::default().discard_values().sweep_all_revisions();\n \n         self.query(ra_db::ParseQuery).sweep(sweep);\n "}, {"sha": "a673dbdcf6cfd7286f3aebdc18762c2b43862eba", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -25,9 +25,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n-            Ty::Adt {\n-                def_id, ref substs, ..\n-            } => {\n+            Ty::Adt { def_id, ref substs, .. } => {\n                 match def_id {\n                     AdtDef::Struct(s) => {\n                         for field in s.fields(ctx.db) {"}, {"sha": "43532226fe9e8f08795a0dd681e85357faf5c87b", "filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -43,13 +43,12 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n         node: &'a N,\n         params: &mut FxHashMap<String, (u32, &'a ast::Param)>,\n     ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n+        node.functions().filter_map(|it| it.param_list()).flat_map(|it| it.params()).for_each(\n+            |param| {\n                 let text = param.syntax().text().to_string();\n                 params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n+            },\n+        )\n     }\n }\n "}, {"sha": "c47a14e9f7d1e0928c9b136dadd40b954799ef2c", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -31,14 +31,10 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         hir::ModuleDef::Enum(e) => {\n             e.variants(ctx.db).into_iter().for_each(|variant| {\n                 if let Some(name) = variant.name(ctx.db) {\n-                    let detail_types = variant\n-                        .fields(ctx.db)\n-                        .into_iter()\n-                        .map(|field| field.ty(ctx.db));\n-                    let detail = join(detail_types)\n-                        .separator(\", \")\n-                        .surround_with(\"(\", \")\")\n-                        .to_string();\n+                    let detail_types =\n+                        variant.fields(ctx.db).into_iter().map(|field| field.ty(ctx.db));\n+                    let detail =\n+                        join(detail_types).separator(\", \").surround_with(\"(\", \")\").to_string();\n \n                     CompletionItem::new(\n                         CompletionKind::Reference,"}, {"sha": "10a3c8db70f2b3ad9fb5723a2eaf49188b203d60", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -17,11 +17,7 @@ use ra_text_edit::TextEditBuilder;\n \n fn postfix_snippet(ctx: &CompletionContext, label: &str, snippet: &str) -> Builder {\n     let replace_range = ctx.source_range();\n-    let receiver_range = ctx\n-        .dot_receiver\n-        .expect(\"no receiver available\")\n-        .syntax()\n-        .range();\n+    let receiver_range = ctx.dot_receiver.expect(\"no receiver available\").syntax().range();\n     let delete_range = TextRange::from_to(receiver_range.start(), replace_range.start());\n     let mut builder = TextEditBuilder::default();\n     builder.delete(delete_range);"}, {"sha": "4457884072d79b806ee6ae0c197f84d9fc1a2fda", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,13 +7,9 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     let names = ctx.resolver.all_names();\n \n     names.into_iter().for_each(|(name, res)| {\n-        CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            name.to_string(),\n-        )\n-        .from_resolution(ctx, &res)\n-        .add_to(acc)\n+        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n+            .from_resolution(ctx, &res)\n+            .add_to(acc)\n     });\n }\n "}, {"sha": "82bd4d6061d0f4e6c75389f4869a7f3a1bbae9c0", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -108,12 +108,8 @@ impl<'a> CompletionContext<'a> {\n     }\n     fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.range() == name_range)\n-            .last()\n-            .unwrap();\n+        let top_node =\n+            name_ref.syntax().ancestors().take_while(|it| it.range() == name_range).last().unwrap();\n \n         match top_node.parent().map(|it| it.kind()) {\n             Some(SOURCE_FILE) | Some(ITEM_LIST) => {"}, {"sha": "7b8972af0e66313b3a1119b83856d811d80a1dfb", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -105,10 +105,7 @@ impl CompletionItem {\n     }\n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n-        self.lookup\n-            .as_ref()\n-            .map(|it| it.as_str())\n-            .unwrap_or_else(|| self.label())\n+        self.lookup.as_ref().map(|it| it.as_str()).unwrap_or_else(|| self.label())\n     }\n \n     pub fn insert_text_format(&self) -> InsertTextFormat {\n@@ -214,10 +211,7 @@ impl Builder {\n     ) -> Builder {\n         use hir::ModuleDef::*;\n \n-        let def = resolution\n-            .as_ref()\n-            .take_types()\n-            .or_else(|| resolution.as_ref().take_values());\n+        let def = resolution.as_ref().take_types().or_else(|| resolution.as_ref().take_values());\n         let def = match def {\n             None => return self,\n             Some(it) => it,\n@@ -323,10 +317,8 @@ pub(crate) fn check_completion(test_name: &str, code: &str, kind: CompletionKind\n     };\n     let completions = completions(&analysis.db, position).unwrap();\n     let completion_items: Vec<CompletionItem> = completions.into();\n-    let mut kind_completions: Vec<CompletionItem> = completion_items\n-        .into_iter()\n-        .filter(|c| c.completion_kind == kind)\n-        .collect();\n+    let mut kind_completions: Vec<CompletionItem> =\n+        completion_items.into_iter().filter(|c| c.completion_kind == kind).collect();\n     kind_completions.sort_by_key(|c| c.label.clone());\n     assert_debug_snapshot_matches!(test_name, kind_completions);\n }"}, {"sha": "53d95fb4c67e5401005f38e593b8df40b92fda72", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -21,10 +21,8 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             let source_root = db.file_source_root(file_id);\n             let diag = match problem {\n                 Problem::UnresolvedModule { candidate } => {\n-                    let create_file = FileSystemEdit::CreateFile {\n-                        source_root,\n-                        path: candidate.clone(),\n-                    };\n+                    let create_file =\n+                        FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n                     let fix = SourceChange {\n                         label: \"create module\".to_string(),\n                         source_file_edits: Vec::new(),\n@@ -44,10 +42,8 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n                         dst_source_root: source_root,\n                         dst_path: move_to.clone(),\n                     };\n-                    let create_file = FileSystemEdit::CreateFile {\n-                        source_root,\n-                        path: move_to.join(candidate),\n-                    };\n+                    let create_file =\n+                        FileSystemEdit::CreateFile { source_root, path: move_to.join(candidate) };\n                     let fix = SourceChange {\n                         label: \"move file and create module\".to_string(),\n                         source_file_edits: Vec::new(),"}, {"sha": "4051728e16cc1cd079f82276a4e4911139505b6e", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -31,9 +31,7 @@ fn extend_selection_in_macro(\n }\n \n fn find_macro_call(node: &SyntaxNode, range: TextRange) -> Option<&ast::MacroCall> {\n-    find_covering_node(node, range)\n-        .ancestors()\n-        .find_map(ast::MacroCall::cast)\n+    find_covering_node(node, range).ancestors().find_map(ast::MacroCall::cast)\n }\n \n #[cfg(test)]"}, {"sha": "413720960a0faabc396269f80f8f4105a855c6b1", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -50,18 +50,13 @@ pub(crate) fn reference_definition(\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n     {\n         // Check if it is a method\n-        if let Some(method_call) = name_ref\n-            .syntax()\n-            .parent()\n-            .and_then(ast::MethodCallExpr::cast)\n-        {\n+        if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n             tested_by!(goto_definition_works_for_methods);\n             let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n-            if let Some(func) = syntax_mapping\n-                .node_expr(expr)\n-                .and_then(|it| infer_result.method_resolution(it))\n+            if let Some(func) =\n+                syntax_mapping.node_expr(expr).and_then(|it| infer_result.method_resolution(it))\n             {\n                 return Exact(NavigationTarget::from_function(db, func));\n             };\n@@ -72,39 +67,28 @@ pub(crate) fn reference_definition(\n             let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(field_expr.syntax()).unwrap();\n-            if let Some(field) = syntax_mapping\n-                .node_expr(expr)\n-                .and_then(|it| infer_result.field_resolution(it))\n+            if let Some(field) =\n+                syntax_mapping.node_expr(expr).and_then(|it| infer_result.field_resolution(it))\n             {\n                 return Exact(NavigationTarget::from_field(db, field));\n             };\n         }\n     }\n     // Try name resolution\n     let resolver = hir::source_binder::resolver_for_node(db, file_id, name_ref.syntax());\n-    if let Some(path) = name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::Path::cast)\n-        .and_then(hir::Path::from_ast)\n+    if let Some(path) =\n+        name_ref.syntax().ancestors().find_map(ast::Path::cast).and_then(hir::Path::from_ast)\n     {\n         let resolved = resolver.resolve_path(db, &path);\n-        match resolved\n-            .clone()\n-            .take_types()\n-            .or_else(|| resolved.take_values())\n-        {\n+        match resolved.clone().take_types().or_else(|| resolved.take_values()) {\n             Some(Resolution::Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n             Some(Resolution::LocalBinding(pat)) => {\n                 let body = resolver.body().expect(\"no body for local binding\");\n                 let syntax_mapping = body.syntax_mapping(db);\n-                let ptr = syntax_mapping\n-                    .pat_syntax(pat)\n-                    .expect(\"pattern not found in syntax mapping\");\n-                let name = path\n-                    .as_ident()\n-                    .cloned()\n-                    .expect(\"local binding from a multi-segment path\");\n+                let ptr =\n+                    syntax_mapping.pat_syntax(pat).expect(\"pattern not found in syntax mapping\");\n+                let name =\n+                    path.as_ident().cloned().expect(\"local binding from a multi-segment path\");\n                 let nav = NavigationTarget::from_scope_entry(file_id, name, ptr);\n                 return Exact(nav);\n             }"}, {"sha": "60b81567c77d6dcdaba6bc0e25a5739cf65e5528", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -33,13 +33,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     }\n     if range.is_none() {\n         let node = find_leaf_at_offset(file.syntax(), position.offset).find_map(|leaf| {\n-            leaf.ancestors()\n-                .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n+            leaf.ancestors().find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n         })?;\n-        let frange = FileRange {\n-            file_id: position.file_id,\n-            range: node.range(),\n-        };\n+        let frange = FileRange { file_id: position.file_id, range: node.range() };\n         res.extend(type_of(db, frange).map(Into::into));\n         range = Some(node.range());\n     };\n@@ -126,10 +122,8 @@ impl NavigationTarget {\n         where\n             T: ast::NameOwner + ast::VisibilityOwner,\n         {\n-            let mut string = node\n-                .visibility()\n-                .map(|v| format!(\"{} \", v.syntax().text()))\n-                .unwrap_or_default();\n+            let mut string =\n+                node.visibility().map(|v| format!(\"{} \", v.syntax().text())).unwrap_or_default();\n             string.push_str(label);\n             node.name()?.syntax().text().push_to(&mut string);\n             Some(string)"}, {"sha": "444c4aeb26e050719cbb275705fd8fe65ae4d936", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -83,9 +83,7 @@ mod tests {\n \n         let navs = analysis.goto_implementation(pos).unwrap().unwrap().info;\n         assert_eq!(navs.len(), expected.len());\n-        navs.into_iter()\n-            .enumerate()\n-            .for_each(|(i, nav)| nav.assert_match(expected[i]));\n+        navs.into_iter().enumerate().for_each(|(i, nav)| nav.assert_match(expected[i]));\n     }\n \n     #[test]\n@@ -109,10 +107,7 @@ mod tests {\n             impl Foo {}\n             impl Foo {}\n             \",\n-            &[\n-                \"impl IMPL_BLOCK FileId(1) [12; 23)\",\n-                \"impl IMPL_BLOCK FileId(1) [24; 35)\",\n-            ],\n+            &[\"impl IMPL_BLOCK FileId(1) [12; 23)\", \"impl IMPL_BLOCK FileId(1) [24; 35)\"],\n         );\n     }\n \n@@ -129,10 +124,7 @@ mod tests {\n                 impl super::Foo {}\n             }\n             \",\n-            &[\n-                \"impl IMPL_BLOCK FileId(1) [24; 42)\",\n-                \"impl IMPL_BLOCK FileId(1) [57; 75)\",\n-            ],\n+            &[\"impl IMPL_BLOCK FileId(1) [24; 42)\", \"impl IMPL_BLOCK FileId(1) [57; 75)\"],\n         );\n     }\n \n@@ -149,10 +141,7 @@ mod tests {\n             //- /b.rs\n             impl crate::Foo {}\n             \",\n-            &[\n-                \"impl IMPL_BLOCK FileId(2) [0; 18)\",\n-                \"impl IMPL_BLOCK FileId(3) [0; 18)\",\n-            ],\n+            &[\"impl IMPL_BLOCK FileId(2) [0; 18)\", \"impl IMPL_BLOCK FileId(3) [0; 18)\"],\n         );\n     }\n \n@@ -183,10 +172,7 @@ mod tests {\n             //- /b.rs\n             impl crate::T for crate::Foo {}\n             \",\n-            &[\n-                \"impl IMPL_BLOCK FileId(2) [0; 31)\",\n-                \"impl IMPL_BLOCK FileId(3) [0; 31)\",\n-            ],\n+            &[\"impl IMPL_BLOCK FileId(2) [0; 31)\", \"impl IMPL_BLOCK FileId(3) [0; 31)\"],\n         );\n     }\n }"}, {"sha": "2d090d9b4de656eadc04874505f40acb4404a4eb", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -90,15 +90,8 @@ pub struct SourceFileEdit {\n \n #[derive(Debug)]\n pub enum FileSystemEdit {\n-    CreateFile {\n-        source_root: SourceRootId,\n-        path: RelativePathBuf,\n-    },\n-    MoveFile {\n-        src: FileId,\n-        dst_source_root: SourceRootId,\n-        dst_path: RelativePathBuf,\n-    },\n+    CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n+    MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n }\n \n #[derive(Debug)]\n@@ -179,9 +172,7 @@ impl AnalysisHost {\n     /// Returns a snapshot of the current state, which you can query for\n     /// semantic information.\n     pub fn analysis(&self) -> Analysis {\n-        Analysis {\n-            db: self.db.snapshot(),\n-        }\n+        Analysis { db: self.db.snapshot() }\n     }\n \n     /// Applies changes to the current state of the world. If there are\n@@ -401,17 +392,12 @@ impl Analysis {\n \n impl SourceChange {\n     pub(crate) fn from_local_edit(file_id: FileId, edit: LocalEdit) -> SourceChange {\n-        let file_edit = SourceFileEdit {\n-            file_id,\n-            edit: edit.edit,\n-        };\n+        let file_edit = SourceFileEdit { file_id, edit: edit.edit };\n         SourceChange {\n             label: edit.label,\n             source_file_edits: vec![file_edit],\n             file_system_edits: vec![],\n-            cursor_position: edit\n-                .cursor_position\n-                .map(|offset| FilePosition { offset, file_id }),\n+            cursor_position: edit.cursor_position.map(|offset| FilePosition { offset, file_id }),\n         }\n     }\n }"}, {"sha": "8d860306255be9eed489d64ea7b717afc89ccebd", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -41,10 +41,7 @@ impl MockAnalysis {\n         let mut res = MockAnalysis::new();\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n-                assert!(\n-                    position.is_none(),\n-                    \"only one marker (<|>) per fixture is allowed\"\n-                );\n+                assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n                 position = Some(res.add_file_with_position(&entry.meta, &entry.text));\n             } else {\n                 res.add_file(&entry.meta, &entry.text);\n@@ -97,9 +94,7 @@ impl MockAnalysis {\n                 let other_crate = crate_graph.add_crate_root(file_id);\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 if let Some(root_crate) = root_crate {\n-                    crate_graph\n-                        .add_dep(root_crate, crate_name.into(), other_crate)\n-                        .unwrap();\n+                    crate_graph.add_dep(root_crate, crate_name.into(), other_crate).unwrap();\n                 }\n             }\n             change.add_file(source_root, file_id, path, Arc::new(contents));"}, {"sha": "a2e4b65068c2cf2e9f4842ea8a5ebd71099949c3", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -72,10 +72,7 @@ impl NavigationTarget {\n \n     pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let (file_id, source) = module.definition_source(db);\n-        let name = module\n-            .name(db)\n-            .map(|it| it.to_string().into())\n-            .unwrap_or_default();\n+        let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         match source {\n             ModuleSource::SourceFile(node) => {\n                 NavigationTarget::from_syntax(file_id, name, None, node.syntax())\n@@ -87,10 +84,7 @@ impl NavigationTarget {\n     }\n \n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n-        let name = module\n-            .name(db)\n-            .map(|it| it.to_string().into())\n-            .unwrap_or_default();\n+        let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some((file_id, source)) = module.declaration_source(db) {\n             return NavigationTarget::from_syntax(file_id, name, None, source.syntax());\n         }"}, {"sha": "2cb1cc9be06e38d2b15e636e0c6c2d47797dcc87", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -305,9 +305,7 @@ mod tests {\n                 }\n             }\n         }\n-        let result = text_edit_bulder\n-            .finish()\n-            .apply(&*analysis.file_text(file_id.unwrap()));\n+        let result = text_edit_bulder.finish().apply(&*analysis.file_text(file_id.unwrap()));\n         assert_eq_text!(expected, &*result);\n     }\n }"}, {"sha": "d64b5a4e06e26ec5b890d1344d2ec5f9fdec6f2f", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -23,11 +23,7 @@ pub enum RunnableKind {\n \n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let source_file = db.parse(file_id);\n-    source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(|i| runnable(db, file_id, i))\n-        .collect()\n+    source_file.syntax().descendants().filter_map(|i| runnable(db, file_id, i)).collect()\n }\n \n fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {\n@@ -45,20 +41,13 @@ fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n     let kind = if name == \"main\" {\n         RunnableKind::Bin\n     } else if fn_def.has_atom_attr(\"test\") {\n-        RunnableKind::Test {\n-            name: name.to_string(),\n-        }\n+        RunnableKind::Test { name: name.to_string() }\n     } else if fn_def.has_atom_attr(\"bench\") {\n-        RunnableKind::Bench {\n-            name: name.to_string(),\n-        }\n+        RunnableKind::Bench { name: name.to_string() }\n     } else {\n         return None;\n     };\n-    Some(Runnable {\n-        range: fn_def.syntax().range(),\n-        kind,\n-    })\n+    Some(Runnable { range: fn_def.syntax().range(), kind })\n }\n \n fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Option<Runnable> {\n@@ -77,16 +66,8 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Opt\n     let module = hir::source_binder::module_from_child_node(db, file_id, module.syntax())?;\n \n     // FIXME: thread cancellation instead of `.ok`ing\n-    let path = module\n-        .path_to_root(db)\n-        .into_iter()\n-        .rev()\n-        .filter_map(|it| it.name(db))\n-        .join(\"::\");\n-    Some(Runnable {\n-        range,\n-        kind: RunnableKind::TestMod { path },\n-    })\n+    let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n+    Some(Runnable { range, kind: RunnableKind::TestMod { path } })\n }\n \n #[cfg(test)]"}, {"sha": "e0fc1c123c836af2b348c0f6dc33a435c4989eb8", "filename": "crates/ra_ide_api/src/status.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -22,9 +22,7 @@ pub(crate) fn syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n pub(crate) fn status(db: &RootDatabase) -> String {\n     let files_stats = db.query(FileTextQuery).entries::<FilesStats>();\n     let syntax_tree_stats = syntax_tree_stats(db);\n-    let symbols_stats = db\n-        .query(LibrarySymbolsQuery)\n-        .entries::<LibrarySymbolsStats>();\n+    let symbols_stats = db.query(LibrarySymbolsQuery).entries::<LibrarySymbolsStats>();\n     let n_defs = {\n         let interner: &hir::HirInterner = db.as_ref();\n         interner.len()\n@@ -75,11 +73,7 @@ pub(crate) struct SyntaxTreeStats {\n \n impl fmt::Display for SyntaxTreeStats {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            fmt,\n-            \"{} trees, {} ({}) retained\",\n-            self.total, self.retained, self.retained_size,\n-        )\n+        write!(fmt, \"{} trees, {} ({}) retained\", self.total, self.retained, self.retained_size,)\n     }\n }\n \n@@ -144,20 +138,13 @@ impl MemoryStats {\n \n     #[cfg(not(feature = \"jemalloc\"))]\n     fn current() -> MemoryStats {\n-        MemoryStats {\n-            allocated: Bytes(0),\n-            resident: Bytes(0),\n-        }\n+        MemoryStats { allocated: Bytes(0), resident: Bytes(0) }\n     }\n }\n \n impl fmt::Display for MemoryStats {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            fmt,\n-            \"{} allocated {} resident\",\n-            self.allocated, self.resident,\n-        )\n+        write!(fmt, \"{} allocated {} resident\", self.allocated, self.resident,)\n     }\n }\n "}, {"sha": "de0f4613402fd6e1e5aec9fd175e5d1a4ec2f4ec", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -101,10 +101,7 @@ pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol>\n         }\n \n         let snap = Snap(db.snapshot());\n-        files\n-            .par_iter()\n-            .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-            .collect()\n+        files.par_iter().map_with(snap, |db, &file_id| db.0.file_symbols(file_id)).collect()\n     };\n     query.search(&buf)\n }"}, {"sha": "a435fe56e64fed85f4edf8f4ec3e62f90845e500", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -9,20 +9,12 @@ use crate::{\n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let source_file = db.parse(file_id);\n     let mut res = ra_ide_api_light::highlight(source_file.syntax());\n-    for macro_call in source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::MacroCall::cast)\n-    {\n+    for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n-            let mapped_ranges = ra_ide_api_light::highlight(&exp.syntax())\n-                .into_iter()\n-                .filter_map(|r| {\n+            let mapped_ranges =\n+                ra_ide_api_light::highlight(&exp.syntax()).into_iter().filter_map(|r| {\n                     let mapped_range = exp.map_range_back(r.range)?;\n-                    let res = HighlightedRange {\n-                        range: mapped_range + off,\n-                        tag: r.tag,\n-                    };\n+                    let res = HighlightedRange { range: mapped_range + off, tag: r.tag };\n                     Some(res)\n                 });\n             res.extend(mapped_ranges);"}, {"sha": "7c383ca2af69f575ba4bab3adf8dc89baf714405", "filename": "crates/ra_ide_api_light/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -72,14 +72,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     single_use_tree: &ast::UseTree,\n ) -> Option<TextEdit> {\n     let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree\n-        .path()?\n-        .segment()?\n-        .syntax()\n-        .first_child()?\n-        .kind()\n-        == SyntaxKind::SELF_KW\n-    {\n+    if single_use_tree.path()?.segment()?.syntax().first_child()?.kind() == SyntaxKind::SELF_KW {\n         let start = use_tree_list_node.prev_sibling()?.range().start();\n         let end = use_tree_list_node.range().end();\n         let range = TextRange::from_to(start, end);\n@@ -145,9 +138,8 @@ mod tests {\n         for node in file.syntax().descendants() {\n             func(&mut diagnostics, node);\n         }\n-        let diagnostic = diagnostics\n-            .pop()\n-            .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n+        let diagnostic =\n+            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n         let fix = diagnostic.fix.unwrap();\n         let actual = fix.edit.apply(&before);\n         assert_eq_text!(after, &actual);\n@@ -162,21 +154,9 @@ mod tests {\n         \",\n             check_unnecessary_braces_in_use_statement,\n         );\n-        check_apply(\n-            \"use {b};\",\n-            \"use b;\",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\n-            \"use a::{c};\",\n-            \"use a::c;\",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\n-            \"use a::{self};\",\n-            \"use a;\",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n+        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n         check_apply(\n             \"use a::{c, d::{e}};\",\n             \"use a::{c, d::e};\","}, {"sha": "28d62f290559df08af83e729c386670906223b93", "filename": "crates/ra_ide_api_light/src/extend_selection.rs", "status": "modified", "additions": 11, "deletions": 46, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -43,11 +43,7 @@ pub fn extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n     let node = find_covering_node(root, range);\n \n     // Using shallowest node with same range allows us to traverse siblings.\n-    let node = node\n-        .ancestors()\n-        .take_while(|n| n.range() == node.range())\n-        .last()\n-        .unwrap();\n+    let node = node.ancestors().take_while(|n| n.range() == node.range()).last().unwrap();\n \n     if range == node.range() {\n         if string_kinds.contains(&node.kind()) {\n@@ -145,10 +141,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n     }\n \n     if let Some(comma_node) = nearby_comma(node, Direction::Prev) {\n-        return Some(TextRange::from_to(\n-            comma_node.range().start(),\n-            node.range().end(),\n-        ));\n+        return Some(TextRange::from_to(comma_node.range().start(), node.range().end()));\n     }\n \n     if let Some(comma_node) = nearby_comma(node, Direction::Next) {\n@@ -160,10 +153,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n             .filter(|node| is_single_line_ws(node))\n             .unwrap_or(comma_node);\n \n-        return Some(TextRange::from_to(\n-            node.range().start(),\n-            final_node.range().end(),\n-        ));\n+        return Some(TextRange::from_to(node.range().start(), final_node.range().end()));\n     }\n \n     return None;\n@@ -217,36 +207,15 @@ mod tests {\n     #[test]\n     fn test_extend_selection_list() {\n         do_check(r#\"fn foo(<|>x: i32) {}\"#, &[\"x\", \"x: i32\"]);\n-        do_check(\n-            r#\"fn foo(<|>x: i32, y: i32) {}\"#,\n-            &[\"x\", \"x: i32\", \"x: i32, \"],\n-        );\n-        do_check(\n-            r#\"fn foo(<|>x: i32,y: i32) {}\"#,\n-            &[\"x\", \"x: i32\", \"x: i32,\"],\n-        );\n-        do_check(\n-            r#\"fn foo(x: i32, <|>y: i32) {}\"#,\n-            &[\"y\", \"y: i32\", \", y: i32\"],\n-        );\n-        do_check(\n-            r#\"fn foo(x: i32, <|>y: i32, ) {}\"#,\n-            &[\"y\", \"y: i32\", \", y: i32\"],\n-        );\n-        do_check(\n-            r#\"fn foo(x: i32,<|>y: i32) {}\"#,\n-            &[\"y\", \"y: i32\", \",y: i32\"],\n-        );\n+        do_check(r#\"fn foo(<|>x: i32, y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32, \"]);\n+        do_check(r#\"fn foo(<|>x: i32,y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32,\"]);\n+        do_check(r#\"fn foo(x: i32, <|>y: i32) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n+        do_check(r#\"fn foo(x: i32, <|>y: i32, ) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n+        do_check(r#\"fn foo(x: i32,<|>y: i32) {}\"#, &[\"y\", \"y: i32\", \",y: i32\"]);\n \n-        do_check(\n-            r#\"const FOO: [usize; 2] = [ 22<|> , 33];\"#,\n-            &[\"22\", \"22 , \"],\n-        );\n+        do_check(r#\"const FOO: [usize; 2] = [ 22<|> , 33];\"#, &[\"22\", \"22 , \"]);\n         do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|>];\"#, &[\"33\", \", 33\"]);\n-        do_check(\n-            r#\"const FOO: [usize; 2] = [ 22 , 33<|> ,];\"#,\n-            &[\"33\", \", 33\"],\n-        );\n+        do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|> ,];\"#, &[\"33\", \", 33\"]);\n \n         do_check(\n             r#\"\n@@ -292,11 +261,7 @@ struct B {\n     <|>\n }\n             \"#,\n-            &[\n-                \"\\n    \\n\",\n-                \"{\\n    \\n}\",\n-                \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\",\n-            ],\n+            &[\"\\n    \\n\", \"{\\n    \\n}\", \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\"],\n         )\n     }\n "}, {"sha": "357a7dee1e9823d263209e1368bf339413a77905", "filename": "crates/ra_ide_api_light/src/folding_ranges.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ffolding_ranges.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -30,30 +30,21 @@ pub fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n         // Fold items that span multiple lines\n         if let Some(kind) = fold_kind(node.kind()) {\n             if node.text().contains('\\n') {\n-                res.push(Fold {\n-                    range: node.range(),\n-                    kind,\n-                });\n+                res.push(Fold { range: node.range(), kind });\n             }\n         }\n \n         // Fold groups of comments\n         if node.kind() == COMMENT && !visited_comments.contains(&node) {\n             if let Some(range) = contiguous_range_for_comment(node, &mut visited_comments) {\n-                res.push(Fold {\n-                    range,\n-                    kind: FoldKind::Comment,\n-                })\n+                res.push(Fold { range, kind: FoldKind::Comment })\n             }\n         }\n \n         // Fold groups of imports\n         if node.kind() == USE_ITEM && !visited_imports.contains(&node) {\n             if let Some(range) = contiguous_range_for_group(node, &mut visited_imports) {\n-                res.push(Fold {\n-                    range,\n-                    kind: FoldKind::Imports,\n-                })\n+                res.push(Fold { range, kind: FoldKind::Imports })\n             }\n         }\n \n@@ -62,10 +53,7 @@ pub fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n             if let Some(range) =\n                 contiguous_range_for_group_unless(node, has_visibility, &mut visited_mods)\n             {\n-                res.push(Fold {\n-                    range,\n-                    kind: FoldKind::Mods,\n-                })\n+                res.push(Fold { range, kind: FoldKind::Mods })\n             }\n         }\n     }\n@@ -84,9 +72,7 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n }\n \n fn has_visibility(node: &SyntaxNode) -> bool {\n-    ast::Module::cast(node)\n-        .and_then(|m| m.visibility())\n-        .is_some()\n+    ast::Module::cast(node).and_then(|m| m.visibility()).is_some()\n }\n \n fn contiguous_range_for_group<'a>(\n@@ -125,10 +111,7 @@ fn contiguous_range_for_group_unless<'a>(\n     }\n \n     if first != last {\n-        Some(TextRange::from_to(\n-            first.range().start(),\n-            last.range().end(),\n-        ))\n+        Some(TextRange::from_to(first.range().start(), last.range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n@@ -169,10 +152,7 @@ fn contiguous_range_for_comment<'a>(\n     }\n \n     if first != last {\n-        Some(TextRange::from_to(\n-            first.range().start(),\n-            last.range().end(),\n-        ))\n+        Some(TextRange::from_to(first.range().start(), last.range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n@@ -199,10 +179,8 @@ mod tests {\n             fold_kinds.len(),\n             \"The amount of fold kinds is different than the expected amount\"\n         );\n-        for ((fold, range), fold_kind) in folds\n-            .into_iter()\n-            .zip(ranges.into_iter())\n-            .zip(fold_kinds.into_iter())\n+        for ((fold, range), fold_kind) in\n+            folds.into_iter().zip(ranges.into_iter()).zip(fold_kinds.into_iter())\n         {\n             assert_eq!(fold.range.start(), range.start());\n             assert_eq!(fold.range.end(), range.end());\n@@ -280,12 +258,7 @@ mod with_attribute_next;</fold>\n fn main() <fold>{\n }</fold>\"#;\n \n-        let folds = &[\n-            FoldKind::Mods,\n-            FoldKind::Mods,\n-            FoldKind::Mods,\n-            FoldKind::Block,\n-        ];\n+        let folds = &[FoldKind::Mods, FoldKind::Mods, FoldKind::Mods, FoldKind::Block];\n         do_check(text, folds);\n     }\n "}, {"sha": "8bc03f974afe3dd426fcb7e6eb0b641cd6c05164", "filename": "crates/ra_ide_api_light/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -32,10 +32,7 @@ fn prev_leaves(node: &SyntaxNode) -> impl Iterator<Item = &SyntaxNode> {\n }\n \n fn prev_leaf(node: &SyntaxNode) -> Option<&SyntaxNode> {\n-    generate(node.ancestors().find_map(SyntaxNode::prev_sibling), |it| {\n-        it.last_child()\n-    })\n-    .last()\n+    generate(node.ancestors().find_map(SyntaxNode::prev_sibling), |it| it.last_child()).last()\n }\n \n pub fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {"}, {"sha": "03770c52e47a965504e4ad2c8147276931b553cc", "filename": "crates/ra_ide_api_light/src/join_lines.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fjoin_lines.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -50,11 +50,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> LocalEdit {\n         }\n     }\n \n-    LocalEdit {\n-        label: \"join lines\".to_string(),\n-        edit: edit.finish(),\n-        cursor_position: None,\n-    }\n+    LocalEdit { label: \"join lines\".to_string(), edit: edit.finish(), cursor_position: None }\n }\n \n fn remove_newline(\n@@ -71,10 +67,7 @@ fn remove_newline(\n         )];\n         let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n \n-        edit.replace(\n-            TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n-            \" \".to_string(),\n-        );\n+        edit.replace(TextRange::offset_len(offset, ((spaces + 1) as u32).into()), \" \".to_string());\n         return;\n     }\n \n@@ -109,11 +102,7 @@ fn remove_newline(\n         edit.delete(TextRange::from_to(prev.range().start(), node.range().end()));\n     } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n         // Removes: comma, newline (incl. surrounding whitespace)\n-        let space = if let Some(left) = prev.prev_sibling() {\n-            compute_ws(left, next)\n-        } else {\n-            \" \"\n-        };\n+        let space = if let Some(left) = prev.prev_sibling() { compute_ws(left, next) } else { \" \" };\n         edit.replace(\n             TextRange::from_to(prev.range().start(), node.range().end()),\n             space.to_string(),\n@@ -134,20 +123,14 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Opti\n     let block = ast::Block::cast(node.parent()?)?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n     let expr = extract_trivial_expression(block)?;\n-    edit.replace(\n-        block_expr.syntax().range(),\n-        expr.syntax().text().to_string(),\n-    );\n+    edit.replace(block_expr.syntax().range(), expr.syntax().text().to_string());\n     Some(())\n }\n \n fn join_single_use_tree(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node.parent()?)?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n-    edit.replace(\n-        use_tree_list.syntax().range(),\n-        tree.syntax().text().to_string(),\n-    );\n+    edit.replace(use_tree_list.syntax().range(), tree.syntax().text().to_string());\n     Some(())\n }\n "}, {"sha": "f3078f51e593b2b50e83bfeb2d175581c046f0b5", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -63,9 +63,8 @@ pub struct Diagnostic {\n }\n \n pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n-    const BRACES: &[SyntaxKind] = &[\n-        L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE,\n-    ];\n+    const BRACES: &[SyntaxKind] =\n+        &[L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE];\n     let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax(), offset)\n         .filter_map(|node| {\n             let idx = BRACES.iter().position(|&brace| brace == node.kind())?;\n@@ -74,9 +73,7 @@ pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n         .next()?;\n     let parent = brace_node.parent()?;\n     let matching_kind = BRACES[brace_idx ^ 1];\n-    let matching_node = parent\n-        .children()\n-        .find(|node| node.kind() == matching_kind)?;\n+    let matching_node = parent.children().find(|node| node.kind() == matching_kind)?;\n     Some(matching_node.range().start())\n }\n \n@@ -122,10 +119,7 @@ pub fn highlight(root: &SyntaxNode) -> Vec<HighlightedRange> {\n                 continue;\n             }\n         };\n-        res.push(HighlightedRange {\n-            range: node.range(),\n-            tag,\n-        })\n+        res.push(HighlightedRange { range: node.range(), tag })\n     }\n     res\n }"}, {"sha": "bf004c33ad05a8d6a8d46d0eb00f6b64e840f796", "filename": "crates/ra_ide_api_light/src/line_index.rs", "status": "modified", "additions": 23, "deletions": 142, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fline_index.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -54,10 +54,7 @@ impl LineIndex {\n \n             let char_len = TextUnit::of_char(c);\n             if char_len.to_usize() > 1 {\n-                utf16_chars.push(Utf16Char {\n-                    start: curr_col,\n-                    end: curr_col + char_len,\n-                });\n+                utf16_chars.push(Utf16Char { start: curr_col, end: curr_col + char_len });\n             }\n \n             curr_col += char_len;\n@@ -68,21 +65,15 @@ impl LineIndex {\n             utf16_lines.insert(line, utf16_chars);\n         }\n \n-        LineIndex {\n-            newlines,\n-            utf16_lines,\n-        }\n+        LineIndex { newlines, utf16_lines }\n     }\n \n     pub fn line_col(&self, offset: TextUnit) -> LineCol {\n         let line = self.newlines.upper_bound(&offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n \n-        LineCol {\n-            line: line as u32,\n-            col_utf16: self.utf8_to_utf16_col(line as u32, col) as u32,\n-        }\n+        LineCol { line: line as u32, col_utf16: self.utf8_to_utf16_col(line as u32, col) as u32 }\n     }\n \n     pub fn offset(&self, line_col: LineCol) -> TextUnit {\n@@ -131,10 +122,7 @@ impl LineIndex {\n #[cfg(test)]\n /// Simple reference implementation to use in proptests\n pub fn to_line_col(text: &str, offset: TextUnit) -> LineCol {\n-    let mut res = LineCol {\n-        line: 0,\n-        col_utf16: 0,\n-    };\n+    let mut res = LineCol { line: 0, col_utf16: 0 };\n     for (i, c) in text.char_indices() {\n         if i + c.len_utf8() > offset.to_usize() {\n             // if it's an invalid offset, inside a multibyte char\n@@ -161,120 +149,31 @@ mod test_line_index {\n     fn test_line_index() {\n         let text = \"hello\\nworld\";\n         let index = LineIndex::new(text);\n-        assert_eq!(\n-            index.line_col(0.into()),\n-            LineCol {\n-                line: 0,\n-                col_utf16: 0\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(1.into()),\n-            LineCol {\n-                line: 0,\n-                col_utf16: 1\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(5.into()),\n-            LineCol {\n-                line: 0,\n-                col_utf16: 5\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(6.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 0\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(7.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 1\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(8.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 2\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(10.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 4\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(11.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 5\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(12.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 6\n-            }\n-        );\n+        assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n+        assert_eq!(index.line_col(1.into()), LineCol { line: 0, col_utf16: 1 });\n+        assert_eq!(index.line_col(5.into()), LineCol { line: 0, col_utf16: 5 });\n+        assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 0 });\n+        assert_eq!(index.line_col(7.into()), LineCol { line: 1, col_utf16: 1 });\n+        assert_eq!(index.line_col(8.into()), LineCol { line: 1, col_utf16: 2 });\n+        assert_eq!(index.line_col(10.into()), LineCol { line: 1, col_utf16: 4 });\n+        assert_eq!(index.line_col(11.into()), LineCol { line: 1, col_utf16: 5 });\n+        assert_eq!(index.line_col(12.into()), LineCol { line: 1, col_utf16: 6 });\n \n         let text = \"\\nhello\\nworld\";\n         let index = LineIndex::new(text);\n-        assert_eq!(\n-            index.line_col(0.into()),\n-            LineCol {\n-                line: 0,\n-                col_utf16: 0\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(1.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 0\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(2.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 1\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(6.into()),\n-            LineCol {\n-                line: 1,\n-                col_utf16: 5\n-            }\n-        );\n-        assert_eq!(\n-            index.line_col(7.into()),\n-            LineCol {\n-                line: 2,\n-                col_utf16: 0\n-            }\n-        );\n+        assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n+        assert_eq!(index.line_col(1.into()), LineCol { line: 1, col_utf16: 0 });\n+        assert_eq!(index.line_col(2.into()), LineCol { line: 1, col_utf16: 1 });\n+        assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 5 });\n+        assert_eq!(index.line_col(7.into()), LineCol { line: 2, col_utf16: 0 });\n     }\n \n     fn arb_text_with_offset() -> BoxedStrategy<(TextUnit, String)> {\n-        arb_text()\n-            .prop_flat_map(|text| (arb_offset(&text), Just(text)))\n-            .boxed()\n+        arb_text().prop_flat_map(|text| (arb_offset(&text), Just(text))).boxed()\n     }\n \n     fn to_line_col(text: &str, offset: TextUnit) -> LineCol {\n-        let mut res = LineCol {\n-            line: 0,\n-            col_utf16: 0,\n-        };\n+        let mut res = LineCol { line: 0, col_utf16: 0 };\n         for (i, c) in text.char_indices() {\n             if i + c.len_utf8() > offset.to_usize() {\n                 // if it's an invalid offset, inside a multibyte char\n@@ -333,13 +232,7 @@ const C: char = '\u30e1';\n \n         assert_eq!(col_index.utf16_lines.len(), 1);\n         assert_eq!(col_index.utf16_lines[&1].len(), 1);\n-        assert_eq!(\n-            col_index.utf16_lines[&1][0],\n-            Utf16Char {\n-                start: 17.into(),\n-                end: 20.into()\n-            }\n-        );\n+        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n \n         // UTF-8 to UTF-16, no changes\n         assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n@@ -364,20 +257,8 @@ const C: char = \\\"\u30e1 \u30e1\\\";\n \n         assert_eq!(col_index.utf16_lines.len(), 1);\n         assert_eq!(col_index.utf16_lines[&1].len(), 2);\n-        assert_eq!(\n-            col_index.utf16_lines[&1][0],\n-            Utf16Char {\n-                start: 17.into(),\n-                end: 20.into()\n-            }\n-        );\n-        assert_eq!(\n-            col_index.utf16_lines[&1][1],\n-            Utf16Char {\n-                start: 21.into(),\n-                end: 24.into()\n-            }\n-        );\n+        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n+        assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n \n         // UTF-8 to UTF-16\n         assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);"}, {"sha": "799a920ad75b43b2c5f6d645562cdb8049f24857", "filename": "crates/ra_ide_api_light/src/line_index_utils.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fline_index_utils.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -17,11 +17,7 @@ struct LineIndexStepIter<'a> {\n \n impl<'a> LineIndexStepIter<'a> {\n     fn from(line_index: &LineIndex) -> LineIndexStepIter {\n-        let mut x = LineIndexStepIter {\n-            line_index,\n-            next_newline_idx: 0,\n-            utf16_chars: None,\n-        };\n+        let mut x = LineIndexStepIter { line_index, next_newline_idx: 0, utf16_chars: None };\n         // skip first newline since it's not real\n         x.next();\n         x\n@@ -35,10 +31,7 @@ impl<'a> Iterator for LineIndexStepIter<'a> {\n             .as_mut()\n             .and_then(|(newline, x)| {\n                 let x = x.next()?;\n-                Some(Step::Utf16Char(TextRange::from_to(\n-                    *newline + x.start,\n-                    *newline + x.end,\n-                )))\n+                Some(Step::Utf16Char(TextRange::from_to(*newline + x.start, *newline + x.end)))\n             })\n             .or_else(|| {\n                 let next_newline = *self.line_index.newlines.get(self.next_newline_idx)?;\n@@ -113,11 +106,7 @@ struct Edits<'a> {\n \n impl<'a> Edits<'a> {\n     fn from_text_edit(text_edit: &'a TextEdit) -> Edits<'a> {\n-        let mut x = Edits {\n-            edits: text_edit.as_atoms(),\n-            current: None,\n-            acc_diff: 0,\n-        };\n+        let mut x = Edits { edits: text_edit.as_atoms(), current: None, acc_diff: 0 };\n         x.advance_edit();\n         x\n     }\n@@ -127,11 +116,7 @@ impl<'a> Edits<'a> {\n             Some((next, rest)) => {\n                 let delete = self.translate_range(next.delete);\n                 let diff = next.insert.len() as i64 - next.delete.len().to_usize() as i64;\n-                self.current = Some(TranslatedEdit {\n-                    delete,\n-                    insert: &next.insert,\n-                    diff,\n-                });\n+                self.current = Some(TranslatedEdit { delete, insert: &next.insert, diff });\n                 self.edits = rest;\n             }\n             None => {\n@@ -142,10 +127,7 @@ impl<'a> Edits<'a> {\n \n     fn next_inserted_steps(&mut self) -> Option<OffsetStepIter<'a>> {\n         let cur = self.current.as_ref()?;\n-        let res = Some(OffsetStepIter {\n-            offset: cur.delete.start(),\n-            text: &cur.insert,\n-        });\n+        let res = Some(OffsetStepIter { offset: cur.delete.start(), text: &cur.insert });\n         self.advance_edit();\n         res\n     }\n@@ -160,18 +142,12 @@ impl<'a> Edits<'a> {\n                 if step_pos <= edit.delete.start() {\n                     NextSteps::Use\n                 } else if step_pos <= edit.delete.end() {\n-                    let iter = OffsetStepIter {\n-                        offset: edit.delete.start(),\n-                        text: &edit.insert,\n-                    };\n+                    let iter = OffsetStepIter { offset: edit.delete.start(), text: &edit.insert };\n                     // empty slice to avoid returning steps again\n                     edit.insert = &edit.insert[edit.insert.len()..];\n                     NextSteps::ReplaceMany(iter)\n                 } else {\n-                    let iter = OffsetStepIter {\n-                        offset: edit.delete.start(),\n-                        text: &edit.insert,\n-                    };\n+                    let iter = OffsetStepIter { offset: edit.delete.start(), text: &edit.insert };\n                     // empty slice to avoid returning steps again\n                     edit.insert = &edit.insert[edit.insert.len()..];\n                     self.advance_edit();\n@@ -222,11 +198,7 @@ struct RunningLineCol {\n \n impl RunningLineCol {\n     fn new() -> RunningLineCol {\n-        RunningLineCol {\n-            line: 0,\n-            last_newline: TextUnit::from(0),\n-            col_adjust: TextUnit::from(0),\n-        }\n+        RunningLineCol { line: 0, last_newline: TextUnit::from(0), col_adjust: TextUnit::from(0) }\n     }\n \n     fn to_line_col(&self, offset: TextUnit) -> LineCol {\n@@ -339,12 +311,7 @@ mod test {\n                 let edited_text = x.edit.apply(&x.text);\n                 let arb_offset = arb_offset(&edited_text);\n                 (Just(x), Just(edited_text), arb_offset).prop_map(|(x, edited_text, offset)| {\n-                    ArbTextWithEditAndOffset {\n-                        text: x.text,\n-                        edit: x.edit,\n-                        edited_text,\n-                        offset,\n-                    }\n+                    ArbTextWithEditAndOffset { text: x.text, edit: x.edit, edited_text, offset }\n                 })\n             })\n             .boxed()"}, {"sha": "75afd118145f89424eab1e790179d47ed555165f", "filename": "crates/ra_ide_api_light/src/structure.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fstructure.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -70,10 +70,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             node_range: node.syntax().range(),\n             kind: node.syntax().kind(),\n             detail,\n-            deprecated: node\n-                .attrs()\n-                .filter_map(|x| x.as_named())\n-                .any(|x| x == \"deprecated\"),\n+            deprecated: node.attrs().filter_map(|x| x.as_named()).any(|x| x == \"deprecated\"),\n         })\n     }\n \n@@ -123,11 +120,9 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             let target_trait = im.target_trait();\n             let label = match target_trait {\n                 None => format!(\"impl {}\", target_type.syntax().text()),\n-                Some(t) => format!(\n-                    \"impl {} for {}\",\n-                    t.syntax().text(),\n-                    target_type.syntax().text(),\n-                ),\n+                Some(t) => {\n+                    format!(\"impl {} for {}\", t.syntax().text(), target_type.syntax().text(),)\n+                }\n             };\n \n             let node = StructureNode {"}, {"sha": "a08a5a8c5678958173e9a8ab30975a7c226ab483", "filename": "crates/ra_ide_api_light/src/typing.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -8,9 +8,8 @@ use ra_syntax::{\n use crate::{LocalEdit, TextEditBuilder, formatting::leading_indent};\n \n pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let comment = find_leaf_at_offset(file.syntax(), offset)\n-        .left_biased()\n-        .and_then(ast::Comment::cast)?;\n+    let comment =\n+        find_leaf_at_offset(file.syntax(), offset).left_biased().and_then(ast::Comment::cast)?;\n \n     if let ast::CommentFlavor::Multiline = comment.flavor() {\n         return None;\n@@ -64,12 +63,7 @@ pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<LocalEdit>\n         if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n             return None;\n         }\n-        if file\n-            .syntax()\n-            .text()\n-            .slice(eq_offset..expr_range.start())\n-            .contains('\\n')\n-        {\n+        if file.syntax().text().slice(eq_offset..expr_range.start()).contains('\\n') {\n             return None;\n         }\n     } else {\n@@ -100,10 +94,7 @@ pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit\n     let current_indent_len = TextUnit::of_str(current_indent);\n \n     // Make sure dot is a part of call chain\n-    let field_expr = whitespace\n-        .syntax()\n-        .parent()\n-        .and_then(ast::FieldExpr::cast)?;\n+    let field_expr = whitespace.syntax().parent().and_then(ast::FieldExpr::cast)?;\n     let prev_indent = leading_indent(field_expr.syntax())?;\n     let target_indent = format!(\"    {}\", prev_indent);\n     let target_indent_len = TextUnit::of_str(&target_indent);"}, {"sha": "2af2b89fec37590b30d08c3c18716c43cf0ddb3b", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,15 +7,13 @@ use lsp_types::{\n \n pub fn server_capabilities() -> ServerCapabilities {\n     ServerCapabilities {\n-        text_document_sync: Some(TextDocumentSyncCapability::Options(\n-            TextDocumentSyncOptions {\n-                open_close: Some(true),\n-                change: Some(TextDocumentSyncKind::Full),\n-                will_save: None,\n-                will_save_wait_until: None,\n-                save: None,\n-            },\n-        )),\n+        text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n+            open_close: Some(true),\n+            change: Some(TextDocumentSyncKind::Full),\n+            will_save: None,\n+            will_save_wait_until: None,\n+            save: None,\n+        })),\n         hover_provider: Some(true),\n         completion_provider: Some(CompletionOptions {\n             resolve_provider: None,\n@@ -32,9 +30,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n         document_symbol_provider: Some(true),\n         workspace_symbol_provider: Some(true),\n         code_action_provider: Some(CodeActionProviderCapability::Simple(true)),\n-        code_lens_provider: Some(CodeLensOptions {\n-            resolve_provider: Some(true),\n-        }),\n+        code_lens_provider: Some(CodeLensOptions { resolve_provider: Some(true) }),\n         document_formatting_provider: Some(true),\n         document_range_formatting_provider: None,\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {"}, {"sha": "e011eab7cb0e94404f7086dac5facd8dd23cadc2", "filename": "crates/ra_lsp_server/src/cargo_target_spec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -64,10 +64,7 @@ impl CargoTargetSpec {\n             None => return Ok(None),\n         };\n         let file_id = world.analysis().crate_root(crate_id)?;\n-        let path = world\n-            .vfs\n-            .read()\n-            .file2path(ra_vfs::VfsFile(file_id.0.into()));\n+        let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0.into()));\n         let res = world.workspaces.iter().find_map(|ws| {\n             let tgt = ws.cargo.target_by_root(&path)?;\n             let res = CargoTargetSpec {"}, {"sha": "20077a48af5552c5a41eca7643d79f137d133fa7", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -82,11 +82,8 @@ impl ConvWith for CompletionItem {\n     fn conv_with(mut self, ctx: &LineIndex) -> ::lsp_types::CompletionItem {\n         let atom_text_edit = AtomTextEdit::replace(self.source_range(), self.insert_text());\n         let text_edit = (&atom_text_edit).conv_with(ctx);\n-        let additional_text_edits = if let Some(edit) = self.take_text_edit() {\n-            Some(edit.conv_with(ctx))\n-        } else {\n-            None\n-        };\n+        let additional_text_edits =\n+            if let Some(edit) = self.take_text_edit() { Some(edit.conv_with(ctx)) } else { None };\n \n         let mut res = lsp_types::CompletionItem {\n             label: self.label().to_string(),\n@@ -112,10 +109,7 @@ impl ConvWith for Position {\n     type Output = TextUnit;\n \n     fn conv_with(self, line_index: &LineIndex) -> TextUnit {\n-        let line_col = LineCol {\n-            line: self.line as u32,\n-            col_utf16: self.character as u32,\n-        };\n+        let line_col = LineCol { line: self.line as u32, col_utf16: self.character as u32 };\n         line_index.offset(line_col)\n     }\n }\n@@ -135,10 +129,7 @@ impl ConvWith for TextRange {\n     type Output = Range;\n \n     fn conv_with(self, line_index: &LineIndex) -> Range {\n-        Range::new(\n-            self.start().conv_with(line_index),\n-            self.end().conv_with(line_index),\n-        )\n+        Range::new(self.start().conv_with(line_index), self.end().conv_with(line_index))\n     }\n }\n \n@@ -147,10 +138,7 @@ impl ConvWith for Range {\n     type Output = TextRange;\n \n     fn conv_with(self, line_index: &LineIndex) -> TextRange {\n-        TextRange::from_to(\n-            self.start.conv_with(line_index),\n-            self.end.conv_with(line_index),\n-        )\n+        TextRange::from_to(self.start.conv_with(line_index), self.end.conv_with(line_index))\n     }\n }\n \n@@ -303,11 +291,7 @@ impl TryConvWith for SourceChange {\n             changes: None,\n             document_changes: Some(DocumentChanges::Operations(document_changes)),\n         };\n-        Ok(req::SourceChange {\n-            label: self.label,\n-            workspace_edit,\n-            cursor_position,\n-        })\n+        Ok(req::SourceChange { label: self.label, workspace_edit, cursor_position })\n     }\n }\n \n@@ -320,16 +304,8 @@ impl TryConvWith for SourceFileEdit {\n             version: None,\n         };\n         let line_index = world.analysis().file_line_index(self.file_id);\n-        let edits = self\n-            .edit\n-            .as_atoms()\n-            .iter()\n-            .map_conv_with(&line_index)\n-            .collect();\n-        Ok(TextDocumentEdit {\n-            text_document,\n-            edits,\n-        })\n+        let edits = self.edit.as_atoms().iter().map_conv_with(&line_index).collect();\n+        Ok(TextDocumentEdit { text_document, edits })\n     }\n }\n \n@@ -342,18 +318,10 @@ impl TryConvWith for FileSystemEdit {\n                 let uri = world.path_to_uri(source_root, &path)?;\n                 ResourceOp::Create(CreateFile { uri, options: None })\n             }\n-            FileSystemEdit::MoveFile {\n-                src,\n-                dst_source_root,\n-                dst_path,\n-            } => {\n+            FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n                 let old_uri = world.file_id_to_uri(src)?;\n                 let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n-                ResourceOp::Rename(RenameFile {\n-                    old_uri,\n-                    new_uri,\n-                    options: None,\n-                })\n+                ResourceOp::Rename(RenameFile { old_uri, new_uri, options: None })\n             }\n         };\n         Ok(res)\n@@ -381,11 +349,8 @@ pub fn to_location_link(\n \n     let target_range = target.info.full_range().conv_with(&tgt_line_index);\n \n-    let target_selection_range = target\n-        .info\n-        .focus_range()\n-        .map(|it| it.conv_with(&tgt_line_index))\n-        .unwrap_or(target_range);\n+    let target_selection_range =\n+        target.info.focus_range().map(|it| it.conv_with(&tgt_line_index)).unwrap_or(target_range);\n \n     let res = LocationLink {\n         origin_selection_range: Some(target.range.conv_with(line_index)),"}, {"sha": "03f83c7bef14c6f5cbc2024fddbd20ed4e20b3c3", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -36,23 +36,15 @@ struct InitializationOptions {\n fn main_inner() -> Result<()> {\n     let (receiver, sender, threads) = stdio_transport();\n     let cwd = ::std::env::current_dir()?;\n-    run_server(\n-        ra_lsp_server::server_capabilities(),\n-        receiver,\n-        sender,\n-        |params, r, s| {\n-            let root = params\n-                .root_uri\n-                .and_then(|it| it.to_file_path().ok())\n-                .unwrap_or(cwd);\n-            let supports_decorations = params\n-                .initialization_options\n-                .and_then(|v| InitializationOptions::deserialize(v).ok())\n-                .and_then(|it| it.publish_decorations)\n-                == Some(true);\n-            ra_lsp_server::main_loop(false, root, supports_decorations, r, s)\n-        },\n-    )?;\n+    run_server(ra_lsp_server::server_capabilities(), receiver, sender, |params, r, s| {\n+        let root = params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n+        let supports_decorations = params\n+            .initialization_options\n+            .and_then(|v| InitializationOptions::deserialize(v).ok())\n+            .and_then(|it| it.publish_decorations)\n+            == Some(true);\n+        ra_lsp_server::main_loop(false, root, supports_decorations, r, s)\n+    })?;\n     log::info!(\"shutting down IO...\");\n     threads.join()?;\n     log::info!(\"... IO is down\");"}, {"sha": "a5129985182361c0428aa2ad2f33682964932fdd", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 13, "deletions": 42, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -25,10 +25,7 @@ use crate::{\n };\n \n #[derive(Debug, Fail)]\n-#[fail(\n-    display = \"Language Server request failed with {}. ({})\",\n-    code, message\n-)]\n+#[fail(display = \"Language Server request failed with {}. ({})\", code, message)]\n pub struct LspError {\n     pub code: i32,\n     pub message: String,\n@@ -69,9 +66,7 @@ pub fn main_loop(\n         }\n     };\n     ws_worker.shutdown();\n-    ws_watcher\n-        .shutdown()\n-        .map_err(|_| format_err!(\"ws watcher died\"))?;\n+    ws_watcher.shutdown().map_err(|_| format_err!(\"ws watcher died\"))?;\n     let mut state = ServerWorldState::new(ws_root.clone(), workspaces);\n \n     log::info!(\"server initialized, serving requests\");\n@@ -92,9 +87,7 @@ pub fn main_loop(\n     );\n \n     log::info!(\"waiting for tasks to finish...\");\n-    task_receiver\n-        .into_iter()\n-        .for_each(|task| on_task(task, msg_sender, &mut pending_requests));\n+    task_receiver.into_iter().for_each(|task| on_task(task, msg_sender, &mut pending_requests));\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     drop(pool);\n@@ -119,9 +112,7 @@ enum Event {\n impl fmt::Debug for Event {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let debug_verbose_not = |not: &RawNotification, f: &mut fmt::Formatter| {\n-            f.debug_struct(\"RawNotification\")\n-                .field(\"method\", &not.method)\n-                .finish()\n+            f.debug_struct(\"RawNotification\").field(\"method\", &not.method).finish()\n         };\n \n         match self {\n@@ -287,13 +278,7 @@ fn on_request(\n     sender: &Sender<Task>,\n     req: RawRequest,\n ) -> Result<Option<RawRequest>> {\n-    let mut pool_dispatcher = PoolDispatcher {\n-        req: Some(req),\n-        res: None,\n-        pool,\n-        world,\n-        sender,\n-    };\n+    let mut pool_dispatcher = PoolDispatcher { req: Some(req), res: None, pool, world, sender };\n     let req = pool_dispatcher\n         .on::<req::AnalyzerStatus>(handlers::handle_analyzer_status)?\n         .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n@@ -362,13 +347,9 @@ fn on_notification(\n     let not = match not.cast::<req::DidOpenTextDocument>() {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n-            let path = uri\n-                .to_file_path()\n-                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            if let Some(file_id) = state\n-                .vfs\n-                .write()\n-                .add_file_overlay(&path, params.text_document.text)\n+            let path = uri.to_file_path().map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            if let Some(file_id) =\n+                state.vfs.write().add_file_overlay(&path, params.text_document.text)\n             {\n                 subs.add_sub(FileId(file_id.0.into()));\n             }\n@@ -379,14 +360,9 @@ fn on_notification(\n     let not = match not.cast::<req::DidChangeTextDocument>() {\n         Ok(mut params) => {\n             let uri = params.text_document.uri;\n-            let path = uri\n-                .to_file_path()\n-                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let text = params\n-                .content_changes\n-                .pop()\n-                .ok_or_else(|| format_err!(\"empty changes\"))?\n-                .text;\n+            let path = uri.to_file_path().map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            let text =\n+                params.content_changes.pop().ok_or_else(|| format_err!(\"empty changes\"))?.text;\n             state.vfs.write().change_file_overlay(path.as_path(), text);\n             return Ok(());\n         }\n@@ -395,16 +371,11 @@ fn on_notification(\n     let not = match not.cast::<req::DidCloseTextDocument>() {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n-            let path = uri\n-                .to_file_path()\n-                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            let path = uri.to_file_path().map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n             if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n                 subs.remove_sub(FileId(file_id.0.into()));\n             }\n-            let params = req::PublishDiagnosticsParams {\n-                uri,\n-                diagnostics: Vec::new(),\n-            };\n+            let params = req::PublishDiagnosticsParams { uri, diagnostics: Vec::new() };\n             let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n             msg_sender.send(RawMessage::Notification(not)).unwrap();\n             return Ok(());"}, {"sha": "0cdb39c32f890fd72bc3ad874efd6e44bbd0bca3", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -46,12 +46,7 @@ pub fn handle_extend_selection(\n         .into_iter()\n         .map_conv_with(&line_index)\n         .map(|range| FileRange { file_id, range })\n-        .map(|frange| {\n-            world\n-                .analysis()\n-                .extend_selection(frange)\n-                .map(|it| it.conv_with(&line_index))\n-        })\n+        .map(|frange| world.analysis().extend_selection(frange).map(|it| it.conv_with(&line_index)))\n         .collect::<Cancelable<Vec<_>>>()?;\n     Ok(req::ExtendSelectionResult { selections })\n }\n@@ -67,10 +62,7 @@ pub fn handle_find_matching_brace(\n         .into_iter()\n         .map_conv_with(&line_index)\n         .map(|offset| {\n-            world\n-                .analysis()\n-                .matching_brace(FilePosition { file_id, offset })\n-                .unwrap_or(offset)\n+            world.analysis().matching_brace(FilePosition { file_id, offset }).unwrap_or(offset)\n         })\n         .map_conv_with(&line_index)\n         .collect();\n@@ -171,11 +163,7 @@ pub fn handle_workspace_symbol(\n     let all_symbols = params.query.contains('#');\n     let libs = params.query.contains('*');\n     let query = {\n-        let query: String = params\n-            .query\n-            .chars()\n-            .filter(|&c| c != '#' && c != '*')\n-            .collect();\n+        let query: String = params.query.chars().filter(|&c| c != '#' && c != '*').collect();\n         let mut q = Query::new(query);\n         if !all_symbols {\n             q.only_types();\n@@ -367,10 +355,7 @@ pub fn handle_completion(\n         Some(items) => items,\n     };\n     let line_index = world.analysis().file_line_index(position.file_id);\n-    let items = items\n-        .into_iter()\n-        .map(|item| item.conv_with(&line_index))\n-        .collect();\n+    let items = items.into_iter().map(|item| item.conv_with(&line_index)).collect();\n \n     Ok(Some(req::CompletionResponse::Array(items)))\n }\n@@ -496,9 +481,8 @@ pub fn handle_rename(world: ServerWorld, params: RenameParams) -> Result<Option<\n         .into());\n     }\n \n-    let optional_change = world\n-        .analysis()\n-        .rename(FilePosition { file_id, offset }, &*params.new_name)?;\n+    let optional_change =\n+        world.analysis().rename(FilePosition { file_id, offset }, &*params.new_name)?;\n     let change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it,\n@@ -517,14 +501,10 @@ pub fn handle_references(\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n \n-    let refs = world\n-        .analysis()\n-        .find_all_refs(FilePosition { file_id, offset })?;\n+    let refs = world.analysis().find_all_refs(FilePosition { file_id, offset })?;\n \n     Ok(Some(\n-        refs.into_iter()\n-            .filter_map(|r| to_location(r.0, r.1, &world, &line_index).ok())\n-            .collect(),\n+        refs.into_iter().filter_map(|r| to_location(r.0, r.1, &world, &line_index).ok()).collect(),\n     ))\n }\n \n@@ -540,9 +520,7 @@ pub fn handle_formatting(\n \n     use std::process;\n     let mut rustfmt = process::Command::new(\"rustfmt\");\n-    rustfmt\n-        .stdin(process::Stdio::piped())\n-        .stdout(process::Stdio::piped());\n+    rustfmt.stdin(process::Stdio::piped()).stdout(process::Stdio::piped());\n \n     if let Ok(path) = params.text_document.uri.to_file_path() {\n         if let Some(parent) = path.parent() {\n@@ -582,10 +560,7 @@ pub fn handle_code_action(\n     let line_index = world.analysis().file_line_index(file_id);\n     let range = params.range.conv_with(&line_index);\n \n-    let assists = world\n-        .analysis()\n-        .assists(FileRange { file_id, range })?\n-        .into_iter();\n+    let assists = world.analysis().assists(FileRange { file_id, range })?.into_iter();\n     let fixes = world\n         .analysis()\n         .diagnostics(file_id)?\n@@ -720,18 +695,11 @@ pub fn handle_code_lens_resolve(world: ServerWorld, code_lens: CodeLens) -> Resu\n                     to_value(locations).unwrap(),\n                 ]),\n             };\n-            Ok(CodeLens {\n-                range: code_lens.range,\n-                command: Some(cmd),\n-                data: None,\n-            })\n+            Ok(CodeLens { range: code_lens.range, command: Some(cmd), data: None })\n         }\n         None => Ok(CodeLens {\n             range: code_lens.range,\n-            command: Some(Command {\n-                title: \"Error\".into(),\n-                ..Default::default()\n-            }),\n+            command: Some(Command { title: \"Error\".into(), ..Default::default() }),\n             data: None,\n         }),\n     }\n@@ -744,16 +712,11 @@ pub fn handle_document_highlight(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n \n-    let refs = world\n-        .analysis()\n-        .find_all_refs(params.try_conv_with(&world)?)?;\n+    let refs = world.analysis().find_all_refs(params.try_conv_with(&world)?)?;\n \n     Ok(Some(\n         refs.into_iter()\n-            .map(|r| DocumentHighlight {\n-                range: r.1.conv_with(&line_index),\n-                kind: None,\n-            })\n+            .map(|r| DocumentHighlight { range: r.1.conv_with(&line_index), kind: None })\n             .collect(),\n     ))\n }\n@@ -785,10 +748,7 @@ pub fn publish_decorations(\n     file_id: FileId,\n ) -> Result<req::PublishDecorationsParams> {\n     let uri = world.file_id_to_uri(file_id)?;\n-    Ok(req::PublishDecorationsParams {\n-        uri,\n-        decorations: highlight(&world, file_id)?,\n-    })\n+    Ok(req::PublishDecorationsParams { uri, decorations: highlight(&world, file_id)? })\n }\n \n fn highlight(world: &ServerWorld, file_id: FileId) -> Result<Vec<Decoration>> {\n@@ -797,10 +757,7 @@ fn highlight(world: &ServerWorld, file_id: FileId) -> Result<Vec<Decoration>> {\n         .analysis()\n         .highlight(file_id)?\n         .into_iter()\n-        .map(|h| Decoration {\n-            range: h.range.conv_with(&line_index),\n-            tag: h.tag,\n-        })\n+        .map(|h| Decoration { range: h.range.conv_with(&line_index), tag: h.tag })\n         .collect();\n     Ok(res)\n }"}, {"sha": "11bd952d978bee36f0b42d3cf717c23153f2532c", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,9 +7,7 @@ pub struct Subscriptions {\n \n impl Subscriptions {\n     pub fn new() -> Subscriptions {\n-        Subscriptions {\n-            subs: FxHashSet::default(),\n-        }\n+        Subscriptions { subs: FxHashSet::default() }\n     }\n     pub fn add_sub(&mut self, file_id: FileId) {\n         self.subs.insert(file_id);"}, {"sha": "3b76389d23a05eae59299ae438355f7a1dde4874", "filename": "crates/ra_lsp_server/src/project_model/cargo_workspace.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -118,14 +118,11 @@ impl Target {\n impl CargoWorkspace {\n     pub fn from_cargo_metadata(cargo_toml: &Path) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n-        meta.manifest_path(cargo_toml)\n-            .features(CargoOpt::AllFeatures);\n+        meta.manifest_path(cargo_toml).features(CargoOpt::AllFeatures);\n         if let Some(parent) = cargo_toml.parent() {\n             meta.current_dir(parent);\n         }\n-        let meta = meta\n-            .exec()\n-            .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n+        let meta = meta.exec().map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n         let mut targets = Arena::default();\n@@ -157,10 +154,8 @@ impl CargoWorkspace {\n         for node in resolve.nodes {\n             let source = pkg_by_id[&node.id];\n             for dep_node in node.deps {\n-                let dep = PackageDependency {\n-                    name: dep_node.name.into(),\n-                    pkg: pkg_by_id[&dep_node.pkg],\n-                };\n+                let dep =\n+                    PackageDependency { name: dep_node.name.into(), pkg: pkg_by_id[&dep_node.pkg] };\n                 packages[source].dependencies.push(dep);\n             }\n         }\n@@ -171,8 +166,6 @@ impl CargoWorkspace {\n         self.packages.iter().map(|(id, _pkg)| id)\n     }\n     pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n-        self.packages()\n-            .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))\n-            .next()\n+        self.packages().filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root)).next()\n     }\n }"}, {"sha": "49210ac7aafb9d9571b6a5907bcb8e41021113e5", "filename": "crates/ra_lsp_server/src/project_model/sysroot.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -53,9 +53,7 @@ impl Sysroot {\n             );\n         }\n \n-        let mut sysroot = Sysroot {\n-            crates: Arena::default(),\n-        };\n+        let mut sysroot = Sysroot { crates: Arena::default() };\n         for name in SYSROOT_CRATES.trim().lines() {\n             let root = src.join(format!(\"lib{}\", name)).join(\"lib.rs\");\n             if root.exists() {\n@@ -77,10 +75,7 @@ impl Sysroot {\n     }\n \n     fn by_name(&self, name: &str) -> Option<SysrootCrate> {\n-        self.crates\n-            .iter()\n-            .find(|(_id, data)| data.name == name)\n-            .map(|(id, _data)| id)\n+        self.crates.iter().find(|(_id, data)| data.name == name).map(|(id, _data)| id)\n     }\n }\n "}, {"sha": "02f2a37a8c56d39687044e6a5fc902cb492d042f", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -80,10 +80,7 @@ impl ServerWorldState {\n                 }\n             }\n \n-            let libstd = ws\n-                .sysroot\n-                .std()\n-                .and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n+            let libstd = ws.sysroot.std().and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n \n             let mut pkg_to_lib_crate = FxHashMap::default();\n             let mut pkg_crates = FxHashMap::default();\n@@ -99,10 +96,7 @@ impl ServerWorldState {\n                             lib_tgt = Some(crate_id);\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n                         }\n-                        pkg_crates\n-                            .entry(pkg)\n-                            .or_insert_with(Vec::new)\n-                            .push(crate_id);\n+                        pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                     }\n                 }\n \n@@ -192,18 +186,8 @@ impl ServerWorldState {\n                         libs.push((SourceRootId(root.0.into()), files));\n                     }\n                 }\n-                VfsChange::AddFile {\n-                    root,\n-                    file,\n-                    path,\n-                    text,\n-                } => {\n-                    change.add_file(\n-                        SourceRootId(root.0.into()),\n-                        FileId(file.0.into()),\n-                        path,\n-                        text,\n-                    );\n+                VfsChange::AddFile { root, file, path, text } => {\n+                    change.add_file(SourceRootId(root.0.into()), FileId(file.0.into()), path, text);\n                 }\n                 VfsChange::RemoveFile { root, file, path } => {\n                     change.remove_file(SourceRootId(root.0.into()), FileId(file.0.into()), path)\n@@ -247,9 +231,7 @@ impl ServerWorld {\n     }\n \n     pub fn uri_to_file_id(&self, uri: &Url) -> Result<FileId> {\n-        let path = uri\n-            .to_file_path()\n-            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+        let path = uri.to_file_path().map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n         let file = self\n             .vfs\n             .read()"}, {"sha": "e49c871691efb1ec981d5b3ae5c2198343c0bd9d", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -55,10 +55,7 @@ fn foo() {\n     );\n     server.wait_for_feedback(\"workspace loaded\");\n     server.request::<Runnables>(\n-        RunnablesParams {\n-            text_document: server.doc_id(\"lib.rs\"),\n-            position: None,\n-        },\n+        RunnablesParams { text_document: server.doc_id(\"lib.rs\"), position: None },\n         json!([\n           {\n             \"args\": [ \"test\", \"--\", \"foo\", \"--nocapture\" ],\n@@ -220,10 +217,7 @@ fn main() {}\n \"#,\n     );\n     server.wait_for_feedback(\"workspace loaded\");\n-    let empty_context = || CodeActionContext {\n-        diagnostics: Vec::new(),\n-        only: None,\n-    };\n+    let empty_context = || CodeActionContext { diagnostics: Vec::new(), only: None };\n     server.request::<CodeActionRequest>(\n         CodeActionParams {\n             text_document: server.doc_id(\"src/lib.rs\"),"}, {"sha": "eee85f8c8968b22091eea21c85553c8bf8725050", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -83,9 +83,7 @@ impl Server {\n \n     pub fn doc_id(&self, rel_path: &str) -> TextDocumentIdentifier {\n         let path = self.dir.path().join(rel_path);\n-        TextDocumentIdentifier {\n-            uri: Url::from_file_path(path).unwrap(),\n-        }\n+        TextDocumentIdentifier { uri: Url::from_file_path(path).unwrap() }\n     }\n \n     pub fn request<R>(&self, params: R::Params, expected_resp: Value)\n@@ -119,11 +117,7 @@ impl Server {\n     }\n     fn send_request_(&self, r: RawRequest) -> Value {\n         let id = r.id;\n-        self.worker\n-            .as_ref()\n-            .unwrap()\n-            .send(RawMessage::Request(r))\n-            .unwrap();\n+        self.worker.as_ref().unwrap().send(RawMessage::Request(r)).unwrap();\n         while let Some(msg) = self.recv() {\n             match msg {\n                 RawMessage::Request(req) => panic!(\"unexpected request: {:?}\", req),\n@@ -169,11 +163,7 @@ impl Server {\n         })\n     }\n     fn send_notification(&self, not: RawNotification) {\n-        self.worker\n-            .as_ref()\n-            .unwrap()\n-            .send(RawMessage::Notification(not))\n-            .unwrap();\n+        self.worker.as_ref().unwrap().send(RawMessage::Notification(not)).unwrap();\n     }\n }\n "}, {"sha": "b0983783147ba2099f8f59d7949fad23031c7b52", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -137,18 +137,12 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \"#;\n \n         let source_file = ast::SourceFile::parse(macro_definition);\n-        let macro_definition = source_file\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::MacroCall::cast)\n-            .unwrap();\n+        let macro_definition =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let source_file = ast::SourceFile::parse(macro_invocation);\n-        let macro_invocation = source_file\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::MacroCall::cast)\n-            .unwrap();\n+        let macro_invocation =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let definition_tt = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n         let invocation_tt = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n@@ -163,23 +157,17 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \n     fn create_rules(macro_definition: &str) -> MacroRules {\n         let source_file = ast::SourceFile::parse(macro_definition);\n-        let macro_definition = source_file\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::MacroCall::cast)\n-            .unwrap();\n+        let macro_definition =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let definition_tt = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n     fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n         let source_file = ast::SourceFile::parse(invocation);\n-        let macro_invocation = source_file\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::MacroCall::cast)\n-            .unwrap();\n+        let macro_invocation =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let invocation_tt = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n "}, {"sha": "31531f4c9ee8c00ba2de76210fdf18c913850b56", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -133,11 +133,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings>\n                 }\n                 _ => return None,\n             },\n-            crate::TokenTree::Repeat(crate::Repeat {\n-                subtree,\n-                kind: _,\n-                separator,\n-            }) => {\n+            crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n                 while let Some(nested) = match_lhs(subtree, input) {\n                     res.push_nested(nested)?;\n                     if let Some(separator) = *separator {\n@@ -166,10 +162,7 @@ fn expand_subtree(\n         .map(|it| expand_tt(it, bindings, nesting))\n         .collect::<Option<Vec<_>>>()?;\n \n-    Some(tt::Subtree {\n-        token_trees,\n-        delimiter: template.delimiter,\n-    })\n+    Some(tt::Subtree { token_trees, delimiter: template.delimiter })\n }\n \n fn expand_tt(\n@@ -188,23 +181,15 @@ fn expand_tt(\n                 token_trees.push(t.into())\n             }\n             nesting.pop().unwrap();\n-            tt::Subtree {\n-                token_trees,\n-                delimiter: tt::Delimiter::None,\n-            }\n-            .into()\n+            tt::Subtree { token_trees, delimiter: tt::Delimiter::None }.into()\n         }\n         crate::TokenTree::Leaf(leaf) => match leaf {\n-            crate::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n-                text: ident.text.clone(),\n-            })\n-            .into(),\n+            crate::Leaf::Ident(ident) => {\n+                tt::Leaf::from(tt::Ident { text: ident.text.clone() }).into()\n+            }\n             crate::Leaf::Punct(punct) => tt::Leaf::from(punct.clone()).into(),\n             crate::Leaf::Var(v) => bindings.get(&v.text, nesting)?.clone(),\n-            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal {\n-                text: l.text.clone(),\n-            })\n-            .into(),\n+            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };\n     Some(res)"}, {"sha": "60e566ed2370708675892ef0afc26cdbcb6f65f1", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -52,10 +52,7 @@ fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n         };\n         token_trees.push(child);\n     }\n-    Some(crate::Subtree {\n-        token_trees,\n-        delimiter: tt.delimiter,\n-    })\n+    Some(crate::Subtree { token_trees, delimiter: tt.delimiter })\n }\n \n fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n@@ -92,9 +89,5 @@ fn parse_repeat(p: &mut TtCursor) -> Option<crate::Repeat> {\n         _ => return None,\n     };\n     p.bump();\n-    Some(crate::Repeat {\n-        subtree,\n-        kind,\n-        separator,\n-    })\n+    Some(crate::Repeat { subtree, kind, separator })\n }"}, {"sha": "9a2eceabac7abea8b2da22961c48d3d8e037d625", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -23,23 +23,14 @@ fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n             for char in child.leaf_text().unwrap().chars() {\n                 if let Some(char) = prev {\n                     token_trees.push(\n-                        tt::Leaf::from(tt::Punct {\n-                            char,\n-                            spacing: tt::Spacing::Joint,\n-                        })\n-                        .into(),\n+                        tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Joint }).into(),\n                     );\n                 }\n                 prev = Some(char)\n             }\n             if let Some(char) = prev {\n-                token_trees.push(\n-                    tt::Leaf::from(tt::Punct {\n-                        char,\n-                        spacing: tt::Spacing::Alone,\n-                    })\n-                    .into(),\n-                );\n+                token_trees\n+                    .push(tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Alone }).into());\n             }\n         } else {\n             let child: tt::TokenTree = if child.kind() == TOKEN_TREE {\n@@ -48,20 +39,14 @@ fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n                 let text = child.leaf_text().unwrap().clone();\n                 tt::Leaf::from(tt::Ident { text }).into()\n             } else if child.kind().is_literal() {\n-                tt::Leaf::from(tt::Literal {\n-                    text: child.leaf_text().unwrap().clone(),\n-                })\n-                .into()\n+                tt::Leaf::from(tt::Literal { text: child.leaf_text().unwrap().clone() }).into()\n             } else {\n                 return None;\n             };\n             token_trees.push(child)\n         }\n     }\n \n-    let res = tt::Subtree {\n-        delimiter,\n-        token_trees,\n-    };\n+    let res = tt::Subtree { delimiter, token_trees };\n     Some(res)\n }"}, {"sha": "81a99228fd2d0a325b5d3b172c271a1b1026c04a", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,10 +7,7 @@ pub fn visitor<'a, T>() -> impl Visitor<'a, Output = T> {\n }\n \n pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output = T, Ctx = C> {\n-    EmptyVisitorCtx {\n-        ph: PhantomData,\n-        ctx,\n-    }\n+    EmptyVisitorCtx { ph: PhantomData, ctx }\n }\n \n pub trait Visitor<'a>: Sized {\n@@ -21,11 +18,7 @@ pub trait Visitor<'a>: Sized {\n         N: AstNode + 'a,\n         F: FnOnce(&'a N) -> Self::Output,\n     {\n-        Vis {\n-            inner: self,\n-            f,\n-            ph: PhantomData,\n-        }\n+        Vis { inner: self, f, ph: PhantomData }\n     }\n }\n \n@@ -38,11 +31,7 @@ pub trait VisitorCtx<'a>: Sized {\n         N: AstNode + 'a,\n         F: FnOnce(&'a N, Self::Ctx) -> Self::Output,\n     {\n-        VisCtx {\n-            inner: self,\n-            f,\n-            ph: PhantomData,\n-        }\n+        VisCtx { inner: self, f, ph: PhantomData }\n     }\n }\n "}, {"sha": "cf5cfecc27ac11a07367037ae45d6490042503c0", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -127,16 +127,12 @@ pub trait DocCommentsOwner: AstNode {\n                 let line = comment.text().as_str();\n \n                 // Determine if the prefix or prefix + 1 char is stripped\n-                let pos = if line\n-                    .chars()\n-                    .nth(prefix_len)\n-                    .map(|c| c.is_whitespace())\n-                    .unwrap_or(false)\n-                {\n-                    prefix_len + 1\n-                } else {\n-                    prefix_len\n-                };\n+                let pos =\n+                    if line.chars().nth(prefix_len).map(|c| c.is_whitespace()).unwrap_or(false) {\n+                        prefix_len + 1\n+                    } else {\n+                        prefix_len\n+                    };\n \n                 line[pos..].to_owned()\n             })\n@@ -357,10 +353,7 @@ pub enum PathSegmentKind<'a> {\n \n impl PathSegment {\n     pub fn parent_path(&self) -> &Path {\n-        self.syntax()\n-            .parent()\n-            .and_then(Path::cast)\n-            .expect(\"segments are always nested in paths\")\n+        self.syntax().parent().and_then(Path::cast).expect(\"segments are always nested in paths\")\n     }\n \n     pub fn kind(&self) -> Option<PathSegmentKind> {\n@@ -428,10 +421,7 @@ pub struct AstChildren<'a, N> {\n \n impl<'a, N> AstChildren<'a, N> {\n     fn new(parent: &'a SyntaxNode) -> Self {\n-        AstChildren {\n-            inner: parent.children(),\n-            ph: PhantomData,\n-        }\n+        AstChildren { inner: parent.children(), ph: PhantomData }\n     }\n }\n \n@@ -658,11 +648,7 @@ impl SelfParam {\n         let borrowed = self.syntax().children().any(|n| n.kind() == AMP);\n         if borrowed {\n             // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children()\n-                .skip_while(|n| n.kind() != AMP)\n-                .any(|n| n.kind() == MUT_KW)\n+            if self.syntax().children().skip_while(|n| n.kind() != AMP).any(|n| n.kind() == MUT_KW)\n             {\n                 SelfParamFlavor::MutRef\n             } else {\n@@ -769,8 +755,5 @@ fn test_doc_comment_preserves_indents() {\n         \"#,\n     );\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\n-        \"doc1\\n```\\nfn foo() {\\n    // ...\\n}\\n```\",\n-        module.doc_comment_text().unwrap()\n-    );\n+    assert_eq!(\"doc1\\n```\\nfn foo() {\\n    // ...\\n}\\n```\", module.doc_comment_text().unwrap());\n }"}, {"sha": "28fcb1f7d34a8901e22af36b33a61c20b54b8da1", "filename": "crates/ra_syntax/src/grammar/expressions.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,26 +7,17 @@ use super::*;\n const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n-    let r = Restrictions {\n-        forbid_structs: false,\n-        prefer_stmt: false,\n-    };\n+    let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n     expr_bp(p, r, 1)\n }\n \n pub(super) fn expr_stmt(p: &mut Parser) -> BlockLike {\n-    let r = Restrictions {\n-        forbid_structs: false,\n-        prefer_stmt: true,\n-    };\n+    let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n     expr_bp(p, r, 1)\n }\n \n fn expr_no_struct(p: &mut Parser) {\n-    let r = Restrictions {\n-        forbid_structs: true,\n-        prefer_stmt: false,\n-    };\n+    let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n     expr_bp(p, r, 1);\n }\n "}, {"sha": "27ba87657e6dd952ffca59cbaf3566a899faf15a", "filename": "crates/ra_syntax/src/grammar/expressions/atom.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -141,14 +141,7 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n         }\n     }\n     p.expect(R_PAREN);\n-    m.complete(\n-        p,\n-        if saw_expr && !saw_comma {\n-            PAREN_EXPR\n-        } else {\n-            TUPLE_EXPR\n-        },\n-    )\n+    m.complete(p, if saw_expr && !saw_comma { PAREN_EXPR } else { TUPLE_EXPR })\n }\n \n // test array_expr"}, {"sha": "a61f260cf19e8ba02a1d18ed3f99532aaea5e8ff", "filename": "crates/ra_syntax/src/grammar/items.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -155,11 +155,7 @@ pub(super) fn maybe_item(p: &mut Parser, flavor: ItemFlavor) -> MaybeItem {\n             IMPL_BLOCK\n         }\n         _ => {\n-            return if has_mods {\n-                MaybeItem::Modifiers\n-            } else {\n-                MaybeItem::None\n-            };\n+            return if has_mods { MaybeItem::Modifiers } else { MaybeItem::None };\n         }\n     };\n "}, {"sha": "185386569aa01014c70627823de2fa9cddfb965e", "filename": "crates/ra_syntax/src/grammar/params.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -36,11 +36,7 @@ impl Flavor {\n }\n \n fn list_(p: &mut Parser, flavor: Flavor) {\n-    let (bra, ket) = if flavor.type_required() {\n-        (L_PAREN, R_PAREN)\n-    } else {\n-        (PIPE, PIPE)\n-    };\n+    let (bra, ket) = if flavor.type_required() { (L_PAREN, R_PAREN) } else { (PIPE, PIPE) };\n     assert!(p.at(bra));\n     let m = p.start();\n     p.bump();"}, {"sha": "f3f400ae0cc6b1fe670b8a7c2aaebb5a06d9d589", "filename": "crates/ra_syntax/src/grammar/patterns.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -2,9 +2,7 @@ use super::*;\n \n pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST\n     .union(paths::PATH_FIRST)\n-    .union(token_set![\n-        REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE\n-    ]);\n+    .union(token_set![REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE]);\n \n pub(super) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET)"}, {"sha": "c341c4176bbe85a74634fa44398383a9b80401ae", "filename": "crates/ra_syntax/src/lexer/ptr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -11,10 +11,7 @@ pub(crate) struct Ptr<'s> {\n impl<'s> Ptr<'s> {\n     /// Creates a new `Ptr` from a string.\n     pub fn new(text: &'s str) -> Ptr<'s> {\n-        Ptr {\n-            text,\n-            len: 0.into(),\n-        }\n+        Ptr { text, len: 0.into() }\n     }\n \n     /// Gets the length of the remaining string."}, {"sha": "088b2f5d70d06d06f6f0795052e72925de940de7", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -11,11 +11,7 @@\n //!   [rfc#2256]: <https://github.com/rust-lang/rfcs/pull/2256>\n //!   [RFC.md]: <https://github.com/matklad/libsyntax2/blob/master/docs/RFC.md>\n \n-#![forbid(\n-    missing_debug_implementations,\n-    unconditional_recursion,\n-    future_incompatible\n-)]\n+#![forbid(missing_debug_implementations, unconditional_recursion, future_incompatible)]\n #![deny(bad_style, missing_docs)]\n #![allow(missing_docs)]\n //#![warn(unreachable_pub)] // rust-lang/rust#47816\n@@ -70,8 +66,7 @@ impl SourceFile {\n     }\n \n     pub fn reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n-        self.incremental_reparse(edit)\n-            .unwrap_or_else(|| self.full_reparse(edit))\n+        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n     }\n \n     pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreeArc<SourceFile>> {"}, {"sha": "504df753e41474d28585c0004f0fd340904efb1f", "filename": "crates/ra_syntax/src/parser_api.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -136,10 +136,7 @@ pub(crate) struct Marker {\n \n impl Marker {\n     fn new(pos: u32) -> Marker {\n-        Marker {\n-            pos,\n-            bomb: DropBomb::new(\"Marker must be either completed or abandoned\"),\n-        }\n+        Marker { pos, bomb: DropBomb::new(\"Marker must be either completed or abandoned\") }\n     }\n \n     /// Finishes the syntax tree node and assigns `kind` to it,"}, {"sha": "f255dc23b1883ce7373a35c7bc544d2420c7522a", "filename": "crates/ra_syntax/src/parser_impl.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -54,9 +54,7 @@ pub(crate) fn parse_with<S: Sink>(\n         parser(&mut parser_api);\n         parser_api.0.into_events()\n     };\n-    EventProcessor::new(sink, text, tokens, &mut events)\n-        .process()\n-        .finish()\n+    EventProcessor::new(sink, text, tokens, &mut events).process().finish()\n }\n \n /// Implementation details of `Parser`, extracted\n@@ -160,17 +158,13 @@ impl<'t> ParserImpl<'t> {\n \n     /// Append one Error event to the back of events.\n     pub(super) fn error(&mut self, msg: String) {\n-        self.push_event(Event::Error {\n-            msg: ParseError(msg),\n-        })\n+        self.push_event(Event::Error { msg: ParseError(msg) })\n     }\n \n     /// Complete an event with appending a `Finish` event.\n     pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n         match self.events[pos as usize] {\n-            Event::Start {\n-                kind: ref mut slot, ..\n-            } => {\n+            Event::Start { kind: ref mut slot, .. } => {\n                 *slot = kind;\n             }\n             _ => unreachable!(),\n@@ -183,10 +177,7 @@ impl<'t> ParserImpl<'t> {\n         let idx = pos as usize;\n         if idx == self.events.len() - 1 {\n             match self.events.pop() {\n-                Some(Event::Start {\n-                    kind: TOMBSTONE,\n-                    forward_parent: None,\n-                }) => (),\n+                Some(Event::Start { kind: TOMBSTONE, forward_parent: None }) => (),\n                 _ => unreachable!(),\n             }\n         }\n@@ -196,10 +187,7 @@ impl<'t> ParserImpl<'t> {\n     pub(super) fn precede(&mut self, pos: u32) -> u32 {\n         let new_pos = self.start();\n         match self.events[pos as usize] {\n-            Event::Start {\n-                ref mut forward_parent,\n-                ..\n-            } => {\n+            Event::Start { ref mut forward_parent, .. } => {\n                 *forward_parent = Some(new_pos - pos);\n             }\n             _ => unreachable!(),"}, {"sha": "677876ab5dfd55eea64c1c1e6d586fcc02ec9f98", "filename": "crates/ra_syntax/src/parser_impl/event.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -86,10 +86,7 @@ pub(crate) enum Event {\n \n impl Event {\n     pub(crate) fn tombstone() -> Self {\n-        Event::Start {\n-            kind: TOMBSTONE,\n-            forward_parent: None,\n-        }\n+        Event::Start { kind: TOMBSTONE, forward_parent: None }\n     }\n }\n \n@@ -109,14 +106,7 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         tokens: &'a [Token],\n         events: &'a mut [Event],\n     ) -> EventProcessor<'a, S> {\n-        EventProcessor {\n-            sink,\n-            text_pos: 0.into(),\n-            text,\n-            token_pos: 0,\n-            tokens,\n-            events,\n-        }\n+        EventProcessor { sink, text_pos: 0.into(), text, token_pos: 0, tokens, events }\n     }\n \n     /// Generate the syntax tree with the control of events.\n@@ -125,14 +115,9 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n \n         for i in 0..self.events.len() {\n             match mem::replace(&mut self.events[i], Event::tombstone()) {\n-                Event::Start {\n-                    kind: TOMBSTONE, ..\n-                } => (),\n+                Event::Start { kind: TOMBSTONE, .. } => (),\n \n-                Event::Start {\n-                    kind,\n-                    forward_parent,\n-                } => {\n+                Event::Start { kind, forward_parent } => {\n                     // For events[A, B, C], B is A's forward_parent, C is B's forward_parent,\n                     // in the normal control flow, the parent-child relation: `A -> B -> C`,\n                     // while with the magic forward_parent, it writes: `C <- B <- A`.\n@@ -145,10 +130,7 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                         idx += fwd as usize;\n                         // append `A`'s forward_parent `B`\n                         fp = match mem::replace(&mut self.events[idx], Event::tombstone()) {\n-                            Event::Start {\n-                                kind,\n-                                forward_parent,\n-                            } => {\n+                            Event::Start { kind, forward_parent } => {\n                                 forward_parents.push(kind);\n                                 forward_parent\n                             }\n@@ -174,10 +156,9 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                         .sum::<TextUnit>();\n                     self.leaf(kind, len, n_raw_tokens);\n                 }\n-                Event::Error { msg } => self.sink.error(SyntaxError::new(\n-                    SyntaxErrorKind::ParseError(msg),\n-                    self.text_pos,\n-                )),\n+                Event::Error { msg } => self\n+                    .sink\n+                    .error(SyntaxError::new(SyntaxErrorKind::ParseError(msg), self.text_pos)),\n             }\n         }\n         self.sink\n@@ -189,10 +170,8 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n             self.sink.start_branch(kind);\n             return;\n         }\n-        let n_trivias = self.tokens[self.token_pos..]\n-            .iter()\n-            .take_while(|it| it.kind.is_trivia())\n-            .count();\n+        let n_trivias =\n+            self.tokens[self.token_pos..].iter().take_while(|it| it.kind.is_trivia()).count();\n         let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n         let mut trivia_end =\n             self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextUnit>();"}, {"sha": "616a26fdc83d8bb88ad9df8f52df665f991914fe", "filename": "crates/ra_syntax/src/parser_impl/input.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -36,11 +36,7 @@ impl<'t> ParserInput<'t> {\n             len += token.len;\n         }\n \n-        ParserInput {\n-            text,\n-            start_offsets,\n-            tokens,\n-        }\n+        ParserInput { text, start_offsets, tokens }\n     }\n \n     /// Get the syntax kind of token at given input position."}, {"sha": "aae590cb62a8f65a98eca5342ccc10e32e69a68c", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -15,16 +15,12 @@ pub struct SyntaxNodePtr {\n \n impl SyntaxNodePtr {\n     pub fn new(node: &SyntaxNode) -> SyntaxNodePtr {\n-        SyntaxNodePtr {\n-            range: node.range(),\n-            kind: node.kind(),\n-        }\n+        SyntaxNodePtr { range: node.range(), kind: node.kind() }\n     }\n \n     pub fn to_node(self, source_file: &SourceFile) -> &SyntaxNode {\n         generate(Some(source_file.syntax()), |&node| {\n-            node.children()\n-                .find(|it| self.range.is_subrange(&it.range()))\n+            node.children().find(|it| self.range.is_subrange(&it.range()))\n         })\n         .find(|it| it.range() == self.range && it.kind() == self.kind)\n         .unwrap_or_else(|| panic!(\"can't resolve local ptr to SyntaxNode: {:?}\", self))\n@@ -55,10 +51,7 @@ impl<N: AstNode> Clone for AstPtr<N> {\n \n impl<N: AstNode> AstPtr<N> {\n     pub fn new(node: &N) -> AstPtr<N> {\n-        AstPtr {\n-            raw: SyntaxNodePtr::new(node.syntax()),\n-            _ty: PhantomData,\n-        }\n+        AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }\n     }\n \n     pub fn to_node(self, source_file: &SourceFile) -> &N {\n@@ -76,11 +69,7 @@ fn test_local_syntax_ptr() {\n     use crate::{ast, AstNode};\n \n     let file = SourceFile::parse(\"struct Foo { f: u32, }\");\n-    let field = file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::NamedFieldDef::cast)\n-        .unwrap();\n+    let field = file.syntax().descendants().find_map(ast::NamedFieldDef::cast).unwrap();\n     let ptr = SyntaxNodePtr::new(field.syntax());\n     let field_syntax = ptr.to_node(&file);\n     assert_eq!(field.syntax(), &*field_syntax);"}, {"sha": "c5c609ad54f145dfb6ba310f647d88548d75d989", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -75,10 +75,7 @@ fn is_contextual_kw(text: &str) -> bool {\n type ParseFn = fn(&mut Parser);\n fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxNode, ParseFn)> {\n     let node = algo::find_covering_node(node, range);\n-    return node\n-        .ancestors()\n-        .filter_map(|node| reparser(node).map(|r| (node, r)))\n-        .next();\n+    return node.ancestors().filter_map(|node| reparser(node).map(|r| (node, r))).next();\n \n     fn reparser(node: &SyntaxNode) -> Option<ParseFn> {\n         let res = match node.kind() {\n@@ -169,10 +166,7 @@ mod tests {\n         let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed = {\n             let f = SourceFile::parse(&before);\n-            let edit = AtomTextEdit {\n-                delete: range,\n-                insert: replace_with.to_string(),\n-            };\n+            let edit = AtomTextEdit { delete: range, insert: replace_with.to_string() };\n             let (node, green, new_errors) =\n                 reparser(f.syntax(), &edit).expect(\"cannot incrementally reparse\");\n             let green_root = node.replace_with(green);"}, {"sha": "7469eb903ede5fb21088f112c2f03a7edf0e6375", "filename": "crates/ra_syntax/src/string_lexing/parser.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -24,9 +24,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn advance(&mut self) -> char {\n-        let next = self\n-            .peek()\n-            .expect(\"cannot advance if end of input is reached\");\n+        let next = self.peek().expect(\"cannot advance if end of input is reached\");\n         self.pos += next.len_utf8();\n         next\n     }\n@@ -133,10 +131,7 @@ impl<'a> Parser<'a> {\n             Some(self.parse_escape(start))\n         } else {\n             let end = self.get_pos();\n-            Some(StringComponent::new(\n-                TextRange::from_to(start, end),\n-                CodePoint,\n-            ))\n+            Some(StringComponent::new(TextRange::from_to(start, end), CodePoint))\n         }\n     }\n "}, {"sha": "a4742a0d1f84f1f44b1948e222619843311375dd", "filename": "crates/ra_syntax/src/string_lexing/string.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -120,12 +120,7 @@ mod tests {\n     fn closed_char_component(src: &str) -> StringComponent {\n         let (has_closing_quote, components) = parse(src);\n         assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(\n-            components.len() == 1,\n-            \"Literal: {}\\nComponents: {:#?}\",\n-            src,\n-            components\n-        );\n+        assert!(components.len() == 1, \"Literal: {}\\nComponents: {:#?}\", src, components);\n         components[0].clone()\n     }\n "}, {"sha": "4e77c15b6b723aa83801f2e5a1a909b25b98ee95", "filename": "crates/ra_syntax/src/validation/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -17,8 +17,6 @@ pub(crate) fn validate_block_node(node: &ast::Block, errors: &mut Vec<SyntaxErro\n             _ => {}\n         }\n     }\n-    errors.extend(\n-        node.attrs()\n-            .map(|attr| SyntaxError::new(InvalidBlockAttr, attr.syntax().range())),\n-    )\n+    errors\n+        .extend(node.attrs().map(|attr| SyntaxError::new(InvalidBlockAttr, attr.syntax().range())))\n }"}, {"sha": "d51fabcf96ab05d5f1c2a6c80e13c4828e885dca", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -28,10 +28,7 @@ pub(super) fn validate_byte_node(node: &ast::Byte, errors: &mut Vec<SyntaxError>\n     }\n \n     if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(\n-            InvalidSuffix,\n-            range + literal_range.start(),\n-        ));\n+        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n     }\n \n     if len == 0 {\n@@ -55,10 +52,7 @@ pub(super) fn validate_byte_component(\n         AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n         UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n         CodePoint => {\n-            let c = text\n-                .chars()\n-                .next()\n-                .expect(\"Code points should be one character long\");\n+            let c = text.chars().next().expect(\"Code points should be one character long\");\n \n             // These bytes must always be escaped\n             if c == '\\t' || c == '\\r' || c == '\\n' {\n@@ -93,10 +87,7 @@ fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<Synt\n     } else if text.chars().count() < 4 {\n         errors.push(SyntaxError::new(TooShortByteCodeEscape, range));\n     } else {\n-        assert!(\n-            text.chars().count() == 4,\n-            \"ByteCodeEscape cannot be longer than 4 chars\"\n-        );\n+        assert!(text.chars().count() == 4, \"ByteCodeEscape cannot be longer than 4 chars\");\n \n         if u8::from_str_radix(&text[2..], 16).is_err() {\n             errors.push(SyntaxError::new(MalformedByteCodeEscape, range));\n@@ -115,12 +106,7 @@ mod test {\n \n     fn assert_valid_byte(literal: &str) {\n         let file = build_file(literal);\n-        assert!(\n-            file.errors().len() == 0,\n-            \"Errors for literal '{}': {:?}\",\n-            literal,\n-            file.errors()\n-        );\n+        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n     }\n \n     fn assert_invalid_byte(literal: &str) {\n@@ -193,13 +179,7 @@ mod test {\n \n     #[test]\n     fn test_invalid_unicode_escape() {\n-        let well_formed = [\n-            r\"\\u{FF}\",\n-            r\"\\u{0}\",\n-            r\"\\u{F}\",\n-            r\"\\u{10FFFF}\",\n-            r\"\\u{1_0__FF___FF_____}\",\n-        ];\n+        let well_formed = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n         for c in &well_formed {\n             assert_invalid_byte(c);\n         }"}, {"sha": "7abe8f3303b24416d4e22c4b54884db7cc3df6db", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -34,10 +34,7 @@ pub(crate) fn validate_byte_string_node(node: &ast::ByteString, errors: &mut Vec\n     }\n \n     if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(\n-            InvalidSuffix,\n-            range + literal_range.start(),\n-        ));\n+        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n     }\n }\n \n@@ -53,12 +50,7 @@ mod test {\n \n     fn assert_valid_str(literal: &str) {\n         let file = build_file(literal);\n-        assert!(\n-            file.errors().len() == 0,\n-            \"Errors for literal '{}': {:?}\",\n-            literal,\n-            file.errors()\n-        );\n+        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n     }\n \n     fn assert_invalid_str(literal: &str) {\n@@ -130,13 +122,7 @@ mod test {\n \n     #[test]\n     fn test_invalid_unicode_escape() {\n-        let well_formed = [\n-            r\"\\u{FF}\",\n-            r\"\\u{0}\",\n-            r\"\\u{F}\",\n-            r\"\\u{10FFFF}\",\n-            r\"\\u{1_0__FF___FF_____}\",\n-        ];\n+        let well_formed = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n         for c in &well_formed {\n             assert_invalid_str(c);\n         }"}, {"sha": "012594db33a81f90d3908ad6cd2c1874cc7e7a7b", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -31,10 +31,7 @@ pub(super) fn validate_char_node(node: &ast::Char, errors: &mut Vec<SyntaxError>\n     }\n \n     if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(\n-            InvalidSuffix,\n-            range + literal_range.start(),\n-        ));\n+        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n     }\n \n     if len == 0 {\n@@ -184,12 +181,7 @@ mod test {\n \n     fn assert_valid_char(literal: &str) {\n         let file = build_file(literal);\n-        assert!(\n-            file.errors().len() == 0,\n-            \"Errors for literal '{}': {:?}\",\n-            literal,\n-            file.errors()\n-        );\n+        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n     }\n \n     fn assert_invalid_char(literal: &str) {\n@@ -258,13 +250,7 @@ mod test {\n \n     #[test]\n     fn test_valid_unicode_escape() {\n-        let valid = [\n-            r\"\\u{FF}\",\n-            r\"\\u{0}\",\n-            r\"\\u{F}\",\n-            r\"\\u{10FFFF}\",\n-            r\"\\u{1_0__FF___FF_____}\",\n-        ];\n+        let valid = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n         for c in &valid {\n             assert_valid_char(c);\n         }"}, {"sha": "4fd7fffdf4e6ced91789cdcd95a029bf9a1eedf3", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -29,10 +29,7 @@ pub(crate) fn validate_string_node(node: &ast::String, errors: &mut Vec<SyntaxEr\n     }\n \n     if let Some(range) = components.suffix {\n-        errors.push(SyntaxError::new(\n-            InvalidSuffix,\n-            range + literal_range.start(),\n-        ));\n+        errors.push(SyntaxError::new(InvalidSuffix, range + literal_range.start()));\n     }\n }\n \n@@ -48,12 +45,7 @@ mod test {\n \n     fn assert_valid_str(literal: &str) {\n         let file = build_file(literal);\n-        assert!(\n-            file.errors().len() == 0,\n-            \"Errors for literal '{}': {:?}\",\n-            literal,\n-            file.errors()\n-        );\n+        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n     }\n \n     fn assert_invalid_str(literal: &str) {\n@@ -121,13 +113,7 @@ mod test {\n \n     #[test]\n     fn test_valid_unicode_escape() {\n-        let valid = [\n-            r\"\\u{FF}\",\n-            r\"\\u{0}\",\n-            r\"\\u{F}\",\n-            r\"\\u{10FFFF}\",\n-            r\"\\u{1_0__FF___FF_____}\",\n-        ];\n+        let valid = [r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"];\n         for c in &valid {\n             assert_valid_str(c);\n         }"}, {"sha": "e8b9112d46360a1b103c3802181530c28bbc7a97", "filename": "crates/ra_syntax/src/yellow/builder.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -12,10 +12,7 @@ pub(crate) struct GreenBuilder {\n \n impl GreenBuilder {\n     pub(crate) fn new() -> GreenBuilder {\n-        GreenBuilder {\n-            errors: Vec::new(),\n-            inner: GreenNodeBuilder::new(),\n-        }\n+        GreenBuilder { errors: Vec::new(), inner: GreenNodeBuilder::new() }\n     }\n }\n "}, {"sha": "412cf82cc7a82498d767013a9654f4cba8984b36", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -28,10 +28,7 @@ impl Into<Location> for TextRange {\n \n impl SyntaxError {\n     pub fn new<L: Into<Location>>(kind: SyntaxErrorKind, loc: L) -> SyntaxError {\n-        SyntaxError {\n-            kind,\n-            location: loc.into(),\n-        }\n+        SyntaxError { kind, location: loc.into() }\n     }\n \n     pub fn kind(&self) -> SyntaxErrorKind {\n@@ -119,10 +116,9 @@ impl fmt::Display for SyntaxErrorKind {\n             InvalidByteEscape => write!(f, \"Invalid escape sequence\"),\n             TooShortByteCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n             MalformedByteCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n-            UnicodeEscapeForbidden => write!(\n-                f,\n-                \"Unicode escapes are not allowed in byte literals or byte strings\"\n-            ),\n+            UnicodeEscapeForbidden => {\n+                write!(f, \"Unicode escapes are not allowed in byte literals or byte strings\")\n+            }\n             TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n             AsciiCodeEscapeOutOfRange => {\n                 write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")"}, {"sha": "84e5b231ac5f67f7ad1d0cac6bbd2a1bc1dbb759", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -10,10 +10,7 @@ pub struct SyntaxText<'a> {\n \n impl<'a> SyntaxText<'a> {\n     pub(crate) fn new(node: &'a SyntaxNode) -> SyntaxText<'a> {\n-        SyntaxText {\n-            node,\n-            range: node.range(),\n-        }\n+        SyntaxText { node, range: node.range() }\n     }\n \n     pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n@@ -58,10 +55,7 @@ impl<'a> SyntaxText<'a> {\n         let range = range.restrict(self.range).unwrap_or_else(|| {\n             panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n         });\n-        SyntaxText {\n-            node: self.node,\n-            range,\n-        }\n+        SyntaxText { node: self.node, range }\n     }\n \n     pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {"}, {"sha": "168d0623dc9832750333be5c8d2d90f2c56a7dc0", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -23,36 +23,28 @@ fn lexer_tests() {\n \n #[test]\n fn parser_tests() {\n-    dir_tests(\n-        &test_data_dir(),\n-        &[\"parser/inline/ok\", \"parser/ok\"],\n-        |text, path| {\n-            let file = SourceFile::parse(text);\n-            let errors = file.errors();\n-            assert_eq!(\n-                &*errors,\n-                &[] as &[ra_syntax::SyntaxError],\n-                \"There should be no errors in the file {:?}\",\n-                path.display()\n-            );\n-            dump_tree(file.syntax())\n-        },\n-    );\n-    dir_tests(\n-        &test_data_dir(),\n-        &[\"parser/err\", \"parser/inline/err\"],\n-        |text, path| {\n-            let file = SourceFile::parse(text);\n-            let errors = file.errors();\n-            assert_ne!(\n-                &*errors,\n-                &[] as &[ra_syntax::SyntaxError],\n-                \"There should be errors in the file {:?}\",\n-                path.display()\n-            );\n-            dump_tree(file.syntax())\n-        },\n-    );\n+    dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n+        let file = SourceFile::parse(text);\n+        let errors = file.errors();\n+        assert_eq!(\n+            &*errors,\n+            &[] as &[ra_syntax::SyntaxError],\n+            \"There should be no errors in the file {:?}\",\n+            path.display()\n+        );\n+        dump_tree(file.syntax())\n+    });\n+    dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n+        let file = SourceFile::parse(text);\n+        let errors = file.errors();\n+        assert_ne!(\n+            &*errors,\n+            &[] as &[ra_syntax::SyntaxError],\n+            \"There should be errors in the file {:?}\",\n+            path.display()\n+        );\n+        dump_tree(file.syntax())\n+    });\n }\n \n #[test]\n@@ -87,12 +79,7 @@ fn self_hosting_parsing() {\n         let text = read_text(entry.path());\n         let node = SourceFile::parse(&text);\n         let errors = node.errors();\n-        assert_eq!(\n-            &*errors,\n-            &[],\n-            \"There should be no errors in the file {:?}\",\n-            entry\n-        );\n+        assert_eq!(&*errors, &[], \"There should be no errors in the file {:?}\", entry);\n     }\n     assert!(\n         count > 30,"}, {"sha": "df673ba1855d318f8ca19b2a51e52457db9215ce", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -15,10 +15,7 @@ pub struct AtomTextEdit {\n \n impl AtomTextEdit {\n     pub fn replace(range: TextRange, replace_with: String) -> AtomTextEdit {\n-        AtomTextEdit {\n-            delete: range,\n-            insert: replace_with,\n-        }\n+        AtomTextEdit { delete: range, insert: replace_with }\n     }\n \n     pub fn delete(range: TextRange) -> AtomTextEdit {"}, {"sha": "9e21b24f675681029a3ca708965122fa58fa045f", "filename": "crates/ra_text_edit/src/test_utils.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -8,9 +8,7 @@ pub fn arb_text() -> proptest::string::RegexGeneratorStrategy<String> {\n }\n \n fn text_offsets(text: &str) -> Vec<TextUnit> {\n-    text.char_indices()\n-        .map(|(i, _)| TextUnit::from_usize(i))\n-        .collect()\n+    text.char_indices().map(|(i, _)| TextUnit::from_usize(i)).collect()\n }\n \n pub fn arb_offset(text: &str) -> BoxedStrategy<TextUnit> {\n@@ -56,9 +54,7 @@ pub fn arb_text_edit(text: &str) -> BoxedStrategy<TextEdit> {\n                             )\n                             .boxed()\n                     }\n-                    &[x] => arb_text()\n-                        .prop_map(move |text| AtomTextEdit::insert(x, text))\n-                        .boxed(),\n+                    &[x] => arb_text().prop_map(move |text| AtomTextEdit::insert(x, text)).boxed(),\n                     _ => unreachable!(),\n                 })\n                 .collect();"}, {"sha": "8522f99bdd0147f8c2d98161d1987412ce2012a5", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -25,9 +25,7 @@ impl TextEditBuilder {\n         TextEdit::from_atoms(self.atoms)\n     }\n     pub fn invalidates_offset(&self, offset: TextUnit) -> bool {\n-        self.atoms\n-            .iter()\n-            .any(|atom| atom.delete.contains_inclusive(offset))\n+        self.atoms.iter().any(|atom| atom.delete.contains_inclusive(offset))\n     }\n }\n "}, {"sha": "ff5ae3a198e87844bbce9a82d839fb138f92193d", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -14,32 +14,15 @@ use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watc\n use crate::{RootConfig, Roots, VfsRoot};\n \n pub(crate) enum Task {\n-    AddRoot {\n-        root: VfsRoot,\n-        config: Arc<RootConfig>,\n-    },\n+    AddRoot { root: VfsRoot, config: Arc<RootConfig> },\n }\n \n #[derive(Debug)]\n pub enum TaskResult {\n-    BulkLoadRoot {\n-        root: VfsRoot,\n-        files: Vec<(RelativePathBuf, String)>,\n-    },\n-    AddSingleFile {\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-        text: String,\n-    },\n-    ChangeSingleFile {\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-        text: String,\n-    },\n-    RemoveSingleFile {\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-    },\n+    BulkLoadRoot { root: VfsRoot, files: Vec<(RelativePathBuf, String)> },\n+    AddSingleFile { root: VfsRoot, path: RelativePathBuf, text: String },\n+    ChangeSingleFile { root: VfsRoot, path: RelativePathBuf, text: String },\n+    RemoveSingleFile { root: VfsRoot, path: RelativePathBuf },\n }\n \n #[derive(Debug)]\n@@ -127,10 +110,7 @@ impl Worker {\n             },\n         );\n \n-        Worker {\n-            worker,\n-            worker_handle,\n-        }\n+        Worker { worker, worker_handle }\n     }\n \n     pub(crate) fn sender(&self) -> &Sender<Task> {\n@@ -162,9 +142,7 @@ fn watch_root(\n             Some((path, text))\n         })\n         .collect();\n-    sender\n-        .send(TaskResult::BulkLoadRoot { root, files })\n-        .unwrap();\n+    sender.send(TaskResult::BulkLoadRoot { root, files }).unwrap();\n     log::debug!(\"... loaded {}\", config.root.as_path().display());\n }\n \n@@ -233,21 +211,12 @@ fn handle_change(\n         }\n         ChangeKind::Write => {\n             if let Some(text) = read_to_string(&path) {\n-                sender\n-                    .send(TaskResult::ChangeSingleFile {\n-                        root,\n-                        path: rel_path,\n-                        text,\n-                    })\n-                    .unwrap();\n+                sender.send(TaskResult::ChangeSingleFile { root, path: rel_path, text }).unwrap();\n             }\n         }\n-        ChangeKind::Remove => sender\n-            .send(TaskResult::RemoveSingleFile {\n-                root,\n-                path: rel_path,\n-            })\n-            .unwrap(),\n+        ChangeKind::Remove => {\n+            sender.send(TaskResult::RemoveSingleFile { root, path: rel_path }).unwrap()\n+        }\n     }\n }\n \n@@ -282,7 +251,5 @@ fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n }\n \n fn read_to_string(path: &Path) -> Option<String> {\n-    fs::read_to_string(&path)\n-        .map_err(|e| log::warn!(\"failed to read file {}\", e))\n-        .ok()\n+    fs::read_to_string(&path).map_err(|e| log::warn!(\"failed to read file {}\", e)).ok()\n }"}, {"sha": "6b4eb684298bb84cd1ffa75920ebf4205f562a94", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 16, "deletions": 70, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -58,10 +58,7 @@ impl std::ops::Deref for Roots {\n \n impl RootConfig {\n     fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n-        RootConfig {\n-            root,\n-            excluded_dirs,\n-        }\n+        RootConfig { root, excluded_dirs }\n     }\n     /// Cheks if root contains a path and returns a root-relative path.\n     pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n@@ -111,9 +108,7 @@ impl Roots {\n         Roots { roots }\n     }\n     pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n-        self.roots\n-            .iter()\n-            .find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n+        self.roots.iter().find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n     }\n }\n \n@@ -154,21 +149,10 @@ impl Vfs {\n \n         for (root, config) in roots.iter() {\n             root2files.insert(root, Default::default());\n-            worker\n-                .sender()\n-                .send(io::Task::AddRoot {\n-                    root,\n-                    config: Arc::clone(config),\n-                })\n-                .unwrap();\n+            worker.sender().send(io::Task::AddRoot { root, config: Arc::clone(config) }).unwrap();\n         }\n-        let res = Vfs {\n-            roots,\n-            files: Arena::default(),\n-            root2files,\n-            worker,\n-            pending_changes: Vec::new(),\n-        };\n+        let res =\n+            Vfs { roots, files: Arena::default(), root2files, worker, pending_changes: Vec::new() };\n         let vfs_roots = res.roots.iter().map(|(id, _)| id).collect();\n         (res, vfs_roots)\n     }\n@@ -205,12 +189,7 @@ impl Vfs {\n                 let text = fs::read_to_string(path).unwrap_or_default();\n                 let text = Arc::new(text);\n                 let file = self.add_file(root, rel_path.clone(), Arc::clone(&text), false);\n-                let change = VfsChange::AddFile {\n-                    file,\n-                    text,\n-                    root,\n-                    path: rel_path,\n-                };\n+                let change = VfsChange::AddFile { file, text, root, path: rel_path };\n                 self.pending_changes.push(change);\n                 Some(file)\n             };\n@@ -243,10 +222,7 @@ impl Vfs {\n                     cur_files.push((file, path, text));\n                 }\n \n-                let change = VfsChange::AddRoot {\n-                    root,\n-                    files: cur_files,\n-                };\n+                let change = VfsChange::AddRoot { root, files: cur_files };\n                 self.pending_changes.push(change);\n             }\n             TaskResult::AddSingleFile { root, path, text } => {\n@@ -278,12 +254,7 @@ impl Vfs {\n     ) -> Option<VfsFile> {\n         let text = Arc::new(text);\n         let file = self.add_file(root, path.clone(), text.clone(), is_overlay);\n-        self.pending_changes.push(VfsChange::AddFile {\n-            file,\n-            root,\n-            path,\n-            text,\n-        });\n+        self.pending_changes.push(VfsChange::AddFile { file, root, path, text });\n         Some(file)\n     }\n \n@@ -293,8 +264,7 @@ impl Vfs {\n         }\n         let text = Arc::new(text);\n         self.change_file(file, text.clone(), is_overlay);\n-        self.pending_changes\n-            .push(VfsChange::ChangeFile { file, text });\n+        self.pending_changes.push(VfsChange::ChangeFile { file, text });\n     }\n \n     fn do_remove_file(\n@@ -308,8 +278,7 @@ impl Vfs {\n             return;\n         }\n         self.remove_file(file);\n-        self.pending_changes\n-            .push(VfsChange::RemoveFile { root, path, file });\n+        self.pending_changes.push(VfsChange::RemoveFile { root, path, file });\n     }\n \n     pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n@@ -363,12 +332,7 @@ impl Vfs {\n         text: Arc<String>,\n         is_overlayed: bool,\n     ) -> VfsFile {\n-        let data = VfsFileData {\n-            root,\n-            path,\n-            text,\n-            is_overlayed,\n-        };\n+        let data = VfsFileData { root, path, text, is_overlayed };\n         let file = self.files.alloc(data);\n         self.root2files.get_mut(root).unwrap().insert(file);\n         file\n@@ -396,32 +360,14 @@ impl Vfs {\n     }\n \n     fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[root]\n-            .iter()\n-            .map(|&it| it)\n-            .find(|&file| self.files[file].path == path)\n+        self.root2files[root].iter().map(|&it| it).find(|&file| self.files[file].path == path)\n     }\n }\n \n #[derive(Debug, Clone)]\n pub enum VfsChange {\n-    AddRoot {\n-        root: VfsRoot,\n-        files: Vec<(VfsFile, RelativePathBuf, Arc<String>)>,\n-    },\n-    AddFile {\n-        root: VfsRoot,\n-        file: VfsFile,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-    },\n-    RemoveFile {\n-        root: VfsRoot,\n-        file: VfsFile,\n-        path: RelativePathBuf,\n-    },\n-    ChangeFile {\n-        file: VfsFile,\n-        text: Arc<String>,\n-    },\n+    AddRoot { root: VfsRoot, files: Vec<(VfsFile, RelativePathBuf, Arc<String>)> },\n+    AddFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf, text: Arc<String> },\n+    RemoveFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf },\n+    ChangeFile { file: VfsFile, text: Arc<String> },\n }"}, {"sha": "649ef96c9ab794eb0d59db1431089f9706ff56d9", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 17, "deletions": 45, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -7,10 +7,7 @@ use tempfile::tempdir;\n \n fn process_tasks(vfs: &mut Vfs, num_tasks: u32) {\n     for _ in 0..num_tasks {\n-        let task = vfs\n-            .task_receiver()\n-            .recv_timeout(Duration::from_secs(3))\n-            .unwrap();\n+        let task = vfs.task_receiver().recv_timeout(Duration::from_secs(3)).unwrap();\n         log::debug!(\"{:?}\", task);\n         vfs.handle_task(task);\n     }\n@@ -32,11 +29,7 @@ macro_rules! assert_match {\n fn test_vfs_works() -> std::io::Result<()> {\n     // Logger::with_str(\"vfs=debug,ra_vfs=debug\").start().unwrap();\n \n-    let files = [\n-        (\"a/foo.rs\", \"hello\"),\n-        (\"a/bar.rs\", \"world\"),\n-        (\"a/b/baz.rs\", \"nested hello\"),\n-    ];\n+    let files = [(\"a/foo.rs\", \"hello\"), (\"a/bar.rs\", \"world\"), (\"a/b/baz.rs\", \"nested hello\")];\n \n     let dir = tempdir().unwrap();\n     for (path, text) in files.iter() {\n@@ -66,14 +59,10 @@ fn test_vfs_works() -> std::io::Result<()> {\n             })\n             .collect::<HashSet<_>>();\n \n-        let expected_files = [\n-            (\"foo.rs\", \"hello\"),\n-            (\"bar.rs\", \"world\"),\n-            (\"baz.rs\", \"nested hello\"),\n-        ]\n-        .iter()\n-        .map(|(path, text)| (path.to_string(), text.to_string()))\n-        .collect::<HashSet<_>>();\n+        let expected_files = [(\"foo.rs\", \"hello\"), (\"bar.rs\", \"world\"), (\"baz.rs\", \"nested hello\")]\n+            .iter()\n+            .map(|(path, text)| (path.to_string(), text.to_string()))\n+            .collect::<HashSet<_>>();\n \n         assert_eq!(files, expected_files);\n     }\n@@ -107,14 +96,10 @@ fn test_vfs_works() -> std::io::Result<()> {\n     );\n \n     vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::AddFile { text, path, .. }],\n-        {\n-            assert_eq!(text.as_str(), \"spam\");\n-            assert_eq!(path, \"spam.rs\");\n-        }\n-    );\n+    assert_match!(vfs.commit_changes().as_slice(), [VfsChange::AddFile { text, path, .. }], {\n+        assert_eq!(text.as_str(), \"spam\");\n+        assert_eq!(path, \"spam.rs\");\n+    });\n \n     vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n     assert_match!(\n@@ -126,30 +111,17 @@ fn test_vfs_works() -> std::io::Result<()> {\n     fs::create_dir_all(dir.path().join(\"a/sub1/sub2\")).unwrap();\n     fs::write(dir.path().join(\"a/sub1/sub2/new.rs\"), \"new hello\").unwrap();\n     process_tasks(&mut vfs, 1);\n-    assert_match!(\n-        vfs.commit_changes().as_slice(),\n-        [VfsChange::AddFile { text, path, .. }],\n-        {\n-            assert_eq!(text.as_str(), \"new hello\");\n-            assert_eq!(path, \"sub1/sub2/new.rs\");\n-        }\n-    );\n+    assert_match!(vfs.commit_changes().as_slice(), [VfsChange::AddFile { text, path, .. }], {\n+        assert_eq!(text.as_str(), \"new hello\");\n+        assert_eq!(path, \"sub1/sub2/new.rs\");\n+    });\n \n-    fs::rename(\n-        &dir.path().join(\"a/sub1/sub2/new.rs\"),\n-        &dir.path().join(\"a/sub1/sub2/new1.rs\"),\n-    )\n-    .unwrap();\n+    fs::rename(&dir.path().join(\"a/sub1/sub2/new.rs\"), &dir.path().join(\"a/sub1/sub2/new1.rs\"))\n+        .unwrap();\n     process_tasks(&mut vfs, 2);\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n-        [VfsChange::RemoveFile {\n-            path: removed_path, ..\n-        }, VfsChange::AddFile {\n-            text,\n-            path: added_path,\n-            ..\n-        }],\n+        [VfsChange::RemoveFile { path: removed_path, .. }, VfsChange::AddFile { text, path: added_path, .. }],\n         {\n             assert_eq!(removed_path, \"sub1/sub2/new.rs\");\n             assert_eq!(added_path, \"sub1/sub2/new1.rs\");"}, {"sha": "09fc2e6597043f9cf8ecebe73c3b75ec1aac2778", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -85,9 +85,7 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n                     stack.push(from);\n                 } else if text.starts_with(&close) {\n                     text = &text[close.len()..];\n-                    let from = stack\n-                        .pop()\n-                        .unwrap_or_else(|| panic!(\"unmatched </{}>\", tag));\n+                    let from = stack.pop().unwrap_or_else(|| panic!(\"unmatched </{}>\", tag));\n                     let to = TextUnit::of_str(&res);\n                     ranges.push(TextRange::from_to(from, to));\n                 }\n@@ -131,10 +129,7 @@ pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n     macro_rules! flush {\n         () => {\n             if let Some(meta) = meta {\n-                res.push(FixtureEntry {\n-                    meta: meta.to_string(),\n-                    text: buf.clone(),\n-                });\n+                res.push(FixtureEntry { meta: meta.to_string(), text: buf.clone() });\n                 buf.clear();\n             }\n         };\n@@ -226,15 +221,13 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n             let mut l = l.iter().collect::<Vec<_>>();\n             let mut r = r.iter().collect::<Vec<_>>();\n \n-            l.retain(\n-                |l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n-                    Some(i) => {\n-                        r.remove(i);\n-                        false\n-                    }\n-                    None => true,\n-                },\n-            );\n+            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n+                Some(i) => {\n+                    r.remove(i);\n+                    false\n+                }\n+                None => true,\n+            });\n \n             if !l.is_empty() {\n                 assert!(!r.is_empty());\n@@ -250,10 +243,7 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n                 return Some((expected, actual));\n             }\n \n-            l.values()\n-                .zip(r.values())\n-                .filter_map(|(l, r)| find_mismatch(l, r))\n-                .nth(0)\n+            l.values().zip(r.values()).filter_map(|(l, r)| find_mismatch(l, r)).nth(0)\n         }\n         (&Null, &Null) => None,\n         // magic string literal \"{...}\" acts as wildcard for any sub-JSON\n@@ -312,12 +302,7 @@ fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n \n pub fn project_dir() -> PathBuf {\n     let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir)\n-        .parent()\n-        .unwrap()\n-        .parent()\n-        .unwrap()\n-        .to_owned()\n+    PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n }\n \n /// Read file and normalize newlines."}, {"sha": "d2a84643c8a40d53df6db8fef9d5460409e91539", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -64,10 +64,7 @@ pub struct MarkChecker {\n impl MarkChecker {\n     pub fn new(mark: &'static AtomicUsize) -> MarkChecker {\n         let value_on_entry = mark.load(Ordering::SeqCst);\n-        MarkChecker {\n-            mark,\n-            value_on_entry,\n-        }\n+        MarkChecker { mark, value_on_entry }\n     }\n }\n "}, {"sha": "ca0aad13608f61eff700d14e18116afe816d5e2e", "filename": "crates/thread_worker/src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fthread_worker%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Fthread_worker%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -71,12 +71,5 @@ impl WorkerHandle {\n fn worker_chan<I, O>(buf: usize) -> (Worker<I, O>, Receiver<I>, Sender<O>) {\n     let (input_sender, input_receiver) = bounded::<I>(buf);\n     let (output_sender, output_receiver) = unbounded::<O>();\n-    (\n-        Worker {\n-            inp: input_sender,\n-            out: output_receiver,\n-        },\n-        input_receiver,\n-        output_sender,\n-    )\n+    (Worker { inp: input_sender, out: output_receiver }, input_receiver, output_sender)\n }"}, {"sha": "ea18c0863f30c0204dc131f3200d421967db43fa", "filename": "crates/tools/src/bin/pre-commit.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -19,19 +19,10 @@ fn update_staged() -> Result<()> {\n         .current_dir(&root)\n         .output()?;\n     if !output.status.success() {\n-        bail!(\n-            \"`git diff --diff-filter=MAR --name-only --cached` exited with {}\",\n-            output.status\n-        );\n+        bail!(\"`git diff --diff-filter=MAR --name-only --cached` exited with {}\", output.status);\n     }\n     for line in String::from_utf8(output.stdout)?.lines() {\n-        run(\n-            &format!(\n-                \"git update-index --add {}\",\n-                root.join(line).to_string_lossy()\n-            ),\n-            \".\",\n-        )?;\n+        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n     }\n     Ok(())\n }"}, {"sha": "ef9c613a7da9255cedc1b8d3c1b57ac41548b893", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -58,10 +58,8 @@ pub fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n                 None => continue 'outer,\n             }\n         };\n-        let text: String = itertools::join(\n-            block.map(|(_, line)| line).chain(::std::iter::once(\"\")),\n-            \"\\n\",\n-        );\n+        let text: String =\n+            itertools::join(block.map(|(_, line)| line).chain(::std::iter::once(\"\")), \"\\n\");\n         assert!(!text.trim().is_empty() && text.ends_with('\\n'));\n         res.push((start_line, Test { name, text, ok }))\n     }\n@@ -78,22 +76,15 @@ pub fn generate(mode: Mode) -> Result<()> {\n }\n \n pub fn project_root() -> PathBuf {\n-    Path::new(&env!(\"CARGO_MANIFEST_DIR\"))\n-        .ancestors()\n-        .nth(2)\n-        .unwrap()\n-        .to_path_buf()\n+    Path::new(&env!(\"CARGO_MANIFEST_DIR\")).ancestors().nth(2).unwrap().to_path_buf()\n }\n \n pub fn run(cmdline: &str, dir: &str) -> Result<()> {\n     eprintln!(\"\\nwill run: {}\", cmdline);\n     let project_dir = project_root().join(dir);\n     let mut args = cmdline.split_whitespace();\n     let exec = args.next().unwrap();\n-    let status = Command::new(exec)\n-        .args(args)\n-        .current_dir(project_dir)\n-        .status()?;\n+    let status = Command::new(exec).args(args).current_dir(project_dir).status()?;\n     if !status.success() {\n         bail!(\"`{}` exited with {}\", cmdline, status);\n     }\n@@ -112,10 +103,7 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     };\n \n     if mode == Verify {\n-        run(\n-            &format!(\"rustup run {} -- cargo fmt -- --check\", TOOLCHAIN),\n-            \".\",\n-        )?;\n+        run(&format!(\"rustup run {} -- cargo fmt -- --check\", TOOLCHAIN), \".\")?;\n     } else {\n         run(&format!(\"rustup run {} -- cargo fmt\", TOOLCHAIN), \".\")?;\n     }\n@@ -124,10 +112,7 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n \n pub fn install_rustfmt() -> Result<()> {\n     run(&format!(\"rustup install {}\", TOOLCHAIN), \".\")?;\n-    run(\n-        &format!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN),\n-        \".\",\n-    )\n+    run(&format!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN), \".\")\n }\n \n pub fn install_format_hook() -> Result<()> {\n@@ -156,10 +141,7 @@ pub fn run_fuzzer() -> Result<()> {\n         _ => run(\"cargo install cargo-fuzz\", \".\")?,\n     };\n \n-    run(\n-        \"rustup run nightly -- cargo fuzz run parser\",\n-        \"./crates/ra_syntax\",\n-    )\n+    run(\"rustup run nightly -- cargo fuzz run parser\", \"./crates/ra_syntax\")\n }\n \n pub fn gen_tests(mode: Mode) -> Result<()> {\n@@ -245,11 +227,7 @@ fn existing_tests(dir: &Path, ok: bool) -> Result<HashMap<String, (PathBuf, Test\n             file_name[5..file_name.len() - 3].to_string()\n         };\n         let text = fs::read_to_string(&path)?;\n-        let test = Test {\n-            name: name.clone(),\n-            text,\n-            ok,\n-        };\n+        let test = Test { name: name.clone(), text, ok };\n         if let Some(old) = res.insert(name, (path, test)) {\n             println!(\"Duplicate test: {:?}\", old);\n         }"}, {"sha": "963ffbe986cf27dbf1b1e52883ef9145da5fd0cc", "filename": "crates/tools/src/main.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fmain.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -15,10 +15,7 @@ fn main() -> Result<()> {\n         .subcommand(SubCommand::with_name(\"format-hook\"))\n         .subcommand(SubCommand::with_name(\"fuzz-tests\"))\n         .get_matches();\n-    match matches\n-        .subcommand_name()\n-        .expect(\"Subcommand must be specified\")\n-    {\n+    match matches.subcommand_name().expect(\"Subcommand must be specified\") {\n         \"install-code\" => install_code_extension()?,\n         \"gen-tests\" => gen_tests(Overwrite)?,\n         \"gen-syntax\" => generate(Overwrite)?,\n@@ -45,10 +42,7 @@ fn install_code_extension() -> Result<()> {\n             \"./editors/code\",\n         )?;\n     } else {\n-        run(\n-            r\"code --install-extension ./ra-lsp-0.0.1.vsix --force\",\n-            \"./editors/code\",\n-        )?;\n+        run(r\"code --install-extension ./ra-lsp-0.0.1.vsix --force\", \"./editors/code\")?;\n     }\n     Ok(())\n }"}, {"sha": "aab52a4aaa6c38646fbdd368c7bc84dab3aa32d3", "filename": "crates/tools/tests/cli.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Ftests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e3b4c70b5ef23b2fdfc197296d483680e125f9/crates%2Ftools%2Ftests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Ftests%2Fcli.rs?ref=12e3b4c70b5ef23b2fdfc197296d483680e125f9", "patch": "@@ -10,19 +10,13 @@ fn generated_grammar_is_fresh() {\n #[test]\n fn generated_tests_are_fresh() {\n     if let Err(error) = gen_tests(Verify) {\n-        panic!(\n-            \"{}. Please update tests by running `cargo gen-tests`\",\n-            error\n-        );\n+        panic!(\"{}. Please update tests by running `cargo gen-tests`\", error);\n     }\n }\n \n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Verify) {\n-        panic!(\n-            \"{}. Please format the code by running `cargo format`\",\n-            error\n-        );\n+        panic!(\"{}. Please format the code by running `cargo format`\", error);\n     }\n }"}]}