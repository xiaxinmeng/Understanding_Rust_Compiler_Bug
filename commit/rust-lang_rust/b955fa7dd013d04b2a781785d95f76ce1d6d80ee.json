{"sha": "b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "node_id": "C_kwDOAAsO6NoAKGI5NTVmYTdkZDAxM2QwNGIyYTc4MTc4NWQ5NWY3NmNlMWQ2ZDgwZWU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-07T14:14:27Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-15T14:53:20Z"}, "message": "don't require `FnCtxt` to check global asm", "tree": {"sha": "1e1f92682cc0a17b599e3d4e09f17cb99feb2899", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e1f92682cc0a17b599e3d4e09f17cb99feb2899"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "html_url": "https://github.com/rust-lang/rust/commit/b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "html_url": "https://github.com/rust-lang/rust/commit/4b56fd9341d26a955b8ecf0bb6c444f403cb401a"}], "stats": {"total": 43, "additions": 29, "deletions": 14}, "files": [{"sha": "51ddec62d78f151e120b0520737852fadccf6e31", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "patch": "@@ -1,3 +1,5 @@\n+use crate::check::intrinsicck::InlineAsmCtxt;\n+\n use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n@@ -936,11 +938,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         DefKind::GlobalAsm => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::GlobalAsm(asm) = it.kind else { span_bug!(it.span, \"DefKind::GlobalAsm but got {:#?}\", it) };\n-            Inherited::build(tcx, it.def_id).enter(|inh| {\n-                let fcx = FnCtxt::new(&inh, tcx.param_env(it.def_id), id.hir_id());\n-                fcx.check_asm(asm, it.hir_id());\n-                fcx.select_all_obligations_or_error();\n-            })\n+            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.hir_id());\n         }\n         _ => {}\n     }"}, {"sha": "89b376442a887aceaaa15eeac53e126cd1d953fd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "patch": "@@ -4,6 +4,7 @@ use crate::check::fn_ctxt::arg_matrix::{\n     ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n };\n use crate::check::gather_locals::Declaration;\n+use crate::check::intrinsicck::InlineAsmCtxt;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n use crate::check::TupleArgumentsFlag::*;\n@@ -59,7 +60,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"FnCtxt::check_asm: {} deferred checks\", deferred_asm_checks.len());\n         for (asm, hir_id) in deferred_asm_checks.drain(..) {\n             let enclosing_id = self.tcx.hir().enclosing_body_owner(hir_id);\n-            self.check_asm(asm, enclosing_id);\n+            InlineAsmCtxt::new_in_fn(self).check_asm(asm, enclosing_id);\n         }\n     }\n "}, {"sha": "0889aff3934e693011c5f2dc664692f384f12c89", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> InheritedBuilder<'tcx> {\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n-    pub(super) fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);"}, {"sha": "0adf0d28aae10eb4a17b9a2807f5b36d78b0178d", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b955fa7dd013d04b2a781785d95f76ce1d6d80ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=b955fa7dd013d04b2a781785d95f76ce1d6d80ee", "patch": "@@ -111,6 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         false\n     }\n+}\n+\n+pub struct InlineAsmCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    fcx: Option<&'a FnCtxt<'a, 'tcx>>,\n+}\n+\n+impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n+    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n+        InlineAsmCtxt { tcx, fcx: None }\n+    }\n+\n+    pub fn new_in_fn(fcx: &'a FnCtxt<'a, 'tcx>) -> Self {\n+        InlineAsmCtxt { tcx: fcx.tcx, fcx: Some(fcx) }\n+    }\n \n     fn check_asm_operand_type(\n         &self,\n@@ -122,9 +137,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n         target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n+        let fcx = self.fcx.unwrap_or_else(|| span_bug!(expr.span, \"asm operand for global asm\"));\n         // Check the type against the allowed types for inline asm.\n-        let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n-        let ty = self.resolve_vars_if_possible(ty);\n+        let ty = fcx.typeck_results.borrow().expr_ty_adjusted(expr);\n+        let ty = fcx.resolve_vars_if_possible(ty);\n         let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n@@ -134,7 +150,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Expect types to be fully resolved, no const or type variables.\n         if ty.has_infer_types_or_consts() {\n-            assert!(self.is_tainted_by_errors());\n+            assert!(fcx.is_tainted_by_errors());\n             return None;\n         }\n \n@@ -151,7 +167,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n             ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n             ty::FnPtr(_) => Some(asm_ty_isize),\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if fcx.is_thin_ptr_ty(ty) => {\n                 Some(asm_ty_isize)\n             }\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n@@ -203,7 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n+        if !fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, ty, DUMMY_SP) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n@@ -224,8 +240,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n \n-                let in_expr_ty = self.typeck_results.borrow().expr_ty_adjusted(in_expr);\n-                let in_expr_ty = self.resolve_vars_if_possible(in_expr_ty);\n+                let in_expr_ty = fcx.typeck_results.borrow().expr_ty_adjusted(in_expr);\n+                let in_expr_ty = fcx.resolve_vars_if_possible(in_expr_ty);\n                 err.span_label(in_expr.span, &format!(\"type `{in_expr_ty}`\"));\n                 err.span_label(expr.span, &format!(\"type `{ty}`\"));\n                 err.note("}]}