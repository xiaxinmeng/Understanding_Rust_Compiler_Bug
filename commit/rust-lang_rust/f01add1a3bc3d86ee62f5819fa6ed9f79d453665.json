{"sha": "f01add1a3bc3d86ee62f5819fa6ed9f79d453665", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMWFkZDFhM2JjM2Q4NmVlNjJmNTgxOWZhNmVkOWY3OWQ0NTM2NjU=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-17T17:22:07Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-17T17:22:07Z"}, "message": "Add signal support, better exec error handling", "tree": {"sha": "492992a6c6e0510b55681a242fa111b08e61db27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/492992a6c6e0510b55681a242fa111b08e61db27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f01add1a3bc3d86ee62f5819fa6ed9f79d453665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f01add1a3bc3d86ee62f5819fa6ed9f79d453665", "html_url": "https://github.com/rust-lang/rust/commit/f01add1a3bc3d86ee62f5819fa6ed9f79d453665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f01add1a3bc3d86ee62f5819fa6ed9f79d453665/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267bc54fbd2cfeadde7a87fc2aa3fb975ff58b6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/267bc54fbd2cfeadde7a87fc2aa3fb975ff58b6c", "html_url": "https://github.com/rust-lang/rust/commit/267bc54fbd2cfeadde7a87fc2aa3fb975ff58b6c"}], "stats": {"total": 114, "additions": 80, "deletions": 34}, "files": [{"sha": "92694e4b2227c5ebd9bed73da439be1100a713eb", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 80, "deletions": 34, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f01add1a3bc3d86ee62f5819fa6ed9f79d453665/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f01add1a3bc3d86ee62f5819fa6ed9f79d453665/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=f01add1a3bc3d86ee62f5819fa6ed9f79d453665", "patch": "@@ -13,7 +13,7 @@ use env;\n use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, c_int, gid_t, uid_t};\n+use libc::{self, pid_t, gid_t, uid_t};\n use path::Path;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n@@ -145,33 +145,79 @@ impl Command {\n \n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n-        if self.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n-        }\n-\n-        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-\n-        let pid = unsafe {\n-            match cvt(libc::clone(libc::CLONE_VFORK))? {\n-                0 => {\n-                    let err = self.do_exec(theirs);\n-                    let _ = libc::exit((-err.raw_os_error().unwrap_or(libc::EINVAL)) as usize);\n-                    unreachable!();\n-                }\n-                n => n as pid_t,\n-            }\n-        };\n-\n-        let mut status_mux = 0;\n-        if cvt(libc::waitpid(pid, &mut status_mux, libc::WNOHANG))? == pid {\n-            match libc::Error::demux(status_mux) {\n-                Ok(status) => Ok((Process { pid: pid, status: Some(ExitStatus::from(status as c_int)) }, ours)),\n-                Err(err) => Err(io::Error::from_raw_os_error(err.errno)),\n-            }\n-        } else {\n-            Ok((Process { pid: pid, status: None }, ours))\n-        }\n+         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+         if self.saw_nul {\n+             return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                       \"nul byte found in provided data\"));\n+         }\n+\n+         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+         let (input, output) = pipe::anon_pipe()?;\n+\n+         let pid = unsafe {\n+             match cvt(libc::clone(0))? {\n+                 0 => {\n+                     drop(input);\n+                     let err = self.do_exec(theirs);\n+                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                     let bytes = [\n+                         (errno >> 24) as u8,\n+                         (errno >> 16) as u8,\n+                         (errno >>  8) as u8,\n+                         (errno >>  0) as u8,\n+                         CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                         CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                     ];\n+                     // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                     // we want to be sure we *don't* run at_exit destructors as\n+                     // we're being torn down regardless\n+                     assert!(output.write(&bytes).is_ok());\n+                     let _ = libc::exit(1);\n+                     panic!(\"failed to exit\");\n+                 }\n+                 n => n,\n+             }\n+         };\n+\n+         let mut p = Process { pid: pid, status: None };\n+         drop(output);\n+         let mut bytes = [0; 8];\n+\n+         // loop to handle EINTR\n+         loop {\n+             match input.read(&mut bytes) {\n+                 Ok(0) => return Ok((p, ours)),\n+                 Ok(8) => {\n+                     assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                             \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                     let errno = combine(&bytes[0.. 4]);\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     return Err(Error::from_raw_os_error(errno))\n+                 }\n+                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                 Err(e) => {\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                 },\n+                 Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     panic!(\"short read on the CLOEXEC pipe\")\n+                 }\n+             }\n+         }\n+\n+         fn combine(arr: &[u8]) -> i32 {\n+             let a = arr[0] as u32;\n+             let b = arr[1] as u32;\n+             let c = arr[2] as u32;\n+             let d = arr[3] as u32;\n+\n+             ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+         }\n     }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n@@ -378,11 +424,11 @@ impl fmt::Debug for Command {\n \n /// Unix exit statuses\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n+pub struct ExitStatus(i32);\n \n impl ExitStatus {\n     fn exited(&self) -> bool {\n-        true\n+        self.0 & 0x7F == 0\n     }\n \n     pub fn success(&self) -> bool {\n@@ -391,23 +437,23 @@ impl ExitStatus {\n \n     pub fn code(&self) -> Option<i32> {\n         if self.exited() {\n-            Some(self.0)\n+            Some((self.0 >> 8) & 0xFF)\n         } else {\n             None\n         }\n     }\n \n     pub fn signal(&self) -> Option<i32> {\n         if !self.exited() {\n-            Some(self.0)\n+            Some(self.0 & 0x7F)\n         } else {\n             None\n         }\n     }\n }\n \n-impl From<c_int> for ExitStatus {\n-    fn from(a: c_int) -> ExitStatus {\n+impl From<i32> for ExitStatus {\n+    fn from(a: i32) -> ExitStatus {\n         ExitStatus(a)\n     }\n }"}]}