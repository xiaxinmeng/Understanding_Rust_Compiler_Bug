{"sha": "da33da161bf01093bc87e0cdff317d40bd648974", "node_id": "C_kwDOAAsO6NoAKGRhMzNkYTE2MWJmMDEwOTNiYzg3ZTBjZGZmMzE3ZDQwYmQ2NDg5NzQ", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T14:57:09Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-04T15:09:53Z"}, "message": "Add documentation for scoped threads.", "tree": {"sha": "916c0d8457ad174344e0c9bf1e2592c963cb5283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/916c0d8457ad174344e0c9bf1e2592c963cb5283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da33da161bf01093bc87e0cdff317d40bd648974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da33da161bf01093bc87e0cdff317d40bd648974", "html_url": "https://github.com/rust-lang/rust/commit/da33da161bf01093bc87e0cdff317d40bd648974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da33da161bf01093bc87e0cdff317d40bd648974/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc699e1b62573fef34e2521a6ada0975e79b0459", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc699e1b62573fef34e2521a6ada0975e79b0459", "html_url": "https://github.com/rust-lang/rust/commit/cc699e1b62573fef34e2521a6ada0975e79b0459"}], "stats": {"total": 186, "additions": 175, "deletions": 11}, "files": [{"sha": "8f050b72a4104a70bd42700c0e4fbc8af486a409", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 175, "deletions": 11, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/da33da161bf01093bc87e0cdff317d40bd648974/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da33da161bf01093bc87e0cdff317d40bd648974/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=da33da161bf01093bc87e0cdff317d40bd648974", "patch": "@@ -7,13 +7,17 @@ use crate::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sync::{Arc, Mutex};\n \n-/// TODO: documentation\n+/// A scope to spawn scoped threads in.\n+///\n+/// See [`scope`] for details.\n pub struct Scope<'env> {\n     data: ScopeData,\n     env: PhantomData<&'env ()>,\n }\n \n-/// TODO: documentation\n+/// An owned permission to join on a scoped thread (block on its termination).\n+///\n+/// See [`Scope::spawn`] for details.\n pub struct ScopedJoinHandle<'scope, T>(JoinInner<'scope, T>);\n \n pub(super) struct ScopeData {\n@@ -39,7 +43,52 @@ impl ScopeData {\n     }\n }\n \n-/// TODO: documentation\n+/// Create a scope for spawning scoped threads.\n+///\n+/// The function passed to `scope` will be provided a [`Scope`] object,\n+/// through which scoped threads can be [spawned][`Scope::spawn`].\n+///\n+/// Unlike non-scoped threads, scoped threads can non-`'static` data,\n+/// as the scope guarantees all threads will be joined at the end of the scope.\n+///\n+/// All threads spawned within the scope that haven't been manually joined\n+/// will be automatically joined before this function returns.\n+///\n+/// # Panics\n+///\n+/// If any of the automatically joined threads panicked, this function will panic.\n+///\n+/// If you want to handle panics from spawned threads,\n+/// [`join`][ScopedJoinHandle::join] them before the end of the scope.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(scoped_threads)]\n+/// use std::thread;\n+///\n+/// let mut a = vec![1, 2, 3];\n+/// let mut x = 0;\n+///\n+/// thread::scope(|s| {\n+///     s.spawn(|_| {\n+///         println!(\"hello from the first scoped thread\");\n+///         // We can borrow `a` here.\n+///         dbg!(&a);\n+///     });\n+///     s.spawn(|_| {\n+///         println!(\"hello from the second scoped thread\");\n+///         // We can even mutably borrow `x` here,\n+///         // because no other threads are using it.\n+///         x += a[0] + a[2];\n+///     });\n+///     println!(\"hello from the main thread\");\n+/// });\n+///\n+/// // After the scope, we can modify and access our variables again:\n+/// a.push(4);\n+/// assert_eq!(x, a.len());\n+/// ```\n pub fn scope<'env, F, T>(f: F) -> T\n where\n     F: FnOnce(&Scope<'env>) -> T,\n@@ -80,7 +129,30 @@ where\n }\n \n impl<'env> Scope<'env> {\n-    /// TODO: documentation\n+    /// Spawns a new thread within a scope, returning a [`ScopedJoinHandle`] for it.\n+    ///\n+    /// Unlike non-scoped threads, threads spawned with this function may\n+    /// borrow non-`'static` data from the outside the scope. See [`scope`] for\n+    /// details.\n+    ///\n+    /// The join handle provides a [`join`] method that can be used to join the spawned\n+    /// thread. If the spawned thread panics, [`join`] will return an [`Err`] containing\n+    /// the panic payload.\n+    ///\n+    /// If the join handle is dropped, the spawned thread will implicitly joined at the\n+    /// end of the scope. In that case, if the spawned thread panics, [`scope`] will\n+    /// panic after all threads are joined.\n+    ///\n+    /// This call will create a thread using default parameters of [`Builder`].\n+    /// If you want to specify the stack size or the name of the thread, use\n+    /// [`Builder::spawn_scoped`] instead.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n+    /// to recover from such errors.\n+    ///\n+    /// [`join`]: ScopedJoinHandle::join\n     pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n     where\n         F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n@@ -91,7 +163,54 @@ impl<'env> Scope<'env> {\n }\n \n impl Builder {\n-    fn spawn_scoped<'scope, 'env, F, T>(\n+    /// Spawns a new scoped thread using the settings set through this `Builder`.\n+    ///\n+    /// Unlike [`Scope::spawn`], this method yields an [`io::Result`] to\n+    /// capture any failure to create the thread at the OS level.\n+    ///\n+    /// [`io::Result`]: crate::io::Result\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if a thread name was set and it contained null bytes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// use std::thread;\n+    ///\n+    /// let mut a = vec![1, 2, 3];\n+    /// let mut x = 0;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     thread::Builder::new()\n+    ///         .name(\"first\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can borrow `a` here.\n+    ///         dbg!(&a);\n+    ///     })\n+    ///     .unwrap();\n+    ///     thread::Builder::new()\n+    ///         .name(\"second\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can even mutably borrow `x` here,\n+    ///         // because no other threads are using it.\n+    ///         x += a[0] + a[2];\n+    ///     })\n+    ///     .unwrap();\n+    ///     println!(\"hello from the main thread\");\n+    /// });\n+    ///\n+    /// // After the scope, we can modify and access our variables again:\n+    /// a.push(4);\n+    /// assert_eq!(x, a.len());\n+    /// ```\n+    pub fn spawn_scoped<'scope, 'env, F, T>(\n         self,\n         scope: &'scope Scope<'env>,\n         f: F,\n@@ -105,16 +224,61 @@ impl Builder {\n }\n \n impl<'scope, T> ScopedJoinHandle<'scope, T> {\n-    /// TODO\n-    pub fn join(self) -> Result<T> {\n-        self.0.join()\n-    }\n-\n-    /// TODO\n+    /// Extracts a handle to the underlying thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         println!(\"hello\");\n+    ///     });\n+    ///     println!(\"thread id: {:?}\", t.thread().id());\n+    /// });\n+    /// ```\n+    #[must_use]\n     pub fn thread(&self) -> &Thread {\n         &self.0.thread\n     }\n \n+    /// Waits for the associated thread to finish.\n+    ///\n+    /// This function will return immediately if the associated thread has already finished.\n+    ///\n+    /// In terms of [atomic memory orderings], the completion of the associated\n+    /// thread synchronizes with this function returning.\n+    /// In other words, all operations performed by that thread\n+    /// [happen before](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses)\n+    /// all operations that happen after `join` returns.\n+    ///\n+    /// If the associated thread panics, [`Err`] is returned with the panic payload.\n+    ///\n+    /// [atomic memory orderings]: crate::sync::atomic\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         panic!(\"oh no\");\n+    ///     });\n+    ///     assert!(t.join().is_err());\n+    /// });\n+    /// ```\n+    pub fn join(self) -> Result<T> {\n+        self.0.join()\n+    }\n+\n     /// Checks if the the associated thread is still running its main function.\n     ///\n     /// This might return `false` for a brief moment after the thread's main"}]}