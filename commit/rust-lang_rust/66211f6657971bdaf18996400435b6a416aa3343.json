{"sha": "66211f6657971bdaf18996400435b6a416aa3343", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjExZjY2NTc5NzFiZGFmMTg5OTY0MDA0MzViNmE0MTZhYTMzNDM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-18T15:57:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-18T15:57:34Z"}, "message": "Rollup merge of #82066 - matthewjasper:trait-ref-fix, r=jackh726\n\nEnsure valid TraitRefs are created for GATs\n\nThis fixes `ProjectionTy::trait_ref` to use the correct substs. Places that need all of the substs have been updated to not use `trait_ref`.\n\nr? ````@jackh726````", "tree": {"sha": "fc0bfa6c8cf3b7c7344a4373cab51d2947a6dc5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc0bfa6c8cf3b7c7344a4373cab51d2947a6dc5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66211f6657971bdaf18996400435b6a416aa3343", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgLo5uCRBK7hj4Ov3rIwAAdHIIADIJbWFCB4hZLySnZYuCOViO\n35Q9JTW+SWfFtMaHmxNzfXTXcRfjMlIzuipIRKWtP7tqkaDg5LdVSWMZ+lPh3+eM\nzwFiW6JBFivnTlXiiz90szNyZPY3EoA48mwkr5VulILgmHXgSq4pldjeNOlIxyMs\n6d+pmOr5lGmbsPL6654Bh3m2uJKMNjl9MyqleHrkzPHJvR+RBKs2LP+Tik6CPdUV\ncW4FT/p96GR4uHsCChr7jFOkU2Evg86UBAVxawSdfcvjVjAf/82tYhT4k3H9VtBU\n+EGnvi9sXBE1BDQgNX8YyaACrPAc6gjAiLBCWjeoWyITn3x05gDjzMymaLJHFig=\n=B2Eu\n-----END PGP SIGNATURE-----\n", "payload": "tree fc0bfa6c8cf3b7c7344a4373cab51d2947a6dc5e\nparent 55ab2e38797ad1661ff4cfa95074a3d81636fde0\nparent eeb82e45fe42ec77efd99b706f96b3e66bcfb524\nauthor Dylan DPC <dylan.dpc@gmail.com> 1613663854 +0100\ncommitter GitHub <noreply@github.com> 1613663854 +0100\n\nRollup merge of #82066 - matthewjasper:trait-ref-fix, r=jackh726\n\nEnsure valid TraitRefs are created for GATs\n\nThis fixes `ProjectionTy::trait_ref` to use the correct substs. Places that need all of the substs have been updated to not use `trait_ref`.\n\nr? ````@jackh726````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66211f6657971bdaf18996400435b6a416aa3343", "html_url": "https://github.com/rust-lang/rust/commit/66211f6657971bdaf18996400435b6a416aa3343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66211f6657971bdaf18996400435b6a416aa3343/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55ab2e38797ad1661ff4cfa95074a3d81636fde0", "url": "https://api.github.com/repos/rust-lang/rust/commits/55ab2e38797ad1661ff4cfa95074a3d81636fde0", "html_url": "https://github.com/rust-lang/rust/commit/55ab2e38797ad1661ff4cfa95074a3d81636fde0"}, {"sha": "eeb82e45fe42ec77efd99b706f96b3e66bcfb524", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb82e45fe42ec77efd99b706f96b3e66bcfb524", "html_url": "https://github.com/rust-lang/rust/commit/eeb82e45fe42ec77efd99b706f96b3e66bcfb524"}], "stats": {"total": 781, "additions": 542, "deletions": 239}, "files": [{"sha": "7f712643d19adb832e7e0e00960e1e26acb6823c", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -914,6 +914,7 @@ impl<'a> State<'a> {\n \n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n         self.print_ident(constraint.ident);\n+        constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n         self.s.space();\n         match &constraint.kind {\n             ast::AssocTyConstraintKind::Equality { ty } => {"}, {"sha": "03524569ce7a9f726fc581dd5cffee3aefda03de", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -242,6 +242,7 @@ language_item_table! {\n \n     Deref,                   sym::deref,               deref_trait,                Target::Trait;\n     DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait;\n+    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait;\n \n     Fn,                      kw::Fn,                   fn_trait,                   Target::Trait;"}, {"sha": "11ee8fb17ad1b4abc01175e138d765b28e192bb1", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -55,6 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n     fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n+        let trace = ToTrace::to_trace(self.infcx.tcx, self.cause, a_is_expected, a, b);\n         Trace { at: self, trace, a_is_expected }\n     }\n }\n@@ -251,6 +252,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -262,6 +264,7 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -273,6 +276,7 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -284,6 +288,7 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -298,6 +303,7 @@ impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -309,3 +315,20 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        let a_ty = tcx.mk_projection(a.item_def_id, a.substs);\n+        let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Types(ExpectedFound::new(a_is_expected, a_ty, b_ty)),\n+        }\n+    }\n+}"}, {"sha": "7fe1e848d525ade36979328e541fc19a210f693f", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -1,5 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n@@ -405,14 +406,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         {\n                             // Synthesize the associated type restriction `Add<Output = Expected>`.\n                             // FIXME: extract this logic for use in other diagnostics.\n-                            let trait_ref = proj.trait_ref(self);\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n                             let path =\n                                 self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n                             let item_name = self.item_name(proj.item_def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n                             let path = if path.ends_with('>') {\n-                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n                             } else {\n-                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n                             };\n                             note = !suggest_constraining_type_param(\n                                 self,\n@@ -561,7 +570,7 @@ impl<T> Trait<T> for X {\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n-        let trait_ref = proj_ty.trait_ref(self);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n@@ -595,6 +604,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             pred.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         ) {\n@@ -612,6 +622,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             param.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         );\n@@ -697,6 +708,7 @@ impl<T> Trait<T> for X {\n                 db,\n                 self.def_span(def_id),\n                 &assoc,\n+                proj_ty.trait_ref_and_own_substs(self).1,\n                 values.found,\n                 &msg,\n             ) {\n@@ -861,6 +873,7 @@ fn foo(&self) -> Self::T { String::new() }\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -870,7 +883,12 @@ fn foo(&self) -> Self::T { String::new() }\n                 // Relate the type param against `T` in `<A as T>::Foo`.\n                 ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n                     && self.constrain_associated_type_structured_suggestion(\n-                        db, ptr.span, assoc, ty, msg,\n+                        db,\n+                        ptr.span,\n+                        assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n                     )\n             }\n             _ => false,\n@@ -884,6 +902,7 @@ fn foo(&self) -> Self::T { String::new() }\n         db: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -895,11 +914,20 @@ fn foo(&self) -> Self::T { String::new() }\n                 let span = Span::new(pos, pos, span.ctxt());\n                 (span, format!(\", {} = {}\", assoc.ident, ty))\n             } else {\n-                (span.shrink_to_hi(), format!(\"<{} = {}>\", assoc.ident, ty))\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident, item_args, ty))\n             };\n             db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;\n         }\n         false\n     }\n+\n+    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        let mut item_args = String::new();\n+        FmtPrinter::new(self, &mut item_args, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\");\n+        item_args\n+    }\n }"}, {"sha": "b7f62437fa5a86379a79f1728eb076100a914599", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -1289,8 +1289,22 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n+    /// Returns the `DefId` of the trait of the associated item being projected.\n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.skip_binder().projection_ty.trait_def_id(tcx)\n+    }\n+\n+    #[inline]\n+    pub fn projection_self_ty(&self) -> Binder<Ty<'tcx>> {\n+        self.map_bound(|predicate| predicate.projection_ty.self_ty())\n+    }\n+\n+    /// Get the [PolyTraitRef] required for this projection to be well formed.\n+    /// Note that for generic associated types the predicates of the associated\n+    /// type also need to be checked.\n+    #[inline]\n+    pub fn required_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our"}, {"sha": "bbf64c69d83bd399f2ccb57e6cb3dbe465869693", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -17,7 +17,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1112,36 +1112,35 @@ pub struct ProjectionTy<'tcx> {\n }\n \n impl<'tcx> ProjectionTy<'tcx> {\n-    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n-    /// associated item named `item_name`.\n-    pub fn from_ref_and_name(\n-        tcx: TyCtxt<'_>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        item_name: Ident,\n-    ) -> ProjectionTy<'tcx> {\n-        let item_def_id = tcx\n-            .associated_items(trait_ref.def_id)\n-            .find_by_name_and_kind(tcx, item_name, ty::AssocKind::Type, trait_ref.def_id)\n-            .unwrap()\n-            .def_id;\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        tcx.associated_item(self.item_def_id).container.id()\n+    }\n \n-        ProjectionTy { substs: trait_ref.substs, item_def_id }\n+    /// Extracts the underlying trait reference and own substs from this projection.\n+    /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n+    /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n+    pub fn trait_ref_and_own_substs(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n+        let def_id = tcx.associated_item(self.item_def_id).container.id();\n+        let trait_generics = tcx.generics_of(def_id);\n+        (\n+            ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, trait_generics) },\n+            &self.substs[trait_generics.count()..],\n+        )\n     }\n \n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n+    ///\n+    /// WARNING: This will drop the substs for generic associated types\n+    /// consider calling [Self::trait_ref_and_own_substs] to get those\n+    /// as well.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n-        // FIXME: This method probably shouldn't exist at all, since it's not\n-        // clear what this method really intends to do. Be careful when\n-        // using this method since the resulting TraitRef additionally\n-        // contains the substs for the assoc_item, which strictly speaking\n-        // is not correct\n-        let def_id = tcx.associated_item(self.item_def_id).container.id();\n-        // Include substitutions for generic arguments of associated types\n-        let assoc_item = tcx.associated_item(self.item_def_id);\n-        let substs_assoc_item = self.substs.truncate_to(tcx, tcx.generics_of(assoc_item.def_id));\n-        ty::TraitRef { def_id, substs: substs_assoc_item }\n+        let def_id = self.trait_def_id(tcx);\n+        ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, tcx.generics_of(def_id)) }\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1493,12 +1492,11 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::ExistentialTraitRef<'tcx> {\n-        // FIXME(generic_associated_types): substs is the substs of the\n-        // associated type, which should be truncated to get the correct substs\n-        // for the trait.\n+    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n-        ty::ExistentialTraitRef { def_id, substs: self.substs }\n+        let subst_count = tcx.generics_of(def_id).count() - 1;\n+        let substs = tcx.intern_substs(&self.substs[..subst_count]);\n+        ty::ExistentialTraitRef { def_id, substs }\n     }\n \n     pub fn with_self_ty(\n@@ -1517,6 +1515,20 @@ impl<'tcx> ExistentialProjection<'tcx> {\n             ty: self.ty,\n         }\n     }\n+\n+    pub fn erase_self_ty(\n+        tcx: TyCtxt<'tcx>,\n+        projection_predicate: ty::ProjectionPredicate<'tcx>,\n+    ) -> Self {\n+        // Assert there is a Self.\n+        projection_predicate.projection_ty.substs.type_at(0);\n+\n+        Self {\n+            item_def_id: projection_predicate.projection_ty.item_def_id,\n+            substs: tcx.intern_substs(&projection_predicate.projection_ty.substs[1..]),\n+            ty: projection_predicate.ty,\n+        }\n+    }\n }\n \n impl<'tcx> PolyExistentialProjection<'tcx> {"}, {"sha": "6e0e1c5eeef1524c43c1bcece6f5c0422c2df50d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -77,6 +77,12 @@ trait DefIdVisitor<'tcx> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.skeleton().visit_projection_ty(projection)\n+    }\n     fn visit_predicates(\n         &mut self,\n         predicates: ty::GenericPredicates<'tcx>,\n@@ -101,14 +107,28 @@ where\n         if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<V::BreakTy> {\n+        let (trait_ref, assoc_substs) =\n+            projection.trait_ref_and_own_substs(self.def_id_visitor.tcx());\n+        self.visit_trait(trait_ref)?;\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::CONTINUE\n+        } else {\n+            assoc_substs.iter().try_for_each(|subst| subst.visit_with(self))\n+        }\n+    }\n+\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n             ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)?;\n-                self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+                self.visit_projection_ty(projection_ty)\n             }\n             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n@@ -197,7 +217,7 @@ where\n                     return ControlFlow::CONTINUE;\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n-                return self.visit_trait(proj.trait_ref(tcx));\n+                return self.visit_projection_ty(proj);\n             }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n@@ -1203,10 +1223,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n-                let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty).is_break()\n                     || self\n-                        .visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                        .visit_projection_ty(poly_predicate.skip_binder().projection_ty)\n                         .is_break()\n                 {\n                     return;"}, {"sha": "3f24a33f7d57074be463fb87460f02063da359e9", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -6,7 +6,6 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n #[derive(Copy, Clone, Debug)]\n@@ -146,11 +145,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         let normalized_ty = fulfillcx.normalize_projection_type(\n             &self.infcx,\n             self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(\n-                tcx,\n-                trait_ref,\n-                Ident::with_dummy_span(sym::Target),\n-            ),\n+            ty::ProjectionTy {\n+                item_def_id: tcx.lang_items().deref_target()?,\n+                substs: trait_ref.substs,\n+            },\n             cause,\n         );\n         if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {"}, {"sha": "e9aaa65256419773b1b91c922c3184cc18683e3e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -1589,8 +1589,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), vec![], ErrorCode::E0282)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n+                let self_ty = data.projection_ty.self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {\n                     return;"}, {"sha": "3d9f98273db79099eabe4ad60c0a9c1a25b7f8dc", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n@@ -633,9 +634,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // only reason we can fail to make progress on\n                 // trait selection is because we don't have enough\n                 // information about the types in the trait.\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref),\n+                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),\n                 );\n \n                 debug!(\n@@ -663,9 +664,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n             Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),\n             Ok(Ok(None)) => {\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    project_obligation.predicate.to_poly_trait_ref(tcx),\n+                    project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),\n                 );\n                 ProcessResult::Unchanged\n             }\n@@ -678,16 +679,15 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of inference variables contained in a trait ref.\n-fn trait_ref_infer_vars<'a, 'tcx>(\n+/// Returns the set of inference variables contained in `substs`.\n+fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    substs: ty::Binder<SubstsRef<'tcx>>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n-        .resolve_vars_if_possible(trait_ref)\n-        .skip_binder()\n-        .substs\n+        .resolve_vars_if_possible(substs)\n+        .skip_binder() // ok because this check doesn't care about regions\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that\n         // doesn't contain inference variables, not just the outermost level."}, {"sha": "7de20e477fe0479769be5d14a9ecdaf44c00d2f0", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -292,11 +292,7 @@ fn predicate_references_self(\n             //\n             // This is ALT2 in issue #56288, see that for discussion of the\n             // possible alternatives.\n-            if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n-                Some(sp)\n-            } else {\n-                None\n-            }\n+            if data.projection_ty.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "0af6d6459159e6d10bd73a586d6fddd20d3fda4f", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -741,11 +741,7 @@ fn project_type<'cx, 'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n-    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n-\n-    debug!(?obligation_trait_ref);\n-\n-    if obligation_trait_ref.references_error() {\n+    if obligation.predicate.references_error() {\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n@@ -754,19 +750,19 @@ fn project_type<'cx, 'tcx>(\n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n     // the return value of push_candidate which assumes it's ran at last.\n-    assemble_candidates_from_param_env(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_param_env(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_trait_def(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_object_ty(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n \n     if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n         // Avoid normalization cycle from selection (see\n         // `assemble_candidates_from_object_ty`).\n         // FIXME(lazy_normalization): Lazy normalization should save us from\n-        // having to do special case this.\n+        // having to special case this.\n     } else {\n-        assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+        assemble_candidates_from_impls(selcx, obligation, &mut candidates);\n     };\n \n     match candidates {\n@@ -792,14 +788,12 @@ fn project_type<'cx, 'tcx>(\n fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n@@ -820,15 +814,14 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let bounds = match *obligation_trait_ref.self_ty().kind() {\n+    let bounds = match *obligation.predicate.self_ty().kind() {\n         ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n         ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n@@ -843,7 +836,6 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n         bounds.iter(),\n@@ -863,14 +855,13 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_object_ty(..)\");\n \n     let tcx = selcx.tcx();\n \n-    let self_ty = obligation_trait_ref.self_ty();\n+    let self_ty = obligation.predicate.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n@@ -890,7 +881,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::Object,\n         env_predicates,\n@@ -901,7 +891,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n@@ -921,8 +910,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                 && infcx.probe(|_| {\n                     selcx.match_projection_projections(\n                         obligation,\n-                        obligation_trait_ref,\n-                        &data,\n+                        data,\n                         potentially_unnormalized_candidates,\n                     )\n                 });\n@@ -948,14 +936,13 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_impls\");\n \n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n+    let poly_trait_ref = obligation.predicate.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let _ = selcx.infcx().commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n@@ -1410,25 +1397,25 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n         poly_cache_entry,\n     );\n \n-    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n-    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    let cache_projection = cache_entry.projection_ty;\n+    let obligation_projection = obligation.predicate;\n     let mut nested_obligations = Vec::new();\n-    let cache_trait_ref = if potentially_unnormalized_candidate {\n+    let cache_projection = if potentially_unnormalized_candidate {\n         ensure_sufficient_stack(|| {\n             normalize_with_depth_to(\n                 selcx,\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                cache_trait_ref,\n+                cache_projection,\n                 &mut nested_obligations,\n             )\n         })\n     } else {\n-        cache_trait_ref\n+        cache_projection\n     };\n \n-    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n+    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);"}, {"sha": "45b5aff40a6d277b6c1bbf14497c4850451922cd", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -32,6 +32,7 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Constness;\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n@@ -1254,32 +1255,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub(super) fn match_projection_projections(\n         &mut self,\n         obligation: &ProjectionTyObligation<'tcx>,\n-        obligation_trait_ref: &ty::TraitRef<'tcx>,\n-        data: &PolyProjectionPredicate<'tcx>,\n+        env_predicate: PolyProjectionPredicate<'tcx>,\n         potentially_unnormalized_candidates: bool,\n     ) -> bool {\n         let mut nested_obligations = Vec::new();\n-        let projection_ty = if potentially_unnormalized_candidates {\n+        let (infer_predicate, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+            obligation.cause.span,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            env_predicate,\n+        );\n+        let infer_projection = if potentially_unnormalized_candidates {\n             ensure_sufficient_stack(|| {\n                 project::normalize_with_depth_to(\n                     self,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    data.map_bound(|data| data.projection_ty),\n+                    infer_predicate.projection_ty,\n                     &mut nested_obligations,\n                 )\n             })\n         } else {\n-            data.map_bound(|data| data.projection_ty)\n+            infer_predicate.projection_ty\n         };\n \n-        // FIXME(generic_associated_types): Compare the whole projections\n-        let data_poly_trait_ref = projection_ty.map_bound(|proj| proj.trait_ref(self.tcx()));\n-        let obligation_poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+            .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),"}, {"sha": "fdf5f697e61178910b203811739878a5ad88f265", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -779,14 +779,11 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>> {\n-        let trait_ref = self.projection_ty.trait_ref(interner.tcx);\n+        let (trait_ref, own_substs) = self.projection_ty.trait_ref_and_own_substs(interner.tcx);\n         chalk_solve::rust_ir::AliasEqBound {\n             trait_bound: trait_ref.lower_into(interner),\n             associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n-            parameters: self.projection_ty.substs[trait_ref.substs.len()..]\n-                .iter()\n-                .map(|arg| arg.lower_into(interner))\n-                .collect(),\n+            parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n             value: self.ty.lower_into(interner),\n         }\n     }"}, {"sha": "ce187ab93a9e1cd2d832336076a88397681d500b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -985,10 +985,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         //\n         // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n \n-        debug!(\n-            \"add_predicates_for_ast_type_binding(hir_ref_id {:?}, trait_ref {:?}, binding {:?}, bounds {:?}\",\n-            hir_ref_id, trait_ref, binding, bounds\n-        );\n+        debug!(?hir_ref_id, ?trait_ref, ?binding, ?bounds, \"add_predicates_for_ast_type_binding\",);\n         let tcx = self.tcx();\n \n         let candidate =\n@@ -1326,37 +1323,35 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(\"regular_traits: {:?}\", regular_traits);\n         debug!(\"auto_traits: {:?}\", auto_traits);\n \n-        // Transform a `PolyTraitRef` into a `PolyExistentialTraitRef` by\n-        // removing the dummy `Self` type (`trait_object_dummy_self`).\n-        let trait_ref_to_existential = |trait_ref: ty::TraitRef<'tcx>| {\n-            if trait_ref.self_ty() != dummy_self {\n-                // FIXME: There appears to be a missing filter on top of `expand_trait_aliases`,\n-                // which picks up non-supertraits where clauses - but also, the object safety\n-                // completely ignores trait aliases, which could be object safety hazards. We\n-                // `delay_span_bug` here to avoid an ICE in stable even when the feature is\n-                // disabled. (#66420)\n-                tcx.sess.delay_span_bug(\n-                    DUMMY_SP,\n-                    &format!(\n-                        \"trait_ref_to_existential called on {:?} with non-dummy Self\",\n-                        trait_ref,\n-                    ),\n-                );\n-            }\n-            ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n-        };\n-\n         // Erase the `dummy_self` (`trait_object_dummy_self`) used above.\n-        let existential_trait_refs =\n-            regular_traits.iter().map(|i| i.trait_ref().map_bound(trait_ref_to_existential));\n+        let existential_trait_refs = regular_traits.iter().map(|i| {\n+            i.trait_ref().map_bound(|trait_ref: ty::TraitRef<'tcx>| {\n+                if trait_ref.self_ty() != dummy_self {\n+                    // FIXME: There appears to be a missing filter on top of `expand_trait_aliases`,\n+                    // which picks up non-supertraits where clauses - but also, the object safety\n+                    // completely ignores trait aliases, which could be object safety hazards. We\n+                    // `delay_span_bug` here to avoid an ICE in stable even when the feature is\n+                    // disabled. (#66420)\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\n+                            \"trait_ref_to_existential called on {:?} with non-dummy Self\",\n+                            trait_ref,\n+                        ),\n+                    );\n+                }\n+                ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n+            })\n+        });\n         let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n-                let trait_ref = trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n+                if b.projection_ty.self_ty() != dummy_self {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", b),\n+                    );\n                 }\n+                ty::ExistentialProjection::erase_self_ty(tcx, b)\n             })\n         });\n "}, {"sha": "431e6d70ff35c7815db140bc3275daf8b7977626", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur if there is a trait-reference\n+        // infer the kind. This can occur when we elaborate a predicate\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n@@ -234,11 +234,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n \n-        let trait_ref = projection.to_poly_trait_ref(tcx);\n+        let trait_def_id = projection.trait_def_id(tcx);\n \n-        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n-        let is_gen = gen_trait == trait_ref.def_id();\n+        let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");\n             return None;\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let input_tys = if is_fn {\n-            let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n+            let arg_param_ty = projection.skip_binder().projection_ty.substs.type_at(1);\n             let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n@@ -662,9 +662,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Check that this is a projection from the `Future` trait.\n-        let trait_ref = predicate.projection_ty.trait_ref(self.tcx);\n+        let trait_def_id = predicate.projection_ty.trait_def_id(self.tcx);\n         let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(cause_span));\n-        if trait_ref.def_id != future_trait {\n+        if trait_def_id != future_trait {\n             debug!(\"deduce_future_output_from_projection: not a future\");\n             return None;\n         }"}, {"sha": "7f27325f7f96ffdb9840e502c1cb673bd63dbfba", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -769,9 +769,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter_map(move |obligation| {\n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(self.tcx), obligation))\n-                    }\n+                    ty::PredicateKind::Projection(data) => Some((\n+                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n+                        obligation,\n+                    )),\n                     ty::PredicateKind::Trait(data, _) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }"}, {"sha": "0134266fab56d12c1388c58165426bfc70269c1b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -23,6 +23,7 @@ use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n \n use std::cmp::Ordering;\n+use std::iter;\n \n use super::probe::Mode;\n use super::{CandidateSource, MethodError, NoMatchData};\n@@ -648,21 +649,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Projection(pred) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n-                                let trait_ref =\n-                                    pred.skip_binder().projection_ty.trait_ref(self.tcx);\n-                                let assoc = self\n-                                    .tcx\n-                                    .associated_item(pred.skip_binder().projection_ty.item_def_id);\n-                                let ty = pred.skip_binder().ty;\n-                                let obligation = format!(\"{}::{} = {}\", trait_ref, assoc.ident, ty);\n-                                let quiet = format!(\n-                                    \"<_ as {}>::{} = {}\",\n-                                    trait_ref.print_only_trait_path(),\n-                                    assoc.ident,\n-                                    ty\n+                                let projection_ty = pred.skip_binder().projection_ty;\n+\n+                                let substs_with_infer_self = tcx.mk_substs(\n+                                    iter::once(tcx.mk_ty_var(ty::TyVid { index: 0 }).into())\n+                                        .chain(projection_ty.substs.iter().skip(1)),\n                                 );\n-                                bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n-                                Some((obligation, trait_ref.self_ty()))\n+\n+                                let quiet_projection_ty = ty::ProjectionTy {\n+                                    substs: substs_with_infer_self,\n+                                    item_def_id: projection_ty.item_def_id,\n+                                };\n+\n+                                let ty = pred.skip_binder().ty;\n+\n+                                let obligation = format!(\"{} = {}\", projection_ty, ty);\n+                                let quiet = format!(\"{} = {}\", quiet_projection_ty, ty);\n+\n+                                bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                                Some((obligation, projection_ty.self_ty()))\n                             }\n                             ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.trait_ref;"}, {"sha": "529de1a2874841b6055b333fb6f2a240cc0a163f", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -198,7 +198,7 @@ pub fn setup_constraining_predicates<'tcx>(\n                 //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n-                let inputs = parameters_for(&projection.projection_ty.trait_ref(tcx), true);\n+                let inputs = parameters_for(&projection.projection_ty, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;"}, {"sha": "2419771eae212fa79ef30efdcab1fdf0d951cd6e", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -64,6 +64,7 @@ pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_diagnostic_item = \"deref_target\"]\n+    #[cfg_attr(not(bootstrap), lang = \"deref_target\")]\n     type Target: ?Sized;\n \n     /// Dereferences the value."}, {"sha": "8877c6cc9927b9111e1afaf0994a20f110c61343", "filename": "src/test/pretty/gat-bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fpretty%2Fgat-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fpretty%2Fgat-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fgat-bounds.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -13,4 +13,6 @@ impl X for () {\n     type Y<T> where Self: Sized = u32;\n }\n \n+fn f<T: X<Y<()> = i32>>() {}\n+\n fn main() { }"}, {"sha": "36db3d1bb9e4793da39e538383a55ea570befdc4", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,17 @@\n+// Test that correct syntax is used in suggestion to constrain associated type\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+fn f<T: X>(a: T::Y<i32>) {\n+    //~^ HELP consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+    //~| SUGGESTION Y<i32> = Vec<i32>>\n+    let b: Vec<i32> = a;\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "ecf559d9e94a1867d2b6a993e049deb76a24c860", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/constraint-assoc-type-suggestion.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0308]: mismatched types\n+  --> $DIR/constraint-assoc-type-suggestion.rs:13:23\n+   |\n+LL |     let b: Vec<i32> = a;\n+   |            --------   ^ expected struct `Vec`, found associated type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:       expected struct `Vec<i32>`\n+           found associated type `<T as X>::Y<i32>`\n+help: consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+   |\n+LL | fn f<T: X<Y<i32> = Vec<i32>>>(a: T::Y<i32>) {\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8094450e5e137dfb9c93bd1b9df2f449d95cfe54", "filename": "src/test/ui/generic-associated-types/generic-associated-type-bounds.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a>;\n+    fn m(&self) -> Self::Y<'_>;\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+\n+    fn m(&self) -> Self::Y<'_> {\n+        self\n+    }\n+}\n+\n+fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &() {\n+    x.m()\n+}\n+\n+fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &() {\n+    x.m()\n+}\n+\n+fn h(x: &()) -> &() {\n+    x.m()\n+}\n+\n+fn main() {\n+    f(&());\n+    g(&());\n+    h(&());\n+}"}, {"sha": "5e73a8829862233ca6242d7087979ae55e8a79ec", "filename": "src/test/ui/generic-associated-types/issue-76535.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -1,11 +1,11 @@\n #![feature(generic_associated_types)]\n- //~^ WARNING the feature\n+//~^ WARNING the feature\n \n pub trait SubTrait {}\n \n pub trait SuperTrait {\n     type SubType<'a>: SubTrait;\n-      //~^ ERROR missing generics for associated\n+    //~^ ERROR missing generics for associated\n \n     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n }\n@@ -36,6 +36,4 @@ impl SuperTrait for SuperStruct {\n \n fn main() {\n     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-      //~^ ERROR the trait\n-      //~| ERROR the trait\n }"}, {"sha": "17661e0d90a4aecf2b550d95f27498ba38f4ea3e", "filename": "src/test/ui/generic-associated-types/issue-76535.stderr", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -23,41 +23,6 @@ help: use angle brackets to add missing lifetime argument\n LL |     type SubType<'a><'a>: SubTrait;\n    |                 ^^^^\n \n-error[E0038]: the trait `SuperTrait` cannot be made into an object\n-  --> $DIR/issue-76535.rs:38:14\n-   |\n-LL |     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SuperTrait` cannot be made into an object\n-   |\n-   = help: consider moving `get_sub` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-76535.rs:10:37\n-   |\n-LL | pub trait SuperTrait {\n-   |           ---------- this trait cannot be made into an object...\n-...\n-LL |     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n-   |                                     ^^^^^^^^^^^^^^^^^ ...because method `get_sub` references the `Self` type in its return type\n-\n-error[E0038]: the trait `SuperTrait` cannot be made into an object\n-  --> $DIR/issue-76535.rs:38:57\n-   |\n-LL |     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SuperTrait` cannot be made into an object\n-   |\n-   = help: consider moving `get_sub` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-76535.rs:10:37\n-   |\n-LL | pub trait SuperTrait {\n-   |           ---------- this trait cannot be made into an object...\n-...\n-LL |     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n-   |                                     ^^^^^^^^^^^^^^^^^ ...because method `get_sub` references the `Self` type in its return type\n-   = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn SuperTrait<SubType = SubStruct<'_>>>>` for `Box<SuperStruct>`\n-   = note: required by cast to type `Box<dyn SuperTrait<SubType = SubStruct<'_>>>`\n-\n-error: aborting due to 3 previous errors; 1 warning emitted\n+error: aborting due to previous error; 1 warning emitted\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "aeb33ca54641cc399daa00c0ef7209194e4aba85", "filename": "src/test/ui/generic-associated-types/issue-79422.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -19,7 +19,7 @@ impl<'a, T> RefCont<'a, T> for Box<T> {\n \n trait MapLike<K, V> {\n     type VRefCont<'a>: RefCont<'a, V>;\n-      //~^ ERROR missing generics\n+    //~^ ERROR missing generics\n     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n }\n \n@@ -42,6 +42,5 @@ impl<K, V: Default> MapLike<K, V> for Source {\n fn main() {\n     let m = Box::new(std::collections::BTreeMap::<u8, u8>::new())\n         as Box<dyn MapLike<u8, u8, VRefCont = dyn RefCont<'_, u8>>>;\n-      //~^ ERROR the trait\n-      //~^^^ ERROR the trait\n+    //~^^ ERROR type mismatch resolving\n }"}, {"sha": "a119bff03e2906e68bf67f30895e0ea4e9b110a1", "filename": "src/test/ui/generic-associated-types/issue-79422.stderr", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -14,41 +14,17 @@ help: use angle brackets to add missing lifetime argument\n LL |     type VRefCont<'a><'a>: RefCont<'a, V>;\n    |                  ^^^^\n \n-error[E0038]: the trait `MapLike` cannot be made into an object\n-  --> $DIR/issue-79422.rs:44:12\n-   |\n-LL |         as Box<dyn MapLike<u8, u8, VRefCont = dyn RefCont<'_, u8>>>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MapLike` cannot be made into an object\n-   |\n-   = help: consider moving `get` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-79422.rs:23:38\n-   |\n-LL | trait MapLike<K, V> {\n-   |       ------- this trait cannot be made into an object...\n-...\n-LL |     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...because method `get` references the `Self` type in its return type\n-\n-error[E0038]: the trait `MapLike` cannot be made into an object\n+error[E0271]: type mismatch resolving `<BTreeMap<u8, u8> as MapLike<u8, u8>>::VRefCont<'static> == (dyn RefCont<'_, u8> + 'static)`\n   --> $DIR/issue-79422.rs:43:13\n    |\n LL |     let m = Box::new(std::collections::BTreeMap::<u8, u8>::new())\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MapLike` cannot be made into an object\n-   |\n-   = help: consider moving `get` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-79422.rs:23:38\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn RefCont`, found reference\n    |\n-LL | trait MapLike<K, V> {\n-   |       ------- this trait cannot be made into an object...\n-...\n-LL |     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...because method `get` references the `Self` type in its return type\n-   = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>>>` for `Box<BTreeMap<u8, u8>>`\n-   = note: required by cast to type `Box<dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>>`\n+   = note: expected trait object `(dyn RefCont<'_, u8> + 'static)`\n+                 found reference `&'static u8`\n+   = note: required for the cast to the object type `dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+Some errors have detailed explanations: E0107, E0271.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "2de4c7b8492a34244977ccc8ec7618220b47ca92", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,35 @@\n+// Test that the predicate printed in an unresolved method error prints the\n+// generics for a generic associated type.\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+//~| NOTE `#[warn(incomplete_features)]` on by default\n+//~| NOTE see issue #44265\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+trait M {\n+    fn f(&self) {}\n+}\n+\n+impl<T: X<Y<i32> = i32>> M for T {}\n+\n+struct S;\n+//~^ NOTE method `f` not found for this\n+//~| NOTE doesn't satisfy `<S as X>::Y<i32> = i32`\n+//~| NOTE doesn't satisfy `S: M`\n+\n+impl X for S {\n+    type Y<T> = bool;\n+}\n+\n+fn f(a: S) {\n+    a.f();\n+    //~^ ERROR the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+    //~| NOTE method cannot be called on `S` due to unsatisfied trait bounds\n+    //~| NOTE the following trait bounds were not satisfied:\n+}\n+\n+fn main() {}"}, {"sha": "c94155d13c344a78f3889f4a2d5cf3a645883a4e", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:4:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:29:7\n+   |\n+LL | struct S;\n+   | ---------\n+   | |\n+   | method `f` not found for this\n+   | doesn't satisfy `<S as X>::Y<i32> = i32`\n+   | doesn't satisfy `S: M`\n+...\n+LL |     a.f();\n+   |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `<S as X>::Y<i32> = i32`\n+           which is required by `S: M`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "0024e127a982c94f65899d927be8c4b733b6d735", "filename": "src/test/ui/generic-associated-types/projection-type-lifetime-mismatch.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,36 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a>;\n+    fn m(&self) -> Self::Y<'_>;\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+\n+    fn m(&self) -> Self::Y<'_> {\n+        self\n+    }\n+}\n+\n+fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn h(x: &()) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn main() {\n+    f(&());\n+    g(&());\n+    h(&());\n+}"}, {"sha": "13b765dfa57191e8d1aa59ea89233afa283c56b8", "filename": "src/test/ui/generic-associated-types/projection-type-lifetime-mismatch.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,27 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:18:5\n+   |\n+LL | fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &'static () {\n+   |         ------------------------------- help: add explicit lifetime `'static` to the type of `x`: `&'static impl for<'a> X<Y<'a> = &'a ()>`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:23:5\n+   |\n+LL | fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &'static () {\n+   |                                       -- help: add explicit lifetime `'static` to the type of `x`: `&'static T`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:28:5\n+   |\n+LL | fn h(x: &()) -> &'static () {\n+   |         --- help: add explicit lifetime `'static` to the type of `x`: `&'static ()`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "7bcc7ba752ad04b8c263c5ebf43ee93cea172f6d", "filename": "src/test/ui/generic-associated-types/unsatified-item-lifetime-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,28 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a: 'static>;\n+    //~^ WARNING unnecessary lifetime parameter\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+}\n+\n+struct B<'a, T: for<'r> X<Y<'r> = &'r ()>> {\n+    f: <T as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+struct C<'a, T: X> {\n+    f: <T as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+struct D<'a> {\n+    f: <() as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "1c81d33ccfe7280f423c70a63d716a7d2cbb3dfd", "filename": "src/test/ui/generic-associated-types/unsatified-item-lifetime-bound.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66211f6657971bdaf18996400435b6a416aa3343/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr?ref=66211f6657971bdaf18996400435b6a416aa3343", "patch": "@@ -0,0 +1,50 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/unsatified-item-lifetime-bound.rs:5:12\n+   |\n+LL |     type Y<'a: 'static>;\n+   |            ^^^^^^^^^^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:14:8\n+   |\n+LL |     f: <T as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 13:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:13:10\n+   |\n+LL | struct B<'a, T: for<'r> X<Y<'r> = &'r ()>> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:19:8\n+   |\n+LL |     f: <T as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 18:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:18:10\n+   |\n+LL | struct C<'a, T: X> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:24:8\n+   |\n+LL |     f: <() as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 23:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:23:10\n+   |\n+LL | struct D<'a> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0478`."}]}