{"sha": "a5c333c3ed98d539fcadcc723e992f5295d22d5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YzMzM2MzZWQ5OGQ1MzlmY2FkY2M3MjNlOTkyZjUyOTVkMjJkNWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-08T16:10:20Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-08T16:10:40Z"}, "message": "Fix yet another parser infinite loop\n\nThis commit is an example of fixing a common parser error: infinite\nloop due to error recovery.\n\nThis error typically happens when we parse a list of items and fail to\nparse a specific item at the current position.\n\nOne choices is to skip a token and try to parse a list item at the\nnext position. This is a good, but not universal, default. When\nparsing a list of arguments in a function call, you, for example,\ndon't want to skip over `fn`, because it's most likely that it is a\nfunction declaration, and not a mistyped arg:\n\n```\nfn foo() {\n    quux(1, 2\n\nfn bar() {\n}\n```\n\nAnother choice is to bail out of the loop immediately, but it isn't\nperfect either: sometimes skipping over garbage helps:\n\n```\nquux(1, foo:, 92) // should skip over `:`, b/c that's part of `foo::bar`\n```\n\nIn general, parser tries to balance these two cases, though we don't\nhave a definitive strategy yet.\n\nHowever, if the parser accidentally neither skips over a token, nor\nbreaks out of the loop, then it becomes stuck in the loop infinitely\n(there's an internal counter to self-check this situation and panic\nthough), and that's exactly what is demonstrated by the test.\n\nTo fix such situation, first of all, add the test case to tests/data/parser/{err,fuzz-failures}.\n\nThen, run\n\n```\nRUST_BACKTRACE=short cargo test --package libsyntax2\n````\n\nto verify that parser indeed panics, and to get an idea what grammar\nproduction is the culprit (look for `_list` functions!).\n\nIn this case, I see\n\n```\n  10: libsyntax2::grammar::expressions::atom::match_arm_list\n             at crates/libsyntax2/src/grammar/expressions/atom.rs:309\n```\n\nand that's look like it might be a culprit. I verify it by adding\n`eprintln!(\"loopy {:?}\", p.current());` and indeed I see that this is\nprinted repeatedly.\n\nDiagnosing this a bit shows that the problem is that\n`pattern::pattern` function does not consume anything if the next\ntoken is `let`. That is a good default to make cases like\n\n```\nlet\nlet foo = 92;\n```\n\nwhere the user hasn't typed the pattern yet, to parse in a reasonable\nthey correctly.\n\nFor match arms, pretty much the single thing we expect is a pattern,\nso, for a fix, I introduce a special variant of pattern that does not\ndo recovery.", "tree": {"sha": "30ced64ce9e769e1dfb1242685bb9c46bfd92f19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ced64ce9e769e1dfb1242685bb9c46bfd92f19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c333c3ed98d539fcadcc723e992f5295d22d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c333c3ed98d539fcadcc723e992f5295d22d5c", "html_url": "https://github.com/rust-lang/rust/commit/a5c333c3ed98d539fcadcc723e992f5295d22d5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c333c3ed98d539fcadcc723e992f5295d22d5c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "html_url": "https://github.com/rust-lang/rust/commit/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "8335c700f8ae162d38891146d169743af37f7666", "filename": "crates/libsyntax2/src/grammar/expressions/atom.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5c333c3ed98d539fcadcc723e992f5295d22d5c/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c333c3ed98d539fcadcc723e992f5295d22d5c/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=a5c333c3ed98d539fcadcc723e992f5295d22d5c", "patch": "@@ -323,11 +323,9 @@ fn match_arm_list(p: &mut Parser) {\n // }\n fn match_arm(p: &mut Parser) -> BlockLike {\n     let m = p.start();\n-    loop {\n+    patterns::pattern_r(p, TokenSet::EMPTY);\n+    while p.eat(PIPE) {\n         patterns::pattern(p);\n-        if !p.eat(PIPE) {\n-            break;\n-        }\n     }\n     if p.eat(IF_KW) {\n         expr_no_struct(p);"}, {"sha": "29a55cb46d8c32a7d48e303d3d2e40b7a03e0c56", "filename": "crates/libsyntax2/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5c333c3ed98d539fcadcc723e992f5295d22d5c/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c333c3ed98d539fcadcc723e992f5295d22d5c/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=a5c333c3ed98d539fcadcc723e992f5295d22d5c", "patch": "@@ -8,15 +8,19 @@ pub(super) const PATTERN_FIRST: TokenSet =\n     ];\n \n pub(super) fn pattern(p: &mut Parser) {\n-    if let Some(lhs) = atom_pat(p) {\n+    pattern_r(p, PAT_RECOVERY_SET)\n+}\n+\n+pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n+    if let Some(lhs) = atom_pat(p, recovery_set) {\n         // test range_pat\n         // fn main() {\n         //     match 92 { 0 ... 100 => () }\n         // }\n         if p.at(DOTDOTDOT) {\n             let m = lhs.precede(p);\n             p.bump();\n-            atom_pat(p);\n+            atom_pat(p, recovery_set);\n             m.complete(p, RANGE_PAT);\n         }\n     }\n@@ -26,7 +30,7 @@ const PAT_RECOVERY_SET: TokenSet =\n     token_set![LET_KW, IF_KW, WHILE_KW, LOOP_KW, MATCH_KW, R_PAREN, COMMA];\n \n \n-fn atom_pat(p: &mut Parser) -> Option<CompletedMarker> {\n+fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let la0 = p.nth(0);\n     let la1 = p.nth(1);\n     if la0 == REF_KW || la0 == MUT_KW\n@@ -56,7 +60,7 @@ fn atom_pat(p: &mut Parser) -> Option<CompletedMarker> {\n         L_PAREN => tuple_pat(p),\n         L_BRACK => slice_pat(p),\n         _ => {\n-            p.err_recover(\"expected pattern\", PAT_RECOVERY_SET);\n+            p.err_recover(\"expected pattern\", recovery_set);\n             return None;\n         }\n     };"}]}