{"sha": "8c31412c2f84c7d76602b2598c5c1352da61d022", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzE0MTJjMmY4NGM3ZDc2NjAyYjI1OThjNWMxMzUyZGE2MWQwMjI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-04-07T14:19:44Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-04-07T21:55:45Z"}, "message": "Merge branch 'master' into ty-placeholder", "tree": {"sha": "cbc08b79f16f1533e27d84dee16e90f9f319a679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc08b79f16f1533e27d84dee16e90f9f319a679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c31412c2f84c7d76602b2598c5c1352da61d022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c31412c2f84c7d76602b2598c5c1352da61d022", "html_url": "https://github.com/rust-lang/rust/commit/8c31412c2f84c7d76602b2598c5c1352da61d022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c31412c2f84c7d76602b2598c5c1352da61d022/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b83352e44c36e81db7f00eb60e78ff3828c51c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b83352e44c36e81db7f00eb60e78ff3828c51c9e", "html_url": "https://github.com/rust-lang/rust/commit/b83352e44c36e81db7f00eb60e78ff3828c51c9e"}, {"sha": "4c59c92bc4d4d6e5b2b66c4cc08dd1a058283a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c59c92bc4d4d6e5b2b66c4cc08dd1a058283a0d", "html_url": "https://github.com/rust-lang/rust/commit/4c59c92bc4d4d6e5b2b66c4cc08dd1a058283a0d"}], "stats": {"total": 10639, "additions": 7310, "deletions": 3329}, "files": [{"sha": "3533f0df5d1ce82d13e9aa992c7ee62798b5aa0c", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -25,4 +25,4 @@\n \turl = https://github.com/rust-lang-nursery/reference.git\n [submodule \"book\"]\n \tpath = src/doc/book\n-\turl = https://github.com/rust-lang/book\n+\turl = https://github.com/rust-lang/book.git"}, {"sha": "0ffba70d2ef4401b85060756e1324316867370ff", "filename": ".travis.yml", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,19 +15,27 @@ matrix:\n     - env: IMAGE=arm-android\n     - env: IMAGE=armhf-gnu\n     - env: IMAGE=cross DEPLOY=1\n+    - env: IMAGE=dist-aarch64-linux DEPLOY=1\n     - env: IMAGE=dist-android DEPLOY=1\n     - env: IMAGE=dist-arm-linux DEPLOY=1\n-    - env: IMAGE=dist-armv7-aarch64-linux DEPLOY=1\n-    - env: IMAGE=dist-freebsd DEPLOY=1\n-    - env: IMAGE=dist-i586-gnu-i686-musl DEPLOY=1\n+    - env: IMAGE=dist-armhf-linux DEPLOY=1\n+    - env: IMAGE=dist-armv7-linux DEPLOY=1\n     - env: IMAGE=dist-fuchsia DEPLOY=1\n+    - env: IMAGE=dist-i586-gnu-i686-musl DEPLOY=1\n+    - env: IMAGE=dist-i686-freebsd DEPLOY=1\n+    - env: IMAGE=dist-i686-linux DEPLOY=1\n     - env: IMAGE=dist-mips-linux DEPLOY=1\n     - env: IMAGE=dist-mips64-linux DEPLOY=1\n+    - env: IMAGE=dist-mips64el-linux DEPLOY=1\n+    - env: IMAGE=dist-mipsel-linux DEPLOY=1\n     - env: IMAGE=dist-powerpc-linux DEPLOY=1\n     - env: IMAGE=dist-powerpc64-linux DEPLOY=1\n-    - env: IMAGE=dist-s390x-linux-netbsd DEPLOY=1\n-    - env: IMAGE=dist-x86-linux DEPLOY=1\n+    - env: IMAGE=dist-powerpc64le-linux DEPLOY=1\n+    - env: IMAGE=dist-s390x-linux DEPLOY=1\n+    - env: IMAGE=dist-x86_64-freebsd DEPLOY=1\n+    - env: IMAGE=dist-x86_64-linux DEPLOY=1\n     - env: IMAGE=dist-x86_64-musl DEPLOY=1\n+    - env: IMAGE=dist-x86_64-netbsd DEPLOY=1\n     - env: IMAGE=emscripten\n     - env: IMAGE=i686-gnu\n     - env: IMAGE=i686-gnu-nopt\n@@ -55,7 +63,7 @@ matrix:\n       os: osx\n       osx_image: xcode8.2\n       install: &osx_install_sccache >\n-        travis_retry curl -o /usr/local/bin/sccache https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-apple-darwin &&\n+        travis_retry curl -o /usr/local/bin/sccache https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-apple-darwin &&\n           chmod +x /usr/local/bin/sccache &&\n         travis_retry curl -o /usr/local/bin/stamp https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n           chmod +x /usr/local/bin/stamp\n@@ -104,7 +112,7 @@ matrix:\n     # turned on, they're deployed to a different location primarily for projects\n     # which are stuck on nightly and don't want llvm assertions in the artifacts\n     # that they use.\n-    - env: IMAGE=dist-x86-linux DEPLOY_ALT=1\n+    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n     - env: >\n         RUST_CHECK_TARGET=dist\n         RUST_CONFIGURE_ARGS=\"--enable-extended\""}, {"sha": "83cfea0dd834e519c67f143398eb655380b0d33a", "filename": "appveyor.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -115,8 +115,8 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-pc-windows-msvc\n-  - mv 2017-03-24-sccache-x86_64-pc-windows-msvc sccache.exe\n+  - appveyor-retry appveyor DownloadFile https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-pc-windows-msvc\n+  - mv 2017-04-04-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja"}, {"sha": "4729175045b41b688ab903120860866ce7a22ba9", "filename": "cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1 +1 @@\n-Subproject commit 4e95c6b41eca3388f54dd5f7787366ad2df637b5\n+Subproject commit 4729175045b41b688ab903120860866ce7a22ba9"}, {"sha": "526beb41aae5b6dc3a63e13173dd247a6c9058bd", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -163,12 +163,13 @@ def download_stage0(self):\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n \n+        channel = self.stage0_rustc_channel()\n+\n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n             self.print_what_it_means_to_bootstrap()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n-            channel = self.stage0_rustc_channel()\n             filename = \"rust-std-{}-{}.tar.gz\".format(channel, self.build)\n             url = \"https://static.rust-lang.org/dist/\" + self.stage0_rustc_date()\n             tarball = os.path.join(rustc_cache, filename)\n@@ -189,6 +190,14 @@ def download_stage0(self):\n             with open(self.rustc_stamp(), 'w') as f:\n                 f.write(self.stage0_rustc_date())\n \n+            if \"pc-windows-gnu\" in self.build:\n+                filename = \"rust-mingw-{}-{}.tar.gz\".format(channel, self.build)\n+                url = \"https://static.rust-lang.org/dist/\" + self.stage0_rustc_date()\n+                tarball = os.path.join(rustc_cache, filename)\n+                if not os.path.exists(tarball):\n+                    get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n+                unpack(tarball, self.bin_root(), match=\"rust-mingw\", verbose=self.verbose)\n+\n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n             self.print_what_it_means_to_bootstrap()\n@@ -591,16 +600,19 @@ def bootstrap():\n \n def main():\n     start_time = time()\n+    help_triggered = ('-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n         bootstrap()\n-        print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n+        if not help_triggered:\n+            print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n     except (SystemExit, KeyboardInterrupt) as e:\n         if hasattr(e, 'code') and isinstance(e.code, int):\n             exit_code = e.code\n         else:\n             exit_code = 1\n             print(e)\n-        print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n+        if not help_triggered:\n+            print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n         sys.exit(exit_code)\n \n if __name__ == '__main__':"}, {"sha": "308a0ab3076dd5421f90d17efe36562364214b8d", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -44,36 +44,38 @@ pub fn clean(build: &Build) {\n }\n \n fn rm_rf(path: &Path) {\n-    if !path.exists() {\n-        return\n-    }\n-    if path.is_file() {\n-        return do_op(path, \"remove file\", |p| fs::remove_file(p));\n-    }\n-\n-    for file in t!(fs::read_dir(path)) {\n-        let file = t!(file).path();\n+    match path.symlink_metadata() {\n+        Err(e) => {\n+            if e.kind() == ErrorKind::NotFound {\n+                return;\n+            }\n+            panic!(\"failed to get metadata for file {}: {}\", path.display(), e);\n+        },\n+        Ok(metadata) => {\n+            if metadata.file_type().is_file() || metadata.file_type().is_symlink() {\n+                do_op(path, \"remove file\", |p| fs::remove_file(p));\n+                return;\n+            }\n \n-        if file.is_dir() {\n-            rm_rf(&file);\n-        } else {\n-            // On windows we can't remove a readonly file, and git will\n-            // often clone files as readonly. As a result, we have some\n-            // special logic to remove readonly files on windows.\n-            do_op(&file, \"remove file\", |p| fs::remove_file(p));\n-        }\n-    }\n-    do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n+            for file in t!(fs::read_dir(path)) {\n+                rm_rf(&t!(file).path());\n+            }\n+            do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n+        },\n+    };\n }\n \n fn do_op<F>(path: &Path, desc: &str, mut f: F)\n     where F: FnMut(&Path) -> io::Result<()>\n {\n     match f(path) {\n         Ok(()) => {}\n+        // On windows we can't remove a readonly file, and git will often clone files as readonly.\n+        // As a result, we have some special logic to remove readonly files on windows.\n+        // This is also the reason that we can't use things like fs::remove_dir_all().\n         Err(ref e) if cfg!(windows) &&\n                       e.kind() == ErrorKind::PermissionDenied => {\n-            let mut p = t!(path.metadata()).permissions();\n+            let mut p = t!(path.symlink_metadata()).permissions();\n             p.set_readonly(false);\n             t!(fs::set_permissions(path, p));\n             f(path).unwrap_or_else(|e| {"}, {"sha": "a1466d68a135aa4950b13eb9771c182626c162a8", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 155, "deletions": 131, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -18,7 +18,7 @@ use std::fs;\n use std::path::PathBuf;\n use std::process;\n \n-use getopts::{Matches, Options};\n+use getopts::Options;\n \n use Build;\n use config::Config;\n@@ -75,7 +75,22 @@ pub enum Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n+        let mut extra_help = String::new();\n+        let mut subcommand_help = format!(\"\\\n+Usage: x.py <subcommand> [options] [<paths>...]\n+\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    bench       Build and run some benchmarks\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+\n         let mut opts = Options::new();\n+        // Options common to all subcommands\n         opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n         opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n@@ -89,21 +104,83 @@ impl Flags {\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |n, opts: &Options| -> ! {\n-            let command = args.get(0).map(|s| &**s);\n-            let brief = format!(\"Usage: x.py {} [options] [<args>...]\",\n-                                command.unwrap_or(\"<command>\"));\n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n+\n+        // We can't use getopt to parse the options until we have completed specifying which\n+        // options are valid, but under the current implementation, some options are conditional on\n+        // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n+        // complete the definition of the options.  Then we can use the getopt::Matches object from\n+        // there on out.\n+        let mut possible_subcommands = args.iter().collect::<Vec<_>>();\n+        possible_subcommands.retain(|&s|\n+                                           (s == \"build\")\n+                                        || (s == \"test\")\n+                                        || (s == \"bench\")\n+                                        || (s == \"doc\")\n+                                        || (s == \"clean\")\n+                                        || (s == \"dist\"));\n+        let subcommand = match possible_subcommands.first() {\n+            Some(s) => s,\n+            None => {\n+                // No subcommand -- show the general usage and subcommand help\n+                println!(\"{}\\n\", subcommand_help);\n+                process::exit(0);\n+            }\n+        };\n \n-            println!(\"{}\", opts.usage(&brief));\n-            match command {\n-                Some(\"build\") => {\n-                    println!(\"\\\n+        // Some subcommands get extra options\n+        match subcommand.as_str() {\n+            \"test\"  => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"dist\"  => { opts.optflag(\"\", \"install\", \"run installer as well\"); },\n+            _ => { },\n+        };\n+\n+        // Done specifying what options are possible, so do the getopts parsing\n+        let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n+            // Invalid argument/option format\n+            println!(\"\\n{}\\n\", e);\n+            usage(1, &opts, &subcommand_help, &extra_help);\n+        });\n+        // Extra sanity check to make sure we didn't hit this crazy corner case:\n+        //\n+        //     ./x.py --frobulate clean build\n+        //            ^-- option  ^     ^- actual subcommand\n+        //                        \\_ arg to option could be mistaken as subcommand\n+        let mut pass_sanity_check = true;\n+        match matches.free.get(0) {\n+            Some(check_subcommand) => {\n+                if &check_subcommand != subcommand {\n+                    pass_sanity_check = false;\n+                }\n+            },\n+            None => {\n+                pass_sanity_check = false;\n+            }\n+        }\n+        if !pass_sanity_check {\n+            println!(\"{}\\n\", subcommand_help);\n+            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                      You may need to move some options to after the subcommand.\\n\");\n+            process::exit(1);\n+        }\n+        // Extra help text for some commands\n+        match subcommand.as_str() {\n+            \"build\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories to\n-    the crates and/or artifacts to compile. For example:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n \n         ./x.py build src/libcore\n-        ./x.py build src/libproc_macro\n+        ./x.py build src/libcore src/libproc_macro\n         ./x.py build src/libstd --stage 1\n \n     If no arguments are passed then the complete artifacts for that stage are\n@@ -114,15 +191,13 @@ Arguments:\n \n     For a quick build with a usable compile, you can pass:\n \n-        ./x.py build --stage 1 src/libtest\n-\");\n-                }\n-\n-                Some(\"test\") => {\n-                    println!(\"\\\n+        ./x.py build --stage 1 src/libtest\");\n+            }\n+            \"test\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories to\n-    tests that should be compiled and run. For example:\n+    This subcommand accepts a number of paths to directories to tests that\n+    should be compiled and run. For example:\n \n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n@@ -132,171 +207,120 @@ Arguments:\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\n-\");\n-                }\n-\n-                Some(\"doc\") => {\n-                    println!(\"\\\n+        ./x.py test --stage 1\");\n+            }\n+            \"doc\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories of\n-    documentation to build. For example:\n+    This subcommand accepts a number of paths to directories of documentation\n+    to build. For example:\n \n         ./x.py doc src/doc/book\n         ./x.py doc src/doc/nomicon\n-        ./x.py doc src/libstd\n+        ./x.py doc src/doc/book src/libstd\n \n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\n-\");\n-                }\n-\n-                _ => {}\n+        ./x.py doc --stage 1\");\n             }\n-\n-            if let Some(command) = command {\n-                if command == \"build\" ||\n-                   command == \"dist\" ||\n-                   command == \"doc\" ||\n-                   command == \"test\" ||\n-                   command == \"bench\" ||\n-                   command == \"clean\"  {\n-                    println!(\"Available invocations:\");\n-                    if args.iter().any(|a| a == \"-v\") {\n-                        let flags = Flags::parse(&[\"build\".to_string()]);\n-                        let mut config = Config::default();\n-                        config.build = flags.build.clone();\n-                        let mut build = Build::new(flags, config);\n-                        metadata::build(&mut build);\n-                        step::build_rules(&build).print_help(command);\n-                    } else {\n-                        println!(\"    ... elided, run `./x.py {} -h -v` to see\",\n-                                 command);\n-                    }\n-\n-                    println!(\"\");\n-                }\n-            }\n-\n-println!(\"\\\n-Subcommands:\n-    build       Compile either the compiler or libraries\n-    test        Build and run some test suites\n-    bench       Build and run some benchmarks\n-    doc         Build documentation\n-    clean       Clean out build directories\n-    dist        Build and/or install distribution artifacts\n-\n-To learn more about a subcommand, run `./x.py <command> -h`\n-\");\n-\n-            process::exit(n);\n+            _ => { }\n         };\n-        if args.len() == 0 {\n-            println!(\"a command must be passed\");\n-            usage(1, &opts);\n-        }\n-        let parse = |opts: &Options| {\n-            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n-                println!(\"failed to parse options: {}\", e);\n-                usage(1, opts);\n-            });\n-            if m.opt_present(\"h\") {\n-                usage(0, opts);\n+        // Get any optional paths which occur after the subcommand\n+        let cwd = t!(env::current_dir());\n+        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n+\n+\n+        // All subcommands can have an optional \"Available paths\" section\n+        if matches.opt_present(\"verbose\") {\n+            let flags = Flags::parse(&[\"build\".to_string()]);\n+            let mut config = Config::default();\n+            config.build = flags.build.clone();\n+            let mut build = Build::new(flags, config);\n+            metadata::build(&mut build);\n+            let maybe_rules_help = step::build_rules(&build).get_help(subcommand);\n+            if maybe_rules_help.is_some() {\n+                extra_help.push_str(maybe_rules_help.unwrap().as_str());\n             }\n-            return m\n-        };\n+        } else {\n+            extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                     subcommand).as_str());\n+        }\n \n-        let cwd = t!(env::current_dir());\n-        let remaining_as_path = |m: &Matches| {\n-            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n-        };\n+        // User passed in -h/--help?\n+        if matches.opt_present(\"help\") {\n+            usage(0, &opts, &subcommand_help, &extra_help);\n+        }\n \n-        let m: Matches;\n-        let cmd = match &args[0][..] {\n+        let cmd = match subcommand.as_str() {\n             \"build\" => {\n-                m = parse(&opts);\n-                Subcommand::Build { paths: remaining_as_path(&m) }\n-            }\n-            \"doc\" => {\n-                m = parse(&opts);\n-                Subcommand::Doc { paths: remaining_as_path(&m) }\n+                Subcommand::Build { paths: paths }\n             }\n             \"test\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Test {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n             \"bench\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Bench {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n+            \"doc\" => {\n+                Subcommand::Doc { paths: paths }\n+            }\n             \"clean\" => {\n-                m = parse(&opts);\n-                if m.free.len() > 0 {\n-                    println!(\"clean takes no arguments\");\n-                    usage(1, &opts);\n+                if paths.len() > 0 {\n+                    println!(\"\\nclean takes no arguments\\n\");\n+                    usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n                 Subcommand::Clean\n             }\n             \"dist\" => {\n-                opts.optflag(\"\", \"install\", \"run installer as well\");\n-                m = parse(&opts);\n                 Subcommand::Dist {\n-                    paths: remaining_as_path(&m),\n-                    install: m.opt_present(\"install\"),\n+                    paths: paths,\n+                    install: matches.opt_present(\"install\"),\n                 }\n             }\n-            \"--help\" => usage(0, &opts),\n-            cmd => {\n-                println!(\"unknown command: {}\", cmd);\n-                usage(1, &opts);\n+            _ => {\n+                usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n \n-        let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n                 Some(PathBuf::from(\"config.toml\"))\n             } else {\n                 None\n             }\n         });\n \n-        let mut stage = m.opt_str(\"stage\").map(|j| j.parse().unwrap());\n-\n-        let incremental = m.opt_present(\"i\");\n+        let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n-        if incremental {\n+        if matches.opt_present(\"incremental\") {\n             if stage.is_none() {\n                 stage = Some(1);\n             }\n         }\n \n         Flags {\n-            verbose: m.opt_count(\"v\"),\n+            verbose: matches.opt_count(\"verbose\"),\n             stage: stage,\n-            on_fail: m.opt_str(\"on-fail\"),\n-            keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+            on_fail: matches.opt_str(\"on-fail\"),\n+            keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n+            build: matches.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()\n             }),\n-            host: split(m.opt_strs(\"host\")),\n-            target: split(m.opt_strs(\"target\")),\n+            host: split(matches.opt_strs(\"host\")),\n+            target: split(matches.opt_strs(\"target\")),\n             config: cfg_file,\n-            src: m.opt_str(\"src\").map(PathBuf::from),\n-            jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            src: matches.opt_str(\"src\").map(PathBuf::from),\n+            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n-            incremental: incremental,\n+            incremental: matches.opt_present(\"incremental\"),\n         }\n     }\n }"}, {"sha": "25082e3a9d095645d68c8528c1a1fb915d62ddcc", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -49,12 +49,17 @@ pub fn install(build: &Build, stage: u32, host: &str) {\n         install_sh(&build, \"docs\", \"rust-docs\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n+\n+    for target in build.config.target.iter() {\n+        install_sh(&build, \"std\", \"rust-std\", stage, target, &prefix,\n+                   &docdir, &libdir, &mandir, &empty_dir);\n+    }\n+\n     if build.config.rust_save_analysis {\n         install_sh(&build, \"analysis\", \"rust-analysis\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n-    install_sh(&build, \"std\", \"rust-std\", stage, host, &prefix,\n-               &docdir, &libdir, &mandir, &empty_dir);\n+\n     install_sh(&build, \"rustc\", \"rustc\", stage, host, &prefix,\n                &docdir, &libdir, &mandir, &empty_dir);\n     t!(fs::remove_dir_all(&empty_dir));"}, {"sha": "5560b5b0333c862b3c7b64bb23c00e7fcfb5f6c5", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -978,26 +978,25 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n-    pub fn print_help(&self, command: &str) {\n+    pub fn get_help(&self, command: &str) -> Option<String> {\n         let kind = match command {\n             \"build\" => Kind::Build,\n             \"doc\" => Kind::Doc,\n             \"test\" => Kind::Test,\n             \"bench\" => Kind::Bench,\n             \"dist\" => Kind::Dist,\n-            _ => return,\n+            _ => return None,\n         };\n         let rules = self.rules.values().filter(|r| r.kind == kind);\n         let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n         let mut rules = rules.collect::<Vec<_>>();\n         rules.sort_by_key(|r| r.path);\n \n-        println!(\"Available paths:\\n\");\n+        let mut help_string = String::from(\"Available paths:\\n\");\n         for rule in rules {\n-            print!(\"    ./x.py {} {}\", command, rule.path);\n-\n-            println!(\"\");\n+            help_string.push_str(format!(\"    ./x.py {} {}\\n\", command, rule.path).as_str());\n         }\n+        Some(help_string)\n     }\n \n     /// Construct the top-level build steps that we're going to be executing,"}, {"sha": "d42b35d488c3d5be27afee72e36174a513ec5e47", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -74,7 +74,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/current/images/device-tree/vexpress-v2p-ca15-tc1.dtb\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "7c1984410078f990c969c74e836638c4a248ddce", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -22,7 +22,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "d9a5429d2b8e894b8b3dbff2b06f09015ea7406f", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "renamed", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -56,28 +56,22 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY armv7-linux-gnueabihf.config /tmp/\n-COPY armv7-linux-gnueabihf.config aarch64-linux-gnu.config build-toolchains.sh /tmp/\n+COPY aarch64-linux-gnu.config build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n USER root\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV PATH=$PATH:/x-tools/aarch64-unknown-linux-gnueabi/bin\n-ENV PATH=$PATH:/x-tools/armv7-unknown-linux-gnueabihf/bin\n \n ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n     AR_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-ar \\\n-    CXX_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-g++ \\\n-    CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n-    AR_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-ar \\\n-    CXX_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-g++\n+    CXX_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-g++\n \n-ENV HOSTS=armv7-unknown-linux-gnueabihf\n-ENV HOSTS=$HOSTS,aarch64-unknown-linux-gnu\n+ENV HOSTS=aarch64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS", "previous_filename": "src/ci/docker/dist-armv7-aarch64-linux/Dockerfile"}, {"sha": "3d30ee49022d8f9318abc0fa52d71cd8310799d1", "filename": "src/ci/docker/dist-aarch64-linux/aarch64-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-armv7-aarch64-linux/aarch64-linux-gnu.config"}, {"sha": "94f785c96f815ac8d7a72103696a6ae821dd508a", "filename": "src/ci/docker/dist-aarch64-linux/build-toolchains.sh", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2Fbuild-toolchains.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,37 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir build\n+cd build\n+cp ../aarch64-linux-gnu.config .config\n+ct-ng oldconfig\n+hide_output ct-ng build\n+cd ..\n+rm -rf build"}, {"sha": "31f4b8b777be5be44967e61694dbea67144ff069", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -32,7 +32,7 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV TARGETS=arm-linux-androideabi"}, {"sha": "7162aa0efc0cfa1eae6ca5d1bc3608f6603692be", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -56,27 +56,22 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY arm-linux-gnueabihf.config arm-linux-gnueabi.config build-toolchains.sh /tmp/\n+COPY arm-linux-gnueabi.config build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n USER root\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabi/bin\n-ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabihf/bin\n \n ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n     AR_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-ar \\\n-    CXX_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-g++ \\\n-    CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n-    AR_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-ar \\\n-    CXX_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-g++\n+    CXX_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-g++\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n-ENV HOSTS=$HOSTS,arm-unknown-linux-gnueabihf\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f78ecf9381a1fce61dc582d29bc1c802ca52fe36", "filename": "src/ci/docker/dist-arm-linux/build-toolchains.sh", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fbuild-toolchains.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -35,11 +35,3 @@ ct-ng oldconfig\n hide_output ct-ng build\n cd ..\n rm -rf build\n-\n-mkdir build\n-cd build\n-cp ../arm-linux-gnueabihf.config .config\n-ct-ng oldconfig\n-hide_output ct-ng build\n-cd ..\n-rm -rf build"}, {"sha": "8fa1cbe492fac67ab03ed1365a57909b3ebcf482", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,77 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n+  g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n+  make \\\n+  patch \\\n+  python2.7 \\\n+  sudo \\\n+  texinfo \\\n+  wget \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY arm-linux-gnueabihf.config build-toolchains.sh /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabihf/bin\n+\n+ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n+    AR_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-ar \\\n+    CXX_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-g++\n+\n+ENV HOSTS=arm-unknown-linux-gnueabihf\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "1feeef15557498d7d0be00e216370aa2416b2a2b", "filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabihf.config"}, {"sha": "df1134d5483c2ff3d4953e5dba14e1552250fc5d", "filename": "src/ci/docker/dist-armhf-linux/build-toolchains.sh", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fbuild-toolchains.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,37 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir build\n+cd build\n+cp ../arm-linux-gnueabihf.config .config\n+ct-ng oldconfig\n+hide_output ct-ng build\n+cd ..\n+rm -rf build"}, {"sha": "9fcd827fc9962cda2f27ef26033fc831618f354d", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,77 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n+  g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n+  make \\\n+  patch \\\n+  python2.7 \\\n+  sudo \\\n+  texinfo \\\n+  wget \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY build-toolchains.sh armv7-linux-gnueabihf.config /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV PATH=$PATH:/x-tools/armv7-unknown-linux-gnueabihf/bin\n+\n+ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n+    AR_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-ar \\\n+    CXX_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-g++\n+\n+ENV HOSTS=armv7-unknown-linux-gnueabihf\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "79d6c77c41152115f176d175483453b85983c408", "filename": "src/ci/docker/dist-armv7-linux/armv7-linux-gnueabihf.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-armv7-aarch64-linux/armv7-linux-gnueabihf.config"}, {"sha": "2d395fee792ec1d96437277424f538b4da47a9be", "filename": "src/ci/docker/dist-armv7-linux/build-toolchains.sh", "status": "renamed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fbuild-toolchains.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -35,11 +35,3 @@ ct-ng oldconfig\n hide_output ct-ng build\n cd ..\n rm -rf build\n-\n-mkdir build\n-cd build\n-cp ../aarch64-linux-gnu.config .config\n-ct-ng oldconfig\n-hide_output ct-ng build\n-cd ..\n-rm -rf build", "previous_filename": "src/ci/docker/dist-armv7-aarch64-linux/build-toolchains.sh"}, {"sha": "bfffd9637fcee5049405354f8152739bf11f00e4", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -29,7 +29,7 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV \\"}, {"sha": "d2727cbdb3508b35a5a8cc223597397fbed9bacd", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -26,7 +26,7 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV RUST_CONFIGURE_ARGS \\"}, {"sha": "ad285a57a84a3f56891012099ae498dab2503b9b", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/build-musl.sh", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,11 +15,14 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.14\n+MUSL=musl-1.1.16\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n-CFLAGS=\"$CFLAGS -m32\" ./configure --prefix=/musl-i686 --disable-shared --target=i686\n-make -j10\n+CC=gcc \\\n+  CFLAGS=\"$CFLAGS -m32\" \\\n+  ./configure --prefix=/musl-i686 --disable-shared \\\n+    --target=i686\n+make AR=ar RANLIB=ranlib -j10\n make install\n cd ..\n "}, {"sha": "3b81216c6431edc91ec7e3148b7329d9cbf38c58", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "renamed", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -17,7 +17,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n COPY build-toolchain.sh /tmp/\n-RUN /tmp/build-toolchain.sh x86_64\n RUN /tmp/build-toolchain.sh i686\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n@@ -26,19 +25,15 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV \\\n-    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n-    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc \\\n-    CXX_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-g++ \\\n     AR_i686_unknown_freebsd=i686-unknown-freebsd10-ar \\\n     CC_i686_unknown_freebsd=i686-unknown-freebsd10-gcc \\\n     CXX_i686_unknown_freebsd=i686-unknown-freebsd10-g++\n \n-ENV HOSTS=x86_64-unknown-freebsd\n-ENV HOSTS=$HOSTS,i686-unknown-freebsd\n+ENV HOSTS=i686-unknown-freebsd\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS", "previous_filename": "src/ci/docker/dist-freebsd/Dockerfile"}, {"sha": "5642e6fc937f9736e14bc23aed1fca4b045bc88a", "filename": "src/ci/docker/dist-i686-freebsd/build-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-freebsd/build-toolchain.sh"}, {"sha": "b322f56f0d0480aade00539c8795aec18ddfb23f", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -2,6 +2,12 @@ FROM centos:5\n \n WORKDIR /build\n \n+# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n+# to http://vault.centos.org/\n+RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n+RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n+RUN sed -i 's/#\\(baseurl.*\\)mirror.centos.org/\\1107.158.252.35/' /etc/yum.repos.d/*.repo\n+\n RUN yum upgrade -y && yum install -y \\\n       curl \\\n       bzip2 \\\n@@ -76,11 +82,10 @@ RUN curl -Lo /rustroot/dumb-init \\\n ENTRYPOINT [\"/rustroot/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV HOSTS=i686-unknown-linux-gnu\n-ENV HOSTS=$HOSTS,x86_64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n       --host=$HOSTS \\", "previous_filename": "src/ci/docker/dist-x86-linux/Dockerfile"}, {"sha": "80aa1f2a0161308affc245daaf2952f973643918", "filename": "src/ci/docker/dist-i686-linux/build-binutils.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-binutils.sh"}, {"sha": "82e46455cb0f0673fef2fe6442d25aa7c4b8d976", "filename": "src/ci/docker/dist-i686-linux/build-cmake.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-cmake.sh"}, {"sha": "b7d22755a571bab38aa4d85629fa69cbec041c24", "filename": "src/ci/docker/dist-i686-linux/build-curl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-curl.sh"}, {"sha": "ab2562538d6d7376e942a219ce0f00664082be9f", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-gcc.sh"}, {"sha": "92fa66b496d933648a0e49c3f83b6565246188a7", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-git.sh"}, {"sha": "4ce38fd9205e27b4aff8b169f4ead5c31f731993", "filename": "src/ci/docker/dist-i686-linux/build-headers.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-headers.sh"}, {"sha": "64b1abf82a8277d8ebc1a10c54b40fd7be583bd4", "filename": "src/ci/docker/dist-i686-linux/build-openssl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-openssl.sh"}, {"sha": "a7a450f3c8de772403b481b96c94b03d5ec2325e", "filename": "src/ci/docker/dist-i686-linux/build-python.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/build-python.sh"}, {"sha": "97e6d2908cf8a5ae3174e1bc08a17ea27fa3aae5", "filename": "src/ci/docker/dist-i686-linux/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-x86-linux/shared.sh"}, {"sha": "33cca061103a333406ddf9d648c1db9cf5ed36b2", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -13,12 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils \\\n   g++-mips-linux-gnu \\\n-  g++-mipsel-linux-gnu \\\n   libssl-dev \\\n   pkg-config\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n@@ -27,7 +26,6 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV HOSTS=mips-unknown-linux-gnu\n-ENV HOSTS=$HOSTS,mipsel-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "157de83abb783bc5e9cf608a3c7b75f4050dc754", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -13,12 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils \\\n   g++-mips64-linux-gnuabi64 \\\n-  g++-mips64el-linux-gnuabi64 \\\n   libssl-dev \\\n   pkg-config\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n@@ -27,7 +26,6 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV HOSTS=mips64-unknown-linux-gnuabi64\n-ENV HOSTS=$HOSTS,mips64el-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "739d5ff6ac4aaddcce445c4f3ba8c414bdf81d2e", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  g++-mips64el-linux-gnuabi64 \\\n+  libssl-dev \\\n+  pkg-config\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV HOSTS=mips64el-unknown-linux-gnuabi64\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "9339063bc19ebb91c4a84f1d3c30a88141170bc0", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  g++-mipsel-linux-gnu \\\n+  libssl-dev \\\n+  pkg-config\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV HOSTS=mipsel-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "92342caed2a9540da682ce3dab052b27e2e3c26d", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -63,7 +63,7 @@ RUN ./build-powerpc-toolchain.sh\n USER root\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV PATH=$PATH:/x-tools/powerpc-unknown-linux-gnu/bin"}, {"sha": "182dfd93cc76fea34780f15c11cc62050de6977b", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -62,26 +62,18 @@ RUN ./build-powerpc64-toolchain.sh\n \n USER root\n \n-RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n-COPY build-powerpc64le-toolchain.sh /tmp/\n-RUN ./build-powerpc64le-toolchain.sh\n-\n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV PATH=$PATH:/x-tools/powerpc64-unknown-linux-gnu/bin\n \n ENV \\\n     AR_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-ar \\\n     CC_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-gcc \\\n-    CXX_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-g++ \\\n-    AR_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-ar \\\n-    CC_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-gcc \\\n-    CXX_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-g++\n+    CXX_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-g++\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n-ENV HOSTS=$HOSTS,powerpc64le-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "6b9f964d5a38379f12e58d09e80c7bd0156bcda3", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,77 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n+  g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n+  make \\\n+  patch \\\n+  python2.7 \\\n+  sudo \\\n+  texinfo \\\n+  wget \\\n+  xz-utils \\\n+  libssl-dev \\\n+ pkg-config\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+USER root\n+\n+RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n+COPY shared.sh build-powerpc64le-toolchain.sh /tmp/\n+RUN ./build-powerpc64le-toolchain.sh\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV \\\n+    AR_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-ar \\\n+    CC_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-gcc \\\n+    CXX_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-g++\n+\n+ENV HOSTS=powerpc64le-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "4d3e638916dbf248b6f52509b4d3f4251acf2d50", "filename": "src/ci/docker/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64le-toolchain.sh"}, {"sha": "97e6d2908cf8a5ae3174e1bc08a17ea27fa3aae5", "filename": "src/ci/docker/dist-powerpc64le-linux/shared.sh", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fshared.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,25 @@\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}"}, {"sha": "7c94f713e18759a7b55fb83e7c6440f13495dd49", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "renamed", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -60,27 +60,20 @@ COPY patches/ /tmp/patches/\n COPY s390x-linux-gnu.config build-s390x-toolchain.sh /tmp/\n RUN ./build-s390x-toolchain.sh\n \n-COPY build-netbsd-toolchain.sh /tmp/\n-RUN ./build-netbsd-toolchain.sh\n-\n USER root\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n-ENV PATH=$PATH:/x-tools/s390x-ibm-linux-gnu/bin:/x-tools/x86_64-unknown-netbsd/bin\n+ENV PATH=$PATH:/x-tools/s390x-ibm-linux-gnu/bin\n \n ENV \\\n-    AR_x86_64_unknown_netbsd=x86_64--netbsd-ar \\\n-    CC_x86_64_unknown_netbsd=x86_64--netbsd-gcc-sysroot \\\n-    CXX_x86_64_unknown_netbsd=x86_64--netbsd-g++-sysroot \\\n     CC_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-gcc \\\n     AR_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-ar \\\n     CXX_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-g++\n \n-ENV HOSTS=x86_64-unknown-netbsd\n-ENV HOSTS=$HOSTS,s390x-unknown-linux-gnu\n+ENV HOSTS=s390x-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/Dockerfile"}, {"sha": "b4995e20dc69b1058bc1577ea3e5aa535d790dd8", "filename": "src/ci/docker/dist-s390x-linux/build-s390x-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/build-s390x-toolchain.sh"}, {"sha": "cba416ed2f70bc12990229442e23feb47a0fdd3c", "filename": "src/ci/docker/dist-s390x-linux/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch"}, {"sha": "fa5e4510987f1ca682a642234f52353481e77e1f", "filename": "src/ci/docker/dist-s390x-linux/s390x-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/s390x-linux-gnu.config"}, {"sha": "a2939c8c48591065be4515e3840d0d2e3a90aa1c", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,39 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  bzip2 \\\n+  xz-utils \\\n+  wget \\\n+  libssl-dev \\\n+  pkg-config\n+\n+COPY build-toolchain.sh /tmp/\n+RUN /tmp/build-toolchain.sh x86_64\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV \\\n+    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n+    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc \\\n+    CXX_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-g++\n+\n+ENV HOSTS=x86_64-unknown-freebsd\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5642e6fc937f9736e14bc23aed1fca4b045bc88a", "filename": "src/ci/docker/dist-x86_64-freebsd/build-toolchain.sh", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,112 @@\n+#!/bin/bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+ARCH=$1\n+BINUTILS=2.25.1\n+GCC=5.3.0\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir binutils\n+cd binutils\n+\n+# First up, build binutils\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-$BINUTILS/configure \\\n+  --target=$ARCH-unknown-freebsd10\n+hide_output make -j10\n+hide_output make install\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download the FreeBSD libc and relevant header files\n+\n+mkdir freebsd\n+case \"$ARCH\" in\n+    x86_64)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/10.2-RELEASE/base.txz\n+        ;;\n+    i686)\n+        URL=ftp://ftp.freebsd.org/pub/FreeBSD/releases/i386/10.2-RELEASE/base.txz\n+        ;;\n+esac\n+curl $URL | tar xJf - -C freebsd ./usr/include ./usr/lib ./lib\n+\n+dst=/usr/local/$ARCH-unknown-freebsd10\n+\n+cp -r freebsd/usr/include $dst/\n+cp freebsd/usr/lib/crt1.o $dst/lib\n+cp freebsd/usr/lib/Scrt1.o $dst/lib\n+cp freebsd/usr/lib/crti.o $dst/lib\n+cp freebsd/usr/lib/crtn.o $dst/lib\n+cp freebsd/usr/lib/libc.a $dst/lib\n+cp freebsd/usr/lib/libutil.a $dst/lib\n+cp freebsd/usr/lib/libutil_p.a $dst/lib\n+cp freebsd/usr/lib/libm.a $dst/lib\n+cp freebsd/usr/lib/librt.so.1 $dst/lib\n+cp freebsd/usr/lib/libexecinfo.so.1 $dst/lib\n+cp freebsd/lib/libc.so.7 $dst/lib\n+cp freebsd/lib/libm.so.5 $dst/lib\n+cp freebsd/lib/libutil.so.9 $dst/lib\n+cp freebsd/lib/libthr.so.3 $dst/lib/libpthread.so\n+\n+ln -s libc.so.7 $dst/lib/libc.so\n+ln -s libm.so.5 $dst/lib/libm.so\n+ln -s librt.so.1 $dst/lib/librt.so\n+ln -s libutil.so.9 $dst/lib/libutil.so\n+ln -s libexecinfo.so.1 $dst/lib/libexecinfo.so\n+rm -rf freebsd\n+\n+# Finally, download and build gcc to target FreeBSD\n+mkdir gcc\n+cd gcc\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n+./contrib/download_prerequisites\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+hide_output ../gcc-$GCC/configure                \\\n+  --enable-languages=c,c++                       \\\n+  --target=$ARCH-unknown-freebsd10               \\\n+  --disable-multilib                             \\\n+  --disable-nls                                  \\\n+  --disable-libgomp                              \\\n+  --disable-libquadmath                          \\\n+  --disable-libssp                               \\\n+  --disable-libvtv                               \\\n+  --disable-libcilkrts                           \\\n+  --disable-libada                               \\\n+  --disable-libsanitizer                         \\\n+  --disable-libquadmath-support                  \\\n+  --disable-lto\n+hide_output make -j10\n+hide_output make install\n+cd ../..\n+rm -rf gcc"}, {"sha": "cbe5f5936a506a404004fb5eeef0c29c342fb03a", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,101 @@\n+FROM centos:5\n+\n+WORKDIR /build\n+\n+# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n+# to http://vault.centos.org/\n+RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n+RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n+RUN sed -i 's/#\\(baseurl.*\\)mirror.centos.org/\\1107.158.252.35/' /etc/yum.repos.d/*.repo\n+\n+RUN yum upgrade -y && yum install -y \\\n+      curl \\\n+      bzip2 \\\n+      gcc \\\n+      gcc-c++ \\\n+      make \\\n+      glibc-devel \\\n+      perl \\\n+      zlib-devel \\\n+      file \\\n+      xz \\\n+      which \\\n+      pkgconfig \\\n+      wget \\\n+      autoconf \\\n+      gettext\n+\n+ENV PATH=/rustroot/bin:$PATH\n+ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n+ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n+WORKDIR /tmp\n+COPY shared.sh build-binutils.sh /tmp/\n+\n+# We need a build of openssl which supports SNI to download artifacts from\n+# static.rust-lang.org. This'll be used to link into libcurl below (and used\n+# later as well), so build a copy of OpenSSL with dynamic libraries into our\n+# generic root.\n+COPY build-openssl.sh /tmp/\n+RUN ./build-openssl.sh\n+\n+# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n+# some https urls we have, so install a new version of libcurl + curl which is\n+# using the openssl we just built previously.\n+#\n+# Note that we also disable a bunch of optional features of curl that we don't\n+# really need.\n+COPY build-curl.sh /tmp/\n+RUN ./build-curl.sh\n+\n+# binutils < 2.22 has a bug where the 32-bit executables it generates\n+# immediately segfault in Rust, so we need to install our own binutils.\n+#\n+# See https://github.com/rust-lang/rust/issues/20440 for more info\n+RUN ./build-binutils.sh\n+\n+# Need a newer version of gcc than centos has to compile LLVM nowadays\n+COPY build-gcc.sh /tmp/\n+RUN ./build-gcc.sh\n+\n+# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n+COPY build-python.sh /tmp/\n+RUN ./build-python.sh\n+\n+# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n+# cloning, so download and build it here.\n+COPY build-git.sh /tmp/\n+RUN ./build-git.sh\n+\n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n+# with so we install newer ones here\n+COPY build-headers.sh /tmp/\n+RUN ./build-headers.sh\n+\n+RUN curl -Lo /rustroot/dumb-init \\\n+      https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64 && \\\n+      chmod +x /rustroot/dumb-init\n+ENTRYPOINT [\"/rustroot/dumb-init\", \"--\"]\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV HOSTS=x86_64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --host=$HOSTS \\\n+      --enable-extended \\\n+      --enable-sanitizers\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+\n+# This is the only builder which will create source tarballs\n+ENV DIST_SRC 1\n+\n+# When we build cargo in this container, we don't want it to use the system\n+# libcurl, instead it should compile its own.\n+ENV LIBCURL_NO_PKG_CONFIG 1"}, {"sha": "80aa1f2a0161308affc245daaf2952f973643918", "filename": "src/ci/docker/dist-x86_64-linux/build-binutils.sh", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-binutils.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,26 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+source shared.sh\n+\n+curl https://ftp.gnu.org/gnu/binutils/binutils-2.25.1.tar.bz2 | tar xfj -\n+\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-2.25.1/configure --prefix=/rustroot\n+hide_output make -j10\n+hide_output make install\n+\n+cd ..\n+rm -rf binutils-build\n+rm -rf binutils-2.25.1"}, {"sha": "82e46455cb0f0673fef2fe6442d25aa7c4b8d976", "filename": "src/ci/docker/dist-x86_64-linux/build-cmake.sh", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-cmake.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,25 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+curl https://cmake.org/files/v3.6/cmake-3.6.3.tar.gz | tar xzf -\n+\n+mkdir cmake-build\n+cd cmake-build\n+hide_output ../cmake-3.6.3/configure --prefix=/rustroot\n+hide_output make -j10\n+hide_output make install\n+\n+cd ..\n+rm -rf cmake-build\n+rm -rf cmake-3.6.3"}, {"sha": "b7d22755a571bab38aa4d85629fa69cbec041c24", "filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,43 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+VERSION=7.51.0\n+\n+curl http://cool.haxx.se/download/curl-$VERSION.tar.bz2 | tar xjf -\n+\n+mkdir curl-build\n+cd curl-build\n+hide_output ../curl-$VERSION/configure \\\n+      --prefix=/rustroot \\\n+      --with-ssl=/rustroot \\\n+      --disable-sspi \\\n+      --disable-gopher \\\n+      --disable-smtp \\\n+      --disable-smb \\\n+      --disable-imap \\\n+      --disable-pop3 \\\n+      --disable-tftp \\\n+      --disable-telnet \\\n+      --disable-manual \\\n+      --disable-dict \\\n+      --disable-rtsp \\\n+      --disable-ldaps \\\n+      --disable-ldap\n+hide_output make -j10\n+hide_output make install\n+\n+cd ..\n+rm -rf curl-build\n+rm -rf curl-$VERSION\n+yum erase -y curl"}, {"sha": "ab2562538d6d7376e942a219ce0f00664082be9f", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+source shared.sh\n+\n+GCC=4.8.5\n+\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n+./contrib/download_prerequisites\n+mkdir ../gcc-build\n+cd ../gcc-build\n+hide_output ../gcc-$GCC/configure \\\n+    --prefix=/rustroot \\\n+    --enable-languages=c,c++\n+hide_output make -j10\n+hide_output make install\n+ln -nsf gcc /rustroot/bin/cc\n+\n+cd ..\n+rm -rf gcc-build\n+rm -rf gcc-$GCC\n+yum erase -y gcc gcc-c++ binutils"}, {"sha": "92fa66b496d933648a0e49c3f83b6565246188a7", "filename": "src/ci/docker/dist-x86_64-linux/build-git.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+\n+cd git-2.10.0\n+make configure\n+hide_output ./configure --prefix=/rustroot\n+hide_output make -j10\n+hide_output make install\n+\n+cd ..\n+rm -rf git-2.10.0"}, {"sha": "4ce38fd9205e27b4aff8b169f4ead5c31f731993", "filename": "src/ci/docker/dist-x86_64-linux/build-headers.sh", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-headers.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,25 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+curl https://cdn.kernel.org/pub/linux/kernel/v3.x/linux-3.2.84.tar.xz | unxz | tar x\n+\n+cd linux-3.2.84\n+hide_output make mrproper\n+hide_output make INSTALL_HDR_PATH=dest headers_install\n+\n+find dest/include \\( -name .install -o -name ..install.cmd \\) -delete\n+yes | cp -fr dest/include/* /usr/include\n+\n+cd ..\n+rm -rf linux-3.2.84"}, {"sha": "64b1abf82a8277d8ebc1a10c54b40fd7be583bd4", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+VERSION=1.0.2j\n+\n+curl https://www.openssl.org/source/openssl-$VERSION.tar.gz | tar xzf -\n+\n+cd openssl-$VERSION\n+hide_output ./config --prefix=/rustroot shared -fPIC\n+hide_output make -j10\n+hide_output make install\n+cd ..\n+rm -rf openssl-$VERSION\n+\n+# Make the system cert collection available to the new install.\n+ln -nsf /etc/pki/tls/cert.pem /rustroot/ssl/"}, {"sha": "a7a450f3c8de772403b481b96c94b03d5ec2325e", "filename": "src/ci/docker/dist-x86_64-linux/build-python.sh", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-python.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+curl https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz | \\\n+  tar xzf -\n+\n+mkdir python-build\n+cd python-build\n+\n+# Gotta do some hackery to tell python about our custom OpenSSL build, but other\n+# than that fairly normal.\n+CFLAGS='-I /rustroot/include' LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n+    hide_output ../Python-2.7.12/configure --prefix=/rustroot\n+hide_output make -j10\n+hide_output make install\n+\n+cd ..\n+rm -rf python-build\n+rm -rf Python-2.7.12"}, {"sha": "97e6d2908cf8a5ae3174e1bc08a17ea27fa3aae5", "filename": "src/ci/docker/dist-x86_64-linux/shared.sh", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fshared.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,25 @@\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}"}, {"sha": "a41c0cca3b5f0e5b086b2da1243faadce941bd9b", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -26,7 +26,7 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n ENV RUST_CONFIGURE_ARGS \\"}, {"sha": "776da0093974c0c68c9b59ca84f9fd55eec26059", "filename": "src/ci/docker/dist-x86_64-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.14\n+MUSL=musl-1.1.16\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n ./configure --prefix=/musl-x86_64 --disable-shared"}, {"sha": "a1dd9a3724a882004e62f8038a8c993aeb3f7f50", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,78 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n+  g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n+  make \\\n+  patch \\\n+  python2.7 \\\n+  sudo \\\n+  texinfo \\\n+  wget \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY build-netbsd-toolchain.sh /tmp/\n+RUN ./build-netbsd-toolchain.sh\n+\n+USER root\n+\n+RUN curl -o /usr/local/bin/sccache \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n+      chmod +x /usr/local/bin/sccache\n+\n+ENV PATH=$PATH:/x-tools/x86_64-unknown-netbsd/bin\n+\n+ENV \\\n+    AR_x86_64_unknown_netbsd=x86_64--netbsd-ar \\\n+    CC_x86_64_unknown_netbsd=x86_64--netbsd-gcc-sysroot \\\n+    CXX_x86_64_unknown_netbsd=x86_64--netbsd-g++-sysroot\n+\n+ENV HOSTS=x86_64-unknown-netbsd\n+\n+ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ea335a249736c703296840774638e609961625c1", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/build-netbsd-toolchain.sh"}, {"sha": "ffdb1d18a94ef8dd122222dc335bde25bc789a5e", "filename": "src/ci/docker/emscripten/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Femscripten%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,7 +15,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   lib32stdc++6\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "34d0567a440f9debc694a256a4b54aeaf7149b9f", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "960a0fa7a385f9aec3dd05e9111065fe5e54323d", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "9871df90e00d509e55f22ad9a8c4050e5bb56cb2", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,7 +15,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "197b0ec9b9bb64bbe041682cdfb7771997c50004", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "60af302791a74406e67923bbc71c7bb1c25aa943", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -16,7 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "4ec0b5c152575951bd6022d423670db169330af9", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "6448f88950f0df30e7bee4b02f6b348b695294c7", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "c00667fe1dd00020f22007714fd98d71c9872684", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "7284d231b844bd67c8b3bc3abbdac29cb8a49231", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "1dce84bc5fd73e61eda10ef6f4440151e1fba357", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-03-24-sccache-x86_64-unknown-linux-musl && \\\n+      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-04-04-sccache-x86_64-unknown-linux-musl && \\\n       chmod +x /usr/local/bin/sccache\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "20812de524add29aa089e6bdd28dabcc08b5771a", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -123,6 +123,7 @@\n - [no_debug](no-debug.md)\n - [non_ascii_idents](non-ascii-idents.md)\n - [nonzero](nonzero.md)\n+- [offset_to](offset-to.md)\n - [omit_gdb_pretty_printer_section](omit-gdb-pretty-printer-section.md)\n - [on_unimplemented](on-unimplemented.md)\n - [once_poison](once-poison.md)\n@@ -171,6 +172,7 @@\n - [slice_concat_ext](slice-concat-ext.md)\n - [slice_get_slice](slice-get-slice.md)\n - [slice_patterns](slice-patterns.md)\n+- [slice_rsplit](slice-rsplit.md)\n - [sort_internals](sort-internals.md)\n - [sort_unstable](sort-unstable.md)\n - [specialization](specialization.md)\n@@ -203,11 +205,11 @@\n - [unwind_attributes](unwind-attributes.md)\n - [update_panic_count](update-panic-count.md)\n - [use_extern_macros](use-extern-macros.md)\n+- [used](used.md)\n - [utf8_error_error_len](utf8-error-error-len.md)\n - [vec_remove_item](vec-remove-item.md)\n - [windows_c](windows-c.md)\n - [windows_handle](windows-handle.md)\n - [windows_net](windows-net.md)\n - [windows_stdio](windows-stdio.md)\n-- [windows_subsystem](windows-subsystem.md)\n - [zero_one](zero-one.md)"}, {"sha": "03d990eb4ae970421d5bdea89b0d6c76ba71076a", "filename": "src/doc/unstable-book/src/offset-to.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,7 @@\n+# `offset_to`\n+\n+The tracking issue for this feature is: [#41079]\n+\n+[#41079]: https://github.com/rust-lang/rust/issues/41079\n+\n+------------------------"}, {"sha": "8c2954f7294e02b666e4ad15244be99048f15867", "filename": "src/doc/unstable-book/src/slice-rsplit.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,10 @@\n+# `slice_rsplit`\n+\n+The tracking issue for this feature is: [#41020]\n+\n+[#41020]: https://github.com/rust-lang/rust/issues/41020\n+\n+------------------------\n+\n+The `slice_rsplit` feature enables two methods on slices:\n+`slice.rsplit(predicate)` and `slice.rsplit_mut(predicate)`."}, {"sha": "75a8b2774f42242e4790f7ca521c958c6f7f507d", "filename": "src/doc/unstable-book/src/used.md", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Fused.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fdoc%2Funstable-book%2Fsrc%2Fused.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fused.md?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,153 @@\n+# `used`\n+\n+The tracking issue for this feature\n+is: [40289](https://github.com/rust-lang/rust/issues/40289).\n+\n+------------------------\n+\n+The `#[used]` attribute can be applied to `static` variables to prevent the Rust\n+compiler from optimizing them away even if they appear to be unused by the crate\n+(appear to be \"dead code\").\n+\n+``` rust\n+#![feature(used)]\n+\n+#[used]\n+static FOO: i32 = 1;\n+\n+static BAR: i32 = 2;\n+\n+fn main() {}\n+```\n+\n+If you compile this program into an object file, you'll see that `FOO` makes it\n+to the object file but `BAR` doesn't. Neither static variable is used by the\n+program.\n+\n+``` text\n+$ rustc -C opt-level=3 --emit=obj used.rs\n+\n+$ nm -C used.o\n+0000000000000000 T main\n+                 U std::rt::lang_start\n+0000000000000000 r used::FOO\n+0000000000000000 t used::main\n+```\n+\n+Note that the *linker* knows nothing about the `#[used]` attribute and will\n+remove `#[used]` symbols if they are not referenced by other parts of the\n+program:\n+\n+``` text\n+$ rustc -C opt-level=3 used.rs\n+\n+$ nm -C used | grep FOO\n+```\n+\n+\"This doesn't sound too useful then!\" you may think but keep reading.\n+\n+To preserve the symbols all the way to the final binary, you'll need the\n+cooperation of the linker. Here's one example:\n+\n+The ELF standard defines two special sections, `.init_array` and\n+`.pre_init_array`, that may contain function pointers which will be executed\n+*before* the `main` function is invoked. The linker will preserve symbols placed\n+in these sections (at least when linking programs that target the `*-*-linux-*`\n+targets).\n+\n+``` rust,ignore\n+#![feature(used)]\n+\n+extern \"C\" fn before_main() {\n+    println!(\"Hello, world!\");\n+}\n+\n+#[link_section = \".init_array\"]\n+#[used]\n+static INIT_ARRAY: [extern \"C\" fn(); 1] = [before_main];\n+\n+fn main() {}\n+```\n+\n+So, `#[used]` and `#[link_section]` can be combined to obtain \"life before\n+main\".\n+\n+``` text\n+$ rustc -C opt-level=3 before-main.rs\n+\n+$ ./before-main\n+Hello, world!\n+```\n+\n+Another example: ARM Cortex-M microcontrollers need their reset handler, a\n+pointer to the function that will executed right after the microcontroller is\n+turned on, to be placed near the start of their FLASH memory to boot properly.\n+\n+This condition can be met using `#[used]` and `#[link_section]` plus a linker\n+script.\n+\n+``` rust,ignore\n+#![feature(lang_items)]\n+#![feature(used)]\n+#![no_main]\n+#![no_std]\n+\n+extern \"C\" fn reset_handler() -> ! {\n+    loop {}\n+}\n+\n+#[link_section = \".reset_handler\"]\n+#[used]\n+static RESET_HANDLER: extern \"C\" fn() -> ! = reset_handler;\n+\n+#[lang = \"panic_fmt\"]\n+fn panic_fmt() {}\n+```\n+\n+``` text\n+MEMORY\n+{\n+  FLASH : ORIGIN = 0x08000000, LENGTH = 128K\n+  RAM : ORIGIN = 0x20000000, LENGTH = 20K\n+}\n+\n+SECTIONS\n+{\n+  .text ORIGIN(FLASH) :\n+  {\n+    /* Vector table */\n+    LONG(ORIGIN(RAM) + LENGTH(RAM)); /* initial SP value */\n+    KEEP(*(.reset_handler));\n+\n+    /* Omitted: The rest of the vector table */\n+\n+    *(.text.*);\n+  } > FLASH\n+\n+  /DISCARD/ :\n+  {\n+    /* Unused unwinding stuff */\n+    *(.ARM.exidx.*)\n+  }\n+}\n+```\n+\n+``` text\n+$ xargo rustc --target thumbv7m-none-eabi --release -- \\\n+    -C link-arg=-Tlink.x -C link-arg=-nostartfiles\n+\n+$ arm-none-eabi-objdump -Cd target/thumbv7m-none-eabi/release/app\n+./target/thumbv7m-none-eabi/release/app:     file format elf32-littlearm\n+\n+\n+Disassembly of section .text:\n+\n+08000000 <app::RESET_HANDLER-0x4>:\n+ 8000000:       20005000        .word   0x20005000\n+\n+08000004 <app::RESET_HANDLER>:\n+ 8000004:       08000009                                ....\n+\n+08000008 <app::reset_handler>:\n+ 8000008:       e7fe            b.n     8000008 <app::reset_handler>\n+```"}, {"sha": "80583352fbf967d5a77b9d525b3d993f7a2525fc", "filename": "src/doc/unstable-book/src/windows-subsystem.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b83352e44c36e81db7f00eb60e78ff3828c51c9e/src%2Fdoc%2Funstable-book%2Fsrc%2Fwindows-subsystem.md", "raw_url": "https://github.com/rust-lang/rust/raw/b83352e44c36e81db7f00eb60e78ff3828c51c9e/src%2Fdoc%2Funstable-book%2Fsrc%2Fwindows-subsystem.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fwindows-subsystem.md?ref=b83352e44c36e81db7f00eb60e78ff3828c51c9e", "patch": "@@ -1,10 +0,0 @@\n-# `windows_subsystem`\n-\n-The tracking issue for this feature is: [#37499]\n-\n-[#37499]: https://github.com/rust-lang/rust/issues/37499\n-\n-------------------------\n-\n-\n-"}, {"sha": "75ab3f1a17be43f4e3669d6eb347ce6e7c56e4cb", "filename": "src/etc/char_private.py", "status": "modified", "additions": 98, "deletions": 34, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -76,6 +76,66 @@ def get_codepoints(f):\n     for c in range(prev_codepoint + 1, NUM_CODEPOINTS):\n         yield Codepoint(c, None)\n \n+def compress_singletons(singletons):\n+    uppers = [] # (upper, # items in lowers)\n+    lowers = []\n+\n+    for i in singletons:\n+        upper = i >> 8\n+        lower = i & 0xff\n+        if len(uppers) == 0 or uppers[-1][0] != upper:\n+            uppers.append((upper, 1))\n+        else:\n+            upper, count = uppers[-1]\n+            uppers[-1] = upper, count + 1\n+        lowers.append(lower)\n+\n+    return uppers, lowers\n+\n+def compress_normal(normal):\n+    # lengths 0x00..0x7f are encoded as 00, 01, ..., 7e, 7f\n+    # lengths 0x80..0x7fff are encoded as 80 80, 80 81, ..., ff fe, ff ff\n+    compressed = [] # [truelen, (truelenaux), falselen, (falselenaux)]\n+\n+    prev_start = 0\n+    for start, count in normal:\n+        truelen = start - prev_start\n+        falselen = count\n+        prev_start = start + count\n+\n+        assert truelen < 0x8000 and falselen < 0x8000\n+        entry = []\n+        if truelen > 0x7f:\n+            entry.append(0x80 | (truelen >> 8))\n+            entry.append(truelen & 0xff)\n+        else:\n+            entry.append(truelen & 0x7f)\n+        if falselen > 0x7f:\n+            entry.append(0x80 | (falselen >> 8))\n+            entry.append(falselen & 0xff)\n+        else:\n+            entry.append(falselen & 0x7f)\n+\n+        compressed.append(entry)\n+\n+    return compressed\n+\n+def print_singletons(uppers, lowers, uppersname, lowersname):\n+    print(\"const {}: &'static [(u8, u8)] = &[\".format(uppersname))\n+    for u, c in uppers:\n+        print(\"    ({:#04x}, {}),\".format(u, c))\n+    print(\"];\")\n+    print(\"const {}: &'static [u8] = &[\".format(lowersname))\n+    for i in range(0, len(lowers), 8):\n+        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(l) for l in lowers[i:i+8])))\n+    print(\"];\")\n+\n+def print_normal(normal, normalname):\n+    print(\"const {}: &'static [u8] = &[\".format(normalname))\n+    for v in normal:\n+        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(i) for i in v)))\n+    print(\"];\")\n+\n def main():\n     file = get_file(\"http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\")\n \n@@ -111,6 +171,11 @@ def main():\n             else:\n                 normal0.append((a, b - a))\n \n+    singletons0u, singletons0l = compress_singletons(singletons0)\n+    singletons1u, singletons1l = compress_singletons(singletons1)\n+    normal0 = compress_normal(normal0)\n+    normal1 = compress_normal(normal1)\n+\n     print(\"\"\"\\\n // Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -125,38 +190,49 @@ def main():\n // NOTE: The following code was generated by \"src/etc/char_private.py\",\n //       do not edit directly!\n \n-use slice::SliceExt;\n-\n-fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n-    for &s in singletons {\n-        if x == s {\n-            return false;\n-        } else if x < s {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n+         normal: &[u8]) -> bool {\n+    let xupper = (x >> 8) as u8;\n+    let mut lowerstart = 0;\n+    for &(upper, lowercount) in singletonuppers {\n+        let lowerend = lowerstart + lowercount as usize;\n+        if xupper == upper {\n+            for &lower in &singletonlowers[lowerstart..lowerend] {\n+                if lower == x as u8 {\n+                    return false;\n+                }\n+            }\n+        } else if xupper < upper {\n             break;\n         }\n+        lowerstart = lowerend;\n     }\n-    for w in normal.chunks(2) {\n-        let start = w[0];\n-        let len = w[1];\n-        let difference = (x as i32) - (start as i32);\n-        if 0 <= difference {\n-            if difference < len as i32 {\n-                return false;\n-            }\n+\n+    let mut x = x as i32;\n+    let mut normal = normal.iter().cloned();\n+    let mut current = true;\n+    while let Some(v) = normal.next() {\n+        let len = if v & 0x80 != 0 {\n+            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n         } else {\n+            v as i32\n+        };\n+        x -= len;\n+        if x < 0 {\n             break;\n         }\n+        current = !current;\n     }\n-    true\n+    current\n }\n \n pub fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {\n-        check(lower, SINGLETONS0, NORMAL0)\n+        check(lower, SINGLETONS0U, SINGLETONS0L, NORMAL0)\n     } else if x < 0x20000 {\n-        check(lower, SINGLETONS1, NORMAL1)\n+        check(lower, SINGLETONS1U, SINGLETONS1L, NORMAL1)\n     } else {\\\n \"\"\")\n     for a, b in extra:\n@@ -169,22 +245,10 @@ def main():\n }\\\n \"\"\")\n     print()\n-    print(\"const SINGLETONS0: &'static [u16] = &[\")\n-    for s in singletons0:\n-        print(\"    0x{:x},\".format(s))\n-    print(\"];\")\n-    print(\"const SINGLETONS1: &'static [u16] = &[\")\n-    for s in singletons1:\n-        print(\"    0x{:x},\".format(s))\n-    print(\"];\")\n-    print(\"const NORMAL0: &'static [u16] = &[\")\n-    for a, b in normal0:\n-        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n-    print(\"];\")\n-    print(\"const NORMAL1: &'static [u16] = &[\")\n-    for a, b in normal1:\n-        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n-    print(\"];\")\n+    print_singletons(singletons0u, singletons0l, 'SINGLETONS0U', 'SINGLETONS0L')\n+    print_singletons(singletons1u, singletons1l, 'SINGLETONS1U', 'SINGLETONS1L')\n+    print_normal(normal0, 'NORMAL0')\n+    print_normal(normal1, 'NORMAL1')\n \n if __name__ == '__main__':\n     main()"}, {"sha": "394ff97d84533872d535b598db50de8b8158de34", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -51,7 +51,7 @@ def make_win_dist(rust_root, plat_root, target_triple):\n \n     target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\"]\n \n-    rustc_dlls = [\"libstdc++-6.dll\"]\n+    rustc_dlls = [\"libstdc++-6.dll\", \"libwinpthread-1.dll\"]\n     if target_triple.startswith(\"i686-\"):\n         rustc_dlls.append(\"libgcc_s_dw2-1.dll\")\n     else:\n@@ -67,6 +67,7 @@ def make_win_dist(rust_root, plat_root, target_triple):\n                     \"libstdc++.a\",\n                     \"libiconv.a\",\n                     \"libmoldname.a\",\n+                    \"libpthread.a\",\n                     # Windows import libs\n                     \"libadvapi32.a\",\n                     \"libbcrypt.a\","}, {"sha": "7e92404bc0d6f3dce905231c980c41af9d7ec228", "filename": "src/libcollections/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -13,8 +13,8 @@ core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n [[test]]\n-name = \"collectionstest\"\n-path = \"../libcollectionstest/lib.rs\"\n+name = \"collectionstests\"\n+path = \"../libcollections/tests/lib.rs\"\n \n [[bench]]\n name = \"collectionsbenches\""}, {"sha": "248c15e96f8f65f3b432fbe7db9dc7645823c1d5", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -52,6 +52,7 @@\n #![feature(shared)]\n #![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n+#![feature(slice_rsplit)]\n #![cfg_attr(not(test), feature(sort_unstable))]\n #![feature(specialization)]\n #![feature(staged_api)]\n@@ -62,6 +63,7 @@\n #![feature(untagged_unions)]\n #![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n+#![feature(offset_to)]\n \n #![no_std]\n "}, {"sha": "1b3eeb837d909aba3257b66c3680bbc7b59faaef", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -697,8 +697,8 @@ impl<T> LinkedList<T> {\n \n     /// Returns a place for insertion at the front of the list.\n     ///\n-    /// Using this method with placement syntax is equivalent to [`push_front`]\n-    /// (#method.push_front), but may be more efficient.\n+    /// Using this method with placement syntax is equivalent to\n+    /// [`push_front`](#method.push_front), but may be more efficient.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6cff315a6ccd9eb28083d2b1f5b2afa9e8dc2430", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -115,6 +115,8 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{SplitMut, ChunksMut, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n@@ -779,6 +781,72 @@ impl<T> [T] {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, starting at the end of the slice and working backwards.\n+    /// The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let slice = [11, 22, 33, 0, 44, 55];\n+    /// let mut iter = slice.rsplit(|num| *num == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n+    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// As with `split()`, if the first or last element is matched, an empty\n+    /// slice will be the first (or last) item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n+    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n+    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`, starting at the end of the slice and working\n+    /// backwards. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let mut v = [100, 400, 300, 200, 600, 500];\n+    ///\n+    /// let mut count = 0;\n+    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n+    ///     count += 1;\n+    ///     group[0] = count;\n+    /// }\n+    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n+    /// ```\n+    ///\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit_mut(self, pred)\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices."}, {"sha": "d284937a9e676a0a56ce4824c3b8abb2dd62f8b1", "filename": "src/libcollections/tests/binary_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbinary_heap.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/binary_heap.rs"}, {"sha": "2c899d96940ece9e222adc3ff21600f7f164c708", "filename": "src/libcollections/tests/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbtree%2Fmap.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/btree/map.rs"}, {"sha": "ae8b18d0c9fd92203fef9cc2bfd826aad5883bcc", "filename": "src/libcollections/tests/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbtree%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/btree/mod.rs"}, {"sha": "6171b8ba624cd5581b505d3eb47cfc43d8e81c7c", "filename": "src/libcollections/tests/btree/set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbtree%2Fset.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/btree/set.rs"}, {"sha": "b29245121daadeb52d6c206130090d43e9406008", "filename": "src/libcollections/tests/cow_str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fcow_str.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/cow_str.rs"}, {"sha": "70e21c65a1806549eb10764d5bbb67ddfb616a6e", "filename": "src/libcollections/tests/fmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Ffmt.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/fmt.rs"}, {"sha": "618eb386c0f4c88887b1baab32c2cc553ce64a69", "filename": "src/libcollections/tests/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/lib.rs"}, {"sha": "a59724a017b1241de3e9995727a719782b76ea7f", "filename": "src/libcollections/tests/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flinked_list.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/linked_list.rs"}, {"sha": "c3e5304fb2b3544b855e7441d7ab32d88e0b7b09", "filename": "src/libcollections/tests/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fslice.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/slice.rs"}, {"sha": "c9b7104fec4f0072d2256f2b0de70153fd4648a9", "filename": "src/libcollections/tests/str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fstr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/str.rs"}, {"sha": "2f021b9935d6abc9b74daea6fdba81de54e9e765", "filename": "src/libcollections/tests/string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fstring.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/string.rs"}, {"sha": "63df0eb73050971b86dad86fe7e4814f53d23d32", "filename": "src/libcollections/tests/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fvec.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/vec.rs"}, {"sha": "f2935c05d4f7a90ac3112b0481fdac7057562652", "filename": "src/libcollections/tests/vec_deque.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fvec_deque.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcollectionstest/vec_deque.rs"}, {"sha": "35ecf411db4e0b2a998b03a18be4fcd7404ec701", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -678,8 +678,9 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Removes an element from anywhere in the vector and return it, replacing\n-    /// it with the last element.\n+    /// Removes an element from the vector and returns it.\n+    ///\n+    /// The removed element is replaced by the last element of the vector.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -972,6 +973,29 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Returns a place for insertion at the back of the `Vec`.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// let mut vec = vec![1, 2];\n+    /// vec.place_back() <- 3;\n+    /// vec.place_back() <- 4;\n+    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place_back(&mut self) -> PlaceBack<T> {\n+        PlaceBack { vec: self }\n+    }\n+\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n@@ -1266,29 +1290,6 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n     }\n-\n-    /// Returns a place for insertion at the back of the `Vec`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// vec.place_back() <- 3;\n-    /// vec.place_back() <- 4;\n-    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec: self }\n-    }\n }\n \n // Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1345,7 +1346,7 @@ impl<T: PartialEq> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    ///# #![feature(vec_remove_item)]\n+    /// # #![feature(vec_remove_item)]\n     /// let mut vec = vec![1, 2, 3, 1];\n     ///\n     /// vec.remove_item(&1);\n@@ -2073,14 +2074,10 @@ impl<T> Iterator for IntoIter<T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let diff = (self.end as usize) - (self.ptr as usize);\n-        let size = mem::size_of::<T>();\n-        let exact = diff /\n-                    (if size == 0 {\n-                         1\n-                     } else {\n-                         size\n-                     });\n+        let exact = match self.ptr.offset_to(self.end) {\n+            Some(x) => x as usize,\n+            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n+        };\n         (exact, Some(exact))\n     }\n "}, {"sha": "22f2ff1a3461830b13fd9ff25cdb579bd9c1c429", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -635,7 +635,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Shortens a `VecDeque`, dropping excess elements from the back.\n+    /// Shortens the `VecDeque`, dropping excess elements from the back.\n     ///\n     /// If `len` is greater than the `VecDeque`'s current length, this has no\n     /// effect.\n@@ -941,7 +941,7 @@ impl<T> VecDeque<T> {\n         a.contains(x) || b.contains(x)\n     }\n \n-    /// Provides a reference to the front element, or `None` if the sequence is\n+    /// Provides a reference to the front element, or `None` if the `VecDeque` is\n     /// empty.\n     ///\n     /// # Examples\n@@ -966,7 +966,7 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n-    /// sequence is empty.\n+    /// `VecDeque` is empty.\n     ///\n     /// # Examples\n     ///\n@@ -993,7 +993,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Provides a reference to the back element, or `None` if the sequence is\n+    /// Provides a reference to the back element, or `None` if the `VecDeque` is\n     /// empty.\n     ///\n     /// # Examples\n@@ -1018,7 +1018,7 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n-    /// sequence is empty.\n+    /// `VecDeque` is empty.\n     ///\n     /// # Examples\n     ///\n@@ -1046,7 +1046,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Removes the first element and returns it, or `None` if the sequence is\n+    /// Removes the first element and returns it, or `None` if the `VecDeque` is\n     /// empty.\n     ///\n     /// # Examples\n@@ -1073,7 +1073,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Inserts an element first in the sequence.\n+    /// Prepends an element to the `VecDeque`.\n     ///\n     /// # Examples\n     ///\n@@ -1096,7 +1096,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Appends an element to the back of a buffer\n+    /// Appends an element to the back of the `VecDeque`.\n     ///\n     /// # Examples\n     ///\n@@ -1117,7 +1117,7 @@ impl<T> VecDeque<T> {\n         unsafe { self.buffer_write(head, value) }\n     }\n \n-    /// Removes the last element from a buffer and returns it, or `None` if\n+    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n     /// it is empty.\n     ///\n     /// # Examples"}, {"sha": "5af63aa970f2c7cb50a720298b73dbc875e5b4c9", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -10,8 +10,8 @@ test = false\n bench = false\n \n [[test]]\n-name = \"coretest\"\n-path = \"../libcoretest/lib.rs\"\n+name = \"coretests\"\n+path = \"../libcore/tests/lib.rs\"\n \n [[bench]]\n name = \"corebenches\""}, {"sha": "2c0f449b27601405bdcb1014552944c36b2461e7", "filename": "src/libcore/char_private.rs", "status": "modified", "additions": 467, "deletions": 771, "changes": 1238, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fchar_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fchar_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar_private.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -11,38 +11,49 @@\n // NOTE: The following code was generated by \"src/etc/char_private.py\",\n //       do not edit directly!\n \n-use slice::SliceExt;\n-\n-fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n-    for &s in singletons {\n-        if x == s {\n-            return false;\n-        } else if x < s {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n+         normal: &[u8]) -> bool {\n+    let xupper = (x >> 8) as u8;\n+    let mut lowerstart = 0;\n+    for &(upper, lowercount) in singletonuppers {\n+        let lowerend = lowerstart + lowercount as usize;\n+        if xupper == upper {\n+            for &lower in &singletonlowers[lowerstart..lowerend] {\n+                if lower == x as u8 {\n+                    return false;\n+                }\n+            }\n+        } else if xupper < upper {\n             break;\n         }\n+        lowerstart = lowerend;\n     }\n-    for w in normal.chunks(2) {\n-        let start = w[0];\n-        let len = w[1];\n-        let difference = (x as i32) - (start as i32);\n-        if 0 <= difference {\n-            if difference < len as i32 {\n-                return false;\n-            }\n+\n+    let mut x = x as i32;\n+    let mut normal = normal.iter().cloned();\n+    let mut current = true;\n+    while let Some(v) = normal.next() {\n+        let len = if v & 0x80 != 0 {\n+            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n         } else {\n+            v as i32\n+        };\n+        x -= len;\n+        if x < 0 {\n             break;\n         }\n+        current = !current;\n     }\n-    true\n+    current\n }\n \n pub fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {\n-        check(lower, SINGLETONS0, NORMAL0)\n+        check(lower, SINGLETONS0U, SINGLETONS0L, NORMAL0)\n     } else if x < 0x20000 {\n-        check(lower, SINGLETONS1, NORMAL1)\n+        check(lower, SINGLETONS1U, SINGLETONS1L, NORMAL1)\n     } else {\n         if 0x2a6d7 <= x && x < 0x2a700 {\n             return false;\n@@ -66,761 +77,446 @@ pub fn is_printable(x: char) -> bool {\n     }\n }\n \n-const SINGLETONS0: &'static [u16] = &[\n-    0xad,\n-    0x378,\n-    0x379,\n-    0x38b,\n-    0x38d,\n-    0x3a2,\n-    0x530,\n-    0x557,\n-    0x558,\n-    0x560,\n-    0x588,\n-    0x58b,\n-    0x58c,\n-    0x590,\n-    0x61c,\n-    0x61d,\n-    0x6dd,\n-    0x70e,\n-    0x70f,\n-    0x74b,\n-    0x74c,\n-    0x82e,\n-    0x82f,\n-    0x83f,\n-    0x85c,\n-    0x85d,\n-    0x8b5,\n-    0x8e2,\n-    0x984,\n-    0x98d,\n-    0x98e,\n-    0x991,\n-    0x992,\n-    0x9a9,\n-    0x9b1,\n-    0x9ba,\n-    0x9bb,\n-    0x9c5,\n-    0x9c6,\n-    0x9c9,\n-    0x9ca,\n-    0x9de,\n-    0x9e4,\n-    0x9e5,\n-    0xa04,\n-    0xa11,\n-    0xa12,\n-    0xa29,\n-    0xa31,\n-    0xa34,\n-    0xa37,\n-    0xa3a,\n-    0xa3b,\n-    0xa3d,\n-    0xa49,\n-    0xa4a,\n-    0xa5d,\n-    0xa84,\n-    0xa8e,\n-    0xa92,\n-    0xaa9,\n-    0xab1,\n-    0xab4,\n-    0xaba,\n-    0xabb,\n-    0xac6,\n-    0xaca,\n-    0xace,\n-    0xacf,\n-    0xae4,\n-    0xae5,\n-    0xb04,\n-    0xb0d,\n-    0xb0e,\n-    0xb11,\n-    0xb12,\n-    0xb29,\n-    0xb31,\n-    0xb34,\n-    0xb3a,\n-    0xb3b,\n-    0xb45,\n-    0xb46,\n-    0xb49,\n-    0xb4a,\n-    0xb5e,\n-    0xb64,\n-    0xb65,\n-    0xb84,\n-    0xb91,\n-    0xb9b,\n-    0xb9d,\n-    0xbc9,\n-    0xbce,\n-    0xbcf,\n-    0xc04,\n-    0xc0d,\n-    0xc11,\n-    0xc29,\n-    0xc45,\n-    0xc49,\n-    0xc57,\n-    0xc64,\n-    0xc65,\n-    0xc84,\n-    0xc8d,\n-    0xc91,\n-    0xca9,\n-    0xcb4,\n-    0xcba,\n-    0xcbb,\n-    0xcc5,\n-    0xcc9,\n-    0xcdf,\n-    0xce4,\n-    0xce5,\n-    0xcf0,\n-    0xd04,\n-    0xd0d,\n-    0xd11,\n-    0xd3b,\n-    0xd3c,\n-    0xd45,\n-    0xd49,\n-    0xd64,\n-    0xd65,\n-    0xd80,\n-    0xd81,\n-    0xd84,\n-    0xdb2,\n-    0xdbc,\n-    0xdbe,\n-    0xdbf,\n-    0xdd5,\n-    0xdd7,\n-    0xdf0,\n-    0xdf1,\n-    0xe83,\n-    0xe85,\n-    0xe86,\n-    0xe89,\n-    0xe8b,\n-    0xe8c,\n-    0xe98,\n-    0xea0,\n-    0xea4,\n-    0xea6,\n-    0xea8,\n-    0xea9,\n-    0xeac,\n-    0xeba,\n-    0xebe,\n-    0xebf,\n-    0xec5,\n-    0xec7,\n-    0xece,\n-    0xecf,\n-    0xeda,\n-    0xedb,\n-    0xf48,\n-    0xf98,\n-    0xfbd,\n-    0xfcd,\n-    0x10c6,\n-    0x10ce,\n-    0x10cf,\n-    0x1249,\n-    0x124e,\n-    0x124f,\n-    0x1257,\n-    0x1259,\n-    0x125e,\n-    0x125f,\n-    0x1289,\n-    0x128e,\n-    0x128f,\n-    0x12b1,\n-    0x12b6,\n-    0x12b7,\n-    0x12bf,\n-    0x12c1,\n-    0x12c6,\n-    0x12c7,\n-    0x12d7,\n-    0x1311,\n-    0x1316,\n-    0x1317,\n-    0x135b,\n-    0x135c,\n-    0x13f6,\n-    0x13f7,\n-    0x13fe,\n-    0x13ff,\n-    0x1680,\n-    0x170d,\n-    0x176d,\n-    0x1771,\n-    0x17de,\n-    0x17df,\n-    0x180e,\n-    0x180f,\n-    0x191f,\n-    0x196e,\n-    0x196f,\n-    0x1a1c,\n-    0x1a1d,\n-    0x1a5f,\n-    0x1a7d,\n-    0x1a7e,\n-    0x1aae,\n-    0x1aaf,\n-    0x1cf7,\n-    0x1f16,\n-    0x1f17,\n-    0x1f1e,\n-    0x1f1f,\n-    0x1f46,\n-    0x1f47,\n-    0x1f4e,\n-    0x1f4f,\n-    0x1f58,\n-    0x1f5a,\n-    0x1f5c,\n-    0x1f5e,\n-    0x1f7e,\n-    0x1f7f,\n-    0x1fb5,\n-    0x1fc5,\n-    0x1fd4,\n-    0x1fd5,\n-    0x1fdc,\n-    0x1ff0,\n-    0x1ff1,\n-    0x1ff5,\n-    0x2072,\n-    0x2073,\n-    0x208f,\n-    0x23ff,\n-    0x2b74,\n-    0x2b75,\n-    0x2b96,\n-    0x2b97,\n-    0x2bc9,\n-    0x2c2f,\n-    0x2c5f,\n-    0x2d26,\n-    0x2d2e,\n-    0x2d2f,\n-    0x2da7,\n-    0x2daf,\n-    0x2db7,\n-    0x2dbf,\n-    0x2dc7,\n-    0x2dcf,\n-    0x2dd7,\n-    0x2ddf,\n-    0x2e9a,\n-    0x3040,\n-    0x3097,\n-    0x3098,\n-    0x318f,\n-    0x321f,\n-    0x32ff,\n-    0xa7af,\n-    0xa8fe,\n-    0xa8ff,\n-    0xa9ce,\n-    0xa9ff,\n-    0xaa4e,\n-    0xaa4f,\n-    0xaa5a,\n-    0xaa5b,\n-    0xab07,\n-    0xab08,\n-    0xab0f,\n-    0xab10,\n-    0xab27,\n-    0xab2f,\n-    0xabee,\n-    0xabef,\n-    0xfa6e,\n-    0xfa6f,\n-    0xfb37,\n-    0xfb3d,\n-    0xfb3f,\n-    0xfb42,\n-    0xfb45,\n-    0xfd90,\n-    0xfd91,\n-    0xfdfe,\n-    0xfdff,\n-    0xfe53,\n-    0xfe67,\n-    0xfe75,\n-    0xffc8,\n-    0xffc9,\n-    0xffd0,\n-    0xffd1,\n-    0xffd8,\n-    0xffd9,\n-    0xffe7,\n-    0xfffe,\n-    0xffff,\n+const SINGLETONS0U: &'static [(u8, u8)] = &[\n+    (0x00, 1),\n+    (0x03, 5),\n+    (0x05, 8),\n+    (0x06, 3),\n+    (0x07, 4),\n+    (0x08, 7),\n+    (0x09, 16),\n+    (0x0a, 27),\n+    (0x0b, 24),\n+    (0x0c, 22),\n+    (0x0d, 20),\n+    (0x0e, 22),\n+    (0x0f, 4),\n+    (0x10, 3),\n+    (0x12, 18),\n+    (0x13, 9),\n+    (0x16, 1),\n+    (0x17, 5),\n+    (0x18, 2),\n+    (0x19, 3),\n+    (0x1a, 7),\n+    (0x1c, 1),\n+    (0x1f, 22),\n+    (0x20, 3),\n+    (0x23, 1),\n+    (0x2b, 5),\n+    (0x2c, 2),\n+    (0x2d, 11),\n+    (0x2e, 1),\n+    (0x30, 3),\n+    (0x31, 1),\n+    (0x32, 2),\n+    (0xa7, 1),\n+    (0xa8, 2),\n+    (0xa9, 2),\n+    (0xaa, 4),\n+    (0xab, 8),\n+    (0xfa, 2),\n+    (0xfb, 5),\n+    (0xfd, 4),\n+    (0xfe, 3),\n+    (0xff, 9),\n ];\n-const SINGLETONS1: &'static [u16] = &[\n-    0xc,\n-    0x27,\n-    0x3b,\n-    0x3e,\n-    0x4e,\n-    0x4f,\n-    0x18f,\n-    0x39e,\n-    0x49e,\n-    0x49f,\n-    0x806,\n-    0x807,\n-    0x809,\n-    0x836,\n-    0x83d,\n-    0x83e,\n-    0x856,\n-    0x8f3,\n-    0x9d0,\n-    0x9d1,\n-    0xa04,\n-    0xa14,\n-    0xa18,\n-    0xb56,\n-    0xb57,\n-    0x10bd,\n-    0x1135,\n-    0x11ce,\n-    0x11cf,\n-    0x11e0,\n-    0x1212,\n-    0x1287,\n-    0x1289,\n-    0x128e,\n-    0x129e,\n-    0x1304,\n-    0x130d,\n-    0x130e,\n-    0x1311,\n-    0x1312,\n-    0x1329,\n-    0x1331,\n-    0x1334,\n-    0x133a,\n-    0x133b,\n-    0x1345,\n-    0x1346,\n-    0x1349,\n-    0x134a,\n-    0x134e,\n-    0x134f,\n-    0x1364,\n-    0x1365,\n-    0x145a,\n-    0x145c,\n-    0x15b6,\n-    0x15b7,\n-    0x1c09,\n-    0x1c37,\n-    0x1c90,\n-    0x1c91,\n-    0x1ca8,\n-    0x246f,\n-    0x6a5f,\n-    0x6aee,\n-    0x6aef,\n-    0x6b5a,\n-    0x6b62,\n-    0xbc9a,\n-    0xbc9b,\n-    0xd127,\n-    0xd128,\n-    0xd455,\n-    0xd49d,\n-    0xd4a0,\n-    0xd4a1,\n-    0xd4a3,\n-    0xd4a4,\n-    0xd4a7,\n-    0xd4a8,\n-    0xd4ad,\n-    0xd4ba,\n-    0xd4bc,\n-    0xd4c4,\n-    0xd506,\n-    0xd50b,\n-    0xd50c,\n-    0xd515,\n-    0xd51d,\n-    0xd53a,\n-    0xd53f,\n-    0xd545,\n-    0xd551,\n-    0xd6a6,\n-    0xd6a7,\n-    0xd7cc,\n-    0xd7cd,\n-    0xdaa0,\n-    0xe007,\n-    0xe019,\n-    0xe01a,\n-    0xe022,\n-    0xe025,\n-    0xe8c5,\n-    0xe8c6,\n-    0xee04,\n-    0xee20,\n-    0xee23,\n-    0xee25,\n-    0xee26,\n-    0xee28,\n-    0xee33,\n-    0xee38,\n-    0xee3a,\n-    0xee48,\n-    0xee4a,\n-    0xee4c,\n-    0xee50,\n-    0xee53,\n-    0xee55,\n-    0xee56,\n-    0xee58,\n-    0xee5a,\n-    0xee5c,\n-    0xee5e,\n-    0xee60,\n-    0xee63,\n-    0xee65,\n-    0xee66,\n-    0xee6b,\n-    0xee73,\n-    0xee78,\n-    0xee7d,\n-    0xee7f,\n-    0xee8a,\n-    0xeea4,\n-    0xeeaa,\n-    0xf0af,\n-    0xf0b0,\n-    0xf0c0,\n-    0xf0d0,\n-    0xf12f,\n-    0xf91f,\n-    0xf931,\n-    0xf932,\n-    0xf93f,\n+const SINGLETONS0L: &'static [u8] = &[\n+    0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n+    0x58, 0x60, 0x88, 0x8b, 0x8c, 0x90, 0x1c, 0x1d,\n+    0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0x2e, 0x2f, 0x3f,\n+    0x5c, 0x5d, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91,\n+    0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6, 0xc9,\n+    0xca, 0xde, 0xe4, 0xe5, 0x04, 0x11, 0x12, 0x29,\n+    0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a,\n+    0x5d, 0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba,\n+    0xbb, 0xc6, 0xca, 0xce, 0xcf, 0xe4, 0xe5, 0x04,\n+    0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,\n+    0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65,\n+    0x84, 0x91, 0x9b, 0x9d, 0xc9, 0xce, 0xcf, 0x04,\n+    0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65,\n+    0x84, 0x8d, 0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5,\n+    0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04, 0x0d, 0x11,\n+    0x3b, 0x3c, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n+    0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5, 0xd7, 0xf0,\n+    0xf1, 0x83, 0x85, 0x86, 0x89, 0x8b, 0x8c, 0x98,\n+    0xa0, 0xa4, 0xa6, 0xa8, 0xa9, 0xac, 0xba, 0xbe,\n+    0xbf, 0xc5, 0xc7, 0xce, 0xcf, 0xda, 0xdb, 0x48,\n+    0x98, 0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49, 0x4e,\n+    0x4f, 0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f,\n+    0xb1, 0xb6, 0xb7, 0xbf, 0xc1, 0xc6, 0xc7, 0xd7,\n+    0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7, 0xfe,\n+    0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e,\n+    0x0f, 0x1f, 0x6e, 0x6f, 0x1c, 0x1d, 0x5f, 0x7d,\n+    0x7e, 0xae, 0xaf, 0xf7, 0x16, 0x17, 0x1e, 0x1f,\n+    0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e,\n+    0x7e, 0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0,\n+    0xf1, 0xf5, 0x72, 0x73, 0x8f, 0xff, 0x74, 0x75,\n+    0x96, 0x97, 0xc9, 0x2f, 0x5f, 0x26, 0x2e, 0x2f,\n+    0xa7, 0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf,\n+    0x9a, 0x40, 0x97, 0x98, 0x8f, 0x1f, 0xff, 0xaf,\n+    0xfe, 0xff, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b,\n+    0x07, 0x08, 0x0f, 0x10, 0x27, 0x2f, 0xee, 0xef,\n+    0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90,\n+    0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n+    0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n-const NORMAL0: &'static [u16] = &[\n-    0x0, 0x20,\n-    0x7f, 0x22,\n-    0x380, 0x4,\n-    0x5c8, 0x8,\n-    0x5eb, 0x5,\n-    0x5f5, 0x11,\n-    0x7b2, 0xe,\n-    0x7fb, 0x5,\n-    0x85f, 0x41,\n-    0x8be, 0x16,\n-    0x9b3, 0x3,\n-    0x9cf, 0x8,\n-    0x9d8, 0x4,\n-    0x9fc, 0x5,\n-    0xa0b, 0x4,\n-    0xa43, 0x4,\n-    0xa4e, 0x3,\n-    0xa52, 0x7,\n-    0xa5f, 0x7,\n-    0xa76, 0xb,\n-    0xad1, 0xf,\n-    0xaf2, 0x7,\n-    0xafa, 0x7,\n-    0xb4e, 0x8,\n-    0xb58, 0x4,\n-    0xb78, 0xa,\n-    0xb8b, 0x3,\n-    0xb96, 0x3,\n-    0xba0, 0x3,\n-    0xba5, 0x3,\n-    0xbab, 0x3,\n-    0xbba, 0x4,\n-    0xbc3, 0x3,\n-    0xbd1, 0x6,\n-    0xbd8, 0xe,\n-    0xbfb, 0x5,\n-    0xc3a, 0x3,\n-    0xc4e, 0x7,\n-    0xc5b, 0x5,\n-    0xc70, 0x8,\n-    0xcce, 0x7,\n-    0xcd7, 0x7,\n-    0xcf3, 0xe,\n-    0xd50, 0x4,\n-    0xd97, 0x3,\n-    0xdc7, 0x3,\n-    0xdcb, 0x4,\n-    0xde0, 0x6,\n-    0xdf5, 0xc,\n-    0xe3b, 0x4,\n-    0xe5c, 0x25,\n-    0xe8e, 0x6,\n-    0xee0, 0x20,\n-    0xf6d, 0x4,\n-    0xfdb, 0x25,\n-    0x10c8, 0x5,\n-    0x137d, 0x3,\n-    0x139a, 0x6,\n-    0x169d, 0x3,\n-    0x16f9, 0x7,\n-    0x1715, 0xb,\n-    0x1737, 0x9,\n-    0x1754, 0xc,\n-    0x1774, 0xc,\n-    0x17ea, 0x6,\n-    0x17fa, 0x6,\n-    0x181a, 0x6,\n-    0x1878, 0x8,\n-    0x18ab, 0x5,\n-    0x18f6, 0xa,\n-    0x192c, 0x4,\n-    0x193c, 0x4,\n-    0x1941, 0x3,\n-    0x1975, 0xb,\n-    0x19ac, 0x4,\n-    0x19ca, 0x6,\n-    0x19db, 0x3,\n-    0x1a8a, 0x6,\n-    0x1a9a, 0x6,\n-    0x1abf, 0x41,\n-    0x1b4c, 0x4,\n-    0x1b7d, 0x3,\n-    0x1bf4, 0x8,\n-    0x1c38, 0x3,\n-    0x1c4a, 0x3,\n-    0x1c89, 0x37,\n-    0x1cc8, 0x8,\n-    0x1cfa, 0x6,\n-    0x1df6, 0x5,\n-    0x1fff, 0x11,\n-    0x2028, 0x8,\n-    0x205f, 0x11,\n-    0x209d, 0x3,\n-    0x20bf, 0x11,\n-    0x20f1, 0xf,\n-    0x218c, 0x4,\n-    0x2427, 0x19,\n-    0x244b, 0x15,\n-    0x2bba, 0x3,\n-    0x2bd2, 0x1a,\n-    0x2bf0, 0x10,\n-    0x2cf4, 0x5,\n-    0x2d28, 0x5,\n-    0x2d68, 0x7,\n-    0x2d71, 0xe,\n-    0x2d97, 0x9,\n-    0x2e45, 0x3b,\n-    0x2ef4, 0xc,\n-    0x2fd6, 0x1a,\n-    0x2ffc, 0x5,\n-    0x3100, 0x5,\n-    0x312e, 0x3,\n-    0x31bb, 0x5,\n-    0x31e4, 0xc,\n-    0x4db6, 0xa,\n-    0x9fd6, 0x2a,\n-    0xa48d, 0x3,\n-    0xa4c7, 0x9,\n-    0xa62c, 0x14,\n-    0xa6f8, 0x8,\n-    0xa7b8, 0x3f,\n-    0xa82c, 0x4,\n-    0xa83a, 0x6,\n-    0xa878, 0x8,\n-    0xa8c6, 0x8,\n-    0xa8da, 0x6,\n-    0xa954, 0xb,\n-    0xa97d, 0x3,\n-    0xa9da, 0x4,\n-    0xaa37, 0x9,\n-    0xaac3, 0x18,\n-    0xaaf7, 0xa,\n-    0xab17, 0x9,\n-    0xab66, 0xa,\n-    0xabfa, 0x6,\n-    0xd7a4, 0xc,\n-    0xd7c7, 0x4,\n-    0xd7fc, 0x2104,\n-    0xfada, 0x26,\n-    0xfb07, 0xc,\n-    0xfb18, 0x5,\n-    0xfbc2, 0x11,\n-    0xfd40, 0x10,\n-    0xfdc8, 0x28,\n-    0xfe1a, 0x6,\n-    0xfe6c, 0x4,\n-    0xfefd, 0x4,\n-    0xffbf, 0x3,\n-    0xffdd, 0x3,\n-    0xffef, 0xd,\n+const SINGLETONS1U: &'static [(u8, u8)] = &[\n+    (0x00, 6),\n+    (0x01, 1),\n+    (0x03, 1),\n+    (0x04, 2),\n+    (0x08, 8),\n+    (0x09, 2),\n+    (0x0a, 3),\n+    (0x0b, 2),\n+    (0x10, 1),\n+    (0x11, 4),\n+    (0x12, 5),\n+    (0x13, 18),\n+    (0x14, 2),\n+    (0x15, 2),\n+    (0x1c, 5),\n+    (0x24, 1),\n+    (0x6a, 3),\n+    (0x6b, 2),\n+    (0xbc, 2),\n+    (0xd1, 2),\n+    (0xd4, 12),\n+    (0xd5, 9),\n+    (0xd6, 2),\n+    (0xd7, 2),\n+    (0xda, 1),\n+    (0xe0, 5),\n+    (0xe8, 2),\n+    (0xee, 32),\n+    (0xf0, 4),\n+    (0xf1, 1),\n+    (0xf9, 4),\n ];\n-const NORMAL1: &'static [u16] = &[\n+const SINGLETONS1L: &'static [u8] = &[\n+    0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n+    0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n+    0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x56,\n+    0x57, 0xbd, 0x35, 0xce, 0xcf, 0xe0, 0x12, 0x87,\n+    0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12,\n+    0x29, 0x31, 0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49,\n+    0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5a, 0x5c, 0xb6,\n+    0xb7, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x6f, 0x5f,\n+    0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28,\n+    0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8,\n+    0xad, 0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15,\n+    0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc,\n+    0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0xc5,\n+    0xc6, 0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33,\n+    0x38, 0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53, 0x55,\n+    0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65,\n+    0x66, 0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4,\n+    0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x2f, 0x1f, 0x31,\n+    0x32, 0x3f,\n+];\n+const NORMAL0: &'static [u8] = &[\n+    0x00, 0x20,\n+    0x5f, 0x22,\n+    0x82, 0xdf, 0x04,\n+    0x82, 0x44, 0x08,\n+    0x1b, 0x05,\n+    0x05, 0x11,\n+    0x81, 0xac, 0x0e,\n+    0x3b, 0x05,\n+    0x5f, 0x41,\n+    0x1e, 0x16,\n+    0x80, 0xdf, 0x03,\n+    0x19, 0x08,\n+    0x01, 0x04,\n+    0x20, 0x05,\n+    0x0a, 0x04,\n+    0x34, 0x04,\n+    0x07, 0x03,\n+    0x01, 0x07,\n+    0x06, 0x07,\n+    0x10, 0x0b,\n+    0x50, 0x0f,\n+    0x12, 0x07,\n+    0x01, 0x07,\n+    0x4d, 0x08,\n+    0x02, 0x04,\n+    0x1c, 0x0a,\n+    0x09, 0x03,\n+    0x08, 0x03,\n+    0x07, 0x03,\n+    0x02, 0x03,\n+    0x03, 0x03,\n+    0x0c, 0x04,\n+    0x05, 0x03,\n+    0x0b, 0x06,\n+    0x01, 0x0e,\n+    0x15, 0x05,\n+    0x3a, 0x03,\n+    0x11, 0x07,\n+    0x06, 0x05,\n+    0x10, 0x08,\n+    0x56, 0x07,\n+    0x02, 0x07,\n+    0x15, 0x0e,\n+    0x4f, 0x04,\n+    0x43, 0x03,\n+    0x2d, 0x03,\n+    0x01, 0x04,\n+    0x11, 0x06,\n+    0x0f, 0x0c,\n+    0x3a, 0x04,\n+    0x1d, 0x25,\n+    0x0d, 0x06,\n+    0x4c, 0x20,\n+    0x6d, 0x04,\n+    0x6a, 0x25,\n+    0x80, 0xc8, 0x05,\n+    0x82, 0xb0, 0x03,\n+    0x1a, 0x06,\n+    0x82, 0xfd, 0x03,\n+    0x59, 0x07,\n+    0x15, 0x0b,\n+    0x17, 0x09,\n+    0x14, 0x0c,\n+    0x14, 0x0c,\n+    0x6a, 0x06,\n+    0x0a, 0x06,\n+    0x1a, 0x06,\n+    0x58, 0x08,\n+    0x2b, 0x05,\n+    0x46, 0x0a,\n+    0x2c, 0x04,\n+    0x0c, 0x04,\n+    0x01, 0x03,\n+    0x31, 0x0b,\n+    0x2c, 0x04,\n+    0x1a, 0x06,\n+    0x0b, 0x03,\n+    0x80, 0xac, 0x06,\n+    0x0a, 0x06,\n+    0x1f, 0x41,\n+    0x4c, 0x04,\n+    0x2d, 0x03,\n+    0x74, 0x08,\n+    0x3c, 0x03,\n+    0x0f, 0x03,\n+    0x3c, 0x37,\n+    0x08, 0x08,\n+    0x2a, 0x06,\n+    0x80, 0xf6, 0x05,\n+    0x82, 0x04, 0x11,\n+    0x18, 0x08,\n+    0x2f, 0x11,\n+    0x2d, 0x03,\n+    0x1f, 0x11,\n+    0x21, 0x0f,\n+    0x80, 0x8c, 0x04,\n+    0x82, 0x97, 0x19,\n+    0x0b, 0x15,\n+    0x87, 0x5a, 0x03,\n+    0x15, 0x1a,\n+    0x04, 0x10,\n+    0x80, 0xf4, 0x05,\n+    0x2f, 0x05,\n+    0x3b, 0x07,\n+    0x02, 0x0e,\n+    0x18, 0x09,\n+    0x80, 0xa5, 0x3b,\n+    0x74, 0x0c,\n+    0x80, 0xd6, 0x1a,\n+    0x0c, 0x05,\n+    0x80, 0xff, 0x05,\n+    0x29, 0x03,\n+    0x80, 0x8a, 0x05,\n+    0x24, 0x0c,\n+    0x9b, 0xc6, 0x0a,\n+    0xd2, 0x16, 0x2a,\n+    0x84, 0x8d, 0x03,\n+    0x37, 0x09,\n+    0x81, 0x5c, 0x14,\n+    0x80, 0xb8, 0x08,\n+    0x80, 0xb8, 0x3f,\n+    0x35, 0x04,\n+    0x0a, 0x06,\n+    0x38, 0x08,\n+    0x46, 0x08,\n+    0x0c, 0x06,\n+    0x74, 0x0b,\n+    0x1e, 0x03,\n+    0x5a, 0x04,\n+    0x59, 0x09,\n+    0x80, 0x83, 0x18,\n+    0x1c, 0x0a,\n+    0x16, 0x09,\n+    0x46, 0x0a,\n+    0x80, 0x8a, 0x06,\n+    0xab, 0xa4, 0x0c,\n+    0x17, 0x04,\n+    0x31, 0xa1, 0x04,\n+    0x81, 0xda, 0x26,\n+    0x07, 0x0c,\n+    0x05, 0x05,\n+    0x80, 0xa5, 0x11,\n+    0x81, 0x6d, 0x10,\n+    0x78, 0x28,\n+    0x2a, 0x06,\n+    0x4c, 0x04,\n+    0x80, 0x8d, 0x04,\n+    0x80, 0xbe, 0x03,\n+    0x1b, 0x03,\n+    0x0f, 0x0d,\n+];\n+const NORMAL1: &'static [u8] = &[\n+    0x5e, 0x22,\n+    0x7b, 0x05,\n+    0x03, 0x04,\n+    0x2d, 0x03,\n+    0x65, 0x04,\n+    0x01, 0x2f,\n+    0x2e, 0x80, 0x82,\n+    0x1d, 0x03,\n+    0x31, 0x0f,\n+    0x1c, 0x04,\n+    0x24, 0x0c,\n+    0x1b, 0x05,\n+    0x2b, 0x05,\n+    0x44, 0x04,\n+    0x0e, 0x2a,\n+    0x80, 0xaa, 0x06,\n+    0x24, 0x04,\n+    0x24, 0x04,\n+    0x28, 0x08,\n+    0x34, 0x0b,\n+    0x01, 0x80, 0x90,\n+    0x81, 0x37, 0x09,\n+    0x16, 0x0a,\n+    0x08, 0x80, 0x98,\n+    0x39, 0x03,\n+    0x63, 0x08,\n+    0x09, 0x30,\n+    0x16, 0x05,\n+    0x21, 0x03,\n+    0x1b, 0x05,\n+    0x01, 0x40,\n+    0x38, 0x04,\n+    0x4b, 0x05,\n+    0x28, 0x04,\n+    0x03, 0x04,\n+    0x09, 0x08,\n+    0x09, 0x07,\n+    0x40, 0x20,\n+    0x27, 0x04,\n+    0x0c, 0x09,\n+    0x36, 0x03,\n+    0x3a, 0x05,\n+    0x1a, 0x07,\n+    0x04, 0x0c,\n+    0x07, 0x50,\n+    0x49, 0x37,\n+    0x33, 0x0d,\n+    0x33, 0x07,\n+    0x06, 0x81, 0x60,\n+    0x1f, 0x81, 0x81,\n+    0x4e, 0x04,\n+    0x1e, 0x0f,\n+    0x43, 0x0e,\n+    0x19, 0x07,\n+    0x0a, 0x06,\n+    0x44, 0x0c,\n+    0x27, 0x09,\n+    0x75, 0x0b,\n+    0x3f, 0x41,\n+    0x2a, 0x06,\n+    0x3b, 0x05,\n+    0x0a, 0x06,\n+    0x51, 0x06,\n+    0x01, 0x05,\n+    0x10, 0x03,\n+    0x05, 0x80, 0x8b,\n+    0x5e, 0x22,\n+    0x48, 0x08,\n+    0x0a, 0x80, 0xa6,\n     0x5e, 0x22,\n-    0xfb, 0x5,\n-    0x103, 0x4,\n-    0x134, 0x3,\n-    0x19c, 0x4,\n-    0x1a1, 0x2f,\n-    0x1fe, 0x82,\n-    0x29d, 0x3,\n-    0x2d1, 0xf,\n-    0x2fc, 0x4,\n-    0x324, 0xc,\n-    0x34b, 0x5,\n-    0x37b, 0x5,\n-    0x3c4, 0x4,\n-    0x3d6, 0x2a,\n-    0x4aa, 0x6,\n-    0x4d4, 0x4,\n-    0x4fc, 0x4,\n-    0x528, 0x8,\n-    0x564, 0xb,\n-    0x570, 0x90,\n-    0x737, 0x9,\n-    0x756, 0xa,\n-    0x768, 0x98,\n-    0x839, 0x3,\n-    0x89f, 0x8,\n-    0x8b0, 0x30,\n-    0x8f6, 0x5,\n-    0x91c, 0x3,\n-    0x93a, 0x5,\n-    0x940, 0x40,\n-    0x9b8, 0x4,\n-    0xa07, 0x5,\n-    0xa34, 0x4,\n-    0xa3b, 0x4,\n-    0xa48, 0x8,\n-    0xa59, 0x7,\n-    0xaa0, 0x20,\n-    0xae7, 0x4,\n-    0xaf7, 0x9,\n-    0xb36, 0x3,\n-    0xb73, 0x5,\n-    0xb92, 0x7,\n-    0xb9d, 0xc,\n-    0xbb0, 0x50,\n-    0xc49, 0x37,\n-    0xcb3, 0xd,\n-    0xcf3, 0x7,\n-    0xd00, 0x160,\n-    0xe7f, 0x181,\n-    0x104e, 0x4,\n-    0x1070, 0xf,\n-    0x10c2, 0xe,\n-    0x10e9, 0x7,\n-    0x10fa, 0x6,\n-    0x1144, 0xc,\n-    0x1177, 0x9,\n-    0x11f5, 0xb,\n-    0x123f, 0x41,\n-    0x12aa, 0x6,\n-    0x12eb, 0x5,\n-    0x12fa, 0x6,\n-    0x1351, 0x6,\n-    0x1358, 0x5,\n-    0x136d, 0x3,\n-    0x1375, 0x8b,\n-    0x145e, 0x22,\n-    0x14c8, 0x8,\n-    0x14da, 0xa6,\n-    0x15de, 0x22,\n-    0x1645, 0xb,\n-    0x165a, 0x6,\n-    0x166d, 0x13,\n-    0x16b8, 0x8,\n-    0x16ca, 0x36,\n-    0x171a, 0x3,\n-    0x172c, 0x4,\n-    0x1740, 0x160,\n-    0x18f3, 0xc,\n-    0x1900, 0x1c0,\n-    0x1af9, 0x107,\n-    0x1c46, 0xa,\n-    0x1c6d, 0x3,\n-    0x1cb7, 0x349,\n-    0x239a, 0x66,\n-    0x2475, 0xb,\n-    0x2544, 0xabc,\n-    0x342f, 0xfd1,\n-    0x4647, 0x21b9,\n-    0x6a39, 0x7,\n-    0x6a6a, 0x4,\n-    0x6a70, 0x60,\n-    0x6af6, 0xa,\n-    0x6b46, 0xa,\n-    0x6b78, 0x5,\n-    0x6b90, 0x370,\n-    0x6f45, 0xb,\n-    0x6f7f, 0x10,\n-    0x6fa0, 0x40,\n-    0x6fe1, 0x1f,\n-    0x87ed, 0x13,\n-    0x8af3, 0x250d,\n-    0xb002, 0xbfe,\n-    0xbc6b, 0x5,\n-    0xbc7d, 0x3,\n-    0xbc89, 0x7,\n-    0xbca0, 0x1360,\n-    0xd0f6, 0xa,\n-    0xd173, 0x8,\n-    0xd1e9, 0x17,\n-    0xd246, 0xba,\n-    0xd357, 0x9,\n-    0xd372, 0x8e,\n-    0xd547, 0x3,\n-    0xda8c, 0xf,\n-    0xdab0, 0x550,\n-    0xe02b, 0x7d5,\n-    0xe8d7, 0x29,\n-    0xe94b, 0x5,\n-    0xe95a, 0x4,\n-    0xe960, 0x4a0,\n-    0xee3c, 0x6,\n-    0xee43, 0x4,\n-    0xee9c, 0x5,\n-    0xeebc, 0x34,\n-    0xeef2, 0x10e,\n-    0xf02c, 0x4,\n-    0xf094, 0xc,\n-    0xf0f6, 0xa,\n-    0xf10d, 0x3,\n-    0xf16c, 0x4,\n-    0xf1ad, 0x39,\n-    0xf203, 0xd,\n-    0xf23c, 0x4,\n-    0xf249, 0x7,\n-    0xf252, 0xae,\n-    0xf6d3, 0xd,\n-    0xf6ed, 0x3,\n-    0xf6f7, 0x9,\n-    0xf774, 0xc,\n-    0xf7d5, 0x2b,\n-    0xf80c, 0x4,\n-    0xf848, 0x8,\n-    0xf85a, 0x6,\n-    0xf888, 0x8,\n-    0xf8ae, 0x62,\n-    0xf928, 0x8,\n-    0xf94c, 0x4,\n-    0xf95f, 0x21,\n-    0xf992, 0x2e,\n-    0xf9c1, 0x63f,\n+    0x45, 0x0b,\n+    0x0a, 0x06,\n+    0x0d, 0x13,\n+    0x38, 0x08,\n+    0x0a, 0x36,\n+    0x1a, 0x03,\n+    0x0f, 0x04,\n+    0x10, 0x81, 0x60,\n+    0x53, 0x0c,\n+    0x01, 0x81, 0xc0,\n+    0x39, 0x81, 0x07,\n+    0x46, 0x0a,\n+    0x1d, 0x03,\n+    0x47, 0x83, 0x49,\n+    0x83, 0x9a, 0x66,\n+    0x75, 0x0b,\n+    0x80, 0xc4, 0x8a, 0xbc,\n+    0x84, 0x2f, 0x8f, 0xd1,\n+    0x82, 0x47, 0xa1, 0xb9,\n+    0x82, 0x39, 0x07,\n+    0x2a, 0x04,\n+    0x02, 0x60,\n+    0x26, 0x0a,\n+    0x46, 0x0a,\n+    0x28, 0x05,\n+    0x13, 0x83, 0x70,\n+    0x45, 0x0b,\n+    0x2f, 0x10,\n+    0x11, 0x40,\n+    0x01, 0x1f,\n+    0x97, 0xed, 0x13,\n+    0x82, 0xf3, 0xa5, 0x0d,\n+    0x02, 0x8b, 0xfe,\n+    0x6b, 0x05,\n+    0x0d, 0x03,\n+    0x09, 0x07,\n+    0x10, 0x93, 0x60,\n+    0x80, 0xf6, 0x0a,\n+    0x73, 0x08,\n+    0x6e, 0x17,\n+    0x46, 0x80, 0xba,\n+    0x57, 0x09,\n+    0x12, 0x80, 0x8e,\n+    0x81, 0x47, 0x03,\n+    0x85, 0x42, 0x0f,\n+    0x15, 0x85, 0x50,\n+    0x2b, 0x87, 0xd5,\n+    0x80, 0xd7, 0x29,\n+    0x4b, 0x05,\n+    0x0a, 0x04,\n+    0x02, 0x84, 0xa0,\n+    0x3c, 0x06,\n+    0x01, 0x04,\n+    0x55, 0x05,\n+    0x1b, 0x34,\n+    0x02, 0x81, 0x0e,\n+    0x2c, 0x04,\n+    0x64, 0x0c,\n+    0x56, 0x0a,\n+    0x0d, 0x03,\n+    0x5c, 0x04,\n+    0x3d, 0x39,\n+    0x1d, 0x0d,\n+    0x2c, 0x04,\n+    0x09, 0x07,\n+    0x02, 0x80, 0xae,\n+    0x83, 0xd3, 0x0d,\n+    0x0d, 0x03,\n+    0x07, 0x09,\n+    0x74, 0x0c,\n+    0x55, 0x2b,\n+    0x0c, 0x04,\n+    0x38, 0x08,\n+    0x0a, 0x06,\n+    0x28, 0x08,\n+    0x1e, 0x62,\n+    0x18, 0x08,\n+    0x1c, 0x04,\n+    0x0f, 0x21,\n+    0x12, 0x2e,\n+    0x01, 0x86, 0x3f,\n ];"}, {"sha": "e0a4707ff665f58c0bdedbb8fed6f6e29bc897be", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 57, "deletions": 39, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -61,16 +61,18 @@ extern \"rust-intrinsic\" {\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -79,8 +81,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -89,16 +92,18 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -107,8 +112,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -117,8 +123,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -127,8 +134,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -137,25 +145,28 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange).\n+    /// [`AtomicBool::compare_exchange`][compare_exchange].\n+    ///\n+    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n     pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -164,8 +175,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -174,16 +186,18 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -192,8 +206,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -202,8 +217,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -212,8 +228,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     /// The stabilized version of this intrinsic is available on the\n@@ -222,8 +239,9 @@ extern \"rust-intrinsic\" {\n     /// as the `success` and\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`]\n-    /// (../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak).\n+    /// [`AtomicBool::compare_exchange_weak`][cew].\n+    ///\n+    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n@@ -1253,17 +1271,17 @@ extern \"rust-intrinsic\" {\n     #[cfg(not(stage0))]\n     pub fn unchecked_shr<T>(x: T, y: T) -> T;\n \n-    /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n+    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n-    /// Returns (a - b) mod 2^N, where N is the width of T in bits.\n+    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n-    /// Returns (a * b) mod 2^N, where N is the width of T in bits.\n+    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)"}, {"sha": "273f9d0e6f6d31cf9581cbafb0fde73d7f569f96", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -358,12 +358,24 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.rfind(predicate)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.find(predicate)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "798dda199281310a58c3740c084803a41fa37a5e", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -467,7 +467,7 @@ pub trait DoubleEndedIterator: Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        for x in self.by_ref().rev() {\n+        while let Some(x) = self.next_back() {\n             if predicate(&x) { return Some(x) }\n         }\n         None"}, {"sha": "b5553fb29475b9481251e62d0d9eea761f9599b3", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -19,7 +19,7 @@\n //! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n //! tracked for the actual usages, so it normally doesn't matter.\n \n-// This module is only for dec2flt and flt2dec, and only public because of libcoretest.\n+// This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n #![unstable(feature = \"core_private_bignum\","}, {"sha": "45fa721a5a33e0b71c8504e3e0b5ef9a1ab6487c", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -10,12 +10,12 @@\n \n //! Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n //! Normal floating point numbers have a canonical representation as (frac, exp) such that the\n-//! value is 2^exp * (1 + sum(frac[N-i] / 2^i)) where N is the number of bits. Subnormals are\n-//! slightly different and weird, but the same principle applies.\n+//! value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n+//! Subnormals are slightly different and weird, but the same principle applies.\n //!\n-//! Here, however, we represent them as (sig, k) with f positive, such that the value is f * 2^e.\n-//! Besides making the \"hidden bit\" explicit, this changes the exponent by the so-called\n-//! mantissa shift.\n+//! Here, however, we represent them as (sig, k) with f positive, such that the value is f *\n+//! 2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the\n+//! so-called mantissa shift.\n //!\n //! Put another way, normally floats are written as (1) but here they are written as (2):\n //!\n@@ -94,7 +94,8 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10^e from a pre-computed table. Panics for e >= ceil_log5_of_max_sig().\n+    /// Get the value 10<sup>e</sup> from a pre-computed table. Panics for e >=\n+    /// ceil_log5_of_max_sig().\n     fn short_fast_pow10(e: usize) -> Self;\n \n     // FIXME Everything that follows should be associated constants, but taking the value of an"}, {"sha": "6635d95155f4baa4537a0cce133ff8f10bb806a6", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -10,7 +10,7 @@\n \n //! Extended precision \"soft float\", for internal use only.\n \n-// This module is only for dec2flt and flt2dec, and only public because of libcoretest.\n+// This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n #![unstable(feature = \"core_private_diy_float\","}, {"sha": "5123e42df61ca8e013943c5d2be7f1f561d57299", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -118,7 +118,7 @@ provide a large enough buffer and `Part` array, and to assemble the final\n string from resulting `Part`s itself.\n \n All algorithms and formatting functions are accompanied by extensive tests\n-in `coretest::num::flt2dec` module. It also shows how to use individual\n+in `coretests::num::flt2dec` module. It also shows how to use individual\n functions.\n \n */"}, {"sha": "f665cfdee77aeaaaadc9513dda03b45fac286578", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -90,7 +90,7 @@ impl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n \n mod wrapping;\n \n-// All these modules are technically private and only exposed for libcoretest:\n+// All these modules are technically private and only exposed for coretests:\n pub mod flt2dec;\n pub mod dec2flt;\n pub mod bignum;"}, {"sha": "1a48f27762580e38047b87ad5468adb21b58114f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -894,9 +894,15 @@ impl<A> ExactSizeIterator for Item<A> {}\n impl<A> FusedIterator for Item<A> {}\n unsafe impl<A> TrustedLen for Item<A> {}\n \n-/// An iterator over a reference of the contained item in an [`Option`].\n+/// An iterator over a reference to the [`Some`] variant of an [`Option`].\n+///\n+/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n+///\n+/// This `struct` is created by the [`Option::iter`] function.\n ///\n /// [`Option`]: enum.Option.html\n+/// [`Some`]: enum.Option.html#variant.Some\n+/// [`Option::iter`]: enum.Option.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n@@ -933,9 +939,15 @@ impl<'a, A> Clone for Iter<'a, A> {\n     }\n }\n \n-/// An iterator over a mutable reference of the contained item in an [`Option`].\n+/// An iterator over a mutable reference to the [`Some`] variant of an [`Option`].\n+///\n+/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n+///\n+/// This `struct` is created by the [`Option::iter_mut`] function.\n ///\n /// [`Option`]: enum.Option.html\n+/// [`Some`]: enum.Option.html#variant.Some\n+/// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n@@ -964,9 +976,15 @@ impl<'a, A> FusedIterator for IterMut<'a, A> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n \n-/// An iterator over the item contained inside an [`Option`].\n+/// An iterator over the value in [`Some`] variant of an [`Option`].\n+///\n+/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n+///\n+/// This `struct` is created by the [`Option::into_iter`] function.\n ///\n /// [`Option`]: enum.Option.html\n+/// [`Some`]: enum.Option.html#variant.Some\n+/// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }"}, {"sha": "04480fc5d31da2e53d5479850fbf0ce9a560fcdb", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -500,6 +500,44 @@ impl<T: ?Sized> *const T {\n             intrinsics::arith_offset(self, count)\n         }\n     }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers ia not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// This function returns `None` if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(offset_to)]\n+    ///\n+    /// fn main() {\n+    ///     let a = [0; 5];\n+    ///     let ptr1: *const i32 = &a[1];\n+    ///     let ptr2: *const i32 = &a[3];\n+    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n+    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n+    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n+    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n+    #[inline]\n+    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n+        let size = mem::size_of::<T>();\n+        if size == 0 {\n+            None\n+        } else {\n+            let diff = (other as isize).wrapping_sub(self as isize);\n+            Some(diff / size as isize)\n+        }\n+    }\n }\n \n #[lang = \"mut_ptr\"]\n@@ -653,6 +691,44 @@ impl<T: ?Sized> *mut T {\n             Some(&mut *self)\n         }\n     }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers ia not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// This function returns `None` if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(offset_to)]\n+    ///\n+    /// fn main() {\n+    ///     let mut a = [0; 5];\n+    ///     let ptr1: *mut i32 = &mut a[1];\n+    ///     let ptr2: *mut i32 = &mut a[3];\n+    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n+    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n+    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n+    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n+    #[inline]\n+    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n+        let size = mem::size_of::<T>();\n+        if size == 0 {\n+            None\n+        } else {\n+            let diff = (other as isize).wrapping_sub(self as isize);\n+            Some(diff / size as isize)\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "6d598677c9ba4f0cad90dc5bf1458d1d94433f58", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 152, "deletions": 20, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -81,6 +81,10 @@ pub trait SliceExt {\n     fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -159,6 +163,10 @@ pub trait SliceExt {\n     fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -293,15 +301,21 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[inline]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplit { inner: self.split(pred) }\n+    }\n+\n     #[inline]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitN {\n             inner: GenericSplitN {\n                 iter: self.split(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -312,9 +326,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitN {\n             inner: GenericSplitN {\n-                iter: self.split(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit(pred),\n+                count: n\n             }\n         }\n     }\n@@ -475,15 +488,21 @@ impl<T> SliceExt for [T] {\n         SplitMut { v: self, pred: pred, finished: false }\n     }\n \n+    #[inline]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplitMut { inner: self.split_mut(pred) }\n+    }\n+\n     #[inline]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n             inner: GenericSplitN {\n                 iter: self.split_mut(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -494,9 +513,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitNMut {\n             inner: GenericSplitN {\n-                iter: self.split_mut(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit_mut(pred),\n+                count: n\n             }\n         }\n     }\n@@ -1498,9 +1516,10 @@ unsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n // Return the arithmetic difference if `T` is zero size.\n #[inline(always)]\n fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n-    let diff = (end as usize).wrapping_sub(start as usize);\n-    let size = mem::size_of::<T>();\n-    diff / (if size == 0 { 1 } else { size })\n+    match start.offset_to(end) {\n+        Some(x) => x as usize,\n+        None => (end as usize).wrapping_sub(start as usize),\n+    }\n }\n \n // Extension methods for raw pointers, used by the iterators\n@@ -1735,14 +1754,130 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit`] method on [slices].\n+///\n+/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\n+pub struct RSplit<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: Split<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplit\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit_mut`] method on [slices].\n+///\n+/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub struct RSplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: SplitMut<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplitMut\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An private iterator over subslices separated by elements that\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n #[derive(Debug)]\n struct GenericSplitN<I> {\n     iter: I,\n     count: usize,\n-    invert: bool\n }\n \n impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n@@ -1753,10 +1888,7 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n         match self.count {\n             0 => None,\n             1 => { self.count -= 1; self.iter.finish() }\n-            _ => {\n-                self.count -= 1;\n-                if self.invert {self.iter.next_back()} else {self.iter.next()}\n-            }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n \n@@ -1798,7 +1930,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<Split<'a, T, P>>\n+    inner: GenericSplitN<RSplit<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -1841,7 +1973,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMu\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<SplitMut<'a, T, P>>\n+    inner: GenericSplitN<RSplitMut<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]"}, {"sha": "352cc926994e3685ae5ca5554eba5f9fbfd3e3c6", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -152,11 +152,16 @@ impl fmt::Display for ParseBoolError {\n Section: Creating a string\n */\n \n-/// Errors which can occur when attempting to interpret a sequence of `u8`\n+/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n /// as a string.\n ///\n-/// As such, the `from_utf8` family of functions and methods for both `String`s\n-/// and `&str`s make use of this error, for example.\n+/// [`u8`]: ../../std/primitive.u8.html\n+///\n+/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n+/// and [`&str`]s make use of this error, for example.\n+///\n+/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n+/// [`&str`]: ../../std/str/fn.from_utf8.html\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n@@ -210,11 +215,15 @@ impl Utf8Error {\n \n /// Converts a slice of bytes to a string slice.\n ///\n-/// A string slice (`&str`) is made of bytes (`u8`), and a byte slice (`&[u8]`)\n-/// is made of bytes, so this function converts between the two. Not all byte\n-/// slices are valid string slices, however: `&str` requires that it is valid\n-/// UTF-8. `from_utf8()` checks to ensure that the bytes are valid UTF-8, and\n-/// then does the conversion.\n+/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n+/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n+/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n+/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n+/// UTF-8, and then does the conversion.\n+///\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`u8`]: ../../std/primitive.u8.html\n+/// [byteslice]: ../../std/primitive.slice.html\n ///\n /// If you are sure that the byte slice is valid UTF-8, and you don't want to\n /// incur the overhead of the validity check, there is an unsafe version of\n@@ -228,9 +237,12 @@ impl Utf8Error {\n ///\n /// [string]: ../../std/string/struct.String.html#method.from_utf8\n ///\n-/// Because you can stack-allocate a `[u8; N]`, and you can take a `&[u8]` of\n-/// it, this function is one way to have a stack-allocated string. There is\n-/// an example of this in the examples section below.\n+/// Because you can stack-allocate a `[u8; N]`, and you can take a\n+/// [`&[u8]`][byteslice] of it, this function is one way to have a\n+/// stack-allocated string. There is an example of this in the\n+/// examples section below.\n+///\n+/// [byteslice]: ../../std/primitive.slice.html\n ///\n /// # Errors\n ///"}, {"sha": "2e1058bfc3413bd4efa59a5815c3fc1fae711541", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -153,8 +153,9 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// Rust's memory orderings are [the same as\n /// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n-/// For more information see the [nomicon][1].\n-/// [1]: ../../../nomicon/atomics.html\n+/// For more information see the [nomicon].\n+///\n+/// [nomicon]: ../../../nomicon/atomics.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n@@ -321,7 +322,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the bool, returning the old value.\n+    /// Stores a value into the bool, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -732,7 +733,7 @@ impl<T> AtomicPtr<T> {\n         }\n     }\n \n-    /// Stores a value into the pointer, returning the old value.\n+    /// Stores a value into the pointer, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -1047,7 +1048,7 @@ macro_rules! atomic_int {\n                 unsafe { atomic_store(self.v.get(), val, order); }\n             }\n \n-            /// Stores a value into the atomic integer, returning the old value.\n+            /// Stores a value into the atomic integer, returning the previous value.\n             ///\n             /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n@@ -1201,7 +1202,9 @@ macro_rules! atomic_int {\n                 }\n             }\n \n-            /// Add to the current value, returning the previous value.\n+            /// Adds to the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n             ///\n             /// # Examples\n             ///\n@@ -1218,7 +1221,9 @@ macro_rules! atomic_int {\n                 unsafe { atomic_add(self.v.get(), val, order) }\n             }\n \n-            /// Subtract from the current value, returning the previous value.\n+            /// Subtracts from the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n             ///\n             /// # Examples\n             ///\n@@ -1235,7 +1240,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_sub(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise and with the current value, returning the previous value.\n+            /// Bitwise \"and\" with the current value.\n+            ///\n+            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1251,7 +1261,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_and(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise or with the current value, returning the previous value.\n+            /// Bitwise \"or\" with the current value.\n+            ///\n+            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1267,7 +1282,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_or(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise xor with the current value, returning the previous value.\n+            /// Bitwise \"xor\" with the current value.\n+            ///\n+            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1415,7 +1435,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_add).\n+/// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n@@ -1428,7 +1448,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_sub).\n+/// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}, {"sha": "2d3e81aa131ed4ceb5fc7d2696af966b9d9c660b", "filename": "src/libcore/tests/any.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fany.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/any.rs"}, {"sha": "6af031dee5845b9875776ef0933cff27f97dc187", "filename": "src/libcore/tests/array.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/array.rs"}, {"sha": "b6bb5fddf4a4bdc4fed02347bfc312cc53636f0e", "filename": "src/libcore/tests/atomic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fatomic.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/atomic.rs"}, {"sha": "8585f2f08711332a3e5af0fa53145df9e1b657ec", "filename": "src/libcore/tests/cell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/cell.rs"}, {"sha": "e4012ec91e2b3f1fdd8a0132d934e01dac18ee03", "filename": "src/libcore/tests/char.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/char.rs"}, {"sha": "91d68ba33447aa99115bd3491a932a625f8315b7", "filename": "src/libcore/tests/clone.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fclone.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/clone.rs"}, {"sha": "e3c65ad8b33c019378ad6e53cbcbdb3295f0ec71", "filename": "src/libcore/tests/cmp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/cmp.rs"}, {"sha": "e71e61bda5efdec258bf7a5d81f302d17b66ba38", "filename": "src/libcore/tests/fmt/builders.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/fmt/builders.rs"}, {"sha": "695001312e4d5aeac1a40c15f9b0b9397906a8bd", "filename": "src/libcore/tests/fmt/float.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Ffloat.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/fmt/float.rs"}, {"sha": "5d204c7d523d681a937b5f3d540c889cb7920948", "filename": "src/libcore/tests/fmt/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/fmt/mod.rs"}, {"sha": "4ddedd9100486ea8640a712a390310f89b7305a2", "filename": "src/libcore/tests/fmt/num.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/fmt/num.rs"}, {"sha": "53ac17c052f6af89a27831ba50f2f7d1686bb4ba", "filename": "src/libcore/tests/hash/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/hash/mod.rs"}, {"sha": "4a9657e03404af4f6d02cf79a05c92e8a05c8ebb", "filename": "src/libcore/tests/hash/sip.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/hash/sip.rs"}, {"sha": "2b380abf63c58dddab364dcb64be682279d9df87", "filename": "src/libcore/tests/intrinsics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fintrinsics.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/intrinsics.rs"}, {"sha": "08442f9bcbff522d498b826d3dda8d1faf1b011e", "filename": "src/libcore/tests/iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/iter.rs"}, {"sha": "d92c378160d2e0e4ba3eabcc5fcdc813675b07c4", "filename": "src/libcore/tests/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/lib.rs"}, {"sha": "86e59c736ba4a133b8d3257a2c56661c1fa07e33", "filename": "src/libcore/tests/mem.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/mem.rs"}, {"sha": "7a367ddeec8d4599ec8543a712306059061edd91", "filename": "src/libcore/tests/nonzero.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/nonzero.rs"}, {"sha": "58a9dd1b128ce8c96cd398a9c1f4f4628c49ea16", "filename": "src/libcore/tests/num/bignum.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/bignum.rs"}, {"sha": "5d546c643e7ee5248ee42b42cc481d24a0d0bd3a", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/dec2flt/mod.rs"}, {"sha": "09acf2bc517b086decd12413e4399c84e6cce8a9", "filename": "src/libcore/tests/num/dec2flt/parse.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/dec2flt/parse.rs"}, {"sha": "1a3533317dae68c57aed2528469ed575e738e58d", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/dec2flt/rawfp.rs"}, {"sha": "0bca616ea9abcc99e5fc604ee4d91f2472b2985d", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/flt2dec/estimator.rs"}, {"sha": "0f4d19e7092571495405338fb31ef9f3a1f5fd9b", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/flt2dec/mod.rs"}, {"sha": "4edb0f3df60c44ea3d0b1aa7c76c379cb5d37de5", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/flt2dec/strategy/dragon.rs"}, {"sha": "79e66ee669e146d13e9addfaf635d1eee5670db4", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs"}, {"sha": "7435831ac6dba26fa851d9ae98f962e467a47437", "filename": "src/libcore/tests/num/i16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fi16.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/i16.rs"}, {"sha": "3b3407e1ada520a373f5163bebc829742fbfa944", "filename": "src/libcore/tests/num/i32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fi32.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/i32.rs"}, {"sha": "9e1aec256eed0ad4afe35b811a99385f465c002a", "filename": "src/libcore/tests/num/i64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fi64.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/i64.rs"}, {"sha": "f72244239b2606fee16fecd4bfae67ff637cef47", "filename": "src/libcore/tests/num/i8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fi8.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/i8.rs"}, {"sha": "8d791283ab87ebd22846667445f7414dc53a60b9", "filename": "src/libcore/tests/num/int_macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/int_macros.rs"}, {"sha": "51737c9c3b485e42b74b47e3671ee5eecc53a90d", "filename": "src/libcore/tests/num/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/mod.rs"}, {"sha": "8455207583cc182d162cdbccbaa53b8eb6029280", "filename": "src/libcore/tests/num/u16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fu16.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/u16.rs"}, {"sha": "b44e60f6529791036b5e02483e9d0c0eb9ecf4ee", "filename": "src/libcore/tests/num/u32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fu32.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/u32.rs"}, {"sha": "ffcd1015d58d63f10049f2a234869eed26375095", "filename": "src/libcore/tests/num/u64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fu64.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/u64.rs"}, {"sha": "4ee14e22f2d576fbe0cf31b9857d8e07cfafe6c5", "filename": "src/libcore/tests/num/u8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fu8.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/u8.rs"}, {"sha": "daa1cc3a7f4fb860b90335063f72bcbfefab31d8", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/num/uint_macros.rs"}, {"sha": "1c6c13b0d02e8b6e5417bbfbc900d4ca78f21f67", "filename": "src/libcore/tests/ops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/ops.rs"}, {"sha": "51b0655f680f6186857c7e07cdedaa640326ab16", "filename": "src/libcore/tests/option.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/option.rs"}, {"sha": "7f6f472bfbb78ea5588f7a770a61792f95bc6f1a", "filename": "src/libcore/tests/ptr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/ptr.rs"}, {"sha": "4c5f19dee12935efbbeb6b09f12ecbabf5b6765e", "filename": "src/libcore/tests/result.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/result.rs"}, {"sha": "ec38345030fa5897423ff55d2f4f882dcff4c1ee", "filename": "src/libcore/tests/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/slice.rs"}, {"sha": "08daafccc5404e523ffa85bf953122d2c2de4cf4", "filename": "src/libcore/tests/str.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// All `str` tests live in libcollectiontest::str\n+// All `str` tests live in collectionstests::str", "previous_filename": "src/libcoretest/str.rs"}, {"sha": "4fe5e0a740bf7007c37f08c1da63f4ffc11e5702", "filename": "src/libcore/tests/tuple.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibcore%2Ftests%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftuple.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "previous_filename": "src/libcoretest/tuple.rs"}, {"sha": "dca9ebb3397a62b547b831f931ae172231df6f5b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -394,6 +394,10 @@ impl Definitions {\n         }\n     }\n \n+    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.node_to_hir_id[node_id]\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,"}, {"sha": "73d81212cd77eaf5ffd15c5d4e7d241582521048", "filename": "src/librustc/ich/hcx.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{self, CachingCodemapView, DefPathHashes};\n+use session::config::DebugInfoLevel::NoDebugInfo;\n+use ty;\n+\n+use std::hash as std_hash;\n+\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::symbol::Symbol;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+/// This is the context state available during incr. comp. hashing. It contains\n+/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n+/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n+/// things (e.g. each DefId/DefPath is only hashed once).\n+pub struct StableHashingContext<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_path_hashes: DefPathHashes<'a, 'tcx>,\n+    codemap: CachingCodemapView<'tcx>,\n+    hash_spans: bool,\n+    hash_bodies: bool,\n+    overflow_checks_enabled: bool,\n+    node_id_hashing_mode: NodeIdHashingMode,\n+    // A sorted array of symbol keys for fast lookup.\n+    ignored_attr_names: Vec<Symbol>,\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum NodeIdHashingMode {\n+    Ignore,\n+    HashDefPath,\n+    HashTraitsInScope,\n+}\n+\n+impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+\n+    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n+        let check_overflow_initial = tcx.sess.overflow_checks();\n+\n+        let mut ignored_attr_names: Vec<_> = ich::IGNORED_ATTRIBUTES\n+            .iter()\n+            .map(|&s| Symbol::intern(s))\n+            .collect();\n+\n+        ignored_attr_names.sort();\n+\n+        StableHashingContext {\n+            tcx: tcx,\n+            def_path_hashes: DefPathHashes::new(tcx),\n+            codemap: CachingCodemapView::new(tcx),\n+            hash_spans: hash_spans_initial,\n+            hash_bodies: true,\n+            overflow_checks_enabled: check_overflow_initial,\n+            node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            ignored_attr_names: ignored_attr_names,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self,\n+                                                          hash_bodies: bool,\n+                                                          f: F) {\n+        let prev_hash_bodies = self.hash_bodies;\n+        self.hash_bodies = hash_bodies;\n+        f(self);\n+        self.hash_bodies = prev_hash_bodies;\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_spans<F: FnOnce(&mut Self)>(&mut self,\n+                                                     hash_spans: bool,\n+                                                     f: F) {\n+        let prev_hash_spans = self.hash_spans;\n+        self.hash_spans = hash_spans;\n+        f(self);\n+        self.hash_spans = prev_hash_spans;\n+    }\n+\n+    #[inline]\n+    pub fn with_node_id_hashing_mode<F: FnOnce(&mut Self)>(&mut self,\n+                                                           mode: NodeIdHashingMode,\n+                                                           f: F) {\n+        let prev = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = mode;\n+        f(self);\n+        self.node_id_hashing_mode = prev;\n+    }\n+\n+    #[inline]\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    #[inline]\n+    pub fn def_path_hash(&mut self, def_id: DefId) -> u64 {\n+        self.def_path_hashes.hash(def_id)\n+    }\n+\n+    #[inline]\n+    pub fn hash_spans(&self) -> bool {\n+        self.hash_spans\n+    }\n+\n+    #[inline]\n+    pub fn hash_bodies(&self) -> bool {\n+        self.hash_bodies\n+    }\n+\n+    #[inline]\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+        &mut self.codemap\n+    }\n+\n+    #[inline]\n+    pub fn is_ignored_attr(&self, name: Symbol) -> bool {\n+        self.ignored_attr_names.binary_search(&name).is_ok()\n+    }\n+\n+    pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self,\n+                                                    item_attrs: &[ast::Attribute],\n+                                                    f: F) {\n+        let prev_overflow_checks = self.overflow_checks_enabled;\n+        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n+            self.overflow_checks_enabled = true;\n+        }\n+        let prev_hash_node_ids = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+\n+        f(self);\n+\n+        self.node_id_hashing_mode = prev_hash_node_ids;\n+        self.overflow_checks_enabled = prev_overflow_checks;\n+    }\n+\n+    #[inline]\n+    pub fn binop_can_panic_at_runtime(&self, binop: hir::BinOp_) -> bool\n+    {\n+        match binop {\n+            hir::BiAdd |\n+            hir::BiSub |\n+            hir::BiMul => self.overflow_checks_enabled,\n+\n+            hir::BiDiv |\n+            hir::BiRem => true,\n+\n+            hir::BiAnd |\n+            hir::BiOr |\n+            hir::BiBitXor |\n+            hir::BiBitAnd |\n+            hir::BiBitOr |\n+            hir::BiShl |\n+            hir::BiShr |\n+            hir::BiEq |\n+            hir::BiLt |\n+            hir::BiLe |\n+            hir::BiNe |\n+            hir::BiGe |\n+            hir::BiGt => false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unop_can_panic_at_runtime(&self, unop: hir::UnOp) -> bool\n+    {\n+        match unop {\n+            hir::UnDeref |\n+            hir::UnNot => false,\n+            hir::UnNeg => self.overflow_checks_enabled,\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match hcx.node_id_hashing_mode {\n+            NodeIdHashingMode::Ignore => {\n+                // Most NodeIds in the HIR can be ignored, but if there is a\n+                // corresponding entry in the `trait_map` we need to hash that.\n+                // Make sure we don't ignore too much by checking that there is\n+                // no entry in a debug_assert!().\n+                debug_assert!(hcx.tcx.trait_map.get(self).is_none());\n+            }\n+            NodeIdHashingMode::HashDefPath => {\n+                hcx.tcx.hir.definitions().node_to_hir_id(*self).hash_stable(hcx, hasher);\n+            }\n+            NodeIdHashingMode::HashTraitsInScope => {\n+                if let Some(traits) = hcx.tcx.trait_map.get(self) {\n+                    // The ordering of the candidates is not fixed. So we hash\n+                    // the def-ids and then sort them and hash the collection.\n+                    let mut candidates: AccumulateVec<[_; 8]> =\n+                        traits.iter()\n+                              .map(|&hir::TraitCandidate { def_id, import_id: _ }| {\n+                                  hcx.def_path_hash(def_id)\n+                              })\n+                              .collect();\n+                    if traits.len() > 1 {\n+                        candidates.sort();\n+                    }\n+                    candidates.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+\n+    // Hash a span in a stable way. We can't directly hash the span's BytePos\n+    // fields (that would be similar to hashing pointers, since those are just\n+    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n+    // triple, which stays the same even if the containing FileMap has moved\n+    // within the CodeMap.\n+    // Also note that we are hashing byte offsets for the column, not unicode\n+    // codepoint offsets. For the purpose of the hash that's sufficient.\n+    // Also, hashing filenames is expensive so we avoid doing it twice when the\n+    // span starts and ends in the same file, which is almost always the case.\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use syntax_pos::Pos;\n+\n+        if !hcx.hash_spans {\n+            return\n+        }\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span_hi = if self.hi > self.lo {\n+            // We might end up in the middle of a multibyte character here,\n+            // but that's OK, since we are not trying to decode anything at\n+            // this position.\n+            self.hi - ::syntax_pos::BytePos(1)\n+        } else {\n+            self.hi\n+        };\n+\n+        {\n+            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo);\n+            let loc1 = loc1.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            let loc2 = hcx.codemap().byte_pos_to_line_and_col(span_hi);\n+            let loc2 = loc2.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            if loc1.0 == loc2.0 {\n+                std_hash::Hash::hash(&0u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                // Do not hash the file name twice\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            } else {\n+                std_hash::Hash::hash(&1u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                std_hash::Hash::hash(loc2.0, hasher);\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            }\n+        }\n+\n+        if self.ctxt == SyntaxContext::empty() {\n+            0u8.hash_stable(hcx, hasher);\n+        } else {\n+            1u8.hash_stable(hcx, hasher);\n+            self.source_callsite().hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}, {"sha": "6d11f2a87a413485ceb97bbaf6cdb2ebc4b8caf4", "filename": "src/librustc/ich/impls_const_math.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from `rustc_const_math` in no particular order.\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n+    F32(val),\n+    F64(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n+    I8(val),\n+    I16(val),\n+    I32(val),\n+    I64(val),\n+    I128(val),\n+    Isize(val),\n+    U8(val),\n+    U16(val),\n+    U32(val),\n+    U64(val),\n+    U128(val),\n+    Usize(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n+    Is16(i16),\n+    Is32(i32),\n+    Is64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n+    Us16(i16),\n+    Us32(i32),\n+    Us64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n+    NotInRange,\n+    CmpBetweenUnequalTypes,\n+    UnequalTypes(op),\n+    Overflow(op),\n+    ShiftNegative,\n+    DivisionByZero,\n+    RemainderByZero,\n+    UnsignedNegation,\n+    ULitOutOfRange(int_ty),\n+    LitOutOfRange(int_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::Op {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    Shr,\n+    Shl,\n+    Neg,\n+    BitAnd,\n+    BitOr,\n+    BitXor\n+});"}, {"sha": "9cf8a0693d3636383133b2cbf0198e7bdb6141e0", "filename": "src/librustc/ich/impls_hir.rs", "status": "added", "additions": 1106, "deletions": 0, "changes": 1106, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,1106 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various HIR data\n+//! types in no particular order.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{StableHashingContext, NodeIdHashingMode};\n+use std::mem;\n+\n+use syntax::ast;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::HirId {\n+            owner,\n+            local_id,\n+        } = *self;\n+\n+        hcx.def_path_hash(DefId::local(owner)).hash_stable(hcx, hasher);\n+        local_id.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n+\n+// The following implementations of HashStable for ItemId, TraitItemId, and\n+// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n+// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// are used when another item in the HIR is *referenced* and we certainly\n+// want to pick up on a reference changing its target, so we hash the NodeIds\n+// in \"DefPath Mode\".\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ItemId {\n+            id\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::Lifetime {\n+    id,\n+    span,\n+    name\n+});\n+\n+impl_stable_hash_for!(struct hir::LifetimeDef {\n+    lifetime,\n+    bounds,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Path {\n+    span,\n+    def,\n+    segments\n+});\n+\n+impl_stable_hash_for!(struct hir::PathSegment {\n+    name,\n+    parameters\n+});\n+\n+impl_stable_hash_for!(enum hir::PathParameters {\n+    AngleBracketedParameters(data),\n+    ParenthesizedParameters(data)\n+});\n+\n+impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+    lifetimes,\n+    types,\n+    infer_types,\n+    bindings\n+});\n+\n+impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n+    span,\n+    inputs,\n+    output\n+});\n+\n+impl_stable_hash_for!(enum hir::TyParamBound {\n+    TraitTyParamBound(poly_trait_ref, trait_bound_modifier),\n+    RegionTyParamBound(lifetime)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitBoundModifier {\n+    None,\n+    Maybe\n+});\n+\n+impl_stable_hash_for!(struct hir::TyParam {\n+    name,\n+    id,\n+    bounds,\n+    default,\n+    span,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Generics {\n+    lifetimes,\n+    ty_params,\n+    where_clause,\n+    span\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereClause {\n+    id,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum hir::WherePredicate {\n+    BoundPredicate(pred),\n+    RegionPredicate(pred),\n+    EqPredicate(pred)\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n+    span,\n+    bound_lifetimes,\n+    bounded_ty,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n+    span,\n+    lifetime,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereEqPredicate {\n+    id,\n+    span,\n+    lhs_ty,\n+    rhs_ty\n+});\n+\n+impl_stable_hash_for!(struct hir::MutTy {\n+    ty,\n+    mutbl\n+});\n+\n+impl_stable_hash_for!(struct hir::MethodSig {\n+    unsafety,\n+    constness,\n+    abi,\n+    decl,\n+    generics\n+});\n+\n+impl_stable_hash_for!(struct hir::TypeBinding {\n+    id,\n+    name,\n+    ty,\n+    span\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::TySlice(..)       |\n+            hir::TyArray(..)       |\n+            hir::TyPtr(..)         |\n+            hir::TyRptr(..)        |\n+            hir::TyBareFn(..)      |\n+            hir::TyNever           |\n+            hir::TyTup(..)         |\n+            hir::TyTraitObject(..) |\n+            hir::TyImplTrait(..)   |\n+            hir::TyTypeof(..)      |\n+            hir::TyErr             |\n+            hir::TyInfer           => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::TyPath(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Ty {\n+                id,\n+                ref node,\n+                ref span,\n+            } = *self;\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::PrimTy {\n+    TyInt(int_ty),\n+    TyUint(uint_ty),\n+    TyFloat(float_ty),\n+    TyStr,\n+    TyBool,\n+    TyChar\n+});\n+\n+impl_stable_hash_for!(struct hir::BareFnTy {\n+    unsafety,\n+    abi,\n+    lifetimes,\n+    decl\n+});\n+\n+impl_stable_hash_for!(enum hir::Ty_ {\n+    TySlice(t),\n+    TyArray(t, body_id),\n+    TyPtr(t),\n+    TyRptr(lifetime, t),\n+    TyBareFn(t),\n+    TyNever,\n+    TyTup(ts),\n+    TyPath(qpath),\n+    TyTraitObject(trait_refs, lifetime),\n+    TyImplTrait(bounds),\n+    TyTypeof(body_id),\n+    TyErr,\n+    TyInfer\n+});\n+\n+impl_stable_hash_for!(struct hir::FnDecl {\n+    inputs,\n+    output,\n+    variadic,\n+    has_implicit_self\n+});\n+\n+impl_stable_hash_for!(enum hir::FunctionRetTy {\n+    DefaultReturn(span),\n+    Return(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitRef {\n+            ref path,\n+            ref_id,\n+        } = *self;\n+\n+        path.hash_stable(hcx, hasher);\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+            ref_id.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+\n+impl_stable_hash_for!(struct hir::PolyTraitRef {\n+    bound_lifetimes,\n+    trait_ref,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum hir::QPath {\n+    Resolved(t, path),\n+    TypeRelative(t, path_segment)\n+});\n+\n+impl_stable_hash_for!(struct hir::MacroDef {\n+    name,\n+    attrs,\n+    id,\n+    span,\n+    body\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Block {\n+            ref stmts,\n+            ref expr,\n+            id,\n+            rules,\n+            span,\n+            targeted_by_break,\n+        } = *self;\n+\n+        let non_item_stmts = || stmts.iter().filter(|stmt| {\n+            match stmt.node {\n+                hir::StmtDecl(ref decl, _) => {\n+                    match decl.node {\n+                        // If this is a declaration of a nested item, we don't\n+                        // want to leave any trace of it in the hash value, not\n+                        // even that it exists. Otherwise changing the position\n+                        // of nested items would invalidate the containing item\n+                        // even though that does not constitute a semantic\n+                        // change.\n+                        hir::DeclItem(_) => false,\n+                        hir::DeclLocal(_) => true\n+                    }\n+                }\n+                hir::StmtExpr(..) |\n+                hir::StmtSemi(..) => true\n+            }\n+        });\n+\n+        let count = non_item_stmts().count();\n+\n+        count.hash_stable(hcx, hasher);\n+\n+        for stmt in non_item_stmts() {\n+            stmt.hash_stable(hcx, hasher);\n+        }\n+\n+        expr.hash_stable(hcx, hasher);\n+        id.hash_stable(hcx, hasher);\n+        rules.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+        targeted_by_break.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::PatKind::Wild        |\n+            hir::PatKind::Binding(..) |\n+            hir::PatKind::Tuple(..)   |\n+            hir::PatKind::Box(..)     |\n+            hir::PatKind::Ref(..)     |\n+            hir::PatKind::Lit(..)     |\n+            hir::PatKind::Range(..)   |\n+            hir::PatKind::Slice(..)   => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::PatKind::Path(..)        |\n+            hir::PatKind::Struct(..)      |\n+            hir::PatKind::TupleStruct(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Pat {\n+            id,\n+            ref node,\n+            ref span\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        });\n+        node.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for_spanned!(hir::FieldPat);\n+impl_stable_hash_for!(struct hir::FieldPat {\n+    name,\n+    pat,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for!(enum hir::BindingMode {\n+    BindByRef(mutability),\n+    BindByValue(mutability)\n+});\n+\n+impl_stable_hash_for!(enum hir::RangeEnd {\n+    Included,\n+    Excluded\n+});\n+\n+impl_stable_hash_for!(enum hir::PatKind {\n+    Wild,\n+    Binding(binding_mode, var, name, sub),\n+    Struct(path, field_pats, dotdot),\n+    TupleStruct(path, field_pats, dotdot),\n+    Path(path),\n+    Tuple(field_pats, dotdot),\n+    Box(sub),\n+    Ref(sub, mutability),\n+    Lit(expr),\n+    Range(start, end, end_kind),\n+    Slice(one, two, three)\n+});\n+\n+impl_stable_hash_for!(enum hir::BinOp_ {\n+    BiAdd,\n+    BiSub,\n+    BiMul,\n+    BiDiv,\n+    BiRem,\n+    BiAnd,\n+    BiOr,\n+    BiBitXor,\n+    BiBitAnd,\n+    BiBitOr,\n+    BiShl,\n+    BiShr,\n+    BiEq,\n+    BiLt,\n+    BiLe,\n+    BiNe,\n+    BiGe,\n+    BiGt\n+});\n+\n+impl_stable_hash_for_spanned!(hir::BinOp_);\n+\n+impl_stable_hash_for!(enum hir::UnOp {\n+    UnDeref,\n+    UnNot,\n+    UnNeg\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Stmt_);\n+\n+impl_stable_hash_for!(struct hir::Local {\n+    pat,\n+    ty,\n+    init,\n+    id,\n+    span,\n+    attrs\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Decl_);\n+impl_stable_hash_for!(enum hir::Decl_ {\n+    DeclLocal(local),\n+    DeclItem(item_id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arm {\n+    attrs,\n+    pats,\n+    guard,\n+    body\n+});\n+\n+impl_stable_hash_for!(struct hir::Field {\n+    name,\n+    expr,\n+    span,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Name);\n+\n+\n+impl_stable_hash_for!(enum hir::BlockCheckMode {\n+    DefaultBlock,\n+    UnsafeBlock(src),\n+    PushUnsafeBlock(src),\n+    PopUnsafeBlock(src)\n+});\n+\n+impl_stable_hash_for!(enum hir::UnsafeSource {\n+    CompilerGenerated,\n+    UserProvided\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Expr {\n+                id,\n+                ref span,\n+                ref node,\n+                ref attrs\n+            } = *self;\n+\n+            let (spans_always_on, node_id_hashing_mode) = match *node {\n+                hir::ExprBox(..)        |\n+                hir::ExprArray(..)      |\n+                hir::ExprCall(..)       |\n+                hir::ExprLit(..)        |\n+                hir::ExprCast(..)       |\n+                hir::ExprType(..)       |\n+                hir::ExprIf(..)         |\n+                hir::ExprWhile(..)      |\n+                hir::ExprLoop(..)       |\n+                hir::ExprMatch(..)      |\n+                hir::ExprClosure(..)    |\n+                hir::ExprBlock(..)      |\n+                hir::ExprAssign(..)     |\n+                hir::ExprTupField(..)   |\n+                hir::ExprAddrOf(..)     |\n+                hir::ExprBreak(..)      |\n+                hir::ExprAgain(..)      |\n+                hir::ExprRet(..)        |\n+                hir::ExprInlineAsm(..)  |\n+                hir::ExprRepeat(..)     |\n+                hir::ExprTup(..)        => {\n+                    // For these we only hash the span when debuginfo is on.\n+                    (false, NodeIdHashingMode::Ignore)\n+                }\n+                // For the following, spans might be significant because of\n+                // panic messages indicating the source location.\n+                hir::ExprBinary(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprUnary(op, _) => {\n+                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprAssignOp(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprIndex(..) => {\n+                    (true, NodeIdHashingMode::Ignore)\n+                }\n+                // For these we don't care about the span, but want to hash the\n+                // trait in scope\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..)       |\n+                hir::ExprStruct(..)     |\n+                hir::ExprField(..)      => {\n+                    (false, NodeIdHashingMode::HashTraitsInScope)\n+                }\n+            };\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+\n+            if spans_always_on {\n+                hcx.while_hashing_spans(true, |hcx| {\n+                    span.hash_stable(hcx, hasher);\n+                    node.hash_stable(hcx, hasher);\n+                    attrs.hash_stable(hcx, hasher);\n+                });\n+            } else {\n+                span.hash_stable(hcx, hasher);\n+                node.hash_stable(hcx, hasher);\n+                attrs.hash_stable(hcx, hasher);\n+            }\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Expr_ {\n+    ExprBox(sub),\n+    ExprArray(subs),\n+    ExprCall(callee, args),\n+    ExprMethodCall(name, ts, args),\n+    ExprTup(fields),\n+    ExprBinary(op, lhs, rhs),\n+    ExprUnary(op, operand),\n+    ExprLit(value),\n+    ExprCast(expr, t),\n+    ExprType(expr, t),\n+    ExprIf(cond, then, els),\n+    ExprWhile(cond, body, label),\n+    ExprLoop(body, label, loop_src),\n+    ExprMatch(matchee, arms, match_src),\n+    ExprClosure(capture_clause, decl, body_id, span),\n+    ExprBlock(blk),\n+    ExprAssign(lhs, rhs),\n+    ExprAssignOp(op, lhs, rhs),\n+    ExprField(owner, field_name),\n+    ExprTupField(owner, idx),\n+    ExprIndex(lhs, rhs),\n+    ExprPath(path),\n+    ExprAddrOf(mutability, sub),\n+    ExprBreak(destination, sub),\n+    ExprAgain(destination),\n+    ExprRet(val),\n+    ExprInlineAsm(asm, inputs, outputs),\n+    ExprStruct(path, fields, base),\n+    ExprRepeat(val, times)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopSource {\n+    Loop,\n+    WhileLet,\n+    ForLoop\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use hir::MatchSource;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            MatchSource::Normal |\n+            MatchSource::WhileLetDesugar |\n+            MatchSource::ForLoopDesugar |\n+            MatchSource::TryDesugar => {\n+                // No fields to hash.\n+            }\n+            MatchSource::IfLetDesugar { contains_else_clause } => {\n+                contains_else_clause.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::CaptureClause {\n+    CaptureByValue,\n+    CaptureByRef\n+});\n+\n+impl_stable_hash_for_spanned!(usize);\n+\n+impl_stable_hash_for!(struct hir::Destination {\n+    ident,\n+    target_id\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Ident);\n+\n+impl_stable_hash_for!(enum hir::LoopIdResult {\n+    Ok(node_id),\n+    Err(loop_id_error)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel\n+});\n+\n+impl_stable_hash_for!(enum hir::ScopeTarget {\n+    Block(node_id),\n+    Loop(loop_id_result)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ast::Ident {\n+            ref name,\n+            ctxt: _ // Ignore this\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItem {\n+            id,\n+            name,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::TraitMethod {\n+    Required(name),\n+    Provided(body)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitItemKind {\n+    Const(t, body),\n+    Method(sig, method),\n+    Type(bounds, rhs)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItem {\n+            id,\n+            name,\n+            ref vis,\n+            defaultness,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            defaultness.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplItemKind {\n+    Const(t, body),\n+    Method(sig, body),\n+    Type(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Visibility::Public |\n+            hir::Visibility::Crate |\n+            hir::Visibility::Inherited => {\n+                // No fields to hash.\n+            }\n+            hir::Visibility::Restricted { ref path, id } => {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+                    id.hash_stable(hcx, hasher);\n+                });\n+                path.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Defaultness::Final => {\n+                // No fields to hash.\n+            }\n+            hir::Defaultness::Default { has_value } => {\n+                has_value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplPolarity {\n+    Positive,\n+    Negative\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Mod {\n+            inner,\n+            // We are not hashing the IDs of the items contained in the module.\n+            // This is harmless and matches the current behavior but it's not\n+            // actually correct. See issue #40876.\n+            item_ids: _,\n+        } = *self;\n+\n+        inner.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignMod {\n+    abi,\n+    items\n+});\n+\n+impl_stable_hash_for!(struct hir::EnumDef {\n+    variants\n+});\n+\n+impl_stable_hash_for!(struct hir::Variant_ {\n+    name,\n+    attrs,\n+    data,\n+    disr_expr\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Variant_);\n+\n+impl_stable_hash_for!(enum hir::UseKind {\n+    Single,\n+    Glob,\n+    ListStem\n+});\n+\n+impl_stable_hash_for!(struct hir::StructField {\n+    span,\n+    name,\n+    vis,\n+    id,\n+    ty,\n+    attrs\n+});\n+\n+impl_stable_hash_for!(enum hir::VariantData {\n+    Struct(fields, id),\n+    Tuple(fields, id),\n+    Unit(id)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::ItemExternCrate(..) |\n+            hir::ItemStatic(..)      |\n+            hir::ItemConst(..)       |\n+            hir::ItemFn(..)          |\n+            hir::ItemMod(..)         |\n+            hir::ItemForeignMod(..)  |\n+            hir::ItemTy(..)          |\n+            hir::ItemEnum(..)        |\n+            hir::ItemStruct(..)      |\n+            hir::ItemUnion(..)       |\n+            hir::ItemTrait(..)       |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemImpl(..)        => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::ItemUse(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Item {\n+            name,\n+            ref attrs,\n+            id,\n+            ref node,\n+            ref vis,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Item_ {\n+    ItemExternCrate(name),\n+    ItemUse(path, use_kind),\n+    ItemStatic(ty, mutability, body_id),\n+    ItemConst(ty, body_id),\n+    ItemFn(fn_decl, unsafety, constness, abi, generics, body_id),\n+    ItemMod(module),\n+    ItemForeignMod(foreign_mod),\n+    ItemTy(ty, generics),\n+    ItemEnum(enum_def, generics),\n+    ItemStruct(variant_data, generics),\n+    ItemUnion(variant_data, generics),\n+    ItemTrait(unsafety, generics, bounds, item_refs),\n+    ItemDefaultImpl(unsafety, trait_ref),\n+    ItemImpl(unsafety, impl_polarity, generics, trait_ref, ty, impl_item_refs)\n+});\n+\n+impl_stable_hash_for!(struct hir::TraitItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    defaultness\n+});\n+\n+impl_stable_hash_for!(struct hir::ImplItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    vis,\n+    defaultness\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::AssociatedItemKind::Const |\n+            hir::AssociatedItemKind::Type => {\n+                // No fields to hash.\n+            }\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                has_self.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignItem {\n+    name,\n+    attrs,\n+    node,\n+    id,\n+    span,\n+    vis\n+});\n+\n+impl_stable_hash_for!(enum hir::ForeignItem_ {\n+    ForeignItemFn(fn_decl, arg_names, generics),\n+    ForeignItemStatic(ty, is_mutbl)\n+});\n+\n+impl_stable_hash_for!(enum hir::Stmt_ {\n+    StmtDecl(decl, id),\n+    StmtExpr(expr, id),\n+    StmtSemi(expr, id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arg {\n+    pat,\n+    id\n+});\n+\n+impl_stable_hash_for!(struct hir::Body {\n+    arguments,\n+    value\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        if hcx.hash_bodies() {\n+            hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::InlineAsmOutput {\n+    constraint,\n+    is_rw,\n+    is_indirect\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::InlineAsm {\n+            asm,\n+            asm_str_style,\n+            ref outputs,\n+            ref inputs,\n+            ref clobbers,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            ctxt: _, // This is used for error reporting\n+        } = *self;\n+\n+        asm.hash_stable(hcx, hasher);\n+        asm_str_style.hash_stable(hcx, hasher);\n+        outputs.hash_stable(hcx, hasher);\n+        inputs.hash_stable(hcx, hasher);\n+        clobbers.hash_stable(hcx, hasher);\n+        volatile.hash_stable(hcx, hasher);\n+        alignstack.hash_stable(hcx, hasher);\n+        dialect.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::def::CtorKind {\n+    Fn,\n+    Const,\n+    Fictive\n+});\n+\n+impl_stable_hash_for!(enum hir::def::Def {\n+    Mod(def_id),\n+    Struct(def_id),\n+    Union(def_id),\n+    Enum(def_id),\n+    Variant(def_id),\n+    Trait(def_id),\n+    TyAlias(def_id),\n+    AssociatedTy(def_id),\n+    PrimTy(prim_ty),\n+    TyParam(def_id),\n+    SelfTy(trait_def_id, impl_def_id),\n+    Fn(def_id),\n+    Const(def_id),\n+    Static(def_id, is_mutbl),\n+    StructCtor(def_id, ctor_kind),\n+    VariantCtor(def_id, ctor_kind),\n+    Method(def_id),\n+    AssociatedConst(def_id),\n+    Local(def_id),\n+    Upvar(def_id, index, expr_id),\n+    Label(node_id),\n+    Macro(def_id, macro_kind),\n+    Err\n+});\n+\n+impl_stable_hash_for!(enum hir::Mutability {\n+    MutMutable,\n+    MutImmutable\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Unsafety {\n+    Unsafe,\n+    Normal\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Constness {\n+    Const,\n+    NotConst\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        DefId::local(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::def::Export {\n+    name,\n+    def,\n+    span\n+});"}, {"sha": "401f7e1921ab49a3561cedb8ac808a87ef53395a", "filename": "src/librustc/ich/impls_mir.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various MIR data\n+//! types in no particular order.\n+\n+use ich::StableHashingContext;\n+use mir;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::mem;\n+\n+\n+impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n+impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n+impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n+impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n+impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n+impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::Terminator<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::TerminatorKind::Goto { ref target } => {\n+                target.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::SwitchInt { ref discr,\n+                                             switch_ty,\n+                                             ref values,\n+                                             ref targets } => {\n+                discr.hash_stable(hcx, hasher);\n+                switch_ty.hash_stable(hcx, hasher);\n+                values.hash_stable(hcx, hasher);\n+                targets.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable => {}\n+            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+                location.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::DropAndReplace { ref location,\n+                                                  ref value,\n+                                                  target,\n+                                                  unwind, } => {\n+                location.hash_stable(hcx, hasher);\n+                value.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Call { ref func,\n+                                        ref args,\n+                                        ref destination,\n+                                        cleanup } => {\n+                func.hash_stable(hcx, hasher);\n+                args.hash_stable(hcx, hasher);\n+                destination.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Assert { ref cond,\n+                                          expected,\n+                                          ref msg,\n+                                          target,\n+                                          cleanup } => {\n+                cond.hash_stable(hcx, hasher);\n+                expected.hash_stable(hcx, hasher);\n+                msg.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher);\n+            }\n+            mir::AssertMessage::Math(ref const_math_err) => {\n+                const_math_err.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+                rvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::SetDiscriminant { ref lvalue, variant_index } => {\n+                lvalue.hash_stable(hcx, hasher);\n+                variant_index.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::StorageLive(ref lvalue) |\n+            mir::StatementKind::StorageDead(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::Nop => {}\n+            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                asm.hash_stable(hcx, hasher);\n+                outputs.hash_stable(hcx, hasher);\n+                inputs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Lvalue::Local(ref local) => {\n+                local.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Static(ref statik) => {\n+                statik.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Projection(ref lvalue_projection) => {\n+                lvalue_projection.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mir::Projection {\n+            ref base,\n+            ref elem,\n+        } = *self;\n+\n+        base.hash_stable(hcx, hasher);\n+        elem.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ProjectionElem::Deref => {}\n+            mir::ProjectionElem::Field(field, ty) => {\n+                field.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Index(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                offset.hash_stable(hcx, hasher);\n+                min_length.hash_stable(hcx, hasher);\n+                from_end.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Subslice { from, to } => {\n+                from.hash_stable(hcx, hasher);\n+                to.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Downcast(adt_def, variant) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                variant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Operand::Consume(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Operand::Constant(ref constant) => {\n+                constant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Rvalue::Use(ref operand) => {\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Repeat(ref operand, ref val) => {\n+                operand.hash_stable(hcx, hasher);\n+                val.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Ref(region, borrow_kind, ref lvalue) => {\n+                region.hash_stable(hcx, hasher);\n+                borrow_kind.hash_stable(hcx, hasher);\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Len(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n+                cast_kind.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::BinaryOp(op, ref operand1, ref operand2) |\n+            mir::Rvalue::CheckedBinaryOp(op, ref operand1, ref operand2) => {\n+                op.hash_stable(hcx, hasher);\n+                operand1.hash_stable(hcx, hasher);\n+                operand2.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                op.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Discriminant(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Box(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                kind.hash_stable(hcx, hasher);\n+                operands.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::CastKind {\n+    Misc,\n+    ReifyFnPointer,\n+    ClosureFnPointer,\n+    UnsafeFnPointer,\n+    Unsize\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::AggregateKind::Tuple => {}\n+            mir::AggregateKind::Array(t) => {\n+                t.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Adt(adt_def, idx, substs, active_field) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                idx.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                active_field.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Closure(def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::BinOp {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt\n+});\n+\n+impl_stable_hash_for!(enum mir::UnOp {\n+    Not,\n+    Neg\n+});\n+\n+\n+impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Literal::Item { def_id, substs } => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Value { ref value } => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Promoted { index } => {\n+                index.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Location { block, statement_index });"}, {"sha": "26734500001f6d772327d64f712d074ab21d7c02", "filename": "src/librustc/ich/impls_syntax.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from libsyntax in no particular order.\n+\n+use ich::StableHashingContext;\n+\n+use std::hash as std_hash;\n+use std::mem;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let s: &str = &**self;\n+        s.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_str().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n+    Att,\n+    Intel\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ext::base::MacroKind {\n+    Bang,\n+    Attr,\n+    Derive\n+});\n+\n+\n+impl_stable_hash_for!(enum ::syntax::abi::Abi {\n+    Cdecl,\n+    Stdcall,\n+    Fastcall,\n+    Vectorcall,\n+    Aapcs,\n+    Win64,\n+    SysV64,\n+    PtxKernel,\n+    Msp430Interrupt,\n+    X86Interrupt,\n+    Rust,\n+    C,\n+    System,\n+    RustIntrinsic,\n+    RustCall,\n+    PlatformIntrinsic,\n+    Unadjusted\n+});\n+\n+impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n+impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+                reason.hash_stable(hcx, hasher);\n+                issue.hash_stable(hcx, hasher);\n+            }\n+            ::syntax::attr::StabilityLevel::Stable { ref since } => {\n+                since.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason });\n+\n+\n+impl_stable_hash_for!(enum ::syntax::attr::IntType {\n+    SignedInt(int_ty),\n+    UnsignedInt(uint_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n+    Signed(int_ty),\n+    Unsigned(int_ty),\n+    Unsuffixed\n+});\n+\n+impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n+    Str(value, style),\n+    ByteStr(value),\n+    Byte(value),\n+    Char(value),\n+    Int(value, lit_int_type),\n+    Float(value, float_ty),\n+    FloatUnsuffixed(value),\n+    Bool(value)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::IntTy { Is, I8, I16, I32, I64, I128 });\n+impl_stable_hash_for!(enum ::syntax::ast::UintTy { Us, U8, U16, U32, U64, U128 });\n+impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n+impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n+impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n+impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, name });\n+impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n+impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Some attributes are always ignored during hashing.\n+        let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n+            .iter()\n+            .filter(|attr| {\n+                !attr.is_sugared_doc &&\n+                attr.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true)\n+            })\n+            .collect();\n+\n+        filtered.len().hash_stable(hcx, hasher);\n+        for attr in filtered {\n+            attr.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Make sure that these have been filtered out.\n+        debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n+        debug_assert!(!self.is_sugared_doc);\n+\n+        let ast::Attribute {\n+            id: _,\n+            style,\n+            ref path,\n+            ref tokens,\n+            is_sugared_doc: _,\n+            span,\n+        } = *self;\n+\n+        style.hash_stable(hcx, hasher);\n+        path.segments.len().hash_stable(hcx, hasher);\n+        for segment in &path.segments {\n+            segment.identifier.name.hash_stable(hcx, hasher);\n+        }\n+        for tt in tokens.trees() {\n+            tt.hash_stable(hcx, hasher);\n+        }\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            tokenstream::TokenTree::Token(span, ref token) => {\n+                span.hash_stable(hcx, hasher);\n+                hash_token(token, hcx, hasher, span);\n+            }\n+            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+                span.hash_stable(hcx, hasher);\n+                std_hash::Hash::hash(&delimited.delim, hasher);\n+                for sub_tt in delimited.stream().trees() {\n+                    sub_tt.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                               hasher: &mut StableHasher<W>,\n+                                               error_reporting_span: Span) {\n+    mem::discriminant(token).hash_stable(hcx, hasher);\n+    match *token {\n+        token::Token::Eq |\n+        token::Token::Lt |\n+        token::Token::Le |\n+        token::Token::EqEq |\n+        token::Token::Ne |\n+        token::Token::Ge |\n+        token::Token::Gt |\n+        token::Token::AndAnd |\n+        token::Token::OrOr |\n+        token::Token::Not |\n+        token::Token::Tilde |\n+        token::Token::At |\n+        token::Token::Dot |\n+        token::Token::DotDot |\n+        token::Token::DotDotDot |\n+        token::Token::Comma |\n+        token::Token::Semi |\n+        token::Token::Colon |\n+        token::Token::ModSep |\n+        token::Token::RArrow |\n+        token::Token::LArrow |\n+        token::Token::FatArrow |\n+        token::Token::Pound |\n+        token::Token::Dollar |\n+        token::Token::Question |\n+        token::Token::Underscore |\n+        token::Token::Whitespace |\n+        token::Token::Comment |\n+        token::Token::Eof => {}\n+\n+        token::Token::BinOp(bin_op_token) |\n+        token::Token::BinOpEq(bin_op_token) => {\n+            std_hash::Hash::hash(&bin_op_token, hasher);\n+        }\n+\n+        token::Token::OpenDelim(delim_token) |\n+        token::Token::CloseDelim(delim_token) => {\n+            std_hash::Hash::hash(&delim_token, hasher);\n+        }\n+        token::Token::Literal(ref lit, ref opt_name) => {\n+            mem::discriminant(lit).hash_stable(hcx, hasher);\n+            match *lit {\n+                token::Lit::Byte(val) |\n+                token::Lit::Char(val) |\n+                token::Lit::Integer(val) |\n+                token::Lit::Float(val) |\n+                token::Lit::Str_(val) |\n+                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n+                token::Lit::StrRaw(val, n) |\n+                token::Lit::ByteStrRaw(val, n) => {\n+                    val.hash_stable(hcx, hasher);\n+                    n.hash_stable(hcx, hasher);\n+                }\n+            };\n+            opt_name.hash_stable(hcx, hasher);\n+        }\n+\n+        token::Token::Ident(ident) |\n+        token::Token::Lifetime(ident) |\n+        token::Token::SubstNt(ident) => ident.name.hash_stable(hcx, hasher),\n+\n+        token::Token::Interpolated(ref non_terminal) => {\n+            // FIXME(mw): This could be implemented properly. It's just a\n+            //            lot of work, since we would need to hash the AST\n+            //            in a stable way, in addition to the HIR.\n+            //            Since this is hardly used anywhere, just emit a\n+            //            warning for now.\n+            if hcx.tcx().sess.opts.debugging_opts.incremental.is_some() {\n+                let msg = format!(\"Quasi-quoting might make incremental \\\n+                                   compilation very inefficient: {:?}\",\n+                                  non_terminal);\n+                hcx.tcx().sess.span_warn(error_reporting_span, &msg[..]);\n+            }\n+\n+            std_hash::Hash::hash(non_terminal, hasher);\n+        }\n+\n+        token::Token::DocComment(val) |\n+        token::Token::Shebang(val) => val.hash_stable(hcx, hasher),\n+    }\n+}"}, {"sha": "7b6f3af2a11ec88582d572128185e17c029b4a43", "filename": "src/librustc/ich/impls_ty.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from rustc::ty in no particular order.\n+\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::hash as std_hash;\n+use std::mem;\n+use ty;\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Ty<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let type_hash = hcx.tcx().type_id_hash(*self);\n+        type_hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&**self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_type().hash_stable(hcx, hasher);\n+        self.as_region().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::ReErased |\n+            ty::ReStatic |\n+            ty::ReEmpty => {\n+                // No variant fields to hash for these ...\n+            }\n+            ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                db.depth.hash_stable(hcx, hasher);\n+                i.hash_stable(hcx, hasher);\n+            }\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+                index.hash_stable(hcx, hasher);\n+                name.hash_stable(hcx, hasher);\n+            }\n+            ty::ReLateBound(..) |\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => {\n+                bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::AutoBorrow::Ref(ref region, mutability) => {\n+                region.hash_stable(hcx, hasher);\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::AutoBorrow::RawPtr(mutability) => {\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer => {}\n+            ty::adjustment::Adjust::DerefRef { autoderefs, ref autoref, unsize } => {\n+                autoderefs.hash_stable(hcx, hasher);\n+                autoref.hash_stable(hcx, hasher);\n+                unsize.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n+impl_stable_hash_for!(struct ty::MethodCall { expr_id, autoderef });\n+impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n+impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n+impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n+\n+impl_stable_hash_for!(enum ty::BorrowKind {\n+    ImmBorrow,\n+    UniqueImmBorrow,\n+    MutBorrow\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UpvarCapture::ByValue => {}\n+            ty::UpvarCapture::ByRef(ref up_var_borrow) => {\n+                up_var_borrow.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n+    inputs_and_output,\n+    variadic,\n+    unsafety,\n+    abi\n+});\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ty::ClosureKind { Fn, FnMut, FnOnce });\n+\n+impl_stable_hash_for!(enum ty::Visibility {\n+    Public,\n+    Restricted(def_id),\n+    Invisible\n+});\n+\n+impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n+impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n+impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n+\n+impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        a.hash_stable(hcx, hasher);\n+        b.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n+impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_name });\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::Predicate::Trait(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Equate(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::RegionOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::TypeOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Projection(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::WellFormed(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ObjectSafe(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ClosureKind(def_id, closure_kind) => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_kind.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        std_hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::VariantDef {\n+    did,\n+    name,\n+    discr,\n+    fields,\n+    ctor_kind\n+});\n+\n+impl_stable_hash_for!(enum ty::VariantDiscr {\n+    Explicit(def_id),\n+    Relative(distance)\n+});\n+\n+impl_stable_hash_for!(struct ty::FieldDef {\n+    did,\n+    name,\n+    vis\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::const_val::ConstVal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::const_val::ConstVal;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            ConstVal::Float(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Integral(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Str(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::ByteStr(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Bool(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Function(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Struct(ref _name_value_map) => {\n+                // BTreeMap<ast::Name, ConstVal<'tcx>>),\n+                panic!(\"Ordering still unstable\")\n+            }\n+            ConstVal::Tuple(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Array(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Repeat(ref value, times) => {\n+                value.hash_stable(hcx, hasher);\n+                times.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Char(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n+\n+\n+impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n+    parent,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum ty::Variance {\n+    Covariant,\n+    Invariant,\n+    Contravariant,\n+    Bivariant\n+});\n+\n+impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n+    Struct(index)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::Generics {\n+            parent,\n+            parent_regions,\n+            parent_types,\n+            ref regions,\n+            ref types,\n+\n+            // Reverse map to each `TypeParameterDef`'s `index` field, from\n+            // `def_id.index` (`def_id.krate` is the same as the item's).\n+            type_param_to_index: _, // Don't hash this\n+            has_self,\n+        } = *self;\n+\n+        parent.hash_stable(hcx, hasher);\n+        parent_regions.hash_stable(hcx, hasher);\n+        parent_types.hash_stable(hcx, hasher);\n+        regions.hash_stable(hcx, hasher);\n+        types.hash_stable(hcx, hasher);\n+        has_self.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::RegionParameterDef {\n+            name,\n+            def_id,\n+            index,\n+            issue_32330: _,\n+            pure_wrt_drop\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        def_id.hash_stable(hcx, hasher);\n+        index.hash_stable(hcx, hasher);\n+        pure_wrt_drop.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::TypeParameterDef {\n+    name,\n+    def_id,\n+    index,\n+    has_default,\n+    object_lifetime_default,\n+    pure_wrt_drop\n+});\n+\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::resolve_lifetime::Set1<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::resolve_lifetime::Set1;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Set1::Empty |\n+            Set1::Many => {\n+                // Nothing to do.\n+            }\n+            Set1::One(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n+    Static,\n+    EarlyBound(index, decl),\n+    LateBound(db_index, decl),\n+    LateBoundAnon(db_index, anon_index),\n+    Free(call_site_scope_data, decl)\n+});\n+\n+impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n+    fn_id,\n+    body_id\n+});\n+\n+impl_stable_hash_for!(struct ty::DebruijnIndex {\n+    depth\n+});"}, {"sha": "f0601a0efabf89e87390c67498c3e6c436d6a48d", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,20 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! ICH - Incremental Compilation Hash\n+\n pub use self::fingerprint::Fingerprint;\n pub use self::def_path_hash::DefPathHashes;\n pub use self::caching_codemap_view::CachingCodemapView;\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n \n mod fingerprint;\n mod def_path_hash;\n mod caching_codemap_view;\n+mod hcx;\n+\n+mod impls_const_math;\n+mod impls_hir;\n+mod impls_mir;\n+mod impls_ty;\n+mod impls_syntax;\n \n pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n pub const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n pub const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+pub const ATTR_PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+\n+pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n+    ATTR_IF_THIS_CHANGED,\n+    ATTR_THEN_THIS_WOULD_NEED,\n+    ATTR_DIRTY,\n+    ATTR_CLEAN,\n+    ATTR_DIRTY_METADATA,\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n+];\n \n pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -30,5 +54,7 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n     ATTR_DIRTY_METADATA,\n-    ATTR_CLEAN_METADATA\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n ];"}, {"sha": "3b002fd4dfc1a210e8445eb9e2cd8469beac0c68", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -41,6 +41,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n+#![feature(discriminant_value)]\n \n extern crate arena;\n extern crate core;"}, {"sha": "c18e585f79553bd1791ca22614efb51701389829", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {\n         $($variant:ident = $e:expr,)*\n@@ -59,3 +61,80 @@ macro_rules! span_bug {\n         $crate::session::span_bug_fmt(file!(), line!(), $span, format_args!($($message)*))\n     })\n }\n+\n+#[macro_export]\n+macro_rules! __impl_stable_hash_field {\n+    (DECL IGNORED) => (_);\n+    (DECL $name:ident) => (ref $name);\n+    (USE IGNORED $ctx:expr, $hasher:expr) => ({});\n+    (USE $name:ident, $ctx:expr, $hasher:expr) => ($name.hash_stable($ctx, $hasher));\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for {\n+    (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $enum_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                use $enum_name::*;\n+                ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n+\n+                match *self {\n+                    $(\n+                        $variant $( ( $( __impl_stable_hash_field!(DECL $arg) ),* ) )* => {\n+                            $($( __impl_stable_hash_field!(USE $arg, __ctx, __hasher) );*)*\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+    };\n+    (struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+    (tuple_struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name (\n+                    $(ref $field),*\n+                ) = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for_spanned {\n+    ($T:path) => (\n+\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::codemap::Spanned<$T>\n+        {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                  hasher: &mut StableHasher<W>) {\n+                self.node.hash_stable(hcx, hasher);\n+                self.span.hash_stable(hcx, hasher);\n+            }\n+        }\n+    );\n+}\n+"}, {"sha": "7d3c17a048917adf85f0477eae8ce3e0bf29d801", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -202,11 +202,14 @@ pub enum ImmutabilityBlame<'tcx> {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_name: FieldName) -> (&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n+    fn resolve_field(&self, field_name: FieldName) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n-        let adt_def = self.ty.ty_adt_def().unwrap_or_else(|| {\n-            bug!(\"interior cmt {:?} is not an ADT\", self)\n-        });\n+        let adt_def = match self.ty.sty {\n+            ty::TyAdt(def, _) => def,\n+            ty::TyTuple(..) => return None,\n+            // closures get `Categorization::Upvar` rather than `Categorization::Interior`\n+            _ =>  bug!(\"interior cmt {:?} is not an ADT\", self)\n+        };\n         let variant_def = match self.cat {\n             Categorization::Downcast(_, variant_did) => {\n                 adt_def.variant_with_id(variant_did)\n@@ -220,7 +223,7 @@ impl<'tcx> cmt_<'tcx> {\n             NamedField(name) => variant_def.field_named(name),\n             PositionalField(idx) => &variant_def.fields[idx]\n         };\n-        (adt_def, field_def)\n+        Some((adt_def, field_def))\n     }\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n@@ -232,8 +235,9 @@ impl<'tcx> cmt_<'tcx> {\n                     Categorization::Local(node_id) =>\n                         Some(ImmutabilityBlame::LocalDeref(node_id)),\n                     Categorization::Interior(ref base_cmt, InteriorField(field_name)) => {\n-                        let (adt_def, field_def) = base_cmt.resolve_field(field_name);\n-                        Some(ImmutabilityBlame::AdtFieldDeref(adt_def, field_def))\n+                        base_cmt.resolve_field(field_name).map(|(adt_def, field_def)| {\n+                            ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n+                        })\n                     }\n                     Categorization::Upvar(Upvar { id, .. }) => {\n                         if let NoteClosureEnv(..) = self.note {"}, {"sha": "e5dd48534a6a136ad452e09c9a01226dd1f7196e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,11 +15,11 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use dep_graph::DepNode;\n use hir::map as hir_map;\n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, CrateNum};\n use ty::{self, TyCtxt};\n+use ty::maps::Providers;\n use middle::privacy;\n use session::config;\n use util::nodemap::{NodeSet, FxHashSet};\n@@ -362,7 +362,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n }\n \n pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n-    let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n+    ty::queries::reachable_set::get(tcx, DUMMY_SP, LOCAL_CRATE)\n+}\n+\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> NodeSet {\n+    debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n \n@@ -408,3 +412,10 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n     // Return the set of reachable symbols.\n     reachable_context.reachable_symbols\n }\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        reachable_set,\n+        ..*providers\n+    };\n+}"}, {"sha": "799686ceca4a0ec97021d7ed5343d0d24c417b7f", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -10,7 +10,9 @@\n \n use std::cell::{Ref, RefCell};\n use rustc_data_structures::indexed_vec::IndexVec;\n-\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use ich::StableHashingContext;\n use mir::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n@@ -33,6 +35,13 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Cache {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHasher<W>) {\n+        // do nothing\n+    }\n+}\n \n impl Cache {\n     pub fn new() -> Self {"}, {"sha": "aea4684e526ce3a04c454a23bb93075c0b8ebf9d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -243,6 +243,19 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct Mir<'tcx> {\n+    basic_blocks,\n+    visibility_scopes,\n+    promoted,\n+    return_ty,\n+    local_decls,\n+    arg_count,\n+    upvar_decls,\n+    spread_arg,\n+    span,\n+    cache\n+});\n+\n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n@@ -830,6 +843,11 @@ pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+impl_stable_hash_for!(struct Static<'tcx> {\n+    def_id,\n+    ty\n+});\n+\n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases"}, {"sha": "571ef30b6b9096356a0f92b216088c5d6571d036", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -267,7 +267,7 @@ impl Size {\n \n /// Alignment of a type in bytes, both ABI-mandated and preferred.\n /// Since alignments are always powers of 2, we can pack both in one byte,\n-/// giving each a nibble (4 bits) for a maximum alignment of 2^15 = 32768.\n+/// giving each a nibble (4 bits) for a maximum alignment of 2<sup>15</sup> = 32768.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Align {\n     raw: u8"}, {"sha": "823bdc9e092ac8290801a25a1b8b3e7ac83a61dd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -15,6 +15,7 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n@@ -209,6 +210,11 @@ impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"reachability\")\n+    }\n+}\n \n macro_rules! define_maps {\n     (<$tcx:tt>\n@@ -440,6 +446,8 @@ define_maps! { <'tcx>\n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n+    pub reachable_set: reachability_dep_node(CrateNum) -> NodeSet,\n+\n     pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n@@ -451,6 +459,10 @@ fn crate_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n \n+fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::Reachability\n+}\n+\n fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }"}, {"sha": "3c529a69820427052525d8fc999fc79ba552b3df", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -19,6 +19,7 @@ use dep_graph::{self, DepNode};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -50,6 +51,8 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -1379,6 +1382,25 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n \n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::AdtDef {\n+            did,\n+            ref variants,\n+            ref flags,\n+            ref repr,\n+        } = *self;\n+\n+        did.hash_stable(hcx, hasher);\n+        variants.hash_stable(hcx, hasher);\n+        flags.hash_stable(hcx, hasher);\n+        repr.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n@@ -1391,6 +1413,13 @@ pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n }\n \n+impl_stable_hash_for!(struct ReprOptions {\n+    c,\n+    packed,\n+    simd,\n+    int\n+});\n+\n impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();"}, {"sha": "54f5cff16ed6cb584b888d46983820938f5e9d1e", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -490,6 +490,17 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               _ => span_bug!(e.span, \"typeck error\"),\n              })\n           }\n+          (Char(a), Char(b)) => {\n+            Bool(match op.node {\n+              hir::BiEq => a == b,\n+              hir::BiNe => a != b,\n+              hir::BiLt => a < b,\n+              hir::BiLe => a <= b,\n+              hir::BiGe => a >= b,\n+              hir::BiGt => a > b,\n+              _ => span_bug!(e.span, \"typeck error\"),\n+             })\n+          }\n \n           _ => signal!(e, MiscBinaryOp),\n         }"}, {"sha": "c1735b4a4ec9a588156757293152deb775fa1129", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -37,6 +37,8 @@\n #![feature(unsize)]\n #![feature(i128_type)]\n #![feature(conservative_impl_trait)]\n+#![feature(discriminant_value)]\n+#![feature(specialization)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "dc412a0763ef70f196eed9134bfa930f21a40570", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::Hasher;\n+use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n@@ -174,3 +174,193 @@ impl<W> Hasher for StableHasher<W> {\n         self.write_ileb128(i as i64);\n     }\n }\n+\n+\n+/// Something that implements `HashStable<CTX>` can be hashed in a way that is\n+/// stable across multiple compiliation sessions.\n+pub trait HashStable<CTX> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>);\n+}\n+\n+// Implement HashStable by just calling `Hash::hash()`. This works fine for\n+// self-contained values that don't depend on the hashing context `CTX`.\n+macro_rules! impl_stable_hash_via_hash {\n+    ($t:ty) => (\n+        impl<CTX> HashStable<CTX> for $t {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  _: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+                ::std::hash::Hash::hash(self, hasher);\n+            }\n+        }\n+    );\n+}\n+\n+impl_stable_hash_via_hash!(i8);\n+impl_stable_hash_via_hash!(i16);\n+impl_stable_hash_via_hash!(i32);\n+impl_stable_hash_via_hash!(i64);\n+impl_stable_hash_via_hash!(isize);\n+\n+impl_stable_hash_via_hash!(u8);\n+impl_stable_hash_via_hash!(u16);\n+impl_stable_hash_via_hash!(u32);\n+impl_stable_hash_via_hash!(u64);\n+impl_stable_hash_via_hash!(usize);\n+\n+impl_stable_hash_via_hash!(u128);\n+impl_stable_hash_via_hash!(i128);\n+\n+impl_stable_hash_via_hash!(char);\n+impl_stable_hash_via_hash!(());\n+\n+impl<CTX> HashStable<CTX> for f32 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u32 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for f64 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u64 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.0.hash_stable(ctx, hasher);\n+        self.1.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n+    default fn hash_stable<W: StableHasherResult>(&self,\n+                                                  ctx: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for item in self {\n+            item.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&self[..]).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for str {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash(hasher);\n+        self.as_bytes().hash(hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for bool {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (if *self { 1u8 } else { 0u8 }).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+\n+impl<T, CTX> HashStable<CTX> for Option<T>\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        if let Some(ref value) = *self {\n+            1u8.hash_stable(ctx, hasher);\n+            value.hash_stable(ctx, hasher);\n+        } else {\n+            0u8.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, T, CTX> HashStable<CTX> for &'a T\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl<K, V, CTX> HashStable<CTX> for ::std::collections::BTreeMap<K, V>\n+    where K: Ord + HashStable<CTX>,\n+          V: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for (k, v) in self {\n+            k.hash_stable(ctx, hasher);\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::collections::BTreeSet<T>\n+    where T: Ord + HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in self {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n+    where T: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in &self.raw {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}"}, {"sha": "0fb386341a9f3e0b1f8ba70a0550777ef1f2efb6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -889,6 +889,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     rustc_privacy::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n+    reachable::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n@@ -1358,10 +1359,9 @@ pub fn build_output_filenames(input: &Input,\n                                            .values()\n                                            .filter(|a| a.is_none())\n                                            .count();\n-            let ofile = if unnamed_output_types > 1 &&\n-                            sess.opts.output_types.contains_key(&OutputType::Exe) {\n-                sess.warn(\"ignoring specified output filename for 'link' output because multiple \\\n-                           outputs were requested\");\n+            let ofile = if unnamed_output_types > 1 {\n+                sess.warn(\"due to multiple output types requested, the explicitly specified \\\n+                           output file name will be adapted for each output type\");\n                 None\n             } else {\n                 Some(out_file.clone())"}, {"sha": "c80a5a1627797bfbae1448530bd649f99ca9b55d", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 93, "deletions": 104, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -27,24 +27,17 @@\n //! at the end of compilation would be different from those computed\n //! at the beginning.\n \n-use syntax::ast;\n use std::cell::RefCell;\n use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use rustc::ich::{Fingerprint, DefPathHashes, CachingCodemapView};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n-use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n-\n-use self::svh_visitor::StrictVersionHashVisitor;\n-\n-mod svh_visitor;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n \n@@ -94,107 +87,58 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n     }\n }\n \n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-    let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n-    let mut visitor = HashItemsVisitor {\n-        tcx: tcx,\n-        hashes: IncrementalHashesMap::new(),\n-        def_path_hashes: DefPathHashes::new(tcx),\n-        codemap: CachingCodemapView::new(tcx),\n-        hash_spans: hash_spans,\n-    };\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| {\n-            v.hash_crate_root_module(krate);\n-        });\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            visitor.calculate_node_id(macro_def.id,\n-                                      |v| v.visit_macro_def(macro_def));\n-        }\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}\n-\n-struct HashItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_path_hashes: DefPathHashes<'a, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n+    hcx: StableHashingContext<'a, 'tcx>,\n     hashes: IncrementalHashesMap,\n-    hash_spans: bool,\n }\n \n-impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n-    fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        self.calculate_def_id(def_id, walk_op)\n-    }\n-\n-    fn calculate_def_id<W>(&mut self, def_id: DefId, mut walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n+    fn compute_and_store_ich_for_item_like<T>(&mut self,\n+                                              dep_node: DepNode<DefId>,\n+                                              hash_bodies: bool,\n+                                              item_like: T)\n+        where T: HashStable<StableHashingContext<'a, 'tcx>>\n     {\n-        assert!(def_id.is_local());\n-        debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n-        self.calculate_def_hash(DepNode::Hir(def_id), false, &mut walk_op);\n-        self.calculate_def_hash(DepNode::HirBody(def_id), true, &mut walk_op);\n-    }\n+        let mut hasher = IchHasher::new();\n+        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n+            item_like.hash_stable(hcx, &mut hasher);\n+        });\n \n-    fn calculate_def_hash<W>(&mut self,\n-                             dep_node: DepNode<DefId>,\n-                             hash_bodies: bool,\n-                             walk_op: &mut W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let mut state = IchHasher::new();\n-        walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n-                                                   self.tcx,\n-                                                   &mut self.def_path_hashes,\n-                                                   &mut self.codemap,\n-                                                   self.hash_spans,\n-                                                   hash_bodies));\n-        let bytes_hashed = state.bytes_hashed();\n-        let item_hash = state.finish();\n+        let bytes_hashed = hasher.bytes_hashed();\n+        let item_hash = hasher.finish();\n         debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n         self.hashes.insert(dep_node, item_hash);\n \n-        let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n+        let tcx = self.hcx.tcx();\n+        let bytes_hashed =\n+            tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n             bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+        tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n     fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n+        let tcx = self.hcx.tcx();\n+        let krate = tcx.hir.krate();\n \n         let mut crate_state = IchHasher::new();\n \n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n+        let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n         crate_disambiguator.as_str().len().hash(&mut crate_state);\n         crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash.\n         {\n-            let def_path_hashes = &mut self.def_path_hashes;\n+            let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n                            .map(|(item_dep_node, &item_hash)| {\n                                // convert from a DepNode<DefId> tp a\n                                // DepNode<u64> where the u64 is the\n                                // hash of the def-id's def-path:\n                                let item_dep_node =\n-                                   item_dep_node.map_def(|&did| Some(def_path_hashes.hash(did)))\n+                                   item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n                                                 .unwrap();\n                                (item_dep_node, item_hash)\n                            })\n@@ -203,40 +147,85 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n             item_hashes.hash(&mut crate_state);\n         }\n \n-        {\n-            let mut visitor = StrictVersionHashVisitor::new(&mut crate_state,\n-                                                            self.tcx,\n-                                                            &mut self.def_path_hashes,\n-                                                            &mut self.codemap,\n-                                                            self.hash_spans,\n-                                                            false);\n-            visitor.hash_attributes(&krate.attrs);\n-        }\n+        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n \n         let crate_hash = crate_state.finish();\n         self.hashes.insert(DepNode::Krate, crate_hash);\n         debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n-}\n \n-\n-impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n+        let hir::Crate {\n+            ref module,\n+            // Crate attributes are not copied over to the root `Mod`, so hash\n+            // them explicitly here.\n+            ref attrs,\n+            span,\n+\n+            // These fields are handled separately:\n+            exported_macros: _,\n+            items: _,\n+            trait_items: _,\n+            impl_items: _,\n+            bodies: _,\n+            trait_impls: _,\n+            trait_default_impl: _,\n+            body_ids: _,\n+        } = *krate;\n+\n+        let def_id = DefId::local(CRATE_DEF_INDEX);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id),\n+                                                 false,\n+                                                 (module, (span, attrs)));\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id),\n+                                                 true,\n+                                                 (module, (span, attrs)));\n     }\n+}\n \n+impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.calculate_node_id(item.id, |v| v.visit_item(item));\n-        visit::walk_item(self, item);\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.calculate_node_id(trait_item.id, |v| v.visit_trait_item(trait_item));\n-        visit::walk_trait_item(self, trait_item);\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n-        visit::walk_impl_item(self, impl_item);\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n }\n+\n+pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                                    -> IncrementalHashesMap {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let krate = tcx.hir.krate();\n+\n+    let mut visitor = ComputeItemHashesVisitor {\n+        hcx: StableHashingContext::new(tcx),\n+        hashes: IncrementalHashesMap::new(),\n+    };\n+\n+    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n+        visitor.hash_crate_root_module(krate);\n+        krate.visit_all_item_likes(&mut visitor);\n+\n+        for macro_def in krate.exported_macros.iter() {\n+            let def_id = tcx.hir.local_def_id(macro_def.id);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n+        }\n+    });\n+\n+    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n+\n+    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n+    visitor.hashes\n+}"}, {"sha": "4700b77be07629738dfa00477c6ccb256fb086c5", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "removed", "additions": 0, "deletions": 1113, "changes": 1113, "blob_url": "https://github.com/rust-lang/rust/blob/b83352e44c36e81db7f00eb60e78ff3828c51c9e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83352e44c36e81db7f00eb60e78ff3828c51c9e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=b83352e44c36e81db7f00eb60e78ff3828c51c9e", "patch": "@@ -1,1113 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use self::SawExprComponent::*;\n-use self::SawAbiComponent::*;\n-use self::SawItemComponent::*;\n-use self::SawPatComponent::*;\n-use self::SawTyComponent::*;\n-use self::SawTraitOrImplItemComponent::*;\n-use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId};\n-use syntax::attr;\n-use syntax::ext::hygiene::SyntaxContext;\n-use syntax::parse::token;\n-use syntax::symbol::InternedString;\n-use syntax_pos::{Span, BytePos};\n-use syntax::tokenstream;\n-use rustc::hir;\n-use rustc::hir::*;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self as visit, Visitor};\n-use rustc::ich::{DefPathHashes, CachingCodemapView, IGNORED_ATTRIBUTES};\n-use rustc::ty::TyCtxt;\n-use std::hash::{Hash, Hasher};\n-\n-use super::IchHasher;\n-\n-pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n-    pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-    pub st: &'a mut IchHasher,\n-    // collect a deterministic hash of def-ids that we have seen\n-    def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-    hash_spans: bool,\n-    codemap: &'a mut CachingCodemapView<'tcx>,\n-    overflow_checks_enabled: bool,\n-    hash_bodies: bool,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    pub fn new(st: &'a mut IchHasher,\n-               tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-               codemap: &'a mut CachingCodemapView<'tcx>,\n-               hash_spans: bool,\n-               hash_bodies: bool)\n-               -> Self {\n-        let check_overflow = tcx.sess.overflow_checks();\n-\n-        StrictVersionHashVisitor {\n-            st: st,\n-            tcx: tcx,\n-            def_path_hashes: def_path_hashes,\n-            hash_spans: hash_spans,\n-            codemap: codemap,\n-            overflow_checks_enabled: check_overflow,\n-            hash_bodies: hash_bodies,\n-        }\n-    }\n-\n-    fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n-        self.def_path_hashes.hash(def_id)\n-    }\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing FileMap has moved\n-    // within the CodeMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n-    fn hash_span(&mut self, span: Span) {\n-        debug!(\"hash_span: st={:?}\", self.st);\n-\n-        // If this is not an empty or invalid span, we want to hash the last\n-        // position that belongs to it, as opposed to hashing the first\n-        // position past it.\n-        let span_hi = if span.hi > span.lo {\n-            // We might end up in the middle of a multibyte character here,\n-            // but that's OK, since we are not trying to decode anything at\n-            // this position.\n-            span.hi - BytePos(1)\n-        } else {\n-            span.hi\n-        };\n-\n-        let expn_kind = if span.ctxt == SyntaxContext::empty() {\n-            SawSpanExpnKind::NoExpansion\n-        } else {\n-            SawSpanExpnKind::SomeExpansion\n-        };\n-\n-        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n-        let loc1 = loc1.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n-        let loc2 = loc2.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let saw = if loc1.0 == loc2.0 {\n-            SawSpan(loc1.0,\n-                    loc1.1, loc1.2,\n-                    loc2.1, loc2.2,\n-                    expn_kind)\n-        } else {\n-            SawSpanTwoFiles(loc1.0, loc1.1, loc1.2,\n-                            loc2.0, loc2.1, loc2.2,\n-                            expn_kind)\n-        };\n-        saw.hash(self.st);\n-\n-        if expn_kind == SawSpanExpnKind::SomeExpansion {\n-            self.hash_span(span.source_callsite());\n-        }\n-    }\n-\n-    fn hash_discriminant<T>(&mut self, v: &T) {\n-        unsafe {\n-            let disr = ::std::intrinsics::discriminant_value(v);\n-            debug!(\"hash_discriminant: disr={}, st={:?}\", disr, self.st);\n-            disr.hash(self.st);\n-        }\n-    }\n-}\n-\n-// To off-load the bulk of the hash-computation on #[derive(Hash)],\n-// we define a set of enums corresponding to the content that our\n-// crate visitor will encounter as it traverses the ast.\n-//\n-// The important invariant is that all of the Saw*Component enums\n-// do not carry any Spans, Names, or Idents.\n-//\n-// Not carrying any Names/Idents is the important fix for problem\n-// noted on PR #13948: using the ident.name as the basis for a\n-// hash leads to unstable SVH, because ident.name is just an index\n-// into intern table (i.e. essentially a random address), not\n-// computed from the name content.\n-//\n-// With the below enums, the SVH computation is not sensitive to\n-// artifacts of how rustc was invoked nor of how the source code\n-// was laid out.  (Or at least it is *less* sensitive.)\n-\n-// This enum represents the different potential bits of code the\n-// visitor could encounter that could affect the ABI for the crate,\n-// and assigns each a distinct tag to feed into the hash computation.\n-#[derive(Hash)]\n-enum SawAbiComponent<'a> {\n-\n-    // FIXME (#14132): should we include (some function of)\n-    // ident.ctxt as well?\n-    SawIdent(InternedString),\n-    SawStructDef(InternedString),\n-\n-    SawLifetime,\n-    SawLifetimeDef(usize),\n-\n-    SawMod,\n-    SawForeignItem(SawForeignItemComponent),\n-    SawItem(SawItemComponent),\n-    SawTy(SawTyComponent),\n-    SawFnDecl(bool),\n-    SawGenerics,\n-    SawTraitItem(SawTraitOrImplItemComponent),\n-    SawImplItem(SawTraitOrImplItemComponent),\n-    SawStructField,\n-    SawVariant(bool),\n-    SawQPath,\n-    SawPathSegment,\n-    SawPathParameters,\n-    SawBlock,\n-    SawPat(SawPatComponent),\n-    SawLocal,\n-    SawArm,\n-    SawExpr(SawExprComponent<'a>),\n-    SawStmt,\n-    SawVis,\n-    SawAssociatedItemKind(hir::AssociatedItemKind),\n-    SawDefaultness(hir::Defaultness),\n-    SawWherePredicate,\n-    SawTyParamBound,\n-    SawPolyTraitRef,\n-    SawAssocTypeBinding,\n-    SawAttribute(ast::AttrStyle),\n-    SawMacroDef,\n-    SawSpan(&'a str,\n-            usize, BytePos,\n-            usize, BytePos,\n-            SawSpanExpnKind),\n-    SawSpanTwoFiles(&'a str, usize, BytePos,\n-                    &'a str, usize, BytePos,\n-                    SawSpanExpnKind),\n-}\n-\n-/// SawExprComponent carries all of the information that we want\n-/// to include in the hash that *won't* be covered by the\n-/// subsequent recursive traversal of the expression's\n-/// substructure by the visitor.\n-///\n-/// We know every Expr_ variant is covered by a variant because\n-/// `fn saw_expr` maps each to some case below.  Ensuring that\n-/// each variant carries an appropriate payload has to be verified\n-/// by hand.\n-///\n-/// (However, getting that *exactly* right is not so important\n-/// because the SVH is just a developer convenience; there is no\n-/// guarantee of collision-freedom, hash collisions are just\n-/// (hopefully) unlikely.)\n-///\n-/// The xxxComponent enums and saw_xxx functions for Item, Pat,\n-/// Ty, TraitItem and ImplItem follow the same methodology.\n-#[derive(Hash)]\n-enum SawExprComponent<'a> {\n-\n-    SawExprLoop(Option<InternedString>),\n-    SawExprField(InternedString),\n-    SawExprTupField(usize),\n-    SawExprBreak(Option<InternedString>),\n-    SawExprAgain(Option<InternedString>),\n-\n-    SawExprBox,\n-    SawExprArray,\n-    SawExprCall,\n-    SawExprMethodCall,\n-    SawExprTup,\n-    SawExprBinary(hir::BinOp_),\n-    SawExprUnary(hir::UnOp),\n-    SawExprLit(ast::LitKind),\n-    SawExprLitStr(InternedString, ast::StrStyle),\n-    SawExprLitFloat(InternedString, Option<ast::FloatTy>),\n-    SawExprCast,\n-    SawExprType,\n-    SawExprIf,\n-    SawExprWhile,\n-    SawExprMatch,\n-    SawExprClosure(CaptureClause),\n-    SawExprBlock,\n-    SawExprAssign,\n-    SawExprAssignOp(hir::BinOp_),\n-    SawExprIndex,\n-    SawExprPath,\n-    SawExprAddrOf(hir::Mutability),\n-    SawExprRet,\n-    SawExprInlineAsm(StableInlineAsm<'a>),\n-    SawExprStruct,\n-    SawExprRepeat,\n-}\n-\n-// The boolean returned indicates whether the span of this expression is always\n-// significant, regardless of debuginfo.\n-fn saw_expr<'a>(node: &'a Expr_,\n-                overflow_checks_enabled: bool)\n-                -> (SawExprComponent<'a>, bool) {\n-    let binop_can_panic_at_runtime = |binop| {\n-        match binop {\n-            BiAdd |\n-            BiSub |\n-            BiMul => overflow_checks_enabled,\n-\n-            BiDiv |\n-            BiRem => true,\n-\n-            BiAnd |\n-            BiOr |\n-            BiBitXor |\n-            BiBitAnd |\n-            BiBitOr |\n-            BiShl |\n-            BiShr |\n-            BiEq |\n-            BiLt |\n-            BiLe |\n-            BiNe |\n-            BiGe |\n-            BiGt => false\n-        }\n-    };\n-\n-    let unop_can_panic_at_runtime = |unop| {\n-        match unop {\n-            UnDeref |\n-            UnNot => false,\n-            UnNeg => overflow_checks_enabled,\n-        }\n-    };\n-\n-    match *node {\n-        ExprBox(..)              => (SawExprBox, false),\n-        ExprArray(..)            => (SawExprArray, false),\n-        ExprCall(..)             => (SawExprCall, false),\n-        ExprMethodCall(..)       => (SawExprMethodCall, false),\n-        ExprTup(..)              => (SawExprTup, false),\n-        ExprBinary(op, ..)       => {\n-            (SawExprBinary(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprUnary(op, _)         => {\n-            (SawExprUnary(op), unop_can_panic_at_runtime(op))\n-        }\n-        ExprLit(ref lit)         => (saw_lit(lit), false),\n-        ExprCast(..)             => (SawExprCast, false),\n-        ExprType(..)             => (SawExprType, false),\n-        ExprIf(..)               => (SawExprIf, false),\n-        ExprWhile(..)            => (SawExprWhile, false),\n-        ExprLoop(_, id, _)       => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n-        ExprMatch(..)            => (SawExprMatch, false),\n-        ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n-        ExprBlock(..)            => (SawExprBlock, false),\n-        ExprAssign(..)           => (SawExprAssign, false),\n-        ExprAssignOp(op, ..)     => {\n-            (SawExprAssignOp(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n-        ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n-        ExprIndex(..)            => (SawExprIndex, true),\n-        ExprPath(_)              => (SawExprPath, false),\n-        ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprRet(..)              => (SawExprRet, false),\n-        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n-        ExprStruct(..)           => (SawExprStruct, false),\n-        ExprRepeat(..)           => (SawExprRepeat, false),\n-    }\n-}\n-\n-fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n-    match lit.node {\n-        ast::LitKind::Str(s, style) => SawExprLitStr(s.as_str(), style),\n-        ast::LitKind::Float(s, ty) => SawExprLitFloat(s.as_str(), Some(ty)),\n-        ast::LitKind::FloatUnsuffixed(s) => SawExprLitFloat(s.as_str(), None),\n-        ref node @ _ => SawExprLit(node.clone()),\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawItemComponent {\n-    SawItemExternCrate,\n-    SawItemUse(UseKind),\n-    SawItemStatic(Mutability),\n-    SawItemConst,\n-    SawItemFn(Unsafety, Constness, Abi),\n-    SawItemMod,\n-    SawItemForeignMod(Abi),\n-    SawItemTy,\n-    SawItemEnum,\n-    SawItemStruct,\n-    SawItemUnion,\n-    SawItemTrait(Unsafety),\n-    SawItemDefaultImpl(Unsafety),\n-    SawItemImpl(Unsafety, ImplPolarity)\n-}\n-\n-fn saw_item(node: &Item_) -> SawItemComponent {\n-    match *node {\n-        ItemExternCrate(..) => SawItemExternCrate,\n-        ItemUse(_, kind) => SawItemUse(kind),\n-        ItemStatic(_, mutability, _) => SawItemStatic(mutability),\n-        ItemConst(..) =>SawItemConst,\n-        ItemFn(_, unsafety, constness, abi, _, _) => SawItemFn(unsafety, constness, abi),\n-        ItemMod(..) => SawItemMod,\n-        ItemForeignMod(ref fm) => SawItemForeignMod(fm.abi),\n-        ItemTy(..) => SawItemTy,\n-        ItemEnum(..) => SawItemEnum,\n-        ItemStruct(..) => SawItemStruct,\n-        ItemUnion(..) => SawItemUnion,\n-        ItemTrait(unsafety, ..) => SawItemTrait(unsafety),\n-        ItemDefaultImpl(unsafety, _) => SawItemDefaultImpl(unsafety),\n-        ItemImpl(unsafety, implpolarity, ..) => SawItemImpl(unsafety, implpolarity)\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawForeignItemComponent {\n-    Static { mutable: bool },\n-    Fn,\n-}\n-\n-#[derive(Hash)]\n-enum SawPatComponent {\n-    SawPatWild,\n-    SawPatBinding(BindingMode),\n-    SawPatStruct,\n-    SawPatTupleStruct,\n-    SawPatPath,\n-    SawPatTuple,\n-    SawPatBox,\n-    SawPatRef(Mutability),\n-    SawPatLit,\n-    SawPatRange,\n-    SawPatSlice\n-}\n-\n-fn saw_pat(node: &PatKind) -> SawPatComponent {\n-    match *node {\n-        PatKind::Wild => SawPatWild,\n-        PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n-        PatKind::Struct(..) => SawPatStruct,\n-        PatKind::TupleStruct(..) => SawPatTupleStruct,\n-        PatKind::Path(_) => SawPatPath,\n-        PatKind::Tuple(..) => SawPatTuple,\n-        PatKind::Box(..) => SawPatBox,\n-        PatKind::Ref(_, mutability) => SawPatRef(mutability),\n-        PatKind::Lit(..) => SawPatLit,\n-        PatKind::Range(..) => SawPatRange,\n-        PatKind::Slice(..) => SawPatSlice\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTyComponent {\n-    SawTySlice,\n-    SawTyArray,\n-    SawTyPtr(Mutability),\n-    SawTyRptr(Mutability),\n-    SawTyBareFn(Unsafety, Abi),\n-    SawTyNever,\n-    SawTyTup,\n-    SawTyPath,\n-    SawTyObjectSum,\n-    SawTyImplTrait,\n-    SawTyTypeof,\n-    SawTyInfer,\n-    SawTyErr,\n-}\n-\n-fn saw_ty(node: &Ty_) -> SawTyComponent {\n-    match *node {\n-      TySlice(..) => SawTySlice,\n-      TyArray(..) => SawTyArray,\n-      TyPtr(ref mty) => SawTyPtr(mty.mutbl),\n-      TyRptr(_, ref mty) => SawTyRptr(mty.mutbl),\n-      TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n-      TyNever => SawTyNever,\n-      TyTup(..) => SawTyTup,\n-      TyPath(_) => SawTyPath,\n-      TyTraitObject(..) => SawTyObjectSum,\n-      TyImplTrait(..) => SawTyImplTrait,\n-      TyTypeof(..) => SawTyTypeof,\n-      TyInfer => SawTyInfer,\n-      TyErr => SawTyErr,\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTraitOrImplItemComponent {\n-    SawTraitOrImplItemConst,\n-    // The boolean signifies whether a body is present\n-    SawTraitOrImplItemMethod(Unsafety, Constness, Abi, bool),\n-    SawTraitOrImplItemType\n-}\n-\n-fn saw_trait_item(ti: &TraitItemKind) -> SawTraitOrImplItemComponent {\n-    match *ti {\n-        TraitItemKind::Const(..) => SawTraitOrImplItemConst,\n-        TraitItemKind::Method(ref sig, TraitMethod::Required(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, false),\n-        TraitItemKind::Method(ref sig, TraitMethod::Provided(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        TraitItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n-    match *ii {\n-        ImplItemKind::Const(..) => SawTraitOrImplItemConst,\n-        ImplItemKind::Method(ref sig, _) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        ImplItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-#[derive(Clone, Copy, Hash, Eq, PartialEq)]\n-enum SawSpanExpnKind {\n-    NoExpansion,\n-    SomeExpansion,\n-}\n-\n-/// A wrapper that provides a stable Hash implementation.\n-struct StableInlineAsm<'a>(&'a InlineAsm);\n-\n-impl<'a> Hash for StableInlineAsm<'a> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let InlineAsm {\n-            asm,\n-            asm_str_style,\n-            ref outputs,\n-            ref inputs,\n-            ref clobbers,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: _, // This is used for error reporting\n-        } = *self.0;\n-\n-        asm.as_str().hash(state);\n-        asm_str_style.hash(state);\n-        outputs.len().hash(state);\n-        for output in outputs {\n-            let InlineAsmOutput { constraint, is_rw, is_indirect } = *output;\n-            constraint.as_str().hash(state);\n-            is_rw.hash(state);\n-            is_indirect.hash(state);\n-        }\n-        inputs.len().hash(state);\n-        for input in inputs {\n-            input.as_str().hash(state);\n-        }\n-        clobbers.len().hash(state);\n-        for clobber in clobbers {\n-            clobber.as_str().hash(state);\n-        }\n-        volatile.hash(state);\n-        alignstack.hash(state);\n-        dialect.hash(state);\n-    }\n-}\n-\n-macro_rules! hash_attrs {\n-    ($visitor:expr, $attrs:expr) => ({\n-        let attrs = $attrs;\n-        if attrs.len() > 0 {\n-            $visitor.hash_attributes(attrs);\n-        }\n-    })\n-}\n-\n-macro_rules! hash_span {\n-    ($visitor:expr, $span:expr) => ({\n-        hash_span!($visitor, $span, false)\n-    });\n-    ($visitor:expr, $span:expr, $force:expr) => ({\n-        if $force || $visitor.hash_spans {\n-            $visitor.hash_span($span);\n-        }\n-    });\n-}\n-\n-impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n-        if self.hash_bodies {\n-            visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n-        } else {\n-            visit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          s: &'tcx VariantData,\n-                          name: Name,\n-                          _: &'tcx Generics,\n-                          _: NodeId,\n-                          span: Span) {\n-        debug!(\"visit_variant_data: st={:?}\", self.st);\n-        SawStructDef(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_struct_def(self, s);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     v: &'tcx Variant,\n-                     g: &'tcx Generics,\n-                     item_id: NodeId) {\n-        debug!(\"visit_variant: st={:?}\", self.st);\n-        SawVariant(v.node.disr_expr.is_some()).hash(self.st);\n-        hash_attrs!(self, &v.node.attrs);\n-        visit::walk_variant(self, v, g, item_id)\n-    }\n-\n-    fn visit_name(&mut self, span: Span, name: Name) {\n-        debug!(\"visit_name: st={:?}\", self.st);\n-        SawIdent(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-    }\n-\n-    fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n-        debug!(\"visit_lifetime: st={:?}\", self.st);\n-        SawLifetime.hash(self.st);\n-        visit::walk_lifetime(self, l);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n-        debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-        SawLifetimeDef(l.bounds.len()).hash(self.st);\n-        visit::walk_lifetime_def(self, l);\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        debug!(\"visit_expr: st={:?}\", self.st);\n-        let (saw_expr, force_span) = saw_expr(&ex.node,\n-                                              self.overflow_checks_enabled);\n-        SawExpr(saw_expr).hash(self.st);\n-        // No need to explicitly hash the discriminant here, since we are\n-        // implicitly hashing the discriminant of SawExprComponent.\n-        hash_span!(self, ex.span, force_span);\n-        hash_attrs!(self, &ex.attrs);\n-\n-        // Always hash nested constant bodies (e.g. n in `[x; n]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_expr(self, ex);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n-        debug!(\"visit_stmt: st={:?}\", self.st);\n-\n-        // We don't want to modify the hash for decls, because\n-        // they might be item decls (if they are local decls,\n-        // we'll hash that fact in visit_local); but we do want to\n-        // remember if this was a StmtExpr or StmtSemi (the later\n-        // had an explicit semi-colon; this affects the typing\n-        // rules).\n-        match s.node {\n-            StmtDecl(..) => (),\n-            StmtExpr(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-            StmtSemi(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-        }\n-\n-        visit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n-        debug!(\"visit_foreign_item: st={:?}\", self.st);\n-\n-        match i.node {\n-            ForeignItemFn(..) => {\n-                SawForeignItem(SawForeignItemComponent::Fn)\n-            }\n-            ForeignItemStatic(_, mutable) => {\n-                SawForeignItem(SawForeignItemComponent::Static {\n-                    mutable: mutable\n-                })\n-            }\n-        }.hash(self.st);\n-\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_foreign_item(self, i)\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx Item) {\n-        debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-        self.maybe_enable_overflow_checks(&i.attrs);\n-\n-        SawItem(saw_item(&i.node)).hash(self.st);\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_item(self, i)\n-    }\n-\n-    fn visit_mod(&mut self, m: &'tcx Mod, span: Span, n: NodeId) {\n-        debug!(\"visit_mod: st={:?}\", self.st);\n-        SawMod.hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_mod(self, m, n)\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx Ty) {\n-        debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy(saw_ty(&t.node)).hash(self.st);\n-        hash_span!(self, t.span);\n-\n-        // Always hash nested constant bodies (e.g. N in `[T; N]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_ty(self, t);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_generics(&mut self, g: &'tcx Generics) {\n-        debug!(\"visit_generics: st={:?}\", self.st);\n-        SawGenerics.hash(self.st);\n-        visit::walk_generics(self, g)\n-    }\n-\n-    fn visit_fn_decl(&mut self, fd: &'tcx FnDecl) {\n-        debug!(\"visit_fn_decl: st={:?}\", self.st);\n-        SawFnDecl(fd.variadic).hash(self.st);\n-        visit::walk_fn_decl(self, fd)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n-        debug!(\"visit_trait_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ti.attrs);\n-\n-        SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n-        hash_span!(self, ti.span);\n-        hash_attrs!(self, &ti.attrs);\n-        visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n-        debug!(\"visit_impl_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ii.attrs);\n-\n-        SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n-        hash_span!(self, ii.span);\n-        hash_attrs!(self, &ii.attrs);\n-        visit::walk_impl_item(self, ii)\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        debug!(\"visit_struct_field: st={:?}\", self.st);\n-        SawStructField.hash(self.st);\n-        hash_span!(self, s.span);\n-        hash_attrs!(self, &s.attrs);\n-        visit::walk_struct_field(self, s)\n-    }\n-\n-    fn visit_qpath(&mut self, qpath: &'tcx QPath, id: NodeId, span: Span) {\n-        debug!(\"visit_qpath: st={:?}\", self.st);\n-        SawQPath.hash(self.st);\n-        self.hash_discriminant(qpath);\n-        visit::walk_qpath(self, qpath, id, span)\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n-        debug!(\"visit_path: st={:?}\", self.st);\n-        hash_span!(self, path.span);\n-        visit::walk_path(self, path)\n-    }\n-\n-    fn visit_def_mention(&mut self, def: Def) {\n-        self.hash_def(def);\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx Block) {\n-        debug!(\"visit_block: st={:?}\", self.st);\n-        SawBlock.hash(self.st);\n-        hash_span!(self, b.span);\n-        visit::walk_block(self, b)\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx Pat) {\n-        debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat(saw_pat(&p.node)).hash(self.st);\n-        hash_span!(self, p.span);\n-        visit::walk_pat(self, p)\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx Local) {\n-        debug!(\"visit_local: st={:?}\", self.st);\n-        SawLocal.hash(self.st);\n-        hash_attrs!(self, &l.attrs);\n-        visit::walk_local(self, l)\n-        // No need to hash span, we are hashing all component spans\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx Arm) {\n-        debug!(\"visit_arm: st={:?}\", self.st);\n-        SawArm.hash(self.st);\n-        hash_attrs!(self, &a.attrs);\n-        visit::walk_arm(self, a)\n-    }\n-\n-    fn visit_id(&mut self, id: NodeId) {\n-        debug!(\"visit_id: id={} st={:?}\", id, self.st);\n-        self.hash_resolve(id)\n-    }\n-\n-    fn visit_vis(&mut self, v: &'tcx Visibility) {\n-        debug!(\"visit_vis: st={:?}\", self.st);\n-        SawVis.hash(self.st);\n-        self.hash_discriminant(v);\n-        visit::walk_vis(self, v)\n-    }\n-\n-    fn visit_associated_item_kind(&mut self, kind: &'tcx AssociatedItemKind) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawAssociatedItemKind(*kind).hash(self.st);\n-        visit::walk_associated_item_kind(self, kind);\n-    }\n-\n-    fn visit_defaultness(&mut self, defaultness: &'tcx Defaultness) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawDefaultness(*defaultness).hash(self.st);\n-        visit::walk_defaultness(self, defaultness);\n-    }\n-\n-    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n-        debug!(\"visit_where_predicate: st={:?}\", self.st);\n-        SawWherePredicate.hash(self.st);\n-        self.hash_discriminant(predicate);\n-        // Ignoring span. Any important nested components should be visited.\n-        visit::walk_where_predicate(self, predicate)\n-    }\n-\n-    fn visit_ty_param_bound(&mut self, bounds: &'tcx TyParamBound) {\n-        debug!(\"visit_ty_param_bound: st={:?}\", self.st);\n-        SawTyParamBound.hash(self.st);\n-        self.hash_discriminant(bounds);\n-        // The TraitBoundModifier in TraitTyParamBound will be hash in\n-        // visit_poly_trait_ref()\n-        visit::walk_ty_param_bound(self, bounds)\n-    }\n-\n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n-        debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n-        SawPolyTraitRef.hash(self.st);\n-        m.hash(self.st);\n-        visit::walk_poly_trait_ref(self, t, m)\n-    }\n-\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n-        debug!(\"visit_path_segment: st={:?}\", self.st);\n-        SawPathSegment.hash(self.st);\n-        visit::walk_path_segment(self, path_span, path_segment)\n-    }\n-\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'tcx PathParameters) {\n-        debug!(\"visit_path_parameters: st={:?}\", self.st);\n-        SawPathParameters.hash(self.st);\n-        self.hash_discriminant(path_parameters);\n-        visit::walk_path_parameters(self, path_span, path_parameters)\n-    }\n-\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n-        debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n-        SawAssocTypeBinding.hash(self.st);\n-        hash_span!(self, type_binding.span);\n-        visit::walk_assoc_type_binding(self, type_binding)\n-    }\n-\n-    fn visit_attribute(&mut self, _: &ast::Attribute) {\n-        // We explicitly do not use this method, since doing that would\n-        // implicitly impose an order on the attributes being hashed, while we\n-        // explicitly don't want their order to matter\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n-        debug!(\"visit_macro_def: st={:?}\", self.st);\n-        SawMacroDef.hash(self.st);\n-        hash_attrs!(self, &macro_def.attrs);\n-        for tt in macro_def.body.trees() {\n-            self.hash_token_tree(&tt);\n-        }\n-        visit::walk_macro_def(self, macro_def)\n-    }\n-}\n-\n-#[derive(Hash)]\n-pub enum DefHash {\n-    SawDefId,\n-    SawLabel,\n-    SawPrimTy,\n-    SawSelfTy,\n-    SawErr,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn hash_resolve(&mut self, id: ast::NodeId) {\n-        // Because whether or not a given id has an entry is dependent\n-        // solely on expr variant etc, we don't need to hash whether\n-        // or not an entry was present (we are already hashing what\n-        // variant it is above when we visit the HIR).\n-\n-        if let Some(traits) = self.tcx.trait_map.get(&id) {\n-            debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n-            traits.len().hash(self.st);\n-\n-            // The ordering of the candidates is not fixed. So we hash\n-            // the def-ids and then sort them and hash the collection.\n-            let mut candidates: Vec<_> =\n-                traits.iter()\n-                      .map(|&TraitCandidate { def_id, import_id: _ }| {\n-                          self.compute_def_id_hash(def_id)\n-                      })\n-                      .collect();\n-            candidates.sort();\n-            candidates.hash(self.st);\n-        }\n-    }\n-\n-    fn hash_def_id(&mut self, def_id: DefId) {\n-        self.compute_def_id_hash(def_id).hash(self.st);\n-    }\n-\n-    fn hash_def(&mut self, def: Def) {\n-        match def {\n-            // Crucial point: for all of these variants, the variant +\n-            // add'l data that is added is always the same if the\n-            // def-id is the same, so it suffices to hash the def-id\n-            Def::Fn(..) |\n-            Def::Mod(..) |\n-            Def::Static(..) |\n-            Def::Variant(..) |\n-            Def::VariantCtor(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::TyParam(..) |\n-            Def::Struct(..) |\n-            Def::StructCtor(..) |\n-            Def::Union(..) |\n-            Def::Trait(..) |\n-            Def::Method(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::Macro(..) => {\n-                DefHash::SawDefId.hash(self.st);\n-                self.hash_def_id(def.def_id());\n-            }\n-\n-            Def::Label(..) => {\n-                DefHash::SawLabel.hash(self.st);\n-                // we don't encode the `id` because it always refers to something\n-                // within this item, so if it changed, there would have to be other\n-                // changes too\n-            }\n-            Def::PrimTy(ref prim_ty) => {\n-                DefHash::SawPrimTy.hash(self.st);\n-                prim_ty.hash(self.st);\n-            }\n-            Def::SelfTy(..) => {\n-                DefHash::SawSelfTy.hash(self.st);\n-                // the meaning of Self is always the same within a\n-                // given context, so we don't need to hash the other\n-                // fields\n-            }\n-            Def::Err => {\n-                DefHash::SawErr.hash(self.st);\n-            }\n-        }\n-    }\n-\n-    pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n-        debug!(\"hash_attributes: st={:?}\", self.st);\n-        let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n-\n-        for i in indices {\n-            let attr = &attributes[i];\n-            match attr.name() {\n-                Some(name) if IGNORED_ATTRIBUTES.contains(&&*name.as_str()) => continue,\n-                _ => {}\n-            };\n-            if !attr.is_sugared_doc {\n-                SawAttribute(attr.style).hash(self.st);\n-                for segment in &attr.path.segments {\n-                    SawIdent(segment.identifier.name.as_str()).hash(self.st);\n-                }\n-                for tt in attr.tokens.trees() {\n-                    self.hash_token_tree(&tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn indices_sorted_by<T, K, F>(&mut self, items: &[T], get_key: F) -> Vec<usize>\n-        where K: Ord,\n-              F: Fn(&T) -> K\n-    {\n-        let mut indices = Vec::with_capacity(items.len());\n-        indices.extend(0 .. items.len());\n-        indices.sort_by_key(|index| get_key(&items[*index]));\n-        indices\n-    }\n-\n-    fn maybe_enable_overflow_checks(&mut self, item_attrs: &[ast::Attribute]) {\n-        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n-            self.overflow_checks_enabled = true;\n-        }\n-    }\n-\n-    fn hash_token_tree(&mut self, tt: &tokenstream::TokenTree) {\n-        self.hash_discriminant(tt);\n-        match *tt {\n-            tokenstream::TokenTree::Token(span, ref token) => {\n-                hash_span!(self, span);\n-                self.hash_token(token, span);\n-            }\n-            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n-                hash_span!(self, span);\n-                delimited.delim.hash(self.st);\n-                for sub_tt in delimited.stream().trees() {\n-                    self.hash_token_tree(&sub_tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn hash_token(&mut self,\n-                  token: &token::Token,\n-                  error_reporting_span: Span) {\n-        self.hash_discriminant(token);\n-        match *token {\n-            token::Token::Eq |\n-            token::Token::Lt |\n-            token::Token::Le |\n-            token::Token::EqEq |\n-            token::Token::Ne |\n-            token::Token::Ge |\n-            token::Token::Gt |\n-            token::Token::AndAnd |\n-            token::Token::OrOr |\n-            token::Token::Not |\n-            token::Token::Tilde |\n-            token::Token::At |\n-            token::Token::Dot |\n-            token::Token::DotDot |\n-            token::Token::DotDotDot |\n-            token::Token::Comma |\n-            token::Token::Semi |\n-            token::Token::Colon |\n-            token::Token::ModSep |\n-            token::Token::RArrow |\n-            token::Token::LArrow |\n-            token::Token::FatArrow |\n-            token::Token::Pound |\n-            token::Token::Dollar |\n-            token::Token::Question |\n-            token::Token::Underscore |\n-            token::Token::Whitespace |\n-            token::Token::Comment |\n-            token::Token::Eof => {}\n-\n-            token::Token::BinOp(bin_op_token) |\n-            token::Token::BinOpEq(bin_op_token) => bin_op_token.hash(self.st),\n-\n-            token::Token::OpenDelim(delim_token) |\n-            token::Token::CloseDelim(delim_token) => delim_token.hash(self.st),\n-\n-            token::Token::Literal(ref lit, ref opt_name) => {\n-                self.hash_discriminant(lit);\n-                match *lit {\n-                    token::Lit::Byte(val) |\n-                    token::Lit::Char(val) |\n-                    token::Lit::Integer(val) |\n-                    token::Lit::Float(val) |\n-                    token::Lit::Str_(val) |\n-                    token::Lit::ByteStr(val) => val.as_str().hash(self.st),\n-                    token::Lit::StrRaw(val, n) |\n-                    token::Lit::ByteStrRaw(val, n) => {\n-                        val.as_str().hash(self.st);\n-                        n.hash(self.st);\n-                    }\n-                };\n-                opt_name.map(ast::Name::as_str).hash(self.st);\n-            }\n-\n-            token::Token::Ident(ident) |\n-            token::Token::Lifetime(ident) |\n-            token::Token::SubstNt(ident) => ident.name.as_str().hash(self.st),\n-\n-            token::Token::Interpolated(ref non_terminal) => {\n-                // FIXME(mw): This could be implemented properly. It's just a\n-                //            lot of work, since we would need to hash the AST\n-                //            in a stable way, in addition to the HIR.\n-                //            Since this is hardly used anywhere, just emit a\n-                //            warning for now.\n-                if self.tcx.sess.opts.debugging_opts.incremental.is_some() {\n-                    let msg = format!(\"Quasi-quoting might make incremental \\\n-                                       compilation very inefficient: {:?}\",\n-                                      non_terminal);\n-                    self.tcx.sess.span_warn(error_reporting_span, &msg[..]);\n-                }\n-\n-                non_terminal.hash(self.st);\n-            }\n-\n-            token::Token::DocComment(val) |\n-            token::Token::Shebang(val) => val.as_str().hash(self.st),\n-        }\n-    }\n-\n-    pub fn hash_crate_root_module(&mut self, krate: &'tcx Crate) {\n-        let hir::Crate {\n-            ref module,\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);\n-        // Crate attributes are not copied over to the root `Mod`, so hash them\n-        // explicitly here.\n-        hash_attrs!(self, attrs);\n-    }\n-}"}, {"sha": "d10df17f85837bc251a7055f04f512704eb5d792", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -22,7 +22,6 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n-#![feature(core_intrinsics)]\n #![feature(conservative_impl_trait)]\n #![cfg_attr(stage0, feature(pub_restricted))]\n "}, {"sha": "7d5887e699fd7fdb2329291736ca32a7130ec1f6", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -259,4 +259,10 @@ fn main() {\n             println!(\"cargo:rustc-link-lib={}\", stdcppname);\n         }\n     }\n+\n+    // LLVM requires symbols from this library, but apparently they're not printeds\n+    // during llvm-config?\n+    if target.contains(\"windows\") {\n+        println!(\"cargo:rustc-link-lib=ole32\");\n+    }\n }"}, {"sha": "32c9183ece999ff742f7d33f1dd9b0b92fddda20", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1662,10 +1662,3 @@ extern \"C\" {\n     pub fn LLVMRustUnsetComdat(V: ValueRef);\n     pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n }\n-\n-\n-// LLVM requires symbols from this library, but apparently they're not printed\n-// during llvm-config?\n-#[cfg(windows)]\n-#[link(name = \"ole32\")]\n-extern \"C\" {}"}, {"sha": "c503b8c7fe06f7bb9c58ed0fce452203e35551e0", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -25,6 +25,9 @@ impl<'tcx> CFG<'tcx> {\n         &mut self.basic_blocks[blk]\n     }\n \n+    // llvm.org/PR32488 makes this function use an excess of stack space. Mark\n+    // it as #[inline(never)] to keep rustc's stack use in check.\n+    #[inline(never)]\n     pub fn start_new_block(&mut self) -> BasicBlock {\n         self.basic_blocks.push(BasicBlockData::new(None))\n     }"}, {"sha": "966cb7ee8d8d83c6299955357d2a2306469c1328", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -222,8 +222,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n             let name = unwrap_or!(attrs[i].name(), continue);\n \n             if name == \"derive\" {\n-                let result = attrs[i].parse_list(&self.session.parse_sess,\n-                                                 |parser| parser.parse_path(PathStyle::Mod));\n+                let result = attrs[i].parse_list(&self.session.parse_sess, |parser| {\n+                    parser.parse_path_allowing_meta(PathStyle::Mod)\n+                });\n+\n                 let mut traits = match result {\n                     Ok(traits) => traits,\n                     Err(mut e) => {"}, {"sha": "3fd0ce45e3610af20760a82c093a76450a1f6e9d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1149,8 +1149,32 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                     &trait_item.attrs,\n                                     trait_item.span);\n             }\n-            ast::TraitItemKind::Const(_, None) |\n-            ast::TraitItemKind::Type(..) |\n+            ast::TraitItemKind::Type(ref _bounds, ref default_ty) => {\n+                // FIXME do something with _bounds (for type refs)\n+                let name = trait_item.ident.name.to_string();\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n+                let sub_span = self.span.sub_span_after_keyword(trait_item.span, keywords::Type);\n+\n+                if !self.span.filter_generated(sub_span, trait_item.span) {\n+                    self.dumper.typedef(TypeDefData {\n+                        span: sub_span.expect(\"No span found for assoc type\"),\n+                        name: name,\n+                        id: trait_item.id,\n+                        qualname: qualname,\n+                        value: self.span.snippet(trait_item.span),\n+                        visibility: Visibility::Public,\n+                        parent: Some(trait_id),\n+                        docs: docs_for_attrs(&trait_item.attrs),\n+                        sig: None,\n+                        attributes: trait_item.attrs.clone(),\n+                    }.lower(self.tcx));\n+                }\n+\n+                if let &Some(ref default_ty) = default_ty {\n+                    self.visit_ty(default_ty)\n+                }\n+            }\n+            ast::TraitItemKind::Const(ref ty, None) => self.visit_ty(ty),\n             ast::TraitItemKind::Macro(_) => {}\n         }\n     }\n@@ -1177,7 +1201,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                     &impl_item.attrs,\n                                     impl_item.span);\n             }\n-            ast::ImplItemKind::Type(_) |\n+            ast::ImplItemKind::Type(ref ty) => self.visit_ty(ty),\n             ast::ImplItemKind::Macro(_) => {}\n         }\n     }\n@@ -1377,15 +1401,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         debug!(\"visit_expr {:?}\", ex.node);\n         self.process_macro_use(ex.span, ex.id);\n         match ex.node {\n-            ast::ExprKind::Call(ref _f, ref _args) => {\n-                // Don't need to do anything for function calls,\n-                // because just walking the callee path does what we want.\n-                visit::walk_expr(self, ex);\n-            }\n-            ast::ExprKind::Path(_, ref path) => {\n-                self.process_path(ex.id, path, None);\n-                visit::walk_expr(self, ex);\n-            }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.hir.expect_expr(ex.id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n@@ -1483,6 +1498,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 self.visit_expr(element);\n                 self.nest_tables(count.id, |v| v.visit_expr(count));\n             }\n+            // In particular, we take this branch for call and path expressions,\n+            // where we'll index the idents involved just by continuing to walk.\n             _ => {\n                 visit::walk_expr(self, ex)\n             }\n@@ -1582,4 +1599,39 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         walk_list!(self, visit_ty, &l.ty);\n         walk_list!(self, visit_expr, &l.init);\n     }\n+\n+    fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n+        match item.node {\n+            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+                if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n+                    down_cast_data!(fn_data, FunctionData, item.span);\n+                    if !self.span.filter_generated(Some(fn_data.span), item.span) {\n+                        self.dumper.function(fn_data.clone().lower(self.tcx));\n+                    }\n+\n+                    self.nest_tables(item.id, |v| v.process_formals(&decl.inputs,\n+                                                                    &fn_data.qualname));\n+                    self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n+                }\n+\n+                for arg in &decl.inputs {\n+                    self.visit_ty(&arg.ty);\n+                }\n+\n+                if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n+                    self.visit_ty(&ret_ty);\n+                }\n+            }\n+            ast::ForeignItemKind::Static(ref ty, _) => {\n+                if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n+                    down_cast_data!(var_data, VariableData, item.span);\n+                    if !self.span.filter_generated(Some(var_data.span), item.span) {\n+                        self.dumper.variable(var_data.lower(self.tcx));\n+                    }\n+                }\n+\n+                self.visit_ty(ty);\n+            }\n+        }\n+    }\n }"}, {"sha": "44615071a56a71eb87e495b03b3907ddb91bcc30", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -120,6 +120,50 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         result\n     }\n \n+    pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n+        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        match item.node {\n+            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::FunctionData(FunctionData {\n+                    id: item.id,\n+                    name: item.ident.to_string(),\n+                    qualname: qualname,\n+                    declaration: None,\n+                    span: sub_span.unwrap(),\n+                    scope: self.enclosing_scope(item.id),\n+                    value: make_signature(decl, generics),\n+                    visibility: From::from(&item.vis),\n+                    parent: None,\n+                    docs: docs_for_attrs(&item.attrs),\n+                    sig: self.sig_base_extern(item),\n+                    attributes: item.attrs.clone(),\n+                }))\n+            }\n+            ast::ForeignItemKind::Static(ref ty, m) => {\n+                let keyword = if m { keywords::Mut } else { keywords::Static };\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::VariableData(VariableData {\n+                    id: item.id,\n+                    kind: VariableKind::Static,\n+                    name: item.ident.to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.enclosing_scope(item.id),\n+                    parent: None,\n+                    value: String::new(),\n+                    type_value: ty_to_string(ty),\n+                    visibility: From::from(&item.vis),\n+                    docs: docs_for_attrs(&item.attrs),\n+                    sig: Some(self.sig_base_extern(item)),\n+                    attributes: item.attrs.clone(),\n+                }))\n+            }\n+        }\n+    }\n+\n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n@@ -751,6 +795,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    fn sig_base_extern(&self, item: &ast::ForeignItem) -> Signature {\n+        let text = self.span_utils.signature_string_for_span(item.span);\n+        let name = item.ident.to_string();\n+        let ident_start = text.find(&name).expect(\"Name not in signature?\");\n+        let ident_end = ident_start + name.len();\n+        Signature {\n+            span: Span { hi: item.span.lo + BytePos(text.len() as u32), ..item.span },\n+            text: text,\n+            ident_start: ident_start,\n+            ident_end: ident_end,\n+            defs: vec![],\n+            refs: vec![],\n+        }\n+    }\n+\n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n         self.tcx.hir.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)"}, {"sha": "63cfe591ce366b6fefdd6367de221f214f12610d", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -32,8 +32,7 @@ use syntax::ast;\n \n use {ModuleSource, ModuleTranslation};\n \n-const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n@@ -62,9 +61,9 @@ struct AssertModuleSource<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let disposition = if attr.check_name(PARTITION_REUSED) {\n+        let disposition = if attr.check_name(ATTR_PARTITION_REUSED) {\n             Disposition::Reused\n-        } else if attr.check_name(PARTITION_TRANSLATED) {\n+        } else if attr.check_name(ATTR_PARTITION_TRANSLATED) {\n             Disposition::Translated\n         } else {\n             return;"}, {"sha": "12a1ffa2767255aa325b6f3eff380d6fad49ca44", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -734,9 +734,10 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n+        let mut linker = trans.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n                   objects, out_filename, outputs, trans);\n+        cmd = linker.finalize();\n     }\n     cmd.args(&sess.target.target.options.late_link_args);\n     for obj in &sess.target.target.options.post_link_objects {\n@@ -1021,38 +1022,18 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         }\n     });\n \n-    let pair = sess.cstore.used_libraries().into_iter().filter(|l| {\n+    let relevant_libs = sess.cstore.used_libraries().into_iter().filter(|l| {\n         relevant_lib(sess, l)\n-    }).partition(|lib| {\n-        lib.kind == NativeLibraryKind::NativeStatic\n     });\n-    let (staticlibs, others): (Vec<_>, Vec<_>) = pair;\n-\n-    // Some platforms take hints about whether a library is static or dynamic.\n-    // For those that support this, we ensure we pass the option if the library\n-    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n-    // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    cmd.hint_static();\n \n     let search_path = archive_search_paths(sess);\n-    for l in staticlibs {\n-        // Here we explicitly ask that the entire archive is included into the\n-        // result artifact. For more details see #15460, but the gist is that\n-        // the linker will strip away any unused objects in the archive if we\n-        // don't otherwise explicitly reference them. This can occur for\n-        // libraries which are just providing bindings, libraries with generic\n-        // functions, etc.\n-        cmd.link_whole_staticlib(&l.name.as_str(), &search_path);\n-    }\n-\n-    cmd.hint_dynamic();\n-\n-    for lib in others {\n+    for lib in relevant_libs {\n         match lib.kind {\n             NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n             NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n             NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&lib.name.as_str()),\n-            NativeLibraryKind::NativeStatic => bug!(),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&lib.name.as_str(),\n+                                                                        &search_path)\n         }\n     }\n }"}, {"sha": "a178d17a7c2d371f01e17ce87fc7cd22a41efab7", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LinkerInfo {\n     }\n \n     pub fn to_linker(&'a self,\n-                     cmd: &'a mut Command,\n+                     cmd: Command,\n                      sess: &'a Session) -> Box<Linker+'a> {\n         if sess.target.target.options.is_like_msvc {\n             Box::new(MsvcLinker {\n@@ -61,7 +61,8 @@ impl<'a, 'tcx> LinkerInfo {\n             Box::new(GnuLinker {\n                 cmd: cmd,\n                 sess: sess,\n-                info: self\n+                info: self,\n+                hinted_static: false,\n             }) as Box<Linker>\n         }\n     }\n@@ -93,30 +94,49 @@ pub trait Linker {\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n     fn args(&mut self, args: &[String]);\n-    fn hint_static(&mut self);\n-    fn hint_dynamic(&mut self);\n-    fn whole_archives(&mut self);\n-    fn no_whole_archives(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n+    // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n+    fn finalize(&mut self) -> Command;\n }\n \n pub struct GnuLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo\n+    info: &'a LinkerInfo,\n+    hinted_static: bool, // Keeps track of the current hinting mode.\n }\n \n impl<'a> GnuLinker<'a> {\n     fn takes_hints(&self) -> bool {\n         !self.sess.target.target.options.is_like_osx\n     }\n+\n+    // Some platforms take hints about whether a library is static or dynamic.\n+    // For those that support this, we ensure we pass the option if the library\n+    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n+    // libfoo.a and libfoo.so both exist that the right one is chosen.\n+    fn hint_static(&mut self) {\n+        if !self.takes_hints() { return }\n+        if !self.hinted_static {\n+            self.cmd.arg(\"-Wl,-Bstatic\");\n+            self.hinted_static = true;\n+        }\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if !self.takes_hints() { return }\n+        if self.hinted_static {\n+            self.cmd.arg(\"-Wl,-Bdynamic\");\n+            self.hinted_static = false;\n+        }\n+    }\n }\n \n impl<'a> Linker for GnuLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n-    fn link_staticlib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n-    fn link_rlib(&mut self, lib: &Path) { self.cmd.arg(lib); }\n+    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_staticlib(&mut self, lib: &str) { self.hint_static(); self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n     fn framework_path(&mut self, path: &Path) { self.cmd.arg(\"-F\").arg(path); }\n     fn output_filename(&mut self, path: &Path) { self.cmd.arg(\"-o\").arg(path); }\n@@ -125,14 +145,23 @@ impl<'a> Linker for GnuLinker<'a> {\n     fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+        self.hint_dynamic();\n         self.cmd.arg(\"-l\").arg(lib);\n     }\n \n     fn link_framework(&mut self, framework: &str) {\n+        self.hint_dynamic();\n         self.cmd.arg(\"-framework\").arg(framework);\n     }\n \n+    // Here we explicitly ask that the entire archive is included into the\n+    // result artifact. For more details see #15460, but the gist is that\n+    // the linker will strip away any unused objects in the archive if we\n+    // don't otherwise explicitly reference them. This can occur for\n+    // libraries which are just providing bindings, libraries with generic\n+    // functions, etc.\n     fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]) {\n+        self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n             self.cmd.arg(\"-Wl,--whole-archive\")\n@@ -148,6 +177,7 @@ impl<'a> Linker for GnuLinker<'a> {\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n         if self.sess.target.target.options.is_like_osx {\n             let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(lib);\n@@ -228,26 +258,6 @@ impl<'a> Linker for GnuLinker<'a> {\n         }\n     }\n \n-    fn whole_archives(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,--whole-archive\");\n-    }\n-\n-    fn no_whole_archives(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,--no-whole-archive\");\n-    }\n-\n-    fn hint_static(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,-Bstatic\");\n-    }\n-\n-    fn hint_dynamic(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,-Bdynamic\");\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // If we're compiling a dylib, then we let symbol visibility in object\n         // files to take care of whether they're exported or not.\n@@ -311,10 +321,17 @@ impl<'a> Linker for GnuLinker<'a> {\n     fn subsystem(&mut self, subsystem: &str) {\n         self.cmd.arg(&format!(\"-Wl,--subsystem,{}\", subsystem));\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        self.hint_dynamic(); // Reset to default before returning the composed command line.\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n     info: &'a LinkerInfo\n }\n@@ -416,22 +433,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(\"/DEBUG\");\n     }\n \n-    fn whole_archives(&mut self) {\n-        // hints not supported?\n-    }\n-    fn no_whole_archives(&mut self) {\n-        // hints not supported?\n-    }\n-\n-    // On windows static libraries are of the form `foo.lib` and dynamic\n-    // libraries are not linked against directly, but rather through their\n-    // import libraries also called `foo.lib`. As a result there's no\n-    // possibility for a native library to appear both dynamically and\n-    // statically in the same folder so we don't have to worry about hints like\n-    // we do on Unix platforms.\n-    fn hint_static(&mut self) {}\n-    fn hint_dynamic(&mut self) {}\n-\n     // Currently the compiler doesn't use `dllexport` (an LLVM attribute) to\n     // export symbols from a dynamic library. When building a dynamic library,\n     // however, we're going to want some symbols exported, so this function\n@@ -492,10 +493,16 @@ impl<'a> Linker for MsvcLinker<'a> {\n             self.cmd.arg(\"/ENTRY:mainCRTStartup\");\n         }\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n pub struct EmLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n     info: &'a LinkerInfo\n }\n@@ -591,22 +598,6 @@ impl<'a> Linker for EmLinker<'a> {\n         bug!(\"building dynamic library is unsupported on Emscripten\")\n     }\n \n-    fn whole_archives(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_whole_archives(&mut self) {\n-        // noop\n-    }\n-\n-    fn hint_static(&mut self) {\n-        // noop\n-    }\n-\n-    fn hint_dynamic(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -640,6 +631,12 @@ impl<'a> Linker for EmLinker<'a> {\n     fn subsystem(&mut self, _subsystem: &str) {\n         // noop\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n fn exported_symbols(scx: &SharedCrateContext,"}, {"sha": "d204703b775983ec2b74f60407e796373cf357d7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -50,7 +50,7 @@ use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_u64, C_undef};\n+use common::{C_struct_in_context, C_u64, C_undef, C_array};\n use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -1187,6 +1187,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             }\n \n+            // Create the llvm.used variable\n+            // This variable has type [N x i8*] and is stored in the llvm.metadata section\n+            if !ccx.used_statics().borrow().is_empty() {\n+                let name = CString::new(\"llvm.used\").unwrap();\n+                let section = CString::new(\"llvm.metadata\").unwrap();\n+                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics().borrow());\n+\n+                unsafe {\n+                    let g = llvm::LLVMAddGlobal(ccx.llmod(),\n+                                                val_ty(array).to_ref(),\n+                                                name.as_ptr());\n+                    llvm::LLVMSetInitializer(g, array);\n+                    llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n+                    llvm::LLVMSetSection(g, section.as_ptr());\n+                }\n+            }\n+\n             // Finalize debuginfo\n             if ccx.sess().opts.debuginfo != NoDebugInfo {\n                 debuginfo::finalize(&ccx);"}, {"sha": "daf1a1ba95f9a175991e2877cf2c9e4d2b0d889e", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -276,6 +276,12 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         base::set_link_section(ccx, g, attrs);\n \n+        if attr::contains_name(attrs, \"used\") {\n+            // This static will be stored in the llvm.used variable which is an array of i8*\n+            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(ccx).to_ref());\n+            ccx.used_statics().borrow_mut().push(cast);\n+        }\n+\n         Ok(g)\n     }\n }"}, {"sha": "afb94f546abe894aeb9e001a8545e2bc51915803", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -132,6 +132,10 @@ pub struct LocalCrateContext<'tcx> {\n     /// to constants.)\n     statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n+    /// Statics that will be placed in the llvm.used variable\n+    /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n+    used_statics: RefCell<Vec<ValueRef>>,\n+\n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n     llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n     type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n@@ -587,6 +591,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 impl_method_cache: RefCell::new(FxHashMap()),\n                 closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n+                used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n                 llsizingtypes: RefCell::new(FxHashMap()),\n                 type_hashcodes: RefCell::new(FxHashMap()),\n@@ -754,6 +759,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().statics_to_rauw\n     }\n \n+    pub fn used_statics<'a>(&'a self) -> &'a RefCell<Vec<ValueRef>> {\n+        &self.local().used_statics\n+    }\n+\n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().lltypes\n     }"}, {"sha": "d69f31a45048d48721e669e0c9af3cfcd56bb18d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -762,7 +762,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n             let slot = bcx.alloca(llretty, \"personalityslot\");\n             self.llpersonalityslot = Some(slot);\n-            Lifetime::Start.call(bcx, slot);\n             slot\n         }\n     }\n@@ -794,6 +793,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n+        Lifetime::Start.call(&bcx, slot);\n         bcx.store(llretval, slot, None);\n         bcx.br(target_bb);\n         bcx.llbb()"}, {"sha": "4b975d7b324f99c492ef96ab3d2a448db289fadf", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -196,19 +196,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                                     let field_ty = field.ty(tcx, substs);\n \n-                                    if self.is_fn_ty(&field_ty, span) {\n-                                        err.help(&format!(\"use `({0}.{1})(...)` if you \\\n-                                                           meant to call the function \\\n-                                                           stored in the `{1}` field\",\n-                                                          expr_string,\n-                                                          item_name));\n+                                    if tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                                        if self.is_fn_ty(&field_ty, span) {\n+                                            err.help(&format!(\"use `({0}.{1})(...)` if you \\\n+                                                               meant to call the function \\\n+                                                               stored in the `{1}` field\",\n+                                                              expr_string,\n+                                                              item_name));\n+                                        } else {\n+                                            err.help(&format!(\"did you mean to write `{0}.{1}` \\\n+                                                               instead of `{0}.{1}(...)`?\",\n+                                                              expr_string,\n+                                                              item_name));\n+                                        }\n+                                        err.span_label(span, &\"field, not a method\");\n                                     } else {\n-                                        err.help(&format!(\"did you mean to write `{0}.{1}` \\\n-                                                           instead of `{0}.{1}(...)`?\",\n-                                                          expr_string,\n-                                                          item_name));\n+                                        err.span_label(span, &\"private field, not a method\");\n                                     }\n-                                    err.span_label(span, &\"field, not a method\");\n                                     break;\n                                 }\n                             }"}, {"sha": "c995b7e92843dd1707b5639e77144e02fa8b1c60", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -3884,7 +3884,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           element_ty\n                       }\n                       None => {\n-                          self.check_expr_has_type(&idx, self.tcx.types.err);\n                           let mut err = self.type_error_struct(\n                               expr.span,\n                               |actual| {"}, {"sha": "cc33bd8754d9ed1c59caf83c37b1a4979a02b5c4", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -184,9 +184,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // particularly for things like `String + &String`.\n         let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n-        let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                                    Symbol::intern(name), trait_def_id,\n-                                                    lhs_expr) {\n+        let return_ty = self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n+                                              Symbol::intern(name), trait_def_id,\n+                                              lhs_expr);\n+\n+        // see `NB` above\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+\n+        let return_ty = match return_ty {\n             Ok(return_ty) => return_ty,\n             Err(()) => {\n                 // error types are considered \"builtin\"\n@@ -209,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n                             if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty_var],\n+                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty],\n                                     Symbol::intern(name), trait_def_id,\n                                     lhs_expr).is_ok() {\n                                 err.note(\n@@ -240,7 +245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(missing_trait) = missing_trait {\n                             if missing_trait == \"std::ops::Add\" &&\n                                 self.check_str_addition(expr, lhs_expr, lhs_ty,\n-                                                         rhs_expr, rhs_ty_var, &mut err) {\n+                                                         rhs_expr, rhs_ty, &mut err) {\n                                 // This has nothing here because it means we did string\n                                 // concatenation (e.g. \"Hello \" + \"World!\"). This means\n                                 // we don't want the note in the else clause to be emitted\n@@ -257,9 +262,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        // see `NB` above\n-        self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n-\n         (rhs_ty_var, return_ty)\n     }\n \n@@ -268,12 +270,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           lhs_expr: &'gcx hir::Expr,\n                           lhs_ty: Ty<'tcx>,\n                           rhs_expr: &'gcx hir::Expr,\n-                          rhs_ty_var: Ty<'tcx>,\n+                          rhs_ty: Ty<'tcx>,\n                           mut err: &mut errors::DiagnosticBuilder) -> bool {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         let mut is_string_addition = false;\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n         if let TyRef(_, l_ty) = lhs_ty.sty {\n             if let TyRef(_, r_ty) = rhs_ty.sty {\n                 if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr {"}, {"sha": "33280fb931aafebb0fd7431e6fb09d69ffb20adf", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -11,7 +11,6 @@\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::lint;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt};\n \n@@ -53,12 +52,16 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n+                    struct_span_err!(self.tcx.sess,\n+                                     self.tcx.span_of_impl(item1).unwrap(),\n+                                     E0592,\n+                                     \"duplicate definitions with name `{}`\",\n+                                     name)\n+                        .span_label(self.tcx.span_of_impl(item1).unwrap(),\n+                                    &format!(\"duplicate definitions for `{}`\", name))\n+                        .span_label(self.tcx.span_of_impl(item2).unwrap(),\n+                                    &format!(\"other definition for `{}`\", name))\n+                        .emit();\n                 }\n             }\n         }"}, {"sha": "1e687d63f58755d732d1e71878c4ca45262d90df", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 273, "deletions": 330, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -16,17 +16,18 @@\n //! of `fmt::Display`. Example usage:\n //!\n //! ```rust,ignore\n-//! use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle};\n+//! use rustdoc::html::markdown::Markdown;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, MarkdownOutputStyle::Fancy));\n+//! let html = format!(\"{}\", Markdown(s));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n+use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::str;\n@@ -36,43 +37,23 @@ use syntax::codemap::Span;\n use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n-use html::escape::Escape;\n use test;\n \n-use pulldown_cmark::{self, Event, Parser, Tag};\n-\n-#[derive(Copy, Clone)]\n-pub enum MarkdownOutputStyle {\n-    Compact,\n-    Fancy,\n-}\n-\n-impl MarkdownOutputStyle {\n-    pub fn is_compact(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Compact => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_fancy(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Fancy => true,\n-            _ => false,\n-        }\n-    }\n-}\n+use pulldown_cmark::{html, Event, Tag, Parser};\n+use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n \n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str, pub MarkdownOutputStyle);\n+pub struct Markdown<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n+/// A unit struct like `Markdown`, that renders only the first paragraph.\n+pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n@@ -89,12 +70,21 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-/// Returns a new string with all consecutive whitespace collapsed into\n-/// single spaces.\n+/// Convert chars from a title for an id.\n ///\n-/// Any leading or trailing whitespace will be trimmed.\n-fn collapse_whitespace(s: &str) -> String {\n-    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n+/// \"Hello, world!\" -> \"hello-world\"\n+fn slugify(c: char) -> Option<char> {\n+    if c.is_alphanumeric() || c == '-' || c == '_' {\n+        if c.is_ascii() {\n+            Some(c.to_ascii_lowercase())\n+        } else {\n+            Some(c)\n+        }\n+    } else if c.is_whitespace() && c.is_ascii() {\n+        Some('-')\n+    } else {\n+        None\n+    }\n }\n \n // Information about the playground if a URL has been specified, containing an\n@@ -103,72 +93,50 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n-macro_rules! event_loop_break {\n-    ($parser:expr, $toc_builder:expr, $shorter:expr, $buf:expr, $escape:expr, $id:expr,\n-     $($end_event:pat)|*) => {{\n-        fn inner(id: &mut Option<&mut String>, s: &str) {\n-            if let Some(ref mut id) = *id {\n-                id.push_str(s);\n-            }\n+/// Adds syntax highlighting and playground Run buttons to rust code blocks.\n+struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+}\n+\n+impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n+    fn new(iter: I) -> Self {\n+        CodeBlocks {\n+            inner: iter,\n         }\n-        while let Some(event) = $parser.next() {\n-            match event {\n-                $($end_event)|* => break,\n-                Event::Text(ref s) => {\n-                    inner($id, s);\n-                    if $escape {\n-                        $buf.push_str(&format!(\"{}\", Escape(s)));\n-                    } else {\n-                        $buf.push_str(s);\n-                    }\n-                }\n-                Event::SoftBreak | Event::HardBreak if !$buf.is_empty() => {\n-                    $buf.push(' ');\n-                }\n-                x => {\n-                    looper($parser, &mut $buf, Some(x), $toc_builder, $shorter, $id);\n-                }\n+    }\n+}\n+\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n+            if !LangString::parse(&lang).rust {\n+                return Some(Event::Start(Tag::CodeBlock(lang)));\n             }\n+        } else {\n+            return event;\n         }\n-    }}\n-}\n \n-pub fn render(w: &mut fmt::Formatter,\n-              s: &str,\n-              print_toc: bool,\n-              shorter: MarkdownOutputStyle) -> fmt::Result {\n-    fn code_block(parser: &mut Parser, buffer: &mut String, lang: &str) {\n         let mut origtext = String::new();\n-        while let Some(event) = parser.next() {\n+        for event in &mut self.inner {\n             match event {\n-                Event::End(Tag::CodeBlock(_)) => break,\n+                Event::End(Tag::CodeBlock(..)) => break,\n                 Event::Text(ref s) => {\n                     origtext.push_str(s);\n                 }\n                 _ => {}\n             }\n         }\n-        let origtext = origtext.trim_left();\n-        debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n-\n         let lines = origtext.lines().filter(|l| {\n             stripped_filtered_line(*l).is_none()\n         });\n         let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-        let block_info = if lang.is_empty() {\n-            LangString::all_false()\n-        } else {\n-            LangString::parse(lang)\n-        };\n-        if !block_info.rust {\n-            buffer.push_str(&format!(\"<pre><code class=\\\"language-{}\\\">{}</code></pre>\",\n-                            lang, text));\n-            return\n-        }\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n-            buffer.push('\\n');\n+            let mut s = String::from(\"\\n\");\n             let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n                 if url.is_empty() {\n                     return None;\n@@ -178,7 +146,7 @@ pub fn render(w: &mut fmt::Formatter,\n                 }).collect::<Vec<&str>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let test = test::maketest(&test, krate, false,\n-                                          &Default::default());\n+                                        &Default::default());\n                 let channel = if test.contains(\"#![feature(\") {\n                     \"&amp;version=nightly\"\n                 } else {\n@@ -207,271 +175,186 @@ pub fn render(w: &mut fmt::Formatter,\n                     url, test_escaped, channel\n                 ))\n             });\n-            buffer.push_str(&highlight::render_with_highlighting(\n-                            &text,\n-                            Some(\"rust-example-rendered\"),\n-                            None,\n-                            playground_button.as_ref().map(String::as_str)));\n-        });\n-    }\n-\n-    fn heading(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-               shorter: MarkdownOutputStyle, level: i32) {\n-        let mut ret = String::new();\n-        let mut id = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, ret, true, &mut Some(&mut id),\n-                          Event::End(Tag::Header(_)));\n-        ret = ret.trim_right().to_owned();\n-\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n-            } else {\n-                None\n-            }\n-        }).collect::<String>();\n-\n-        let id = derive_id(id);\n-\n-        let sec = toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, ret.clone(), id.clone()))\n-        });\n-\n-        // Render the HTML\n-        buffer.push_str(&format!(\"<h{lvl} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n-                                  <a href=\\\"#{id}\\\">{sec}{}</a></h{lvl}>\",\n-                                 ret, lvl = level, id = id, sec = sec));\n-    }\n-\n-    fn inline_code(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                   shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id, Event::End(Tag::Code));\n-        buffer.push_str(&format!(\"<code>{}</code>\",\n-                                 Escape(&collapse_whitespace(content.trim_right()))));\n+            s.push_str(&highlight::render_with_highlighting(\n+                        &text,\n+                        Some(\"rust-example-rendered\"),\n+                        None,\n+                        playground_button.as_ref().map(String::as_str)));\n+            Some(Event::Html(s.into()))\n+        })\n     }\n+}\n \n-    fn link(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, url: &str, mut title: String,\n-            id: &mut Option<&mut String>) {\n-        event_loop_break!(parser, toc_builder, shorter, title, true, id,\n-                          Event::End(Tag::Link(_, _)));\n-        buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n-    }\n+/// Make headings links with anchor ids and build up TOC.\n+struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    toc: Option<&'b mut TocBuilder>,\n+    buf: VecDeque<Event<'a>>,\n+}\n \n-    fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Paragraph));\n-        buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+        HeadingLinks {\n+            inner: iter,\n+            toc: toc,\n+            buf: VecDeque::new(),\n+        }\n     }\n+}\n \n-    fn table_cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::TableHead) |\n-                              Event::End(Tag::Table(_)) |\n-                              Event::End(Tag::TableRow) |\n-                              Event::End(Tag::TableCell));\n-        buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n-    }\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+    type Item = Event<'a>;\n \n-    fn table_row(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) |\n-                    Event::End(Tag::Table(_)) |\n-                    Event::End(Tag::TableRow) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(e) = self.buf.pop_front() {\n+            return Some(e);\n         }\n-        buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n-    }\n \n-    fn table_head(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::Header(level))) = event {\n+            let mut id = String::new();\n+            for event in &mut self.inner {\n+                match event {\n+                    Event::End(Tag::Header(..)) => break,\n+                    Event::Text(ref text) => id.extend(text.chars().filter_map(slugify)),\n+                    _ => {},\n                 }\n+                self.buf.push_back(event);\n             }\n-        }\n-        if !content.is_empty() {\n-            buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n-        }\n-    }\n+            let id = derive_id(id);\n \n-    fn table(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-             shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        let mut rows = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableHead) => {\n-                    table_head(parser, &mut content, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::TableRow) => {\n-                    table_row(parser, &mut rows, toc_builder, shorter);\n-                }\n-                _ => {}\n+            if let Some(ref mut builder) = self.toc {\n+                let mut html_header = String::new();\n+                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                let sec = builder.push(level as u32, html_header, id.clone());\n+                self.buf.push_front(Event::InlineHtml(format!(\"{} \", sec).into()));\n             }\n+\n+            self.buf.push_back(Event::InlineHtml(format!(\"</a></h{}>\", level).into()));\n+\n+            let start_tags = format!(\"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                                      <a href=\\\"#{id}\\\">\",\n+                                     id = id,\n+                                     level = level);\n+            return Some(Event::InlineHtml(start_tags.into()));\n         }\n-        buffer.push_str(&format!(\"<table>{}{}</table>\",\n-                                 content,\n-                                 if shorter.is_compact() || rows.is_empty() {\n-                                     String::new()\n-                                 } else {\n-                                     format!(\"<tbody>{}</tbody>\", rows)\n-                                 }));\n+        event\n     }\n+}\n \n-    fn blockquote(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::BlockQuote));\n-        buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n-    }\n+/// Extracts just the first paragraph.\n+struct SummaryLine<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    started: bool,\n+    depth: u32,\n+}\n \n-    fn list_item(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Item) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(&format!(\"{}\", Escape(s)));\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n+impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n+    fn new(iter: I) -> Self {\n+        SummaryLine {\n+            inner: iter,\n+            started: false,\n+            depth: 0,\n         }\n-        buffer.push_str(&format!(\"<li>{}</li>\", content));\n     }\n+}\n \n-    fn list(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle) {\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::List(_)) => break,\n-                Event::Start(Tag::Item) => {\n-                    list_item(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.started && self.depth == 0 {\n+            return None;\n+        }\n+        if !self.started {\n+            self.started = true;\n         }\n-        buffer.push_str(&format!(\"<ul>{}</ul>\", content));\n+        let event = self.inner.next();\n+        match event {\n+            Some(Event::Start(..)) => self.depth += 1,\n+            Some(Event::End(..)) => self.depth -= 1,\n+            _ => {}\n+        }\n+        event\n     }\n+}\n \n-    fn emphasis(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Emphasis));\n-        buffer.push_str(&format!(\"<em>{}</em>\", content));\n-    }\n+/// Moves all footnote definitions to the end and add back links to the\n+/// references.\n+struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    footnotes: HashMap<String, (Vec<Event<'a>>, u16)>,\n+}\n \n-    fn strong(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-              shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Strong));\n-        buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n+impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+    fn new(iter: I) -> Self {\n+        Footnotes {\n+            inner: iter,\n+            footnotes: HashMap::new(),\n+        }\n     }\n+    fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n+        let new_id = self.footnotes.keys().count() + 1;\n+        let key = key.to_owned();\n+        self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n+    }\n+}\n \n-    fn looper<'a>(parser: &'a mut Parser, buffer: &mut String, next_event: Option<Event<'a>>,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                  id: &mut Option<&mut String>) -> bool {\n-        if let Some(event) = next_event {\n-            match event {\n-                Event::Start(Tag::CodeBlock(lang)) => {\n-                    code_block(parser, buffer, &*lang);\n-                }\n-                Event::Start(Tag::Header(level)) => {\n-                    heading(parser, buffer, toc_builder, shorter, level);\n-                }\n-                Event::Start(Tag::Code) => {\n-                    inline_code(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Paragraph) => {\n-                    paragraph(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Link(ref url, ref t)) => {\n-                    link(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n-                }\n-                Event::Start(Tag::Table(_)) => {\n-                    table(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::BlockQuote) => {\n-                    blockquote(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::List(_)) => {\n-                    list(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::Emphasis) => {\n-                    emphasis(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Strong) => {\n-                    strong(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Html(h) | Event::InlineHtml(h) => {\n-                    buffer.push_str(&*h);\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.inner.next() {\n+                Some(Event::FootnoteReference(ref reference)) => {\n+                    let entry = self.get_entry(&reference);\n+                    let reference = format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}\\\n+                                             </a></sup>\",\n+                                            (*entry).1);\n+                    return Some(Event::Html(reference.into()));\n+                }\n+                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                    let mut content = Vec::new();\n+                    for event in &mut self.inner {\n+                        if let Event::End(Tag::FootnoteDefinition(..)) = event {\n+                            break;\n+                        }\n+                        content.push(event);\n+                    }\n+                    let entry = self.get_entry(&def);\n+                    (*entry).0 = content;\n+                }\n+                Some(e) => return Some(e),\n+                None => {\n+                    if !self.footnotes.is_empty() {\n+                        let mut v: Vec<_> = self.footnotes.drain().map(|(_, x)| x).collect();\n+                        v.sort_by(|a, b| a.1.cmp(&b.1));\n+                        let mut ret = String::from(\"<div class=\\\"footnotes\\\"><hr><ol>\");\n+                        for (mut content, id) in v {\n+                            write!(ret, \"<li id=\\\"ref{}\\\">\", id).unwrap();\n+                            let mut is_paragraph = false;\n+                            if let Some(&Event::End(Tag::Paragraph)) = content.last() {\n+                                content.pop();\n+                                is_paragraph = true;\n+                            }\n+                            html::push_html(&mut ret, content.into_iter());\n+                            write!(ret,\n+                                   \"&nbsp;<a href=\\\"#supref{}\\\" rev=\\\"footnote\\\">\u21a9</a>\",\n+                                   id).unwrap();\n+                            if is_paragraph {\n+                                ret.push_str(\"</p>\");\n+                            }\n+                            ret.push_str(\"</li>\");\n+                        }\n+                        ret.push_str(\"</ol></div>\");\n+                        return Some(Event::Html(ret.into()));\n+                    } else {\n+                        return None;\n+                    }\n                 }\n-                _ => {}\n             }\n-            shorter.is_fancy()\n-        } else {\n-            false\n         }\n     }\n-\n-    let mut toc_builder = if print_toc {\n-        Some(TocBuilder::new())\n-    } else {\n-        None\n-    };\n-    let mut buffer = String::new();\n-    let mut parser = Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES);\n-    loop {\n-        let next_event = parser.next();\n-        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter, &mut None) {\n-            break\n-        }\n-    }\n-    let mut ret = toc_builder.map_or(Ok(()), |builder| {\n-        write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n-    });\n-\n-    if ret.is_ok() {\n-        ret = w.write_str(&buffer);\n-    }\n-    ret\n }\n \n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n@@ -618,17 +501,45 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, shorter) = *self;\n+        let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, shorter)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        let mut toc = TocBuilder::new();\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+\n+        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -637,7 +548,41 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        // Treat inline HTML as plain text.\n+        let p = p.map(|event| match event {\n+            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+            _ => event\n+        });\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n+    }\n+}\n+\n+impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownSummaryLine(md) = *self;\n+        // This is actually common enough to special-case\n+        if md.is_empty() { return Ok(()) }\n+\n+        let p = Parser::new(md);\n+\n+        let mut s = String::new();\n+\n+        html::push_html(&mut s, SummaryLine::new(p));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -659,14 +604,10 @@ pub fn plain_summary_line(md: &str) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Link(_, ref t)) if !self.is_first => {\n-                    (Some(t.as_ref().to_owned()), 1)\n-                }\n                 Event::Start(Tag::Code) => (Some(\"`\".to_owned()), 1),\n                 Event::End(Tag::Code) => (Some(\"`\".to_owned()), -1),\n                 Event::Start(Tag::Header(_)) => (None, 1),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                Event::End(Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n                 Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n                 _ => (None, 0),\n             };\n@@ -697,7 +638,7 @@ pub fn plain_summary_line(md: &str) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+    use super::{LangString, Markdown, MarkdownHtml};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -737,14 +678,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown, MarkdownOutputStyle::Fancy));\n+        format!(\"{}\", Markdown(markdown));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n@@ -766,7 +707,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -797,6 +738,7 @@ mod tests {\n         }\n \n         t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n+        t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n         t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n         t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n         t(\"# top header\", \"top header\");\n@@ -810,7 +752,8 @@ mod tests {\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\");\n+        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n+        t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n+        t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n     }\n }"}, {"sha": "1e1202f04005cdd3ccdb0b3b15b484c39b868b1e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1651,7 +1651,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&markdown, MarkdownOutputStyle::Fancy))?;\n+               Markdown(&markdown))?;\n     }\n     Ok(())\n }\n@@ -1684,8 +1684,7 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s),\n-                                 MarkdownOutputStyle::Fancy))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n     Ok(())\n }\n@@ -1873,8 +1872,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value,\n-                                                     MarkdownOutputStyle::Compact).to_string())),\n+                       docs = MarkdownSummaryLine(doc_value),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2904,7 +2902,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, MarkdownOutputStyle::Fancy))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n "}, {"sha": "5fadda030a4b41c5bc7798375ae6848694a3dbba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, MarkdownOutputStyle, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -96,7 +96,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text, MarkdownOutputStyle::Fancy))\n+        format!(\"{}\", Markdown(text))\n     };\n \n     let err = write!("}, {"sha": "59fef8d20271bf83e23d8122406f93a18a14feac", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -82,7 +82,7 @@ fn unindent(s: &str) -> String {\n     });\n \n     if !lines.is_empty() {\n-        let mut unindented = vec![ lines[0].trim().to_string() ];\n+        let mut unindented = vec![ lines[0].trim_left().to_string() ];\n         unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n             if line.chars().all(|c| c.is_whitespace()) {\n                 line.to_string()\n@@ -160,4 +160,15 @@ mod unindent_tests {\n         let r = unindent(&s);\n         assert_eq!(r, \"line1\\nline2\");\n     }\n+\n+    #[test]\n+    fn should_not_trim() {\n+        let s = \"\\t    line1  \\n\\t    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1  \\nline2\");\n+\n+        let s = \"    \\tline1  \\n    \\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1  \\nline2\");\n+    }\n }"}, {"sha": "b36253862094f4acf1c6aff41f1c89dd23193edb", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -9,6 +9,20 @@\n // except according to those terms.\n \n //! Operations on ASCII strings and characters.\n+//!\n+//! Most string operations in Rust act on UTF-8 strings. However, at times it\n+//! makes more sense to only consider the ASCII character set for a specific\n+//! operation.\n+//!\n+//! The [`AsciiExt`] trait provides methods that allow for character\n+//! operations that only act on the ASCII subset and leave non-ASCII characters\n+//! alone.\n+//!\n+//! The [`escape_default`] function provides an iterator over the bytes of an\n+//! escaped version of the character given.\n+//!\n+//! [`AsciiExt`]: trait.AsciiExt.html\n+//! [`escape_default`]: fn.escape_default.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -53,11 +67,11 @@ pub trait AsciiExt {\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let ascii = 'a';\n-    /// let utf8 = '\u2764';\n+    /// let non_ascii = '\u2764';\n     /// let int_ascii = 97;\n     ///\n     /// assert!(ascii.is_ascii());\n-    /// assert!(!utf8.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n     /// assert!(int_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -79,11 +93,11 @@ pub trait AsciiExt {\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let ascii = 'a';\n-    /// let utf8 = '\u2764';\n+    /// let non_ascii = '\u2764';\n     /// let int_ascii = 97;\n     ///\n     /// assert_eq!('A', ascii.to_ascii_uppercase());\n-    /// assert_eq!('\u2764', utf8.to_ascii_uppercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_uppercase());\n     /// assert_eq!(65, int_ascii.to_ascii_uppercase());\n     /// ```\n     ///\n@@ -108,11 +122,11 @@ pub trait AsciiExt {\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let ascii = 'A';\n-    /// let utf8 = '\u2764';\n+    /// let non_ascii = '\u2764';\n     /// let int_ascii = 65;\n     ///\n     /// assert_eq!('a', ascii.to_ascii_lowercase());\n-    /// assert_eq!('\u2764', utf8.to_ascii_lowercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_lowercase());\n     /// assert_eq!(97, int_ascii.to_ascii_lowercase());\n     /// ```\n     ///\n@@ -934,8 +948,12 @@ impl AsciiExt for char {\n     }\n }\n \n-/// An iterator over the escaped version of a byte, constructed via\n-/// `std::ascii::escape_default`.\n+/// An iterator over the escaped version of a byte.\n+///\n+/// This `struct` is created by the [`escape_default`] function. See its\n+/// documentation for more.\n+///\n+/// [`escape_default`]: fn.escape_default.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     range: Range<usize>,\n@@ -966,6 +984,38 @@ pub struct EscapeDefault {\n ///\n /// assert_eq!(b'\\\\', escaped.next().unwrap());\n /// assert_eq!(b't', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\r');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'r', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\n');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'n', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\'');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\'', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\"');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\"', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\\\');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\x9d');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'x', escaped.next().unwrap());\n+/// assert_eq!(b'9', escaped.next().unwrap());\n+/// assert_eq!(b'd', escaped.next().unwrap());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn escape_default(c: u8) -> EscapeDefault {"}, {"sha": "a06299eaefe0ad47ac8068c65747bb1396fdbd5d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -472,7 +472,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval, gap.into_bucket().into_table())\n+    (retkey, retval, gap.into_table())\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -485,14 +485,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut key: K,\n                                 mut val: V)\n                                 -> FullBucketMut<'a, K, V> {\n-    let start_index = bucket.index();\n     let size = bucket.table().size();\n-    // Save the *starting point*.\n-    let mut bucket = bucket.stash();\n+    let raw_capacity = bucket.table().capacity();\n     // There can be at most `size - dib` buckets to displace, because\n     // in the worst case, there are `size` elements and we already are\n     // `displacement` buckets away from the initial one.\n-    let idx_end = start_index + size - bucket.displacement();\n+    let idx_end = (bucket.index() + size - bucket.displacement()) % raw_capacity;\n+    // Save the *starting point*.\n+    let mut bucket = bucket.stash();\n \n     loop {\n         let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n@@ -568,11 +568,8 @@ impl<K, V, S> HashMap<K, V, S>\n     // The caller should ensure that invariants by Robin Hood Hashing hold\n     // and that there's space in the underlying table.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n-        // note that buckets.index() keeps increasing\n-        // even if the pointer wraps back to the first bucket.\n-        let limit_bucket = buckets.index() + raw_cap;\n+        let start_index = buckets.index();\n \n         loop {\n             // We don't need to compare hashes for value swap.\n@@ -585,7 +582,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n-            debug_assert!(buckets.index() < limit_bucket);\n+            debug_assert!(buckets.index() != start_index);\n         }\n     }\n }\n@@ -1244,24 +1241,25 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&K, &mut V) -> bool\n     {\n-        if self.table.capacity() == 0 || self.table.size() == 0 {\n+        if self.table.size() == 0 {\n             return;\n         }\n+        let mut elems_left = self.table.size();\n         let mut bucket = Bucket::head_bucket(&mut self.table);\n         bucket.prev();\n-        let tail = bucket.index();\n-        loop {\n+        let start_index = bucket.index();\n+        while elems_left != 0 {\n             bucket = match bucket.peek() {\n                 Full(mut full) => {\n+                    elems_left -= 1;\n                     let should_remove = {\n                         let (k, v) = full.read_mut();\n                         !f(k, v)\n                     };\n                     if should_remove {\n-                        let prev_idx = full.index();\n                         let prev_raw = full.raw();\n                         let (_, _, t) = pop_internal(full);\n-                        Bucket::new_from(prev_raw, prev_idx, t)\n+                        Bucket::new_from(prev_raw, t)\n                     } else {\n                         full.into_bucket()\n                     }\n@@ -1271,9 +1269,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 }\n             };\n             bucket.prev();  // reverse iteration\n-            if bucket.index() == tail {\n-                break;\n-            }\n+            debug_assert!(elems_left == 0 || bucket.index() != start_index);\n         }\n     }\n }"}, {"sha": "9623706548b322d32c9e2a887e92cf6dbedd810d", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 151, "deletions": 173, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -113,7 +113,7 @@ impl TaggedHashUintPtr {\n /// when the RawTable is created and is accessible with the `tag` and `set_tag`\n /// functions.\n pub struct RawTable<K, V> {\n-    capacity: usize,\n+    capacity_mask: usize,\n     size: usize,\n     hashes: TaggedHashUintPtr,\n \n@@ -125,10 +125,13 @@ pub struct RawTable<K, V> {\n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n+// An unsafe view of a RawTable bucket\n+// Valid indexes are within [0..table_capacity)\n pub struct RawBucket<K, V> {\n-    hash: *mut HashUint,\n+    hash_start: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n-    pair: *const (K, V),\n+    pair_start: *const (K, V),\n+    idx: usize,\n     _marker: marker::PhantomData<(K, V)>,\n }\n \n@@ -141,7 +144,6 @@ impl<K, V> Clone for RawBucket<K, V> {\n \n pub struct Bucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -154,13 +156,11 @@ impl<K, V, M: Copy> Clone for Bucket<K, V, M> {\n \n pub struct EmptyBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n pub struct FullBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -232,13 +232,17 @@ fn can_alias_safehash_as_hash() {\n     assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n }\n \n+// RawBucket methods are unsafe as it's possible to\n+// make a RawBucket point to invalid memory using safe code.\n impl<K, V> RawBucket<K, V> {\n-    unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n-        RawBucket {\n-            hash: self.hash.offset(count),\n-            pair: self.pair.offset(count),\n-            _marker: marker::PhantomData,\n-        }\n+    unsafe fn hash(&self) -> *mut HashUint {\n+        self.hash_start.offset(self.idx as isize)\n+    }\n+    unsafe fn pair(&self) -> *mut (K, V) {\n+        self.pair_start.offset(self.idx as isize) as *mut (K, V)\n+    }\n+    unsafe fn hash_pair(&self) -> (*mut HashUint, *mut (K, V)) {\n+        (self.hash(), self.pair())\n     }\n }\n \n@@ -258,7 +262,7 @@ impl<K, V, M> FullBucket<K, V, M> {\n     }\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// Get the raw bucket.\n     pub fn raw(&self) -> RawBucket<K, V> {\n@@ -280,7 +284,7 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n impl<K, V, M> Bucket<K, V, M> {\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// get the table.\n     pub fn into_table(self) -> M {\n@@ -331,12 +335,11 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n-    pub fn new_from(r: RawBucket<K, V>, i: usize, t: M)\n+    pub fn new_from(r: RawBucket<K, V>, t: M)\n         -> Bucket<K, V, M>\n     {\n         Bucket {\n             raw: r,\n-            idx: i,\n             table: t,\n         }\n     }\n@@ -346,18 +349,16 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         // This is an uncommon case though, so avoid it in release builds.\n         debug_assert!(table.capacity() > 0,\n                       \"Table should have capacity at this point\");\n-        let ib_index = ib_index & (table.capacity() - 1);\n+        let ib_index = ib_index & table.capacity_mask;\n         Bucket {\n-            raw: unsafe { table.first_bucket_raw().offset(ib_index as isize) },\n-            idx: ib_index,\n+            raw: table.raw_bucket_at(ib_index),\n             table: table,\n         }\n     }\n \n     pub fn first(table: M) -> Bucket<K, V, M> {\n         Bucket {\n-            raw: table.first_bucket_raw(),\n-            idx: 0,\n+            raw: table.raw_bucket_at(0),\n             table: table,\n         }\n     }\n@@ -401,48 +402,30 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n     /// the appropriate types to call most of the other functions in\n     /// this module.\n     pub fn peek(self) -> BucketState<K, V, M> {\n-        match unsafe { *self.raw.hash } {\n+        match unsafe { *self.raw.hash() } {\n             EMPTY_BUCKET => {\n                 Empty(EmptyBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n             _ => {\n                 Full(FullBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n         }\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the next slot.\n+    /// Modifies the bucket in place to make it point to the next slot.\n     pub fn next(&mut self) {\n-        self.idx += 1;\n-        let range = self.table.capacity();\n-        // This code is branchless thanks to a conditional move.\n-        let dist = if self.idx & (range - 1) == 0 {\n-            1 - range as isize\n-        } else {\n-            1\n-        };\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_add(1) & self.table.capacity_mask;\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the previous slot.\n+    /// Modifies the bucket in place to make it point to the previous slot.\n     pub fn prev(&mut self) {\n-        let range = self.table.capacity();\n-        let new_idx = self.idx.wrapping_sub(1) & (range - 1);\n-        let dist = (new_idx as isize).wrapping_sub(self.idx as isize);\n-        self.idx = new_idx;\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_sub(1) & self.table.capacity_mask;\n     }\n }\n \n@@ -458,15 +441,13 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     pub fn gap_peek(self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         let gap = EmptyBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: (),\n         };\n \n@@ -494,31 +475,29 @@ impl<K, V, M> EmptyBucket<K, V, M>\n     /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n     pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n-            *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.pair as *mut (K, V), (key, value));\n+            *self.raw.hash() = hash.inspect();\n+            ptr::write(self.raw.pair(), (key, value));\n \n             self.table.borrow_table_mut().size += 1;\n         }\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     /// Puts given key, remain value uninitialized.\n     /// It is only used for inplacement insertion.\n     pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n-        *self.raw.hash = hash.inspect();\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::write(&mut (*pair_mut).0, key);\n+        *self.raw.hash() = hash.inspect();\n+        let pair_ptr = self.raw.pair();\n+        ptr::write(&mut (*pair_ptr).0, key);\n \n         self.table.borrow_table_mut().size += 1;\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -536,7 +515,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -546,7 +524,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn stash(self) -> FullBucket<K, V, Self> {\n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self,\n         }\n     }\n@@ -560,17 +537,20 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx.wrapping_sub(self.hash().inspect() as usize)) & (self.table.capacity() - 1)\n+        (self.raw.idx.wrapping_sub(self.hash().inspect() as usize)) & self.table.capacity_mask\n     }\n \n     #[inline]\n     pub fn hash(&self) -> SafeHash {\n-        unsafe { SafeHash { hash: *self.raw.hash } }\n+        unsafe { SafeHash { hash: *self.raw.hash() } }\n     }\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -586,11 +566,10 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n         self.table.size -= 1;\n \n         unsafe {\n-            *self.raw.hash = EMPTY_BUCKET;\n-            let (k, v) = ptr::read(self.raw.pair);\n+            *self.raw.hash() = EMPTY_BUCKET;\n+            let (k, v) = ptr::read(self.raw.pair());\n             (EmptyBucket {\n                  raw: self.raw,\n-                 idx: self.idx,\n                  table: self.table,\n              },\n             k,\n@@ -604,9 +583,9 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     pub unsafe fn remove_key(&mut self) {\n         self.table.size -= 1;\n \n-        *self.raw.hash = EMPTY_BUCKET;\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::drop_in_place(&mut (*pair_mut).0); // only drop key\n+        *self.raw.hash() = EMPTY_BUCKET;\n+        let pair_ptr = self.raw.pair();\n+        ptr::drop_in_place(&mut (*pair_ptr).0); // only drop key\n     }\n }\n \n@@ -617,8 +596,8 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n-            let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let (old_key, old_val) = ptr::replace(self.raw.pair as *mut (K, V), (k, v));\n+            let old_hash = ptr::replace(self.raw.hash() as *mut SafeHash, h);\n+            let (old_key, old_val) = ptr::replace(self.raw.pair(), (k, v));\n \n             (old_hash, old_key, old_val)\n         }\n@@ -630,8 +609,10 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -644,7 +625,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -654,8 +638,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -667,22 +653,23 @@ impl<K, V, M> GapThenFull<K, V, M>\n         &self.full\n     }\n \n-    pub fn into_bucket(self) -> Bucket<K, V, M> {\n-        self.full.into_bucket()\n+    pub fn into_table(self) -> M {\n+        self.full.into_table()\n     }\n \n     pub fn shift(mut self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         unsafe {\n-            *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n+            let (gap_hash, gap_pair) = self.gap.raw.hash_pair();\n+            let (full_hash, full_pair) = self.full.raw.hash_pair();\n+            *gap_hash = mem::replace(&mut *full_hash, EMPTY_BUCKET);\n+            ptr::copy_nonoverlapping(full_pair, gap_pair, 1);\n         }\n \n-        let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n+        let FullBucket { raw: prev_raw, .. } = self.full;\n \n         match self.full.next().peek() {\n             Full(bucket) => {\n                 self.gap.raw = prev_raw;\n-                self.gap.idx = prev_idx;\n \n                 self.full = bucket;\n \n@@ -761,7 +748,7 @@ impl<K, V> RawTable<K, V> {\n         if capacity == 0 {\n             return RawTable {\n                 size: 0,\n-                capacity: 0,\n+                capacity_mask: capacity.wrapping_sub(1),\n                 hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n@@ -801,25 +788,27 @@ impl<K, V> RawTable<K, V> {\n         let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n         RawTable {\n-            capacity: capacity,\n+            capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n             hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n         }\n     }\n \n-    fn first_bucket_raw(&self) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+    fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n \n-        let buffer = self.hashes.ptr() as *mut u8;\n         let (pairs_offset, _, oflo) =\n             calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n+\n+        let buffer = self.hashes.ptr() as *mut u8;\n         unsafe {\n             RawBucket {\n-                hash: self.hashes.ptr(),\n-                pair: buffer.offset(pairs_offset as isize) as *const _,\n+                hash_start: buffer as *mut HashUint,\n+                pair_start: buffer.offset(pairs_offset as isize) as *const (K, V),\n+                idx: index,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -837,7 +826,7 @@ impl<K, V> RawTable<K, V> {\n \n     /// The hashtable's capacity, similar to a vector's.\n     pub fn capacity(&self) -> usize {\n-        self.capacity\n+        self.capacity_mask.wrapping_add(1)\n     }\n \n     /// The number of elements ever `put` in the hashtable, minus the number\n@@ -848,47 +837,45 @@ impl<K, V> RawTable<K, V> {\n \n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n-            raw: self.first_bucket_raw(),\n-            hashes_end: unsafe { self.hashes.ptr().offset(self.capacity as isize) },\n+            raw: self.raw_bucket_at(0),\n+            elems_left: self.size,\n             marker: marker::PhantomData,\n         }\n     }\n \n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n         }\n     }\n \n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n             _marker: marker::PhantomData,\n         }\n     }\n \n     pub fn into_iter(self) -> IntoIter<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         IntoIter {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: self,\n         }\n     }\n \n     pub fn drain(&mut self) -> Drain<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         Drain {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: unsafe { Shared::new(self) },\n@@ -900,18 +887,16 @@ impl<K, V> RawTable<K, V> {\n     /// state and should only be used for dropping the table's remaining\n     /// entries. It's used in the implementation of Drop.\n     unsafe fn rev_drop_buckets(&mut self) {\n-        let first_raw = self.first_bucket_raw();\n-        let mut raw = first_raw.offset(self.capacity as isize);\n+        // initialize the raw bucket past the end of the table\n+        let mut raw = self.raw_bucket_at(self.capacity());\n         let mut elems_left = self.size;\n \n         while elems_left != 0 {\n-            debug_assert!(raw.hash != first_raw.hash);\n+            raw.idx -= 1;\n \n-            raw = raw.offset(-1);\n-\n-            if *raw.hash != EMPTY_BUCKET {\n+            if *raw.hash() != EMPTY_BUCKET {\n                 elems_left -= 1;\n-                ptr::drop_in_place(raw.pair as *mut (K, V));\n+                ptr::drop_in_place(raw.pair());\n             }\n         }\n     }\n@@ -931,7 +916,7 @@ impl<K, V> RawTable<K, V> {\n /// this interface is safe, it's not used outside this module.\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut HashUint,\n+    elems_left: usize,\n \n     // Strictly speaking, this should be &'a (K,V), but that would\n     // require that K:'a, and we often use RawBuckets<'static...> for\n@@ -946,7 +931,7 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n     fn clone(&self) -> RawBuckets<'a, K, V> {\n         RawBuckets {\n             raw: self.raw,\n-            hashes_end: self.hashes_end,\n+            elems_left: self.elems_left,\n             marker: marker::PhantomData,\n         }\n     }\n@@ -957,25 +942,36 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n     type Item = RawBucket<K, V>;\n \n     fn next(&mut self) -> Option<RawBucket<K, V>> {\n-        while self.raw.hash != self.hashes_end {\n+        if self.elems_left == 0 {\n+            return None;\n+        }\n+\n+        loop {\n             unsafe {\n-                // We are swapping out the pointer to a bucket and replacing\n-                // it with the pointer to the next one.\n-                let prev = ptr::replace(&mut self.raw, self.raw.offset(1));\n-                if *prev.hash != EMPTY_BUCKET {\n-                    return Some(prev);\n+                let item = self.raw;\n+                self.raw.idx += 1;\n+                if *item.hash() != EMPTY_BUCKET {\n+                    self.elems_left -= 1;\n+                    return Some(item);\n                 }\n             }\n         }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.elems_left, Some(self.elems_left))\n+    }\n+}\n \n-        None\n+impl<'a, K, V> ExactSizeIterator for RawBuckets<'a, K, V> {\n+    fn len(&self) -> usize {\n+        self.elems_left\n     }\n }\n \n /// Iterator over shared references to entries in a table.\n pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n }\n \n unsafe impl<'a, K: Sync, V: Sync> Sync for Iter<'a, K, V> {}\n@@ -986,16 +982,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n \n-\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n     // To ensure invariance with respect to V\n     _marker: marker::PhantomData<&'a mut V>,\n }\n@@ -1009,7 +1002,6 @@ impl<'a, K: 'a, V: 'a> IterMut<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n@@ -1027,7 +1019,6 @@ impl<K, V> IntoIter<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.table.size,\n         }\n     }\n }\n@@ -1044,11 +1035,8 @@ unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}\n \n impl<'a, K, V> Drain<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n-        unsafe {\n-            Iter {\n-                iter: self.iter.clone(),\n-                elems_left: (**self.table).size,\n-            }\n+        Iter {\n+            iter: self.iter.clone(),\n         }\n     }\n }\n@@ -1057,64 +1045,65 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            unsafe { (&(*bucket.pair).0, &(*bucket.pair).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            let pair_mut = bucket.pair as *mut (K, V);\n-            unsafe { (&(*pair_mut).0, &mut (*pair_mut).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &mut (*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (SafeHash, K, V);\n \n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n+        self.iter.next().map(|raw| {\n             self.table.size -= 1;\n             unsafe {\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: *bucket.hash }, k, v)\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: *raw.hash() }, k, v)\n             }\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.table.size();\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     fn len(&self) -> usize {\n-        self.table.size()\n+        self.iter().len()\n     }\n }\n \n@@ -1123,23 +1112,21 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n-            unsafe {\n-                (*self.table.as_mut_ptr()).size -= 1;\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) }, k, v)\n-            }\n+        self.iter.next().map(|raw| unsafe {\n+            (*self.table.as_mut_ptr()).size -= 1;\n+            let (k, v) = ptr::read(raw.pair());\n+            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = unsafe { (**self.table).size() };\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize {\n-        unsafe { (**self.table).size() }\n+        self.iter.len()\n     }\n }\n \n@@ -1152,30 +1139,21 @@ impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     fn clone(&self) -> RawTable<K, V> {\n         unsafe {\n-            let mut new_ht = RawTable::new_uninitialized(self.capacity());\n-\n-            {\n-                let cap = self.capacity();\n-                let mut new_buckets = Bucket::first(&mut new_ht);\n-                let mut buckets = Bucket::first(self);\n-                while buckets.index() != cap {\n-                    match buckets.peek() {\n-                        Full(full) => {\n-                            let (h, k, v) = {\n-                                let (k, v) = full.read();\n-                                (full.hash(), k.clone(), v.clone())\n-                            };\n-                            *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.pair as *mut (K, V), (k, v));\n-                        }\n-                        Empty(..) => {\n-                            *new_buckets.raw.hash = EMPTY_BUCKET;\n-                        }\n-                    }\n-                    new_buckets.next();\n-                    buckets.next();\n+            let cap = self.capacity();\n+            let mut new_ht = RawTable::new_uninitialized(cap);\n+\n+            let mut new_buckets = new_ht.raw_bucket_at(0);\n+            let mut buckets = self.raw_bucket_at(0);\n+            while buckets.idx < cap {\n+                *new_buckets.hash() = *buckets.hash();\n+                if *new_buckets.hash() != EMPTY_BUCKET {\n+                    let pair_ptr = buckets.pair();\n+                    let kv = ((*pair_ptr).0.clone(), (*pair_ptr).1.clone());\n+                    ptr::write(new_buckets.pair(), kv);\n                 }\n-            };\n+                buckets.idx += 1;\n+                new_buckets.idx += 1;\n+            }\n \n             new_ht.size = self.size();\n \n@@ -1186,7 +1164,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n \n unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity() == 0 {\n             return;\n         }\n \n@@ -1202,8 +1180,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n                                                           align_of::<HashUint>(),\n                                                           pairs_size,"}, {"sha": "6b1267d89b6d5730246c2f7d0ce6d797ded38968", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1176,6 +1176,7 @@ impl AsInner<fs_imp::DirEntry> for DirEntry {\n /// This function currently corresponds to the `unlink` function on Unix\n /// and the `DeleteFile` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1212,6 +1213,7 @@ pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `stat` function on Unix\n /// and the `GetFileAttributesEx` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1245,6 +1247,7 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n /// This function currently corresponds to the `lstat` function on Unix\n /// and the `GetFileAttributesEx` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1287,6 +1290,7 @@ pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n /// on Windows, `from` can be anything, but `to` must *not* be a directory.\n ///\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1330,6 +1334,7 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1366,6 +1371,7 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// This function currently corresponds to the `link` function on Unix\n /// and the `CreateHardLink` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1424,6 +1430,7 @@ pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// and the `CreateFile` function with `FILE_FLAG_OPEN_REPARSE_POINT` and\n /// `FILE_FLAG_BACKUP_SEMANTICS` flags on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1457,6 +1464,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// This function currently corresponds to the `realpath` function on Unix\n /// and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1489,6 +1497,7 @@ pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// This function currently corresponds to the `mkdir` function on Unix\n /// and the `CreateDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1522,6 +1531,7 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `mkdir` function on Unix\n /// and the `CreateDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1562,6 +1572,7 @@ pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `rmdir` function on Unix\n /// and the `RemoveDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1599,6 +1610,7 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n /// on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1633,6 +1645,7 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `opendir` function on Unix\n /// and the `FindFirstFile` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1679,6 +1692,7 @@ pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n /// This function currently corresponds to the `chmod` function on Unix\n /// and the `SetFileAttributes` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1726,9 +1740,9 @@ impl DirBuilder {\n         }\n     }\n \n-    /// Indicate that directories create should be created recursively, creating\n-    /// all parent directories if they do not exist with the same security and\n-    /// permissions settings.\n+    /// Indicates that directories should be created recursively, creating all\n+    /// parent directories. Parents that do not exist are created with the same\n+    /// security and permissions settings.\n     ///\n     /// This option defaults to `false`.\n     ///\n@@ -1749,6 +1763,9 @@ impl DirBuilder {\n     /// Create the specified directory with the options configured in this\n     /// builder.\n     ///\n+    /// It is considered an error if the directory already exists unless\n+    /// recursive mode is enabled.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "3b82412716e54f7346dbfc24c2732f56070f246c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -21,12 +21,12 @@ use memchr;\n /// The `BufReader` struct adds buffering to any reader.\n ///\n /// It can be excessively inefficient to work directly with a [`Read`] instance.\n-/// For example, every call to [`read`] on [`TcpStream`] results in a system call.\n-/// A `BufReader` performs large, infrequent reads on the underlying [`Read`]\n-/// and maintains an in-memory buffer of the results.\n+/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n+/// results in a system call. A `BufReader` performs large, infrequent reads on\n+/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n ///\n /// [`Read`]: ../../std/io/trait.Read.html\n-/// [`read`]: ../../std/net/struct.TcpStream.html#method.read\n+/// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n ///\n /// # Examples\n@@ -261,9 +261,10 @@ impl<R: Seek> Seek for BufReader<R> {\n /// Wraps a writer and buffers its output.\n ///\n /// It can be excessively inefficient to work directly with something that\n-/// implements [`Write`]. For example, every call to [`write`] on [`TcpStream`]\n-/// results in a system call. A `BufWriter` keeps an in-memory buffer of data\n-/// and writes it to an underlying writer in large, infrequent batches.\n+/// implements [`Write`]. For example, every call to\n+/// [`write`][`Tcpstream::write`] on [`TcpStream`] results in a system call. A\n+/// `BufWriter` keeps an in-memory buffer of data and writes it to an underlying\n+/// writer in large, infrequent batches.\n ///\n /// The buffer will be written out when the writer is dropped.\n ///\n@@ -303,7 +304,7 @@ impl<R: Seek> Seek for BufReader<R> {\n /// the `stream` is dropped.\n ///\n /// [`Write`]: ../../std/io/trait.Write.html\n-/// [`write`]: ../../std/net/struct.TcpStream.html#method.write\n+/// [`Tcpstream::write`]: ../../std/net/struct.TcpStream.html#method.write\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {"}, {"sha": "cd096c115ba5a2a181f9a2275076915240bbaf13", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -21,7 +21,8 @@\n //! of other types, and you can implement them for your types too. As such,\n //! you'll see a few different types of I/O throughout the documentation in\n //! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n-//! example, [`Read`] adds a [`read`] method, which we can use on `File`s:\n+//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n+//! `File`s:\n //!\n //! ```\n //! use std::io;\n@@ -106,7 +107,7 @@\n //! ```\n //!\n //! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n-//! to [`write`]:\n+//! to [`write`][`Write::write`]:\n //!\n //! ```\n //! use std::io;\n@@ -257,13 +258,13 @@\n //! [`Vec<T>`]: ../vec/struct.Vec.html\n //! [`BufReader`]: struct.BufReader.html\n //! [`BufWriter`]: struct.BufWriter.html\n-//! [`write`]: trait.Write.html#tymethod.write\n+//! [`Write::write`]: trait.Write.html#tymethod.write\n //! [`io::stdout`]: fn.stdout.html\n //! [`println!`]: ../macro.println.html\n //! [`Lines`]: struct.Lines.html\n //! [`io::Result`]: type.Result.html\n //! [`?` operator]: ../../book/syntax-index.html\n-//! [`read`]: trait.Read.html#tymethod.read\n+//! [`Read::read`]: trait.Read.html#tymethod.read\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "bc315d54100e42d1048a90baa96d64cda64d2722", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -58,7 +58,7 @@ pub struct TcpStream(net_imp::TcpStream);\n ///\n /// After creating a `TcpListener` by [`bind`]ing it to a socket address, it listens\n /// for incoming TCP connections. These can be accepted by calling [`accept`] or by\n-/// iterating over the [`Incoming`] iterator returned by [`incoming`].\n+/// iterating over the [`Incoming`] iterator returned by [`incoming`][`TcpListener::incoming`].\n ///\n /// The socket will be closed when the value is dropped.\n ///\n@@ -68,7 +68,7 @@ pub struct TcpStream(net_imp::TcpStream);\n /// [`bind`]: #method.bind\n /// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n /// [`Incoming`]: ../../std/net/struct.Incoming.html\n-/// [`incoming`]: #method.incoming\n+/// [`TcpListener::incoming`]: #method.incoming\n ///\n /// # Examples\n ///"}, {"sha": "86e661d7948f07dfb05a533f16e0077ae9c6ae13", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -56,14 +56,14 @@\n //!   traits indicate fundamental properties of types.\n //! * [`std::ops`]::{[`Drop`], [`Fn`], [`FnMut`], [`FnOnce`]}. Various\n //!   operations for both destructors and overloading `()`.\n-//! * [`std::mem`]::[`drop`], a convenience function for explicitly dropping a\n-//!   value.\n+//! * [`std::mem`]::[`drop`][`mem::drop`], a convenience function for explicitly\n+//!   dropping a value.\n //! * [`std::boxed`]::[`Box`], a way to allocate values on the heap.\n //! * [`std::borrow`]::[`ToOwned`], The conversion trait that defines\n //!   [`to_owned`], the generic method for creating an owned type from a\n //!   borrowed type.\n-//! * [`std::clone`]::[`Clone`], the ubiquitous trait that defines [`clone`],\n-//!   the method for producing a copy of a value.\n+//! * [`std::clone`]::[`Clone`], the ubiquitous trait that defines\n+//!   [`clone`][`Clone::clone`], the method for producing a copy of a value.\n //! * [`std::cmp`]::{[`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`] }. The\n //!   comparison traits, which implement the comparison operators and are often\n //!   seen in trait bounds.\n@@ -117,8 +117,8 @@\n //! [`ToOwned`]: ../borrow/trait.ToOwned.html\n //! [`ToString`]: ../string/trait.ToString.html\n //! [`Vec`]: ../vec/struct.Vec.html\n-//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n-//! [`drop`]: ../mem/fn.drop.html\n+//! [`Clone::clone`]: ../clone/trait.Clone.html#tymethod.clone\n+//! [`mem::drop`]: ../mem/fn.drop.html\n //! [`std::borrow`]: ../borrow/index.html\n //! [`std::boxed`]: ../boxed/index.html\n //! [`std::clone`]: ../clone/index.html"}, {"sha": "8cfd8fcd8c680b166fa38c14a3facd402afbc484", "filename": "src/libstd/process.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1070,6 +1070,27 @@ pub fn exit(code: i32) -> ! {\n ///     // execution never gets here\n /// }\n /// ```\n+///\n+/// The [`abort`] function terminates the process, so the destructor will not\n+/// get run on the example below:\n+///\n+/// ```no_run\n+/// use std::process;\n+///\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"This will never be printed!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = HasDrop;\n+///     process::abort();\n+///     // the destructor implemented for HasDrop will never get run\n+/// }\n+/// ```\n #[stable(feature = \"process_abort\", since = \"1.17.0\")]\n pub fn abort() -> ! {\n     unsafe { ::sys::abort_internal() };"}, {"sha": "a7b01e49d2bb625f2654b1bd13d5e30c81fae272", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -50,12 +50,11 @@ struct BarrierState {\n     generation_id: usize,\n }\n \n-/// A result returned from wait.\n+/// A `BarrierWaitResult` is returned by [`wait`] when all threads in the [`Barrier`]\n+/// have rendezvoused.\n ///\n-/// Currently this opaque structure only has one method, [`.is_leader`]. Only\n-/// one thread will receive a result that will return `true` from this function.\n-///\n-/// [`.is_leader`]: #method.is_leader\n+/// [`wait`]: struct.Barrier.html#method.wait\n+/// [`Barrier`]: struct.Barrier.html\n ///\n /// # Examples\n ///"}, {"sha": "0da65a4f2e12f2c9ed8d256d583515612a888092", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 172, "deletions": 46, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -13,40 +13,50 @@\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:\n //!\n-//! * `Sender`\n-//! * `SyncSender`\n-//! * `Receiver`\n+//! * [`Sender`]\n+//! * [`SyncSender`]\n+//! * [`Receiver`]\n //!\n-//! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n+//! A [`Sender`] or [`SyncSender`] is used to send data to a [`Receiver`]. Both\n //! senders are clone-able (multi-producer) such that many threads can send\n //! simultaneously to one receiver (single-consumer).\n //!\n //! These channels come in two flavors:\n //!\n-//! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n+//! 1. An asynchronous, infinitely buffered channel. The [`channel`] function\n //!    will return a `(Sender, Receiver)` tuple where all sends will be\n //!    **asynchronous** (they never block). The channel conceptually has an\n //!    infinite buffer.\n //!\n-//! 2. A synchronous, bounded channel. The `sync_channel()` function will return\n-//!    a `(SyncSender, Receiver)` tuple where the storage for pending messages\n-//!    is a pre-allocated buffer of a fixed size. All sends will be\n+//! 2. A synchronous, bounded channel. The [`sync_channel`] function will\n+//!    return a `(SyncSender, Receiver)` tuple where the storage for pending\n+//!    messages is a pre-allocated buffer of a fixed size. All sends will be\n //!    **synchronous** by blocking until there is buffer space available. Note\n-//!    that a bound of 0 is allowed, causing the channel to become a\n-//!    \"rendezvous\" channel where each sender atomically hands off a message to\n-//!    a receiver.\n+//!    that a bound of 0 is allowed, causing the channel to become a \"rendezvous\"\n+//!    channel where each sender atomically hands off a message to a receiver.\n+//!\n+//! [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+//! [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n+//! [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+//! [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+//! [`channel`]: ../../../std/sync/mpsc/fn.channel.html\n+//! [`sync_channel`]: ../../../std/sync/mpsc/fn.sync_channel.html\n //!\n //! ## Disconnection\n //!\n-//! The send and receive operations on channels will all return a `Result`\n+//! The send and receive operations on channels will all return a [`Result`]\n //! indicating whether the operation succeeded or not. An unsuccessful operation\n //! is normally indicative of the other half of a channel having \"hung up\" by\n //! being dropped in its corresponding thread.\n //!\n //! Once half of a channel has been deallocated, most operations can no longer\n-//! continue to make progress, so `Err` will be returned. Many applications will\n-//! continue to `unwrap()` the results returned from this module, instigating a\n-//! propagation of failure among threads if one unexpectedly dies.\n+//! continue to make progress, so [`Err`] will be returned. Many applications\n+//! will continue to [`unwrap`] the results returned from this module,\n+//! instigating a propagation of failure among threads if one unexpectedly dies.\n+//!\n+//! [`Result`]: ../../../std/result/enum.Result.html\n+//! [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+//! [`unwrap`]: ../../../std/result/enum.Result.html#method.unwrap\n //!\n //! # Examples\n //!\n@@ -288,7 +298,31 @@ mod mpsc_queue;\n mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one thread\n+/// one thread.\n+///\n+/// Messages sent to the channel can be retrieved using [`recv`].\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+/// use std::time::Duration;\n+///\n+/// let (send, recv) = channel();\n+///\n+/// thread::spawn(move || {\n+///     send.send(\"Hello world!\").unwrap();\n+///     thread::sleep(Duration::from_secs(2)); // block for two seconds\n+///     send.send(\"Delayed for 2 seconds\").unwrap();\n+/// });\n+///\n+/// println!(\"{}\", recv.recv().unwrap()); // Received immediately\n+/// println!(\"Waiting...\");\n+/// println!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -302,30 +336,39 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for Receiver<T> { }\n \n-/// An iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n-/// returned when the corresponding channel has hung up.\n+/// An iterator over messages on a receiver, this iterator will block whenever\n+/// [`next`] is called, waiting for a new message, and [`None`] will be returned\n+/// when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An iterator that attempts to yield all pending values for a receiver.\n-/// `None` will be returned when there are no pending values remaining or\n-/// if the corresponding channel has hung up.\n+/// [`None`] will be returned when there are no pending values remaining or if\n+/// the corresponding channel has hung up.\n ///\n /// This Iterator will never block the caller in order to wait for data to\n-/// become available. Instead, it will return `None`.\n+/// become available. Instead, it will return [`None`].\n+///\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An owning iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n+/// whenever [`next`] is called, waiting for a new message, and [`None`] will be\n /// returned when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+///\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n@@ -334,6 +377,35 @@ pub struct IntoIter<T> {\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// Messages can be sent through this channel with [`send`].\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+///\n+/// let (sender, receiver) = channel();\n+/// let sender2 = sender.clone();\n+///\n+/// // First thread owns sender\n+/// thread::spawn(move || {\n+///     sender.send(1).unwrap();\n+/// });\n+///\n+/// // Second thread owns sender2\n+/// thread::spawn(move || {\n+///     sender2.send(2).unwrap();\n+/// });\n+///\n+/// let msg = receiver.recv().unwrap();\n+/// let msg2 = receiver.recv().unwrap();\n+///\n+/// assert_eq!(3, msg + msg2);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -349,6 +421,10 @@ impl<T> !Sync for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<sync::Packet<T>>,\n@@ -360,25 +436,32 @@ unsafe impl<T: Send> Send for SyncSender<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for SyncSender<T> {}\n \n-/// An error returned from the `send` function on channels.\n+/// An error returned from the [`send`] function on channels.\n ///\n-/// A `send` operation can only fail if the receiving end of a channel is\n+/// A [`send`] operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-/// An error returned from the `recv` function on a `Receiver`.\n+/// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n-/// The `recv` operation can only fail if the sending half of a channel is\n+/// The [`recv`] operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n-/// This enumeration is the list of the possible reasons that `try_recv` could\n+/// This enumeration is the list of the possible reasons that [`try_recv`] could\n /// not return data when called.\n+///\n+/// [`try_recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.try_recv\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n@@ -393,8 +476,10 @@ pub enum TryRecvError {\n     Disconnected,\n }\n \n-/// This enumeration is the list of possible errors that `recv_timeout` could\n+/// This enumeration is the list of possible errors that [`recv_timeout`] could\n /// not return data when called.\n+///\n+/// [`recv_timeout`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv_timeout\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n pub enum RecvTimeoutError {\n@@ -409,7 +494,9 @@ pub enum RecvTimeoutError {\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n-/// `SyncSender::try_send` method.\n+/// [`SyncSender::try_send`] method.\n+///\n+/// [`SyncSender::try_send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.try_send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n@@ -556,10 +643,13 @@ impl<T> Sender<T> {\n     /// A successful send occurs when it is determined that the other end of\n     /// the channel has not hung up already. An unsuccessful send would be one\n     /// where the corresponding receiver has already been deallocated. Note\n-    /// that a return value of `Err` means that the data will never be\n-    /// received, but a return value of `Ok` does *not* mean that the data\n+    /// that a return value of [`Err`] means that the data will never be\n+    /// received, but a return value of [`Ok`] does *not* mean that the data\n     /// will be received.  It is possible for the corresponding receiver to\n-    /// hang up immediately after this function returns `Ok`.\n+    /// hang up immediately after this function returns [`Ok`].\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Ok`]: ../../../std/result/enum.Result.html#variant.Ok\n     ///\n     /// This method will never block the current thread.\n     ///\n@@ -702,23 +792,29 @@ impl<T> SyncSender<T> {\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// This function will never panic, but it may return `Err` if the\n-    /// `Receiver` has disconnected and is no longer able to receive\n+    /// This function will never panic, but it may return [`Err`] if the\n+    /// [`Receiver`] has disconnected and is no longer able to receive\n     /// information.\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         self.inner.send(t).map_err(SendError)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send` by returning immediately if the\n+    /// This method differs from [`send`] by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send`, this function has two failure cases\n+    /// data. Compared with [`send`], this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n-    /// See `SyncSender::send` for notes about guarantees of whether the\n+    /// See [`SyncSender::send`] for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n+    ///\n+    /// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+    /// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n@@ -819,15 +915,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -907,15 +1006,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -993,16 +1095,40 @@ impl<T> Receiver<T> {\n     }\n \n     /// Returns an iterator that will block waiting for messages, but never\n-    /// `panic!`. It will return `None` when the channel has hung up.\n+    /// [`panic!`]. It will return [`None`] when the channel has hung up.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n+    /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::channel;\n+    /// use std::thread;\n+    ///\n+    /// let (send, recv) = channel();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     send.send(1u8).unwrap();\n+    ///     send.send(2u8).unwrap();\n+    ///     send.send(3u8).unwrap();\n+    /// });\n+    ///\n+    /// for x in recv.iter() {\n+    ///     println!(\"Got: {}\", x);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n \n     /// Returns an iterator that will attempt to yield all pending values.\n     /// It will return `None` if there are no more pending values or if the\n-    /// channel has hung up. The iterator will never `panic!` or block the\n+    /// channel has hung up. The iterator will never [`panic!`] or block the\n     /// user by waiting for values.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n     #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n     pub fn try_iter(&self) -> TryIter<T> {\n         TryIter { rx: self }"}, {"sha": "f2c178a1ad503f6e21f62ac574b41bb759a40316", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -30,7 +30,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///\n /// The mutexes in this module implement a strategy called \"poisoning\" where a\n /// mutex is considered poisoned whenever a thread panics while holding the\n-/// lock. Once a mutex is poisoned, all other threads are unable to access the\n+/// mutex. Once a mutex is poisoned, all other threads are unable to access the\n /// data by default as it is likely tainted (some invariant is not being\n /// upheld).\n ///\n@@ -115,7 +115,7 @@ pub struct Mutex<T: ?Sized> {\n     // Note that this mutex is in a *box*, not inlined into the struct itself.\n     // Once a native mutex has been used once, its address can never change (it\n     // can't be moved). This mutex type can be safely moved at any time, so to\n-    // ensure that the native mutex is used correctly we box the inner lock to\n+    // ensure that the native mutex is used correctly we box the inner mutex to\n     // give it a constant address.\n     inner: Box<sys::Mutex>,\n     poison: poison::Flag,\n@@ -183,7 +183,7 @@ impl<T: ?Sized> Mutex<T> {\n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n     /// This function will block the local thread until it is available to acquire\n-    /// the mutex. Upon returning, the thread is the only thread with the mutex\n+    /// the mutex. Upon returning, the thread is the only thread with the lock\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n     ///\n@@ -267,9 +267,9 @@ impl<T: ?Sized> Mutex<T> {\n         }\n     }\n \n-    /// Determines whether the lock is poisoned.\n+    /// Determines whether the mutex is poisoned.\n     ///\n-    /// If another thread is active, the lock can still become poisoned at any\n+    /// If another thread is active, the mutex can still become poisoned at any\n     /// time. You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n     ///\n@@ -312,7 +312,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner lock.\n+        // `self` so there's no need to lock the inner mutex.\n         //\n         // To get the inner value, we'd like to call `data.into_inner()`,\n         // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n@@ -353,7 +353,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner lock.\n+        // there's no need to lock the inner mutex.\n         let data = unsafe { &mut *self.data.get() };\n         poison::map_result(self.poison.borrow(), |_| data )\n     }"}, {"sha": "296235e173d13f575a04b395b1042b9a47a1b470", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -72,13 +72,6 @@ pub trait IntoRawFd {\n     fn into_raw_fd(self) -> RawFd;\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for RawFd {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for fs::File {\n     fn as_raw_fd(&self) -> RawFd {\n@@ -91,14 +84,6 @@ impl FromRawFd for fs::File {\n         fs::File::from_inner(sys::fs::File::from_inner(fd))\n     }\n }\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for RawFd {\n-    fn into_raw_fd(self) -> RawFd {\n-        self\n-    }\n-}\n-\n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for fs::File {\n     fn into_raw_fd(self) -> RawFd {"}, {"sha": "854d380d128c9d18d500297b7ecaa07badce30a3", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -92,7 +92,7 @@ pub fn init() {\n \n     #[cfg(not(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n-        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n+        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n     }\n     #[cfg(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\"))]\n     unsafe fn reset_sigpipe() {}"}, {"sha": "706256ff10ec9dac6cb548150ff68ad129dc0511", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cmp;\n use io;\n use libc::{self, c_int};\n use mem;\n-use ptr;\n use sys::{cvt, cvt_r};\n use sys::fd::FileDesc;\n \n@@ -80,16 +78,14 @@ pub fn read2(p1: AnonPipe,\n     p1.set_nonblocking(true)?;\n     p2.set_nonblocking(true)?;\n \n-    let max = cmp::max(p1.raw(), p2.raw());\n+    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n+    fds[0].fd = p1.raw();\n+    fds[0].events = libc::POLLIN;\n+    fds[1].fd = p2.raw();\n+    fds[1].events = libc::POLLIN;\n     loop {\n-        // wait for either pipe to become readable using `select`\n-        cvt_r(|| unsafe {\n-            let mut read: libc::fd_set = mem::zeroed();\n-            libc::FD_SET(p1.raw(), &mut read);\n-            libc::FD_SET(p2.raw(), &mut read);\n-            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n-                         ptr::null_mut())\n-        })?;\n+        // wait for either pipe to become readable using `poll`\n+        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n \n         // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n         // EAGAIN. If we hit EOF, then this will happen because the underlying\n@@ -109,11 +105,11 @@ pub fn read2(p1: AnonPipe,\n                 }\n             }\n         };\n-        if read(&p1, v1)? {\n+        if fds[0].revents != 0 && read(&p1, v1)? {\n             p2.set_nonblocking(false)?;\n             return p2.read_to_end(v2).map(|_| ());\n         }\n-        if read(&p2, v2)? {\n+        if fds[1].revents != 0 && read(&p2, v2)? {\n             p1.set_nonblocking(false)?;\n             return p1.read_to_end(v1).map(|_| ());\n         }"}, {"sha": "d6e2fed56be96b1d5b640dacc05aecc73fe2295f", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -144,7 +144,7 @@ pub trait OpenOptionsExt {\n     /// `CreateFile`).\n     ///\n     /// If a _new_ file is created because it does not yet exist and\n-    ///`.create(true)` or `.create_new(true)` are specified, the new file is\n+    /// `.create(true)` or `.create_new(true)` are specified, the new file is\n     /// given the attributes declared with `.attributes()`.\n     ///\n     /// If an _existing_ file is opened with `.create(true).truncate(true)`, its"}, {"sha": "759f055c4b1236e4640982e21d4be19fd15b7155", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -104,6 +104,7 @@ pub trait CommandExt {\n     /// Sets the [process creation flags][1] to be passed to `CreateProcess`.\n     ///\n     /// These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.\n+    ///\n     /// [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx\n     #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command;"}, {"sha": "7ab6b82ada3445f6ca739fcd4439cc6a538c58c0", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -90,7 +90,7 @@\n //! two ways:\n //!\n //! * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n-//!   function, and calling [`thread`] on the [`JoinHandle`].\n+//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n //! * By requesting the current thread, using the [`thread::current`] function.\n //!\n //! The [`thread::current`] function is available even for threads not spawned\n@@ -151,14 +151,14 @@\n //! [`Arc`]: ../../std/sync/struct.Arc.html\n //! [`spawn`]: ../../std/thread/fn.spawn.html\n //! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n-//! [`thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n+//! [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n //! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n //! [`Result`]: ../../std/result/enum.Result.html\n //! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n //! [`Err`]: ../../std/result/enum.Result.html#variant.Err\n //! [`panic!`]: ../../std/macro.panic.html\n //! [`Builder`]: ../../std/thread/struct.Builder.html\n-//! [`thread::current`]: ../../std/thread/fn.spawn.html\n+//! [`thread::current`]: ../../std/thread/fn.current.html\n //! [`Thread`]: ../../std/thread/struct.Thread.html\n //! [`park`]: ../../std/thread/fn.park.html\n //! [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark"}, {"sha": "e7c5d8278d9775065d1c800633ceaba2458e7e17", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -26,7 +26,8 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n             return true;\n         }\n \n-        match attr.parse_list(cx.parse_sess, |parser| parser.parse_path(PathStyle::Mod)) {\n+        match attr.parse_list(cx.parse_sess,\n+                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n             Ok(ref traits) if traits.is_empty() => {\n                 cx.span_warn(attr.span, \"empty trait list in `derive`\");\n                 false"}, {"sha": "550f1160bed858990976922e25509e1ce577e535", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -292,9 +292,6 @@ declare_features! (\n     // Allows attributes on lifetime/type formal parameters in generics (RFC 1327)\n     (active, generic_param_attrs, \"1.11.0\", Some(34761)),\n \n-    // The #![windows_subsystem] attribute\n-    (active, windows_subsystem, \"1.14.0\", Some(37499)),\n-\n     // Allows #[link(..., cfg(..))]\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n \n@@ -337,11 +334,15 @@ declare_features! (\n     // `extern \"x86-interrupt\" fn()`\n     (active, abi_x86_interrupt, \"1.17.0\", Some(40180)),\n \n+\n     // Allows the `catch {...}` expression\n     (active, catch_expr, \"1.17.0\", Some(31436)),\n \n     // See rust-lang/rfcs#1414. Allows code like `let x: &'static u32 = &42` to work.\n     (active, rvalue_static_promotion, \"1.15.1\", Some(38865)),\n+\n+    // Used to preserve symbols (see llvm.used)\n+    (active, used, \"1.18.0\", Some(40289)),\n );\n \n declare_features! (\n@@ -408,7 +409,8 @@ declare_features! (\n     (accepted, static_recursion, \"1.17.0\", Some(29719)),\n     // pub(restricted) visibilities (RFC 1422)\n     (accepted, pub_restricted, \"1.17.0\", Some(32409)),\n-\n+    // The #![windows_subsystem] attribute\n+    (accepted, windows_subsystem, \"1.18.0\", Some(37499)),\n );\n // If you change this, please modify src/doc/unstable-book as well. You must\n // move that documentation into the relevant place in the other docs, and\n@@ -748,6 +750,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                   \"unwind_attributes\",\n                                   \"#[unwind] is experimental\",\n                                   cfg_fn!(unwind_attributes))),\n+    (\"used\", Whitelisted, Gated(\n+        Stability::Unstable, \"used\",\n+        \"the `#[used]` attribute is an experimental feature\",\n+        cfg_fn!(used))),\n \n     // used in resolve\n     (\"prelude_import\", Whitelisted, Gated(Stability::Unstable,\n@@ -768,11 +774,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                         \"unboxed_closures are still evolving\",\n                                         cfg_fn!(unboxed_closures))),\n \n-    (\"windows_subsystem\", Whitelisted, Gated(Stability::Unstable,\n-                                             \"windows_subsystem\",\n-                                             \"the windows subsystem attribute \\\n-                                              is currently unstable\",\n-                                             cfg_fn!(windows_subsystem))),\n+    (\"windows_subsystem\", Whitelisted, Ungated),\n \n     (\"proc_macro_attribute\", Normal, Gated(Stability::Unstable,\n                                            \"proc_macro\","}, {"sha": "43d21015a4fb14569ac0f1635ae18b218b1bc550", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 88, "deletions": 28, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -570,20 +570,33 @@ impl<'a> Parser<'a> {\n             expected.dedup();\n             let expect = tokens_to_string(&expected[..]);\n             let actual = self.this_token_to_string();\n-            Err(self.fatal(\n-                &(if expected.len() > 1 {\n-                    (format!(\"expected one of {}, found `{}`\",\n-                             expect,\n-                             actual))\n-                } else if expected.is_empty() {\n-                    (format!(\"unexpected token: `{}`\",\n-                             actual))\n+            let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n+                let short_expect = if expected.len() > 6 {\n+                    format!(\"{} possible tokens\", expected.len())\n                 } else {\n-                    (format!(\"expected {}, found `{}`\",\n-                             expect,\n-                             actual))\n-                })[..]\n-            ))\n+                    expect.clone()\n+                };\n+                (format!(\"expected one of {}, found `{}`\", expect, actual),\n+                 (self.prev_span.next_point(), format!(\"expected one of {} here\", short_expect)))\n+            } else if expected.is_empty() {\n+                (format!(\"unexpected token: `{}`\", actual),\n+                 (self.prev_span, \"unexpected token after this\".to_string()))\n+            } else {\n+                (format!(\"expected {}, found `{}`\", expect, actual),\n+                 (self.prev_span.next_point(), format!(\"expected {} here\", expect)))\n+            };\n+            let mut err = self.fatal(&msg_exp);\n+            let sp = if self.token == token::Token::Eof {\n+                // This is EOF, don't want to point at the following char, but rather the last token\n+                self.prev_span\n+            } else {\n+                label_sp\n+            };\n+            err.span_label(sp, &label_exp);\n+            if !sp.source_equal(&self.span) {\n+                err.span_label(self.span, &\"unexpected token\");\n+            }\n+            Err(err)\n         }\n     }\n \n@@ -1773,6 +1786,26 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for back-compat.\n+    /// This is used when parsing derive macro paths in `#[derive]` attributes.\n+    pub fn parse_path_allowing_meta(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+        let meta_ident = match self.token {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtMeta(ref meta) => match meta.node {\n+                    ast::MetaItemKind::Word => Some(ast::Ident::with_empty_ctxt(meta.name)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        if let Some(ident) = meta_ident {\n+            self.bump();\n+            return Ok(ast::Path::from_ident(self.prev_span, ident));\n+        }\n+        self.parse_path(mode)\n+    }\n+\n     /// Examples:\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n@@ -4667,25 +4700,30 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn complain_if_pub_macro(&mut self, visa: &Visibility, span: Span) {\n-        match *visa {\n-            Visibility::Inherited => (),\n+    fn complain_if_pub_macro(&mut self, vis: &Visibility, sp: Span) {\n+        if let Err(mut err) = self.complain_if_pub_macro_diag(vis, sp) {\n+            err.emit();\n+        }\n+    }\n+\n+    fn complain_if_pub_macro_diag(&mut self, vis: &Visibility, sp: Span) -> PResult<'a, ()> {\n+        match *vis {\n+            Visibility::Inherited => Ok(()),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n                     token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n-                    self.diagnostic().struct_span_err(span, \"can't qualify macro_rules \\\n-                                                             invocation with `pub`\")\n-                                     .help(\"did you mean #[macro_export]?\")\n-                                     .emit();\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    err.help(\"did you mean #[macro_export]?\");\n+                    Err(err)\n                 } else {\n-                    self.diagnostic().struct_span_err(span, \"can't qualify macro \\\n-                                                             invocation with `pub`\")\n-                                     .help(\"try adjusting the macro to put `pub` \\\n-                                            inside the invocation\")\n-                                     .emit();\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n+                    Err(err)\n                 }\n             }\n         }\n@@ -4696,14 +4734,36 @@ impl<'a> Parser<'a> {\n                          -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if self.token.is_path_start() {\n-            // method macro.\n+            // Method macro.\n \n             let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis, prev_span);\n+            // Before complaining about trying to set a macro as `pub`,\n+            // check if `!` comes after the path.\n+            let err = self.complain_if_pub_macro_diag(&vis, prev_span);\n \n             let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n+            let bang_err = self.expect(&token::Not);\n+            if let Err(mut err) = err {\n+                if let Err(mut bang_err) = bang_err {\n+                    // Given this code `pub path(`, it seems like this is not setting the\n+                    // visibility of a macro invocation, but rather a mistyped method declaration.\n+                    // Create a diagnostic pointing out that `fn` is missing.\n+                    //\n+                    // x |     pub path(&self) {\n+                    //   |        ^ missing `fn` for method declaration\n+\n+                    err.cancel();\n+                    bang_err.cancel();\n+                    //     pub  path(\n+                    //        ^^ `sp` below will point to this\n+                    let sp = prev_span.between(self.prev_span);\n+                    err = self.diagnostic()\n+                        .struct_span_err(sp, \"missing `fn` for method declaration\");\n+                    err.span_label(sp, &\"missing `fn`\");\n+                }\n+                return Err(err);\n+            }\n \n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;"}, {"sha": "15111bbba0a92d6d04cdb03b0f0f5f09fcd09587", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -43,6 +43,8 @@ use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub struct P<T: ?Sized> {\n@@ -215,3 +217,13 @@ impl<T: Decodable> Decodable for P<[T]> {\n         }))\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for P<T>\n+    where T: ?Sized + HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2d9fd7aa87553dc81ad73bb36f77fc3198ce781a", "filename": "src/libsyntax/util/rc_slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Futil%2Frc_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax%2Futil%2Frc_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Frc_slice.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -12,6 +12,9 @@ use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+\n #[derive(Clone)]\n pub struct RcSlice<T> {\n     data: Rc<Box<[T]>>,\n@@ -41,3 +44,13 @@ impl<T: fmt::Debug> fmt::Debug for RcSlice<T> {\n         fmt::Debug::fmt(self.deref(), f)\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for RcSlice<T>\n+    where T: HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "9b88b9f7696fb3a35f68c5165d3f5ccc59ce610f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -83,7 +83,13 @@ impl Span {\n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(self) -> Span {\n         let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n-        Span { lo: BytePos(lo), hi: self.hi, ctxt: self.ctxt }\n+        Span { lo: BytePos(lo), ..self }\n+    }\n+\n+    /// Returns a new span representing the next character after the end-point of this span\n+    pub fn next_point(self) -> Span {\n+        let lo = cmp::max(self.hi.0, self.lo.0 + 1);\n+        Span { lo: BytePos(lo), hi: BytePos(lo + 1), ..self }\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n@@ -183,6 +189,30 @@ impl Span {\n             Span { hi: end.hi, ..self }\n         }\n     }\n+\n+    pub fn between(self, end: Span) -> Span {\n+        Span {\n+            lo: self.hi,\n+            hi: end.lo,\n+            ctxt: if end.ctxt == SyntaxContext::empty() {\n+                end.ctxt\n+            } else {\n+                self.ctxt\n+            }\n+        }\n+    }\n+\n+    pub fn until(self, end: Span) -> Span {\n+        Span {\n+            lo: self.lo,\n+            hi: end.lo,\n+            ctxt: if end.ctxt == SyntaxContext::empty() {\n+                end.ctxt\n+            } else {\n+                self.ctxt\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "f04394f716660e6a0460dd55efc98eba25635f88", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -39,8 +39,10 @@ pub trait Stats {\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n     /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n-    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n-    /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n+    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n+    /// Predicates\"][paper]\n+    ///\n+    /// [paper]: http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\n     fn sum(&self) -> f64;\n \n     /// Minimum value of the samples."}, {"sha": "9b8099d55a024eea1e7e8f80a2f6049c76c6aed4", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -35,7 +35,8 @@ fn main() {\n     } else if target.contains(\"dragonfly\") {\n         println!(\"cargo:rustc-link-lib=gcc_pic\");\n     } else if target.contains(\"windows-gnu\") {\n-        println!(\"cargo:rustc-link-lib=gcc_eh\");\n+        println!(\"cargo:rustc-link-lib=static-nobundle=gcc_eh\");\n+        println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     }"}, {"sha": "d4d52322adab0e5955b8ab98d1210e060337c64a", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -17,6 +17,7 @@\n #![feature(cfg_target_vendor)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n+#![feature(static_nobundle)]\n \n #![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n "}, {"sha": "e0de64b26df471fe857689099f1e9d62d94a91df", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-msvc\n+\n+// compile-flags: -O -C no-prepopulate-passes\n+\n+#![crate_type=\"lib\"]\n+\n+struct S;\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+fn might_unwind() {\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+pub fn test() {\n+    let _s = S;\n+    // Check that the personality slot alloca gets a lifetime start in each cleanup block, not just\n+    // in the first one.\n+    // CHECK-LABEL: cleanup:\n+    // CHECK: bitcast{{.*}}personalityslot\n+    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK-LABEL: cleanup1:\n+    // CHECK: bitcast{{.*}}personalityslot\n+    // CHECK-NEXT: call void @llvm.lifetime.start\n+    might_unwind();\n+    might_unwind();\n+}"}, {"sha": "68679d7dac896a22a04f855fdc6ca7aea911cf22", "filename": "src/test/compile-fail/feature-gate-used.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Ffeature-gate-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Ffeature-gate-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-used.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[used]\n+fn foo() {}\n+//~^^ ERROR the `#[used]` attribute is an experimental feature\n+\n+fn main() {}"}, {"sha": "aec20b4ad87b70ff77eef70a0dcf06c63757c1a4", "filename": "src/test/compile-fail/issue-40610.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fissue-40610.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fissue-40610.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40610.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f(_: &[f32]) {}\n+\n+fn main() {\n+    () + f(&[1.0]);\n+    //~^ ERROR binary operation `+` cannot be applied to type `()`\n+}"}, {"sha": "e525b3954f5edf8863f569b7f192f2acc17c0979", "filename": "src/test/compile-fail/issue-40861.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fissue-40861.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fissue-40861.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40861.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f(_: &[f32]) {}\n+\n+fn main() {\n+    ()[f(&[1.0])];\n+    //~^ ERROR cannot index a value of type `()`\n+}"}, {"sha": "7772cfd6a2c93894bd9e7e843661c6922b214c60", "filename": "src/test/compile-fail/windows-subsystem-invalid.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -10,7 +10,6 @@\n \n // error-pattern: invalid windows subsystem `wrong`, only `windows` and `console` are allowed\n \n-#![feature(windows_subsystem)]\n #![windows_subsystem = \"wrong\"]\n \n fn main() {}"}, {"sha": "e2fee1d18959194cf049a29e4f13cd93211cd1a1", "filename": "src/test/parse-fail/match-refactor-to-expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,7 +14,9 @@ fn main() {\n     let foo =\n         match //~ NOTE did you mean to remove this `match` keyword?\n         Some(4).unwrap_or_else(5)\n-        ; //~ ERROR expected one of `.`, `?`, `{`, or an operator, found `;`\n+        //~^ NOTE expected one of `.`, `?`, `{`, or an operator here\n+        ; //~ NOTE unexpected token\n+        //~^ ERROR expected one of `.`, `?`, `{`, or an operator, found `;`\n \n     println!(\"{}\", foo)\n }"}, {"sha": "e126422835cae8e050f8d01e908bfb003dfc8b7a", "filename": "src/test/run-make/multiple-emits/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fmultiple-emits%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fmultiple-emits%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmultiple-emits%2FMakefile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs --emit=asm,llvm-ir -o $(TMPDIR)/out 2>&1\n+\trm $(TMPDIR)/out.ll $(TMPDIR)/out.s\n+\t$(RUSTC) foo.rs --emit=asm,llvm-ir -o $(TMPDIR)/out2.ext 2>&1\n+\trm $(TMPDIR)/out2.ll $(TMPDIR)/out2.s"}, {"sha": "8ae3d072362ed6b5db81a00be3becce691926a7f", "filename": "src/test/run-make/multiple-emits/foo.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fmultiple-emits%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fmultiple-emits%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmultiple-emits%2Ffoo.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}"}, {"sha": "a996aa4fad5a7c247e0791430489ed8e61bdf4c3", "filename": "src/test/run-make/save-analysis-fail/foo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -448,3 +448,8 @@ fn test_format_args() {\n     print!(\"{0} + {} = {}\", x, y);\n     print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n }\n+\n+extern {\n+    static EXTERN_FOO: u8;\n+    fn extern_foo(a: u8, b: i32) -> String;\n+}"}, {"sha": "3fe1479f5f2ec2b0404ca6d037ebd41722adaca0", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -11,6 +11,7 @@\n #![ crate_name = \"test\" ]\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n+#![feature(associated_type_defaults)]\n \n extern crate graphviz;\n // A simple rust project\n@@ -441,3 +442,19 @@ fn test_format_args() {\n     print!(\"{0} + {} = {}\", x, y);\n     print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n }\n+\n+struct FrameBuffer;\n+\n+struct SilenceGenerator;\n+\n+impl Iterator for SilenceGenerator {\n+    type Item = FrameBuffer;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        panic!();\n+    }\n+}\n+\n+trait Foo {\n+    type Bar = FrameBuffer;\n+}"}, {"sha": "9d7aa30f874825068620a0b87b21e71bac0502d7", "filename": "src/test/run-make/used/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fused%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fused%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fused%2FMakefile?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+ifdef IS_WINDOWS\n+# Do nothing on MSVC.\n+all:\n+\texit 0\n+else\n+all:\n+\t$(RUSTC) -C opt-level=3 --emit=obj used.rs\n+\tnm $(TMPDIR)/used.o | grep FOO\n+endif"}, {"sha": "186cd0fdf5e35874ab42ad21424f7db28350ab71", "filename": "src/test/run-make/used/used.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fused%2Fused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fused%2Fused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fused%2Fused.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+#![feature(used)]\n+\n+#[used]\n+static FOO: u32 = 0;\n+\n+static BAR: u32 = 0;"}, {"sha": "ffad1e35ee6607df6e3a0854e5e8310690cdcf19", "filename": "src/test/run-make/windows-subsystem/console.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(windows_subsystem)]\n #![windows_subsystem = \"console\"]\n \n fn main() {}"}, {"sha": "33cbe32059190fb2c0bebe95db127534827a192b", "filename": "src/test/run-make/windows-subsystem/windows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(windows_subsystem)]\n #![windows_subsystem = \"windows\"]\n \n fn main() {}"}, {"sha": "f7f79356a0b9f22284b76925a49f0b2f82eca5ed", "filename": "src/test/run-pass/const-err.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-pass%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-pass%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-err.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -13,6 +13,10 @@\n #![deny(const_err)]\n \n const X: *const u8 = b\"\" as _;\n+const Y: bool = 'A' == 'B';\n+const Z: char = 'A';\n+const W: bool = Z <= 'B';\n+\n \n fn main() {\n     let _ = ((-1 as i8) << 8 - 1) as f32;"}, {"sha": "b35cfa12eab189d5b913c8344517ca846e51fd1e", "filename": "src/test/run-pass/issue-40962.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-pass%2Fissue-40962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frun-pass%2Fissue-40962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40962.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-windows_subsystem\n+macro_rules! m {\n+    ($i:meta) => {\n+        #[derive($i)]\n+        struct S;\n+    }\n+}\n \n-#![windows_subsystem = \"console\"]\n-//~^ ERROR: the windows subsystem attribute is currently unstable\n+m!(Clone);\n \n fn main() {}", "previous_filename": "src/test/compile-fail/windows-subsystem-gated.rs"}, {"sha": "f048b64d104abc82ab7e60521c05884c86506ee6", "filename": "src/test/rustdoc/check-hard-break.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-end-whitespace\n+\n+// @has foo/fn.f.html\n+// @has - '<p>hard break:<br />'\n+// @has - 'after hard break</p>'\n+/// hard break:  \n+/// after hard break\n+pub fn f() {}"}, {"sha": "46542677857fc797cc0461d335502f13d25a45ad", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-linelength\n+\n+// @has foo/fn.f.html\n+// @has - '<p>markdown test</p>'\n+// @has - '<p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p>'\n+// @has - '<hr />'\n+// @has - '<p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p>'\n+// @has - '<p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p>'\n+// @has - '<p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\" /></p>'\n+// @has - '<div class=\"footnotes\"><hr><ol><li id=\"ref1\">'\n+// @has - '<p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\">'\n+// @has - '<p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n+/// markdown test\n+///\n+/// this is a [link].\n+///\n+/// [link]: https://example.com \"this is a title\"\n+///\n+/// -----------\n+///\n+/// a footnote[^footnote].\n+///\n+/// another footnote[^footnotebis].\n+///\n+/// [^footnote]: Thing\n+///\n+///\n+/// [^footnotebis]: Another Thing\n+///\n+///\n+/// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n+pub fn f() {}"}, {"sha": "29f157e0425c90de1669310ee59b259960697464", "filename": "src/test/rustdoc/test-lists.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest-lists.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.f.html\n+// @has - //ol/li \"list\"\n+// @has - //ol/li/ol/li \"fooooo\"\n+// @has - //ol/li/ol/li \"x\"\n+// @has - //ol/li \"foo\"\n+/// 1. list\n+///     1. fooooo\n+///     2. x\n+/// 2. foo\n+pub fn f() {}\n+\n+// @has foo/fn.foo2.html\n+// @has - //ul/li \"normal list\"\n+// @has - //ul/li/ul/li \"sub list\"\n+// @has - //ul/li/ul/li \"new elem still same elem and again same elem!\"\n+// @has - //ul/li \"new big elem\"\n+/// * normal list\n+///     * sub list\n+///     * new elem\n+///       still same elem\n+///\n+///       and again same elem!\n+/// * new big elem\n+pub fn foo2() {}"}, {"sha": "a72ad0351e33baa323e44be565320ae08e6356ab", "filename": "src/test/ui/codemap_tests/coherence-overlapping-inherent-impl-trait.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -11,6 +11,6 @@\n #![allow(dead_code)]\n \n trait C {}\n-impl C { fn f() {} } //~ ERROR duplicate definitions with name `f`\n+impl C { fn f() {} }\n impl C { fn f() {} }\n fn main() { }", "previous_filename": "src/test/compile-fail/coherence-overlapping-inherent-impl-trait.rs"}, {"sha": "7f1ab929c6fc2b32fcbd4e0a18cd4341d08da5e8", "filename": "src/test/ui/codemap_tests/coherence-overlapping-inherent-impl-trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,10 @@\n+error[E0592]: duplicate definitions with name `f`\n+  --> $DIR/coherence-overlapping-inherent-impl-trait.rs:14:10\n+   |\n+14 | impl C { fn f() {} }\n+   |          ^^^^^^^^^ duplicate definitions for `f`\n+15 | impl C { fn f() {} }\n+   |          --------- other definition for `f`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a626b63b31ba0586fc3ef57105780f3f57e569cd", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -16,7 +16,7 @@\n struct Foo;\n \n impl Foo {\n-    fn id() {} //~ ERROR duplicate definitions\n+    fn id() {}\n }\n \n impl Foo {\n@@ -26,7 +26,7 @@ impl Foo {\n struct Bar<T>(T);\n \n impl<T> Bar<T> {\n-    fn bar(&self) {} //~ ERROR duplicate definitions\n+    fn bar(&self) {}\n }\n \n impl Bar<u32> {\n@@ -36,7 +36,7 @@ impl Bar<u32> {\n struct Baz<T>(T);\n \n impl<T: Copy> Baz<T> {\n-    fn baz(&self) {} //~ ERROR duplicate definitions\n+    fn baz(&self) {}\n }\n \n impl<T> Baz<Vec<T>> {", "previous_filename": "src/test/compile-fail/inherent-overlap.rs"}, {"sha": "de8a24cf33f44c12f0e70d3dbf57e99101a67e09", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,29 @@\n+error[E0592]: duplicate definitions with name `id`\n+  --> $DIR/overlapping_inherent_impls.rs:19:5\n+   |\n+19 |     fn id() {}\n+   |     ^^^^^^^^^^ duplicate definitions for `id`\n+...\n+23 |     fn id() {}\n+   |     ---------- other definition for `id`\n+\n+error[E0592]: duplicate definitions with name `bar`\n+  --> $DIR/overlapping_inherent_impls.rs:29:5\n+   |\n+29 |     fn bar(&self) {}\n+   |     ^^^^^^^^^^^^^^^^ duplicate definitions for `bar`\n+...\n+33 |     fn bar(&self) {}\n+   |     ---------------- other definition for `bar`\n+\n+error[E0592]: duplicate definitions with name `baz`\n+  --> $DIR/overlapping_inherent_impls.rs:39:5\n+   |\n+39 |     fn baz(&self) {}\n+   |     ^^^^^^^^^^^^^^^^ duplicate definitions for `baz`\n+...\n+43 |     fn baz(&self) {}\n+   |     ---------------- other definition for `baz`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "d7c8935560623118722a329e82234d7b59a97332", "filename": "src/test/ui/did_you_mean/issue-39544.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -51,3 +51,9 @@ pub fn with_arg(z: Z, w: &Z) {\n     let _ = &mut z.x;\n     let _ = &mut w.x;\n }\n+\n+pub fn with_tuple() {\n+    let mut y = 0;\n+    let x = (&y,);\n+    *x.0 = 1;\n+}"}, {"sha": "2e98bc65e9e9f0c268e3badf0b5e61bdc11f914a", "filename": "src/test/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -90,5 +90,11 @@ error: cannot borrow immutable field `w.x` as mutable\n 52 |     let _ = &mut w.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n-error: aborting due to 11 previous errors\n+error: cannot assign to immutable borrowed content `*x.0`\n+  --> $DIR/issue-39544.rs:58:5\n+   |\n+58 |     *x.0 = 1;\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "cf75929bae20ca35e53731b22138ad5492910929", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    pub hello_method(&self) {\n+        println!(\"Hello\");\n+    }\n+}\n+\n+fn main() {\n+    S.hello_method();\n+}"}, {"sha": "460958027ad0f2d574d68d3698ae32a80b01fd7f", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,8 @@\n+error: missing `fn` for method declaration\n+  --> $DIR/issue-40006.rs:14:8\n+   |\n+14 |     pub hello_method(&self) {\n+   |        ^ missing `fn`\n+\n+error: aborting due to previous error\n+"}, {"sha": "849787e383f107d2140ed9c97dcce388f2b9b140", "filename": "src/test/ui/resolve/token-error-correct-3.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,13 +14,16 @@ error: expected one of `,`, `.`, `?`, or an operator, found `;`\n   --> $DIR/token-error-correct-3.rs:23:35\n    |\n 23 |             callback(path.as_ref();  //~ NOTE: unclosed delimiter\n-   |                                   ^\n+   |                                   ^ expected one of `,`, `.`, `?`, or an operator here\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n   --> $DIR/token-error-correct-3.rs:29:9\n    |\n+25 |             fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: mismatched types\n+   |                                                             - expected one of `.`, `;`, `?`, `}`, or an operator here\n+...\n 29 |         } else { //~ ERROR: incorrect close delimiter: `}`\n-   |         ^\n+   |         ^ unexpected token\n \n error[E0425]: cannot find function `is_directory` in this scope\n   --> $DIR/token-error-correct-3.rs:21:13"}, {"sha": "226fa6469bc740f9403c0f8aa75050a68693574e", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -32,7 +32,7 @@ error: expected one of `)`, `,`, `.`, `<`, `?`, `break`, `continue`, `false`, `f\n   --> $DIR/token-error-correct.rs:14:13\n    |\n 14 |     foo(bar(;\n-   |             ^\n+   |             ^ expected one of 18 possible tokens here\n \n error: expected expression, found `)`\n   --> $DIR/token-error-correct.rs:23:1"}, {"sha": "98183e2f082e9f55b33da1dd5443306de6041d29", "filename": "src/test/ui/span/issue-34264.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -2,19 +2,19 @@ error: expected one of `:` or `@`, found `<`\n   --> $DIR/issue-34264.rs:11:14\n    |\n 11 | fn foo(Option<i32>, String) {}\n-   |              ^\n+   |              ^ expected one of `:` or `@` here\n \n error: expected one of `:` or `@`, found `)`\n   --> $DIR/issue-34264.rs:11:27\n    |\n 11 | fn foo(Option<i32>, String) {}\n-   |                           ^\n+   |                           ^ expected one of `:` or `@` here\n \n error: expected one of `:` or `@`, found `,`\n   --> $DIR/issue-34264.rs:12:9\n    |\n 12 | fn bar(x, y: usize) {}\n-   |         ^\n+   |         ^ expected one of `:` or `@` here\n \n error[E0061]: this function takes 2 parameters but 3 parameters were supplied\n   --> $DIR/issue-34264.rs:16:9"}, {"sha": "94cf38fb32f2f79a73b4b4bec297f79532936c33", "filename": "src/test/ui/suggestions/confuse-field-and-method/private-field.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod animal {\n+    pub struct Dog {\n+        pub age: usize,\n+        dog_age: usize,\n+    }\n+\n+    impl Dog {\n+        pub fn new(age: usize) -> Dog {\n+            Dog { age: age, dog_age: age * 7 }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let dog = animal::Dog::new(3);\n+    let dog_age = dog.dog_age();\n+    //let dog_age = dog.dog_age;\n+    println!(\"{}\", dog_age);\n+}"}, {"sha": "d07885915d2b7a1139bca563b7c986879ec62ab1", "filename": "src/test/ui/suggestions/confuse-field-and-method/private-field.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconfuse-field-and-method%2Fprivate-field.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,8 @@\n+error: no method named `dog_age` found for type `animal::Dog` in the current scope\n+  --> $DIR/private-field.rs:26:23\n+   |\n+26 |     let dog_age = dog.dog_age();\n+   |                       ^^^^^^^ private field, not a method\n+\n+error: aborting due to previous error\n+"}, {"sha": "02c119cf727fe473b0518fd58847eb07909cee6e", "filename": "src/test/ui/token/bounds-obj-parens.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -12,4 +12,6 @@\n \n type A = Box<(Fn(D::Error) -> E) + 'static + Send + Sync>; // OK (but see #39318)\n \n-FAIL //~ ERROR\n+FAIL\n+//~^ ERROR\n+//~| ERROR", "previous_filename": "src/test/parse-fail/bounds-obj-parens.rs"}, {"sha": "4d60be15ecaf0aae9a8801d4a1655831da71eb7a", "filename": "src/test/ui/token/bounds-obj-parens.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fbounds-obj-parens.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `!` or `::`, found `<eof>`\n+  --> $DIR/bounds-obj-parens.rs:15:1\n+   |\n+15 | FAIL\n+   | ^^^^ expected one of `!` or `::` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "93759123618fbac94701fea954325dc370335dc7", "filename": "src/test/ui/token/issue-10636-2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -14,5 +14,7 @@\n pub fn trace_option(option: Option<isize>) {\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n                           //~^ ERROR: expected one of\n+                          //~| NOTE: expected one of\n+                          //~| NOTE: unexpected token\n } //~ ERROR: incorrect close delimiter\n //~^ ERROR: expected expression, found `)`", "previous_filename": "src/test/compile-fail/issue-10636-2.rs"}, {"sha": "b0bae1248b9698442106d8a2654c8473da2c5ffc", "filename": "src/test/ui/token/issue-10636-2.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fissue-10636-2.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,28 @@\n+error: incorrect close delimiter: `}`\n+  --> $DIR/issue-10636-2.rs:19:1\n+   |\n+19 | } //~ ERROR: incorrect close delimiter\n+   | ^\n+   |\n+note: unclosed delimiter\n+  --> $DIR/issue-10636-2.rs:15:15\n+   |\n+15 |     option.map(|some| 42; //~ NOTE: unclosed delimiter\n+   |               ^\n+\n+error: expected one of `,`, `.`, `?`, or an operator, found `;`\n+  --> $DIR/issue-10636-2.rs:15:25\n+   |\n+15 |     option.map(|some| 42; //~ NOTE: unclosed delimiter\n+   |                         ^ expected one of `,`, `.`, `?`, or an operator here\n+\n+error: expected expression, found `)`\n+  --> $DIR/issue-10636-2.rs:19:1\n+   |\n+19 | } //~ ERROR: incorrect close delimiter\n+   | ^\n+\n+error: main function not found\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "47374fc3c608537d671aa2f526ba32d4d316f65f", "filename": "src/test/ui/token/macro-incomplete-parse.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -20,6 +20,8 @@ macro_rules! ignored_item {\n \n macro_rules! ignored_expr {\n     () => ( 1,  //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n+                //~^ NOTE expected one of `.`, `;`, `?`, `}`, or an operator here\n+                //~| NOTE unexpected token\n             2 )\n }\n ", "previous_filename": "src/test/compile-fail/macro-incomplete-parse.rs"}, {"sha": "f23d97586b843437002585034875cd2bca7dddd8", "filename": "src/test/ui/token/macro-incomplete-parse.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fmacro-incomplete-parse.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,32 @@\n+error: macro expansion ignores token `,` and any following\n+  --> $DIR/macro-incomplete-parse.rs:17:9\n+   |\n+17 |         , //~ ERROR macro expansion ignores token `,`\n+   |         ^\n+   |\n+note: caused by the macro expansion here; the usage of `ignored_item!` is likely invalid in item context\n+  --> $DIR/macro-incomplete-parse.rs:32:1\n+   |\n+32 | ignored_item!(); //~ NOTE caused by the macro expansion here\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n+  --> $DIR/macro-incomplete-parse.rs:22:14\n+   |\n+22 |     () => ( 1,  //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n+   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator here\n+\n+error: macro expansion ignores token `,` and any following\n+  --> $DIR/macro-incomplete-parse.rs:29:14\n+   |\n+29 |     () => ( 1, 2 ) //~ ERROR macro expansion ignores token `,`\n+   |              ^\n+   |\n+note: caused by the macro expansion here; the usage of `ignored_pat!` is likely invalid in pattern context\n+  --> $DIR/macro-incomplete-parse.rs:37:9\n+   |\n+37 |         ignored_pat!() => (), //~ NOTE caused by the macro expansion here\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "2bb2c97790c124fd4427acd4d6f1b1ad5947fa79", "filename": "src/test/ui/token/trailing-plus-in-bounds.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -16,4 +16,6 @@ fn main() {\n     let x: Box<Debug+> = box 3 as Box<Debug+>; // Trailing `+` is OK\n }\n \n-FAIL //~ ERROR\n+FAIL\n+//~^ ERROR\n+//~| ERROR", "previous_filename": "src/test/parse-fail/trailing-plus-in-bounds.rs"}, {"sha": "c765a434b8ac6e86ef1c6f5cffce28b847dea095", "filename": "src/test/ui/token/trailing-plus-in-bounds.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Ftrailing-plus-in-bounds.stderr?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `!` or `::`, found `<eof>`\n+  --> $DIR/trailing-plus-in-bounds.rs:19:1\n+   |\n+19 | FAIL\n+   | ^^^^ expected one of `!` or `::` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "efadde992277fefe4b0c6544375487aa47ea6449", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, MarkdownOutputStyle::Fancy))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}, {"sha": "0dbf0d4316abd9c2cdc92ee7794747168f7b69c7", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -75,7 +75,7 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/libtest\", // Probably should defer to unstable std::sys APIs\n \n     // std testing crates, ok for now at least\n-    \"src/libcoretest\",\n+    \"src/libcore/tests\",\n \n     // non-std crates\n     \"src/test\","}, {"sha": "012301299e0c54029a72cf35de4663bab803ff87", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c31412c2f84c7d76602b2598c5c1352da61d022/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=8c31412c2f84c7d76602b2598c5c1352da61d022", "patch": "@@ -110,6 +110,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let skip_cr = contents.contains(\"ignore-tidy-cr\");\n         let skip_tab = contents.contains(\"ignore-tidy-tab\");\n         let skip_length = contents.contains(\"ignore-tidy-linelength\");\n+        let skip_end_whitespace = contents.contains(\"ignore-tidy-end-whitespace\");\n         for (i, line) in contents.split(\"\\n\").enumerate() {\n             let mut err = |msg: &str| {\n                 println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n@@ -122,7 +123,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n             if line.contains(\"\\t\") && !skip_tab {\n                 err(\"tab character\");\n             }\n-            if line.ends_with(\" \") || line.ends_with(\"\\t\") {\n+            if !skip_end_whitespace && (line.ends_with(\" \") || line.ends_with(\"\\t\")) {\n                 err(\"trailing whitespace\");\n             }\n             if line.contains(\"\\r\") && !skip_cr {"}]}