{"sha": "2e1369c198e27da9eec015a9e11088e431feb50b", "node_id": "C_kwDOAAsO6NoAKDJlMTM2OWMxOThlMjdkYTllZWMwMTVhOWUxMTA4OGU0MzFmZWI1MGI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-04-26T14:40:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-05-15T11:43:33Z"}, "message": "Prevent to recompute `should_show_cast` by passing down `self_def_id`", "tree": {"sha": "6dc8da4a3d2f1a30ee751e04b1435216a43e5236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dc8da4a3d2f1a30ee751e04b1435216a43e5236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e1369c198e27da9eec015a9e11088e431feb50b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1369c198e27da9eec015a9e11088e431feb50b", "html_url": "https://github.com/rust-lang/rust/commit/2e1369c198e27da9eec015a9e11088e431feb50b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e1369c198e27da9eec015a9e11088e431feb50b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4054c0f3e6cecddadcc2aa19d7c97efed5611a4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4054c0f3e6cecddadcc2aa19d7c97efed5611a4b", "html_url": "https://github.com/rust-lang/rust/commit/4054c0f3e6cecddadcc2aa19d7c97efed5611a4b"}], "stats": {"total": 388, "additions": 191, "deletions": 197}, "files": [{"sha": "faac3a519af377d9b4b0c56b559600c6d2d81e36", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 191, "deletions": 197, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/2e1369c198e27da9eec015a9e11088e431feb50b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1369c198e27da9eec015a9e11088e431feb50b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e1369c198e27da9eec015a9e11088e431feb50b", "patch": "@@ -379,19 +379,31 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n+fn clean_projection<'tcx>(\n+    ty: ty::ProjectionTy<'tcx>,\n+    cx: &mut DocContext<'_>,\n+    def_id: Option<DefId>,\n+) -> Type {\n+    let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n+    let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n+    let self_type = ty.self_ty().clean(cx);\n+    let self_def_id = if let Some(def_id) = def_id {\n+        cx.tcx.opt_parent(def_id).or(Some(def_id))\n+    } else {\n+        self_type.def_id(&cx.cache)\n+    };\n+    let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+    Type::QPath {\n+        assoc: Box::new(projection_to_path_segment(ty, cx)),\n+        should_show_cast,\n+        self_type: box self_type,\n+        trait_,\n+    }\n+}\n+\n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n-        let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n-        let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n-        let self_type = self.self_ty().clean(cx);\n-        let self_def_id = self_type.def_id(&cx.cache);\n-        let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n-        Type::QPath {\n-            assoc: Box::new(projection_to_path_segment(*self, cx)),\n-            should_show_cast,\n-            self_type: box self_type,\n-            trait_,\n-        }\n+        clean_projection(*self, cx, None)\n     }\n }\n \n@@ -422,23 +434,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n             }\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default = if has_default {\n-                    let mut default = cx.tcx.type_of(self.def_id).clean(cx);\n-\n-                    // We need to reassign the `self_def_id`, if there's a parent (which is the\n-                    // `Self` type), so we can properly render `<Self as X>` casts, because the\n-                    // information about which type `Self` is, is only present here, but not in\n-                    // the cleaning process of the type itself. To resolve this and have the\n-                    // `self_def_id` set, we override it here.\n-                    // See https://github.com/rust-lang/rust/issues/85454\n-                    if let QPath { ref mut should_show_cast, ref trait_, ref self_type, .. } =\n-                        default\n-                    {\n-                        let self_def_id = cx.tcx.parent(self.def_id);\n-                        *should_show_cast =\n-                            compute_should_show_cast(self_def_id, trait_, self_type);\n-                    }\n-\n-                    Some(default)\n+                    Some(clean_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n                 } else {\n                     None\n                 };\n@@ -1534,196 +1530,194 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n-        trace!(\"cleaning type: {:?}\", self);\n-        let ty = normalize(cx, *self).unwrap_or(*self);\n-        match *ty.kind() {\n-            ty::Never => Primitive(PrimitiveType::Never),\n-            ty::Bool => Primitive(PrimitiveType::Bool),\n-            ty::Char => Primitive(PrimitiveType::Char),\n-            ty::Int(int_ty) => Primitive(int_ty.into()),\n-            ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n-            ty::Float(float_ty) => Primitive(float_ty.into()),\n-            ty::Str => Primitive(PrimitiveType::Str),\n-            ty::Slice(ty) => Slice(box ty.clean(cx)),\n-            ty::Array(ty, n) => {\n-                let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n-                n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n-                let n = print_const(cx, n);\n-                Array(box ty.clean(cx), n)\n-            }\n-            ty::RawPtr(mt) => RawPointer(mt.mutbl, box mt.ty.clean(cx)),\n-            ty::Ref(r, ty, mutbl) => {\n-                BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: box ty.clean(cx) }\n-            }\n-            ty::FnDef(..) | ty::FnPtr(_) => {\n-                let ty = cx.tcx.lift(*self).expect(\"FnPtr lift failed\");\n-                let sig = ty.fn_sig(cx.tcx);\n-                let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n-                BareFunction(box BareFunctionDecl {\n-                    unsafety: sig.unsafety(),\n-                    generic_params: Vec::new(),\n-                    decl,\n-                    abi: sig.abi(),\n-                })\n-            }\n-            ty::Adt(def, substs) => {\n-                let did = def.did();\n-                let kind = match def.adt_kind() {\n-                    AdtKind::Struct => ItemType::Struct,\n-                    AdtKind::Union => ItemType::Union,\n-                    AdtKind::Enum => ItemType::Enum,\n-                };\n-                inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, did, false, vec![], substs);\n-                Type::Path { path }\n-            }\n-            ty::Foreign(did) => {\n-                inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n-                let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n-                Type::Path { path }\n-            }\n-            ty::Dynamic(obj, ref reg) => {\n-                // HACK: pick the first `did` as the `did` of the trait object. Someone\n-                // might want to implement \"native\" support for marker-trait-only\n-                // trait objects.\n-                let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n-                let did = dids\n-                    .next()\n-                    .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", self));\n-                let substs = match obj.principal() {\n-                    Some(principal) => principal.skip_binder().substs,\n-                    // marker traits have no substs.\n-                    _ => cx.tcx.intern_substs(&[]),\n-                };\n+fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>) -> Type {\n+    trace!(\"cleaning type: {:?}\", this);\n+    let ty = normalize(cx, this).unwrap_or(this);\n+    match *ty.kind() {\n+        ty::Never => Primitive(PrimitiveType::Never),\n+        ty::Bool => Primitive(PrimitiveType::Bool),\n+        ty::Char => Primitive(PrimitiveType::Char),\n+        ty::Int(int_ty) => Primitive(int_ty.into()),\n+        ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n+        ty::Float(float_ty) => Primitive(float_ty.into()),\n+        ty::Str => Primitive(PrimitiveType::Str),\n+        ty::Slice(ty) => Slice(box ty.clean(cx)),\n+        ty::Array(ty, n) => {\n+            let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n+            n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n+            let n = print_const(cx, n);\n+            Array(box ty.clean(cx), n)\n+        }\n+        ty::RawPtr(mt) => RawPointer(mt.mutbl, box mt.ty.clean(cx)),\n+        ty::Ref(r, ty, mutbl) => {\n+            BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: box ty.clean(cx) }\n+        }\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let ty = cx.tcx.lift(this).expect(\"FnPtr lift failed\");\n+            let sig = ty.fn_sig(cx.tcx);\n+            let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n+            BareFunction(box BareFunctionDecl {\n+                unsafety: sig.unsafety(),\n+                generic_params: Vec::new(),\n+                decl,\n+                abi: sig.abi(),\n+            })\n+        }\n+        ty::Adt(def, substs) => {\n+            let did = def.did();\n+            let kind = match def.adt_kind() {\n+                AdtKind::Struct => ItemType::Struct,\n+                AdtKind::Union => ItemType::Union,\n+                AdtKind::Enum => ItemType::Enum,\n+            };\n+            inline::record_extern_fqn(cx, did, kind);\n+            let path = external_path(cx, did, false, vec![], substs);\n+            Type::Path { path }\n+        }\n+        ty::Foreign(did) => {\n+            inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n+            let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n+            Type::Path { path }\n+        }\n+        ty::Dynamic(obj, ref reg) => {\n+            // HACK: pick the first `did` as the `did` of the trait object. Someone\n+            // might want to implement \"native\" support for marker-trait-only\n+            // trait objects.\n+            let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n+            let did = dids\n+                .next()\n+                .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", this));\n+            let substs = match obj.principal() {\n+                Some(principal) => principal.skip_binder().substs,\n+                // marker traits have no substs.\n+                _ => cx.tcx.intern_substs(&[]),\n+            };\n \n-                inline::record_extern_fqn(cx, did, ItemType::Trait);\n+            inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n-                let lifetime = reg.clean(cx);\n-                let mut bounds = vec![];\n+            let lifetime = reg.clean(cx);\n+            let mut bounds = vec![];\n \n-                for did in dids {\n-                    let empty = cx.tcx.intern_substs(&[]);\n-                    let path = external_path(cx, did, false, vec![], empty);\n-                    inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                    let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n-                    bounds.push(bound);\n-                }\n+            for did in dids {\n+                let empty = cx.tcx.intern_substs(&[]);\n+                let path = external_path(cx, did, false, vec![], empty);\n+                inline::record_extern_fqn(cx, did, ItemType::Trait);\n+                let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n+                bounds.push(bound);\n+            }\n \n-                let mut bindings = vec![];\n-                for pb in obj.projection_bounds() {\n-                    bindings.push(TypeBinding {\n-                        assoc: projection_to_path_segment(\n-                            pb.skip_binder()\n-                                .lift_to_tcx(cx.tcx)\n-                                .unwrap()\n-                                // HACK(compiler-errors): Doesn't actually matter what self\n-                                // type we put here, because we're only using the GAT's substs.\n-                                .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n-                                .projection_ty,\n-                            cx,\n-                        ),\n-                        kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n-                    });\n-                }\n+            let mut bindings = vec![];\n+            for pb in obj.projection_bounds() {\n+                bindings.push(TypeBinding {\n+                    assoc: projection_to_path_segment(\n+                        pb.skip_binder()\n+                            .lift_to_tcx(cx.tcx)\n+                            .unwrap()\n+                            // HACK(compiler-errors): Doesn't actually matter what self\n+                            // type we put here, because we're only using the GAT's substs.\n+                            .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n+                            .projection_ty,\n+                        cx,\n+                    ),\n+                    kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n+                });\n+            }\n \n-                let path = external_path(cx, did, false, bindings, substs);\n-                bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n+            let path = external_path(cx, did, false, bindings, substs);\n+            bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n \n-                DynTrait(bounds, lifetime)\n-            }\n-            ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n+            DynTrait(bounds, lifetime)\n+        }\n+        ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n \n-            ty::Projection(ref data) => data.clean(cx),\n+        ty::Projection(ref data) => clean_projection(*data, cx, def_id),\n \n-            ty::Param(ref p) => {\n-                if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n-                    ImplTrait(bounds)\n-                } else {\n-                    Generic(p.name)\n-                }\n+        ty::Param(ref p) => {\n+            if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n+                ImplTrait(bounds)\n+            } else {\n+                Generic(p.name)\n             }\n+        }\n \n-            ty::Opaque(def_id, substs) => {\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the bounds associated with the def_id.\n-                let substs = cx.tcx.lift(substs).expect(\"Opaque lift failed\");\n-                let bounds = cx\n-                    .tcx\n-                    .explicit_item_bounds(def_id)\n-                    .iter()\n-                    .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n-                    .collect::<Vec<_>>();\n-                let mut regions = vec![];\n-                let mut has_sized = false;\n-                let mut bounds = bounds\n-                    .iter()\n-                    .filter_map(|bound| {\n-                        let bound_predicate = bound.kind();\n-                        let trait_ref = match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                                if let Some(r) = reg.clean(cx) {\n-                                    regions.push(GenericBound::Outlives(r));\n-                                }\n-                                return None;\n+        ty::Opaque(def_id, substs) => {\n+            // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+            // by looking up the bounds associated with the def_id.\n+            let substs = cx.tcx.lift(substs).expect(\"Opaque lift failed\");\n+            let bounds = cx\n+                .tcx\n+                .explicit_item_bounds(def_id)\n+                .iter()\n+                .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n+                .collect::<Vec<_>>();\n+            let mut regions = vec![];\n+            let mut has_sized = false;\n+            let mut bounds = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    let bound_predicate = bound.kind();\n+                    let trait_ref = match bound_predicate.skip_binder() {\n+                        ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n+                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                            if let Some(r) = reg.clean(cx) {\n+                                regions.push(GenericBound::Outlives(r));\n                             }\n-                            _ => return None,\n-                        };\n+                            return None;\n+                        }\n+                        _ => return None,\n+                    };\n \n-                        if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                            if trait_ref.def_id() == sized {\n-                                has_sized = true;\n-                                return None;\n-                            }\n+                    if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n+                        if trait_ref.def_id() == sized {\n+                            has_sized = true;\n+                            return None;\n                         }\n+                    }\n \n-                        let bindings: Vec<_> = bounds\n-                            .iter()\n-                            .filter_map(|bound| {\n-                                if let ty::PredicateKind::Projection(proj) =\n-                                    bound.kind().skip_binder()\n-                                {\n-                                    if proj.projection_ty.trait_ref(cx.tcx)\n-                                        == trait_ref.skip_binder()\n-                                    {\n-                                        Some(TypeBinding {\n-                                            assoc: projection_to_path_segment(\n-                                                proj.projection_ty,\n-                                                cx,\n-                                            ),\n-                                            kind: TypeBindingKind::Equality {\n-                                                term: proj.term.clean(cx),\n-                                            },\n-                                        })\n-                                    } else {\n-                                        None\n-                                    }\n+                    let bindings: Vec<_> = bounds\n+                        .iter()\n+                        .filter_map(|bound| {\n+                            if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder()\n+                            {\n+                                if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n+                                    Some(TypeBinding {\n+                                        assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                        kind: TypeBindingKind::Equality {\n+                                            term: proj.term.clean(cx),\n+                                        },\n+                                    })\n                                 } else {\n                                     None\n                                 }\n-                            })\n-                            .collect();\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .collect();\n \n-                        Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, &bindings))\n-                    })\n-                    .collect::<Vec<_>>();\n-                bounds.extend(regions);\n-                if !has_sized && !bounds.is_empty() {\n-                    bounds.insert(0, GenericBound::maybe_sized(cx));\n-                }\n-                ImplTrait(bounds)\n+                    Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, &bindings))\n+                })\n+                .collect::<Vec<_>>();\n+            bounds.extend(regions);\n+            if !has_sized && !bounds.is_empty() {\n+                bounds.insert(0, GenericBound::maybe_sized(cx));\n             }\n+            ImplTrait(bounds)\n+        }\n \n-            ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n+        ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n-            ty::Bound(..) => panic!(\"Bound\"),\n-            ty::Placeholder(..) => panic!(\"Placeholder\"),\n-            ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n-            ty::Infer(..) => panic!(\"Infer\"),\n-            ty::Error(_) => panic!(\"Error\"),\n-        }\n+        ty::Bound(..) => panic!(\"Bound\"),\n+        ty::Placeholder(..) => panic!(\"Placeholder\"),\n+        ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n+        ty::Infer(..) => panic!(\"Infer\"),\n+        ty::Error(_) => panic!(\"Error\"),\n+    }\n+}\n+\n+impl<'tcx> Clean<Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+        clean_ty(*self, cx, None)\n     }\n }\n "}]}