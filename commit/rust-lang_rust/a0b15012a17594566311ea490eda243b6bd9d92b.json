{"sha": "a0b15012a17594566311ea490eda243b6bd9d92b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYjE1MDEyYTE3NTk0NTY2MzExZWE0OTBlZGEyNDNiNmJkOWQ5MmI=", "commit": {"author": {"name": "moxian", "email": "moxian@google.com", "date": "2018-05-18T11:38:50Z"}, "committer": {"name": "moxian", "email": "moxian@google.com", "date": "2018-06-28T21:56:58Z"}, "message": "Make stackwalking generic instead of matching on enum variants.", "tree": {"sha": "2bc28470db41900192ef83d488ba8b2420fe2968", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bc28470db41900192ef83d488ba8b2420fe2968"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0b15012a17594566311ea490eda243b6bd9d92b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b15012a17594566311ea490eda243b6bd9d92b", "html_url": "https://github.com/rust-lang/rust/commit/a0b15012a17594566311ea490eda243b6bd9d92b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0b15012a17594566311ea490eda243b6bd9d92b/comments", "author": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b280f5f594fc6ff34ddcf35aa26cc46a073808", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b280f5f594fc6ff34ddcf35aa26cc46a073808", "html_url": "https://github.com/rust-lang/rust/commit/c0b280f5f594fc6ff34ddcf35aa26cc46a073808"}], "stats": {"total": 280, "additions": 147, "deletions": 133}, "files": [{"sha": "7ef4e203571b28e6624138655fd58252de1bb403", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "modified", "additions": 147, "deletions": 133, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/a0b15012a17594566311ea490eda243b6bd9d92b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b15012a17594566311ea490eda243b6bd9d92b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=a0b15012a17594566311ea490eda243b6bd9d92b", "patch": "@@ -47,7 +47,7 @@ mod printing;\n pub mod gnu;\n \n pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-use self::printing::{load_printing_fns_ex, load_printing_fns_64};\n+use self::printing::{load_printing_fns_64, load_printing_fns_ex};\n \n pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n     let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n@@ -56,20 +56,15 @@ pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceCon\n     let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n     let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n \n-\n     // StackWalkEx might not be present and we'll fall back to StackWalk64\n     let sw_var = match sym!(dbghelp, \"StackWalkEx\", StackWalkExFn) {\n-         Ok(StackWalkEx) =>\n-            StackWalkVariant::StackWalkEx(\n-                StackWalkEx,\n-                load_printing_fns_ex(&dbghelp)?,\n-            ),\n+        Ok(StackWalkEx) => {\n+            StackWalkVariant::StackWalkEx(StackWalkEx, load_printing_fns_ex(&dbghelp)?)\n+        }\n         Err(e) => match sym!(dbghelp, \"StackWalk64\", StackWalk64Fn) {\n-            Ok(StackWalk64) =>\n-                StackWalkVariant::StackWalk64(\n-                    StackWalk64,\n-                    load_printing_fns_64(&dbghelp)?,\n-                ),\n+            Ok(StackWalk64) => {\n+                StackWalkVariant::StackWalk64(StackWalk64, load_printing_fns_64(&dbghelp)?)\n+            }\n             Err(..) => return Err(e),\n         },\n     };\n@@ -92,101 +87,38 @@ pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceCon\n \n     // And now that we're done with all the setup, do the stack walking!\n     match backtrace_context.StackWalkVariant {\n-        StackWalkVariant::StackWalkEx(f, _) => set_frames_ex(f, frames, backtrace_context, process),\n-        StackWalkVariant::StackWalk64(f, _) => set_frames_64(f, frames, backtrace_context, process),\n-    }\n-}\n-\n-fn set_frames_ex(\n-    StackWalkEx: StackWalkExFn,\n-    frames: &mut [Frame],\n-    backtrace_context: BacktraceContext,\n-    process: c::HANDLE,\n-) -> io::Result<(usize, BacktraceContext)> {\n-    let thread = unsafe { c::GetCurrentProcess() };\n-    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n-    unsafe { c::RtlCaptureContext(&mut context) };\n-\n-    let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n-    frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n-    let image = init_frame_ex(&mut frame, &context);\n+        StackWalkVariant::StackWalkEx(StackWalkEx, _) => {\n+            set_frames(StackWalkEx, frames).map(|i| (i, backtrace_context))\n+        }\n \n-    let mut i = 0;\n-    unsafe {\n-        while i < frames.len()\n-            && StackWalkEx(\n-                image,\n-                process,\n-                thread,\n-                &mut frame,\n-                &mut context,\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                0,\n-            ) == c::TRUE\n-        {\n-            let addr = (frame.AddrPC.Offset - 1) as *const u8;\n-\n-            frames[i] = Frame {\n-                symbol_addr: addr,\n-                exact_position: addr,\n-                inline_context: frame.InlineFrameContext,\n-            };\n-            i += 1;\n+        StackWalkVariant::StackWalk64(StackWalk64, _) => {\n+            set_frames(StackWalk64, frames).map(|i| (i, backtrace_context))\n         }\n     }\n-\n-    Ok((i, backtrace_context))\n }\n \n-fn set_frames_64(\n-    StackWalk64: StackWalk64Fn,\n-    frames: &mut [Frame],\n-    backtrace_context: BacktraceContext,\n-    process: c::HANDLE,\n-) -> io::Result<(usize, BacktraceContext)> {\n+fn set_frames<W: StackWalker>(StackWalk: W, frames: &mut [Frame]) -> io::Result<usize> {\n+    let process = unsafe { c::GetCurrentProcess() };\n     let thread = unsafe { c::GetCurrentProcess() };\n     let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n     unsafe { c::RtlCaptureContext(&mut context) };\n+    let mut frame = W::Item::new();\n+    let image = frame.init(&context);\n \n-    let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n-    let image = init_frame_64(&mut frame, &context);\n-\n-    // Start from -1 to avoid printing this stack frame, which will\n-    // always be exactly the same.\n     let mut i = 0;\n-    unsafe {\n-        while i < frames.len()\n-            && StackWalk64(\n-                image,\n-                process,\n-                thread,\n-                &mut frame,\n-                &mut context,\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-                ptr::null_mut(),\n-            ) == c::TRUE\n-        {\n-            let addr = frame.AddrPC.Offset;\n-            if addr == frame.AddrReturn.Offset || addr == 0 || frame.AddrReturn.Offset == 0\n-            {\n-                break;\n-            }\n-\n-            frames[i] = Frame {\n-                symbol_addr: (addr - 1) as *const u8,\n-                exact_position: (addr - 1) as *const u8,\n-                inline_context: 0,\n-            };\n-            i += 1;\n-        }\n+    while i < frames.len()\n+        && StackWalk.walk(image, process, thread, &mut frame, &mut context) == c::TRUE\n+    {\n+        let addr = frame.get_addr();\n+        frames[i] = Frame {\n+            symbol_addr: addr,\n+            exact_position: addr,\n+            inline_context: 0,\n+        };\n+\n+        i += 1\n     }\n-\n-    Ok((i, backtrace_context))\n+    Ok(i)\n }\n \n type SymInitializeFn = unsafe extern \"system\" fn(c::HANDLE, *mut c_void, c::BOOL) -> c::BOOL;\n@@ -217,56 +149,138 @@ type StackWalk64Fn = unsafe extern \"system\" fn(\n     *mut c_void,\n ) -> c::BOOL;\n \n-#[cfg(target_arch = \"x86\")]\n-fn init_frame_ex(frame: &mut c::STACKFRAME_EX, ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Eip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Esp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Ebp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_I386\n+trait StackWalker {\n+    type Item: StackFrame;\n+\n+    fn walk(&self, c::DWORD, c::HANDLE, c::HANDLE, &mut Self::Item, &mut c::CONTEXT) -> c::BOOL;\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n-fn init_frame_ex(frame: &mut c::STACKFRAME_EX, ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Rip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Rsp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Rbp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_AMD64\n+impl StackWalker for StackWalkExFn {\n+    type Item = c::STACKFRAME_EX;\n+    fn walk(\n+        &self,\n+        image: c::DWORD,\n+        process: c::HANDLE,\n+        thread: c::HANDLE,\n+        frame: &mut Self::Item,\n+        context: &mut c::CONTEXT,\n+    ) -> c::BOOL {\n+        unsafe {\n+            self(\n+                image,\n+                process,\n+                thread,\n+                frame,\n+                context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                0,\n+            )\n+        }\n+    }\n+}\n+\n+impl StackWalker for StackWalk64Fn {\n+    type Item = c::STACKFRAME64;\n+    fn walk(\n+        &self,\n+        image: c::DWORD,\n+        process: c::HANDLE,\n+        thread: c::HANDLE,\n+        frame: &mut Self::Item,\n+        context: &mut c::CONTEXT,\n+    ) -> c::BOOL {\n+        unsafe {\n+            self(\n+                image,\n+                process,\n+                thread,\n+                frame,\n+                context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            )\n+        }\n+    }\n+}\n+\n+trait StackFrame {\n+    fn new() -> Self;\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD;\n+    fn get_addr(&self) -> *const u8;\n }\n \n-#[cfg(target_arch = \"x86\")]\n-fn init_frame_64(frame: &mut c::STACKFRAME64, ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Eip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Esp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Ebp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_I386\n+impl StackFrame for c::STACKFRAME_EX {\n+    fn new() -> c::STACKFRAME_EX {\n+        unsafe { mem::zeroed() }\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Eip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Esp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Ebp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_I386\n+    }\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Rip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Rsp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Rbp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_AMD64\n+    }\n+\n+    fn get_addr(&self) -> *const u8 {\n+        (self.AddrPC.Offset - 1) as *const u8\n+    }\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n-fn init_frame_64(frame: &mut c::STACKFRAME64, ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Rip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Rsp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Rbp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_AMD64\n+impl StackFrame for c::STACKFRAME64 {\n+    fn new() -> c::STACKFRAME64 {\n+        unsafe { mem::zeroed() }\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Eip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Esp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Ebp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_I386\n+    }\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Rip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Rsp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Rbp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_AMD64\n+    }\n+\n+    fn get_addr(&self) -> *const u8 {\n+        (self.AddrPC.Offset - 1) as *const u8\n+    }\n }\n \n enum StackWalkVariant {\n     StackWalkEx(StackWalkExFn, printing::PrintingFnsEx),\n     StackWalk64(StackWalk64Fn, printing::PrintingFns64),\n }\n \n-\n pub struct BacktraceContext {\n     handle: c::HANDLE,\n     SymCleanup: SymCleanupFn,"}]}