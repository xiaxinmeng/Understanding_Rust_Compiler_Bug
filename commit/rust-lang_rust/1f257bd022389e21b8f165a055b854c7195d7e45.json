{"sha": "1f257bd022389e21b8f165a055b854c7195d7e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMjU3YmQwMjIzODllMjFiOGYxNjVhMDU1Yjg1NGM3MTk1ZDdlNDU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-27T17:23:54Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-27T23:56:12Z"}, "message": "resolve: Make sure macros and imports are resolved in full parent scope\n\nSlightly simplify `fn build_reduced_graph_for_use_tree`", "tree": {"sha": "43c4f910975a7a5cea2ea08fc6a5b8e1285ddabb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43c4f910975a7a5cea2ea08fc6a5b8e1285ddabb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f257bd022389e21b8f165a055b854c7195d7e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f257bd022389e21b8f165a055b854c7195d7e45", "html_url": "https://github.com/rust-lang/rust/commit/1f257bd022389e21b8f165a055b854c7195d7e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f257bd022389e21b8f165a055b854c7195d7e45/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acdbd0643cc3d7bd74826c0f13746c81c08d6cc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/acdbd0643cc3d7bd74826c0f13746c81c08d6cc1", "html_url": "https://github.com/rust-lang/rust/commit/acdbd0643cc3d7bd74826c0f13746c81c08d6cc1"}], "stats": {"total": 169, "additions": 83, "deletions": 86}, "files": [{"sha": "328d5bb3af06943ca20f70e37c62de4d00125a25", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1f257bd022389e21b8f165a055b854c7195d7e45", "patch": "@@ -111,23 +111,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn build_reduced_graph_for_use_tree(\n         &mut self,\n-        root_use_tree: &ast::UseTree,\n-        root_id: NodeId,\n+        // This particular use tree\n         use_tree: &ast::UseTree,\n         id: NodeId,\n-        vis: ty::Visibility,\n         parent_prefix: &[Segment],\n-        mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n-        item: &Item,\n+        mut uniform_paths_canary_emitted: bool,\n+        // The whole `use` item\n         parent_scope: ParentScope<'a>,\n+        item: &Item,\n+        vis: ty::Visibility,\n+        root_span: Span,\n     ) {\n         debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n                 uniform_paths_canary_emitted={}, \\\n                 use_tree={:?}, nested={})\",\n                parent_prefix, uniform_paths_canary_emitted, use_tree, nested);\n \n-        let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n         let uniform_paths =\n             self.session.rust_2018() &&\n             self.session.features_untracked().uniform_paths;\n@@ -215,8 +215,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     subclass,\n                     source.ident.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     ty::Visibility::Invisible,\n                     parent_scope.clone(),\n                     true, // is_uniform_paths_canary\n@@ -345,25 +345,25 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     subclass,\n                     use_tree.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     vis,\n                     parent_scope,\n                     false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n                 let subclass = GlobImport {\n-                    is_prelude,\n+                    is_prelude: attr::contains_name(&item.attrs, \"prelude_import\"),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n                     prefix,\n                     subclass,\n                     use_tree.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     vis,\n                     parent_scope,\n                     false, // is_uniform_paths_canary\n@@ -394,16 +394,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n-                        root_use_tree,\n-                        root_id,\n-                        tree,\n-                        id,\n-                        vis,\n-                        &prefix,\n-                        uniform_paths_canary_emitted,\n-                        true,\n-                        item,\n-                        parent_scope.clone(),\n+                        // This particular use tree\n+                        tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        // The whole `use` item\n+                        parent_scope.clone(), item, vis, root_span,\n                     );\n                 }\n             }\n@@ -421,16 +415,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n-                    use_tree,\n-                    item.id,\n-                    use_tree,\n-                    item.id,\n-                    vis,\n-                    &[],\n-                    false, // uniform_paths_canary_emitted\n-                    false,\n-                    item,\n-                    parent_scope,\n+                    // This particular use tree\n+                    use_tree, item.id, &[], false, false,\n+                    // The whole `use` item\n+                    parent_scope, item, vis, use_tree.span,\n                 );\n             }\n "}, {"sha": "def67923322aaabdd06f5809c8394d63627276f6", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=1f257bd022389e21b8f165a055b854c7195d7e45", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use {CrateLint, PathResult, Segment};\n+use macros::ParentScope;\n \n use std::collections::BTreeSet;\n \n@@ -23,7 +24,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Segment>\n+        path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n         // If we don't have a path to suggest changes to, then return.\n@@ -40,10 +42,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n                 debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n \n-                self.make_missing_self_suggestion(span, path.clone())\n-                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_missing_super_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path))\n+                self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n+                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone(),\n+                                                                   parent_scope))\n+                    .or_else(|| self.make_missing_super_suggestion(span, path.clone(),\n+                                                                   parent_scope))\n+                    .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n             },\n             _ => None,\n         }\n@@ -59,11 +63,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfValue.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -82,11 +87,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -105,11 +111,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -131,7 +138,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n         // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n@@ -149,7 +157,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // Replace the first after root (a placeholder we inserted) with a crate name\n             // and check if that is valid.\n             path[1].ident.name = *name;\n-            let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+            let result =\n+                self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {"}, {"sha": "397c67e7587b94c352b8e1ac6161800befc52c78", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1f257bd022389e21b8f165a055b854c7195d7e45", "patch": "@@ -1054,7 +1054,7 @@ pub struct ModuleData<'a> {\n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n                                            Option<&'a NameBinding<'a>>)>>,\n-    macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n+    macro_resolutions: RefCell<Vec<(Vec<Segment>, ParentScope<'a>, Span)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1668,22 +1668,15 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        let def = match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+        let def = match self.resolve_path_without_parent_scope(None, &path, Some(namespace),\n+                                                               true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 path_res.base_def(),\n             PathResult::NonModule(..) => {\n-                if let PathResult::Failed(span, msg, _) = self.resolve_path(\n-                    None,\n-                    &path,\n-                    None,\n-                    true,\n-                    span,\n-                    CrateLint::No,\n-                ) {\n-                    error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n+                let msg = \"type-relative paths are not supported in this context\";\n+                error_callback(self, span, ResolutionError::FailedToResolve(msg));\n                 Def::Err\n             }\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n@@ -2530,10 +2523,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                    self.resolve_path(\n+                    self.resolve_path_without_parent_scope(\n                         None,\n                         &path,\n-                        None,\n+                        Some(TypeNS),\n                         false,\n                         span,\n                         CrateLint::SimplePath(trait_ref.ref_id),\n@@ -3055,8 +3048,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(None, mod_path, Some(TypeNS),\n-                                                             false, span, CrateLint::No) {\n+                    let mod_prefix = match this.resolve_path_without_parent_scope(\n+                        None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                    ) {\n                         PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                             module.def(),\n                         _ => None,\n@@ -3540,7 +3534,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ));\n         }\n \n-        let result = match self.resolve_path(\n+        let result = match self.resolve_path_without_parent_scope(\n             None,\n             &path,\n             Some(ns),\n@@ -3587,7 +3581,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].ident.name != keywords::CrateRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n-                match self.resolve_path(\n+                match self.resolve_path_without_parent_scope(\n                     None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n@@ -3610,7 +3604,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         Some(result)\n     }\n \n-    fn resolve_path(\n+    fn resolve_path_without_parent_scope(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n@@ -3619,12 +3613,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n+        // Macro and import paths must have full parent scope available during resolution,\n+        // other paths will do okay with parent module alone.\n+        assert!(opt_ns != None && opt_ns != Some(MacroNS));\n         let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n-        self.resolve_path_with_parent_scope(base_module, path, opt_ns, &parent_scope,\n-                                            record_used, path_span, crate_lint)\n+        self.resolve_path(base_module, path, opt_ns, &parent_scope,\n+                          record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_parent_scope(\n+    fn resolve_path(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n@@ -3820,7 +3817,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         PathResult::Module(module.unwrap_or_else(|| {\n             span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n         }))\n-\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -4104,8 +4100,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(None, mod_path, Some(TypeNS),\n-                                                                  false, span, CrateLint::No) {\n+            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n+                None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     add_module_candidates(module, &mut names);\n                 }"}, {"sha": "d5f344346c2d17238fe4bd89eec7322b4bb72d5a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1f257bd022389e21b8f165a055b854c7195d7e45", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         parent_scope: &ParentScope<'a>,\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n-        let span = path.span;\n+        let path_span = path.span;\n         let mut path = Segment::from_path(path);\n \n         // Possibly apply the macro helper hack\n@@ -474,15 +474,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_parent_scope(None, &path, Some(MacroNS),\n-                                                                parent_scope, false, span,\n-                                                                CrateLint::No) {\n+            let def = match self.resolve_path(None, &path, Some(MacroNS), parent_scope,\n+                                              false, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n                         if path_res.unresolved_segments() > 0 {\n                             self.found_unresolved_macro = true;\n-                            self.session.span_err(span, \"fail to resolve non-ident macro path\");\n+                            self.session.span_err(path_span,\n+                                                  \"fail to resolve non-ident macro path\");\n                             Err(Determinacy::Determined)\n                         } else {\n                             Ok(def)\n@@ -498,16 +498,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path\n-                    .iter()\n-                    .map(|seg| seg.ident)\n-                    .collect::<Vec<Ident>>()\n-                    .into_boxed_slice(), span));\n+                .push((path, parent_scope.clone(), path_span));\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, span\n+                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -851,9 +847,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n-        for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            let path: Vec<_> = path.iter().map(|&ident| Segment::from_ident(ident)).collect();\n-            match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n+\n+        let macro_resolutions =\n+            mem::replace(&mut *module.macro_resolutions.borrow_mut(), Vec::new());\n+        for (mut path, parent_scope, path_span) in macro_resolutions {\n+            // FIXME: Path resolution will ICE if segment IDs present.\n+            for seg in &mut path { seg.id = None; }\n+            match self.resolve_path(None, &path, Some(MacroNS), &parent_scope,\n+                                    true, path_span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "3ca0a9f7f1b973bd16bdcbdeeb440b9b790845ea", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f257bd022389e21b8f165a055b854c7195d7e45/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1f257bd022389e21b8f165a055b854c7195d7e45", "patch": "@@ -877,6 +877,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }),\n                 &directive.module_path[..],\n                 None,\n+                &directive.parent_scope,\n                 false,\n                 directive.span,\n                 directive.crate_lint(),\n@@ -956,6 +957,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }),\n             &module_path,\n             None,\n+            &directive.parent_scope,\n             true,\n             span,\n             directive.crate_lint(),\n@@ -968,7 +970,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 return if let Some(suggested_path) = self.make_path_suggestion(\n-                    span, module_path.clone()\n+                    span, module_path.clone(), &directive.parent_scope\n                 ) {\n                     Some((\n                         span,"}]}