{"sha": "bbff48e09463618dde1627883a350b7427ae6d44", "node_id": "C_kwDOAAsO6NoAKGJiZmY0OGUwOTQ2MzYxOGRkZTE2Mjc4ODNhMzUwYjc0MjdhZTZkNDQ", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-26T17:29:37Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-26T17:29:37Z"}, "message": "Merge commit '39683d8eb7a32a74bea96ecbf1e87675d3338506' into sync_cg_gcc-2022-03-26", "tree": {"sha": "84d7f352faf7b9dc8f37d379b9f79311160bf7fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84d7f352faf7b9dc8f37d379b9f79311160bf7fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbff48e09463618dde1627883a350b7427ae6d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbff48e09463618dde1627883a350b7427ae6d44", "html_url": "https://github.com/rust-lang/rust/commit/bbff48e09463618dde1627883a350b7427ae6d44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbff48e09463618dde1627883a350b7427ae6d44/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891", "html_url": "https://github.com/rust-lang/rust/commit/1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891"}, {"sha": "39683d8eb7a32a74bea96ecbf1e87675d3338506", "url": "https://api.github.com/repos/rust-lang/rust/commits/39683d8eb7a32a74bea96ecbf1e87675d3338506", "html_url": "https://github.com/rust-lang/rust/commit/39683d8eb7a32a74bea96ecbf1e87675d3338506"}], "stats": {"total": 2263, "additions": 1705, "deletions": 558}, "files": [{"sha": "337837c40bfb86eb03fcb00a01b576af1156116d", "filename": "compiler/rustc_codegen_gcc/.github/workflows/ci.yml", "status": "renamed", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -10,30 +10,43 @@ jobs:\n \n     strategy:\n       fail-fast: false\n+      matrix:\n+        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\"]\n \n     steps:\n     - uses: actions/checkout@v2\n \n+    - uses: actions/checkout@v2\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n     - name: Install packages\n       run: sudo apt-get install ninja-build ripgrep\n \n     - name: Download artifact\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: libgccjit.so\n+          name: ${{ matrix.libgccjit_version }}\n           path: gcc-build\n           repo: antoyo/gcc\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n \n     - name: Setup path to libgccjit\n       run: |\n           echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n           ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n \n-    - name: Set LIBRARY_PATH\n+    - name: Set env\n       run: |\n         echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n         echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n     # https://github.com/actions/cache/issues/133\n     - name: Fixup owner of ~/.cargo/", "previous_filename": "compiler/rustc_codegen_gcc/.github/workflows/main.yml"}, {"sha": "efda74b2633aedb0f50449b1500e9cd0f46ed0f9", "filename": "compiler/rustc_codegen_gcc/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.gitignore?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -18,3 +18,4 @@ gimple*\n res\n test-backend\n gcc_path\n+benchmarks"}, {"sha": "a1d9f2f5e3822a813641c02e93d869e4e028aa19", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "27b30e0fd1b336a11de9f2bf6c184d0354ec60fb", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -21,6 +21,8 @@ You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already i\n ```bash\n $ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n $ cd rustc_codegen_gcc\n+$ git clone https://github.com/llvm/llvm-project llvm --depth 1 --single-branch\n+$ export RUST_COMPILER_RT_ROOT=\"$PWD/llvm/compiler-rt\"\n $ ./prepare_build.sh # download and patch sysroot src\n $ ./build.sh --release\n ```\n@@ -109,6 +111,13 @@ Or add a breakpoint to `add_error` in gdb and print the line number using:\n \n ```\n p loc->m_line\n+p loc->m_filename->m_buffer\n+```\n+\n+To print a debug representation of a tree:\n+\n+```c\n+debug_tree(expr);\n ```\n \n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n@@ -134,4 +143,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n  * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n+ * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "230ab7b6d42baf42715936bb3805c8e71ef4eb8b", "filename": "compiler/rustc_codegen_gcc/build.sh", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild.sh?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -3,7 +3,27 @@\n #set -x\n set -e\n \n-if [ -f ./gcc_path ]; then \n+codegen_channel=debug\n+sysroot_channel=debug\n+\n+while [[ $# -gt 0 ]]; do\n+    case $1 in\n+        --release)\n+            codegen_channel=release\n+            shift\n+            ;;\n+        --release-sysroot)\n+            sysroot_channel=release\n+            shift\n+            ;;\n+        *)\n+            echo \"Unknown option $1\"\n+            exit 1\n+            ;;\n+    esac\n+done\n+\n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -13,13 +33,21 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n-if [[ \"$1\" == \"--release\" ]]; then\n+features=\n+\n+if [[ \"$1\" == \"--features\" ]]; then\n+    shift\n+    features=\"--features $1\"\n+    shift\n+fi\n+\n+if [[ \"$codegen_channel\" == \"release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release\n+    CARGO_INCREMENTAL=1 cargo rustc --release $features\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc\n+    cargo rustc $features\n fi\n \n source config.sh\n@@ -28,4 +56,9 @@ rm -r target/out || true\n mkdir -p target/out/gccjit\n \n echo \"[BUILD] sysroot\"\n-time ./build_sysroot/build_sysroot.sh $CHANNEL\n+if [[ \"$sysroot_channel\" == \"release\" ]]; then\n+    time ./build_sysroot/build_sysroot.sh --release\n+else\n+    time ./build_sysroot/build_sysroot.sh\n+fi\n+"}, {"sha": "a965ca971a07d362635049c8a40a138800d20a60", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -22,7 +22,7 @@ if [[ \"$1\" == \"--release\" ]]; then\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release\n else\n     sysroot_channel='debug'\n-    cargo build --target $TARGET_TRIPLE\n+    cargo build --target $TARGET_TRIPLE --features compiler_builtins/c\n fi\n \n # Copy files to sysroot"}, {"sha": "332f365ce0ceed7cc0cf71fc6c08f51b3e69f4fa", "filename": "compiler/rustc_codegen_gcc/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fcargo.sh?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -8,7 +8,7 @@ pushd $(dirname \"$0\") >/dev/null\n source config.sh\n \n # read nightly compiler from rust-toolchain file\n-TOOLCHAIN=$(cat rust-toolchain)\n+TOOLCHAIN=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n \n popd >/dev/null\n "}, {"sha": "a8435287d9fde698eb89c37a44b4c32dc5e3f4a5", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -14,6 +14,9 @@ unsafe extern \"C\" fn _Unwind_Resume() {\n #[lang = \"sized\"]\n pub trait Sized {}\n \n+#[lang = \"destruct\"]\n+pub trait Destruct {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -59,6 +62,7 @@ unsafe impl Copy for i16 {}\n unsafe impl Copy for i32 {}\n unsafe impl Copy for isize {}\n unsafe impl Copy for f32 {}\n+unsafe impl Copy for f64 {}\n unsafe impl Copy for char {}\n unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n unsafe impl<T: ?Sized> Copy for *const T {}\n@@ -443,12 +447,22 @@ pub trait Deref {\n     fn deref(&self) -> &Self::Target;\n }\n \n+pub trait Allocator {\n+}\n+\n+pub struct Global;\n+\n+impl Allocator for Global {}\n+\n #[lang = \"owned_box\"]\n-pub struct Box<T: ?Sized>(*mut T);\n+pub struct Box<\n+    T: ?Sized,\n+    A: Allocator = Global,\n+>(*mut T, A);\n \n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n-impl<T: ?Sized> Drop for Box<T> {\n+impl<T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler.\n     }\n@@ -468,7 +482,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: *mut T, alloc: A) {\n     libc::free(ptr as *mut u8);\n }\n "}, {"sha": "301b3f9bde4dd73ff882ffbe675b4e2053758984", "filename": "compiler/rustc_codegen_gcc/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -22,7 +22,7 @@ index 0000000..46fd999\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n-+edition = \"2018\"\n++edition = \"2021\"\n +\n +[lib]\n +name = \"coretests\""}, {"sha": "ee5ba449fb8e6bb0ee310eea54ac65a01ec8842a", "filename": "compiler/rustc_codegen_gcc/patches/0023-core-Ignore-failing-tests.patch", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -46,24 +46,4 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 3e00e0a..8e5663b 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n-@@ -2108,6 +2108,7 @@ fn test_copy_within_panics_src_out_of_bounds() {\n-     bytes.copy_within(usize::MAX..=usize::MAX, 0);\n- }\n- \n-+/*\n- #[test]\n- fn test_is_sorted() {\n-     let empty: [i32; 0] = [];\n-@@ -2122,6 +2123,7 @@ fn test_is_sorted() {\n-     assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n-     assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n- }\n-+*/\n- \n- #[test]\n- fn test_slice_run_destructors() {\n -- 2.21.0 (Apple Git-122)"}, {"sha": "03900ba101a900b67f484827b237a9842449a9cc", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "modified", "additions": 208, "deletions": 4, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -7,18 +7,222 @@ Subject: [PATCH] [core] Disable portable-simd test\n  library/core/tests/lib.rs | 1 -\n  1 file changed, 1 deletion(-)\n \n+diff --git a/library/core/src/lib.rs b/library/core/src/lib.rs\n+index aa1ad93..95fbf55 100644\n+--- a/library/core/src/lib.rs\n++++ b/library/core/src/lib.rs\n+@@ -398,23 +398,4 @@ pub mod arch {\n+     }\n+ }\n+ \n+-// Pull in the `core_simd` crate directly into libcore. The contents of\n+-// `core_simd` are in a different repository: rust-lang/portable-simd.\n+-//\n+-// `core_simd` depends on libcore, but the contents of this module are\n+-// set up in such a way that directly pulling it here works such that the\n+-// crate uses this crate as its libcore.\n+-#[path = \"../../portable-simd/crates/core_simd/src/mod.rs\"]\n+-#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n+-#[allow(rustdoc::bare_urls)]\n+-#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-mod core_simd;\n+-\n+-#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n+-#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-pub mod simd {\n+-    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-    pub use crate::core_simd::simd::*;\n+-}\n+-\n+ include!(\"primitive_docs.rs\");\n+diff --git a/library/core/src/slice/mod.rs b/library/core/src/slice/mod.rs\n+index cd38c3a..ad632dc 100644\n+--- a/library/core/src/slice/mod.rs\n++++ b/library/core/src/slice/mod.rs\n+@@ -17,6 +17,5 @@ use crate::ptr;\n+ use crate::result::Result;\n+ use crate::result::Result::{Err, Ok};\n+-use crate::simd::{self, Simd};\n+ use crate::slice;\n+ \n+ #[unstable(\n+@@ -3475,121 +3474,6 @@ impl<T> [T] {\n+         }\n+     }\n+ \n+-    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+-    ///\n+-    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n+-    /// postconditions as that method.  You're only assured that\n+-    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+-    ///\n+-    /// Notably, all of the following are possible:\n+-    /// - `prefix.len() >= LANES`.\n+-    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+-    /// - `suffix.len() >= LANES`.\n+-    ///\n+-    /// That said, this is a safe method, so if you're only writing safe code,\n+-    /// then this can at most cause incorrect logic, not unsoundness.\n+-    ///\n+-    /// # Panics\n+-    ///\n+-    /// This will panic if the size of the SIMD type is different from\n+-    /// `LANES` times that of the scalar.\n+-    ///\n+-    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+-    /// that from ever happening, as only power-of-two numbers of lanes are\n+-    /// supported.  It's possible that, in the future, those restrictions might\n+-    /// be lifted in a way that would make it possible to see panics from this\n+-    /// method for something like `LANES == 3`.\n+-    ///\n+-    /// # Examples\n+-    ///\n+-    /// ```\n+-    /// #![feature(portable_simd)]\n+-    ///\n+-    /// let short = &[1, 2, 3];\n+-    /// let (prefix, middle, suffix) = short.as_simd::<4>();\n+-    /// assert_eq!(middle, []); // Not enough elements for anything in the middle\n+-    ///\n+-    /// // They might be split in any possible way between prefix and suffix\n+-    /// let it = prefix.iter().chain(suffix).copied();\n+-    /// assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n+-    ///\n+-    /// fn basic_simd_sum(x: &[f32]) -> f32 {\n+-    ///     use std::ops::Add;\n+-    ///     use std::simd::f32x4;\n+-    ///     let (prefix, middle, suffix) = x.as_simd();\n+-    ///     let sums = f32x4::from_array([\n+-    ///         prefix.iter().copied().sum(),\n+-    ///         0.0,\n+-    ///         0.0,\n+-    ///         suffix.iter().copied().sum(),\n+-    ///     ]);\n+-    ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n+-    ///     sums.reduce_sum()\n+-    /// }\n+-    ///\n+-    /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n+-    /// assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n+-    /// ```\n+-    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T])\n+-    where\n+-        Simd<T, LANES>: AsRef<[T; LANES]>,\n+-        T: simd::SimdElement,\n+-        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+-    {\n+-        // These are expected to always match, as vector types are laid out like\n+-        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+-        // might as well double-check since it'll optimize away anyhow.\n+-        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+-\n+-        // SAFETY: The simd types have the same layout as arrays, just with\n+-        // potentially-higher alignment, so the de-facto transmutes are sound.\n+-        unsafe { self.align_to() }\n+-    }\n+-\n+-    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+-    ///\n+-    /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n+-    /// postconditions as that method.  You're only assured that\n+-    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+-    ///\n+-    /// Notably, all of the following are possible:\n+-    /// - `prefix.len() >= LANES`.\n+-    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+-    /// - `suffix.len() >= LANES`.\n+-    ///\n+-    /// That said, this is a safe method, so if you're only writing safe code,\n+-    /// then this can at most cause incorrect logic, not unsoundness.\n+-    ///\n+-    /// This is the mutable version of [`slice::as_simd`]; see that for examples.\n+-    ///\n+-    /// # Panics\n+-    ///\n+-    /// This will panic if the size of the SIMD type is different from\n+-    /// `LANES` times that of the scalar.\n+-    ///\n+-    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+-    /// that from ever happening, as only power-of-two numbers of lanes are\n+-    /// supported.  It's possible that, in the future, those restrictions might\n+-    /// be lifted in a way that would make it possible to see panics from this\n+-    /// method for something like `LANES == 3`.\n+-    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])\n+-    where\n+-        Simd<T, LANES>: AsMut<[T; LANES]>,\n+-        T: simd::SimdElement,\n+-        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+-    {\n+-        // These are expected to always match, as vector types are laid out like\n+-        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+-        // might as well double-check since it'll optimize away anyhow.\n+-        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+-\n+-        // SAFETY: The simd types have the same layout as arrays, just with\n+-        // potentially-higher alignment, so the de-facto transmutes are sound.\n+-        unsafe { self.align_to_mut() }\n+-    }\n+-\n+     /// Checks if the elements of this slice are sorted.\n+     ///\n+     /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n-index ec70034..7cd9e21 100644\n+index 06c7be0..359e2e7 100644\n --- a/library/core/tests/lib.rs\n +++ b/library/core/tests/lib.rs\n-@@ -121,7 +121,6 @@ mod pattern;\n- mod pin;\n+@@ -75,7 +75,6 @@\n+ #![feature(never_type)]\n+ #![feature(unwrap_infallible)]\n+ #![feature(result_into_ok_or_err)]\n+-#![feature(portable_simd)]\n+ #![feature(ptr_metadata)]\n+ #![feature(once_cell)]\n+ #![feature(option_result_contains)]\n+@@ -127,7 +126,6 @@ mod pin;\n+ mod pin_macro;\n  mod ptr;\n  mod result;\n -mod simd;\n  mod slice;\n  mod str;\n  mod str_lossy;\n--- \n+diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs\n+index 5dc586d..b6fc48f 100644\n+--- a/library/std/src/lib.rs\n++++ b/library/std/src/lib.rs\n+@@ -312,6 +312,5 @@\n+ #![feature(panic_can_unwind)]\n+ #![feature(panic_unwind)]\n+ #![feature(platform_intrinsics)]\n+-#![feature(portable_simd)]\n+ #![feature(prelude_import)]\n+ #![feature(ptr_as_uninit)]\n+@@ -508,23 +508,6 @@ pub mod time;\n+ #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+ pub mod lazy;\n+ \n+-// Pull in `std_float` crate  into libstd. The contents of\n+-// `std_float` are in a different repository: rust-lang/portable-simd.\n+-#[path = \"../../portable-simd/crates/std_float/src/lib.rs\"]\n+-#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n+-#[allow(rustdoc::bare_urls)]\n+-#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-mod std_float;\n+-\n+-#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n+-#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+-pub mod simd {\n+-    #[doc(inline)]\n+-    pub use crate::std_float::StdFloat;\n+-    #[doc(inline)]\n+-    pub use core::simd::*;\n+-}\n+-\n+ #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+ pub mod task {\n+     //! Types and Traits for working with asynchronous tasks.\n+--\n 2.26.2.7.g19db9cfb68\n "}, {"sha": "dc1beae6d2e71311801af88a5d8b496c0cbc51a4", "filename": "compiler/rustc_codegen_gcc/patches/0028-core-Disable-long-running-tests.patch", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,30 +1,32 @@\n-From 0ffdd8eda8df364391c8ac6e1ce92c73ba9254d4 Mon Sep 17 00:00:00 2001\n+From eb703e627e7a84f1cd8d0d87f0f69da1f0acf765 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Fri, 3 Dec 2021 12:16:30 +0100\n Subject: [PATCH] Disable long running tests\n \n ---\n- library/core/tests/slice.rs | 3 +++\n- 1 file changed, 3 insertions(+)\n+ library/core/tests/slice.rs | 2 ++\n+ 1 file changed, 2 insertions(+)\n \n diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 2c8f00a..44847ee 100644\n+index 8402833..84592e0 100644\n --- a/library/core/tests/slice.rs\n +++ b/library/core/tests/slice.rs\n-@@ -2332,7 +2332,8 @@ macro_rules! empty_max_mut {\n-     };\n- }\n+@@ -2462,6 +2462,7 @@ take_tests! {\n+ #[cfg(not(miri))] // unused in Miri\n+ const EMPTY_MAX: &'static [()] = &[(); usize::MAX];\n  \n +/*\n- #[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n- take_tests! {\n-     slice: &[(); usize::MAX], method: take,\n-     (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n-@@ -2345,3 +2347,4 @@ take_tests! {\n+ // can't be a constant due to const mutability rules\n+ #[cfg(not(miri))] // unused in Miri\n+ macro_rules! empty_max_mut {\n+@@ -2485,6 +2486,7 @@ take_tests! {\n      (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n      (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n  }\n +*/\n+ \n+ #[test]\n+ fn test_slice_from_ptr_range() {\n -- \n 2.26.2.7.g19db9cfb68\n "}, {"sha": "3896775a0b9d27045c0dee3754bbade61027f28e", "filename": "compiler/rustc_codegen_gcc/prepare_build.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,5 +1,4 @@\n #!/bin/bash --verbose\n set -e\n \n-rustup component add rust-src rustc-dev llvm-tools-preview\n ./build_sysroot/prepare_sysroot_src.sh"}, {"sha": "db14ea2bebca557044f875a723bdae0fb54cd56e", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1 +1,3 @@\n-nightly-2021-12-30\n+[toolchain]\n+channel = \"nightly-2022-03-26\"\n+components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "2c796d0f69e593f92efba98ff69cfd0299c1a698", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,5 +1,6 @@\n-use gccjit::{ToRValue, Type};\n+use gccjit::{ToLValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{AbiBuilderMethods, BaseTypeMethods};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::bug;\n use rustc_middle::ty::Ty;\n use rustc_target::abi::call::{CastTarget, FnAbi, PassMode, Reg, RegKind};\n@@ -15,9 +16,21 @@ impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn get_param(&mut self, index: usize) -> Self::Value {\n-        self.cx.current_func.borrow().expect(\"current func\")\n-            .get_param(index as i32)\n-            .to_rvalue()\n+        let func = self.current_func();\n+        let param = func.get_param(index as i32);\n+        let on_stack =\n+            if let Some(on_stack_param_indices) = self.on_stack_function_params.borrow().get(&func) {\n+                on_stack_param_indices.contains(&index)\n+            }\n+            else {\n+                false\n+            };\n+        if on_stack {\n+            param.to_lvalue().get_address(None)\n+        }\n+        else {\n+            param.to_rvalue()\n+        }\n     }\n }\n \n@@ -87,12 +100,13 @@ impl GccType for Reg {\n \n pub trait FnAbiGccExt<'gcc, 'tcx> {\n     // TODO(antoyo): return a function pointer type instead?\n-    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool);\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>);\n     fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n }\n \n impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n-    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool) {\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>) {\n+        let mut on_stack_param_indices = FxHashSet::default();\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() {\n                 1\n@@ -144,17 +158,22 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     unimplemented!();\n                 }\n                 PassMode::Cast(cast) => cast.gcc_type(cx),\n-                PassMode::Indirect { extra_attrs: None, .. } => cx.type_ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n+                    on_stack_param_indices.insert(argument_tys.len());\n+                    arg.memory_ty(cx)\n+                },\n+                PassMode::Indirect { extra_attrs: None, on_stack: false, .. } => cx.type_ptr_to(arg.memory_ty(cx)),\n             };\n             argument_tys.push(arg_ty);\n         }\n \n-        (return_ty, argument_tys, self.c_variadic)\n+        (return_ty, argument_tys, self.c_variadic, on_stack_param_indices)\n     }\n \n     fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        let (return_type, params, variadic) = self.gcc_type(cx);\n+        let (return_type, params, variadic, on_stack_param_indices) = self.gcc_type(cx);\n         let pointer_type = cx.context.new_function_pointer_type(None, return_type, &params, variadic);\n+        cx.on_stack_params.borrow_mut().insert(pointer_type.dyncast_function_ptr_type().expect(\"function ptr type\"), on_stack_param_indices);\n         pointer_type\n     }\n }"}, {"sha": "b503bd020f6bb87a24267ca96edeb177fc06df43", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -45,7 +45,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 if env::var(\"CG_GCCJIT_DUMP_MODULE_NAMES\").as_deref() == Ok(\"1\") {\n                     println!(\"Module {}\", module.name);\n                 }\n-                if env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n+                if env::var(\"CG_GCCJIT_DUMP_ALL_MODULES\").as_deref() == Ok(\"1\") || env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n                     println!(\"Dumping reproducer {}\", module.name);\n                     let _ = fs::create_dir(\"/tmp/reproducers\");\n                     // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n@@ -54,6 +54,11 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                     context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n                     println!(\"Dumped reproducer {}\", module.name);\n                 }\n+                if env::var(\"CG_GCCJIT_DUMP_TO_FILE\").as_deref() == Ok(\"1\") {\n+                    let _ = fs::create_dir(\"/tmp/gccjit_dumps\");\n+                    let path = &format!(\"/tmp/gccjit_dumps/{}.c\", module.name);\n+                    context.dump_to_file(path, true);\n+                }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n             }\n "}, {"sha": "f5aca35cdcbc4e3bc90398e76af00ed514bbfe07", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -52,15 +52,15 @@ pub fn linkage_to_gcc(linkage: Linkage) -> FunctionType {\n     }\n }\n \n-pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<GccContext>, u64) {\n+pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n     let (module, _) = tcx.dep_graph.with_task(\n         dep_node,\n         tcx,\n-        cgu_name,\n+        (cgu_name, supports_128bit_integers),\n         module_codegen,\n         Some(dep_graph::hash_result),\n     );\n@@ -71,7 +71,7 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n     // the time we needed for codegenning it.\n     let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n \n-    fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<GccContext> {\n+    fn module_codegen(tcx: TyCtxt<'_>, (cgu_name, supports_128bit_integers): (Symbol, bool)) -> ModuleCodegen<GccContext> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n@@ -85,6 +85,12 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n         // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n         context.add_command_line_option(\"-fno-strict-aliasing\");\n+\n+        if tcx.sess.opts.debugging_opts.function_sections.unwrap_or(tcx.sess.target.function_sections) {\n+            context.add_command_line_option(\"-ffunction-sections\");\n+            context.add_command_line_option(\"-fdata-sections\");\n+        }\n+\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }\n@@ -99,8 +105,11 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n             context.set_keep_intermediates(true);\n         }\n \n+        // TODO(bjorn3): Remove once unwinding is properly implemented\n+        context.set_allow_unreachable_blocks(true);\n+\n         {\n-            let cx = CodegenCx::new(&context, cgu, tcx);\n+            let cx = CodegenCx::new(&context, cgu, tcx, supports_128bit_integers);\n \n             let mono_items = cgu.items_in_deterministic_order(tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {"}, {"sha": "b2f46e92eccbf72bb150d2e447b0c4719216326f", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 100, "deletions": 252, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -30,6 +30,7 @@ use rustc_codegen_ssa::traits::{\n     OverflowOp,\n     StaticBuilderMethods,\n };\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -80,21 +81,21 @@ impl EnumClone for AtomicOrdering {\n \n pub struct Builder<'a: 'gcc, 'gcc, 'tcx> {\n     pub cx: &'a CodegenCx<'gcc, 'tcx>,\n-    pub block: Option<Block<'gcc>>,\n+    pub block: Block<'gcc>,\n     stack_var_count: Cell<usize>,\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n-    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>) -> Self {\n+    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n         Builder {\n             cx,\n-            block: None,\n+            block,\n             stack_var_count: Cell::new(0),\n         }\n     }\n \n     fn atomic_extremum(&mut self, operation: ExtremumOperation, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type()) / 8;\n+        let size = src.get_type().get_size();\n \n         let func = self.current_func();\n \n@@ -114,10 +115,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let after_block = func.new_block(\"after_while\");\n         self.llbb().end_with_jump(None, while_block);\n \n-        // NOTE: since jumps were added and compare_exchange doesn't expect this, the current blocks in the\n+        // NOTE: since jumps were added and compare_exchange doesn't expect this, the current block in the\n         // state need to be updated.\n-        self.block = Some(while_block);\n-        *self.cx.current_block.borrow_mut() = Some(while_block);\n+        self.switch_to_block(while_block);\n \n         let comparison_operator =\n             match operation {\n@@ -132,17 +132,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         while_block.end_with_conditional(None, cond, while_block, after_block);\n \n-        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n         // state need to be updated.\n-        self.block = Some(after_block);\n-        *self.cx.current_block.borrow_mut() = Some(after_block);\n+        self.switch_to_block(after_block);\n \n         return_value.to_rvalue()\n     }\n \n     fn compare_exchange(&self, dst: RValue<'gcc>, cmp: LValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type());\n-        let compare_exchange = self.context.get_builtin_function(&format!(\"__atomic_compare_exchange_{}\", size / 8));\n+        let size = src.get_type().get_size();\n+        let compare_exchange = self.context.get_builtin_function(&format!(\"__atomic_compare_exchange_{}\", size));\n         let order = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n         let failure_order = self.context.new_rvalue_from_int(self.i32_type, failure_order.to_gcc());\n         let weak = self.context.new_rvalue_from_int(self.bool_type, weak as i32);\n@@ -209,6 +208,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             param_types.push(param);\n         }\n \n+        let mut on_stack_param_indices = FxHashSet::default();\n+        if let Some(indices) = self.on_stack_params.borrow().get(&gcc_func) {\n+            on_stack_param_indices = indices.clone();\n+        }\n+\n         if all_args_match {\n             return Cow::Borrowed(args);\n         }\n@@ -217,10 +221,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             .into_iter()\n             .zip(args.iter())\n             .enumerate()\n-            .map(|(_i, (expected_ty, &actual_val))| {\n+            .map(|(index, (expected_ty, &actual_val))| {\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    self.bitcast(actual_val, expected_ty)\n+                    if on_stack_param_indices.contains(&index) {\n+                        actual_val.dereference(None).to_rvalue()\n+                    }\n+                    else {\n+                        self.bitcast(actual_val, expected_ty)\n+                    }\n                 }\n                 else {\n                     actual_val\n@@ -245,7 +254,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     pub fn current_func(&self) -> Function<'gcc> {\n-        self.block.expect(\"block\").get_function()\n+        self.block.get_function()\n     }\n \n     fn function_call(&mut self, func: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n@@ -256,17 +265,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n         let return_type = func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+            self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n             result.to_rvalue()\n         }\n         else {\n-            current_block.add_eval(None, self.cx.context.new_call(None, func, &args));\n+            self.block.add_eval(None, self.cx.context.new_call(None, func, &args));\n             // Return dummy value when not having return value.\n             self.context.new_rvalue_from_long(self.isize_type, 0)\n         }\n@@ -279,9 +287,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // That's why we assign the result to a local or call add_eval().\n         let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n \n         // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n         if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n@@ -290,35 +297,34 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n         else {\n             if gcc_func.get_param_count() == 0 {\n                 // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n             }\n             else {\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             }\n             // Return dummy value when not having return value.\n             let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n-            current_block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n+            self.block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n             result.to_rvalue()\n         }\n     }\n \n-    pub fn overflow_call(&mut self, func: Function<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    pub fn overflow_call(&self, func: Function<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local.\n         let return_type = self.context.new_type::<bool>();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         // TODO(antoyo): return the new_call() directly? Since the overflow function has no side-effects.\n         unsafe { RETURN_VALUE_COUNT += 1 };\n-        let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-        current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+        let result = current_func.new_local(None, return_type, &format!(\"overflowReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+        self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n         result.to_rvalue()\n     }\n }\n@@ -384,14 +390,11 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n-        let mut bx = Builder::with_cx(cx);\n-        *cx.current_block.borrow_mut() = Some(block);\n-        bx.block = Some(block);\n-        bx\n+        Builder::with_cx(cx, block)\n     }\n \n     fn llbb(&self) -> Block<'gcc> {\n-        self.block.expect(\"block\")\n+        self.block\n     }\n \n     fn append_block(cx: &'a CodegenCx<'gcc, 'tcx>, func: RValue<'gcc>, name: &str) -> Block<'gcc> {\n@@ -405,8 +408,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn switch_to_block(&mut self, block: Self::BasicBlock) {\n-        *self.cx.current_block.borrow_mut() = Some(block);\n-        self.block = Some(block);\n+        self.block = block;\n     }\n \n     fn ret_void(&mut self) {\n@@ -441,67 +443,58 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             let on_val = self.const_uint_big(typ, on_val);\n             gcc_cases.push(self.context.new_case(on_val, on_val, dest));\n         }\n-        self.block.expect(\"block\").end_with_switch(None, value, default_block, &gcc_cases);\n+        self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(&mut self, _typ: Type<'gcc>, _func: RValue<'gcc>, _args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let condition = self.context.new_rvalue_from_int(self.bool_type, 0);\n+    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        // TODO(bjorn3): Properly implement unwinding.\n+        let call_site = self.call(typ, func, args, None);\n+        let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n-        self.context.new_rvalue_from_int(self.int_type, 0)\n-\n-        // TODO(antoyo)\n+        call_site\n     }\n \n     fn unreachable(&mut self) {\n         let func = self.context.get_builtin_function(\"__builtin_unreachable\");\n-        let block = self.block.expect(\"block\");\n-        block.add_eval(None, self.context.new_call(None, func, &[]));\n-        let return_type = block.get_function().get_return_type();\n+        self.block.add_eval(None, self.context.new_call(None, func, &[]));\n+        let return_type = self.block.get_function().get_return_type();\n         let void_type = self.context.new_type::<()>();\n         if return_type == void_type {\n-            block.end_with_void_return(None)\n+            self.block.end_with_void_return(None)\n         }\n         else {\n             let return_value = self.current_func()\n                 .new_local(None, return_type, \"unreachableReturn\");\n-            block.end_with_return(None, return_value)\n+            self.block.end_with_return(None, return_value)\n         }\n     }\n \n-    fn add(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): this should not be required.\n-        if format!(\"{:?}\", a.get_type()) != format!(\"{:?}\", b.get_type()) {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a + b\n+    fn add(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_add(a, b)\n     }\n \n     fn fadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a + b\n     }\n \n-    fn sub(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a - b\n+    fn sub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_sub(a, b)\n     }\n \n     fn fsub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a - b\n     }\n \n     fn mul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a * b\n+        self.gcc_mul(a, b)\n     }\n \n     fn fmul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a * b\n     }\n \n     fn udiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to unsigned?\n-        a / b\n+        self.gcc_udiv(a, b)\n     }\n \n     fn exactudiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -511,8 +504,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn sdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to signed?\n-        a / b\n+        self.gcc_sdiv(a, b)\n     }\n \n     fn exactsdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -529,11 +521,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn urem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a % b\n+        self.gcc_urem(a, b)\n     }\n \n     fn srem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a % b\n+        self.gcc_srem(a, b)\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -549,104 +541,49 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn shl(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a << b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a << b\n-        }\n-        else {\n-            a << b\n-        }\n+        self.gcc_shl(a, b)\n     }\n \n     fn lshr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        // TODO(antoyo): cast to unsigned to do a logical shift if that does not work.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a >> b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a >> b\n-        }\n-        else {\n-            a >> b\n-        }\n+        self.gcc_lshr(a, b)\n     }\n \n     fn ashr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check whether behavior is an arithmetic shift for >> .\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a >> b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a >> b\n-        }\n-        else {\n-            a >> b\n-        }\n+        // It seems to be if the value is signed.\n+        self.gcc_lshr(a, b)\n     }\n \n-    fn and(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a & b\n+    fn and(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_and(a, b)\n     }\n \n-    fn or(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a | b\n+    fn or(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.cx.gcc_or(a, b)\n     }\n \n     fn xor(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a ^ b\n+        self.gcc_xor(a, b)\n     }\n \n     fn neg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n+        self.gcc_neg(a)\n     }\n \n     fn fneg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n         self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n     }\n \n     fn not(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        let operation =\n-            if a.get_type().is_bool() {\n-                UnaryOp::LogicalNegate\n-            }\n-            else {\n-                UnaryOp::BitwiseNegate\n-            };\n-        self.cx.context.new_unary_op(None, operation, a.get_type(), a)\n+        self.gcc_not(a)\n     }\n \n     fn unchecked_sadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a + b\n     }\n \n     fn unchecked_uadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a + b\n+        self.gcc_add(a, b)\n     }\n \n     fn unchecked_ssub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -655,7 +592,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn unchecked_usub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): should generate poison value?\n-        a - b\n+        self.gcc_sub(a, b)\n     }\n \n     fn unchecked_smul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -687,76 +624,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n-        use rustc_middle::ty::{Int, IntTy::*, Uint, UintTy::*};\n-\n-        let new_kind =\n-            match typ.kind() {\n-                Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n-                Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n-                t @ (Uint(_) | Int(_)) => t.clone(),\n-                _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n-            };\n-\n-        // TODO(antoyo): remove duplication with intrinsic?\n-        let name =\n-            match oop {\n-                OverflowOp::Add =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_add_overflow\",\n-                        Int(I16) => \"__builtin_add_overflow\",\n-                        Int(I32) => \"__builtin_sadd_overflow\",\n-                        Int(I64) => \"__builtin_saddll_overflow\",\n-                        Int(I128) => \"__builtin_add_overflow\",\n-\n-                        Uint(U8) => \"__builtin_add_overflow\",\n-                        Uint(U16) => \"__builtin_add_overflow\",\n-                        Uint(U32) => \"__builtin_uadd_overflow\",\n-                        Uint(U64) => \"__builtin_uaddll_overflow\",\n-                        Uint(U128) => \"__builtin_add_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-                OverflowOp::Sub =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_sub_overflow\",\n-                        Int(I16) => \"__builtin_sub_overflow\",\n-                        Int(I32) => \"__builtin_ssub_overflow\",\n-                        Int(I64) => \"__builtin_ssubll_overflow\",\n-                        Int(I128) => \"__builtin_sub_overflow\",\n-\n-                        Uint(U8) => \"__builtin_sub_overflow\",\n-                        Uint(U16) => \"__builtin_sub_overflow\",\n-                        Uint(U32) => \"__builtin_usub_overflow\",\n-                        Uint(U64) => \"__builtin_usubll_overflow\",\n-                        Uint(U128) => \"__builtin_sub_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-                OverflowOp::Mul =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_mul_overflow\",\n-                        Int(I16) => \"__builtin_mul_overflow\",\n-                        Int(I32) => \"__builtin_smul_overflow\",\n-                        Int(I64) => \"__builtin_smulll_overflow\",\n-                        Int(I128) => \"__builtin_mul_overflow\",\n-\n-                        Uint(U8) => \"__builtin_mul_overflow\",\n-                        Uint(U16) => \"__builtin_mul_overflow\",\n-                        Uint(U32) => \"__builtin_umul_overflow\",\n-                        Uint(U64) => \"__builtin_umulll_overflow\",\n-                        Uint(U128) => \"__builtin_mul_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-            };\n-\n-        let intrinsic = self.context.get_builtin_function(&name);\n-        let res = self.current_func()\n-            // TODO(antoyo): is it correct to use rhs type instead of the parameter typ?\n-            .new_local(None, rhs.get_type(), \"binopResult\")\n-            .get_address(None);\n-        let overflow = self.overflow_call(intrinsic, &[lhs, rhs, res], None);\n-        (res.dereference(None).to_rvalue(), overflow)\n+        self.gcc_checked_binop(oop, typ, lhs, rhs)\n     }\n \n     fn alloca(&mut self, ty: Type<'gcc>, align: Align) -> RValue<'gcc> {\n@@ -1006,7 +874,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     /* Casts */\n     fn trunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check that it indeed truncate the value.\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_int_cast(value, dest_ty)\n     }\n \n     fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1019,19 +887,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn fptoui(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_float_to_uint_cast(value, dest_ty)\n     }\n \n     fn fptosi(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_float_to_int_cast(value, dest_ty)\n     }\n \n     fn uitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_uint_to_float_cast(value, dest_ty)\n     }\n \n     fn sitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_int_to_float_cast(value, dest_ty)\n     }\n \n     fn fptrunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1044,11 +912,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn ptrtoint(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.ptrtoint(self.block.expect(\"block\"), value, dest_ty)\n+        let usize_value = self.cx.const_bitcast(value, self.cx.type_isize());\n+        self.intcast(usize_value, dest_ty, false)\n     }\n \n     fn inttoptr(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.inttoptr(self.block.expect(\"block\"), value, dest_ty)\n+        let usize_value = self.intcast(value, self.cx.type_isize(), false);\n+        self.cx.const_bitcast(usize_value, dest_ty)\n     }\n \n     fn bitcast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1057,7 +927,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn intcast(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>, _is_signed: bool) -> RValue<'gcc> {\n         // NOTE: is_signed is for value, not dest_typ.\n-        self.cx.context.new_cast(None, value, dest_typ)\n+        self.gcc_int_cast(value, dest_typ)\n     }\n \n     fn pointercast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1078,44 +948,24 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     /* Comparisons */\n-    fn icmp(&mut self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        let left_type = lhs.get_type();\n-        let right_type = rhs.get_type();\n-        if left_type != right_type {\n-            // NOTE: because libgccjit cannot compare function pointers.\n-            if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n-                lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n-                rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n-            }\n-            // NOTE: hack because we try to cast a vector type to the same vector type.\n-            else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n-                rhs = self.context.new_cast(None, rhs, left_type);\n-            }\n-        }\n-        self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+    fn icmp(&mut self, op: IntPredicate, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_icmp(op, lhs, rhs)\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n         self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n     }\n \n     /* Miscellaneous instructions */\n-    fn memcpy(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-            let val = self.load(src.get_type(), src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+    fn memcpy(&mut self, dst: RValue<'gcc>, _dst_align: Align, src: RValue<'gcc>, _src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memcpy not supported\");\n         let size = self.intcast(size, self.type_size_t(), false);\n         let _is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n         let memcpy = self.context.get_builtin_function(\"memcpy\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle aligns and is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n     }\n \n     fn memmove(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n@@ -1132,20 +982,18 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n \n         let memmove = self.context.get_builtin_function(\"memmove\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n     }\n \n     fn memset(&mut self, ptr: RValue<'gcc>, fill_byte: RValue<'gcc>, size: RValue<'gcc>, _align: Align, flags: MemFlags) {\n         let _is_volatile = flags.contains(MemFlags::VOLATILE);\n         let ptr = self.pointercast(ptr, self.type_i8p());\n         let memset = self.context.get_builtin_function(\"memset\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle align and is_volatile.\n         let fill_byte = self.context.new_cast(None, fill_byte, self.i32_type);\n         let size = self.intcast(size, self.type_size_t(), false);\n-        block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n     }\n \n     fn select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, mut else_val: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1159,16 +1007,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         then_block.add_assignment(None, variable, then_val);\n         then_block.end_with_jump(None, after_block);\n \n-        if then_val.get_type() != else_val.get_type() {\n+        if !then_val.get_type().is_compatible_with(else_val.get_type()) {\n             else_val = self.context.new_cast(None, else_val, then_val.get_type());\n         }\n         else_block.add_assignment(None, variable, else_val);\n         else_block.end_with_jump(None, after_block);\n \n-        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n         // state need to be updated.\n-        self.block = Some(after_block);\n-        *self.cx.current_block.borrow_mut() = Some(after_block);\n+        self.switch_to_block(after_block);\n \n         variable.to_rvalue()\n     }\n@@ -1264,7 +1111,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n-        let field1 = self.context.new_field(None, self.u8_type, \"landing_pad_field_1\");\n+        let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n         let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n         let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n         self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n@@ -1275,7 +1122,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn resume(&mut self, _exn: RValue<'gcc>) {\n-        unimplemented!();\n+        // TODO(bjorn3): Properly implement unwinding.\n+        self.unreachable();\n     }\n \n     fn cleanup_pad(&mut self, _parent: Option<RValue<'gcc>>, _args: &[RValue<'gcc>]) -> Funclet {\n@@ -1322,7 +1170,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn atomic_rmw(&mut self, op: AtomicRmwBinOp, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type()) / 8;\n+        let size = src.get_type().get_size();\n         let name =\n             match op {\n                 AtomicRmwBinOp::AtomicXchg => format!(\"__atomic_exchange_{}\", size),\n@@ -1396,15 +1244,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             // Fix the code in codegen_ssa::base::from_immediate.\n             return value;\n         }\n-        self.context.new_cast(None, value, dest_typ)\n+        self.gcc_int_cast(value, dest_typ)\n     }\n \n     fn cx(&self) -> &CodegenCx<'gcc, 'tcx> {\n         self.cx\n     }\n \n     fn do_not_inline(&mut self, _llret: RValue<'gcc>) {\n-        unimplemented!();\n+        // FIMXE(bjorn3): implement\n     }\n \n     fn set_span(&mut self, _span: Span) {}\n@@ -1470,7 +1318,7 @@ impl<'tcx> HasTargetSpec for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-trait ToGccComp {\n+pub trait ToGccComp {\n     fn to_gcc_comparison(&self) -> ComparisonOp;\n }\n "}, {"sha": "61709dd92de7961e17524100ae7bdbfe02ac1f15", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 8, "deletions": 48, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,7 +1,5 @@\n-use std::convert::TryFrom;\n-\n use gccjit::LValue;\n-use gccjit::{Block, CType, RValue, Type, ToRValue};\n+use gccjit::{RValue, Type, ToRValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods,\n@@ -35,27 +33,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n         // TODO(antoyo): set linkage.\n     }\n-\n-    pub fn inttoptr(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        let func = block.get_function();\n-        let local = func.new_local(None, value.get_type(), \"intLocal\");\n-        block.add_assignment(None, local, value);\n-        let value_address = local.get_address(None);\n-\n-        let ptr = self.context.new_cast(None, value_address, dest_ty.make_pointer());\n-        ptr.dereference(None).to_rvalue()\n-    }\n-\n-    pub fn ptrtoint(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): when libgccjit allow casting from pointer to int, remove this.\n-        let func = block.get_function();\n-        let local = func.new_local(None, value.get_type(), \"ptrLocal\");\n-        block.add_assignment(None, local, value);\n-        let ptr_address = local.get_address(None);\n-\n-        let ptr = self.context.new_cast(None, ptr_address, dest_ty.make_pointer());\n-        ptr.dereference(None).to_rvalue()\n-    }\n }\n \n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n@@ -99,29 +76,15 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn const_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n-        self.context.new_rvalue_from_long(typ, i64::try_from(int).expect(\"i64::try_from\"))\n+        self.gcc_int(typ, int)\n     }\n \n     fn const_uint(&self, typ: Type<'gcc>, int: u64) -> RValue<'gcc> {\n-        self.context.new_rvalue_from_long(typ, u64::try_from(int).expect(\"u64::try_from\") as i64)\n+        self.gcc_uint(typ, int)\n     }\n \n     fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n-        if num >> 64 != 0 {\n-            // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n-            let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n-            let high = self.context.new_rvalue_from_long(typ, (num >> 64) as u64 as i64);\n-\n-            let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-            (high << sixty_four) | self.context.new_cast(None, low, typ)\n-        }\n-        else if typ.is_i128(self) {\n-            let num = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n-            self.context.new_cast(None, num, typ)\n-        }\n-        else {\n-            self.context.new_rvalue_from_long(typ, num as u64 as i64)\n-        }\n+        self.gcc_uint_big(typ, num)\n     }\n \n     fn const_bool(&self, val: bool) -> RValue<'gcc> {\n@@ -210,11 +173,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.value == Pointer {\n-                    self.inttoptr(self.current_block.borrow().expect(\"block\"), value, ty)\n-                } else {\n-                    self.const_bitcast(value, ty)\n-                }\n+                // TODO(bjorn3): assert size is correct\n+                self.const_bitcast(value, ty)\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n@@ -418,11 +378,11 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     }\n \n     fn is_i128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.context.new_c_type(CType::Int128t)\n+        self.unqualified() == cx.i128_type.unqualified()\n     }\n \n     fn is_u128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.context.new_c_type(CType::UInt128t)\n+        self.unqualified() == cx.u128_type.unqualified()\n     }\n \n     fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {"}, {"sha": "de52f3ea2255e7092863403dd028d568b9900b18", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,4 +1,4 @@\n-use gccjit::{LValue, RValue, ToRValue, Type};\n+use gccjit::{GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -35,7 +35,12 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         // following:\n         for (value, variable) in &*self.const_globals.borrow() {\n             if format!(\"{:?}\", value) == format!(\"{:?}\", cv) {\n-                // TODO(antoyo): upgrade alignment.\n+                if let Some(global_variable) = self.global_lvalues.borrow().get(variable) {\n+                    let alignment = align.bits() as i32;\n+                    if alignment > global_variable.get_alignment() {\n+                        global_variable.set_alignment(alignment);\n+                    }\n+                }\n                 return *variable;\n             }\n         }\n@@ -165,11 +170,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             match kind {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n-                    // TODO(antoyo): check if it's okay that TLS is off here.\n-                    // TODO(antoyo): check if it's okay that link_section is None here.\n+                    // TODO(antoyo): check if it's okay that no link_section is set.\n                     // TODO(antoyo): set alignment here as well.\n-                    let global = self.define_global(&name[..], self.val_ty(cv), false, None);\n-                    // TODO(antoyo): set linkage.\n+                    let global = self.declare_private_global(&name[..], self.val_ty(cv));\n                     global\n                 }\n                 _ => {\n@@ -178,11 +181,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                     global\n                 },\n             };\n-        // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n-        // globally.\n         global.global_set_initializer_rvalue(cv);\n         // TODO(antoyo): set unnamed address.\n-        global.get_address(None)\n+        let rvalue = global.get_address(None);\n+        self.global_lvalues.borrow_mut().insert(rvalue, global);\n+        rvalue\n     }\n \n     pub fn get_static(&self, def_id: DefId) -> LValue<'gcc> {\n@@ -218,7 +221,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(&sym, llty, is_tls, fn_attrs.link_section);\n+                        let global = self.declare_global(\n+                            &sym,\n+                            llty,\n+                            GlobalKind::Exported,\n+                            is_tls,\n+                            fn_attrs.link_section,\n+                        );\n \n                         if !self.tcx.is_reachable_non_generic(def_id) {\n                             // TODO(antoyo): set visibility.\n@@ -390,6 +399,6 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        cx.declare_global(&sym, llty, is_tls, attrs.link_section)\n+        cx.declare_global(&sym, llty, GlobalKind::Imported, is_tls, attrs.link_section)\n     }\n }"}, {"sha": "5e5b9e7e9b1b7e85e64dcec0aee15ba37fc55a00", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 83, "deletions": 29, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,6 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n@@ -18,7 +18,6 @@ use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDat\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n use crate::callee::get_fn;\n-use crate::declare::mangle_name;\n \n #[derive(Clone)]\n pub struct FuncSig<'gcc> {\n@@ -31,8 +30,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub codegen_unit: &'tcx CodegenUnit<'tcx>,\n     pub context: &'gcc Context<'gcc>,\n \n-    // TODO(antoyo): First set it to a dummy block to avoid using Option?\n-    pub current_block: RefCell<Option<Block<'gcc>>>,\n+    // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n@@ -62,6 +60,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub ulonglong_type: Type<'gcc>,\n     pub sizet_type: Type<'gcc>,\n \n+    pub supports_128bit_integers: bool,\n+\n     pub float_type: Type<'gcc>,\n     pub double_type: Type<'gcc>,\n \n@@ -81,9 +81,19 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n+    // TODO(antoyo): improve the SSA API to not require those.\n+    // Mapping from function pointer type to indexes of on stack parameters.\n+    pub on_stack_params: RefCell<FxHashMap<FunctionPtrType<'gcc>, FxHashSet<usize>>>,\n+    // Mapping from function to indexes of on stack parameters.\n+    pub on_stack_function_params: RefCell<FxHashMap<Function<'gcc>, FxHashSet<usize>>>,\n+\n     /// Cache of emitted const globals (value -> global)\n     pub const_globals: RefCell<FxHashMap<RValue<'gcc>, RValue<'gcc>>>,\n \n+    /// Map from the address of a global variable (rvalue) to the global variable itself (lvalue).\n+    /// TODO(antoyo): remove when the rustc API is fixed.\n+    pub global_lvalues: RefCell<FxHashMap<RValue<'gcc>, LValue<'gcc>>>,\n+\n     /// Cache of constant strings,\n     pub const_str_cache: RefCell<FxHashMap<Symbol, LValue<'gcc>>>,\n \n@@ -92,7 +102,6 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n-    pub global_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n \n@@ -107,22 +116,29 @@ pub struct CodegenCx<'gcc, 'tcx> {\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn new(context: &'gcc Context<'gcc>, codegen_unit: &'tcx CodegenUnit<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+    pub fn new(context: &'gcc Context<'gcc>, codegen_unit: &'tcx CodegenUnit<'tcx>, tcx: TyCtxt<'tcx>, supports_128bit_integers: bool) -> Self {\n         let check_overflow = tcx.sess.overflow_checks();\n-        // TODO(antoyo): fix this mess. libgccjit seems to return random type when using new_int_type().\n-        let isize_type = context.new_c_type(CType::LongLong);\n-        let usize_type = context.new_c_type(CType::ULongLong);\n-        let bool_type = context.new_type::<bool>();\n-        let i8_type = context.new_type::<i8>();\n-        let i16_type = context.new_type::<i16>();\n-        let i32_type = context.new_type::<i32>();\n-        let i64_type = context.new_c_type(CType::LongLong);\n-        let i128_type = context.new_c_type(CType::Int128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n-        let u8_type = context.new_type::<u8>();\n-        let u16_type = context.new_type::<u16>();\n-        let u32_type = context.new_type::<u32>();\n-        let u64_type = context.new_c_type(CType::ULongLong);\n-        let u128_type = context.new_c_type(CType::UInt128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n+\n+        let i8_type = context.new_c_type(CType::Int8t);\n+        let i16_type = context.new_c_type(CType::Int16t);\n+        let i32_type = context.new_c_type(CType::Int32t);\n+        let i64_type = context.new_c_type(CType::Int64t);\n+        let u8_type = context.new_c_type(CType::UInt8t);\n+        let u16_type = context.new_c_type(CType::UInt16t);\n+        let u32_type = context.new_c_type(CType::UInt32t);\n+        let u64_type = context.new_c_type(CType::UInt64t);\n+\n+        let (i128_type, u128_type) =\n+            if supports_128bit_integers {\n+                let i128_type = context.new_c_type(CType::Int128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?;\n+                let u128_type = context.new_c_type(CType::UInt128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?;\n+                (i128_type, u128_type)\n+            }\n+            else {\n+                let i128_type = context.new_array_type(None, i64_type, 2);\n+                let u128_type = context.new_array_type(None, u64_type, 2);\n+                (i128_type, u128_type)\n+            };\n \n         let tls_model = to_gcc_tls_mode(tcx.sess.tls_model());\n \n@@ -136,8 +152,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ulonglong_type = context.new_c_type(CType::ULongLong);\n         let sizet_type = context.new_c_type(CType::SizeT);\n \n-        assert_eq!(isize_type, i64_type);\n-        assert_eq!(usize_type, u64_type);\n+        let isize_type = context.new_c_type(CType::LongLong);\n+        let usize_type = context.new_c_type(CType::ULongLong);\n+        let bool_type = context.new_type::<bool>();\n+\n+        // TODO(antoyo): only have those assertions on x86_64.\n+        assert_eq!(isize_type.get_size(), i64_type.get_size());\n+        assert_eq!(usize_type.get_size(), u64_type.get_size());\n \n         let mut functions = FxHashMap::default();\n         let builtins = [\n@@ -160,7 +181,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             check_overflow,\n             codegen_unit,\n             context,\n-            current_block: RefCell::new(None),\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n@@ -187,14 +207,19 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             ulonglong_type,\n             sizet_type,\n \n+            supports_128bit_integers,\n+\n             float_type,\n             double_type,\n \n             linkage: Cell::new(FunctionType::Internal),\n             instances: Default::default(),\n             function_instances: Default::default(),\n+            on_stack_params: Default::default(),\n+            on_stack_function_params: Default::default(),\n             vtables: Default::default(),\n             const_globals: Default::default(),\n+            global_lvalues: Default::default(),\n             const_str_cache: Default::default(),\n             globals: Default::default(),\n             scalar_types: Default::default(),\n@@ -203,7 +228,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             struct_types: Default::default(),\n             types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n-            global_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n@@ -217,6 +241,41 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         function\n     }\n \n+    pub fn is_native_int_type(&self, typ: Type<'gcc>) -> bool {\n+        let types = [\n+            self.u8_type,\n+            self.u16_type,\n+            self.u32_type,\n+            self.u64_type,\n+            self.i8_type,\n+            self.i16_type,\n+            self.i32_type,\n+            self.i64_type,\n+        ];\n+\n+        for native_type in types {\n+            if native_type.is_compatible_with(typ) {\n+                return true;\n+            }\n+        }\n+\n+        self.supports_128bit_integers &&\n+            (self.u128_type.is_compatible_with(typ) || self.i128_type.is_compatible_with(typ))\n+    }\n+\n+    pub fn is_non_native_int_type(&self, typ: Type<'gcc>) -> bool {\n+        !self.supports_128bit_integers &&\n+            (self.u128_type.is_compatible_with(typ) || self.i128_type.is_compatible_with(typ))\n+    }\n+\n+    pub fn is_native_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n+        self.is_native_int_type(typ) || typ == self.bool_type\n+    }\n+\n+    pub fn is_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n+        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ == self.bool_type\n+    }\n+\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -450,11 +509,6 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-pub fn unit_name<'tcx>(codegen_unit: &CodegenUnit<'tcx>) -> String {\n-    let name = &codegen_unit.name().to_string();\n-    mangle_name(&name.replace('-', \"_\"))\n-}\n-\n fn to_gcc_tls_mode(tls_model: TlsModel) -> gccjit::TlsModel {\n     match tls_model {\n         TlsModel::GeneralDynamic => gccjit::TlsModel::GlobalDynamic,"}, {"sha": "43017376916dca5e7f48aa94b4fd5c14f3f4a2d9", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -5,7 +5,7 @@ use rustc_span::Symbol;\n use rustc_target::abi::call::FnAbi;\n \n use crate::abi::FnAbiGccExt;\n-use crate::context::{CodegenCx, unit_name};\n+use crate::context::CodegenCx;\n use crate::intrinsic::llvm;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -22,15 +22,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             global\n         }\n         else {\n-            self.declare_global(name, ty, is_tls, link_section)\n+            self.declare_global(name, ty, GlobalKind::Exported, is_tls, link_section)\n         }\n     }\n \n     pub fn declare_unnamed_global(&self, ty: Type<'gcc>) -> LValue<'gcc> {\n-        let index = self.global_gen_sym_counter.get();\n-        self.global_gen_sym_counter.set(index + 1);\n-        let name = format!(\"global_{}_{}\", index, unit_name(&self.codegen_unit));\n-        self.context.new_global(None, GlobalKind::Exported, ty, &name)\n+        let name = self.generate_local_symbol_name(\"global\");\n+        self.context.new_global(None, GlobalKind::Internal, ty, &name)\n     }\n \n     pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> LValue<'gcc> {\n@@ -47,8 +45,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }*/\n \n-    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n-        let global = self.context.new_global(None, GlobalKind::Exported, ty, name);\n+    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, global_kind, ty, name);\n         if is_tls {\n             global.set_tls_model(self.tls_model);\n         }\n@@ -82,8 +80,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n-        let (return_type, params, variadic) = fn_abi.gcc_type(self);\n+        let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n+        self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n         // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n         unsafe { std::mem::transmute(func) }\n     }"}, {"sha": "c3ed71ff730368f9bbda3473cf9ccfe8a550163b", "filename": "compiler/rustc_codegen_gcc/src/int.rs", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -0,0 +1,730 @@\n+//! Module to handle integer operations.\n+//! This module exists because some integer types are not supported on some gcc platforms, e.g.\n+//! 128-bit integers on 32-bit platforms and thus require to be handled manually.\n+\n+use std::convert::TryFrom;\n+\n+use gccjit::{ComparisonOp, FunctionType, RValue, ToRValue, Type, UnaryOp, BinaryOp};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::traits::{BackendTypes, BaseTypeMethods, BuilderMethods, OverflowOp};\n+use rustc_middle::ty::Ty;\n+\n+use crate::builder::ToGccComp;\n+use crate::{builder::Builder, common::{SignType, TypeReflection}, context::CodegenCx};\n+\n+impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    pub fn gcc_urem(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit unsigned %: __umodti3\n+        self.multiplicative_operation(BinaryOp::Modulo, \"mod\", false, a, b)\n+    }\n+\n+    pub fn gcc_srem(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit signed %:   __modti3\n+        self.multiplicative_operation(BinaryOp::Modulo, \"mod\", true, a, b)\n+    }\n+\n+    pub fn gcc_not(&self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        let typ = a.get_type();\n+        if self.is_native_int_type_or_bool(typ) {\n+            let operation =\n+                if typ.is_bool() {\n+                    UnaryOp::LogicalNegate\n+                }\n+                else {\n+                    UnaryOp::BitwiseNegate\n+                };\n+            self.cx.context.new_unary_op(None, operation, typ, a)\n+        }\n+        else {\n+            // TODO(antoyo): use __negdi2 and __negti2 instead?\n+            let element_type = typ.dyncast_array().expect(\"element type\");\n+            let values = [\n+                self.cx.context.new_unary_op(None, UnaryOp::BitwiseNegate, element_type, self.low(a)),\n+                self.cx.context.new_unary_op(None, UnaryOp::BitwiseNegate, element_type, self.high(a)),\n+            ];\n+            self.cx.context.new_array_constructor(None, typ, &values)\n+        }\n+    }\n+\n+    pub fn gcc_neg(&self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        if self.is_native_int_type(a_type) {\n+            self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n+        }\n+        else {\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a], \"__negti2\", false);\n+            self.context.new_call(None, func, &[a])\n+        }\n+    }\n+\n+    pub fn gcc_and(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.cx.bitwise_operation(BinaryOp::BitwiseAnd, a, b)\n+    }\n+\n+    pub fn gcc_lshr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type(a_type);\n+        let b_native = self.is_native_int_type(b_type);\n+        if a_native && b_native {\n+            // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by a signed number.\n+            // TODO(antoyo): cast to unsigned to do a logical shift if that does not work.\n+            if a_type.is_signed(self) != b_type.is_signed(self) {\n+                let b = self.context.new_cast(None, b, a_type);\n+                a >> b\n+            }\n+            else {\n+                a >> b\n+            }\n+        }\n+        else if a_native && !b_native {\n+            self.gcc_lshr(a, self.gcc_int_cast(b, a_type))\n+        }\n+        else {\n+            // NOTE: we cannot use the lshr builtin because it's calling hi() (to get the most\n+            // significant half of the number) which uses lshr.\n+\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+\n+            let func = self.current_func();\n+            let then_block = func.new_block(\"then\");\n+            let else_block = func.new_block(\"else\");\n+            let after_block = func.new_block(\"after\");\n+            let b0_block = func.new_block(\"b0\");\n+            let actual_else_block = func.new_block(\"actual_else\");\n+\n+            let result = func.new_local(None, a_type, \"shiftResult\");\n+\n+            let sixty_four = self.gcc_int(native_int_type, 64);\n+            let sixty_three = self.gcc_int(native_int_type, 63);\n+            let zero = self.gcc_zero(native_int_type);\n+            let b = self.gcc_int_cast(b, native_int_type);\n+            let condition = self.gcc_icmp(IntPredicate::IntNE, self.gcc_and(b, sixty_four), zero);\n+            self.llbb().end_with_conditional(None, condition, then_block, else_block);\n+\n+            // TODO(antoyo): take endianness into account.\n+            let shift_value = self.gcc_sub(b, sixty_four);\n+            let high = self.high(a);\n+            let sign =\n+                if a_type.is_signed(self) {\n+                    high >> sixty_three\n+                }\n+                else {\n+                    zero\n+                };\n+            let values = [\n+                high >> shift_value,\n+                sign,\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            then_block.add_assignment(None, result, array_value);\n+            then_block.end_with_jump(None, after_block);\n+\n+            let condition = self.gcc_icmp(IntPredicate::IntEQ, b, zero);\n+            else_block.end_with_conditional(None, condition, b0_block, actual_else_block);\n+\n+            b0_block.add_assignment(None, result, a);\n+            b0_block.end_with_jump(None, after_block);\n+\n+            let shift_value = self.gcc_sub(sixty_four, b);\n+            // NOTE: cast low to its unsigned type in order to perform a logical right shift.\n+            let unsigned_type = native_int_type.to_unsigned(&self.cx);\n+            let casted_low = self.context.new_cast(None, self.low(a), unsigned_type);\n+            let shifted_low = casted_low >> self.context.new_cast(None, b, unsigned_type);\n+            let shifted_low = self.context.new_cast(None, shifted_low, native_int_type);\n+            let values = [\n+                (high << shift_value) | shifted_low,\n+                high >> b,\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            actual_else_block.add_assignment(None, result, array_value);\n+            actual_else_block.end_with_jump(None, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n+            // state need to be updated.\n+            self.switch_to_block(after_block);\n+\n+            result.to_rvalue()\n+        }\n+    }\n+\n+    fn additive_operation(&self, operation: BinaryOp, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            if a.get_type() != b.get_type() {\n+                b = self.context.new_cast(None, b, a.get_type());\n+            }\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            let signed = a_type.is_compatible_with(self.i128_type);\n+            let func_name =\n+                match (operation, signed) {\n+                    (BinaryOp::Plus, true) => \"__rust_i128_add\",\n+                    (BinaryOp::Plus, false) => \"__rust_u128_add\",\n+                    (BinaryOp::Minus, true) => \"__rust_i128_sub\",\n+                    (BinaryOp::Minus, false) => \"__rust_u128_sub\",\n+                    _ => unreachable!(\"unexpected additive operation {:?}\", operation),\n+                };\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a, param_b], func_name, false);\n+            self.context.new_call(None, func, &[a, b])\n+        }\n+    }\n+\n+    pub fn gcc_add(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.additive_operation(BinaryOp::Plus, a, b)\n+    }\n+\n+    pub fn gcc_mul(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.multiplicative_operation(BinaryOp::Mult, \"mul\", true, a, b)\n+    }\n+\n+    pub fn gcc_sub(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.additive_operation(BinaryOp::Minus, a, b)\n+    }\n+\n+    fn multiplicative_operation(&self, operation: BinaryOp, operation_name: &str, signed: bool, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            let sign =\n+                if signed {\n+                    \"\"\n+                }\n+                else {\n+                    \"u\"\n+                };\n+            let func_name = format!(\"__{}{}ti3\", sign, operation_name);\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a, param_b], func_name, false);\n+            self.context.new_call(None, func, &[a, b])\n+        }\n+    }\n+\n+    pub fn gcc_sdiv(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): check if the types are signed?\n+        // 128-bit, signed: __divti3\n+        // TODO(antoyo): convert the arguments to signed?\n+        self.multiplicative_operation(BinaryOp::Divide, \"div\", true, a, b)\n+    }\n+\n+    pub fn gcc_udiv(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit, unsigned: __udivti3\n+        self.multiplicative_operation(BinaryOp::Divide, \"div\", false, a, b)\n+    }\n+\n+    pub fn gcc_checked_binop(&self, oop: OverflowOp, typ: Ty<'_>, lhs: <Self as BackendTypes>::Value, rhs: <Self as BackendTypes>::Value) -> (<Self as BackendTypes>::Value, <Self as BackendTypes>::Value) {\n+        use rustc_middle::ty::{Int, IntTy::*, Uint, UintTy::*};\n+\n+        let new_kind =\n+            match typ.kind() {\n+                Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n+                Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n+                t @ (Uint(_) | Int(_)) => t.clone(),\n+                _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n+            };\n+\n+        // TODO(antoyo): remove duplication with intrinsic?\n+        let name =\n+            if self.is_native_int_type(lhs.get_type()) {\n+                match oop {\n+                    OverflowOp::Add =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_add_overflow\",\n+                            Int(I16) => \"__builtin_add_overflow\",\n+                            Int(I32) => \"__builtin_sadd_overflow\",\n+                            Int(I64) => \"__builtin_saddll_overflow\",\n+                            Int(I128) => \"__builtin_add_overflow\",\n+\n+                            Uint(U8) => \"__builtin_add_overflow\",\n+                            Uint(U16) => \"__builtin_add_overflow\",\n+                            Uint(U32) => \"__builtin_uadd_overflow\",\n+                            Uint(U64) => \"__builtin_uaddll_overflow\",\n+                            Uint(U128) => \"__builtin_add_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                    OverflowOp::Sub =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_sub_overflow\",\n+                            Int(I16) => \"__builtin_sub_overflow\",\n+                            Int(I32) => \"__builtin_ssub_overflow\",\n+                            Int(I64) => \"__builtin_ssubll_overflow\",\n+                            Int(I128) => \"__builtin_sub_overflow\",\n+\n+                            Uint(U8) => \"__builtin_sub_overflow\",\n+                            Uint(U16) => \"__builtin_sub_overflow\",\n+                            Uint(U32) => \"__builtin_usub_overflow\",\n+                            Uint(U64) => \"__builtin_usubll_overflow\",\n+                            Uint(U128) => \"__builtin_sub_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                    OverflowOp::Mul =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_mul_overflow\",\n+                            Int(I16) => \"__builtin_mul_overflow\",\n+                            Int(I32) => \"__builtin_smul_overflow\",\n+                            Int(I64) => \"__builtin_smulll_overflow\",\n+                            Int(I128) => \"__builtin_mul_overflow\",\n+\n+                            Uint(U8) => \"__builtin_mul_overflow\",\n+                            Uint(U16) => \"__builtin_mul_overflow\",\n+                            Uint(U32) => \"__builtin_umul_overflow\",\n+                            Uint(U64) => \"__builtin_umulll_overflow\",\n+                            Uint(U128) => \"__builtin_mul_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                }\n+            }\n+            else {\n+                match new_kind {\n+                    Int(I128) | Uint(U128) => {\n+                        let func_name =\n+                            match oop {\n+                                OverflowOp::Add =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_addo\",\n+                                        Uint(U128) => \"__rust_u128_addo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                                OverflowOp::Sub =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_subo\",\n+                                        Uint(U128) => \"__rust_u128_subo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                                OverflowOp::Mul =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_mulo\", // TODO(antoyo): use __muloti4d instead?\n+                                        Uint(U128) => \"__rust_u128_mulo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                            };\n+                        let a_type = lhs.get_type();\n+                        let b_type = rhs.get_type();\n+                        let param_a = self.context.new_parameter(None, a_type, \"a\");\n+                        let param_b = self.context.new_parameter(None, b_type, \"b\");\n+                        let result_field = self.context.new_field(None, a_type, \"result\");\n+                        let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                        let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                        let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                        let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                        let overflow = result.access_field(None, overflow_field);\n+                        let int_result = result.access_field(None, result_field);\n+                        return (int_result, overflow);\n+                    },\n+                    _ => {\n+                        match oop {\n+                            OverflowOp::Mul =>\n+                                match new_kind {\n+                                    Int(I32) => \"__mulosi4\",\n+                                    Int(I64) => \"__mulodi4\",\n+                                    _ => unreachable!(),\n+                                },\n+                            _ => unimplemented!(\"overflow operation for {:?}\", new_kind),\n+                        }\n+                    }\n+                }\n+            };\n+\n+        let intrinsic = self.context.get_builtin_function(&name);\n+        let res = self.current_func()\n+            // TODO(antoyo): is it correct to use rhs type instead of the parameter typ?\n+            .new_local(None, rhs.get_type(), \"binopResult\")\n+            .get_address(None);\n+        let overflow = self.overflow_call(intrinsic, &[lhs, rhs, res], None);\n+        (res.dereference(None).to_rvalue(), overflow)\n+    }\n+\n+    pub fn gcc_icmp(&self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = lhs.get_type();\n+        let b_type = rhs.get_type();\n+        if self.is_non_native_int_type(a_type) || self.is_non_native_int_type(b_type) {\n+            let signed = a_type.is_compatible_with(self.i128_type);\n+            let sign =\n+                if signed {\n+                    \"\"\n+                }\n+                else {\n+                    \"u\"\n+                };\n+            let func_name = format!(\"__{}cmpti2\", sign);\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, self.int_type, &[param_a, param_b], func_name, false);\n+            let cmp = self.context.new_call(None, func, &[lhs, rhs]);\n+            let (op, limit) =\n+                match op {\n+                    IntPredicate::IntEQ => {\n+                        return self.context.new_comparison(None, ComparisonOp::Equals, cmp, self.context.new_rvalue_one(self.int_type));\n+                    },\n+                    IntPredicate::IntNE => {\n+                        return self.context.new_comparison(None, ComparisonOp::NotEquals, cmp, self.context.new_rvalue_one(self.int_type));\n+                    },\n+                    IntPredicate::IntUGT => (ComparisonOp::Equals, 2),\n+                    IntPredicate::IntUGE => (ComparisonOp::GreaterThanEquals, 1),\n+                    IntPredicate::IntULT => (ComparisonOp::Equals, 0),\n+                    IntPredicate::IntULE => (ComparisonOp::LessThanEquals, 1),\n+                    IntPredicate::IntSGT => (ComparisonOp::Equals, 2),\n+                    IntPredicate::IntSGE => (ComparisonOp::GreaterThanEquals, 1),\n+                    IntPredicate::IntSLT => (ComparisonOp::Equals, 0),\n+                    IntPredicate::IntSLE => (ComparisonOp::LessThanEquals, 1),\n+                };\n+            self.context.new_comparison(None, op, cmp, self.context.new_rvalue_from_int(self.int_type, limit))\n+        }\n+        else {\n+            let left_type = lhs.get_type();\n+            let right_type = rhs.get_type();\n+            if left_type != right_type {\n+                // NOTE: because libgccjit cannot compare function pointers.\n+                if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n+                    lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n+                    rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n+                }\n+                // NOTE: hack because we try to cast a vector type to the same vector type.\n+                else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n+                    rhs = self.context.new_cast(None, rhs, left_type);\n+                }\n+            }\n+            self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+        }\n+    }\n+\n+    pub fn gcc_xor(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            a ^ b\n+        }\n+        else {\n+            let values = [\n+                self.low(a) ^ self.low(b),\n+                self.high(a) ^ self.high(b),\n+            ];\n+            self.context.new_array_constructor(None, a_type, &values)\n+        }\n+    }\n+\n+    pub fn gcc_shl(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type(a_type);\n+        let b_native = self.is_native_int_type(b_type);\n+        if a_native && b_native {\n+            // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+            if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+                let a = self.context.new_cast(None, a, b_type);\n+                let result = a << b;\n+                self.context.new_cast(None, result, a_type)\n+            }\n+            else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+                let b = self.context.new_cast(None, b, a_type);\n+                a << b\n+            }\n+            else {\n+                a << b\n+            }\n+        }\n+        else if a_native && !b_native {\n+            self.gcc_shl(a, self.gcc_int_cast(b, a_type))\n+        }\n+        else {\n+            // NOTE: we cannot use the ashl builtin because it's calling widen_hi() which uses ashl.\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+\n+            let func = self.current_func();\n+            let then_block = func.new_block(\"then\");\n+            let else_block = func.new_block(\"else\");\n+            let after_block = func.new_block(\"after\");\n+            let b0_block = func.new_block(\"b0\");\n+            let actual_else_block = func.new_block(\"actual_else\");\n+\n+            let result = func.new_local(None, a_type, \"shiftResult\");\n+\n+            let b = self.gcc_int_cast(b, native_int_type);\n+            let sixty_four = self.gcc_int(native_int_type, 64);\n+            let zero = self.gcc_zero(native_int_type);\n+            let condition = self.gcc_icmp(IntPredicate::IntNE, self.gcc_and(b, sixty_four), zero);\n+            self.llbb().end_with_conditional(None, condition, then_block, else_block);\n+\n+            // TODO(antoyo): take endianness into account.\n+            let values = [\n+                zero,\n+                self.low(a) << (b - sixty_four),\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            then_block.add_assignment(None, result, array_value);\n+            then_block.end_with_jump(None, after_block);\n+\n+            let condition = self.gcc_icmp(IntPredicate::IntEQ, b, zero);\n+            else_block.end_with_conditional(None, condition, b0_block, actual_else_block);\n+\n+            b0_block.add_assignment(None, result, a);\n+            b0_block.end_with_jump(None, after_block);\n+\n+            // NOTE: cast low to its unsigned type in order to perform a logical right shift.\n+            let unsigned_type = native_int_type.to_unsigned(&self.cx);\n+            let casted_low = self.context.new_cast(None, self.low(a), unsigned_type);\n+            let shift_value = self.context.new_cast(None, sixty_four - b, unsigned_type);\n+            let high_low = self.context.new_cast(None, casted_low >> shift_value, native_int_type);\n+            let values = [\n+                self.low(a) << b,\n+                (self.high(a) << b) | high_low,\n+            ];\n+\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            actual_else_block.add_assignment(None, result, array_value);\n+            actual_else_block.end_with_jump(None, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n+            // state need to be updated.\n+            self.switch_to_block(after_block);\n+\n+            result.to_rvalue()\n+        }\n+    }\n+\n+    pub fn gcc_bswap(&mut self, mut arg: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n+        let arg_type = arg.get_type();\n+        if !self.is_native_int_type(arg_type) {\n+            let native_int_type = arg_type.dyncast_array().expect(\"get element type\");\n+            let lsb = self.context.new_array_access(None, arg, self.context.new_rvalue_from_int(self.int_type, 0)).to_rvalue();\n+            let swapped_lsb = self.gcc_bswap(lsb, width / 2);\n+            let swapped_lsb = self.context.new_cast(None, swapped_lsb, native_int_type);\n+            let msb = self.context.new_array_access(None, arg, self.context.new_rvalue_from_int(self.int_type, 1)).to_rvalue();\n+            let swapped_msb = self.gcc_bswap(msb, width / 2);\n+            let swapped_msb = self.context.new_cast(None, swapped_msb, native_int_type);\n+\n+            // NOTE: we also need to swap the two elements here, in addition to swapping inside\n+            // the elements themselves like done above.\n+            return self.context.new_array_constructor(None, arg_type, &[swapped_msb, swapped_lsb]);\n+        }\n+\n+        // TODO(antoyo): check if it's faster to use string literals and a\n+        // match instead of format!.\n+        let bswap = self.cx.context.get_builtin_function(&format!(\"__builtin_bswap{}\", width));\n+        // FIXME(antoyo): this cast should not be necessary. Remove\n+        // when having proper sized integer types.\n+        let param_type = bswap.get_param(0).to_rvalue().get_type();\n+        if param_type != arg_type {\n+            arg = self.bitcast(arg, param_type);\n+        }\n+        self.cx.context.new_call(None, bswap, &[arg])\n+    }\n+}\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn gcc_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_from_long(typ, i64::try_from(int).expect(\"i64::try_from\"))\n+        }\n+        else {\n+            // NOTE: set the sign in high.\n+            self.from_low_high(typ, int, -(int.is_negative() as i64))\n+        }\n+    }\n+\n+    pub fn gcc_uint(&self, typ: Type<'gcc>, int: u64) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_from_long(typ, u64::try_from(int).expect(\"u64::try_from\") as i64)\n+        }\n+        else {\n+            self.from_low_high(typ, int as i64, 0)\n+        }\n+    }\n+\n+    pub fn gcc_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n+        let low = num as u64;\n+        let high = (num >> 64) as u64;\n+        if num >> 64 != 0 {\n+            // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n+            if self.is_native_int_type(typ) {\n+                let low = self.context.new_rvalue_from_long(self.u64_type, low as i64);\n+                let high = self.context.new_rvalue_from_long(typ, high as i64);\n+\n+                let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+                let shift = high << sixty_four;\n+                shift | self.context.new_cast(None, low, typ)\n+            }\n+            else {\n+                self.from_low_high(typ, low as i64, high as i64)\n+            }\n+        }\n+        else if typ.is_i128(self) {\n+            let num = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n+            self.gcc_int_cast(num, typ)\n+        }\n+        else {\n+            self.gcc_uint(typ, num as u64)\n+        }\n+    }\n+\n+    pub fn gcc_zero(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_zero(typ)\n+        }\n+        else {\n+            self.from_low_high(typ, 0, 0)\n+        }\n+    }\n+\n+    pub fn gcc_int_width(&self, typ: Type<'gcc>) -> u64 {\n+        if self.is_native_int_type_or_bool(typ) {\n+            typ.get_size() as u64 * 8\n+        }\n+        else {\n+            // NOTE: the only unsupported types are u128 and i128.\n+            128\n+        }\n+    }\n+\n+    fn bitwise_operation(&self, operation: BinaryOp, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type_or_bool(a_type);\n+        let b_native = self.is_native_int_type_or_bool(b_type);\n+        if a_native && b_native {\n+            if a_type != b_type {\n+                b = self.context.new_cast(None, b, a_type);\n+            }\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            assert!(!a_native && !b_native, \"both types should either be native or non-native for or operation\");\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+            let values = [\n+                self.context.new_binary_op(None, operation, native_int_type, self.low(a), self.low(b)),\n+                self.context.new_binary_op(None, operation, native_int_type, self.high(a), self.high(b)),\n+            ];\n+            self.context.new_array_constructor(None, a_type, &values)\n+        }\n+    }\n+\n+    pub fn gcc_or(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.bitwise_operation(BinaryOp::BitwiseOr, a, b)\n+    }\n+\n+    // TODO(antoyo): can we use https://github.com/rust-lang/compiler-builtins/blob/master/src/int/mod.rs#L379 instead?\n+    pub fn gcc_int_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(dest_typ) && self.is_native_int_type_or_bool(value_type) {\n+            self.context.new_cast(None, value, dest_typ)\n+        }\n+        else if self.is_native_int_type_or_bool(dest_typ) {\n+            self.context.new_cast(None, self.low(value), dest_typ)\n+        }\n+        else if self.is_native_int_type_or_bool(value_type) {\n+            let dest_element_type = dest_typ.dyncast_array().expect(\"get element type\");\n+\n+            // NOTE: set the sign of the value.\n+            let zero = self.context.new_rvalue_zero(value_type);\n+            let is_negative = self.context.new_comparison(None, ComparisonOp::LessThan, value, zero);\n+            let is_negative = self.gcc_int_cast(is_negative, dest_element_type);\n+            let values = [\n+                self.context.new_cast(None, value, dest_element_type),\n+                self.context.new_unary_op(None, UnaryOp::Minus, dest_element_type, is_negative),\n+            ];\n+            self.context.new_array_constructor(None, dest_typ, &values)\n+        }\n+        else {\n+            // Since u128 and i128 are the only types that can be unsupported, we know the type of\n+            // value and the destination type have the same size, so a bitcast is fine.\n+            self.context.new_bitcast(None, value, dest_typ)\n+        }\n+    }\n+\n+    fn int_to_float_cast(&self, signed: bool, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(value_type) {\n+            return self.context.new_cast(None, value, dest_typ);\n+        }\n+\n+        let name_suffix =\n+            match self.type_kind(dest_typ) {\n+                TypeKind::Float => \"tisf\",\n+                TypeKind::Double => \"tidf\",\n+                kind => panic!(\"cannot cast a non-native integer to type {:?}\", kind),\n+            };\n+        let sign =\n+            if signed {\n+                \"\"\n+            }\n+            else {\n+                \"un\"\n+            };\n+        let func_name = format!(\"__float{}{}\", sign, name_suffix);\n+        let param = self.context.new_parameter(None, value_type, \"n\");\n+        let func = self.context.new_function(None, FunctionType::Extern, dest_typ, &[param], func_name, false);\n+        self.context.new_call(None, func, &[value])\n+    }\n+\n+    pub fn gcc_int_to_float_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.int_to_float_cast(true, value, dest_typ)\n+    }\n+\n+    pub fn gcc_uint_to_float_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.int_to_float_cast(false, value, dest_typ)\n+    }\n+\n+    fn float_to_int_cast(&self, signed: bool, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(dest_typ) {\n+            return self.context.new_cast(None, value, dest_typ);\n+        }\n+\n+        let name_suffix =\n+            match self.type_kind(value_type) {\n+                TypeKind::Float => \"sfti\",\n+                TypeKind::Double => \"dfti\",\n+                kind => panic!(\"cannot cast a {:?} to non-native integer\", kind),\n+            };\n+        let sign =\n+            if signed {\n+                \"\"\n+            }\n+            else {\n+                \"uns\"\n+            };\n+        let func_name = format!(\"__fix{}{}\", sign, name_suffix);\n+        let param = self.context.new_parameter(None, value_type, \"n\");\n+        let func = self.context.new_function(None, FunctionType::Extern, dest_typ, &[param], func_name, false);\n+        self.context.new_call(None, func, &[value])\n+    }\n+\n+    pub fn gcc_float_to_int_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.float_to_int_cast(true, value, dest_typ)\n+    }\n+\n+    pub fn gcc_float_to_uint_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.float_to_int_cast(false, value, dest_typ)\n+    }\n+\n+    fn high(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_array_access(None, value, self.context.new_rvalue_from_int(self.int_type, 1))\n+            .to_rvalue()\n+    }\n+\n+    fn low(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_array_access(None, value, self.context.new_rvalue_from_int(self.int_type, 0))\n+            .to_rvalue()\n+    }\n+\n+    fn from_low_high(&self, typ: Type<'gcc>, low: i64, high: i64) -> RValue<'gcc> {\n+        let native_int_type = typ.dyncast_array().expect(\"get element type\");\n+        let values = [\n+            self.context.new_rvalue_from_long(native_int_type, low),\n+            self.context.new_rvalue_from_long(native_int_type, high),\n+        ];\n+        self.context.new_array_constructor(None, typ, &values)\n+    }\n+}"}, {"sha": "08e584a46f33b16dfebc212fe5c3c8ab02fec3fd", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 127, "deletions": 101, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,7 +1,7 @@\n pub mod llvm;\n mod simd;\n \n-use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp};\n+use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n@@ -175,33 +175,31 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                                     let arg = args[0].immediate();\n                                     let result = func.new_local(None, arg.get_type(), \"zeros\");\n-                                    let zero = self.cx.context.new_rvalue_zero(arg.get_type());\n-                                    let cond = self.cx.context.new_comparison(None, ComparisonOp::Equals, arg, zero);\n+                                    let zero = self.cx.gcc_zero(arg.get_type());\n+                                    let cond = self.gcc_icmp(IntPredicate::IntEQ, arg, zero);\n                                     self.llbb().end_with_conditional(None, cond, then_block, else_block);\n \n-                                    let zero_result = self.cx.context.new_rvalue_from_long(arg.get_type(), width as i64);\n+                                    let zero_result = self.cx.gcc_uint(arg.get_type(), width);\n                                     then_block.add_assignment(None, result, zero_result);\n                                     then_block.end_with_jump(None, after_block);\n \n                                     // NOTE: since jumps were added in a place\n-                                    // count_leading_zeroes() does not expect, the current blocks\n+                                    // count_leading_zeroes() does not expect, the current block\n                                     // in the state need to be updated.\n-                                    *self.current_block.borrow_mut() = Some(else_block);\n-                                    self.block = Some(else_block);\n+                                    self.switch_to_block(else_block);\n \n                                     let zeros =\n                                         match name {\n                                             sym::ctlz => self.count_leading_zeroes(width, arg),\n                                             sym::cttz => self.count_trailing_zeroes(width, arg),\n                                             _ => unreachable!(),\n                                         };\n-                                    else_block.add_assignment(None, result, zeros);\n-                                    else_block.end_with_jump(None, after_block);\n+                                    self.llbb().add_assignment(None, result, zeros);\n+                                    self.llbb().end_with_jump(None, after_block);\n \n                                     // NOTE: since jumps were added in a place rustc does not\n-                                    // expect, the current blocks in the state need to be updated.\n-                                    *self.current_block.borrow_mut() = Some(after_block);\n-                                    self.block = Some(after_block);\n+                                    // expect, the current block in the state need to be updated.\n+                                    self.switch_to_block(after_block);\n \n                                     result.to_rvalue()\n                                 }\n@@ -217,17 +215,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                         args[0].immediate() // byte swap a u8/i8 is just a no-op\n                                     }\n                                     else {\n-                                        // TODO(antoyo): check if it's faster to use string literals and a\n-                                        // match instead of format!.\n-                                        let bswap = self.cx.context.get_builtin_function(&format!(\"__builtin_bswap{}\", width));\n-                                        let mut arg = args[0].immediate();\n-                                        // FIXME(antoyo): this cast should not be necessary. Remove\n-                                        // when having proper sized integer types.\n-                                        let param_type = bswap.get_param(0).to_rvalue().get_type();\n-                                        if param_type != arg.get_type() {\n-                                            arg = self.bitcast(arg, param_type);\n-                                        }\n-                                        self.cx.context.new_call(None, bswap, &[arg])\n+                                        self.gcc_bswap(args[0].immediate(), width)\n                                     }\n                                 },\n                                 sym::bitreverse => self.bit_reverse(width, args[0].immediate()),\n@@ -476,17 +464,17 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             val.to_rvalue()\n         };\n         match self.mode {\n-            PassMode::Ignore => {}\n+            PassMode::Ignore => {},\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n-            }\n+            },\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n-            }\n+            },\n             PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n                 let next_arg = next();\n-                self.store(bx, next_arg.to_rvalue(), dst);\n-            }\n+                self.store(bx, next_arg, dst);\n+            },\n         }\n     }\n }\n@@ -526,7 +514,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_cast(None, value, typ)\n+                self.gcc_int_cast(value, typ)\n             }\n             else {\n                 value\n@@ -673,30 +661,33 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 },\n                 128 => {\n                     // TODO(antoyo): find a more efficient implementation?\n-                    let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-                    let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n-                    let low = self.context.new_cast(None, value, self.u64_type);\n+                    let sixty_four = self.gcc_int(typ, 64);\n+                    let right_shift = self.gcc_lshr(value, sixty_four);\n+                    let high = self.gcc_int_cast(right_shift, self.u64_type);\n+                    let low = self.gcc_int_cast(value, self.u64_type);\n \n                     let reversed_high = self.bit_reverse(64, high);\n                     let reversed_low = self.bit_reverse(64, low);\n \n-                    let new_low = self.context.new_cast(None, reversed_high, typ);\n-                    let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n+                    let new_low = self.gcc_int_cast(reversed_high, typ);\n+                    let new_high = self.shl(self.gcc_int_cast(reversed_low, typ), sixty_four);\n \n-                    new_low | new_high\n+                    self.gcc_or(new_low, new_high)\n                 },\n                 _ => {\n                     panic!(\"cannot bit reverse with width = {}\", width);\n                 },\n             };\n \n-        self.context.new_cast(None, result, result_type)\n+        self.gcc_int_cast(result, result_type)\n     }\n \n-    fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+    fn count_leading_zeroes(&mut self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use width?\n         let arg_type = arg.get_type();\n         let count_leading_zeroes =\n+            // TODO(antoyo): write a new function Type::is_compatible_with(&Type) and use it here\n+            // instead of using is_uint().\n             if arg_type.is_uint(&self.cx) {\n                 \"__builtin_clz\"\n             }\n@@ -712,9 +703,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let result = self.current_func()\n                     .new_local(None, array_type, \"count_loading_zeroes_results\");\n \n-                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n-                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, arg, self.u64_type);\n+                let sixty_four = self.const_uint(arg_type, 64);\n+                let shift = self.lshr(arg, sixty_four);\n+                let high = self.gcc_int_cast(shift, self.u64_type);\n+                let low = self.gcc_int_cast(arg, self.u64_type);\n \n                 let zero = self.context.new_rvalue_zero(self.usize_type);\n                 let one = self.context.new_rvalue_one(self.usize_type);\n@@ -723,17 +715,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let clzll = self.context.get_builtin_function(\"__builtin_clzll\");\n \n                 let first_elem = self.context.new_array_access(None, result, zero);\n-                let first_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[high]), arg_type);\n+                let first_value = self.gcc_int_cast(self.context.new_call(None, clzll, &[high]), arg_type);\n                 self.llbb()\n                     .add_assignment(None, first_elem, first_value);\n \n                 let second_elem = self.context.new_array_access(None, result, one);\n-                let second_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[low]), arg_type) + sixty_four;\n+                let cast = self.gcc_int_cast(self.context.new_call(None, clzll, &[low]), arg_type);\n+                let second_value = self.add(cast, sixty_four);\n                 self.llbb()\n                     .add_assignment(None, second_elem, second_value);\n \n                 let third_elem = self.context.new_array_access(None, result, two);\n-                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                let third_value = self.const_uint(arg_type, 128);\n                 self.llbb()\n                     .add_assignment(None, third_elem, third_value);\n \n@@ -749,13 +742,13 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, arg_type);\n+                return self.gcc_int_cast(res.to_rvalue(), arg_type);\n             }\n             else {\n-                let count_leading_zeroes = self.context.get_builtin_function(\"__builtin_clz\");\n-                let arg = self.context.new_cast(None, arg, self.uint_type);\n-                let diff = self.int_width(self.uint_type) - self.int_width(arg_type);\n-                let diff = self.context.new_rvalue_from_long(self.int_type, diff);\n+                let count_leading_zeroes = self.context.get_builtin_function(\"__builtin_clzll\");\n+                let arg = self.context.new_cast(None, arg, self.ulonglong_type);\n+                let diff = self.ulonglong_type.get_size() as i64 - arg_type.get_size() as i64;\n+                let diff = self.context.new_rvalue_from_long(self.int_type, diff * 8);\n                 let res = self.context.new_call(None, count_leading_zeroes, &[arg]) - diff;\n                 return self.context.new_cast(None, res, arg_type);\n             };\n@@ -764,18 +757,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         self.context.new_cast(None, res, arg_type)\n     }\n \n-    fn count_trailing_zeroes(&self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+    fn count_trailing_zeroes(&mut self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n         let result_type = arg.get_type();\n         let arg =\n             if result_type.is_signed(self.cx) {\n                 let new_type = result_type.to_unsigned(self.cx);\n-                self.context.new_cast(None, arg, new_type)\n+                self.gcc_int_cast(arg, new_type)\n             }\n             else {\n                 arg\n             };\n         let arg_type = arg.get_type();\n         let (count_trailing_zeroes, expected_type) =\n+            // TODO(antoyo): write a new function Type::is_compatible_with(&Type) and use it here\n+            // instead of using is_uint().\n             if arg_type.is_uchar(&self.cx) || arg_type.is_ushort(&self.cx) || arg_type.is_uint(&self.cx) {\n                 // NOTE: we don't need to & 0xFF for uchar because the result is undefined on zero.\n                 (\"__builtin_ctz\", self.cx.uint_type)\n@@ -792,9 +787,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let result = self.current_func()\n                     .new_local(None, array_type, \"count_loading_zeroes_results\");\n \n-                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n-                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, arg, self.u64_type);\n+                let sixty_four = self.gcc_int(arg_type, 64);\n+                let shift = self.gcc_lshr(arg, sixty_four);\n+                let high = self.gcc_int_cast(shift, self.u64_type);\n+                let low = self.gcc_int_cast(arg, self.u64_type);\n \n                 let zero = self.context.new_rvalue_zero(self.usize_type);\n                 let one = self.context.new_rvalue_one(self.usize_type);\n@@ -803,17 +799,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let ctzll = self.context.get_builtin_function(\"__builtin_ctzll\");\n \n                 let first_elem = self.context.new_array_access(None, result, zero);\n-                let first_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[low]), arg_type);\n+                let first_value = self.gcc_int_cast(self.context.new_call(None, ctzll, &[low]), arg_type);\n                 self.llbb()\n                     .add_assignment(None, first_elem, first_value);\n \n                 let second_elem = self.context.new_array_access(None, result, one);\n-                let second_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[high]), arg_type) + sixty_four;\n+                let second_value = self.gcc_add(self.gcc_int_cast(self.context.new_call(None, ctzll, &[high]), arg_type), sixty_four);\n                 self.llbb()\n                     .add_assignment(None, second_elem, second_value);\n \n                 let third_elem = self.context.new_array_access(None, result, two);\n-                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                let third_value = self.gcc_int(arg_type, 128);\n                 self.llbb()\n                     .add_assignment(None, third_elem, third_value);\n \n@@ -829,10 +825,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, result_type);\n+                return self.gcc_int_cast(res.to_rvalue(), result_type);\n             }\n             else {\n-                unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n+                let count_trailing_zeroes = self.context.get_builtin_function(\"__builtin_ctzll\");\n+                let arg_size = arg_type.get_size();\n+                let casted_arg = self.context.new_cast(None, arg, self.ulonglong_type);\n+                let byte_diff = self.ulonglong_type.get_size() as i64 - arg_size as i64;\n+                let diff = self.context.new_rvalue_from_long(self.int_type, byte_diff * 8);\n+                let mask = self.context.new_rvalue_from_long(arg_type, -1); // To get the value with all bits set.\n+                let masked = mask & self.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, arg);\n+                let cond = self.context.new_comparison(None, ComparisonOp::Equals, masked, mask);\n+                let diff = diff * self.context.new_cast(None, cond, self.int_type);\n+                let res = self.context.new_call(None, count_trailing_zeroes, &[casted_arg]) - diff;\n+                return self.context.new_cast(None, res, result_type);\n             };\n         let count_trailing_zeroes = self.context.get_builtin_function(count_trailing_zeroes);\n         let arg =\n@@ -846,18 +852,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         self.context.new_cast(None, res, result_type)\n     }\n \n-    fn int_width(&self, typ: Type<'gcc>) -> i64 {\n-        self.cx.int_width(typ) as i64\n-    }\n-\n-    fn pop_count(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+    fn pop_count(&mut self, value: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use the optimized version with fewer operations.\n         let result_type = value.get_type();\n         let value_type = result_type.to_unsigned(self.cx);\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_cast(None, value, value_type)\n+                self.gcc_int_cast(value, value_type)\n             }\n             else {\n                 value\n@@ -867,13 +869,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // TODO(antoyo): implement in the normal algorithm below to have a more efficient\n             // implementation (that does not require a call to __popcountdi2).\n             let popcount = self.context.get_builtin_function(\"__builtin_popcountll\");\n-            let sixty_four = self.context.new_rvalue_from_long(value_type, 64);\n-            let high = self.context.new_cast(None, value >> sixty_four, self.cx.ulonglong_type);\n+            let sixty_four = self.gcc_int(value_type, 64);\n+            let right_shift = self.gcc_lshr(value, sixty_four);\n+            let high = self.gcc_int_cast(right_shift, self.cx.ulonglong_type);\n             let high = self.context.new_call(None, popcount, &[high]);\n-            let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n+            let low = self.gcc_int_cast(value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n             let res = high + low;\n-            return self.context.new_cast(None, res, result_type);\n+            return self.gcc_int_cast(res, result_type);\n         }\n \n         // First step.\n@@ -935,27 +938,29 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     // Algorithm from: https://blog.regehr.org/archives/1063\n     fn rotate_left(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n-        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n-        let shift = shift % max;\n+        let max = self.const_uint(shift.get_type(), width);\n+        let shift = self.urem(shift, max);\n         let lhs = self.shl(value, shift);\n+        let result_neg = self.neg(shift);\n         let result_and =\n             self.and(\n-                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n-                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+                result_neg,\n+                self.const_uint(shift.get_type(), width - 1),\n             );\n         let rhs = self.lshr(value, result_and);\n         self.or(lhs, rhs)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063\n     fn rotate_right(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n-        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n-        let shift = shift % max;\n+        let max = self.const_uint(shift.get_type(), width);\n+        let shift = self.urem(shift, max);\n         let lhs = self.lshr(value, shift);\n+        let result_neg = self.neg(shift);\n         let result_and =\n             self.and(\n-                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n-                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+                result_neg,\n+                self.const_uint(shift.get_type(), width - 1),\n             );\n         let rhs = self.shl(value, result_and);\n         self.or(lhs, rhs)\n@@ -995,9 +1000,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n-            // expect, the current blocks in the state need to be updated.\n-            *self.current_block.borrow_mut() = Some(after_block);\n-            self.block = Some(after_block);\n+            // expect, the current block in the state need to be updated.\n+            self.switch_to_block(after_block);\n \n             res.to_rvalue()\n         }\n@@ -1015,39 +1019,59 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n         if signed {\n             // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let func_name =\n-                match width {\n-                    8 => \"__builtin_sub_overflow\",\n-                    16 => \"__builtin_sub_overflow\",\n-                    32 => \"__builtin_ssub_overflow\",\n-                    64 => \"__builtin_ssubll_overflow\",\n-                    128 => \"__builtin_sub_overflow\",\n-                    _ => unreachable!(),\n-                };\n-            let overflow_func = self.context.get_builtin_function(func_name);\n             let result_type = lhs.get_type();\n             let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_diff\");\n-            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+            let supports_native_type = self.is_native_int_type(result_type);\n+            let overflow =\n+                if supports_native_type {\n+                    let func_name =\n+                        match width {\n+                            8 => \"__builtin_sub_overflow\",\n+                            16 => \"__builtin_sub_overflow\",\n+                            32 => \"__builtin_ssub_overflow\",\n+                            64 => \"__builtin_ssubll_overflow\",\n+                            128 => \"__builtin_sub_overflow\",\n+                            _ => unreachable!(),\n+                        };\n+                    let overflow_func = self.context.get_builtin_function(func_name);\n+                    self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None)\n+                }\n+                else {\n+                    let func_name =\n+                        match width {\n+                            128 => \"__rust_i128_subo\",\n+                            _ => unreachable!(),\n+                        };\n+                    let param_a = self.context.new_parameter(None, result_type, \"a\");\n+                    let param_b = self.context.new_parameter(None, result_type, \"b\");\n+                    let result_field = self.context.new_field(None, result_type, \"result\");\n+                    let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                    let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                    let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                    let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                    let overflow = result.access_field(None, overflow_field);\n+                    let int_result = result.access_field(None, result_field);\n+                    self.llbb().add_assignment(None, res, int_result);\n+                    overflow\n+                };\n \n             let then_block = func.new_block(\"then\");\n             let after_block = func.new_block(\"after\");\n \n-            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n-            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n-            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n-                self.context.new_rvalue_from_int(unsigned_type, 0)\n-            );\n-            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n-            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            // NOTE: convert the type to unsigned to have an unsigned shift.\n+            let unsigned_type = result_type.to_unsigned(&self.cx);\n+            let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n+            let uint_max = self.gcc_not(self.gcc_int(unsigned_type, 0));\n+            let int_max = self.gcc_lshr(uint_max, self.gcc_int(unsigned_type, 1));\n+            then_block.add_assignment(None, res, self.gcc_int_cast(self.gcc_add(shifted, int_max), result_type));\n             then_block.end_with_jump(None, after_block);\n \n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n-            // expect, the current blocks in the state need to be updated.\n-            *self.current_block.borrow_mut() = Some(after_block);\n-            self.block = Some(after_block);\n+            // expect, the current block in the state need to be updated.\n+            self.switch_to_block(after_block);\n \n             res.to_rvalue()\n         }\n@@ -1062,7 +1086,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n }\n \n fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n+    // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n+        // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n         bx.call(bx.type_void(), try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind."}, {"sha": "7d7811c878219ebc3b9403e3a13b81f56e6b9594", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -163,5 +163,26 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         simd_xor: Uint, Int => xor;\n     }\n \n+    macro_rules! arith_unary {\n+        ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n+            $(if name == sym::$name {\n+                match in_elem.kind() {\n+                    $($(ty::$p(_))|* => {\n+                        return Ok(bx.$call(args[0].immediate()))\n+                    })*\n+                    _ => {},\n+                }\n+                require!(false,\n+                         \"unsupported operation on `{}` with element `{}`\",\n+                         in_ty,\n+                         in_elem)\n+            })*\n+        }\n+    }\n+\n+    arith_unary! {\n+        simd_neg: Int => neg, Float => fneg;\n+    }\n+\n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "eac4a06226cf8aaf6d7ace95fbf54f176c0fc2ae", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -1,6 +1,7 @@\n /*\n+ * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n- * TODO(antoyo): support LTO.\n+ * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n  *\n  * TODO(antoyo): remove the patches.\n  */\n@@ -21,6 +22,7 @@ extern crate rustc_middle;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n+extern crate tempfile;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n #[allow(unused_extern_crates)]\n@@ -40,15 +42,16 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod int;\n mod intrinsic;\n mod mono_item;\n mod type_;\n mod type_of;\n \n use std::any::Any;\n-use std::sync::Arc;\n+use std::sync::{Arc, Mutex};\n \n-use gccjit::{Context, OptimizationLevel};\n+use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n use rustc_codegen_ssa::base::codegen_crate;\n@@ -61,10 +64,12 @@ use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::query::Providers;\n use rustc_session::config::{Lto, OptLevel, OutputFilenames};\n use rustc_session::Session;\n use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n+use tempfile::TempDir;\n \n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n@@ -77,13 +82,29 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n }\n \n #[derive(Clone)]\n-pub struct GccCodegenBackend;\n+pub struct GccCodegenBackend {\n+    supports_128bit_integers: Arc<Mutex<bool>>,\n+}\n \n impl CodegenBackend for GccCodegenBackend {\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n             sess.warn(\"LTO is not supported. You may get a linker error.\");\n         }\n+\n+        let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");\n+        let temp_file = temp_dir.into_path().join(\"result.asm\");\n+        let check_context = Context::default();\n+        check_context.set_print_errors_to_stderr(false);\n+        let _int128_ty = check_context.new_c_type(CType::UInt128t);\n+        // NOTE: we cannot just call compile() as this would require other files than libgccjit.so.\n+        check_context.compile_to_file(gccjit::OutputKind::Assembler, temp_file.to_str().expect(\"path to str\"));\n+        *self.supports_128bit_integers.lock().expect(\"lock\") = check_context.get_last_error() == Ok(None);\n+    }\n+\n+    fn provide(&self, providers: &mut Providers) {\n+        // FIXME(antoyo) compute list of enabled features from cli flags\n+        providers.global_backend_features = |_tcx, ()| vec![];\n     }\n \n     fn codegen_crate<'tcx>(&self, tcx: TyCtxt<'tcx>, metadata: EncodedMetadata, need_metadata_module: bool) -> Box<dyn Any> {\n@@ -129,7 +150,7 @@ impl ExtraBackendMethods for GccCodegenBackend {\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n-        base::compile_codegen_unit(tcx, cgu_name)\n+        base::compile_codegen_unit(tcx, cgu_name, *self.supports_128bit_integers.lock().expect(\"lock\"))\n     }\n \n     fn target_machine_factory(&self, _sess: &Session, _opt_level: OptLevel, _features: &[String]) -> TargetMachineFactoryFn<Self> {\n@@ -237,7 +258,9 @@ impl WriteBackendMethods for GccCodegenBackend {\n /// This is the entrypoint for a hot plugged rustc_codegen_gccjit\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(GccCodegenBackend)\n+    Box::new(GccCodegenBackend {\n+        supports_128bit_integers: Arc::new(Mutex::new(false)),\n+    })\n }\n \n fn to_gcc_opt_level(optlevel: Option<OptLevel>) -> OptimizationLevel {"}, {"sha": "e95058085216e94aa9482e579ad4b21097e29b33", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n-use crate::common::TypeReflection;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n@@ -119,9 +118,15 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn type_kind(&self, typ: Type<'gcc>) -> TypeKind {\n-        if typ.is_integral() {\n+        if self.is_int_type_or_bool(typ) {\n             TypeKind::Integer\n         }\n+        else if typ.is_compatible_with(self.float_type) {\n+            TypeKind::Float\n+        }\n+        else if typ.is_compatible_with(self.double_type) {\n+            TypeKind::Double\n+        }\n         else if typ.dyncast_vector().is_some() {\n             TypeKind::Vector\n         }\n@@ -175,24 +180,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> u64 {\n-        if typ.is_i8(self) || typ.is_u8(self) {\n-            8\n-        }\n-        else if typ.is_i16(self) || typ.is_u16(self) {\n-            16\n-        }\n-        else if typ.is_i32(self) || typ.is_u32(self) {\n-            32\n-        }\n-        else if typ.is_i64(self) || typ.is_u64(self) {\n-            64\n-        }\n-        else if typ.is_i128(self) || typ.is_u128(self) {\n-            128\n-        }\n-        else {\n-            panic!(\"Cannot get width of int type {:?}\", typ);\n-        }\n+        self.gcc_int_width(typ)\n     }\n \n     fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {"}, {"sha": "ed8f0445ca3e20d07dc67de469b089e6b7cab5a5", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -251,7 +251,9 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             ty::Ref(..) | ty::RawPtr(_) => {\n                 return self.field(cx, index).gcc_type(cx, true);\n             }\n-            ty::Adt(def, _) if def.is_box() => {\n+            // only wide pointer boxes are handled as pointers\n+            // thin pointer boxes with scalar allocators are handled by the general logic below\n+            ty::Adt(def, substs) if def.is_box() && cx.layout_of(substs.type_at(1)).is_zst() => {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return cx.layout_of(ptr_ty).scalar_pair_element_gcc_type(cx, index, immediate);\n             }"}, {"sha": "1beeee136df3106401aed9afdbde9919c8238fd8", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -4,7 +4,7 @@\n \n set -e\n \n-if [ -f ./gcc_path ]; then \n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -14,14 +14,26 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n+features=\n+\n+if [[ \"$1\" == \"--features\" ]]; then\n+    shift\n+    features=\"--features $1\"\n+    shift\n+fi\n+\n if [[ \"$1\" == \"--release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release\n+    CARGO_INCREMENTAL=1 cargo rustc --release $features\n     shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc\n+    cargo rustc $features\n+fi\n+\n+if [[ \"$1\" == \"--build\" ]]; then\n+    exit\n fi\n \n source config.sh\n@@ -145,14 +157,32 @@ function test_rustc() {\n     echo\n     echo \"[TEST] rust-lang/rust\"\n \n-    rust_toolchain=$(cat rust-toolchain)\n+    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n \n     git clone https://github.com/rust-lang/rust.git || true\n     cd rust\n     git fetch\n     git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n     export RUSTFLAGS=\n \n+    git apply - <<EOF\n+diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n+index 887d27fd6dca4..2c2239f2b83d1 100644\n+--- a/src/tools/compiletest/src/header.rs\n++++ b/src/tools/compiletest/src/header.rs\n+@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n+     cfg: Option<&str>,\n+ ) -> test::TestDesc {\n+     let mut ignore = false;\n+     #[cfg(not(bootstrap))]\n+-    let ignore_message: Option<String> = None;\n++    let ignore_message: Option<&str> = None;\n+     let mut should_fail = false;\n+\n+     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n+\n+EOF\n+\n     rm config.toml || true\n \n     cat > config.toml <<EOF\n@@ -175,13 +205,12 @@ EOF\n \n     git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n     for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n       rm $test\n     done\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n-    rm src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs || true # TODO(antoyo): Enable back this test if I ever implement the llvm_asm! macro.\n \n     RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n \n@@ -206,6 +235,14 @@ case $1 in\n         clean_ui_tests\n         ;;\n \n+    \"--std-tests\")\n+        std_tests\n+        ;;\n+\n+    \"--build-sysroot\")\n+        build_sysroot\n+        ;;\n+\n     *)\n         clean\n         mini_tests"}, {"sha": "eb38a8a383575587c6880ecf37160fcf133ba499", "filename": "compiler/rustc_codegen_gcc/tests/run/assign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -51,7 +51,7 @@ mod libc {\n         pub fn fflush(stream: *mut i32) -> i32;\n         pub fn printf(format: *const i8, ...) -> i32;\n \n-        pub static STDOUT: *mut i32;\n+        pub static stdout: *mut i32;\n     }\n }\n \n@@ -67,7 +67,7 @@ mod intrinsics {\n pub fn panic(_msg: &str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n-        libc::fflush(libc::STDOUT);\n+        libc::fflush(libc::stdout);\n         intrinsics::abort();\n     }\n }"}, {"sha": "49376012c40e79e34ca715aabbb6c1e90c271d52", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -0,0 +1,153 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+\n+#![feature(arbitrary_self_types, auto_traits, core_intrinsics, lang_items, start, intrinsics)]\n+\n+#![no_std]\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+/*\n+ * Core\n+ */\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    unsafe {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    let var = 134217856_u128;\n+    let var2 = 10475372733397991552_u128;\n+    let var3 = 193236519889708027473620326106273939584_u128;\n+    let var4 = 123236519889708027473620326106273939584_u128;\n+    let var5 = 153236519889708027473620326106273939584_u128;\n+    let var6 = 18446744073709551616_i128;\n+    let var7 = 170141183460469231731687303715884105728_u128;\n+\n+    // Shifts.\n+    assert_eq!(var << (argc as u128 - 1), var);\n+    assert_eq!(var << argc as u128, 268435712);\n+    assert_eq!(var << (argc + 32) as u128, 1152922604118474752);\n+    assert_eq!(var << (argc + 48) as u128, 75557935783508361347072);\n+    assert_eq!(var << (argc + 60) as u128, 309485304969250248077606912);\n+    assert_eq!(var << (argc + 62) as u128, 1237941219877000992310427648);\n+    assert_eq!(var << (argc + 63) as u128, 2475882439754001984620855296);\n+    assert_eq!(var << (argc + 80) as u128, 324518863143436548128224745357312);\n+\n+    assert_eq!(var2 << argc as u128, 20950745466795983104);\n+    assert_eq!(var2 << (argc as u128 - 1), var2);\n+    assert_eq!(var2 << (argc + 32) as u128, 89982766606709001335848566784);\n+    assert_eq!(var2 << (argc + 48) as u128, 5897110592337281111546171672756224);\n+    assert_eq!(var2 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n+    assert_eq!(var2 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n+    assert_eq!(var2 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n+\n+    assert_eq!(var3 << argc as u128, 46190672858477591483866044780779667712);\n+    assert_eq!(var3 << (argc as u128 - 1), var3);\n+    assert_eq!(var3 << (argc + 32) as u128, 21267668304951024224840338247585366016);\n+    assert_eq!(var3 << (argc + 48) as u128, 1335125106377253154015353231953100800);\n+    assert_eq!(var3 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n+    assert_eq!(var3 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n+    assert_eq!(var3 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n+\n+    assert_eq!((2220326408_u32 + argc as u32) >> (32 - 6), 33);\n+\n+    assert_eq!(var >> (argc as u128 - 1), var);\n+    assert_eq!(var >> argc as u128, 67108928);\n+    assert_eq!(var >> (argc + 32) as u128, 0);\n+    assert_eq!(var >> (argc + 48) as u128, 0);\n+    assert_eq!(var >> (argc + 60) as u128, 0);\n+    assert_eq!(var >> (argc + 62) as u128, 0);\n+    assert_eq!(var >> (argc + 63) as u128, 0);\n+\n+    assert_eq!(var2 >> argc as u128, 5237686366698995776);\n+    assert_eq!(var2 >> (argc as u128 - 1), var2);\n+    assert_eq!(var2 >> (argc + 32) as u128, 1219493888);\n+    assert_eq!(var2 >> (argc + 48) as u128, 18608);\n+    assert_eq!(var2 >> (argc + 60) as u128, 4);\n+    assert_eq!(var2 >> (argc + 62) as u128, 1);\n+    assert_eq!(var2 >> (argc + 63) as u128, 0);\n+\n+    assert_eq!(var3 >> (argc as u128 - 1), var3);\n+    assert_eq!(var3 >> argc as u128, 96618259944854013736810163053136969792);\n+    assert_eq!(var3 >> (argc + 32) as u128, 22495691651677250335181635584);\n+    assert_eq!(var3 >> (argc + 48) as u128, 343257013727985387194544);\n+    assert_eq!(var3 >> (argc + 60) as u128, 83802981867183932420);\n+    assert_eq!(var3 >> (argc + 62) as u128, 20950745466795983105);\n+    assert_eq!(var3 >> (argc + 63) as u128, 10475372733397991552);\n+    assert_eq!(var3 >> (argc + 80) as u128, 79920751444992);\n+\n+    assert_eq!(var6 >> argc as u128, 9223372036854775808);\n+    assert_eq!((var6 - 1) >> argc as u128, 9223372036854775807);\n+    assert_eq!(var7 >> argc as u128, 85070591730234615865843651857942052864);\n+\n+    // Casts\n+    assert_eq!((var >> (argc + 32) as u128) as u64, 0);\n+    assert_eq!((var >> argc as u128) as u64, 67108928);\n+\n+    // Addition.\n+    assert_eq!(var + argc as u128, 134217857);\n+\n+    assert_eq!(var2 + argc as u128, 10475372733397991553);\n+    assert_eq!(var2 + (var2 + argc as u128) as u128, 20950745466795983105);\n+\n+    assert_eq!(var3 + argc as u128, 193236519889708027473620326106273939585);\n+\n+    // Subtraction\n+    assert_eq!(var - argc as u128, 134217855);\n+\n+    assert_eq!(var2 - argc as u128, 10475372733397991551);\n+\n+    assert_eq!(var3 - argc as u128, 193236519889708027473620326106273939583);\n+\n+    // Multiplication\n+    assert_eq!(var * (argc + 1) as u128, 268435712);\n+    assert_eq!(var * (argc as u128 + var2), 1405982069077538020949770368);\n+\n+    assert_eq!(var2 * (argc + 1) as u128, 20950745466795983104);\n+    assert_eq!(var2 * (argc as u128 + var2), 109733433903618109003204073240861360256);\n+\n+    assert_eq!(var3 * argc as u128, 193236519889708027473620326106273939584);\n+\n+    assert_eq!(var4 * (argc + 1) as u128, 246473039779416054947240652212547879168);\n+\n+    assert_eq!(var5 * (argc + 1) as u128, 306473039779416054947240652212547879168);\n+\n+    // Division.\n+    assert_eq!(var / (argc + 1) as u128, 67108928);\n+    assert_eq!(var / (argc + 2) as u128, 44739285);\n+\n+    assert_eq!(var2 / (argc + 1) as u128, 5237686366698995776);\n+    assert_eq!(var2 / (argc + 2) as u128, 3491790911132663850);\n+\n+    assert_eq!(var3 / (argc + 1) as u128, 96618259944854013736810163053136969792);\n+    assert_eq!(var3 / (argc + 2) as u128, 64412173296569342491206775368757979861);\n+    assert_eq!(var3 / (argc as u128 + var4), 1);\n+    assert_eq!(var3 / (argc as u128 + var2), 18446744073709551615);\n+\n+    assert_eq!(var4 / (argc + 1) as u128, 61618259944854013736810163053136969792);\n+    assert_eq!(var4 / (argc + 2) as u128, 41078839963236009157873442035424646528);\n+\n+    0\n+}"}, {"sha": "6477b83982804646fbb7bc9c597e9dcd8a09a3d4", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -49,7 +49,7 @@ mod libc {\n         pub fn puts(s: *const u8) -> i32;\n         pub fn fflush(stream: *mut i32) -> i32;\n \n-        pub static STDOUT: *mut i32;\n+        pub static stdout: *mut i32;\n     }\n }\n \n@@ -65,7 +65,7 @@ mod intrinsics {\n pub fn panic(_msg: &str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n-        libc::fflush(libc::STDOUT);\n+        libc::fflush(libc::stdout);\n         intrinsics::abort();\n     }\n }"}, {"sha": "52de20021f3e0c16c506573e7cf2f896027d317c", "filename": "compiler/rustc_codegen_gcc/tests/run/mut_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -53,7 +53,7 @@ mod libc {\n         pub fn fflush(stream: *mut i32) -> i32;\n         pub fn printf(format: *const i8, ...) -> i32;\n \n-        pub static STDOUT: *mut i32;\n+        pub static stdout: *mut i32;\n     }\n }\n \n@@ -69,7 +69,7 @@ mod intrinsics {\n pub fn panic(_msg: &str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n-        libc::fflush(libc::STDOUT);\n+        libc::fflush(libc::stdout);\n         intrinsics::abort();\n     }\n }"}, {"sha": "e078b37b4aba9ed247fe3849b74fdb4d649ed7b5", "filename": "compiler/rustc_codegen_gcc/tests/run/operations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -59,7 +59,7 @@ mod libc {\n         pub fn puts(s: *const u8) -> i32;\n         pub fn fflush(stream: *mut i32) -> i32;\n \n-        pub static STDOUT: *mut i32;\n+        pub static stdout: *mut i32;\n     }\n }\n \n@@ -75,7 +75,7 @@ mod intrinsics {\n pub fn panic(_msg: &str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n-        libc::fflush(libc::STDOUT);\n+        libc::fflush(libc::stdout);\n         intrinsics::abort();\n     }\n }"}, {"sha": "294add968449a4c6104e553cc99f5644442274e4", "filename": "compiler/rustc_codegen_gcc/tests/run/static.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbff48e09463618dde1627883a350b7427ae6d44/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs?ref=bbff48e09463618dde1627883a350b7427ae6d44", "patch": "@@ -22,6 +22,12 @@\n #[lang = \"sized\"]\n pub trait Sized {}\n \n+#[lang = \"destruct\"]\n+pub trait Destruct {}\n+\n+#[lang = \"drop\"]\n+pub trait Drop {}\n+\n #[lang = \"copy\"]\n trait Copy {\n }"}]}