{"sha": "21359c3ab5fc497d11b2c0f0435c7635336a726e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMzU5YzNhYjVmYzQ5N2QxMWIyYzBmMDQzNWM3NjM1MzM2YTcyNmU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-25T17:05:16Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-26T15:23:40Z"}, "message": "Take visibility into account for glob imports", "tree": {"sha": "ad438e045f50be776a9245ceb367598e7b60f8f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad438e045f50be776a9245ceb367598e7b60f8f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21359c3ab5fc497d11b2c0f0435c7635336a726e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21359c3ab5fc497d11b2c0f0435c7635336a726e", "html_url": "https://github.com/rust-lang/rust/commit/21359c3ab5fc497d11b2c0f0435c7635336a726e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21359c3ab5fc497d11b2c0f0435c7635336a726e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac25f119eb45d425370d9f7f093bc206e6c4a9f", "html_url": "https://github.com/rust-lang/rust/commit/8ac25f119eb45d425370d9f7f093bc206e6c4a9f"}], "stats": {"total": 208, "additions": 165, "deletions": 43}, "files": [{"sha": "db5f469c76787d4fd07a9bd3fd1fad5ea09323ea", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -149,16 +149,8 @@ impl ItemScope {\n         changed\n     }\n \n-    #[cfg(test)]\n-    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n-        self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n-    }\n-\n-    pub(crate) fn collect_resolutions_with_vis(\n-        &self,\n-        vis: ResolvedVisibility,\n-    ) -> Vec<(Name, PerNs)> {\n-        self.visible.iter().map(|(name, res)| (name.clone(), res.with_visibility(vis))).collect()\n+    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Name, PerNs)> + 'a {\n+        self.visible.iter().map(|(name, res)| (name.clone(), res.clone()))\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {"}, {"sha": "51df44d2f327971bd61a815f3276a3d586064237", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -109,7 +109,7 @@ struct MacroDirective {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, raw::Import)>>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, ResolvedVisibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n@@ -218,6 +218,7 @@ where\n             self.update(\n                 self.def_map.root,\n                 &[(name, PerNs::macros(macro_, ResolvedVisibility::Public))],\n+                ResolvedVisibility::Public,\n             );\n         }\n     }\n@@ -352,7 +353,6 @@ where\n \n     fn record_resolved_import(&mut self, directive: &ImportDirective) {\n         let module_id = directive.module_id;\n-        let import_id = directive.import_id;\n         let import = &directive.import;\n         let def = directive.status.namespaces();\n         let vis = self\n@@ -373,28 +373,48 @@ where\n                         let item_map = self.db.crate_def_map(m.krate);\n                         let scope = &item_map[m.local_id].scope;\n \n-                        // TODO: only use names we can see\n-\n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions_with_vis(vis);\n-\n-                        self.update(module_id, &items);\n+                        let items = scope\n+                            .resolutions()\n+                            // only keep visible names...\n+                            .map(|(n, res)| {\n+                                (\n+                                    n,\n+                                    res.filter_visibility(|v| {\n+                                        v.visible_from_def_map(&self.def_map, module_id)\n+                                    }),\n+                                )\n+                            })\n+                            .filter(|(_, res)| !res.is_none())\n+                            .collect::<Vec<_>>();\n+\n+                        self.update(module_id, &items, vis);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n                         let scope = &self.def_map[m.local_id].scope;\n \n-                        // TODO: only use names we can see\n-\n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions_with_vis(vis);\n-\n-                        self.update(module_id, &items);\n+                        let items = scope\n+                            .resolutions()\n+                            // only keep visible names...\n+                            .map(|(n, res)| {\n+                                (\n+                                    n,\n+                                    res.filter_visibility(|v| {\n+                                        v.visible_from_def_map(&self.def_map, module_id)\n+                                    }),\n+                                )\n+                            })\n+                            .filter(|(_, res)| !res.is_none())\n+                            .collect::<Vec<_>>();\n+\n+                        self.update(module_id, &items, vis);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n-                        if !glob.iter().any(|it| *it == (module_id, import_id)) {\n-                            glob.push((module_id, import_id));\n+                        if !glob.iter().any(|(mid, _)| *mid == module_id) {\n+                            glob.push((module_id, vis));\n                         }\n                     }\n                 }\n@@ -412,7 +432,7 @@ where\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions);\n+                    self.update(module_id, &resolutions, vis);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -434,21 +454,29 @@ where\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def.with_visibility(vis))]);\n+                    self.update(module_id, &[(name, def)], vis);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)]) {\n-        self.update_recursive(module_id, resolutions, 0)\n+    fn update(\n+        &mut self,\n+        module_id: LocalModuleId,\n+        resolutions: &[(Name, PerNs)],\n+        vis: ResolvedVisibility,\n+    ) {\n+        self.update_recursive(module_id, resolutions, vis, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n         resolutions: &[(Name, PerNs)],\n+        // All resolutions are imported with this visibility; the visibilies in\n+        // the `PerNs` values are ignored and overwritten\n+        vis: ResolvedVisibility,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -458,7 +486,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), *res);\n+            changed |= scope.push_res(name.clone(), res.with_visibility(vis));\n         }\n \n         if !changed {\n@@ -471,9 +499,13 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, _glob_import) in glob_imports {\n-            // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n+        for (glob_importing_module, glob_import_vis) in glob_imports {\n+            // we know all resolutions have the same visibility (`vis`), so we\n+            // just need to check that once\n+            if !vis.visible_from_def_map(&self.def_map, glob_importing_module) {\n+                continue;\n+            }\n+            self.update_recursive(glob_importing_module, resolutions, glob_import_vis, depth + 1);\n         }\n     }\n \n@@ -715,7 +747,7 @@ where\n         let def: ModuleDefId = module.into();\n         let vis = ResolvedVisibility::Public; // TODO handle module visibility\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))]);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis);\n         res\n     }\n \n@@ -780,7 +812,7 @@ where\n             .def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, vis)\n             .unwrap_or(ResolvedVisibility::Public);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))])\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis)\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "78bcdc850bf02eb866976e1b5b42f7f98faba24c", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -12,8 +12,8 @@ use test_utils::covers;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n \n-fn def_map(fixtute: &str) -> String {\n-    let dm = compute_crate_def_map(fixtute);\n+fn def_map(fixture: &str) -> String {\n+    let dm = compute_crate_def_map(fixture);\n     render_crate_def_map(&dm)\n }\n \n@@ -32,7 +32,7 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let mut entries = map.modules[module].scope.collect_resolutions();\n+        let mut entries: Vec<_> = map.modules[module].scope.resolutions().collect();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n         for (name, def) in entries {"}, {"sha": "5f137d3a66208403f647728736bd486ce5f83f1a", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -73,6 +73,84 @@ fn glob_2() {\n     );\n }\n \n+#[test]\n+fn glob_privacy_1() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::*;\n+        struct PrivateStructFoo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        struct PrivateStructBar;\n+        pub use super::*;\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    Baz: t v\n+    bar: t\n+    foo: t\n+    \n+    crate::foo\n+    Baz: t v\n+    PrivateStructFoo: t v\n+    bar: t\n+    \n+    crate::foo::bar\n+    Baz: t v\n+    PrivateStructBar: t v\n+    PrivateStructFoo: t v\n+    bar: t\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn glob_privacy_2() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+        use foo::bar::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        fn Foo() {};\n+        pub struct Foo {};\n+\n+        //- /foo/bar.rs\n+        pub(super) struct PrivateBaz;\n+        struct PrivateBar;\n+        pub(crate) struct PubCrateStruct;\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    Foo: t\n+    PubCrateStruct: t v\n+    bar: t\n+    foo: t\n+    \n+    crate::foo\n+    Foo: t v\n+    bar: t\n+    \n+    crate::foo::bar\n+    PrivateBar: t v\n+    PrivateBaz: t v\n+    PubCrateStruct: t v\n+    \"###\n+    );\n+}\n+\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);"}, {"sha": "faeb7aa4dd811ed55650c30b0b80850b11d42e70", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -116,7 +116,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n+            assert_eq!(module_data.scope.resolutions().collect::<Vec<_>>().len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n@@ -126,7 +126,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n+            assert_eq!(module_data.scope.resolutions().collect::<Vec<_>>().len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }"}, {"sha": "7637d8a37a018993ceb5277c93bbb86d60432e37", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -61,6 +61,14 @@ impl PerNs {\n         self.macros.map(|it| it.0)\n     }\n \n+    pub fn filter_visibility(self, mut f: impl FnMut(ResolvedVisibility) -> bool) -> PerNs {\n+        PerNs {\n+            types: self.types.filter(|(_, v)| f(*v)),\n+            values: self.values.filter(|(_, v)| f(*v)),\n+            macros: self.macros.filter(|(_, v)| f(*v)),\n+        }\n+    }\n+\n     pub fn with_visibility(self, vis: ResolvedVisibility) -> PerNs {\n         PerNs {\n             types: self.types.map(|(it, _)| (it, vis)),"}, {"sha": "990b2975c03e359807dde122617ca4a16eb7f45a", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21359c3ab5fc497d11b2c0f0435c7635336a726e/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=21359c3ab5fc497d11b2c0f0435c7635336a726e", "patch": "@@ -134,13 +134,25 @@ impl ResolvedVisibility {\n         if from_module.krate != to_module.krate {\n             return false;\n         }\n-        // from_module needs to be a descendant of to_module\n         let def_map = db.crate_def_map(from_module.krate);\n+        self.visible_from_def_map(&def_map, from_module.local_id)\n+    }\n+\n+    pub(crate) fn visible_from_def_map(\n+        self,\n+        def_map: &crate::nameres::CrateDefMap,\n+        from_module: crate::LocalModuleId,\n+    ) -> bool {\n+        let to_module = match self {\n+            ResolvedVisibility::Module(m) => m,\n+            ResolvedVisibility::Public => return true,\n+        };\n+        // from_module needs to be a descendant of to_module\n         let mut ancestors = std::iter::successors(Some(from_module), |m| {\n-            let parent_id = def_map[m.local_id].parent?;\n-            Some(ModuleId { local_id: parent_id, ..*m })\n+            let parent_id = def_map[*m].parent?;\n+            Some(parent_id)\n         });\n-        ancestors.any(|m| m == to_module)\n+        ancestors.any(|m| m == to_module.local_id)\n     }\n }\n "}]}