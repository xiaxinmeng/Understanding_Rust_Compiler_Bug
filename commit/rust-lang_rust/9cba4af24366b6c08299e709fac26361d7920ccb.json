{"sha": "9cba4af24366b6c08299e709fac26361d7920ccb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYmE0YWYyNDM2NmI2YzA4Mjk5ZTcwOWZhYzI2MzYxZDc5MjBjY2I=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T18:47:27Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T18:47:27Z"}, "message": "manual: describe structs, split out handling of recursion from enums, deprecate records.", "tree": {"sha": "b0b7cd45488ca0a5f07f38040b0a48931e740ea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b7cd45488ca0a5f07f38040b0a48931e740ea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cba4af24366b6c08299e709fac26361d7920ccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cba4af24366b6c08299e709fac26361d7920ccb", "html_url": "https://github.com/rust-lang/rust/commit/9cba4af24366b6c08299e709fac26361d7920ccb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cba4af24366b6c08299e709fac26361d7920ccb/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0673b49b05f2de2a67dd81a27a2af4eeb0ccc830", "url": "https://api.github.com/repos/rust-lang/rust/commits/0673b49b05f2de2a67dd81a27a2af4eeb0ccc830", "html_url": "https://github.com/rust-lang/rust/commit/0673b49b05f2de2a67dd81a27a2af4eeb0ccc830"}], "stats": {"total": 159, "additions": 100, "deletions": 59}, "files": [{"sha": "5f5cde72cf973cc905605b215a499087c2c38046", "filename": "doc/rust.md", "status": "modified", "additions": 100, "deletions": 59, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9cba4af24366b6c08299e709fac26361d7920ccb/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cba4af24366b6c08299e709fac26361d7920ccb/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=9cba4af24366b6c08299e709fac26361d7920ccb", "patch": "@@ -705,6 +705,7 @@ There are several kinds of item:\n   * [modules](#modules)\n   * [functions](#functions)\n   * [type definitions](#type-definitions)\n+  * [structures](#structures)\n   * [enumerations](#enumerations)\n   * [constants](#constants)\n   * [traits](#traits)\n@@ -1111,49 +1112,35 @@ that are composite records, each containing two unsigned 8-bit integers\n accessed through the components `x` and `y`, and laid out in memory with the\n `x` component preceding the `y` component.\n \n-### Enumerations\n-\n-An _enumeration item_ simultaneously declares a new nominal\n-[enumerated type](#enumerated-types) as well as a set of *constructors* that\n-can be used to create or pattern-match values of the corresponding enumerated\n-type.\n+### Structures\n \n-The constructors of an `enum` type may be recursive: that is, each constructor\n-may take an argument that refers, directly or indirectly, to the enumerated\n-type the constructor is a member of. Such recursion has restrictions:\n+A _structure_ is a nominal [structure type](#structure-types) defined with the keyword `struct`.\n \n-* Recursive types can be introduced only through `enum` constructors.\n-* A recursive `enum` item must have at least one non-recursive constructor (in\n-  order to give the recursion a basis case).\n-* The recursive argument of recursive `enum` constructors must be [*box*\n-  values](#box-types) (in order to bound the in-memory size of the\n-  constructor).\n-* Recursive type definitions can cross module boundaries, but not module\n-  *visibility* boundaries or crate boundaries (in order to simplify the\n-  module system).\n+An example of a `struct` item and its use:\n \n+~~~~\n+struct Point {x: int, y: int}\n+let p = Point {x: 10, y: 11};\n+let px: int = p.x;\n+~~~~\n \n-An example of an `enum` item and its use:\n+### Enumerations\n \n-~~~~\n-enum animal {\n-  dog,\n-  cat\n-}\n+An _enumeration_ is a simulatneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,\n+that can be used to create or pattern-match values of the corresponding enumerated type.\n \n-let mut a: animal = dog;\n-a = cat;\n-~~~~\n+Enumerations are declared with the keyword `enum`.\n \n-An example of a *recursive* `enum` item and its use:\n+An example of an `enum` item and its use:\n \n ~~~~\n-enum list<T> {\n-  nil,\n-  cons(T, @list<T>)\n+enum Animal {\n+  Dog,\n+  Cat\n }\n \n-let a: list<int> = cons(7, @cons(13, @nil));\n+let mut a: Animal = Dog;\n+a = Cat;\n ~~~~\n \n ### Constants\n@@ -2374,22 +2361,6 @@ A value of type `~str` is a Unicode string, represented as a vector of 8-bit\n unsigned bytes holding a sequence of UTF-8 codepoints.\n \n \n-### Record types\n-\n-The record type-constructor forms a new heterogeneous product of values.^[The\n-record type-constructor is analogous to the `struct` type-constructor in the\n-Algol/C family, the *record* types of the ML family, or the *structure* types\n-of the Lisp family.] Fields of a record type are accessed by name and are\n-arranged in memory in the order specified by the record type.\n-\n-An example of a record type and its use:\n-\n-~~~~\n-type point = {x: int, y: int};\n-let p: point = {x: 10, y: 11};\n-let px: int = p.x;\n-~~~~\n-\n ### Tuple types\n \n The tuple type-constructor forms a new heterogeneous product of values similar\n@@ -2414,6 +2385,7 @@ let (a, b) = p;\n assert b != ~\"world\";\n ~~~~\n \n+\n ### Vector types\n \n The vector type-constructor represents a homogeneous array of values of a\n@@ -2448,16 +2420,88 @@ All accessible elements of a vector are always initialized, and access to a\n vector is always bounds-checked.\n \n \n+### Structure types\n+\n+A `struct` *type* is a heterogeneous product of other types, called the *fields* of the type.\n+^[`struct` types are analogous `struct` types in C,\n+the *record* types of the ML family,\n+or the *structure* types of the Lisp family.]\n+\n+New instances of a `struct` can be constructed with a [struct expression](#struct-expressions).\n+\n+The memory order of fields in a `struct` is given by the item defining it.\n+Fields may be given in any order in a corresponding struct *expression*;\n+the resulting `struct` value will always be laid out in memory in the order specified by the corresponding *item*.\n+\n+The fields of a `struct` may be qualified by [visibility modifiers](#visibility-modifiers),\n+to restrict access to implementation-private data in a structure.\n+\n+\n ### Enumerated types\n \n-An *enumerated type* is a nominal, heterogeneous disjoint union type.^[The\n-`enum` type is analogous to a `data` constructor declaration in ML or a *pick\n-ADT* in Limbo.] An [`enum` *item*](#enumerations) consists of a number of\n-*constructors*, each of which is independently named and takes an optional\n-tuple of arguments.\n+An *enumerated type* is a nominal, heterogeneous disjoint union type,\n+denoted by the name of an [`enum` item](#enumerations).\n+^[The `enum` type is analogous to a `data` constructor declaration in ML,\n+or a *pick ADT* in Limbo.]\n+\n+An [`enum` item](#enumerations) declares both the type and a number of *variant constructors*,\n+each of which is independently named and takes an optional tuple of arguments.\n+\n+New instances of an `enum` can be constructed by calling one of the variant constructors,\n+in a [call expression](#call-expressions).\n+\n+Any `enum` value consumes as much memory as the largest variant constructor for its corresponding `enum` type.\n+\n+Enum types cannot be denoted *structurally* as types,\n+but must be denoted by named reference to an [`enum` item](#enumerations).\n+\n+\n+### Recursive types\n+\n+Nominal types -- [enumerations](#enumerated-types) and [structures](#structure-types) -- may be recursive.\n+That is, each `enum` constructor or `struct` field may refer, directly or indirectly, to the enclosing `enum` or `struct` type itself.\n+Such recursion has restrictions:\n+\n+* Recursive types must include a nominal type in the recursion\n+  (not mere [type definitions](#type-definitions),\n+   or other structural types such as [vectors](#vector-types) or [tuples](#tuple-types)).\n+* A recursive `enum` item must have at least one non-recursive constructor\n+  (in order to give the recursion a basis case).\n+* The size of a recursive type must be finite;\n+  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n+* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n+  or crate boundaries (in order to simplify the module system and type checker).\n+\n+An example of a *recursive* type and its use:\n+\n+~~~~\n+enum List<T> {\n+  Nil,\n+  Cons(T, @List<T>)\n+}\n+\n+let a: List<int> = Cons(7, @Cons(13, @Nil));\n+~~~~\n+\n+\n+### Record types\n+\n+> **Note:** Records are not nominal types, thus do not directly support recursion, visibility control,\n+> out-of-order field initialization, or coherent trait implementation.\n+> Records are therefore deprecared and will be removed in future versions of Rust.\n+> [Structure types](#structure-types) should be used instead.\n+\n+The record type-constructor forms a new heterogeneous product of values.\n+Fields of a record type are accessed by name and are arranged in memory in the order specified by the record type.\n+\n+An example of a record type and its use:\n+\n+~~~~\n+type Point = {x: int, y: int};\n+let p: Point = {x: 10, y: 11};\n+let px: int = p.x;\n+~~~~\n \n-Enumerated types cannot be denoted *structurally* as types, but must be\n-denoted by named reference to an [*enumeration* item](#enumerations).\n \n ### Pointer types\n \n@@ -2507,6 +2551,7 @@ Raw pointers (`*`)\n     they exist to support interoperability with foreign code,\n     and writing performance-critical or low-level functions.\n \n+\n ### Function types\n \n The function type-constructor `fn` forms new function types. A function type\n@@ -2553,10 +2598,6 @@ fn main() {\n In this example, the trait `printable` occurs as a type in both the type signature of\n `print`, and the cast expression in `main`.\n \n-### Struct types\n-\n-Every struct item defines a type.\n-\n ### Type parameters\n \n Within the body of an item that has type parameter declarations, the names of its type parameters are types:"}]}