{"sha": "5e57faa78aa7661c6000204591558f6665f11abc", "node_id": "C_kwDOAAsO6NoAKDVlNTdmYWE3OGFhNzY2MWM2MDAwMjA0NTkxNTU4ZjY2NjVmMTFhYmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-19T15:01:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-19T15:01:10Z"}, "message": "Auto merge of #93069 - matthiaskrgr:rollup-gx1vkp7, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #88642 (Formally implement let chains)\n - #89621 (doc: guarantee call order for sort_by_cached_key)\n - #91278 (Use iterator instead of recursion in `codegen_place`)\n - #92124 (Little improves in CString `new` when creating from slice)\n - #92783 (Annotate dead code lint with notes about ignored derived impls)\n - #92797 (Remove horizontal lines at top of page)\n - #92920 (Move expr- and item-related pretty printing functions to modules)\n - #93041 (Remove some unused ordering derivations based on `DefId`)\n - #93051 (Add Option::is_some_with and Result::is_{ok,err}_with)\n - #93062 (Update books)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0d7d6afe76f91d3e842864612f968eeac9c708cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d7d6afe76f91d3e842864612f968eeac9c708cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e57faa78aa7661c6000204591558f6665f11abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e57faa78aa7661c6000204591558f6665f11abc", "html_url": "https://github.com/rust-lang/rust/commit/5e57faa78aa7661c6000204591558f6665f11abc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e57faa78aa7661c6000204591558f6665f11abc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f004d2d401682e553af3984ebd9a3976885e752", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f004d2d401682e553af3984ebd9a3976885e752", "html_url": "https://github.com/rust-lang/rust/commit/2f004d2d401682e553af3984ebd9a3976885e752"}, {"sha": "ea1275a62ce5d1671af2d2c6556f9e5937d025db", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1275a62ce5d1671af2d2c6556f9e5937d025db", "html_url": "https://github.com/rust-lang/rust/commit/ea1275a62ce5d1671af2d2c6556f9e5937d025db"}], "stats": {"total": 3732, "additions": 2045, "deletions": 1687}, "files": [{"sha": "6c172d59f837b4f97690ea8582e11a13a91baee1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -392,14 +392,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n     // in a temporary block.\n     fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        match cond.kind {\n-            hir::ExprKind::Let(..) => cond,\n-            _ => {\n-                let span_block =\n-                    self.mark_span_with_reason(DesugaringKind::CondTemporary, cond.span, None);\n-                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n+            match expr.kind {\n+                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                hir::ExprKind::Let(..) => true,\n+                _ => false,\n             }\n         }\n+        if has_let_expr(cond) {\n+            cond\n+        } else {\n+            let reason = DesugaringKind::CondTemporary;\n+            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+        }\n     }\n \n     // We desugar: `'label: while $cond $body` into:"}, {"sha": "a6ecfa4520608a42cf1425844db1171b84313733", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -707,11 +707,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         \"`if let` guards are experimental\",\n         \"you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\"\n     );\n-    gate_all!(\n-        let_chains,\n-        \"`let` expressions in this position are experimental\",\n-        \"you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\"\n-    );\n+    gate_all!(let_chains, \"`let` expressions in this position are unstable\");\n     gate_all!(\n         async_closure,\n         \"async closures are unstable\","}, {"sha": "487451466f1f0af80fbb27ac16cd710029ac3e2e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 5, "deletions": 1200, "changes": 1205, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1,3 +1,6 @@\n+mod expr;\n+mod item;\n+\n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n@@ -6,10 +9,10 @@ use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, T\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n-use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::util::parser;\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::{attr, Term};\n-use rustc_ast::{GenericArg, MacArgs, ModKind};\n+use rustc_ast::{GenericArg, MacArgs};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -210,10 +213,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n-}\n-\n impl std::ops::Deref for State<'_> {\n     type Target = pp::Printer;\n     fn deref(&self) -> &Self::Target {\n@@ -938,13 +937,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &nmod.items {\n-            self.print_foreign_item(item);\n-        }\n-    }\n-\n     pub fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) {\n         if let Some(lt) = *lifetime {\n             self.print_lifetime(lt);\n@@ -1057,343 +1049,6 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n-            }\n-            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                generics,\n-                bounds,\n-                ty,\n-            }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::ForeignItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n-    fn print_item_const(\n-        &mut self,\n-        ident: Ident,\n-        mutbl: Option<ast::Mutability>,\n-        ty: &ast::Ty,\n-        body: Option<&ast::Expr>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        let leading = match mutbl {\n-            None => \"const\",\n-            Some(ast::Mutability::Not) => \"static\",\n-            Some(ast::Mutability::Mut) => \"static mut\",\n-        };\n-        self.word_space(leading);\n-        self.print_ident(ident);\n-        self.word_space(\":\");\n-        self.print_type(ty);\n-        if body.is_some() {\n-            self.space();\n-        }\n-        self.end(); // end the head-ibox\n-        if let Some(body) = body {\n-            self.word_space(\"=\");\n-            self.print_expr(body);\n-        }\n-        self.word(\";\");\n-        self.end(); // end the outer cbox\n-    }\n-\n-    fn print_associated_type(\n-        &mut self,\n-        ident: Ident,\n-        generics: &ast::Generics,\n-        bounds: &ast::GenericBounds,\n-        ty: Option<&ast::Ty>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.word_space(\"type\");\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_type_bounds(\":\", bounds);\n-        self.print_where_clause(&generics.where_clause);\n-        if let Some(ty) = ty {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_type(ty);\n-        }\n-        self.word(\";\");\n-        self.end(); // end inner head-block\n-        self.end(); // end outer head-block\n-    }\n-\n-    /// Pretty-prints an item.\n-    crate fn print_item(&mut self, item: &ast::Item) {\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n-            ast::ItemKind::ExternCrate(orig_name) => {\n-                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n-                    self.print_name(orig_name);\n-                    self.space();\n-                    self.word(\"as\");\n-                    self.space();\n-                }\n-                self.print_ident(item.ident);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Use(ref tree) => {\n-                self.head(visibility_qualified(&item.vis, \"use\"));\n-                self.print_use_tree(tree);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n-                self.print_fn_full(\n-                    sig,\n-                    item.ident,\n-                    generics,\n-                    &item.vis,\n-                    defaultness,\n-                    body,\n-                    &item.attrs,\n-                );\n-            }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n-                    s.word(\"mod\");\n-                }));\n-                self.print_ident(item.ident);\n-\n-                match mod_kind {\n-                    ModKind::Loaded(items, ..) => {\n-                        self.nbsp();\n-                        self.bopen();\n-                        self.print_inner_attributes(&item.attrs);\n-                        for item in items {\n-                            self.print_item(item);\n-                        }\n-                        let empty = item.attrs.is_empty() && items.is_empty();\n-                        self.bclose(item.span, empty);\n-                    }\n-                    ModKind::Unloaded => {\n-                        self.word(\";\");\n-                        self.end(); // end inner head-block\n-                        self.end(); // end outer head-block\n-                    }\n-                }\n-            }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_unsafety(nmod.unsafety);\n-                    s.word(\"extern\");\n-                }));\n-                if let Some(abi) = nmod.abi {\n-                    self.print_literal(&abi.as_lit());\n-                    self.nbsp();\n-                }\n-                self.bopen();\n-                self.print_foreign_mod(nmod, &item.attrs);\n-                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n-                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n-                self.print_inline_asm(asm);\n-                self.end();\n-            }\n-            ast::ItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                ref generics,\n-                ref bounds,\n-                ref ty,\n-            }) => {\n-                let ty = ty.as_deref();\n-                self.print_associated_type(\n-                    item.ident,\n-                    generics,\n-                    bounds,\n-                    ty,\n-                    &item.vis,\n-                    defaultness,\n-                );\n-            }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n-            }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"struct\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"union\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Impl(box ast::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n-                self.word(\"impl\");\n-\n-                if generics.params.is_empty() {\n-                    self.nbsp();\n-                } else {\n-                    self.print_generic_params(&generics.params);\n-                    self.space();\n-                }\n-\n-                self.print_constness(constness);\n-\n-                if let ast::ImplPolarity::Negative(_) = polarity {\n-                    self.word(\"!\");\n-                }\n-\n-                if let Some(ref t) = *of_trait {\n-                    self.print_trait_ref(t);\n-                    self.space();\n-                    self.word_space(\"for\");\n-                }\n-\n-                self.print_type(self_ty);\n-                self.print_where_clause(&generics.where_clause);\n-\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for impl_item in items {\n-                    self.print_assoc_item(impl_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::Trait(box ast::Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-                ..\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n-                self.word_nbsp(\"trait\");\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.print_type_bounds(\":\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\" \");\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for trait_item in items {\n-                    self.print_assoc_item(trait_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.head(visibility_qualified(&item.vis, \"trait\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.nbsp();\n-                self.print_type_bounds(\"=\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n-                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n-                    state.print_visibility(&item.vis)\n-                });\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Item(item))\n-    }\n-\n     fn print_trait_ref(&mut self, t: &ast::TraitRef) {\n         self.print_path(&t.path, false, 0)\n     }\n@@ -1411,167 +1066,6 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    crate fn print_enum_def(\n-        &mut self,\n-        enum_definition: &ast::EnumDef,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        visibility: &ast::Visibility,\n-    ) {\n-        self.head(visibility_qualified(visibility, \"enum\"));\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_where_clause(&generics.where_clause);\n-        self.space();\n-        self.print_variants(&enum_definition.variants, span)\n-    }\n-\n-    crate fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n-        self.bopen();\n-        for v in variants {\n-            self.space_if_not_bol();\n-            self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.attrs);\n-            self.ibox(INDENT_UNIT);\n-            self.print_variant(v);\n-            self.word(\",\");\n-            self.end();\n-            self.maybe_print_trailing_comment(v.span, None);\n-        }\n-        let empty = variants.is_empty();\n-        self.bclose(span, empty)\n-    }\n-\n-    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n-            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Crate(sugar) => match sugar {\n-                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n-                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n-            },\n-            ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if path == \"self\" || path == \"super\" {\n-                    self.word_nbsp(format!(\"pub({})\", path))\n-                } else {\n-                    self.word_nbsp(format!(\"pub(in {})\", path))\n-                }\n-            }\n-            ast::VisibilityKind::Inherited => {}\n-        }\n-    }\n-\n-    crate fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n-        if let ast::Defaultness::Default(_) = defaultness {\n-            self.word_nbsp(\"default\");\n-        }\n-    }\n-\n-    crate fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n-        self.nbsp();\n-        self.bopen();\n-\n-        let empty = fields.is_empty();\n-        if !empty {\n-            self.hardbreak_if_not_bol();\n-\n-            for field in fields {\n-                self.hardbreak_if_not_bol();\n-                self.maybe_print_comment(field.span.lo());\n-                self.print_outer_attributes(&field.attrs);\n-                self.print_visibility(&field.vis);\n-                self.print_ident(field.ident.unwrap());\n-                self.word_nbsp(\":\");\n-                self.print_type(&field.ty);\n-                self.word(\",\");\n-            }\n-        }\n-\n-        self.bclose(span, empty);\n-    }\n-\n-    crate fn print_struct(\n-        &mut self,\n-        struct_def: &ast::VariantData,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        print_finalizer: bool,\n-    ) {\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        match struct_def {\n-            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n-                if let ast::VariantData::Tuple(..) = struct_def {\n-                    self.popen();\n-                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                        s.maybe_print_comment(field.span.lo());\n-                        s.print_outer_attributes(&field.attrs);\n-                        s.print_visibility(&field.vis);\n-                        s.print_type(&field.ty)\n-                    });\n-                    self.pclose();\n-                }\n-                self.print_where_clause(&generics.where_clause);\n-                if print_finalizer {\n-                    self.word(\";\");\n-                }\n-                self.end();\n-                self.end(); // Close the outer-box.\n-            }\n-            ast::VariantData::Struct(ref fields, ..) => {\n-                self.print_where_clause(&generics.where_clause);\n-                self.print_record_struct_body(fields, span);\n-            }\n-        }\n-    }\n-\n-    crate fn print_variant(&mut self, v: &ast::Variant) {\n-        self.head(\"\");\n-        self.print_visibility(&v.vis);\n-        let generics = ast::Generics::default();\n-        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_expr(&d.value)\n-        }\n-    }\n-\n-    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::AssocItemKind::Const(def, ty, body) => {\n-                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n-            }\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::AssocItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n     crate fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n@@ -1682,42 +1176,6 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n-    fn print_else(&mut self, els: Option<&ast::Expr>) {\n-        if let Some(_else) = els {\n-            match _else.kind {\n-                // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else if \");\n-                    self.print_expr_as_cond(i);\n-                    self.space();\n-                    self.print_block(then);\n-                    self.print_else(e.as_deref())\n-                }\n-                // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else \");\n-                    self.print_block(b)\n-                }\n-                // Constraints would be great here!\n-                _ => {\n-                    panic!(\"print_if saw if with weird alternative\");\n-                }\n-            }\n-        }\n-    }\n-\n-    crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n-        self.head(\"if\");\n-        self.print_expr_as_cond(test);\n-        self.space();\n-        self.print_block(blk);\n-        self.print_else(elseopt)\n-    }\n-\n     crate fn print_mac(&mut self, m: &ast::MacCall) {\n         self.print_mac_common(\n             Some(MacHeader::Path(&m.path)),\n@@ -1730,477 +1188,6 @@ impl<'a> State<'a> {\n         );\n     }\n \n-    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, args);\n-        self.pclose()\n-    }\n-\n-    crate fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n-        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n-    }\n-\n-    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n-    /// `if cond { ... }`.\n-    crate fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n-        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n-    }\n-\n-    // Does `expr` need parentheses when printed in a condition position?\n-    //\n-    // These cases need parens due to the parse error observed in #26461: `if return {}`\n-    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-    fn cond_needs_par(expr: &ast::Expr) -> bool {\n-        match expr.kind {\n-            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n-            _ => parser::contains_exterior_struct_lit(expr),\n-        }\n-    }\n-\n-    /// Prints `expr` or `(expr)` when `needs_par` holds.\n-    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n-        if needs_par {\n-            self.popen();\n-        }\n-        self.print_expr(expr);\n-        if needs_par {\n-            self.pclose();\n-        }\n-    }\n-\n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.commasep_exprs(Inconsistent, exprs);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"const\");\n-        self.print_expr(&expr.value);\n-        self.end();\n-    }\n-\n-    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.print_expr(element);\n-        self.word_space(\";\");\n-        self.print_expr(&count.value);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_struct(\n-        &mut self,\n-        qself: &Option<ast::QSelf>,\n-        path: &ast::Path,\n-        fields: &[ast::ExprField],\n-        rest: &ast::StructRest,\n-    ) {\n-        if let Some(qself) = qself {\n-            self.print_qpath(path, qself, true);\n-        } else {\n-            self.print_path(path, true, 0);\n-        }\n-        self.word(\"{\");\n-        self.commasep_cmnt(\n-            Consistent,\n-            fields,\n-            |s, field| {\n-                s.print_outer_attributes(&field.attrs);\n-                s.ibox(INDENT_UNIT);\n-                if !field.is_shorthand {\n-                    s.print_ident(field.ident);\n-                    s.word_space(\":\");\n-                }\n-                s.print_expr(&field.expr);\n-                s.end();\n-            },\n-            |f| f.span,\n-        );\n-        match rest {\n-            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n-                self.ibox(INDENT_UNIT);\n-                if !fields.is_empty() {\n-                    self.word(\",\");\n-                    self.space();\n-                }\n-                self.word(\"..\");\n-                if let ast::StructRest::Base(ref expr) = *rest {\n-                    self.print_expr(expr);\n-                }\n-                self.end();\n-            }\n-            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n-            _ => {}\n-        }\n-        self.word(\"}\");\n-    }\n-\n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, exprs);\n-        if exprs.len() == 1 {\n-            self.word(\",\");\n-        }\n-        self.pclose()\n-    }\n-\n-    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n-        let prec = match func.kind {\n-            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n-            _ => parser::PREC_POSTFIX,\n-        };\n-\n-        self.print_expr_maybe_paren(func, prec);\n-        self.print_call_post(args)\n-    }\n-\n-    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.word(\".\");\n-        self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n-            self.print_generic_args(args, true);\n-        }\n-        self.print_call_post(base_args)\n-    }\n-\n-    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n-        let assoc_op = AssocOp::from_ast_binop(op.node);\n-        let prec = assoc_op.precedence() as i8;\n-        let fixity = assoc_op.fixity();\n-\n-        let (left_prec, right_prec) = match fixity {\n-            Fixity::Left => (prec, prec + 1),\n-            Fixity::Right => (prec + 1, prec),\n-            Fixity::None => (prec + 1, prec + 1),\n-        };\n-\n-        let left_prec = match (&lhs.kind, op.node) {\n-            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n-            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n-            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            // We are given `(let _ = a) OP b`.\n-            //\n-            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n-            //   as the parser will interpret this as `(let _ = a) OP b`.\n-            //\n-            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n-            //   parens are required since the parser would interpret `let a = b < c` as\n-            //   `let a = (b < c)`. To achieve this, we force parens.\n-            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            _ => left_prec,\n-        };\n-\n-        self.print_expr_maybe_paren(lhs, left_prec);\n-        self.space();\n-        self.word_space(op.node.to_string());\n-        self.print_expr_maybe_paren(rhs, right_prec)\n-    }\n-\n-    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n-        self.word(ast::UnOp::to_string(op));\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    fn print_expr_addr_of(\n-        &mut self,\n-        kind: ast::BorrowKind,\n-        mutability: ast::Mutability,\n-        expr: &ast::Expr,\n-    ) {\n-        self.word(\"&\");\n-        match kind {\n-            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n-            ast::BorrowKind::Raw => {\n-                self.word_nbsp(\"raw\");\n-                self.print_mutability(mutability, true);\n-            }\n-        }\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    pub fn print_expr(&mut self, expr: &ast::Expr) {\n-        self.print_expr_outer_attr_style(expr, true)\n-    }\n-\n-    fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n-        self.maybe_print_comment(expr.span.lo());\n-\n-        let attrs = &expr.attrs;\n-        if is_inline {\n-            self.print_outer_attributes_inline(attrs);\n-        } else {\n-            self.print_outer_attributes(attrs);\n-        }\n-\n-        self.ibox(INDENT_UNIT);\n-        self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n-            }\n-            ast::ExprKind::Array(ref exprs) => {\n-                self.print_expr_vec(exprs);\n-            }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n-                self.print_expr_anon_const(anon_const);\n-            }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(element, count);\n-            }\n-            ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n-            }\n-            ast::ExprKind::Tup(ref exprs) => {\n-                self.print_expr_tup(exprs);\n-            }\n-            ast::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(func, &args);\n-            }\n-            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n-                self.print_expr_method_call(segment, &args);\n-            }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n-            }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n-            }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n-            }\n-            ast::ExprKind::Lit(ref lit) => {\n-                self.print_literal(lit);\n-            }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n-                let prec = AssocOp::As.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.space();\n-                self.word_space(\"as\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                self.print_let(pat, scrutinee);\n-            }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"while\");\n-                self.print_expr_as_cond(test);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"for\");\n-                self.print_pat(pat);\n-                self.space();\n-                self.word_space(\"in\");\n-                self.print_expr_as_cond(iter);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Loop(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"loop\");\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(INDENT_UNIT);\n-                self.word_nbsp(\"match\");\n-                self.print_expr_as_cond(expr);\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n-                for arm in arms {\n-                    self.print_arm(arm);\n-                }\n-                let empty = attrs.is_empty() && arms.is_empty();\n-                self.bclose(expr.span, empty);\n-            }\n-            ast::ExprKind::Closure(\n-                capture_clause,\n-                asyncness,\n-                movability,\n-                ref decl,\n-                ref body,\n-                _,\n-            ) => {\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n-\n-                self.print_fn_params_and_ret(decl, true);\n-                self.space();\n-                self.print_expr(body);\n-                self.end(); // need to close a box\n-\n-                // a box will be closed by print_expr, but we didn't want an overall\n-                // wrapper so we closed the corresponding opening. so create an\n-                // empty box to satisfy the close.\n-                self.ibox(0);\n-            }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                // containing cbox, will be closed by print-block at }\n-                self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n-                self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n-                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Await(ref expr) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".await\");\n-            }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word(op.node.to_string());\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::Field(ref expr, ident) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".\");\n-                self.print_ident(ident);\n-            }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\"[\");\n-                self.print_expr(index);\n-                self.word(\"]\");\n-            }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n-                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n-                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n-                // Here we use a fake precedence value so that any child with lower precedence than\n-                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n-                let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n-                }\n-                if let Some(ref e) = *end {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-            }\n-            ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n-                self.word(\"break\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-                if let Some(ref expr) = *opt_expr {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Continue(opt_label) => {\n-                self.word(\"continue\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-            }\n-            ast::ExprKind::Ret(ref result) => {\n-                self.word(\"return\");\n-                if let Some(ref expr) = *result {\n-                    self.word(\" \");\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::InlineAsm(ref a) => {\n-                self.word(\"asm!\");\n-                self.print_inline_asm(a);\n-            }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n-                self.popen();\n-                self.print_expr(e);\n-                self.pclose();\n-            }\n-            ast::ExprKind::Yield(ref e) => {\n-                self.word(\"yield\");\n-\n-                if let Some(ref expr) = *e {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Try(ref e) => {\n-                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n-                self.word(\"?\")\n-            }\n-            ast::ExprKind::TryBlock(ref blk) => {\n-                self.head(\"try\");\n-                self.print_block_with_attrs(blk, attrs)\n-            }\n-            ast::ExprKind::Err => {\n-                self.popen();\n-                self.word(\"/*ERROR*/\");\n-                self.pclose()\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Expr(expr));\n-        self.end();\n-    }\n-\n     fn print_inline_asm(&mut self, asm: &ast::InlineAsm) {\n         enum AsmArg<'a> {\n             Template(String),\n@@ -2496,48 +1483,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_arm(&mut self, arm: &ast::Arm) {\n-        // Note, I have no idea why this check is necessary, but here it is.\n-        if arm.attrs.is_empty() {\n-            self.space();\n-        }\n-        self.cbox(INDENT_UNIT);\n-        self.ibox(0);\n-        self.maybe_print_comment(arm.pat.span.lo());\n-        self.print_outer_attributes(&arm.attrs);\n-        self.print_pat(&arm.pat);\n-        self.space();\n-        if let Some(ref e) = arm.guard {\n-            self.word_space(\"if\");\n-            self.print_expr(e);\n-            self.space();\n-        }\n-        self.word_space(\"=>\");\n-\n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-\n-                // The block will close the pattern's ibox.\n-                self.print_block_unclosed_indent(blk);\n-\n-                // If it is a user-provided unsafe block, print a comma after it.\n-                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    self.word(\",\");\n-                }\n-            }\n-            _ => {\n-                self.end(); // Close the ibox for the pattern.\n-                self.print_expr(&arm.body);\n-                self.word(\",\");\n-            }\n-        }\n-        self.end(); // Close enclosing cbox.\n-    }\n-\n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n@@ -2559,75 +1504,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_fn_full(\n-        &mut self,\n-        sig: &ast::FnSig,\n-        name: Ident,\n-        generics: &ast::Generics,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-        body: Option<&ast::Block>,\n-        attrs: &[ast::Attribute],\n-    ) {\n-        if body.is_some() {\n-            self.head(\"\");\n-        }\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n-        if let Some(body) = body {\n-            self.nbsp();\n-            self.print_block_with_attrs(body, attrs);\n-        } else {\n-            self.word(\";\");\n-        }\n-    }\n-\n-    crate fn print_fn(\n-        &mut self,\n-        decl: &ast::FnDecl,\n-        header: ast::FnHeader,\n-        name: Option<Ident>,\n-        generics: &ast::Generics,\n-    ) {\n-        self.print_fn_header_info(header);\n-        if let Some(name) = name {\n-            self.nbsp();\n-            self.print_ident(name);\n-        }\n-        self.print_generic_params(&generics.params);\n-        self.print_fn_params_and_ret(decl, false);\n-        self.print_where_clause(&generics.where_clause)\n-    }\n-\n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n-        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n-        self.word(open);\n-        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n-        self.word(close);\n-        self.print_fn_ret_ty(&decl.output)\n-    }\n-\n-    crate fn print_movability(&mut self, movability: ast::Movability) {\n-        match movability {\n-            ast::Movability::Static => self.word_space(\"static\"),\n-            ast::Movability::Movable => {}\n-        }\n-    }\n-\n     crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n         }\n     }\n \n-    crate fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n-        match capture_clause {\n-            ast::CaptureBy::Value => self.word_space(\"move\"),\n-            ast::CaptureBy::Ref => {}\n-        }\n-    }\n-\n     pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound]) {\n         if !bounds.is_empty() {\n             self.word(prefix);\n@@ -2722,83 +1604,6 @@ impl<'a> State<'a> {\n         self.word(\">\");\n     }\n \n-    crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n-            return;\n-        }\n-\n-        self.space();\n-        self.word_space(\"where\");\n-\n-        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n-            if i != 0 {\n-                self.word_space(\",\");\n-            }\n-\n-            self.print_where_predicate(predicate);\n-        }\n-    }\n-\n-    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n-        match predicate {\n-            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                bound_generic_params,\n-                bounded_ty,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_formal_generic_params(bound_generic_params);\n-                self.print_type(bounded_ty);\n-                self.print_type_bounds(\":\", bounds);\n-            }\n-            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                lifetime,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_lifetime_bounds(*lifetime, bounds);\n-            }\n-            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n-                self.print_type(lhs_ty);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_type(rhs_ty);\n-            }\n-        }\n-    }\n-\n-    crate fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n-            ast::UseTreeKind::Simple(rename, ..) => {\n-                self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n-                    self.space();\n-                    self.word_space(\"as\");\n-                    self.print_ident(rename);\n-                }\n-            }\n-            ast::UseTreeKind::Glob => {\n-                if !tree.prefix.segments.is_empty() {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::\");\n-                }\n-                self.word(\"*\");\n-            }\n-            ast::UseTreeKind::Nested(ref items) => {\n-                if tree.prefix.segments.is_empty() {\n-                    self.word(\"{\");\n-                } else {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::{\");\n-                }\n-                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n-                    this.print_use_tree(tree)\n-                });\n-                self.word(\"}\");\n-            }\n-        }\n-    }\n-\n     pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n             ast::Mutability::Mut => self.word_nbsp(\"mut\"),"}, {"sha": "956200d60f5078940b1c7bc2188793ba61580397", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,571 @@\n+use crate::pp::Breaks::{Consistent, Inconsistent};\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::{self as ast, BlockCheckMode};\n+\n+impl<'a> State<'a> {\n+    fn print_else(&mut self, els: Option<&ast::Expr>) {\n+        if let Some(_else) = els {\n+            match _else.kind {\n+                // Another `else if` block.\n+                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else if \");\n+                    self.print_expr_as_cond(i);\n+                    self.space();\n+                    self.print_block(then);\n+                    self.print_else(e.as_deref())\n+                }\n+                // Final `else` block.\n+                ast::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else \");\n+                    self.print_block(b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n+        self.head(\"if\");\n+        self.print_expr_as_cond(test);\n+        self.space();\n+        self.print_block(blk);\n+        self.print_else(elseopt)\n+    }\n+\n+    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, args);\n+        self.pclose()\n+    }\n+\n+    fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n+    }\n+\n+    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n+\n+    // Does `expr` need parentheses when printed in a condition position?\n+    //\n+    // These cases need parens due to the parse error observed in #26461: `if return {}`\n+    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    pub(super) fn cond_needs_par(expr: &ast::Expr) -> bool {\n+        match expr.kind {\n+            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n+            _ => parser::contains_exterior_struct_lit(expr),\n+        }\n+    }\n+\n+    /// Prints `expr` or `(expr)` when `needs_par` holds.\n+    pub(super) fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n+        if needs_par {\n+            self.popen();\n+        }\n+        self.print_expr(expr);\n+        if needs_par {\n+            self.pclose();\n+        }\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.commasep_exprs(Inconsistent, exprs);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    pub(super) fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"const\");\n+        self.print_expr(&expr.value);\n+        self.end();\n+    }\n+\n+    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.print_expr(element);\n+        self.word_space(\";\");\n+        self.print_expr(&count.value);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    fn print_expr_struct(\n+        &mut self,\n+        qself: &Option<ast::QSelf>,\n+        path: &ast::Path,\n+        fields: &[ast::ExprField],\n+        rest: &ast::StructRest,\n+    ) {\n+        if let Some(qself) = qself {\n+            self.print_qpath(path, qself, true);\n+        } else {\n+            self.print_path(path, true, 0);\n+        }\n+        self.word(\"{\");\n+        self.commasep_cmnt(\n+            Consistent,\n+            fields,\n+            |s, field| {\n+                s.print_outer_attributes(&field.attrs);\n+                s.ibox(INDENT_UNIT);\n+                if !field.is_shorthand {\n+                    s.print_ident(field.ident);\n+                    s.word_space(\":\");\n+                }\n+                s.print_expr(&field.expr);\n+                s.end();\n+            },\n+            |f| f.span,\n+        );\n+        match rest {\n+            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n+                self.ibox(INDENT_UNIT);\n+                if !fields.is_empty() {\n+                    self.word(\",\");\n+                    self.space();\n+                }\n+                self.word(\"..\");\n+                if let ast::StructRest::Base(ref expr) = *rest {\n+                    self.print_expr(expr);\n+                }\n+                self.end();\n+            }\n+            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n+            _ => {}\n+        }\n+        self.word(\"}\");\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, exprs);\n+        if exprs.len() == 1 {\n+            self.word(\",\");\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n+        let prec = match func.kind {\n+            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n+            _ => parser::PREC_POSTFIX,\n+        };\n+\n+        self.print_expr_maybe_paren(func, prec);\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n+        let base_args = &args[1..];\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+        self.word(\".\");\n+        self.print_ident(segment.ident);\n+        if let Some(ref args) = segment.args {\n+            self.print_generic_args(args, true);\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n+        let assoc_op = AssocOp::from_ast_binop(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        let left_prec = match (&lhs.kind, op.node) {\n+            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n+            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n+            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n+            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            // We are given `(let _ = a) OP b`.\n+            //\n+            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n+            //   as the parser will interpret this as `(let _ = a) OP b`.\n+            //\n+            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n+            //   parens are required since the parser would interpret `let a = b < c` as\n+            //   `let a = (b < c)`. To achieve this, we force parens.\n+            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            _ => left_prec,\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec);\n+        self.space();\n+        self.word_space(op.node.to_string());\n+        self.print_expr_maybe_paren(rhs, right_prec)\n+    }\n+\n+    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n+        self.word(ast::UnOp::to_string(op));\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    fn print_expr_addr_of(\n+        &mut self,\n+        kind: ast::BorrowKind,\n+        mutability: ast::Mutability,\n+        expr: &ast::Expr,\n+    ) {\n+        self.word(\"&\");\n+        match kind {\n+            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            ast::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    pub fn print_expr(&mut self, expr: &ast::Expr) {\n+        self.print_expr_outer_attr_style(expr, true)\n+    }\n+\n+    pub(super) fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n+        self.maybe_print_comment(expr.span.lo());\n+\n+        let attrs = &expr.attrs;\n+        if is_inline {\n+            self.print_outer_attributes_inline(attrs);\n+        } else {\n+            self.print_outer_attributes(attrs);\n+        }\n+\n+        self.ibox(INDENT_UNIT);\n+        self.ann.pre(self, AnnNode::Expr(expr));\n+        match expr.kind {\n+            ast::ExprKind::Box(ref expr) => {\n+                self.word_space(\"box\");\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n+            }\n+            ast::ExprKind::Array(ref exprs) => {\n+                self.print_expr_vec(exprs);\n+            }\n+            ast::ExprKind::ConstBlock(ref anon_const) => {\n+                self.print_expr_anon_const(anon_const);\n+            }\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n+                self.print_expr_repeat(element, count);\n+            }\n+            ast::ExprKind::Struct(ref se) => {\n+                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n+            }\n+            ast::ExprKind::Tup(ref exprs) => {\n+                self.print_expr_tup(exprs);\n+            }\n+            ast::ExprKind::Call(ref func, ref args) => {\n+                self.print_expr_call(func, &args);\n+            }\n+            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n+                self.print_expr_method_call(segment, &args);\n+            }\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                self.print_expr_binary(op, lhs, rhs);\n+            }\n+            ast::ExprKind::Unary(op, ref expr) => {\n+                self.print_expr_unary(op, expr);\n+            }\n+            ast::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n+            }\n+            ast::ExprKind::Lit(ref lit) => {\n+                self.print_literal(lit);\n+            }\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.space();\n+                self.word_space(\"as\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Type(ref expr, ref ty) => {\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.word_space(\":\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+                self.print_let(pat, scrutinee);\n+            }\n+            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n+                self.print_if(test, blk, elseopt.as_deref())\n+            }\n+            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"while\");\n+                self.print_expr_as_cond(test);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"for\");\n+                self.print_pat(pat);\n+                self.space();\n+                self.word_space(\"in\");\n+                self.print_expr_as_cond(iter);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Loop(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"loop\");\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Match(ref expr, ref arms) => {\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(INDENT_UNIT);\n+                self.word_nbsp(\"match\");\n+                self.print_expr_as_cond(expr);\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n+                for arm in arms {\n+                    self.print_arm(arm);\n+                }\n+                let empty = attrs.is_empty() && arms.is_empty();\n+                self.bclose(expr.span, empty);\n+            }\n+            ast::ExprKind::Closure(\n+                capture_clause,\n+                asyncness,\n+                movability,\n+                ref decl,\n+                ref body,\n+                _,\n+            ) => {\n+                self.print_movability(movability);\n+                self.print_asyncness(asyncness);\n+                self.print_capture_clause(capture_clause);\n+\n+                self.print_fn_params_and_ret(decl, true);\n+                self.space();\n+                self.print_expr(body);\n+                self.end(); // need to close a box\n+\n+                // a box will be closed by print_expr, but we didn't want an overall\n+                // wrapper so we closed the corresponding opening. so create an\n+                // empty box to satisfy the close.\n+                self.ibox(0);\n+            }\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                // containing cbox, will be closed by print-block at }\n+                self.cbox(INDENT_UNIT);\n+                // head-box, will be closed by print-block after {\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+                self.word_nbsp(\"async\");\n+                self.print_capture_clause(capture_clause);\n+                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Await(ref expr) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".await\");\n+            }\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word(op.node.to_string());\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::Field(ref expr, ident) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".\");\n+                self.print_ident(ident);\n+            }\n+            ast::ExprKind::Index(ref expr, ref index) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\"[\");\n+                self.print_expr(index);\n+                self.word(\"]\");\n+            }\n+            ast::ExprKind::Range(ref start, ref end, limits) => {\n+                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n+                // Here we use a fake precedence value so that any child with lower precedence than\n+                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                let fake_prec = AssocOp::LOr.precedence() as i8;\n+                if let Some(ref e) = *start {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+                if limits == ast::RangeLimits::HalfOpen {\n+                    self.word(\"..\");\n+                } else {\n+                    self.word(\"..=\");\n+                }\n+                if let Some(ref e) = *end {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+            }\n+            ast::ExprKind::Underscore => self.word(\"_\"),\n+            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+                self.word(\"break\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+                if let Some(ref expr) = *opt_expr {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Continue(opt_label) => {\n+                self.word(\"continue\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+            }\n+            ast::ExprKind::Ret(ref result) => {\n+                self.word(\"return\");\n+                if let Some(ref expr) = *result {\n+                    self.word(\" \");\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::InlineAsm(ref a) => {\n+                self.word(\"asm!\");\n+                self.print_inline_asm(a);\n+            }\n+            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n+            ast::ExprKind::Paren(ref e) => {\n+                self.popen();\n+                self.print_expr(e);\n+                self.pclose();\n+            }\n+            ast::ExprKind::Yield(ref e) => {\n+                self.word(\"yield\");\n+\n+                if let Some(ref expr) = *e {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Try(ref e) => {\n+                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n+                self.word(\"?\")\n+            }\n+            ast::ExprKind::TryBlock(ref blk) => {\n+                self.head(\"try\");\n+                self.print_block_with_attrs(blk, attrs)\n+            }\n+            ast::ExprKind::Err => {\n+                self.popen();\n+                self.word(\"/*ERROR*/\");\n+                self.pclose()\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Expr(expr));\n+        self.end();\n+    }\n+\n+    fn print_arm(&mut self, arm: &ast::Arm) {\n+        // Note, I have no idea why this check is necessary, but here it is.\n+        if arm.attrs.is_empty() {\n+            self.space();\n+        }\n+        self.cbox(INDENT_UNIT);\n+        self.ibox(0);\n+        self.maybe_print_comment(arm.pat.span.lo());\n+        self.print_outer_attributes(&arm.attrs);\n+        self.print_pat(&arm.pat);\n+        self.space();\n+        if let Some(ref e) = arm.guard {\n+            self.word_space(\"if\");\n+            self.print_expr(e);\n+            self.space();\n+        }\n+        self.word_space(\"=>\");\n+\n+        match arm.body.kind {\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+\n+                // The block will close the pattern's ibox.\n+                self.print_block_unclosed_indent(blk);\n+\n+                // If it is a user-provided unsafe block, print a comma after it.\n+                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n+                    self.word(\",\");\n+                }\n+            }\n+            _ => {\n+                self.end(); // Close the ibox for the pattern.\n+                self.print_expr(&arm.body);\n+                self.word(\",\");\n+            }\n+        }\n+        self.end(); // Close enclosing cbox.\n+    }\n+\n+    fn print_movability(&mut self, movability: ast::Movability) {\n+        match movability {\n+            ast::Movability::Static => self.word_space(\"static\"),\n+            ast::Movability::Movable => {}\n+        }\n+    }\n+\n+    fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n+        match capture_clause {\n+            ast::CaptureBy::Value => self.word_space(\"move\"),\n+            ast::CaptureBy::Ref => {}\n+        }\n+    }\n+}"}, {"sha": "c756b946b1e4ae9acf7f311d8319c20bbf1355e6", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,644 @@\n+use crate::pp::Breaks::Inconsistent;\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast as ast;\n+use rustc_ast::GenericBound;\n+use rustc_ast::ModKind;\n+use rustc_span::symbol::Ident;\n+\n+fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n+    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n+}\n+\n+impl<'a> State<'a> {\n+    fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n+        self.print_inner_attributes(attrs);\n+        for item in &nmod.items {\n+            self.print_foreign_item(item);\n+        }\n+    }\n+\n+    fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n+            }\n+            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                generics,\n+                bounds,\n+                ty,\n+            }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::ForeignItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_item_const(\n+        &mut self,\n+        ident: Ident,\n+        mutbl: Option<ast::Mutability>,\n+        ty: &ast::Ty,\n+        body: Option<&ast::Expr>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        let leading = match mutbl {\n+            None => \"const\",\n+            Some(ast::Mutability::Not) => \"static\",\n+            Some(ast::Mutability::Mut) => \"static mut\",\n+        };\n+        self.word_space(leading);\n+        self.print_ident(ident);\n+        self.word_space(\":\");\n+        self.print_type(ty);\n+        if body.is_some() {\n+            self.space();\n+        }\n+        self.end(); // end the head-ibox\n+        if let Some(body) = body {\n+            self.word_space(\"=\");\n+            self.print_expr(body);\n+        }\n+        self.word(\";\");\n+        self.end(); // end the outer cbox\n+    }\n+\n+    fn print_associated_type(\n+        &mut self,\n+        ident: Ident,\n+        generics: &ast::Generics,\n+        bounds: &ast::GenericBounds,\n+        ty: Option<&ast::Ty>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.word_space(\"type\");\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_type_bounds(\":\", bounds);\n+        self.print_where_clause(&generics.where_clause);\n+        if let Some(ty) = ty {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_type(ty);\n+        }\n+        self.word(\";\");\n+        self.end(); // end inner head-block\n+        self.end(); // end outer head-block\n+    }\n+\n+    /// Pretty-prints an item.\n+    crate fn print_item(&mut self, item: &ast::Item) {\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(item.span.lo());\n+        self.print_outer_attributes(&item.attrs);\n+        self.ann.pre(self, AnnNode::Item(item));\n+        match item.kind {\n+            ast::ItemKind::ExternCrate(orig_name) => {\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name);\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n+                }\n+                self.print_ident(item.ident);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Use(ref tree) => {\n+                self.head(visibility_qualified(&item.vis, \"use\"));\n+                self.print_use_tree(tree);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Const(def, ref ty, ref body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n+                let body = body.as_deref();\n+                self.print_fn_full(\n+                    sig,\n+                    item.ident,\n+                    generics,\n+                    &item.vis,\n+                    defaultness,\n+                    body,\n+                    &item.attrs,\n+                );\n+            }\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_visibility(&item.vis);\n+                    s.print_unsafety(unsafety);\n+                    s.word(\"mod\");\n+                }));\n+                self.print_ident(item.ident);\n+\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        let empty = item.attrs.is_empty() && items.is_empty();\n+                        self.bclose(item.span, empty);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n+                }\n+            }\n+            ast::ItemKind::ForeignMod(ref nmod) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_unsafety(nmod.unsafety);\n+                    s.word(\"extern\");\n+                }));\n+                if let Some(abi) = nmod.abi {\n+                    self.print_literal(&abi.as_lit());\n+                    self.nbsp();\n+                }\n+                self.bopen();\n+                self.print_foreign_mod(nmod, &item.attrs);\n+                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::GlobalAsm(ref asm) => {\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.print_inline_asm(asm);\n+                self.end();\n+            }\n+            ast::ItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                ref generics,\n+                ref bounds,\n+                ref ty,\n+            }) => {\n+                let ty = ty.as_deref();\n+                self.print_associated_type(\n+                    item.ident,\n+                    generics,\n+                    bounds,\n+                    ty,\n+                    &item.vis,\n+                    defaultness,\n+                );\n+            }\n+            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n+            }\n+            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"struct\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"union\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Impl(box ast::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                constness,\n+                ref generics,\n+                ref of_trait,\n+                ref self_ty,\n+                ref items,\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_defaultness(defaultness);\n+                self.print_unsafety(unsafety);\n+                self.word(\"impl\");\n+\n+                if generics.params.is_empty() {\n+                    self.nbsp();\n+                } else {\n+                    self.print_generic_params(&generics.params);\n+                    self.space();\n+                }\n+\n+                self.print_constness(constness);\n+\n+                if let ast::ImplPolarity::Negative(_) = polarity {\n+                    self.word(\"!\");\n+                }\n+\n+                if let Some(ref t) = *of_trait {\n+                    self.print_trait_ref(t);\n+                    self.space();\n+                    self.word_space(\"for\");\n+                }\n+\n+                self.print_type(self_ty);\n+                self.print_where_clause(&generics.where_clause);\n+\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for impl_item in items {\n+                    self.print_assoc_item(impl_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::Trait(box ast::Trait {\n+                is_auto,\n+                unsafety,\n+                ref generics,\n+                ref bounds,\n+                ref items,\n+                ..\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_unsafety(unsafety);\n+                self.print_is_auto(is_auto);\n+                self.word_nbsp(\"trait\");\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.print_type_bounds(\":\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\" \");\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for trait_item in items {\n+                    self.print_assoc_item(trait_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                self.head(visibility_qualified(&item.vis, \"trait\"));\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                // FIXME(durka) this seems to be some quite outdated syntax\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.nbsp();\n+                self.print_type_bounds(\"=\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::MacCall(ref mac) => {\n+                self.print_mac(mac);\n+                if mac.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+            ast::ItemKind::MacroDef(ref macro_def) => {\n+                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                    state.print_visibility(&item.vis)\n+                });\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Item(item))\n+    }\n+\n+    fn print_enum_def(\n+        &mut self,\n+        enum_definition: &ast::EnumDef,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        visibility: &ast::Visibility,\n+    ) {\n+        self.head(visibility_qualified(visibility, \"enum\"));\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_where_clause(&generics.where_clause);\n+        self.space();\n+        self.print_variants(&enum_definition.variants, span)\n+    }\n+\n+    fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n+        self.bopen();\n+        for v in variants {\n+            self.space_if_not_bol();\n+            self.maybe_print_comment(v.span.lo());\n+            self.print_outer_attributes(&v.attrs);\n+            self.ibox(INDENT_UNIT);\n+            self.print_variant(v);\n+            self.word(\",\");\n+            self.end();\n+            self.maybe_print_trailing_comment(v.span, None);\n+        }\n+        let empty = variants.is_empty();\n+        self.bclose(span, empty)\n+    }\n+\n+    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n+        match vis.kind {\n+            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n+            ast::VisibilityKind::Crate(sugar) => match sugar {\n+                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n+                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n+            },\n+            ast::VisibilityKind::Restricted { ref path, .. } => {\n+                let path = Self::to_string(|s| s.print_path(path, false, 0));\n+                if path == \"self\" || path == \"super\" {\n+                    self.word_nbsp(format!(\"pub({})\", path))\n+                } else {\n+                    self.word_nbsp(format!(\"pub(in {})\", path))\n+                }\n+            }\n+            ast::VisibilityKind::Inherited => {}\n+        }\n+    }\n+\n+    fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n+        if let ast::Defaultness::Default(_) = defaultness {\n+            self.word_nbsp(\"default\");\n+        }\n+    }\n+\n+    fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n+        self.nbsp();\n+        self.bopen();\n+\n+        let empty = fields.is_empty();\n+        if !empty {\n+            self.hardbreak_if_not_bol();\n+\n+            for field in fields {\n+                self.hardbreak_if_not_bol();\n+                self.maybe_print_comment(field.span.lo());\n+                self.print_outer_attributes(&field.attrs);\n+                self.print_visibility(&field.vis);\n+                self.print_ident(field.ident.unwrap());\n+                self.word_nbsp(\":\");\n+                self.print_type(&field.ty);\n+                self.word(\",\");\n+            }\n+        }\n+\n+        self.bclose(span, empty);\n+    }\n+\n+    fn print_struct(\n+        &mut self,\n+        struct_def: &ast::VariantData,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        print_finalizer: bool,\n+    ) {\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        match struct_def {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+                if let ast::VariantData::Tuple(..) = struct_def {\n+                    self.popen();\n+                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                        s.maybe_print_comment(field.span.lo());\n+                        s.print_outer_attributes(&field.attrs);\n+                        s.print_visibility(&field.vis);\n+                        s.print_type(&field.ty)\n+                    });\n+                    self.pclose();\n+                }\n+                self.print_where_clause(&generics.where_clause);\n+                if print_finalizer {\n+                    self.word(\";\");\n+                }\n+                self.end();\n+                self.end(); // Close the outer-box.\n+            }\n+            ast::VariantData::Struct(ref fields, ..) => {\n+                self.print_where_clause(&generics.where_clause);\n+                self.print_record_struct_body(fields, span);\n+            }\n+        }\n+    }\n+\n+    crate fn print_variant(&mut self, v: &ast::Variant) {\n+        self.head(\"\");\n+        self.print_visibility(&v.vis);\n+        let generics = ast::Generics::default();\n+        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_expr(&d.value)\n+        }\n+    }\n+\n+    fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::AssocItemKind::Const(def, ty, body) => {\n+                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n+            }\n+            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::AssocItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_fn_full(\n+        &mut self,\n+        sig: &ast::FnSig,\n+        name: Ident,\n+        generics: &ast::Generics,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+        body: Option<&ast::Block>,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        if body.is_some() {\n+            self.head(\"\");\n+        }\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n+        if let Some(body) = body {\n+            self.nbsp();\n+            self.print_block_with_attrs(body, attrs);\n+        } else {\n+            self.word(\";\");\n+        }\n+    }\n+\n+    crate fn print_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        header: ast::FnHeader,\n+        name: Option<Ident>,\n+        generics: &ast::Generics,\n+    ) {\n+        self.print_fn_header_info(header);\n+        if let Some(name) = name {\n+            self.nbsp();\n+            self.print_ident(name);\n+        }\n+        self.print_generic_params(&generics.params);\n+        self.print_fn_params_and_ret(decl, false);\n+        self.print_where_clause(&generics.where_clause)\n+    }\n+\n+    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n+        self.word(open);\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n+        self.word(close);\n+        self.print_fn_ret_ty(&decl.output)\n+    }\n+\n+    fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n+        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n+            return;\n+        }\n+\n+        self.space();\n+        self.word_space(\"where\");\n+\n+        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n+            if i != 0 {\n+                self.word_space(\",\");\n+            }\n+\n+            self.print_where_predicate(predicate);\n+        }\n+    }\n+\n+    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n+        match predicate {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_formal_generic_params(bound_generic_params);\n+                self.print_type(bounded_ty);\n+                self.print_type_bounds(\":\", bounds);\n+            }\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                lifetime,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_lifetime_bounds(*lifetime, bounds);\n+            }\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n+                self.print_type(lhs_ty);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_type(rhs_ty);\n+            }\n+        }\n+    }\n+\n+    fn print_use_tree(&mut self, tree: &ast::UseTree) {\n+        match tree.kind {\n+            ast::UseTreeKind::Simple(rename, ..) => {\n+                self.print_path(&tree.prefix, false, 0);\n+                if let Some(rename) = rename {\n+                    self.space();\n+                    self.word_space(\"as\");\n+                    self.print_ident(rename);\n+                }\n+            }\n+            ast::UseTreeKind::Glob => {\n+                if !tree.prefix.segments.is_empty() {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::\");\n+                }\n+                self.word(\"*\");\n+            }\n+            ast::UseTreeKind::Nested(ref items) => {\n+                if tree.prefix.segments.is_empty() {\n+                    self.word(\"{\");\n+                } else {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::{\");\n+                }\n+                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n+                    this.print_use_tree(tree)\n+                });\n+                self.word(\"}\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "c21d19a62279ff4aa35435c1ac392d63378b905c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -429,87 +429,78 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match place_ref {\n-            mir::PlaceRef { local, projection: [] } => match self.locals[local] {\n-                LocalRef::Place(place) => {\n-                    return place;\n-                }\n-                LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(cx);\n-                }\n-                LocalRef::Operand(..) => {\n+        let mut base = 0;\n+        let mut cg_base = match self.locals[place_ref.local] {\n+            LocalRef::Place(place) => place,\n+            LocalRef::UnsizedPlace(place) => bx.load_operand(place).deref(cx),\n+            LocalRef::Operand(..) => {\n+                if let Some(elem) = place_ref\n+                    .projection\n+                    .iter()\n+                    .enumerate()\n+                    .find(|elem| matches!(elem.1, mir::ProjectionElem::Deref))\n+                {\n+                    base = elem.0 + 1;\n+                    self.codegen_consume(\n+                        bx,\n+                        mir::PlaceRef { projection: &place_ref.projection[..elem.0], ..place_ref },\n+                    )\n+                    .deref(bx.cx())\n+                } else {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n-            },\n-            mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n-                // Load the pointer from its location.\n-                self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n-                    .deref(bx.cx())\n             }\n-            mir::PlaceRef { local, projection: &[ref proj_base @ .., elem] } => {\n-                // FIXME turn this recursion into iteration\n-                let cg_base =\n-                    self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n-\n-                match elem {\n-                    mir::ProjectionElem::Deref => bug!(),\n-                    mir::ProjectionElem::Field(ref field, _) => {\n-                        cg_base.project_field(bx, field.index())\n-                    }\n-                    mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::from(index));\n-                        let index = self.codegen_operand(bx, index);\n-                        let llindex = index.immediate();\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: false,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        cg_base.project_index(bx, lloffset)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: true,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        let lllen = cg_base.len(bx.cx());\n-                        let llindex = bx.sub(lllen, lloffset);\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::Subslice { from, to, from_end } => {\n-                        let mut subslice =\n-                            cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n-                        let projected_ty =\n-                            PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n-                        subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n-\n-                        if subslice.layout.is_unsized() {\n-                            assert!(from_end, \"slice subslices should be `from_end`\");\n-                            subslice.llextra = Some(bx.sub(\n-                                cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64)),\n-                            ));\n-                        }\n-\n-                        // Cast the place pointer type to the new\n-                        // array or slice type (`*[%_; new_len]`).\n-                        subslice.llval = bx.pointercast(\n-                            subslice.llval,\n-                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n-                        );\n-\n-                        subslice\n+        };\n+        for elem in place_ref.projection[base..].iter() {\n+            cg_base = match elem.clone() {\n+                mir::ProjectionElem::Deref => bx.load_operand(cg_base).deref(bx.cx()),\n+                mir::ProjectionElem::Field(ref field, _) => {\n+                    cg_base.project_field(bx, field.index())\n+                }\n+                mir::ProjectionElem::Index(index) => {\n+                    let index = &mir::Operand::Copy(mir::Place::from(index));\n+                    let index = self.codegen_operand(bx, index);\n+                    let llindex = index.immediate();\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: false, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    cg_base.project_index(bx, lloffset)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: true, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    let lllen = cg_base.len(bx.cx());\n+                    let llindex = bx.sub(lllen, lloffset);\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::Subslice { from, to, from_end } => {\n+                    let mut subslice = cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n+                    let projected_ty =\n+                        PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem.clone()).ty;\n+                    subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n+\n+                    if subslice.layout.is_unsized() {\n+                        assert!(from_end, \"slice subslices should be `from_end`\");\n+                        subslice.llextra = Some(bx.sub(\n+                            cg_base.llextra.unwrap(),\n+                            bx.cx().const_usize((from as u64) + (to as u64)),\n+                        ));\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+\n+                    // Cast the place pointer type to the new\n+                    // array or slice type (`*[%_; new_len]`).\n+                    subslice.llval = bx.pointercast(\n+                        subslice.llval,\n+                        bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n+                    );\n+\n+                    subslice\n                 }\n-            }\n-        };\n-        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, result);\n-        result\n+                mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+            };\n+        }\n+        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, cg_base);\n+        cg_base\n     }\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {"}, {"sha": "0b65a5ff3ecc3b28df5607f105d7248e733ed1d6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -415,7 +415,7 @@ declare_features! (\n     // Allows setting the threshold for the `large_assignments` lint.\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `if/while p && let q = r && ...` chains.\n-    (incomplete, let_chains, \"1.37.0\", Some(53667), None),\n+    (active, let_chains, \"1.37.0\", Some(53667), None),\n     /// Allows `let...else` statements.\n     (active, let_else, \"1.56.0\", Some(87335), None),\n     /// Allows `#[link(..., cfg(..))]`."}, {"sha": "48f39b26152cbbc40103eadfbe4daa74216d739f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -162,7 +162,7 @@ impl MirPhase {\n }\n \n /// Where a specific `mir::Body` comes from.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n pub struct MirSource<'tcx> {\n     pub instance: InstanceDef<'tcx>,\n@@ -1255,17 +1255,7 @@ pub enum AssertKind<O> {\n     ResumedAfterPanic(GeneratorKind),\n }\n \n-#[derive(\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    PartialOrd,\n-    TyEncodable,\n-    TyDecodable,\n-    Hash,\n-    HashStable,\n-    TypeFoldable\n-)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum InlineAsmOperand<'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -1747,7 +1737,7 @@ pub struct CopyNonOverlapping<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n \n@@ -2072,7 +2062,7 @@ pub struct SourceScopeLocalData {\n \n /// These are values that can appear inside an rvalue. They are intentionally\n /// limited to prevent rvalues from being nested in one another.\n-#[derive(Clone, PartialEq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n@@ -2500,7 +2490,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are `==` in Rust. In\n /// particular, one must be wary of `NaN`!\n \n-#[derive(Clone, Copy, PartialEq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2514,7 +2504,7 @@ pub struct Constant<'tcx> {\n     pub literal: ConstantKind<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, TyEncodable, TyDecodable, Hash, HashStable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable, Debug)]\n #[derive(Lift)]\n pub enum ConstantKind<'tcx> {\n     /// This constant came from the type system"}, {"sha": "11dc69ab71566f2289391e5c4671532d3305903a", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -213,7 +213,7 @@ pub struct Expr<'tcx> {\n \n #[derive(Debug, HashStable)]\n pub enum ExprKind<'tcx> {\n-    /// `Scope`s are used to explicitely mark destruction scopes,\n+    /// `Scope`s are used to explicitly mark destruction scopes,\n     /// and to track the `HirId` of the expressions within the scope.\n     Scope {\n         region_scope: region::Scope,"}, {"sha": "da8fbdbf3bce4b2e72434a639a5d03b5a377ff13", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -90,17 +90,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(\n-                    then_blk,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-                this.cfg.terminate(\n-                    else_blk,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-\n+                this.cfg.goto(then_blk, source_info, join_block);\n+                this.cfg.goto(else_blk, source_info, join_block);\n                 join_block.unit()\n             }\n             ExprKind::Let { expr, ref pat } => {\n@@ -109,8 +100,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.lower_let_expr(block, &this.thir[expr], pat, scope, expr_span)\n                 });\n \n-                let join_block = this.cfg.start_new_block();\n-\n                 this.cfg.push_assign_constant(\n                     true_block,\n                     source_info,\n@@ -133,6 +122,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n+                let join_block = this.cfg.start_new_block();\n                 this.cfg.goto(true_block, source_info, join_block);\n                 this.cfg.goto(false_block, source_info, join_block);\n                 join_block.unit()"}, {"sha": "85950d82419408d1cb2ed7c387f8c2d8bdd2f3fc", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -47,6 +47,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_span = expr.span;\n \n         match expr.kind {\n+            ExprKind::LogicalOp { op: LogicalOp::And, lhs, rhs } => {\n+                let lhs_then_block = unpack!(this.then_else_break(\n+                    block,\n+                    &this.thir[lhs],\n+                    temp_scope_override,\n+                    break_scope,\n+                    variable_scope_span,\n+                ));\n+\n+                let rhs_then_block = unpack!(this.then_else_break(\n+                    lhs_then_block,\n+                    &this.thir[rhs],\n+                    temp_scope_override,\n+                    break_scope,\n+                    variable_scope_span,\n+                ));\n+\n+                rhs_then_block.unit()\n+            }\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, this.source_info(expr_span));\n                 this.in_scope(region_scope, lint_level, |this| {"}, {"sha": "84d6c1d2db87f1c3834a2cafb9b5d121af446d97", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// if let Some(x) = a && let Some(y) = b && let Some(z) = c { ... }\n     ///\n-    /// there are three possible ways the condition can be false and we may have\n+    /// There are three possible ways the condition can be false and we may have\n     /// to drop `x`, `x` and `y`, or neither depending on which binding fails.\n     /// To handle this correctly we use a `DropTree` in a similar way to a\n     /// `loop` expression and 'break' out on all of the 'else' paths."}, {"sha": "a43388808cd5ce2c3664b5ea6377304f43c2cf73", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -315,7 +315,6 @@ impl<'tcx> Cx<'tcx> {\n                             lhs: self.mirror_expr(lhs),\n                             rhs: self.mirror_expr(rhs),\n                         },\n-\n                         _ => {\n                             let op = bin_op(op.node);\n                             ExprKind::Binary {"}, {"sha": "34204c3852ad0842e839fa1bb21368019ecaa780", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -17,6 +17,7 @@ use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n use rustc_session::Session;\n+use rustc_span::source_map::Spanned;\n use rustc_span::{DesugaringKind, ExpnKind, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n@@ -445,6 +446,10 @@ fn check_let_reachability<'p, 'tcx>(\n     pat: &'p DeconstructedPat<'p, 'tcx>,\n     span: Span,\n ) {\n+    if is_let_chain(cx.tcx, pat_id) {\n+        return;\n+    }\n+\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n     let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty());\n \n@@ -764,8 +769,11 @@ pub enum LetSource {\n \n fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n     let hir = tcx.hir();\n+\n     let parent = hir.get_parent_node(pat_id);\n-    match hir.get(parent) {\n+    let parent_node = hir.get(parent);\n+\n+    match parent_node {\n         hir::Node::Arm(hir::Arm {\n             guard: Some(hir::Guard::IfLet(&hir::Pat { hir_id, .. }, _)),\n             ..\n@@ -780,6 +788,7 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n         }\n         _ => {}\n     }\n+\n     let parent_parent = hir.get_parent_node(parent);\n     let parent_parent_node = hir.get(parent_parent);\n \n@@ -792,12 +801,30 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n         ..\n     }) = parent_parent_parent_parent_node\n     {\n-        LetSource::WhileLet\n-    } else if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If { .. }, .. }) =\n-        parent_parent_node\n-    {\n-        LetSource::IfLet\n-    } else {\n-        LetSource::GenericLet\n+        return LetSource::WhileLet;\n+    }\n+\n+    if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If(..), .. }) = parent_parent_node {\n+        return LetSource::IfLet;\n     }\n+\n+    LetSource::GenericLet\n+}\n+\n+// Since this function is called within a let context, it is reasonable to assume that any parent\n+// `&&` infers a let chain\n+fn is_let_chain(tcx: TyCtxt<'_>, pat_id: HirId) -> bool {\n+    let hir = tcx.hir();\n+    let parent = hir.get_parent_node(pat_id);\n+    let parent_parent = hir.get_parent_node(parent);\n+    matches!(\n+        hir.get(parent_parent),\n+        hir::Node::Expr(\n+            hir::Expr {\n+                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, ..),\n+                ..\n+            },\n+            ..\n+        )\n+    )\n }"}, {"sha": "7f15aacc532b31bf0f8300b55b2584b789016498", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -3,6 +3,7 @@\n // from live codes are live, and everything else is dead.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::pluralize;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -15,6 +16,7 @@ use rustc_middle::middle::privacy;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n use std::mem;\n \n // Any local node that may call something in its body block should be\n@@ -47,6 +49,10 @@ struct MarkSymbolVisitor<'tcx> {\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n     struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n+    // maps from ADTs to ignored derived traits (e.g. Debug and Clone)\n+    // and the span of their respective impl (i.e., part of the derive\n+    // macro)\n+    ignored_derived_traits: FxHashMap<DefId, Vec<(Span, DefId)>>,\n }\n \n impl<'tcx> MarkSymbolVisitor<'tcx> {\n@@ -242,14 +248,24 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     /// Automatically generated items marked with `rustc_trivial_field_reads`\n     /// will be ignored for the purposes of dead code analysis (see PR #85200\n     /// for discussion).\n-    fn should_ignore_item(&self, def_id: DefId) -> bool {\n+    fn should_ignore_item(&mut self, def_id: DefId) -> bool {\n         if let Some(impl_of) = self.tcx.impl_of_method(def_id) {\n             if !self.tcx.has_attr(impl_of, sym::automatically_derived) {\n                 return false;\n             }\n \n             if let Some(trait_of) = self.tcx.trait_id_of_impl(impl_of) {\n                 if self.tcx.has_attr(trait_of, sym::rustc_trivial_field_reads) {\n+                    let trait_ref = self.tcx.impl_trait_ref(impl_of).unwrap();\n+                    if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind() {\n+                        let impl_span = self.tcx.def_span(impl_of);\n+                        if let Some(v) = self.ignored_derived_traits.get_mut(&adt_def.did) {\n+                            v.push((impl_span, trait_of));\n+                        } else {\n+                            self.ignored_derived_traits\n+                                .insert(adt_def.did, vec![(impl_span, trait_of)]);\n+                        }\n+                    }\n                     return true;\n                 }\n             }\n@@ -571,7 +587,7 @@ fn create_and_seed_worklist<'tcx>(\n fn find_live<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n-) -> FxHashSet<LocalDefId> {\n+) -> (FxHashSet<LocalDefId>, FxHashMap<DefId, Vec<(Span, DefId)>>) {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -584,14 +600,16 @@ fn find_live<'tcx>(\n         pub_visibility: false,\n         ignore_variant_stack: vec![],\n         struct_constructors,\n+        ignored_derived_traits: FxHashMap::default(),\n     };\n     symbol_visitor.mark_live_symbols();\n-    symbol_visitor.live_symbols\n+    (symbol_visitor.live_symbols, symbol_visitor.ignored_derived_traits)\n }\n \n struct DeadVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     live_symbols: FxHashSet<LocalDefId>,\n+    ignored_derived_traits: FxHashMap<DefId, Vec<(Span, DefId)>>,\n }\n \n impl<'tcx> DeadVisitor<'tcx> {\n@@ -660,7 +678,37 @@ impl<'tcx> DeadVisitor<'tcx> {\n             self.tcx.struct_span_lint_hir(lint::builtin::DEAD_CODE, id, span, |lint| {\n                 let def_id = self.tcx.hir().local_def_id(id);\n                 let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-                lint.build(&format!(\"{} is never {}: `{}`\", descr, participle, name)).emit()\n+                let mut err = lint.build(&format!(\"{} is never {}: `{}`\", descr, participle, name));\n+                let hir = self.tcx.hir();\n+                if let Some(encl_scope) = hir.get_enclosing_scope(id) {\n+                    if let Some(encl_def_id) = hir.opt_local_def_id(encl_scope) {\n+                        if let Some(ign_traits) =\n+                            self.ignored_derived_traits.get(&encl_def_id.to_def_id())\n+                        {\n+                            let traits_str = ign_traits\n+                                .iter()\n+                                .map(|(_, t)| format!(\"`{}`\", self.tcx.item_name(*t)))\n+                                .collect::<Vec<_>>()\n+                                .join(\" and \");\n+                            let plural_s = pluralize!(ign_traits.len());\n+                            let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n+                            let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n+                            let msg = format!(\n+                                \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n+                                 intentionally ignored during dead code analysis\",\n+                                self.tcx.item_name(encl_def_id.to_def_id()),\n+                                article,\n+                                plural_s,\n+                                plural_s,\n+                                traits_str,\n+                                is_are\n+                            );\n+                            let multispan = ign_traits.iter().map(|(s, _)| *s).collect::<Vec<_>>();\n+                            err.span_note(multispan, &msg);\n+                        }\n+                    }\n+                }\n+                err.emit();\n             });\n         }\n     }\n@@ -790,7 +838,7 @@ impl<'tcx> Visitor<'tcx> for DeadVisitor<'tcx> {\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n     let access_levels = &tcx.privacy_access_levels(());\n-    let live_symbols = find_live(tcx, access_levels);\n-    let mut visitor = DeadVisitor { tcx, live_symbols };\n+    let (live_symbols, ignored_derived_traits) = find_live(tcx, access_levels);\n+    let mut visitor = DeadVisitor { tcx, live_symbols, ignored_derived_traits };\n     tcx.hir().walk_toplevel_module(&mut visitor);\n }"}, {"sha": "a5c4140e313872c0363ecd0814534d47d5fe0f03", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -375,7 +375,10 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// During sorting, the key function is called only once per element.\n+    /// During sorting, the key function is called at most once per element, by using\n+    /// temporary storage to remember the results of key evaluation.\n+    /// The order of calls to the key function is unspecified and may change in future versions\n+    /// of the standard library.\n     ///\n     /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\* log(*n*))\n     /// worst-case, where the key function is *O*(*m*)."}, {"sha": "611f4ab38ab334d713b677b6d3a4fc75277bf4be", "filename": "library/core/src/option.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -551,6 +551,29 @@ impl<T> Option<T> {\n         matches!(*self, Some(_))\n     }\n \n+    /// Returns `true` if the option is a [`Some`] wrapping a value matching the predicate.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_some_with)]\n+    ///\n+    /// let x: Option<u32> = Some(2);\n+    /// assert_eq!(x.is_some_with(|&x| x > 1), true);\n+    ///\n+    /// let x: Option<u32> = Some(0);\n+    /// assert_eq!(x.is_some_with(|&x| x > 1), false);\n+    ///\n+    /// let x: Option<u32> = None;\n+    /// assert_eq!(x.is_some_with(|&x| x > 1), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"is_some_with\", issue = \"93050\")]\n+    pub fn is_some_with(&self, f: impl FnOnce(&T) -> bool) -> bool {\n+        matches!(self, Some(x) if f(x))\n+    }\n+\n     /// Returns `true` if the option is a [`None`] value.\n     ///\n     /// # Examples"}, {"sha": "fbd6d419236ae110240b9eb4b91ebfd113d3d0dd", "filename": "library/core/src/result.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -542,6 +542,29 @@ impl<T, E> Result<T, E> {\n         matches!(*self, Ok(_))\n     }\n \n+    /// Returns `true` if the result is [`Ok`] wrapping a value matching the predicate.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_some_with)]\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.is_ok_with(|&x| x > 1), true);\n+    ///\n+    /// let x: Result<u32, &str> = Ok(0);\n+    /// assert_eq!(x.is_ok_with(|&x| x > 1), false);\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"hey\");\n+    /// assert_eq!(x.is_ok_with(|&x| x > 1), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"is_some_with\", issue = \"93050\")]\n+    pub fn is_ok_with(&self, f: impl FnOnce(&T) -> bool) -> bool {\n+        matches!(self, Ok(x) if f(x))\n+    }\n+\n     /// Returns `true` if the result is [`Err`].\n     ///\n     /// # Examples\n@@ -563,6 +586,30 @@ impl<T, E> Result<T, E> {\n         !self.is_ok()\n     }\n \n+    /// Returns `true` if the result is [`Err`] wrapping a value matching the predicate.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_some_with)]\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// let x: Result<u32, Error> = Err(Error::new(ErrorKind::NotFound, \"!\"));\n+    /// assert_eq!(x.is_err_with(|x| x.kind() == ErrorKind::NotFound), true);\n+    ///\n+    /// let x: Result<u32, Error> = Err(Error::new(ErrorKind::PermissionDenied, \"!\"));\n+    /// assert_eq!(x.is_err_with(|x| x.kind() == ErrorKind::NotFound), false);\n+    ///\n+    /// let x: Result<u32, Error> = Ok(123);\n+    /// assert_eq!(x.is_err_with(|x| x.kind() == ErrorKind::NotFound), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"is_some_with\", issue = \"93050\")]\n+    pub fn is_err_with(&self, f: impl FnOnce(&E) -> bool) -> bool {\n+        matches!(self, Err(x) if f(x))\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "d859bff1a45fa0f348d049adfe84097abc5d49ac", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -373,38 +373,61 @@ impl CString {\n     /// the position of the nul byte.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n-        trait SpecIntoVec {\n-            fn into_vec(self) -> Vec<u8>;\n+        trait SpecNewImpl {\n+            fn spec_new_impl(self) -> Result<CString, NulError>;\n         }\n-        impl<T: Into<Vec<u8>>> SpecIntoVec for T {\n-            default fn into_vec(self) -> Vec<u8> {\n-                self.into()\n+\n+        impl<T: Into<Vec<u8>>> SpecNewImpl for T {\n+            default fn spec_new_impl(self) -> Result<CString, NulError> {\n+                let bytes: Vec<u8> = self.into();\n+                match memchr::memchr(0, &bytes) {\n+                    Some(i) => Err(NulError(i, bytes)),\n+                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                }\n             }\n         }\n-        // Specialization for avoiding reallocation.\n-        impl SpecIntoVec for &'_ [u8] {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self);\n-                v\n+\n+        // Specialization for avoiding reallocation\n+        #[inline(always)] // Without that it is not inlined into specializations\n+        fn spec_new_impl_bytes(bytes: &[u8]) -> Result<CString, NulError> {\n+            // We cannot have such large slice that we would overflow here\n+            // but using `checked_add` allows LLVM to assume that capacity never overflows\n+            // and generate twice shorter code.\n+            // `saturating_add` doesn't help for some reason.\n+            let capacity = bytes.len().checked_add(1).unwrap();\n+\n+            // Allocate before validation to avoid duplication of allocation code.\n+            // We still need to allocate and copy memory even if we get an error.\n+            let mut buffer = Vec::with_capacity(capacity);\n+            buffer.extend(bytes);\n+\n+            // Check memory of self instead of new buffer.\n+            // This allows better optimizations if lto enabled.\n+            match memchr::memchr(0, bytes) {\n+                Some(i) => Err(NulError(i, buffer)),\n+                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n             }\n         }\n-        impl SpecIntoVec for &'_ str {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self.as_bytes());\n-                v\n+\n+        impl SpecNewImpl for &'_ [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n             }\n         }\n \n-        Self::_new(SpecIntoVec::into_vec(t))\n-    }\n+        impl SpecNewImpl for &'_ str {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self.as_bytes())\n+            }\n+        }\n \n-    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n-        match memchr::memchr(0, &bytes) {\n-            Some(i) => Err(NulError(i, bytes)),\n-            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+        impl SpecNewImpl for &'_ mut [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n+            }\n         }\n+\n+        t.spec_new_impl()\n     }\n \n     /// Creates a C-compatible string by consuming a byte vector,"}, {"sha": "f17df27fc14696912c48b8b7a7a8fa49e648088d", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1 +1 @@\n-Subproject commit d3740fb7aad0ea4a80ae20f64dee3a8cfc0c5c3c\n+Subproject commit f17df27fc14696912c48b8b7a7a8fa49e648088d"}, {"sha": "66d097d3d80e8f88c288c6879c7c2b909ecf8ad4", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1 +1 @@\n-Subproject commit c05c452b36358821bf4122f9c418674edd1d713d\n+Subproject commit 66d097d3d80e8f88c288c6879c7c2b909ecf8ad4"}, {"sha": "4dee6eb63d728ffb9e7a2ed443e9ada9275c69d2", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1 +1 @@\n-Subproject commit f8ba2f12df60ee19b96de24ae5b73af3de8a446b\n+Subproject commit 4dee6eb63d728ffb9e7a2ed443e9ada9275c69d2"}, {"sha": "78dd6a4684cf8d6b72275fab6d0429ea40b66338", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1 +1 @@\n-Subproject commit 875464457c4104686faf667f47848aa7b0f0a744\n+Subproject commit 78dd6a4684cf8d6b72275fab6d0429ea40b66338"}, {"sha": "44a9a571fa1f81c39ae9cbd23fcdcaa09ce516bb", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -148,8 +148,6 @@ h1.fqn {\n }\n .main-heading {\n \tdisplay: flex;\n-\tborder-bottom: 1px dashed #DDDDDD;\n-\tpadding-bottom: 6px;\n \tmargin-bottom: 15px;\n \n \t/* workaround to keep flex from breaking below 700 px width due to the float: right on the nav\n@@ -785,7 +783,6 @@ nav.sub {\n \n nav.sub {\n \tflex-grow: 1;\n-\tpadding-bottom: 10px;\n \tmargin-bottom: 25px;\n }\n .source nav.sub {"}, {"sha": "69097b81b9f1ca0a946ff346ea5935520108f445", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -194,9 +194,6 @@ pre, .rustdoc.source .example-wrap {\n pre.rust .comment { color: #788797; }\n pre.rust .doccomment { color: #a1ac88; }\n \n-nav:not(.sidebar) {\n-\tborder-bottom-color: #424c57;\n-}\n nav.main .current {\n \tborder-top-color: #5c6773;\n \tborder-bottom-color: #5c6773;"}, {"sha": "39165b2fc058f3192badc5d5925a2453058ebaee", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -151,9 +151,6 @@ a.result-keyword:focus { background-color: #884719; }\n pre.rust .comment { color: #8d8d8b; }\n pre.rust .doccomment { color: #8ca375; }\n \n-nav:not(.sidebar) {\n-\tborder-bottom-color: #4e4e4e;\n-}\n nav.main .current {\n \tborder-top-color: #eee;\n \tborder-bottom-color: #eee;"}, {"sha": "448c9ac603c82c66b60c970f3f82a9ab4e2835c0", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -148,9 +148,6 @@ a.result-keyword:focus { background-color: #afc6e4; }\n .content .fnname { color: #AD7C37; }\n .content span.keyword, .content a.keyword, .block a.current.keyword { color: #3873AD; }\n \n-nav:not(.sidebar) {\n-\tborder-bottom-color: #e0e0e0;\n-}\n nav.main .current {\n \tborder-top-color: #000;\n \tborder-bottom-color: #000;"}, {"sha": "48e0156f1b81b8ee7789e05138d4563efc9107a7", "filename": "src/test/rustdoc-gui/headings.goml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -15,7 +15,6 @@\n goto: file://|DOC_PATH|/test_docs/struct.HeavilyDocumentedStruct.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n-assert-css: (\".main-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -55,7 +54,6 @@ assert-css: (\"h6#sub-sub-heading-for-struct-impl-item-doc\", {\"font-size\": \"15.2p\n goto: file://|DOC_PATH|/test_docs/enum.HeavilyDocumentedEnum.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n-assert-css: (\".main-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -115,7 +113,6 @@ assert-css: (\".sidebar .others h3\", {\"border-bottom-width\": \"0px\"}, ALL)\n goto: file://|DOC_PATH|/test_docs/union.HeavilyDocumentedUnion.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n-assert-css: (\".main-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n@@ -148,7 +145,6 @@ assert-css: (\"h6#sub-heading-for-union-impl-item-doc\", {\"border-bottom-width\": \"\n goto: file://|DOC_PATH|/test_docs/macro.heavily_documented_macro.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n-assert-css: (\".main-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})"}, {"sha": "4c83fd6c0e31c5ef9161127a8a1865b60b2be1be", "filename": "src/test/rustdoc-gui/toggle-docs-mobile.goml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1,12 +1,12 @@\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n size: (433, 600)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 260) // This is the position of the top doc comment toggle\n+click: (4, 250) // This is the position of the top doc comment toggle\n assert-attribute-false: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 260)\n+click: (4, 250)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n // To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n-click: (3, 260)\n+click: (3, 250)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n \n // Assert the position of the toggle on the top doc block.\n@@ -22,10 +22,10 @@ assert-position: (\n // Now we do the same but with a little bigger width\n size: (600, 600)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 260) // New Y position since all search elements are back on one line.\n+click: (4, 250) // New Y position since all search elements are back on one line.\n assert-attribute-false: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 260)\n+click: (4, 250)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n // To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n-click: (3, 260)\n+click: (3, 250)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})"}, {"sha": "2a44e56a3302c87054e9f145b4cc9e9d49521df2", "filename": "src/test/ui/derive-uninhabited-enum-38885.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fderive-uninhabited-enum-38885.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fderive-uninhabited-enum-38885.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderive-uninhabited-enum-38885.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -5,6 +5,12 @@ LL |     Void(Void),\n    |     ^^^^^^^^^^\n    |\n    = note: `-W dead-code` implied by `-W unused`\n+note: `Foo` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n+  --> $DIR/derive-uninhabited-enum-38885.rs:10:10\n+   |\n+LL | #[derive(Debug)]\n+   |          ^^^^^\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: 1 warning emitted\n "}, {"sha": "67bb574315a72331ccffe78954b15eab4418a34e", "filename": "src/test/ui/derives/clone-debug-dead-code.stderr", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -15,18 +15,39 @@ error: field is never read: `f`\n    |\n LL | struct B { f: () }\n    |            ^^^^^\n+   |\n+note: `B` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis\n+  --> $DIR/clone-debug-dead-code.rs:9:10\n+   |\n+LL | #[derive(Clone)]\n+   |          ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: field is never read: `f`\n   --> $DIR/clone-debug-dead-code.rs:14:12\n    |\n LL | struct C { f: () }\n    |            ^^^^^\n+   |\n+note: `C` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n+  --> $DIR/clone-debug-dead-code.rs:13:10\n+   |\n+LL | #[derive(Debug)]\n+   |          ^^^^^\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: field is never read: `f`\n   --> $DIR/clone-debug-dead-code.rs:18:12\n    |\n LL | struct D { f: () }\n    |            ^^^^^\n+   |\n+note: `D` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis\n+  --> $DIR/clone-debug-dead-code.rs:17:10\n+   |\n+LL | #[derive(Debug,Clone)]\n+   |          ^^^^^ ^^^^^\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: field is never read: `f`\n   --> $DIR/clone-debug-dead-code.rs:21:12"}, {"sha": "2cd8731141af752a8b65559c9155948f6b47eeb2", "filename": "src/test/ui/expr/if/attrs/let-chains-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(let_chains)] //~ WARN the feature `let_chains` is incomplete\n+#![feature(let_chains)]\n \n #[cfg(FALSE)]\n fn foo() {"}, {"sha": "8b9874715342c30e23133117b9a38eec1061a4de", "filename": "src/test/ui/expr/if/attrs/let-chains-attr.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fattrs%2Flet-chains-attr.stderr?ref=2f004d2d401682e553af3984ebd9a3976885e752", "patch": "@@ -1,11 +0,0 @@\n-warning: the feature `let_chains` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/let-chains-attr.rs:3:12\n-   |\n-LL | #![feature(let_chains)]\n-   |            ^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-\n-warning: 1 warning emitted\n-"}, {"sha": "3b5683a7748fa86ff795d874ff069ac8cd88305a", "filename": "src/test/ui/lint/dead-code/unused-variant.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Funused-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Funused-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Funused-variant.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -9,6 +9,12 @@ note: the lint level is defined here\n    |\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n+note: `Enum` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis\n+  --> $DIR/unused-variant.rs:3:10\n+   |\n+LL | #[derive(Clone)]\n+   |          ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "01f943c87dd7fda9a1e078f7adee4137a3b80901", "filename": "src/test/ui/mir/mir_let_chains_drop_order.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,93 @@\n+// run-pass\n+// needs-unwind\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+// See `mir_drop_order.rs` for more information\n+\n+#![feature(let_chains)]\n+\n+use std::cell::RefCell;\n+use std::panic;\n+\n+pub struct DropLogger<'a, T> {\n+    extra: T,\n+    id: usize,\n+    log: &'a panic::AssertUnwindSafe<RefCell<Vec<usize>>>\n+}\n+\n+impl<'a, T> Drop for DropLogger<'a, T> {\n+    fn drop(&mut self) {\n+        self.log.0.borrow_mut().push(self.id);\n+    }\n+}\n+\n+struct InjectedFailure;\n+\n+#[allow(unreachable_code)]\n+fn main() {\n+    let log = panic::AssertUnwindSafe(RefCell::new(vec![]));\n+    let d = |id, extra| DropLogger { extra, id: id, log: &log };\n+    let get = || -> Vec<_> {\n+        let mut m = log.0.borrow_mut();\n+        let n = m.drain(..);\n+        n.collect()\n+    };\n+\n+    {\n+        let _x = (\n+            d(\n+                0,\n+                d(\n+                    1,\n+                    if let Some(_) = d(2, Some(true)).extra && let DropLogger { .. } = d(3, None) {\n+                        None\n+                    } else {\n+                        Some(true)\n+                    }\n+                ).extra\n+            ),\n+            d(4, None),\n+            &d(5, None),\n+            d(6, None),\n+            if let DropLogger { .. } = d(7, None) && let DropLogger { .. } = d(8, None) {\n+                d(9, None)\n+            }\n+            else {\n+                // 10 is not constructed\n+                d(10, None)\n+            }\n+        );\n+        assert_eq!(get(), vec![3, 8, 7, 1, 2]);\n+    }\n+    assert_eq!(get(), vec![0, 4, 6, 9, 5]);\n+\n+    let _ = std::panic::catch_unwind(|| {\n+        (\n+            d(\n+                11,\n+                d(\n+                    12,\n+                    if let Some(_) = d(13, Some(true)).extra\n+                        && let DropLogger { .. } = d(14, None)\n+                    {\n+                        None\n+                    } else {\n+                        Some(true)\n+                    }\n+                ).extra\n+            ),\n+            d(15, None),\n+            &d(16, None),\n+            d(17, None),\n+            if let DropLogger { .. } = d(18, None) && let DropLogger { .. } = d(19, None) {\n+                d(20, None)\n+            }\n+            else {\n+                // 10 is not constructed\n+                d(21, None)\n+            },\n+            panic::panic_any(InjectedFailure)\n+        );\n+    });\n+    assert_eq!(get(), vec![14, 19, 20, 17, 15, 11, 18, 16, 12, 13]);\n+}"}, {"sha": "d8da0ac8aa6c5cb8c426540ef28a7e65cc3d88f4", "filename": "src/test/ui/pattern/issue-82290.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs?ref=2f004d2d401682e553af3984ebd9a3976885e752", "patch": "@@ -1,9 +0,0 @@\n-// check-pass\n-\n-#![feature(let_chains)] //~ WARN the feature `let_chains` is incomplete\n-\n-fn main() {\n-    if true && let x = 1 { //~ WARN irrefutable `let` pattern\n-        let _ = x;\n-    }\n-}"}, {"sha": "0a3cf2c794f47baa7e85c4029876768cef79a33a", "filename": "src/test/ui/pattern/issue-82290.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f004d2d401682e553af3984ebd9a3976885e752/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr?ref=2f004d2d401682e553af3984ebd9a3976885e752", "patch": "@@ -1,21 +0,0 @@\n-warning: the feature `let_chains` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-82290.rs:3:12\n-   |\n-LL | #![feature(let_chains)]\n-   |            ^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-\n-warning: irrefutable `let` pattern\n-  --> $DIR/issue-82290.rs:6:16\n-   |\n-LL |     if true && let x = 1 {\n-   |                ^^^^^^^^^\n-   |\n-   = note: `#[warn(irrefutable_let_patterns)]` on by default\n-   = note: this pattern will always match, so the `let` is useless\n-   = help: consider removing `let`\n-\n-warning: 2 warnings emitted\n-"}, {"sha": "34d2d84da934ff6b28a8389ec1b285b981ea2c9d", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -8,36 +8,36 @@ fn _if_let_guard() {\n         //~^ ERROR `if let` guards are experimental\n \n         () if (let 0 = 1) => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if (((let 0 = 1))) => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if true && let 0 = 1 => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if let 0 = 1 && true => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if (let 0 = 1) && true => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if true && (let 0 = 1) => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n \n         () if (let 0 = 1) && (let 0 = 1) => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n+        //~| ERROR `let` expressions in this position are unstable\n \n         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n+        //~| ERROR `let` expressions in this position are unstable\n+        //~| ERROR `let` expressions in this position are unstable\n+        //~| ERROR `let` expressions in this position are unstable\n+        //~| ERROR `let` expressions in this position are unstable\n \n         () if let Range { start: _, end: _ } = (true..true) && false => {}\n-        //~^ ERROR `let` expressions in this position are experimental\n+        //~^ ERROR `let` expressions in this position are unstable\n         _ => {}\n     }\n }\n@@ -52,9 +52,9 @@ fn _macros() {\n         }\n     }\n     use_expr!((let 0 = 1 && 0 == 0));\n-    //~^ ERROR `let` expressions in this position are experimental\n+    //~^ ERROR `let` expressions in this position are unstable\n     use_expr!((let 0 = 1));\n-    //~^ ERROR `let` expressions in this position are experimental\n+    //~^ ERROR `let` expressions in this position are unstable\n     match () {\n         #[cfg(FALSE)]\n         () if let 0 = 1 => {}"}, {"sha": "0cda6ba9a99279d51a57289b6a20633331d3e526", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.stderr", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -27,165 +27,149 @@ LL |         () if let 0 = 1 => {}\n    = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:10:16\n    |\n LL |         () if (let 0 = 1) => {}\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:13:18\n    |\n LL |         () if (((let 0 = 1))) => {}\n    |                  ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:16:23\n    |\n LL |         () if true && let 0 = 1 => {}\n    |                       ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:19:15\n    |\n LL |         () if let 0 = 1 && true => {}\n    |               ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:22:16\n    |\n LL |         () if (let 0 = 1) && true => {}\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:25:24\n    |\n LL |         () if true && (let 0 = 1) => {}\n    |                        ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:28:16\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:28:31\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                               ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:15\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |               ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:28\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                            ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:42\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                          ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:55\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                       ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:68\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                                    ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:39:15\n    |\n LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:54:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:56:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error: aborting due to 19 previous errors\n "}, {"sha": "708bcdd0aefe35feb31eb5d2baf7aa05f5a3d9cd", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-lowering-does-not-wrap-let-chains.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(let_chains)]\n+\n+fn main() {\n+    let first = Some(1);\n+    let second = Some(2);\n+    let mut n = 0;\n+    if let x = first && let y = second && 1 == 1 {\n+        assert_eq!(x, first);\n+        assert_eq!(y, second);\n+        n = 1;\n+    }\n+    assert_eq!(n, 1);\n+}"}, {"sha": "69bc189dd3579cd795fe0730b7cfb283826ce4f3", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-pretty-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1,4 +1,4 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // compile-flags: -Z unpretty=expanded\n \n fn main() {"}, {"sha": "e737ef26e9b3819822566c628bd3f2314be4e9b7", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-pretty-check.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-pretty-check.stdout?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -4,7 +4,7 @@\n use ::std::prelude::rust_2015::*;\n #[macro_use]\n extern crate std;\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // compile-flags: -Z unpretty=expanded\n \n fn main() { if let 0 = 1 {} }"}, {"sha": "a7e108d72d1ff92054f1cf32b9ec48cca4940585", "filename": "src/test/ui/rfc-2497-if-let-chains/chains-without-let.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,20 @@\n+fn and_chain() {\n+    let z;\n+    if true && { z = 3; true} && z == 3 {}\n+    //~^ ERROR use of possibly-uninitialized\n+}\n+\n+fn and_chain_2() {\n+    let z;\n+    true && { z = 3; true} && z == 3;\n+    //~^ ERROR use of possibly-uninitialized\n+}\n+\n+fn or_chain() {\n+    let z;\n+    if false || { z = 3; false} || z == 3 {}\n+    //~^ ERROR use of possibly-uninitialized\n+}\n+\n+fn main() {\n+}"}, {"sha": "3c47040cc8c24ca28a9f75a2d893c269bad3fb1e", "filename": "src/test/ui/rfc-2497-if-let-chains/chains-without-let.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fchains-without-let.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: use of possibly-uninitialized variable: `z`\n+  --> $DIR/chains-without-let.rs:3:34\n+   |\n+LL |     if true && { z = 3; true} && z == 3 {}\n+   |                                  ^ use of possibly-uninitialized `z`\n+\n+error[E0381]: use of possibly-uninitialized variable: `z`\n+  --> $DIR/chains-without-let.rs:9:31\n+   |\n+LL |     true && { z = 3; true} && z == 3;\n+   |                               ^ use of possibly-uninitialized `z`\n+\n+error[E0381]: use of possibly-uninitialized variable: `z`\n+  --> $DIR/chains-without-let.rs:15:36\n+   |\n+LL |     if false || { z = 3; false} || z == 3 {}\n+   |                                    ^ use of possibly-uninitialized `z`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "5b2693d07a7905eb5944555a93943d9c0c7bfd7f", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -18,7 +18,6 @@\n // To that end, we check some positions which is not part of the language above.\n \n #![feature(let_chains)] // Avoid inflating `.stderr` with overzealous gates in this test.\n-//~^ WARN the feature `let_chains` is incomplete\n \n #![allow(irrefutable_let_patterns)]\n "}, {"sha": "4c830554d435c9c6949956575d2f5542a54891fc", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 106, "deletions": 115, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -1,5 +1,5 @@\n error: expressions must be enclosed in braces to be used as const generic arguments\n-  --> $DIR/disallowed-positions.rs:233:9\n+  --> $DIR/disallowed-positions.rs:232:9\n    |\n LL |         true && let 1 = 1\n    |         ^^^^^^^^^^^^^^^^^\n@@ -10,7 +10,7 @@ LL |         { true && let 1 = 1 }\n    |         +                   +\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:30:9\n+  --> $DIR/disallowed-positions.rs:29:9\n    |\n LL |     if &let 0 = 0 {}\n    |         ^^^^^^^^^\n@@ -19,7 +19,7 @@ LL |     if &let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:33:9\n+  --> $DIR/disallowed-positions.rs:32:9\n    |\n LL |     if !let 0 = 0 {}\n    |         ^^^^^^^^^\n@@ -28,7 +28,7 @@ LL |     if !let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:34:9\n+  --> $DIR/disallowed-positions.rs:33:9\n    |\n LL |     if *let 0 = 0 {}\n    |         ^^^^^^^^^\n@@ -37,7 +37,7 @@ LL |     if *let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:36:9\n+  --> $DIR/disallowed-positions.rs:35:9\n    |\n LL |     if -let 0 = 0 {}\n    |         ^^^^^^^^^\n@@ -46,7 +46,7 @@ LL |     if -let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:44:9\n+  --> $DIR/disallowed-positions.rs:43:9\n    |\n LL |     if (let 0 = 0)? {}\n    |         ^^^^^^^^^\n@@ -55,7 +55,7 @@ LL |     if (let 0 = 0)? {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:48:16\n+  --> $DIR/disallowed-positions.rs:47:16\n    |\n LL |     if true || let 0 = 0 {}\n    |                ^^^^^^^^^\n@@ -64,7 +64,7 @@ LL |     if true || let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:49:17\n+  --> $DIR/disallowed-positions.rs:48:17\n    |\n LL |     if (true || let 0 = 0) {}\n    |                 ^^^^^^^^^\n@@ -73,7 +73,7 @@ LL |     if (true || let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:50:25\n+  --> $DIR/disallowed-positions.rs:49:25\n    |\n LL |     if true && (true || let 0 = 0) {}\n    |                         ^^^^^^^^^\n@@ -82,7 +82,7 @@ LL |     if true && (true || let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:51:25\n+  --> $DIR/disallowed-positions.rs:50:25\n    |\n LL |     if true || (true && let 0 = 0) {}\n    |                         ^^^^^^^^^\n@@ -91,7 +91,7 @@ LL |     if true || (true && let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:54:12\n+  --> $DIR/disallowed-positions.rs:53:12\n    |\n LL |     if x = let 0 = 0 {}\n    |            ^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |     if x = let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:57:15\n+  --> $DIR/disallowed-positions.rs:56:15\n    |\n LL |     if true..(let 0 = 0) {}\n    |               ^^^^^^^^^\n@@ -109,7 +109,7 @@ LL |     if true..(let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:59:11\n+  --> $DIR/disallowed-positions.rs:58:11\n    |\n LL |     if ..(let 0 = 0) {}\n    |           ^^^^^^^^^\n@@ -118,7 +118,7 @@ LL |     if ..(let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:61:9\n+  --> $DIR/disallowed-positions.rs:60:9\n    |\n LL |     if (let 0 = 0).. {}\n    |         ^^^^^^^^^\n@@ -127,7 +127,7 @@ LL |     if (let 0 = 0).. {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:65:8\n+  --> $DIR/disallowed-positions.rs:64:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -136,7 +136,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:69:8\n+  --> $DIR/disallowed-positions.rs:68:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -145,7 +145,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:76:8\n+  --> $DIR/disallowed-positions.rs:75:8\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     if let Range { start: F, end } = F..|| true {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:84:8\n+  --> $DIR/disallowed-positions.rs:83:8\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -163,7 +163,7 @@ LL |     if let Range { start: true, end } = t..&&false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:90:19\n+  --> $DIR/disallowed-positions.rs:89:19\n    |\n LL |     if let true = let true = true {}\n    |                   ^^^^^^^^^^^^^^^\n@@ -172,7 +172,7 @@ LL |     if let true = let true = true {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:94:12\n+  --> $DIR/disallowed-positions.rs:93:12\n    |\n LL |     while &let 0 = 0 {}\n    |            ^^^^^^^^^\n@@ -181,7 +181,7 @@ LL |     while &let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:97:12\n+  --> $DIR/disallowed-positions.rs:96:12\n    |\n LL |     while !let 0 = 0 {}\n    |            ^^^^^^^^^\n@@ -190,7 +190,7 @@ LL |     while !let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:98:12\n+  --> $DIR/disallowed-positions.rs:97:12\n    |\n LL |     while *let 0 = 0 {}\n    |            ^^^^^^^^^\n@@ -199,7 +199,7 @@ LL |     while *let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:100:12\n+  --> $DIR/disallowed-positions.rs:99:12\n    |\n LL |     while -let 0 = 0 {}\n    |            ^^^^^^^^^\n@@ -208,7 +208,7 @@ LL |     while -let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:108:12\n+  --> $DIR/disallowed-positions.rs:107:12\n    |\n LL |     while (let 0 = 0)? {}\n    |            ^^^^^^^^^\n@@ -217,7 +217,7 @@ LL |     while (let 0 = 0)? {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:112:19\n+  --> $DIR/disallowed-positions.rs:111:19\n    |\n LL |     while true || let 0 = 0 {}\n    |                   ^^^^^^^^^\n@@ -226,7 +226,7 @@ LL |     while true || let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:113:20\n+  --> $DIR/disallowed-positions.rs:112:20\n    |\n LL |     while (true || let 0 = 0) {}\n    |                    ^^^^^^^^^\n@@ -235,7 +235,7 @@ LL |     while (true || let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:114:28\n+  --> $DIR/disallowed-positions.rs:113:28\n    |\n LL |     while true && (true || let 0 = 0) {}\n    |                            ^^^^^^^^^\n@@ -244,7 +244,7 @@ LL |     while true && (true || let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:115:28\n+  --> $DIR/disallowed-positions.rs:114:28\n    |\n LL |     while true || (true && let 0 = 0) {}\n    |                            ^^^^^^^^^\n@@ -253,7 +253,7 @@ LL |     while true || (true && let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:118:15\n+  --> $DIR/disallowed-positions.rs:117:15\n    |\n LL |     while x = let 0 = 0 {}\n    |               ^^^^^^^^^\n@@ -262,7 +262,7 @@ LL |     while x = let 0 = 0 {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:121:18\n+  --> $DIR/disallowed-positions.rs:120:18\n    |\n LL |     while true..(let 0 = 0) {}\n    |                  ^^^^^^^^^\n@@ -271,7 +271,7 @@ LL |     while true..(let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:123:14\n+  --> $DIR/disallowed-positions.rs:122:14\n    |\n LL |     while ..(let 0 = 0) {}\n    |              ^^^^^^^^^\n@@ -280,7 +280,7 @@ LL |     while ..(let 0 = 0) {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:125:12\n+  --> $DIR/disallowed-positions.rs:124:12\n    |\n LL |     while (let 0 = 0).. {}\n    |            ^^^^^^^^^\n@@ -289,7 +289,7 @@ LL |     while (let 0 = 0).. {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:129:11\n+  --> $DIR/disallowed-positions.rs:128:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -298,7 +298,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:133:11\n+  --> $DIR/disallowed-positions.rs:132:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -307,7 +307,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:140:11\n+  --> $DIR/disallowed-positions.rs:139:11\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -316,7 +316,7 @@ LL |     while let Range { start: F, end } = F..|| true {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:148:11\n+  --> $DIR/disallowed-positions.rs:147:11\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -325,7 +325,7 @@ LL |     while let Range { start: true, end } = t..&&false {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:154:22\n+  --> $DIR/disallowed-positions.rs:153:22\n    |\n LL |     while let true = let true = true {}\n    |                      ^^^^^^^^^^^^^^^\n@@ -334,7 +334,7 @@ LL |     while let true = let true = true {}\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:168:6\n+  --> $DIR/disallowed-positions.rs:167:6\n    |\n LL |     &let 0 = 0;\n    |      ^^^^^^^^^\n@@ -343,7 +343,7 @@ LL |     &let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:170:6\n+  --> $DIR/disallowed-positions.rs:169:6\n    |\n LL |     !let 0 = 0;\n    |      ^^^^^^^^^\n@@ -352,7 +352,7 @@ LL |     !let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:171:6\n+  --> $DIR/disallowed-positions.rs:170:6\n    |\n LL |     *let 0 = 0;\n    |      ^^^^^^^^^\n@@ -361,7 +361,7 @@ LL |     *let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:173:6\n+  --> $DIR/disallowed-positions.rs:172:6\n    |\n LL |     -let 0 = 0;\n    |      ^^^^^^^^^\n@@ -370,7 +370,7 @@ LL |     -let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:181:6\n+  --> $DIR/disallowed-positions.rs:180:6\n    |\n LL |     (let 0 = 0)?;\n    |      ^^^^^^^^^\n@@ -379,7 +379,7 @@ LL |     (let 0 = 0)?;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:185:13\n+  --> $DIR/disallowed-positions.rs:184:13\n    |\n LL |     true || let 0 = 0;\n    |             ^^^^^^^^^\n@@ -388,7 +388,7 @@ LL |     true || let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:186:14\n+  --> $DIR/disallowed-positions.rs:185:14\n    |\n LL |     (true || let 0 = 0);\n    |              ^^^^^^^^^\n@@ -397,7 +397,7 @@ LL |     (true || let 0 = 0);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:187:22\n+  --> $DIR/disallowed-positions.rs:186:22\n    |\n LL |     true && (true || let 0 = 0);\n    |                      ^^^^^^^^^\n@@ -406,7 +406,7 @@ LL |     true && (true || let 0 = 0);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:190:9\n+  --> $DIR/disallowed-positions.rs:189:9\n    |\n LL |     x = let 0 = 0;\n    |         ^^^^^^^^^\n@@ -415,7 +415,7 @@ LL |     x = let 0 = 0;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:192:12\n+  --> $DIR/disallowed-positions.rs:191:12\n    |\n LL |     true..(let 0 = 0);\n    |            ^^^^^^^^^\n@@ -424,7 +424,7 @@ LL |     true..(let 0 = 0);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:193:8\n+  --> $DIR/disallowed-positions.rs:192:8\n    |\n LL |     ..(let 0 = 0);\n    |        ^^^^^^^^^\n@@ -433,7 +433,7 @@ LL |     ..(let 0 = 0);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:194:6\n+  --> $DIR/disallowed-positions.rs:193:6\n    |\n LL |     (let 0 = 0)..;\n    |      ^^^^^^^^^\n@@ -442,7 +442,7 @@ LL |     (let 0 = 0)..;\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:196:6\n+  --> $DIR/disallowed-positions.rs:195:6\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -451,7 +451,7 @@ LL |     (let Range { start: _, end: _ } = true..true || false);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:200:6\n+  --> $DIR/disallowed-positions.rs:199:6\n    |\n LL |     (let true = let true = true);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -460,7 +460,7 @@ LL |     (let true = let true = true);\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:204:6\n+  --> $DIR/disallowed-positions.rs:203:6\n    |\n LL |     &let 0 = 0\n    |      ^^^^^^^^^\n@@ -469,7 +469,7 @@ LL |     &let 0 = 0\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:215:17\n+  --> $DIR/disallowed-positions.rs:214:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n@@ -478,7 +478,7 @@ LL |         true && let 1 = 1\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:219:17\n+  --> $DIR/disallowed-positions.rs:218:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n@@ -487,7 +487,7 @@ LL |         true && let 1 = 1\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:223:17\n+  --> $DIR/disallowed-positions.rs:222:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n@@ -496,25 +496,16 @@ LL |         true && let 1 = 1\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:233:17\n+  --> $DIR/disallowed-positions.rs:232:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if`- and `while`-expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n-warning: the feature `let_chains` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/disallowed-positions.rs:20:12\n-   |\n-LL | #![feature(let_chains)] // Avoid inflating `.stderr` with overzealous gates in this test.\n-   |            ^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-\n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:30:8\n+  --> $DIR/disallowed-positions.rs:29:8\n    |\n LL |     if &let 0 = 0 {}\n    |        ^^^^^^^^^^ expected `bool`, found `&bool`\n@@ -526,27 +517,27 @@ LL +     if let 0 = 0 {}\n    | \n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:34:8\n+  --> $DIR/disallowed-positions.rs:33:8\n    |\n LL |     if *let 0 = 0 {}\n    |        ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:36:8\n+  --> $DIR/disallowed-positions.rs:35:8\n    |\n LL |     if -let 0 = 0 {}\n    |        ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:44:8\n+  --> $DIR/disallowed-positions.rs:43:8\n    |\n LL |     if (let 0 = 0)? {}\n    |        ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:44:19\n+  --> $DIR/disallowed-positions.rs:43:19\n    |\n LL | / fn nested_within_if_expr() {\n LL | |     if &let 0 = 0 {}\n@@ -563,7 +554,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:54:8\n+  --> $DIR/disallowed-positions.rs:53:8\n    |\n LL |     if x = let 0 = 0 {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n@@ -574,7 +565,7 @@ LL |     if x == let 0 = 0 {}\n    |          ~~\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:57:8\n+  --> $DIR/disallowed-positions.rs:56:8\n    |\n LL |     if true..(let 0 = 0) {}\n    |        ^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -583,7 +574,7 @@ LL |     if true..(let 0 = 0) {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:59:8\n+  --> $DIR/disallowed-positions.rs:58:8\n    |\n LL |     if ..(let 0 = 0) {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found struct `RangeTo`\n@@ -592,7 +583,7 @@ LL |     if ..(let 0 = 0) {}\n             found struct `RangeTo<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:61:8\n+  --> $DIR/disallowed-positions.rs:60:8\n    |\n LL |     if (let 0 = 0).. {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found struct `RangeFrom`\n@@ -601,7 +592,7 @@ LL |     if (let 0 = 0).. {}\n             found struct `RangeFrom<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:65:12\n+  --> $DIR/disallowed-positions.rs:64:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -612,7 +603,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:65:8\n+  --> $DIR/disallowed-positions.rs:64:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -621,7 +612,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:69:12\n+  --> $DIR/disallowed-positions.rs:68:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -632,7 +623,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:69:8\n+  --> $DIR/disallowed-positions.rs:68:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -641,7 +632,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:76:12\n+  --> $DIR/disallowed-positions.rs:75:12\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `fn() -> bool`\n@@ -652,16 +643,16 @@ LL |     if let Range { start: F, end } = F..|| true {}\n                   found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:76:41\n+  --> $DIR/disallowed-positions.rs:75:41\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |                                         ^^^^^^^ expected `bool`, found closure\n    |\n    = note: expected type `bool`\n-           found closure `[closure@$DIR/disallowed-positions.rs:76:41: 76:48]`\n+           found closure `[closure@$DIR/disallowed-positions.rs:75:41: 75:48]`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:76:8\n+  --> $DIR/disallowed-positions.rs:75:8\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -670,7 +661,7 @@ LL |     if let Range { start: F, end } = F..|| true {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:84:12\n+  --> $DIR/disallowed-positions.rs:83:12\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n@@ -681,13 +672,13 @@ LL |     if let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:84:44\n+  --> $DIR/disallowed-positions.rs:83:44\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |                                            ^^^^^^^ expected `bool`, found `&&bool`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:84:8\n+  --> $DIR/disallowed-positions.rs:83:8\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -696,15 +687,15 @@ LL |     if let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:40:20\n+  --> $DIR/disallowed-positions.rs:39:20\n    |\n LL |         if let 0 = 0? {}\n    |                    ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:94:11\n+  --> $DIR/disallowed-positions.rs:93:11\n    |\n LL |     while &let 0 = 0 {}\n    |           ^^^^^^^^^^ expected `bool`, found `&bool`\n@@ -716,27 +707,27 @@ LL +     while let 0 = 0 {}\n    | \n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:98:11\n+  --> $DIR/disallowed-positions.rs:97:11\n    |\n LL |     while *let 0 = 0 {}\n    |           ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:100:11\n+  --> $DIR/disallowed-positions.rs:99:11\n    |\n LL |     while -let 0 = 0 {}\n    |           ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:108:11\n+  --> $DIR/disallowed-positions.rs:107:11\n    |\n LL |     while (let 0 = 0)? {}\n    |           ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:108:22\n+  --> $DIR/disallowed-positions.rs:107:22\n    |\n LL | / fn nested_within_while_expr() {\n LL | |     while &let 0 = 0 {}\n@@ -753,7 +744,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:118:11\n+  --> $DIR/disallowed-positions.rs:117:11\n    |\n LL |     while x = let 0 = 0 {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found `()`\n@@ -764,7 +755,7 @@ LL |     while x == let 0 = 0 {}\n    |             ~~\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:121:11\n+  --> $DIR/disallowed-positions.rs:120:11\n    |\n LL |     while true..(let 0 = 0) {}\n    |           ^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -773,7 +764,7 @@ LL |     while true..(let 0 = 0) {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:123:11\n+  --> $DIR/disallowed-positions.rs:122:11\n    |\n LL |     while ..(let 0 = 0) {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found struct `RangeTo`\n@@ -782,7 +773,7 @@ LL |     while ..(let 0 = 0) {}\n             found struct `RangeTo<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:125:11\n+  --> $DIR/disallowed-positions.rs:124:11\n    |\n LL |     while (let 0 = 0).. {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found struct `RangeFrom`\n@@ -791,7 +782,7 @@ LL |     while (let 0 = 0).. {}\n             found struct `RangeFrom<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:129:15\n+  --> $DIR/disallowed-positions.rs:128:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -802,7 +793,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:129:11\n+  --> $DIR/disallowed-positions.rs:128:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -811,7 +802,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:133:15\n+  --> $DIR/disallowed-positions.rs:132:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -822,7 +813,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:133:11\n+  --> $DIR/disallowed-positions.rs:132:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -831,7 +822,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:140:15\n+  --> $DIR/disallowed-positions.rs:139:15\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `fn() -> bool`\n@@ -842,16 +833,16 @@ LL |     while let Range { start: F, end } = F..|| true {}\n                   found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:140:44\n+  --> $DIR/disallowed-positions.rs:139:44\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |                                            ^^^^^^^ expected `bool`, found closure\n    |\n    = note: expected type `bool`\n-           found closure `[closure@$DIR/disallowed-positions.rs:140:44: 140:51]`\n+           found closure `[closure@$DIR/disallowed-positions.rs:139:44: 139:51]`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:140:11\n+  --> $DIR/disallowed-positions.rs:139:11\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -860,7 +851,7 @@ LL |     while let Range { start: F, end } = F..|| true {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:148:15\n+  --> $DIR/disallowed-positions.rs:147:15\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n@@ -871,13 +862,13 @@ LL |     while let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:148:47\n+  --> $DIR/disallowed-positions.rs:147:47\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |                                               ^^^^^^^ expected `bool`, found `&&bool`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:148:11\n+  --> $DIR/disallowed-positions.rs:147:11\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -886,35 +877,35 @@ LL |     while let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:104:23\n+  --> $DIR/disallowed-positions.rs:103:23\n    |\n LL |         while let 0 = 0? {}\n    |                       ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:171:5\n+  --> $DIR/disallowed-positions.rs:170:5\n    |\n LL |     *let 0 = 0;\n    |     ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:173:5\n+  --> $DIR/disallowed-positions.rs:172:5\n    |\n LL |     -let 0 = 0;\n    |     ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:181:5\n+  --> $DIR/disallowed-positions.rs:180:5\n    |\n LL |     (let 0 = 0)?;\n    |     ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:181:16\n+  --> $DIR/disallowed-positions.rs:180:16\n    |\n LL | / fn outside_if_and_while_expr() {\n LL | |     &let 0 = 0;\n@@ -931,7 +922,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:196:10\n+  --> $DIR/disallowed-positions.rs:195:10\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -942,7 +933,7 @@ LL |     (let Range { start: _, end: _ } = true..true || false);\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:204:5\n+  --> $DIR/disallowed-positions.rs:203:5\n    |\n LL | fn outside_if_and_while_expr() {\n    |                                - help: try adding a return type: `-> &bool`\n@@ -951,14 +942,14 @@ LL |     &let 0 = 0\n    |     ^^^^^^^^^^ expected `()`, found `&bool`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:177:17\n+  --> $DIR/disallowed-positions.rs:176:17\n    |\n LL |         let 0 = 0?;\n    |                 ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n-error: aborting due to 103 previous errors; 1 warning emitted\n+error: aborting due to 103 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0600, E0614.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "53fec8316e7e710400e9e5065054103729b44388", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -12,79 +12,79 @@ fn _if() {\n     if let 0 = 1 {} // Stable!\n \n     if (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if (((let 0 = 1))) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if true && let 0 = 1 {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if let 0 = 1 && true {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if (let 0 = 1) && true {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if true && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if (let 0 = 1) && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n \n     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n \n     if let Range { start: _, end: _ } = (true..true) && false {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n }\n \n fn _while() {\n     while let 0 = 1 {} // Stable!\n \n     while (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while (((let 0 = 1))) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while true && let 0 = 1 {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while let 0 = 1 && true {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while (let 0 = 1) && true {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while true && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while (let 0 = 1) && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n \n     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n+    //~| ERROR `let` expressions in this position are unstable [E0658]\n \n     while let Range { start: _, end: _ } = (true..true) && false {}\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n }\n \n fn _macros() {\n     macro_rules! noop_expr { ($e:expr) => {}; }\n \n     noop_expr!((let 0 = 1));\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     macro_rules! use_expr {\n         ($e:expr) => {\n@@ -93,11 +93,11 @@ fn _macros() {\n         }\n     }\n     use_expr!((let 0 = 1 && 0 == 0));\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n     use_expr!((let 0 = 1));\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n     #[cfg(FALSE)] (let 0 = 1);\n-    //~^ ERROR `let` expressions in this position are experimental [E0658]\n+    //~^ ERROR `let` expressions in this position are unstable [E0658]\n     use_expr!(let 0 = 1);\n     //~^ ERROR no rules expected the token `let`\n     // ^--- FIXME(53667): Consider whether `Let` can be added to `ident_can_begin_expr`."}, {"sha": "458826498fe2d1044ec7a6e2562f7e138852cb0d", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.stderr", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -7,325 +7,293 @@ LL |     macro_rules! use_expr {\n LL |     use_expr!(let 0 = 1);\n    |               ^^^ no rules expected this token in macro call\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:14:9\n    |\n LL |     if (let 0 = 1) {}\n    |         ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:17:11\n    |\n LL |     if (((let 0 = 1))) {}\n    |           ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:20:16\n    |\n LL |     if true && let 0 = 1 {}\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:23:8\n    |\n LL |     if let 0 = 1 && true {}\n    |        ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:26:9\n    |\n LL |     if (let 0 = 1) && true {}\n    |         ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:29:17\n    |\n LL |     if true && (let 0 = 1) {}\n    |                 ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:9\n    |\n LL |     if (let 0 = 1) && (let 0 = 1) {}\n    |         ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:32:24\n    |\n LL |     if (let 0 = 1) && (let 0 = 1) {}\n    |                        ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:36:8\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |        ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:36:21\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                     ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:36:35\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                   ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:36:48\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:36:61\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                             ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:43:8\n    |\n LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:50:12\n    |\n LL |     while (let 0 = 1) {}\n    |            ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:53:14\n    |\n LL |     while (((let 0 = 1))) {}\n    |              ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:56:19\n    |\n LL |     while true && let 0 = 1 {}\n    |                   ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:59:11\n    |\n LL |     while let 0 = 1 && true {}\n    |           ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:62:12\n    |\n LL |     while (let 0 = 1) && true {}\n    |            ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:65:20\n    |\n LL |     while true && (let 0 = 1) {}\n    |                    ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:68:12\n    |\n LL |     while (let 0 = 1) && (let 0 = 1) {}\n    |            ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:68:27\n    |\n LL |     while (let 0 = 1) && (let 0 = 1) {}\n    |                           ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:72:11\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |           ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:72:24\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                        ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:72:38\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                      ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:72:51\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                   ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:72:64\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:79:11\n    |\n LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:99:20\n    |\n LL |     #[cfg(FALSE)] (let 0 = 1);\n    |                    ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:86:17\n    |\n LL |     noop_expr!((let 0 = 1));\n    |                 ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:95:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error[E0658]: `let` expressions in this position are experimental\n+error[E0658]: `let` expressions in this position are unstable\n   --> $DIR/feature-gate.rs:97:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-   = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error: aborting due to 33 previous errors\n "}, {"sha": "5915cb9df269c127bd8d101d906d669fe725c336", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+#![feature(let_chains)]\n+\n+use std::ops::Range;\n+\n+fn main() {\n+    let opt = Some(None..Some(1));\n+\n+    if let first = &opt && let Some(ref second) = first && let None = second.start {\n+    }\n+    if let Some(ref first) = opt && let second = first && let _third = second {\n+    }\n+    if let Some(ref first) = opt\n+        && let Range { start: local_start, end: _ } = first\n+        && let None = local_start {\n+    }\n+\n+    while let first = &opt && let Some(ref second) = first && let None = second.start {\n+    }\n+    while let Some(ref first) = opt && let second = first && let _third = second {\n+    }\n+    while let Some(ref first) = opt\n+        && let Range { start: local_start, end: _ } = first\n+        && let None = local_start {\n+    }\n+}"}, {"sha": "3eb8a9ad060207e1cb993f05cb25d5f153fed871", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-88498.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-88498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-88498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-88498.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+pub enum UnOp {\n+    Not(Vec<()>),\n+}\n+\n+pub fn foo() {\n+    if let Some(x) = None {\n+        match x {\n+            UnOp::Not(_) => {}\n+        }\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "6b7d88356508549ce72a53ad57afd2daa952420a", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-90722.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-90722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-90722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-90722.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(let_chains)]\n+\n+fn main() {\n+    let x = Some(vec![\"test\"]);\n+\n+    if let Some(v) = x && v.is_empty() {\n+        println!(\"x == Some([])\");\n+    }\n+}"}, {"sha": "7c7e31f4db4007e5a8f7d443239f86af4c77f942", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-92145.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-92145.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-92145.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-92145.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(let_chains)]\n+\n+fn main() {\n+    let opt = Some(\"foo bar\");\n+\n+    if true && let Some(x) = opt {\n+        println!(\"{}\", x);\n+    }\n+}"}, {"sha": "6b91c455e0e9769685826d96d4062213a1bc011e", "filename": "src/test/ui/rfc-2497-if-let-chains/no-double-assigments.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fno-double-assigments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fno-double-assigments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fno-double-assigments.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+fn main() {\n+    loop {\n+        // [1][0] should leave top scope\n+        if true && [1][0] == 1 && true {\n+        }\n+    }\n+}"}, {"sha": "0856a10520636d42a9ff5bcbc28f050a6c00c6a9", "filename": "src/test/ui/rfc-2497-if-let-chains/then-else-blocks.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e57faa78aa7661c6000204591558f6665f11abc/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fthen-else-blocks.rs?ref=5e57faa78aa7661c6000204591558f6665f11abc", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+#![feature(let_chains)]\n+\n+fn check_if_let(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n+    if let Some(first) = opt\n+        && let Some(second) = first\n+        && let Some(third) = second\n+        && third == value\n+    {\n+        true\n+    }\n+    else {\n+        false\n+    }\n+}\n+\n+fn check_while_let(opt: Option<Option<Option<i32>>>, value: i32) -> bool {\n+    while let Some(first) = opt\n+        && let Some(second) = first\n+        && let Some(third) = second\n+        && third == value\n+    {\n+        return true;\n+    }\n+    false\n+}\n+\n+fn main() {\n+    assert_eq!(check_if_let(Some(Some(Some(1))), 1), true);\n+    assert_eq!(check_if_let(Some(Some(Some(1))), 9), false);\n+\n+    assert_eq!(check_while_let(Some(Some(Some(1))), 1), true);\n+    assert_eq!(check_while_let(Some(Some(Some(1))), 9), false);\n+}"}]}