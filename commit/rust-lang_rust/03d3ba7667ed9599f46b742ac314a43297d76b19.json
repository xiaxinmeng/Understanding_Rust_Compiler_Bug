{"sha": "03d3ba7667ed9599f46b742ac314a43297d76b19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZDNiYTc2NjdlZDk1OTlmNDZiNzQyYWMzMTRhNDMyOTdkNzZiMTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-30T21:46:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-01T15:21:40Z"}, "message": "Implement the changes to coherence such that we consider a type to be\nlocal only if matches `FUNDAMENTAL(LocalType)`, where `FUNDAMENTAL`\nincludes `&T` and types marked as fundamental (which includes `Box`).\nAlso apply these tests to negative reasoning.", "tree": {"sha": "366dc8844a67ea6dbc2ad43fae790a92c13f175d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366dc8844a67ea6dbc2ad43fae790a92c13f175d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03d3ba7667ed9599f46b742ac314a43297d76b19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03d3ba7667ed9599f46b742ac314a43297d76b19", "html_url": "https://github.com/rust-lang/rust/commit/03d3ba7667ed9599f46b742ac314a43297d76b19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03d3ba7667ed9599f46b742ac314a43297d76b19/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89436536246250ee3cbc47a61c31037ce7558c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/89436536246250ee3cbc47a61c31037ce7558c06", "html_url": "https://github.com/rust-lang/rust/commit/89436536246250ee3cbc47a61c31037ce7558c06"}], "stats": {"total": 502, "additions": 337, "deletions": 165}, "files": [{"sha": "411be28b89695162d75d435751b793d64ec6788b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 150, "deletions": 53, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -17,15 +17,17 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n-use middle::subst::{Subst, TypeSpace};\n+use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n \n+#[derive(Copy)]\n+struct ParamIsLocal(bool);\n+\n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n                          impl1_def_id: ast::DefId,\n@@ -56,10 +58,16 @@ fn overlap(selcx: &mut SelectionContext,\n            a_def_id.repr(selcx.tcx()),\n            b_def_id.repr(selcx.tcx()));\n \n-    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n-    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                a_def_id,\n+                                                                util::free_substs_for_impl);\n+\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                b_def_id,\n+                                                                util::fresh_type_vars_for_impl);\n \n     debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+\n     debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n \n     // Does `a <: b` hold? If not, no overlap.\n@@ -74,28 +82,68 @@ fn overlap(selcx: &mut SelectionContext,\n     debug!(\"overlap: subtraitref check succeeded\");\n \n     // Are any of the obligations unsatisfiable? If so, no overlap.\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n     let opt_failing_obligation =\n         a_obligations.iter()\n                      .chain(b_obligations.iter())\n+                     .map(|o| infcx.resolve_type_vars_if_possible(o))\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(selcx.tcx()));\n-        return false;\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(tcx));\n+        return false\n     }\n \n     true\n }\n \n+pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n+{\n+    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr(tcx));\n+\n+    // if the orphan rules pass, that means that no ancestor crate can\n+    // impl this, so it's up to us.\n+    if orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(false)).is_ok() {\n+        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+        return true;\n+    }\n+\n+    // if the trait is not marked fundamental, then it's always possible that\n+    // an ancestor crate will impl this in the future, if they haven't\n+    // already\n+    if\n+        trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n+        !ty::has_attr(tcx, trait_ref.def_id, \"fundamental\")\n+    {\n+        debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n+        return false;\n+    }\n+\n+    // find out when some downstream (or cousin) crate could impl this\n+    // trait-ref, presuming that all the parameters were instantiated\n+    // with downstream types. If not, then it could only be\n+    // implemented by an upstream crate, which means that the impl\n+    // must be visible to us, and -- since the trait is fundamental\n+    // -- we can test.\n+    orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(true)).is_err()\n+}\n+\n+type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n+                                span: Span,\n+                                impl_def_id: ast::DefId)\n+                                -> Substs<'tcx>;\n+\n /// Instantiate fresh variables for all bound parameters of the impl\n /// and return the impl trait ref with those variables substituted.\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: ast::DefId)\n+                                     impl_def_id: ast::DefId,\n+                                     substs_fn: SubstsFn)\n                                      -> (Rc<ty::TraitRef<'tcx>>,\n                                          Vec<PredicateObligation<'tcx>>)\n {\n     let impl_substs =\n-        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+        &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n     let impl_trait_ref =\n         ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n     let impl_trait_ref =\n@@ -134,12 +182,12 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n+    debug!(\"orphan_check({})\", impl_def_id.repr(tcx));\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n@@ -148,34 +196,106 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return Ok(());\n     }\n \n+    orphan_check_trait_ref(tcx, &trait_ref, ParamIsLocal(false))\n+}\n+\n+fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                trait_ref: &ty::TraitRef<'tcx>,\n+                                param_is_local: ParamIsLocal)\n+                                -> Result<(), OrphanCheckErr<'tcx>>\n+{\n+    debug!(\"orphan_check_trait_ref(trait_ref={}, param_is_local={})\",\n+           trait_ref.repr(tcx), param_is_local.0);\n+\n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     let input_tys = Some(trait_ref.self_ty());\n     let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace).iter());\n-    let mut input_tys = input_tys;\n \n     // Find the first input type that either references a type parameter OR\n     // some local type.\n-    match input_tys.find(|&&input_ty| references_local_or_type_parameter(tcx, input_ty)) {\n-        Some(&input_ty) => {\n-            // Within this first type, check that all type parameters are covered by a local\n-            // type constructor. Note that if there is no local type constructor, then any\n-            // type parameter at all will be an error.\n-            let covered_params = type_parameters_covered_by_ty(tcx, input_ty);\n-            let all_params = type_parameters_reachable_from_ty(input_ty);\n-            for &param in all_params.difference(&covered_params) {\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n+    for input_ty in input_tys {\n+        if ty_is_local(tcx, input_ty, param_is_local) {\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n+\n+            // First local input type. Check that there are no\n+            // uncovered type parameters.\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, param_is_local);\n+            for uncovered_ty in uncovered_tys {\n+                if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                    return Err(OrphanCheckErr::UncoveredTy(param));\n+                }\n             }\n+\n+            // OK, found local type, all prior types upheld invariant.\n+            return Ok(());\n         }\n-        None => {\n-            return Err(OrphanCheckErr::NoLocalInputType);\n+\n+        // Otherwise, enforce invariant that there are no type\n+        // parameters reachable.\n+        if !param_is_local.0 {\n+            if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n+                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                return Err(OrphanCheckErr::UncoveredTy(param));\n+            }\n         }\n     }\n \n-    return Ok(());\n+    // If we exit above loop, never found a local type.\n+    debug!(\"orphan_check_trait_ref: no local type\");\n+    return Err(OrphanCheckErr::NoLocalInputType);\n+}\n+\n+fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       param_is_local: ParamIsLocal)\n+                       -> Vec<Ty<'tcx>>\n+{\n+    if ty_is_local_constructor(tcx, ty, param_is_local) {\n+        vec![]\n+    } else if fundamental_ty(tcx, ty) {\n+        ty.walk_shallow()\n+          .flat_map(|t| uncovered_tys(tcx, t, param_is_local).into_iter())\n+          .collect()\n+    } else {\n+        vec![ty]\n+    }\n }\n \n-fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        // FIXME(#20590) straighten story about projection types\n+        ty::ty_projection(..) | ty::ty_param(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, param_is_local: ParamIsLocal) -> bool\n+{\n+    ty_is_local_constructor(tcx, ty, param_is_local) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, param_is_local))\n+}\n+\n+fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n+{\n+    match ty.sty {\n+        ty::ty_uniq(..) | ty::ty_rptr(..) =>\n+            true,\n+        ty::ty_enum(def_id, _) | ty::ty_struct(def_id, _) =>\n+            ty::has_attr(tcx, def_id, \"fundamental\"),\n+        ty::ty_trait(ref data) =>\n+            ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n+        _ =>\n+            false\n+    }\n+}\n+\n+fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 param_is_local: ParamIsLocal)\n+                                 -> bool\n+{\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n     match ty.sty {\n@@ -190,11 +310,15 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_tup(..) |\n-        ty::ty_param(..) |\n+        ty::ty_infer(..) |\n         ty::ty_projection(..) => {\n             false\n         }\n \n+        ty::ty_param(..) => {\n+            param_is_local.0\n+        }\n+\n         ty::ty_enum(def_id, _) |\n         ty::ty_struct(def_id, _) => {\n             def_id.krate == ast::LOCAL_CRATE\n@@ -210,7 +334,6 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_closure(..) |\n-        ty::ty_infer(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n@@ -219,30 +342,4 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                       ty: Ty<'tcx>)\n-                                       -> HashSet<Ty<'tcx>>\n-{\n-    if ty_is_local_constructor(tcx, ty) {\n-        type_parameters_reachable_from_ty(ty)\n-    } else {\n-        ty.walk_children().flat_map(|t| type_parameters_covered_by_ty(tcx, t).into_iter()).collect()\n-    }\n-}\n-\n-/// All type parameters reachable from `ty`\n-fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<Ty<'tcx>> {\n-    ty.walk().filter(|&t| is_type_parameter(t)).collect()\n-}\n-\n-fn references_local_or_type_parameter<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.walk().any(|ty| is_type_parameter(ty) || ty_is_local_constructor(tcx, ty))\n-}\n \n-fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        // FIXME(#20590) straighten story about projection types\n-        ty::ty_projection(..) | ty::ty_param(..) => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "cb9d90744a4464b0a665b7b28a50ce3c6949ecc5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -17,6 +17,7 @@ use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n+use super::coherence;\n use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n@@ -81,7 +82,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n+    previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n #[derive(Clone)]\n@@ -245,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n-        let stack = self.push_stack(None, obligation);\n+        let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n             None => {\n                 self.consider_unification_despite_ambiguity(obligation);\n@@ -327,7 +328,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        self.evaluate_predicate_recursively(None, obligation).may_apply()\n+        self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+            .may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively<'o>(&mut self,\n@@ -346,7 +348,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligation {\n             Ok(obligation) => {\n-                self.evaluate_predicate_recursively(Some(previous_stack), &obligation)\n+                self.evaluate_predicate_recursively(previous_stack.list(), &obligation)\n             }\n             Err(ErrorReported) => {\n                 EvaluatedToOk\n@@ -355,7 +357,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n-                                                stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                                stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult<'tcx>\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n@@ -372,7 +374,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n-                                          previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                          previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n@@ -423,14 +425,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                            obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n \n-        let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n+        let stack = self.push_stack(previous_stack, obligation);\n \n         let result = self.evaluate_stack(&stack);\n \n@@ -538,7 +540,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                        obligation.recursion_depth + 1,\n                                                        skol_map,\n                                                        snapshot);\n-                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                    self.winnow_selection(TraitObligationStackList::empty(),\n+                                          VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n                     false\n@@ -607,6 +610,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(Some(ErrorCandidate));\n         }\n \n+        if !self.is_knowable(stack) {\n+            debug!(\"intercrate not knowable\");\n+            return Ok(None);\n+        }\n+\n         let candidate_set = try!(self.assemble_candidates(stack));\n \n         if candidate_set.ambiguous {\n@@ -707,6 +715,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n+    fn is_knowable<'o>(&mut self,\n+                       stack: &TraitObligationStack<'o, 'tcx>)\n+                       -> bool\n+    {\n+        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+\n+        if !self.intercrate {\n+            return true;\n+        }\n+\n+        let obligation = &stack.obligation;\n+        let predicate = self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        // ok to skip binder because of the nature of the\n+        // trait-ref-is-knowable check, which does not care about\n+        // bound regions\n+        let trait_ref = &predicate.skip_binder().trait_ref;\n+\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+    }\n+\n     fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n@@ -1026,7 +1055,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx().probe(move |_| {\n             match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(Some(stack), obligations.iter())\n+                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => {\n                     EvaluatedToErr(Unimplemented)\n@@ -1310,7 +1339,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => self.winnow_selection(Some(stack), selection),\n+                Ok(selection) => self.winnow_selection(stack.list(),\n+                                                       selection),\n                 Err(error) => EvaluatedToErr(error),\n             }\n         });\n@@ -1320,7 +1350,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn winnow_selection<'o>(&mut self,\n-                            stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                            stack: TraitObligationStackList<'o,'tcx>,\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n@@ -2303,9 +2333,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation.cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation.cause.span,\n+                                                         impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n@@ -2423,9 +2453,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // Create fresh type variables for each type parameter declared\n         // on the impl etc.\n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation_cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation_cause.span,\n+                                                         impl_def_id);\n \n         // Find the self type for the impl.\n         let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n@@ -2476,7 +2506,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Miscellany\n \n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s TraitObligationStack<'s, 'tcx>>,\n+                            previous_stack: TraitObligationStackList<'s, 'tcx>,\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n@@ -2486,7 +2516,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         TraitObligationStack {\n             obligation: obligation,\n             fresh_trait_ref: fresh_trait_ref,\n-            previous: previous_stack.map(|p| p), // FIXME variance\n+            previous: previous_stack,\n         }\n     }\n \n@@ -2639,17 +2669,36 @@ impl<'tcx> SelectionCache<'tcx> {\n     }\n }\n \n-impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n-    fn iter(&self) -> Option<&TraitObligationStack<'o, 'tcx>> {\n-        Some(self)\n+impl<'o,'tcx> TraitObligationStack<'o,'tcx> {\n+    fn list(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList::with(self)\n+    }\n+\n+    fn iter(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        self.list()\n     }\n }\n \n-impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n+#[derive(Copy, Clone)]\n+struct TraitObligationStackList<'o,'tcx:'o> {\n+    head: Option<&'o TraitObligationStack<'o,'tcx>>\n+}\n+\n+impl<'o,'tcx> TraitObligationStackList<'o,'tcx> {\n+    fn empty() -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: None }\n+    }\n+\n+    fn with(r: &'o TraitObligationStack<'o,'tcx>) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: Some(r) }\n+    }\n+}\n+\n+impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     type Item = &'o TraitObligationStack<'o,'tcx>;\n \n-    fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n-        match *self {\n+    fn next(&mut self) -> Option<&'o TraitObligationStack<'o,'tcx>> {\n+        match self.head {\n             Some(o) => {\n                 *self = o.previous;\n                 Some(o)\n@@ -2659,7 +2708,7 @@ impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n     }\n }\n \n-impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n+impl<'o,'tcx> Repr<'tcx> for TraitObligationStack<'o,'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"TraitObligationStack({})\",\n                 self.obligation.repr(tcx))"}, {"sha": "297cea13207e57a99a5f9871db3e36b9e8a752dd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::region;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n@@ -285,7 +286,6 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     }\n }\n \n-\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////\n@@ -294,16 +294,44 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       span: Span,\n-                                       impl_def_id: ast::DefId)\n-                                       -> Substs<'tcx>\n+pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          impl_def_id: ast::DefId)\n+                                          -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n+// determine the `self` type, using fresh variables for all variables\n+// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n+// would return ($0, $1) where $0 and $1 are freshly instantiated type\n+// variables.\n+pub fn free_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      _span: Span,\n+                                      impl_def_id: ast::DefId)\n+                                      -> Substs<'tcx>\n+{\n+    let tcx = infcx.tcx;\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+\n+    let some_types = impl_generics.types.map(|def| {\n+        ty::mk_param_from_def(tcx, def)\n+    });\n+\n+    let some_regions = impl_generics.regions.map(|def| {\n+        // FIXME. This destruction scope information is pretty darn\n+        // bogus; after all, the impl might not even be in this crate!\n+        // But given what we do in coherence, it is harmless enough\n+        // for now I think. -nmatsakis\n+        let extent = region::DestructionScopeData::new(ast::DUMMY_NODE_ID);\n+        ty::free_region_from_def(extent, def)\n+    });\n+\n+    Substs::new(some_types, some_regions)\n+}\n+\n impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)"}, {"sha": "0814ec2c84e7085f62573c1d6b9235ed6a9f9867", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -58,7 +58,7 @@ use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use middle::ty_walk::TypeWalker;\n+use middle::ty_walk::{self, TypeWalker};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n@@ -89,7 +89,8 @@ use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::{ast, ast_map};\n+use syntax::ast;\n+use syntax::ast_map::{self, LinkedPath};\n \n pub type Disr = u64;\n \n@@ -3167,21 +3168,11 @@ impl<'tcx> TyS<'tcx> {\n         TypeWalker::new(self)\n     }\n \n-    /// Iterator that walks types reachable from `self`, in\n-    /// depth-first order. Note that this is a shallow walk. For\n-    /// example:\n-    ///\n-    /// ```notrust\n-    /// isize => { }\n-    /// Foo<Bar<isize>> => { Bar<isize>, isize }\n-    /// [isize] => { isize }\n-    /// ```\n-    pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n-        // Walks type reachable from `self` but not `self\n-        let mut walker = self.walk();\n-        let r = walker.next();\n-        assert_eq!(r, Some(self));\n-        walker\n+    /// Iterator that walks the immediate children of `self`.  Hence\n+    /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n+    /// (but not `i32`, like `walk`).\n+    pub fn walk_shallow(&'tcx self) -> IntoIter<Ty<'tcx>> {\n+        ty_walk::walk_shallow(self)\n     }\n \n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n@@ -5484,7 +5475,7 @@ pub fn with_path<T, F>(cx: &ctxt, id: ast::DefId, f: F) -> T where\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n-        f(csearch::get_item_path(cx, id).iter().cloned().chain(None))\n+        f(csearch::get_item_path(cx, id).iter().cloned().chain(LinkedPath::empty()))\n     }\n }\n "}, {"sha": "ec09d6dcc1ee2c05e35f121c7b4d1e5e7af6f942", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -12,6 +12,7 @@\n \n use middle::ty::{self, Ty};\n use std::iter::Iterator;\n+use std::vec::IntoIter;\n \n pub struct TypeWalker<'tcx> {\n     stack: Vec<Ty<'tcx>>,\n@@ -23,60 +24,6 @@ impl<'tcx> TypeWalker<'tcx> {\n         TypeWalker { stack: vec!(ty), last_subtree: 1, }\n     }\n \n-    fn push_subtypes(&mut self, parent_ty: Ty<'tcx>) {\n-        match parent_ty.sty {\n-            ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-            ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n-            }\n-            ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n-                self.stack.push(ty);\n-            }\n-            ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-                self.stack.push(mt.ty);\n-            }\n-            ty::ty_projection(ref data) => {\n-                self.push_reversed(data.trait_ref.substs.types.as_slice());\n-            }\n-            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                self.push_reversed(principal.substs().types.as_slice());\n-                self.push_reversed(&bounds.projection_bounds.iter().map(|pred| {\n-                    pred.0.ty\n-                }).collect::<Vec<_>>());\n-            }\n-            ty::ty_enum(_, ref substs) |\n-            ty::ty_struct(_, ref substs) |\n-            ty::ty_closure(_, ref substs) => {\n-                self.push_reversed(substs.types.as_slice());\n-            }\n-            ty::ty_tup(ref ts) => {\n-                self.push_reversed(ts);\n-            }\n-            ty::ty_bare_fn(_, ref ft) => {\n-                self.push_sig_subtypes(&ft.sig);\n-            }\n-        }\n-    }\n-\n-    fn push_sig_subtypes(&mut self, sig: &ty::PolyFnSig<'tcx>) {\n-        match sig.0.output {\n-            ty::FnConverging(output) => { self.stack.push(output); }\n-            ty::FnDiverging => { }\n-        }\n-        self.push_reversed(&sig.0.inputs);\n-    }\n-\n-    fn push_reversed(&mut self, tys: &[Ty<'tcx>]) {\n-        // We push slices on the stack in reverse order so as to\n-        // maintain a pre-order traversal. As of the time of this\n-        // writing, the fact that the traversal is pre-order is not\n-        // known to be significant to any code, but it seems like the\n-        // natural order one would expect (basically, the order of the\n-        // types as they are written).\n-        for &ty in tys.iter().rev() {\n-            self.stack.push(ty);\n-        }\n-    }\n-\n     /// Skips the subtree of types corresponding to the last type\n     /// returned by `next()`.\n     ///\n@@ -105,10 +52,70 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();\n-                self.push_subtypes(ty);\n+                push_subtypes(&mut self.stack, ty);\n                 debug!(\"next: stack={:?}\", self.stack);\n                 Some(ty)\n             }\n         }\n     }\n }\n+\n+pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n+    let mut stack = vec![];\n+    push_subtypes(&mut stack, ty);\n+    stack.into_iter()\n+}\n+\n+fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n+    match parent_ty.sty {\n+        ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+        ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n+        }\n+        ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n+            stack.push(ty);\n+        }\n+        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n+            stack.push(mt.ty);\n+        }\n+        ty::ty_projection(ref data) => {\n+            push_reversed(stack, data.trait_ref.substs.types.as_slice());\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+            push_reversed(stack, principal.substs().types.as_slice());\n+            push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n+                pred.0.ty\n+            }).collect::<Vec<_>>());\n+        }\n+        ty::ty_enum(_, ref substs) |\n+        ty::ty_struct(_, ref substs) |\n+        ty::ty_closure(_, ref substs) => {\n+            push_reversed(stack, substs.types.as_slice());\n+        }\n+        ty::ty_tup(ref ts) => {\n+            push_reversed(stack, ts);\n+        }\n+        ty::ty_bare_fn(_, ref ft) => {\n+            push_sig_subtypes(stack, &ft.sig);\n+        }\n+    }\n+}\n+\n+fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n+    match sig.0.output {\n+        ty::FnConverging(output) => { stack.push(output); }\n+        ty::FnDiverging => { }\n+    }\n+    push_reversed(stack, &sig.0.inputs);\n+}\n+\n+fn push_reversed<'tcx>(stack: &mut Vec<Ty<'tcx>>, tys: &[Ty<'tcx>]) {\n+    // We push slices on the stack in reverse order so as to\n+    // maintain a pre-order traversal. As of the time of this\n+    // writing, the fact that the traversal is pre-order is not\n+    // known to be significant to any code, but it seems like the\n+    // natural order one would expect (basically, the order of the\n+    // types as they are written).\n+    for &ty in tys.iter().rev() {\n+        stack.push(ty);\n+    }\n+}"}, {"sha": "4405a9d75ee62afeda9fc7696b57c454be9b50ac", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -384,13 +384,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => {\n-            if cx.sess.verbose() {\n-                param_ty.repr(cx)\n-            } else {\n-                param_ty.user_string(cx)\n-            }\n-        }\n+        ty_param(ref param_ty) => param_ty.user_string(cx),\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             parameterized(cx, &base, substs, did, &[],"}, {"sha": "113827a3b402f2bb4f2353d3895705627037ad61", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d3ba7667ed9599f46b742ac314a43297d76b19/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=03d3ba7667ed9599f46b742ac314a43297d76b19", "patch": "@@ -91,6 +91,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"start\", \"1.0.0\", Active),\n     (\"main\", \"1.0.0\", Active),\n \n+    (\"fundamental\", \"1.0.0\", Active),\n+\n     // Deprecate after snapshot\n     // SNAP 5520801\n     (\"unsafe_destructor\", \"1.0.0\", Active),\n@@ -237,6 +239,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"allow_internal_unstable\", Gated(\"allow_internal_unstable\",\n                                       EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),\n \n+    (\"fundamental\", Gated(\"fundamental\",\n+                          \"the `#[fundamental]` attribute \\\n+                           is an experimental feature\")),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted),\n "}]}