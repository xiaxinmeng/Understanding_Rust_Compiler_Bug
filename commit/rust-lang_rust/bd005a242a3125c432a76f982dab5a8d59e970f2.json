{"sha": "bd005a242a3125c432a76f982dab5a8d59e970f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMDA1YTI0MmEzMTI1YzQzMmE3NmY5ODJkYWI1YThkNTllOTcwZjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-05-01T17:10:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-05-01T21:57:44Z"}, "message": "forego caching for all participants in cycles, apart from root node", "tree": {"sha": "fe7717c629134db1ae8cef373846be2885510d2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7717c629134db1ae8cef373846be2885510d2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd005a242a3125c432a76f982dab5a8d59e970f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd005a242a3125c432a76f982dab5a8d59e970f2", "html_url": "https://github.com/rust-lang/rust/commit/bd005a242a3125c432a76f982dab5a8d59e970f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd005a242a3125c432a76f982dab5a8d59e970f2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "html_url": "https://github.com/rust-lang/rust/commit/47e0803d5c2ad5952220f2c260d7e12921c1d3fe"}], "stats": {"total": 141, "additions": 139, "deletions": 2}, "files": [{"sha": "3c4d48b17b9f322d0130ce912c470b4545f3fa77", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=bd005a242a3125c432a76f982dab5a8d59e970f2", "patch": "@@ -43,6 +43,7 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n+use std::cell::Cell;\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n@@ -153,6 +154,31 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n+    /// Starts out as false -- if, during evaluation, we encounter a\n+    /// cycle, then we will set this flag to true for all participants\n+    /// in the cycle (apart from the \"head\" node). These participants\n+    /// will then forego caching their results. This is not the most\n+    /// efficient solution, but it addresses #60010. The problem we\n+    /// are trying to prevent:\n+    ///\n+    /// - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n+    /// - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n+    /// - `C: NonAutoTrait` requires `A: AutoTrait` (non-coinductive cycle, not ok)\n+    ///\n+    /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n+    /// is `EvaluatedToOk`; this is because they were only considered\n+    /// ok on the premise that if `A: AutoTrait` held, but we indeed\n+    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// currently set a flag on the stack node for `B: AutoTrait` (as\n+    /// well as the second instance of `A: AutoTrait`) to supress\n+    /// caching.\n+    ///\n+    /// This is a simple, targeted fix. The correct fix requires\n+    /// deeper changes, but would permit more caching: we could\n+    /// basically defer caching until we have fully evaluated the\n+    /// tree, and then cache the entire tree at once.\n+    in_cycle: Cell<bool>,\n+\n     previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n@@ -840,8 +866,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n-        debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n-        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        if !stack.in_cycle.get() {\n+            debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        } else {\n+            debug!(\n+                \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n+                 is a cycle participant\",\n+                fresh_trait_ref,\n+            );\n+        }\n \n         Ok(result)\n     }\n@@ -948,6 +982,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n+            // If we have a stack like `A B C D E A`, where the top of\n+            // the stack is the final `A`, then this will iterate over\n+            // `A, E, D, C, B` -- i.e., all the participants apart\n+            // from the cycle head. We mark them as participating in a\n+            // cycle. This suppresses caching for those nodes. See\n+            // `in_cycle` field for more details.\n+            for item in stack.iter().take(rec_index + 1) {\n+                debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n+                item.in_cycle.set(true);\n+            }\n+\n             // Subtle: when checking for a coinductive cycle, we do\n             // not compare using the \"freshened trait refs\" (which\n             // have erased regions) but rather the fully explicit\n@@ -3692,6 +3737,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         TraitObligationStack {\n             obligation,\n             fresh_trait_ref,\n+            in_cycle: Cell::new(false),\n             previous: previous_stack,\n         }\n     }"}, {"sha": "45aa1b3c52239e5ebe5f923c3f381951545fd8b7", "filename": "src/test/ui/traits/cycle-cache-err-60010.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs?ref=bd005a242a3125c432a76f982dab5a8d59e970f2", "patch": "@@ -0,0 +1,71 @@\n+// Test that we properly detect the cycle amongst the traits\n+// here and report an error.\n+\n+use std::panic::RefUnwindSafe;\n+\n+trait Database {\n+    type Storage;\n+}\n+trait HasQueryGroup {}\n+trait Query<DB> {\n+    type Data;\n+}\n+trait SourceDatabase {\n+    fn parse(&self) {\n+        loop {}\n+    }\n+}\n+\n+struct ParseQuery;\n+struct RootDatabase {\n+    _runtime: Runtime<RootDatabase>,\n+}\n+struct Runtime<DB: Database> {\n+    _storage: Box<DB::Storage>,\n+}\n+struct SalsaStorage {\n+    _parse: <ParseQuery as Query<RootDatabase>>::Data, //~ ERROR overflow\n+}\n+\n+impl Database for RootDatabase { //~ ERROR overflow\n+    type Storage = SalsaStorage;\n+}\n+impl HasQueryGroup for RootDatabase {}\n+impl<DB> Query<DB> for ParseQuery\n+where\n+    DB: SourceDatabase,\n+    DB: Database,\n+{\n+    type Data = RootDatabase;\n+}\n+impl<T> SourceDatabase for T\n+where\n+    T: RefUnwindSafe,\n+    T: HasQueryGroup,\n+{\n+}\n+\n+pub(crate) fn goto_implementation(db: &RootDatabase) -> u32 {\n+    // This is not satisfied:\n+    //\n+    // - `RootDatabase: SourceDatabase`\n+    //   - requires `RootDatabase: RefUnwindSafe` + `RootDatabase: HasQueryGroup`\n+    // - `RootDatabase: RefUnwindSafe`\n+    //   - requires `Runtime<RootDatabase>: RefUnwindSafe`\n+    // - `Runtime<RootDatabase>: RefUnwindSafe`\n+    //   - requires `DB::Storage: RefUnwindSafe` (`SalsaStorage: RefUnwindSafe`)\n+    // - `SalsaStorage: RefUnwindSafe`\n+    //    - requires `<ParseQuery as Query<RootDatabase>>::Data: RefUnwindSafe`,\n+    //      which means `ParseQuery: Query<RootDatabase>`\n+    // - `ParseQuery: Query<RootDatabase>`\n+    //    - requires `RootDatabase: SourceDatabase`,\n+    // - `RootDatabase: SourceDatabase` is already on the stack, so we have a\n+    //   cycle with non-coinductive participants\n+    //\n+    // we used to fail to report an error here because we got the\n+    // caching wrong.\n+    SourceDatabase::parse(db);\n+    22\n+}\n+\n+fn main() {}"}, {"sha": "9192f7ba2e3b0af8092cdf72376babfdd9fb5b80", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd005a242a3125c432a76f982dab5a8d59e970f2/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=bd005a242a3125c432a76f982dab5a8d59e970f2", "patch": "@@ -0,0 +1,20 @@\n+error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n+  --> $DIR/cycle-cache-err-60010.rs:27:5\n+   |\n+LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n+\n+error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n+  --> $DIR/cycle-cache-err-60010.rs:30:6\n+   |\n+LL | impl Database for RootDatabase {\n+   |      ^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n+   = note: required because it appears within the type `SalsaStorage`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0275`."}]}