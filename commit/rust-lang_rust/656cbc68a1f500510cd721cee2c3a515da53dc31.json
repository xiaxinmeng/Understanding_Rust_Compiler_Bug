{"sha": "656cbc68a1f500510cd721cee2c3a515da53dc31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NmNiYzY4YTFmNTAwNTEwY2Q3MjFjZWUyYzNhNTE1ZGE1M2RjMzE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-27T02:51:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-27T02:51:54Z"}, "message": "Merge #5033\n\n5033: Order of glob imports should not affect import shadowing r=Nashenas88 a=Nashenas88\n\nFixes #5032\n\nCo-authored-by: Paul Daniel Faria <Nashenas88@users.noreply.github.com>", "tree": {"sha": "92835abecdf6ed44b5b5cef2b20bfb695148ee51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92835abecdf6ed44b5b5cef2b20bfb695148ee51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/656cbc68a1f500510cd721cee2c3a515da53dc31", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9rRLCRBK7hj4Ov3rIwAAdHIIAAtsCEPIvhDW1NHYJl3ZLlqz\nEZzftycw1WRHfJsEHesOzCTsB2OksKvdxMbyaJ8kUp4ezYxXhBzu7fD2s8uT8VJR\nSRQJkn9w3X/zELFI6GY0oIG3cWBqxou44ZSxAtyVlqurC4c2HLYq9r6J63FVjKcO\nJwX/SZYvbku9VIm4dtowdK+8qMwuZvK0q0VVySRycnfw7FD6vDors38msOA739Bg\nUXm+o7+BuSMorvEc1wSUfXkmMHVOgdIhNRGeAHk7/NfftMN5gpVFlRVIRoIQQznc\ncScLhukRc0/fUlBF5hTwW6Zo5WQUkDykbn3ogfGV3/LDXZ3qQY1Zra1otUnMnCw=\n=nEwT\n-----END PGP SIGNATURE-----\n", "payload": "tree 92835abecdf6ed44b5b5cef2b20bfb695148ee51\nparent 9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd\nparent 1f5d30ff1662eb94839bd1cf2e0cb57cc6fac4e4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593226314 +0000\ncommitter GitHub <noreply@github.com> 1593226314 +0000\n\nMerge #5033\n\n5033: Order of glob imports should not affect import shadowing r=Nashenas88 a=Nashenas88\n\nFixes #5032\n\nCo-authored-by: Paul Daniel Faria <Nashenas88@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/656cbc68a1f500510cd721cee2c3a515da53dc31", "html_url": "https://github.com/rust-lang/rust/commit/656cbc68a1f500510cd721cee2c3a515da53dc31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/656cbc68a1f500510cd721cee2c3a515da53dc31/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd", "html_url": "https://github.com/rust-lang/rust/commit/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd"}, {"sha": "1f5d30ff1662eb94839bd1cf2e0cb57cc6fac4e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5d30ff1662eb94839bd1cf2e0cb57cc6fac4e4", "html_url": "https://github.com/rust-lang/rust/commit/1f5d30ff1662eb94839bd1cf2e0cb57cc6fac4e4"}], "stats": {"total": 264, "additions": 244, "deletions": 20}, "files": [{"sha": "4d446c7073b0584889955cdb8bfd8073d0cf7e0f", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=656cbc68a1f500510cd721cee2c3a515da53dc31", "patch": "@@ -4,14 +4,27 @@\n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use ra_db::CrateId;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::mark;\n \n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n-    Lookup, MacroDefId, ModuleDefId, TraitId,\n+    LocalModuleId, Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n \n+#[derive(Copy, Clone)]\n+pub(crate) enum ImportType {\n+    Glob,\n+    Named,\n+}\n+\n+#[derive(Debug, Default)]\n+pub struct PerNsGlobImports {\n+    types: FxHashSet<(LocalModuleId, Name)>,\n+    values: FxHashSet<(LocalModuleId, Name)>,\n+    macros: FxHashSet<(LocalModuleId, Name)>,\n+}\n+\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n     visible: FxHashMap<Name, PerNs>,\n@@ -127,26 +140,72 @@ impl ItemScope {\n         let mut changed = false;\n         let existing = self.visible.entry(name).or_default();\n \n+        if existing.types.is_none() && def.types.is_some() {\n+            existing.types = def.types;\n+            changed = true;\n+        }\n+\n+        if existing.values.is_none() && def.values.is_some() {\n+            existing.values = def.values;\n+            changed = true;\n+        }\n+\n+        if existing.macros.is_none() && def.macros.is_some() {\n+            existing.macros = def.macros;\n+            changed = true;\n+        }\n+\n+        changed\n+    }\n+\n+    pub(crate) fn push_res_with_import(\n+        &mut self,\n+        glob_imports: &mut PerNsGlobImports,\n+        lookup: (LocalModuleId, Name),\n+        def: PerNs,\n+        def_import_type: ImportType,\n+    ) -> bool {\n+        let mut changed = false;\n+        let existing = self.visible.entry(lookup.1.clone()).or_default();\n+\n         macro_rules! check_changed {\n-            ($changed:ident, $existing:expr, $def:expr) => {\n-                match ($existing, $def) {\n+            (\n+                $changed:ident,\n+                ( $existing:ident / $def:ident ) . $field:ident,\n+                $glob_imports:ident [ $lookup:ident ],\n+                $def_import_type:ident\n+            ) => {\n+                match ($existing.$field, $def.$field) {\n                     (None, Some(_)) => {\n-                        $existing = $def;\n+                        match $def_import_type {\n+                            ImportType::Glob => {\n+                                $glob_imports.$field.insert($lookup.clone());\n+                            }\n+                            ImportType::Named => {\n+                                $glob_imports.$field.remove(&$lookup);\n+                            }\n+                        }\n+\n+                        $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n-                    (Some(e), Some(d)) if e.0 != d.0 => {\n+                    (Some(_), Some(_))\n+                        if $glob_imports.$field.contains(&$lookup)\n+                            && matches!($def_import_type, ImportType::Named) =>\n+                    {\n                         mark::hit!(import_shadowed);\n-                        $existing = $def;\n+                        $glob_imports.$field.remove(&$lookup);\n+                        $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n                     _ => {}\n                 }\n             };\n         }\n \n-        check_changed!(changed, existing.types, def.types);\n-        check_changed!(changed, existing.values, def.values);\n-        check_changed!(changed, existing.macros, def.macros);\n+        check_changed!(changed, (existing / def).types, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (existing / def).values, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (existing / def).macros, glob_imports[lookup], def_import_type);\n \n         changed\n     }"}, {"sha": "a35ac1024bf209c1454173c4dc9e15750ae0abc1", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=656cbc68a1f500510cd721cee2c3a515da53dc31", "patch": "@@ -20,6 +20,7 @@ use test_utils::mark;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n         self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind,\n     },\n@@ -80,6 +81,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: CrateDefMap) -> Cr\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n+        from_glob_import: Default::default(),\n     };\n     collector.collect();\n     collector.finish()\n@@ -186,6 +188,7 @@ struct DefCollector<'a> {\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    from_glob_import: PerNsGlobImports,\n }\n \n impl DefCollector<'_> {\n@@ -305,6 +308,7 @@ impl DefCollector<'_> {\n                 self.def_map.root,\n                 &[(name, PerNs::macros(macro_, Visibility::Public))],\n                 Visibility::Public,\n+                ImportType::Named,\n             );\n         }\n     }\n@@ -330,6 +334,7 @@ impl DefCollector<'_> {\n             self.def_map.root,\n             &[(name, PerNs::macros(macro_, Visibility::Public))],\n             Visibility::Public,\n+            ImportType::Named,\n         );\n     }\n \n@@ -383,7 +388,6 @@ impl DefCollector<'_> {\n             let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n             for mut directive in imports {\n                 directive.status = self.resolve_import(directive.module_id, &directive.import);\n-\n                 match directive.status {\n                     PartialResolvedImport::Indeterminate(_) => {\n                         self.record_resolved_import(&directive);\n@@ -477,7 +481,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis);\n+                        self.update(module_id, &items, vis, ImportType::Glob);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -499,7 +503,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis);\n+                        self.update(module_id, &items, vis, ImportType::Glob);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|(mid, _)| *mid == module_id) {\n@@ -529,7 +533,7 @@ impl DefCollector<'_> {\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions, vis);\n+                    self.update(module_id, &resolutions, vis, ImportType::Glob);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -555,15 +559,21 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def)], vis);\n+                    self.update(module_id, &[(name, def)], vis, ImportType::Named);\n                 }\n                 None => mark::hit!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)], vis: Visibility) {\n-        self.update_recursive(module_id, resolutions, vis, 0)\n+    fn update(\n+        &mut self,\n+        module_id: LocalModuleId,\n+        resolutions: &[(Name, PerNs)],\n+        vis: Visibility,\n+        import_type: ImportType,\n+    ) {\n+        self.update_recursive(module_id, resolutions, vis, import_type, 0)\n     }\n \n     fn update_recursive(\n@@ -573,6 +583,7 @@ impl DefCollector<'_> {\n         // All resolutions are imported with this visibility; the visibilies in\n         // the `PerNs` values are ignored and overwritten\n         vis: Visibility,\n+        import_type: ImportType,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -582,7 +593,12 @@ impl DefCollector<'_> {\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res.with_visibility(vis));\n+            changed |= scope.push_res_with_import(\n+                &mut self.from_glob_import,\n+                (module_id, name.clone()),\n+                res.with_visibility(vis),\n+                import_type,\n+            );\n         }\n \n         if !changed {\n@@ -601,7 +617,13 @@ impl DefCollector<'_> {\n             if !vis.is_visible_from_def_map(&self.def_map, glob_importing_module) {\n                 continue;\n             }\n-            self.update_recursive(glob_importing_module, resolutions, glob_import_vis, depth + 1);\n+            self.update_recursive(\n+                glob_importing_module,\n+                resolutions,\n+                glob_import_vis,\n+                ImportType::Glob,\n+                depth + 1,\n+            );\n         }\n     }\n \n@@ -923,6 +945,7 @@ impl ModCollector<'_, '_> {\n                         self.module_id,\n                         &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n+                        ImportType::Named,\n                     )\n                 }\n             }\n@@ -1025,7 +1048,12 @@ impl ModCollector<'_, '_> {\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis, false))], vis);\n+        self.def_collector.update(\n+            self.module_id,\n+            &[(name, PerNs::from_def(def, vis, false))],\n+            vis,\n+            ImportType::Named,\n+        );\n         res\n     }\n \n@@ -1154,6 +1182,7 @@ mod tests {\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),\n+            from_glob_import: Default::default(),\n         };\n         collector.collect();\n         collector.def_map"}, {"sha": "7f3d7509c94cbb55740d8ccb9131862b394e8f6e", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=656cbc68a1f500510cd721cee2c3a515da53dc31", "patch": "@@ -276,3 +276,93 @@ fn glob_shadowed_def() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn glob_shadowed_def_reversed() {\n+    let map = def_map(\n+        r###\"\n+        //- /lib.rs\n+        mod foo;\n+        mod bar;\n+\n+        use bar::baz;\n+        use foo::*;\n+\n+        use baz::Bar;\n+\n+        //- /foo.rs\n+        pub mod baz {\n+            pub struct Foo;\n+        }\n+\n+        //- /bar.rs\n+        pub mod baz {\n+            pub struct Bar;\n+        }\n+        \"###,\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eebar: t\n+        \u22eebaz: t\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::bar\n+        \u22eebaz: t\n+        \u22ee\n+        \u22eecrate::bar::baz\n+        \u22eeBar: t v\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eebaz: t\n+        \u22ee\n+        \u22eecrate::foo::baz\n+        \u22eeFoo: t v\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn glob_shadowed_def_dependencies() {\n+    let map = def_map(\n+        r###\"\n+        //- /lib.rs\n+        mod a { pub mod foo { pub struct X; } }\n+        mod b { pub use super::a::foo; }\n+        mod c { pub mod foo { pub struct Y; } }\n+        mod d {\n+            use super::c::foo;\n+            use super::b::*;\n+            use foo::Y;\n+        }\n+        \"###,\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eea: t\n+        \u22eeb: t\n+        \u22eec: t\n+        \u22eed: t\n+        \u22ee\n+        \u22eecrate::d\n+        \u22eeY: t v\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::c\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::c::foo\n+        \u22eeY: t v\n+        \u22ee\n+        \u22eecrate::b\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::a\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::a::foo\n+        \u22eeX: t v\n+    \"###\n+    );\n+}"}, {"sha": "7d8197f8b0200bd4a2cc4df4841c2d015548945f", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/656cbc68a1f500510cd721cee2c3a515da53dc31/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=656cbc68a1f500510cd721cee2c3a515da53dc31", "patch": "@@ -1739,6 +1739,52 @@ fn main() {\n     assert_eq!(t, \"u32\");\n }\n \n+// This test is actually testing the shadowing behavior within ra_hir_def. It\n+// lives here because the testing infrastructure in ra_hir_def isn't currently\n+// capable of asserting the necessary conditions.\n+#[test]\n+fn should_be_shadowing_imports() {\n+    let t = type_at(\n+        r#\"\n+mod a {\n+    pub fn foo() -> i8 {0}\n+    pub struct foo { a: i8 }\n+}\n+mod b { pub fn foo () -> u8 {0} }\n+mod c { pub struct foo { a: u8 } }\n+mod d {\n+    pub use super::a::*;\n+    pub use super::c::foo;\n+    pub use super::b::foo;\n+}\n+\n+fn main() {\n+    d::foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"u8\");\n+\n+    let t = type_at(\n+        r#\"\n+mod a {\n+    pub fn foo() -> i8 {0}\n+    pub struct foo { a: i8 }\n+}\n+mod b { pub fn foo () -> u8 {0} }\n+mod c { pub struct foo { a: u8 } }\n+mod d {\n+    pub use super::a::*;\n+    pub use super::c::foo;\n+    pub use super::b::foo;\n+}\n+\n+fn main() {\n+    d::foo{a:0<|>};\n+}\"#,\n+    );\n+    assert_eq!(t, \"u8\");\n+}\n+\n #[test]\n fn closure_return() {\n     assert_snapshot!("}]}