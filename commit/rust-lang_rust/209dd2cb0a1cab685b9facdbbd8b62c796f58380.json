{"sha": "209dd2cb0a1cab685b9facdbbd8b62c796f58380", "node_id": "C_kwDOAAsO6NoAKDIwOWRkMmNiMGExY2FiNjg1YjlmYWNkYmJkOGI2MmM3OTZmNTgzODA", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-04-28T14:26:30Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-05T08:53:00Z"}, "message": "generalize \"incoherent impls\" impl for custom types", "tree": {"sha": "dcacc496b0e96a7cf5cfc600378d8f6f1163a093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcacc496b0e96a7cf5cfc600378d8f6f1163a093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/209dd2cb0a1cab685b9facdbbd8b62c796f58380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/209dd2cb0a1cab685b9facdbbd8b62c796f58380", "html_url": "https://github.com/rust-lang/rust/commit/209dd2cb0a1cab685b9facdbbd8b62c796f58380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/209dd2cb0a1cab685b9facdbbd8b62c796f58380/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d3f107c1634ed41a800e220ccf99b665d906d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d3f107c1634ed41a800e220ccf99b665d906d8", "html_url": "https://github.com/rust-lang/rust/commit/12d3f107c1634ed41a800e220ccf99b665d906d8"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "1d0fb31cd5e47f559c100b48ebd35ec2c2baab02", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -644,6 +644,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing,\n         \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n     ),\n+    rustc_attr!(\n+        rustc_has_incoherent_inherent_impls, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        \"#[rustc_has_incoherent_inherent_impls] allows the addition of incoherent inherent impls for \\\n+         the given type by annotating all impl items with #[rustc_allow_incoherent_impl].\"\n+    ),\n     BuiltinAttribute {\n         name: sym::rustc_diagnostic_item,\n         type_: Normal,"}, {"sha": "9e5d781892487b0fccf657ac8c354a8e7836df39", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -327,8 +327,6 @@ language_item_table! {\n     Range,                   sym::Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n     RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n-\n-    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "aa93304319599be41b74266846b0fd19664649e7", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -124,6 +124,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::rustc_allow_incoherent_impl => {\n                     self.check_allow_incoherent_impl(&attr, span, target)\n                 }\n+                sym::rustc_has_incoherent_inherent_impls => {\n+                    self.check_has_incoherent_inherent_impls(&attr, span, target)\n+                }\n                 sym::rustc_const_unstable\n                 | sym::rustc_const_stable\n                 | sym::unstable\n@@ -1095,7 +1098,6 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n-    /// Warns against some misuses of `#[pass_by_value]`\n     fn check_allow_incoherent_impl(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Method(MethodKind::Inherent) => true,\n@@ -1113,6 +1115,30 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    fn check_has_incoherent_inherent_impls(\n+        &self,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Trait | Target::Struct | Target::Enum | Target::Union | Target::ForeignTy => {\n+                true\n+            }\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        \"`rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\",\n+                    )\n+                    .span_label(span, \"only adts, extern types and traits are supported\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     /// Warns against some misuses of `#[must_use]`\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);"}, {"sha": "fab2cf1504ea6232e9fd253f8b34fab53d5950d3", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -1187,6 +1187,7 @@ symbols! {\n         rustc_error,\n         rustc_evaluate_where_clauses,\n         rustc_expected_cgu_reuse,\n+        rustc_has_incoherent_inherent_impls,\n         rustc_if_this_changed,\n         rustc_inherit_overflow_checks,\n         rustc_insignificant_dtor,"}, {"sha": "3a36686613b7c69331c1afa12b6d80c5b7793bd2", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -27,6 +27,7 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::lev_distance::{\n     find_best_match_for_name_with_substrings, lev_distance_with_substrings,\n };\n+use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -642,16 +643,22 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                 self.assemble_inherent_candidates_from_object(generalized_self_ty);\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n+                if self.tcx.has_attr(p.def_id(), sym::rustc_has_incoherent_inherent_impls) {\n+                    self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty);\n+                }\n             }\n             ty::Adt(def, _) => {\n                 let def_id = def.did();\n                 self.assemble_inherent_impl_candidates_for_type(def_id);\n-                if Some(def_id) == self.tcx.lang_items().c_str() {\n+                if self.tcx.has_attr(def_id, sym::rustc_has_incoherent_inherent_impls) {\n                     self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty);\n                 }\n             }\n             ty::Foreign(did) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n+                if self.tcx.has_attr(did, sym::rustc_has_incoherent_inherent_impls) {\n+                    self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty);\n+                }\n             }\n             ty::Param(p) => {\n                 self.assemble_inherent_candidates_from_param(p);"}, {"sha": "359828effa6ca10022ce410691025d47ea198845", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -55,18 +55,13 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n         let self_ty = self.tcx.type_of(item.def_id);\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n-                let def_id = def.did();\n-                if !def_id.is_local() && Some(def_id) == self.tcx.lang_items().c_str() {\n-                    self.check_primitive_impl(item.def_id, self_ty, items, ty.span)\n-                } else {\n-                    self.check_def_id(item, def_id);\n-                }\n+                self.check_def_id(item, self_ty, def.did());\n             }\n             ty::Foreign(did) => {\n-                self.check_def_id(item, did);\n+                self.check_def_id(item, self_ty, did);\n             }\n             ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, data.principal_def_id().unwrap());\n+                self.check_def_id(item, self_ty, data.principal_def_id().unwrap());\n             }\n             ty::Dynamic(..) => {\n                 struct_span_err!(\n@@ -124,14 +119,52 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n     fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n }\n \n+const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n+const INTO_DEFINING_CRATE: &str =\n+    \"consider moving this inherent impl into the crate defining the type if possible\";\n+const ADD_ATTR: &str =\n+    \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n+\n impl<'tcx> InherentCollect<'tcx> {\n-    fn check_def_id(&mut self, item: &hir::Item<'_>, def_id: DefId) {\n+    fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId) {\n+        let impl_def_id = item.def_id;\n         if let Some(def_id) = def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n-            vec.push(item.def_id.to_def_id());\n+            vec.push(impl_def_id.to_def_id());\n+            return;\n+        }\n+\n+        if self.tcx.features().rustc_attrs\n+            && self.tcx.has_attr(def_id, sym::rustc_has_incoherent_inherent_impls)\n+        {\n+            let hir::ItemKind::Impl(hir::Impl { items, .. }) = item.kind else {\n+                bug!(\"expected `impl` item: {:?}\", item);\n+            };\n+\n+            for item in items {\n+                if !self.tcx.has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        item.span,\n+                        E0390,\n+                        \"cannot define inherent `impl` for a type outside of crate where the type is defined\",\n+                    )\n+                    .help(INTO_DEFINING_CRATE)\n+                    .span_help(item.span, ADD_ATTR)\n+                    .emit();\n+                    return;\n+                }\n+            }\n+\n+            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsPlaceholders) {\n+                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n+            } else {\n+                bug!(\"unexpected self type: {:?}\", self_ty);\n+            }\n         } else {\n             struct_span_err!(\n                 self.tcx.sess,\n@@ -153,9 +186,6 @@ impl<'tcx> InherentCollect<'tcx> {\n         items: &[hir::ImplItemRef],\n         span: Span,\n     ) {\n-        const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n-        const ADD_ATTR: &str =\n-            \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n         if !self.tcx.hir().rustc_coherence_is_core() {\n             if self.tcx.features().rustc_attrs {\n                 for item in items {"}, {"sha": "ca335d53c7caa4cab2471906db5b87580b2c69e2", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209dd2cb0a1cab685b9facdbbd8b62c796f58380/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209dd2cb0a1cab685b9facdbbd8b62c796f58380/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=209dd2cb0a1cab685b9facdbbd8b62c796f58380", "patch": "@@ -77,7 +77,7 @@ use crate::str;\n #[derive(Hash)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[unstable(feature = \"core_c_str\", issue = \"94079\")]\n-#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n+#[cfg_attr(not(bootstrap), rustc_has_incoherent_inherent_impls)]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`."}]}