{"sha": "69a0cdf49195d2bc042b44f75e309eb280bcc475", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YTBjZGY0OTE5NWQyYmMwNDJiNDRmNzVlMzA5ZWIyODBiY2M0NzU=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T05:28:52Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:49:54Z"}, "message": "Fix all the test fallout", "tree": {"sha": "0cb4cd8360a223b72c5ce0bc3e3701786a381bd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cb4cd8360a223b72c5ce0bc3e3701786a381bd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a0cdf49195d2bc042b44f75e309eb280bcc475", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a0cdf49195d2bc042b44f75e309eb280bcc475", "html_url": "https://github.com/rust-lang/rust/commit/69a0cdf49195d2bc042b44f75e309eb280bcc475", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a0cdf49195d2bc042b44f75e309eb280bcc475/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092c5078be5b9abfc4e1a80e3ef9d015d321479c", "url": "https://api.github.com/repos/rust-lang/rust/commits/092c5078be5b9abfc4e1a80e3ef9d015d321479c", "html_url": "https://github.com/rust-lang/rust/commit/092c5078be5b9abfc4e1a80e3ef9d015d321479c"}], "stats": {"total": 187, "additions": 100, "deletions": 87}, "files": [{"sha": "fb2b4951ea3d68f62d45b2e86e9c293b45605eb2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -1523,14 +1523,15 @@ fn test_basic() {\n         fn foo() {}\n     ));\n }\n-\n+/* NOTE: When there's a snapshot, update this (yay quasiquoter!)\n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(cx,\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n+*/\n \n #[test]\n fn test_more() {"}, {"sha": "13fe8a150645952334ba3ea1f779919d3ee49417", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -754,14 +754,14 @@ mod test {\n \n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n-            [Ident{name:3,ctxt:4}, Ident{name:78,ctxt:82}]\n+            [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n-            [Ident{name:3,ctxt:104}, Ident{name:78,ctxt:182}]\n+            [Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n         assert!(!segments_name_eq(\n-            [Ident{name:3,ctxt:4}, Ident{name:78,ctxt:82}]\n+            [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n-            [Ident{name:3,ctxt:104}, Ident{name:77,ctxt:182}]\n+            [Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }"}, {"sha": "b7d72ae4debc130342fe3d5dc3e2a8577b4a4d0d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -1150,7 +1150,7 @@ mod test {\n     use super::{pattern_bindings, expand_crate, contains_macro_escape};\n     use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer};\n     use ast;\n-    use ast::{Attribute_, AttrOuter, MetaWord};\n+    use ast::{Attribute_, AttrOuter, MetaWord, Name};\n     use attr;\n     use codemap;\n     use codemap::Spanned;\n@@ -1665,12 +1665,12 @@ foo_module!()\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n         let int_ident = token::str_to_ident(\"int\");\n-        let renames = vec!((x_ident,16));\n+        let renames = vec!((x_ident,Name(16)));\n         let mut renamer = IdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,16,16));\n+        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)));\n     }\n \n     // test the PatIdentRenamer; only PatIdents get renamed\n@@ -1680,13 +1680,13 @@ foo_module!()\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n         let int_ident = token::str_to_ident(\"int\");\n-        let renames = vec!((x_ident,16));\n+        let renames = vec!((x_ident,Name(16)));\n         let mut renamer = PatIdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n         let x_name = x_ident.name;\n-        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,x_name,x_name));\n+        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name));\n     }\n \n "}, {"sha": "2c94db5296750523c48277670ec6a44d6ff5f77c", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -301,8 +301,8 @@ mod tests {\n         assert_eq!(s.clone(), vec!(14));\n     }\n \n-    fn id(n: Name, s: SyntaxContext) -> Ident {\n-        Ident {name: n, ctxt: s}\n+    fn id(n: u32, s: SyntaxContext) -> Ident {\n+        Ident {name: Name(n), ctxt: s}\n     }\n \n     // because of the SCTable, I now need a tidy way of\n@@ -349,12 +349,12 @@ mod tests {\n     fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n-        let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n+        let test_sc = vec!(M(3),R(id(101,0),Name(14)),M(9));\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n             assert!(*table.get(2) == Mark(9,0));\n-            assert!(*table.get(3) == Rename(id(101,0),14,2));\n+            assert!(*table.get(3) == Rename(id(101,0),Name(14),2));\n             assert!(*table.get(4) == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n@@ -381,8 +381,8 @@ mod tests {\n \n     #[test]\n     fn test_marksof () {\n-        let stopname = 242;\n-        let name1 = 243;\n+        let stopname = Name(242);\n+        let name1 = Name(243);\n         let mut t = new_sctable_internal();\n         assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n         // FIXME #5074: ANF'd to dodge nested calls\n@@ -396,16 +396,16 @@ mod tests {\n          assert_eq! (marksof_internal (ans, stopname,&t), vec!(16));}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n-                        R(id(name1,\n+                        R(id(name1.uint() as u32,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n-                          100101102),\n+                          Name(100101102)),\n                         M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n          assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n-                       R(id(name1, name1sc),\n+                       R(id(name1.uint() as u32, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n@@ -419,55 +419,55 @@ mod tests {\n         let mut t = new_sctable_internal();\n         let mut rt = HashMap::new();\n         // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n+        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),Name(a));\n         // - simple ignored marks\n         { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n         // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n+        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),Name(51)),M(12)),EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n         // - rename where names do match, but marks don't\n         { let sc1 = apply_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),\n                                    M(1),\n                                    M(2)),\n                                  EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n+        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(a));}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),M(1),M(2)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),M(1),M(2)),EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50)),sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50))),sc1,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),50),\n-                                    R(id(a,EMPTY_CTXT),51)),\n+        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),Name(50)),\n+                                    R(id(a,EMPTY_CTXT),Name(51))),\n                                   EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(51)); }\n         // the simplest double-rename:\n-        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n+        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),Name(50),EMPTY_CTXT,&mut t);\n+         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),Name(51),a_to_a50,&mut t);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),Name(51));\n          // mark on the outside doesn't stop rename:\n          let sc = apply_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(51));\n          // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n+         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),Name(51)),\n                                               M(9)),\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),Name(50));}\n     }\n \n     #[test]\n     fn mtwt_resolve_test(){\n         let a = 40;\n-        assert_eq!(resolve(id(a,EMPTY_CTXT)),a);\n+        assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n     }\n \n \n@@ -496,10 +496,10 @@ mod tests {\n \n     #[test]\n     fn new_resolves_test() {\n-        let renames = vec!((Ident{name:23,ctxt:EMPTY_CTXT},24),\n-                           (Ident{name:29,ctxt:EMPTY_CTXT},29));\n+        let renames = vec!((Ident{name:Name(23),ctxt:EMPTY_CTXT},Name(24)),\n+                           (Ident{name:Name(29),ctxt:EMPTY_CTXT},Name(29)));\n         let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n-        assert_eq!(resolve(Ident{name:23,ctxt:new_ctxt1}),24);\n-        assert_eq!(resolve(Ident{name:29,ctxt:new_ctxt1}),29);\n+        assert_eq!(resolve(Ident{name:Name(23),ctxt:new_ctxt1}),Name(24));\n+        assert_eq!(resolve(Ident{name:Name(29),ctxt:new_ctxt1}),Name(29));\n     }\n }"}, {"sha": "0aaddacfab624783179153e274e848263b6ac381", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -1326,11 +1326,14 @@ mod test {\n             \"/* my source file */ \\\n              fn main() { println!(\\\"zebra\\\"); }\\n\".to_string());\n         let id = str_to_ident(\"fn\");\n+        assert_eq!(string_reader.next_token().tok, token::COMMENT);\n+        assert_eq!(string_reader.next_token().tok, token::WS);\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n             sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         assert_eq!(tok1,tok2);\n+        assert_eq!(string_reader.next_token().tok, token::WS);\n         // the 'main' id is already read:\n         assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n         // read another token:\n@@ -1359,6 +1362,7 @@ mod test {\n     #[test] fn doublecolonparsing () {\n         check_tokenization(setup(&mk_sh(), \"a b\".to_string()),\n                            vec!(mk_ident(\"a\",false),\n+                            token::WS,\n                              mk_ident(\"b\",false)));\n     }\n \n@@ -1372,6 +1376,7 @@ mod test {\n     #[test] fn dcparsing_3 () {\n         check_tokenization(setup(&mk_sh(), \"a ::b\".to_string()),\n                            vec!(mk_ident(\"a\",false),\n+                             token::WS,\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n@@ -1380,22 +1385,23 @@ mod test {\n         check_tokenization(setup(&mk_sh(), \"a:: b\".to_string()),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n+                             token::WS,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {\n         assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n-                   token::LIT_CHAR('a'));\n+                   token::LIT_CHAR(token::intern(\"a\")));\n     }\n \n     #[test] fn character_space() {\n         assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n-                   token::LIT_CHAR(' '));\n+                   token::LIT_CHAR(token::intern(\" \")));\n     }\n \n     #[test] fn character_escaped() {\n         assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n-                   token::LIT_CHAR('\\n'));\n+                   token::LIT_CHAR(token::intern(\"\\\\n\")));\n     }\n \n     #[test] fn lifetime_name() {\n@@ -1407,7 +1413,7 @@ mod test {\n         assert_eq!(setup(&mk_sh(),\n                          \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n-                   token::LIT_STR_RAW(token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n+                   token::LIT_STR_RAW(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n     }\n \n     #[test] fn line_doc_comments() {\n@@ -1417,9 +1423,13 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        assert_eq!(setup(&mk_sh(),\n-                         \"/* /* */ */'a'\".to_string()).next_token().tok,\n-                   token::LIT_CHAR('a'));\n+        let sh = mk_sh();\n+        let mut lexer = setup(&sh, \"/* /* */ */'a'\".to_string());\n+        match lexer.next_token().tok {\n+            token::COMMENT => { },\n+            _ => fail!(\"expected a comment!\")\n+        }\n+        assert_eq!(lexer.next_token().tok, token::LIT_CHAR(token::intern(\"a\")));\n     }\n \n }"}, {"sha": "5839df6702245d0a8a89e241b45a435262ae5b07", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -757,8 +757,8 @@ mod test {\n     use ast;\n     use ext::mtwt;\n \n-    fn mark_ident(id : Ident, m : ast::Mrk) -> Ident {\n-        Ident{name:id.name,ctxt:mtwt::apply_mark(m,id.ctxt)}\n+    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n+        ast::Ident { name: id.name, ctxt:mtwt::apply_mark(m, id.ctxt) }\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}, {"sha": "452b5a5251222ca1a22b1c092c0c52848094e0f9", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0cdf49195d2bc042b44f75e309eb280bcc475/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=69a0cdf49195d2bc042b44f75e309eb280bcc475", "patch": "@@ -222,36 +222,38 @@ impl StrInterner {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use ast::Name;\n+\n     #[test]\n     #[should_fail]\n     fn i1 () {\n         let i : Interner<RcStr> = Interner::new();\n-        i.get(13);\n+        i.get(Name(13));\n     }\n \n     #[test]\n     fn interner_tests () {\n         let i : Interner<RcStr> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n         // different string gets a different #:\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n         // dog is still at zero\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n         // gensym gets 3\n-        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), 2);\n+        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), Name(2));\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), 3);\n+        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), Name(3));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(RcStr::new(\"dog\")), 4);\n-        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n+        assert_eq!(i.gensym(RcStr::new(\"dog\")), Name(4));\n+        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n     }\n \n     #[test]\n@@ -261,39 +263,39 @@ mod tests {\n             RcStr::new(\"Bob\"),\n             RcStr::new(\"Carol\")\n         ]);\n-        assert_eq!(i.get(0), RcStr::new(\"Alan\"));\n-        assert_eq!(i.get(1), RcStr::new(\"Bob\"));\n-        assert_eq!(i.get(2), RcStr::new(\"Carol\"));\n-        assert_eq!(i.intern(RcStr::new(\"Bob\")), 1);\n+        assert_eq!(i.get(Name(0)), RcStr::new(\"Alan\"));\n+        assert_eq!(i.get(Name(1)), RcStr::new(\"Bob\"));\n+        assert_eq!(i.get(Name(2)), RcStr::new(\"Carol\"));\n+        assert_eq!(i.intern(RcStr::new(\"Bob\")), Name(1));\n     }\n \n     #[test]\n     fn string_interner_tests() {\n         let i : StrInterner = StrInterner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), 0);\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), 0);\n+        assert_eq!(i.intern (\"dog\"), Name(0));\n         // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), 1);\n-        assert_eq!(i.intern(\"cat\"), 1);\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n         // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), 0);\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n         // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), 2);\n+        assert_eq!(i.gensym(\"zebra\"), Name(2));\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), 3);\n+        assert_eq!(i.gensym(\"zebra\"), Name(3));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), 4);\n+        assert_eq!(i.gensym(\"dog\"), Name(4));\n         // gensym tests again with gensym_copy:\n-        assert_eq!(i.gensym_copy(2), 5);\n-        assert_eq!(i.get(5), RcStr::new(\"zebra\"));\n-        assert_eq!(i.gensym_copy(2), 6);\n-        assert_eq!(i.get(6), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n+        assert_eq!(i.gensym_copy(Name(2)), Name(5));\n+        assert_eq!(i.get(Name(5)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.gensym_copy(Name(2)), Name(6));\n+        assert_eq!(i.get(Name(6)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n     }\n }"}]}