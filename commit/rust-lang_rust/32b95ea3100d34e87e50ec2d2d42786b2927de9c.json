{"sha": "32b95ea3100d34e87e50ec2d2d42786b2927de9c", "node_id": "C_kwDOAAsO6NoAKDMyYjk1ZWEzMTAwZDM0ZTg3ZTUwZWMyZDJkNDI3ODZiMjkyN2RlOWM", "commit": {"author": {"name": "vi_mi", "email": "fenil.jain2018@vitstudent.ac.in", "date": "2021-08-16T08:15:10Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-10-16T10:36:06Z"}, "message": "feat: Adding extract_module assist", "tree": {"sha": "c090bc06d183c7a61dc317fdf9c4aba5b844b8c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c090bc06d183c7a61dc317fdf9c4aba5b844b8c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32b95ea3100d34e87e50ec2d2d42786b2927de9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32b95ea3100d34e87e50ec2d2d42786b2927de9c", "html_url": "https://github.com/rust-lang/rust/commit/32b95ea3100d34e87e50ec2d2d42786b2927de9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32b95ea3100d34e87e50ec2d2d42786b2927de9c/comments", "author": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c7526d308a8a9c04318c19c5df626723f69ec23", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7526d308a8a9c04318c19c5df626723f69ec23", "html_url": "https://github.com/rust-lang/rust/commit/6c7526d308a8a9c04318c19c5df626723f69ec23"}], "stats": {"total": 1448, "additions": 1447, "deletions": 1}, "files": [{"sha": "79c5354f848a61a6a74f24a7514c69a658195f96", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "added", "additions": 1409, "deletions": 0, "changes": 1409, "blob_url": "https://github.com/rust-lang/rust/blob/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=32b95ea3100d34e87e50ec2d2d42786b2927de9c", "patch": "@@ -0,0 +1,1409 @@\n+use std::collections::{HashMap, HashSet};\n+\n+use hir::{HasSource, ModuleDef, ModuleSource};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    base_db::FileId,\n+    defs::{Definition, NameClass, NameRefClass},\n+    search::{FileReference, SearchScope},\n+};\n+use stdx::format_to;\n+use syntax::{\n+    algo::find_node_at_range,\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, HasName, HasVisibility,\n+    },\n+    match_ast, ted, AstNode, SourceFile, SyntaxNode, TextRange,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+use super::remove_unused_param::range_to_remove;\n+\n+// Assist: extract_module\n+//\n+// Extracts a selected region as seperate module. All the references, visibility and imports are\n+// resolved.\n+//\n+// ```\n+// $0\n+// fn foo(name: i32) -> i32 {\n+//     name + 1\n+// }\n+// $0\n+//\n+// fn bar(name: i32) -> i32 {\n+//     name + 2\n+// }\n+// ```\n+// ->\n+// ```\n+// mod modname {\n+//     pub(crate) fn foo(name: i32) -> i32 {\n+//         name + 1\n+//     }\n+// }\n+//\n+// fn bar(name: i32) -> i32 {\n+//     name + 2\n+// }\n+// ```\n+pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    if ctx.frange.range.is_empty() {\n+        return None;\n+    }\n+\n+    let node = ctx.covering_element();\n+    let node = match node {\n+        syntax::NodeOrToken::Node(n) => n,\n+        syntax::NodeOrToken::Token(t) => t.parent()?,\n+    };\n+\n+    let mut curr_parent_module: Option<ast::Module> = None;\n+    if let Some(mod_syn_opt) = node.ancestors().find(|it| ast::Module::can_cast(it.kind())) {\n+        curr_parent_module = ast::Module::cast(mod_syn_opt);\n+    }\n+\n+    let mut module = extract_target(&node, ctx.frange.range)?;\n+    if module.body_items.len() == 0 {\n+        return None;\n+    }\n+\n+    let old_item_indent = module.body_items[0].indent_level();\n+\n+    acc.add(\n+        AssistId(\"extract_module\", AssistKind::RefactorExtract),\n+        \"Extract Module\",\n+        module.text_range,\n+        |builder| {\n+            //This takes place in three steps:\n+            //\n+            //- Firstly, we will update the references(usages) e.g. converting a\n+            //  function call bar() to modname::bar(), and similarly for other items\n+            //\n+            //- Secondly, changing the visibility of each item inside the newly selected module\n+            //  i.e. making a fn a() {} to pub(crate) fn a() {}\n+            //\n+            //- Thirdly, resolving all the imports this includes removing paths from imports\n+            //  outside the module, shifting/cloning them inside new module, or shifting the imports, or making\n+            //  new import statemnts\n+\n+            //We are getting item usages and record_fields together, record_fields\n+            //for change_visibility and usages for first point mentioned above in the process\n+            let (usages_to_be_processed, record_fields) = module.get_usages_and_record_fields(ctx);\n+\n+            let import_paths_to_be_removed = module.resolve_imports(curr_parent_module, &ctx);\n+\n+            if let Some(block_items) = module.change_visibility(record_fields) {\n+                module.body_items = block_items;\n+                if module.body_items.len() == 0 {\n+                    return;\n+                }\n+\n+                let mut body_items = Vec::new();\n+                let new_item_indent = old_item_indent + 1;\n+                for item in module.body_items {\n+                    let item = item.indent(IndentLevel(1));\n+                    let mut indented_item = String::new();\n+                    format_to!(indented_item, \"{}{}\", new_item_indent, item.to_string());\n+                    body_items.push(indented_item);\n+                }\n+\n+                let body = body_items.join(\"\\n\\n\");\n+\n+                let mut module_def = String::new();\n+\n+                format_to!(module_def, \"mod {} {{\\n{}\\n{}}}\", module.name, body, old_item_indent);\n+\n+                for usages_to_be_updated_for_file in usages_to_be_processed {\n+                    builder.edit_file(usages_to_be_updated_for_file.0);\n+                    for usage_to_be_processed in usages_to_be_updated_for_file.1 {\n+                        builder.replace(usage_to_be_processed.0, usage_to_be_processed.1)\n+                    }\n+                }\n+\n+                builder.edit_file(ctx.frange.file_id);\n+                for import_path_text_range in import_paths_to_be_removed {\n+                    builder.delete(import_path_text_range);\n+                }\n+                builder.replace(module.text_range, module_def)\n+            }\n+        },\n+    )\n+}\n+\n+#[derive(Debug)]\n+struct Module {\n+    text_range: TextRange,\n+    name: String,\n+    body_items: Vec<ast::Item>,\n+}\n+\n+fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n+    let body_items: Vec<ast::Item> = node\n+        .children()\n+        .filter_map(|child| {\n+            if let Some(item) = ast::Item::cast(child.clone()) {\n+                if selection_range.contains_range(item.syntax().text_range()) {\n+                    return Some(item);\n+                }\n+                return None;\n+            }\n+            None\n+        })\n+        .collect();\n+\n+    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items })\n+}\n+\n+impl Module {\n+    fn get_usages_and_record_fields(\n+        &self,\n+        ctx: &AssistContext,\n+    ) -> (HashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>) {\n+        let mut record_fields = Vec::new();\n+        let mut refs: HashMap<FileId, Vec<(TextRange, String)>> = HashMap::new();\n+\n+        //Here impl is not included as each item inside impl will be tied to the parent of\n+        //implementing block(a struct, enum, etc), if the parent is in selected module, it will\n+        //get updated by ADT section given below or if it is not, then we dont need to do any operation\n+        self.body_items.clone().into_iter().for_each(|item| {\n+            match_ast! {\n+                match (item.syntax()) {\n+                    ast::Adt(it) => {\n+                        if let Some( nod ) = ctx.sema.to_def(&it) {\n+                            let node_def = Definition::ModuleDef(nod.into());\n+                            self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n+\n+                            let mut get_record_fields = |it: ast::Adt| {\n+                                for desc in it.syntax().descendants() {\n+                                    if let Some(record_field) = ast::RecordField::cast(desc) {\n+                                        record_fields.push(record_field.syntax().clone());\n+                                    }\n+                                }\n+                            };\n+\n+                            //Enum Fields are not allowed to explicitly specify pub, it is implied\n+                            match it {\n+                                ast::Adt::Struct(_) => get_record_fields(it),\n+                                ast::Adt::Union(_) => get_record_fields(it),\n+                                ast::Adt::Enum(_) => {},\n+                            }\n+                        }\n+                    },\n+                    ast::TypeAlias(it) => {\n+                        if let Some( nod ) = ctx.sema.to_def(&it) {\n+                            let node_def = Definition::ModuleDef(nod.into());\n+                            self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n+                        }\n+                    },\n+                    ast::Const(it) => {\n+                        if let Some( nod ) = ctx.sema.to_def(&it) {\n+                            let node_def = Definition::ModuleDef(nod.into());\n+                            self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n+                        }\n+                    },\n+                    ast::Static(it) => {\n+                        if let Some( nod ) = ctx.sema.to_def(&it) {\n+                            let node_def = Definition::ModuleDef(nod.into());\n+                            self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n+                        }\n+                    },\n+                    ast::Fn(it) => {\n+                        if let Some( nod ) = ctx.sema.to_def(&it) {\n+                            let node_def = Definition::ModuleDef(nod.into());\n+                            self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        });\n+\n+        return (refs, record_fields);\n+    }\n+\n+    fn expand_and_group_usages_file_wise(\n+        &self,\n+        ctx: &AssistContext,\n+        node_def: Definition,\n+        refs: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n+    ) {\n+        for (file_id, references) in node_def.usages(&ctx.sema).all() {\n+            if let Some(file_refs) = refs.get_mut(&file_id) {\n+                let mut usages = self.expand_ref_to_usages(references, ctx, file_id);\n+                file_refs.append(&mut usages);\n+            } else {\n+                refs.insert(file_id, self.expand_ref_to_usages(references, ctx, file_id));\n+            }\n+        }\n+    }\n+\n+    fn expand_ref_to_usages(\n+        &self,\n+        refs: Vec<FileReference>,\n+        ctx: &AssistContext,\n+        file_id: FileId,\n+    ) -> Vec<(TextRange, String)> {\n+        let source_file = ctx.sema.parse(file_id);\n+\n+        let mut usages_to_be_processed_for_file = Vec::new();\n+        for usage in refs {\n+            if let Some(x) = self.get_usage_to_be_processed(&source_file, usage) {\n+                usages_to_be_processed_for_file.push(x);\n+            }\n+        }\n+\n+        usages_to_be_processed_for_file\n+    }\n+\n+    fn get_usage_to_be_processed(\n+        &self,\n+        source_file: &SourceFile,\n+        FileReference { range, name, .. }: FileReference,\n+    ) -> Option<(TextRange, String)> {\n+        let path: Option<ast::Path> = find_node_at_range(source_file.syntax(), range);\n+\n+        let path = path?;\n+\n+        for desc in path.syntax().descendants() {\n+            if desc.to_string() == name.syntax().to_string()\n+                && !self.text_range.contains_range(desc.text_range())\n+            {\n+                if let Some(name_ref) = ast::NameRef::cast(desc) {\n+                    return Some((\n+                        name_ref.syntax().text_range(),\n+                        format!(\"{}::{}\", self.name, name_ref.to_string()),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn change_visibility(&self, record_fields: Vec<SyntaxNode>) -> Option<Vec<ast::Item>> {\n+        let (body_items, mut replacements, record_field_parents, impls) =\n+            get_replacements_for_visibilty_change(self.body_items.clone(), false);\n+\n+        let impl_items = impls.into_iter().fold(Vec::new(), |mut impl_items, x| {\n+            let this_impl_items =\n+                x.syntax().descendants().fold(Vec::new(), |mut this_impl_items, x| {\n+                    if let Some(item) = ast::Item::cast(x.clone()) {\n+                        this_impl_items.push(item);\n+                    }\n+                    return this_impl_items;\n+                });\n+\n+            impl_items.append(&mut this_impl_items.clone());\n+            return impl_items;\n+        });\n+\n+        let (_, mut impl_item_replacements, _, _) =\n+            get_replacements_for_visibilty_change(impl_items.clone(), true);\n+\n+        replacements.append(&mut impl_item_replacements);\n+\n+        record_field_parents.into_iter().for_each(|x| {\n+            x.1.descendants().filter_map(|x| ast::RecordField::cast(x)).for_each(|desc| {\n+                let is_record_field_present = record_fields\n+                    .clone()\n+                    .into_iter()\n+                    .find(|x| x.to_string() == desc.to_string())\n+                    .is_some();\n+                if is_record_field_present {\n+                    replacements.push((desc.visibility().clone(), desc.syntax().clone()));\n+                }\n+            });\n+        });\n+\n+        replacements.into_iter().for_each(|(vis, syntax)| {\n+            add_change_vis(vis, syntax.first_child_or_token());\n+        });\n+\n+        Some(body_items)\n+    }\n+\n+    fn resolve_imports(\n+        &mut self,\n+        curr_parent_module: Option<ast::Module>,\n+        ctx: &AssistContext,\n+    ) -> Vec<TextRange> {\n+        let mut import_paths_to_be_removed: Vec<TextRange> = vec![];\n+        let mut node_set: HashSet<String> = HashSet::new();\n+\n+        self.body_items.clone().into_iter().for_each(|item| {\n+            item.syntax().descendants().for_each(|x| {\n+                if let Some(name) = ast::Name::cast(x.clone()) {\n+                    if let Some(name_classify) = NameClass::classify(&ctx.sema, &name) {\n+                        //Necessary to avoid two same names going through\n+                        if !node_set.contains(&name.syntax().to_string()) {\n+                            node_set.insert(name.syntax().to_string());\n+                            let def_opt: Option<Definition> = match name_classify {\n+                                NameClass::Definition(def) => Some(def),\n+                                _ => None,\n+                            };\n+\n+                            if let Some(def) = def_opt {\n+                                if let Some(import_path) = self\n+                                    .process_names_and_namerefs_for_import_resolve(\n+                                        def,\n+                                        name.syntax(),\n+                                        &curr_parent_module,\n+                                        ctx,\n+                                    )\n+                                {\n+                                    import_paths_to_be_removed.push(import_path);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if let Some(name_ref) = ast::NameRef::cast(x) {\n+                    if let Some(name_classify) = NameRefClass::classify(&ctx.sema, &name_ref) {\n+                        //Necessary to avoid two same names going through\n+                        if !node_set.contains(&name_ref.syntax().to_string()) {\n+                            node_set.insert(name_ref.syntax().to_string());\n+                            let def_opt: Option<Definition> = match name_classify {\n+                                NameRefClass::Definition(def) => Some(def),\n+                                _ => None,\n+                            };\n+\n+                            if let Some(def) = def_opt {\n+                                if let Some(import_path) = self\n+                                    .process_names_and_namerefs_for_import_resolve(\n+                                        def,\n+                                        name_ref.syntax(),\n+                                        &curr_parent_module,\n+                                        ctx,\n+                                    )\n+                                {\n+                                    import_paths_to_be_removed.push(import_path);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+        });\n+\n+        import_paths_to_be_removed\n+    }\n+\n+    fn process_names_and_namerefs_for_import_resolve(\n+        &mut self,\n+        def: Definition,\n+        node_syntax: &SyntaxNode,\n+        curr_parent_module: &Option<ast::Module>,\n+        ctx: &AssistContext,\n+    ) -> Option<TextRange> {\n+        //We only need to find in the current file\n+        let selection_range = ctx.frange.range;\n+        let search_scope = SearchScope::single_file(ctx.frange.file_id);\n+        let usage_res = def.usages(&ctx.sema).in_scope(search_scope).all();\n+        let curr_file_id = ctx.frange.file_id;\n+        let file = ctx.sema.parse(ctx.frange.file_id);\n+\n+        let mut exists_inside_sel = false;\n+        let mut exists_outside_sel = false;\n+        usage_res.clone().into_iter().for_each(|x| {\n+            let mut non_use_nodes_itr = (&x.1).into_iter().filter_map(|x| {\n+                if find_node_at_range::<ast::Use>(file.syntax(), x.range).is_none() {\n+                    let path_opt = find_node_at_range::<ast::Path>(file.syntax(), x.range);\n+                    return path_opt;\n+                }\n+\n+                None\n+            });\n+\n+            if non_use_nodes_itr\n+                .clone()\n+                .find(|x| !selection_range.contains_range(x.syntax().text_range()))\n+                .is_some()\n+            {\n+                exists_outside_sel = true;\n+            }\n+            if non_use_nodes_itr\n+                .find(|x| selection_range.contains_range(x.syntax().text_range()))\n+                .is_some()\n+            {\n+                exists_inside_sel = true;\n+            }\n+        });\n+\n+        let source_exists_outside_sel_in_same_mod = does_source_exists_outside_sel_in_same_mod(\n+            def,\n+            ctx,\n+            curr_parent_module,\n+            selection_range,\n+            curr_file_id,\n+        );\n+\n+        let use_stmt_opt: Option<ast::Use> = usage_res.into_iter().find_map(|x| {\n+            let file_id = x.0;\n+            let mut use_opt: Option<ast::Use> = None;\n+            if file_id == ctx.frange.file_id {\n+                (&x.1).into_iter().for_each(|x| {\n+                    let node_opt: Option<ast::Use> = find_node_at_range(file.syntax(), x.range);\n+                    if let Some(node) = node_opt {\n+                        use_opt = Some(node.clone());\n+                    }\n+                });\n+            }\n+            return use_opt;\n+        });\n+\n+        let mut use_tree_str_opt: Option<Vec<ast::Path>> = None;\n+        //Exists inside and outside selection\n+        // - Use stmt for item is present -> get the use_tree_str and reconstruct the path in new\n+        // module\n+        // - Use stmt for item is not present ->\n+        //If it is not found, the definition is either ported inside new module or it stays\n+        //outside:\n+        //- Def is inside: Nothing to import\n+        //- Def is outside: Import it inside with super\n+\n+        //Exists inside selection but not outside -> Check for the import of it in original module,\n+        //get the use_tree_str, reconstruct the use stmt in new module\n+\n+        let mut import_path_to_be_removed: Option<TextRange> = None;\n+        if exists_inside_sel && exists_outside_sel {\n+            //Changes to be made only inside new module\n+\n+            //If use_stmt exists, find the use_tree_str, reconstruct it inside new module\n+            //If not, insert a use stmt with super and the given nameref\n+            if let Some((use_tree_str, _)) =\n+                self.process_use_stmt_for_import_resolve(use_stmt_opt, node_syntax)\n+            {\n+                use_tree_str_opt = Some(use_tree_str);\n+            } else if source_exists_outside_sel_in_same_mod {\n+                //Considered only after use_stmt is not present\n+                //source_exists_outside_sel_in_same_mod | exists_outside_sel(exists_inside_sel =\n+                //true for all cases)\n+                // false | false -> Do nothing\n+                // false | true -> If source is in selection -> nothing to do, If source is outside\n+                // mod -> ust_stmt transversal\n+                // true  | false -> super import insertion\n+                // true  | true -> super import insertion\n+                self.make_use_stmt_of_node_with_super(node_syntax);\n+            }\n+        } else if exists_inside_sel && !exists_outside_sel {\n+            //Changes to be made inside new module, and remove import from outside\n+\n+            if let Some((use_tree_str, text_range_opt)) =\n+                self.process_use_stmt_for_import_resolve(use_stmt_opt, node_syntax)\n+            {\n+                if let Some(text_range) = text_range_opt {\n+                    import_path_to_be_removed = Some(text_range);\n+                }\n+                use_tree_str_opt = Some(use_tree_str);\n+            } else if source_exists_outside_sel_in_same_mod {\n+                self.make_use_stmt_of_node_with_super(node_syntax);\n+            }\n+        }\n+\n+        if let Some(use_tree_str) = use_tree_str_opt {\n+            let mut use_tree_str = use_tree_str.clone();\n+            use_tree_str.reverse();\n+            if use_tree_str[0].to_string().contains(\"super\") {\n+                let super_path = make::ext::ident_path(\"super\");\n+                use_tree_str.insert(0, super_path)\n+            }\n+\n+            let use_ =\n+                make::use_(None, make::use_tree(make::join_paths(use_tree_str), None, None, false));\n+            if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n+                self.body_items.insert(0, item);\n+            }\n+        }\n+\n+        import_path_to_be_removed\n+    }\n+\n+    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) {\n+        let super_path = make::ext::ident_path(\"super\");\n+        let node_path = make::ext::ident_path(&node_syntax.to_string());\n+        let use_ = make::use_(\n+            None,\n+            make::use_tree(make::join_paths(vec![super_path, node_path]), None, None, false),\n+        );\n+        if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n+            self.body_items.insert(0, item);\n+        }\n+    }\n+\n+    fn process_use_stmt_for_import_resolve(\n+        &self,\n+        use_stmt_opt: Option<ast::Use>,\n+        node_syntax: &SyntaxNode,\n+    ) -> Option<(Vec<ast::Path>, Option<TextRange>)> {\n+        if let Some(use_stmt) = use_stmt_opt {\n+            for desc in use_stmt.syntax().descendants() {\n+                if let Some(path_seg) = ast::PathSegment::cast(desc) {\n+                    if path_seg.syntax().to_string() == node_syntax.to_string() {\n+                        let mut use_tree_str = vec![path_seg.parent_path()];\n+                        get_use_tree_paths_from_path(path_seg.parent_path(), &mut use_tree_str);\n+                        for ancs in path_seg.syntax().ancestors() {\n+                            //Here we are looking for use_tree with same string value as node\n+                            //passed above as the range_to_remove function looks for a comma and\n+                            //then includes it in the text range to remove it. But the comma only\n+                            //appears at the use_tree level\n+                            if let Some(use_tree) = ast::UseTree::cast(ancs) {\n+                                if use_tree.syntax().to_string() == node_syntax.to_string() {\n+                                    return Some((\n+                                        use_tree_str,\n+                                        Some(range_to_remove(use_tree.syntax())),\n+                                    ));\n+                                }\n+                            }\n+                        }\n+\n+                        return Some((use_tree_str, None));\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+fn does_source_exists_outside_sel_in_same_mod(\n+    def: Definition,\n+    ctx: &AssistContext,\n+    curr_parent_module: &Option<ast::Module>,\n+    selection_range: TextRange,\n+    curr_file_id: FileId,\n+) -> bool {\n+    let mut source_exists_outside_sel_in_same_mod = false;\n+    match def {\n+        Definition::ModuleDef(it) => match it {\n+            ModuleDef::Module(x) => {\n+                let source = x.definition_source(ctx.db());\n+                let have_same_parent;\n+                if let Some(ast_module) = &curr_parent_module {\n+                    if let Some(hir_module) = x.parent(ctx.db()) {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, hir_module, ctx).is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+                } else {\n+                    let source_file_id = source.file_id.original_file(ctx.db());\n+                    have_same_parent = source_file_id == curr_file_id;\n+                }\n+\n+                if have_same_parent {\n+                    match source.value {\n+                        ModuleSource::Module(module_) => {\n+                            source_exists_outside_sel_in_same_mod =\n+                                !selection_range.contains_range(module_.syntax().text_range());\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            ModuleDef::Function(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::Adt(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::Variant(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::Const(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::Static(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::Trait(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            ModuleDef::TypeAlias(x) => {\n+                if let Some(source) = x.source(ctx.db()) {\n+                    let have_same_parent;\n+                    if let Some(ast_module) = &curr_parent_module {\n+                        have_same_parent =\n+                            compare_hir_and_ast_module(&ast_module, x.module(ctx.db()), ctx)\n+                                .is_some();\n+                    } else {\n+                        let source_file_id = source.file_id.original_file(ctx.db());\n+                        have_same_parent = source_file_id == curr_file_id;\n+                    }\n+\n+                    if have_same_parent {\n+                        source_exists_outside_sel_in_same_mod =\n+                            !selection_range.contains_range(source.value.syntax().text_range());\n+                    }\n+                }\n+            }\n+            _ => {}\n+        },\n+        _ => {}\n+    }\n+\n+    return source_exists_outside_sel_in_same_mod;\n+}\n+\n+fn get_replacements_for_visibilty_change(\n+    items: Vec<ast::Item>,\n+    is_clone_for_updated: bool,\n+) -> (\n+    Vec<ast::Item>,\n+    Vec<(Option<ast::Visibility>, SyntaxNode)>,\n+    Vec<(Option<ast::Visibility>, SyntaxNode)>,\n+    Vec<ast::Impl>,\n+) {\n+    let mut replacements = Vec::new();\n+    let mut record_field_parents = Vec::new();\n+    let mut impls = Vec::new();\n+    let mut body_items = Vec::new();\n+\n+    items.into_iter().for_each(|item| {\n+        let mut item = item;\n+        if !is_clone_for_updated {\n+            item = item.clone_for_update();\n+        }\n+        body_items.push(item.clone());\n+        //Use stmts are ignored\n+        match item {\n+            ast::Item::Const(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Enum(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::ExternCrate(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Fn(it) => replacements.push((it.visibility().clone(), it.syntax().clone())),\n+            ast::Item::Impl(it) => impls.push(it),\n+            ast::Item::MacroRules(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::MacroDef(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Module(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Static(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Struct(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()));\n+                record_field_parents.push((it.visibility().clone(), it.syntax().clone()));\n+            }\n+            ast::Item::Trait(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::TypeAlias(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()))\n+            }\n+            ast::Item::Union(it) => {\n+                replacements.push((it.visibility().clone(), it.syntax().clone()));\n+                record_field_parents.push((it.visibility().clone(), it.syntax().clone()));\n+            }\n+            _ => (),\n+        }\n+    });\n+\n+    return (body_items, replacements, record_field_parents, impls);\n+}\n+\n+fn get_use_tree_paths_from_path(\n+    path: ast::Path,\n+    use_tree_str: &mut Vec<ast::Path>,\n+) -> Option<&mut Vec<ast::Path>> {\n+    path.syntax().ancestors().filter(|x| x.to_string() != path.to_string()).find_map(|x| {\n+        if let Some(use_tree) = ast::UseTree::cast(x.clone()) {\n+            if let Some(upper_tree_path) = use_tree.path() {\n+                if upper_tree_path.to_string() != path.to_string() {\n+                    use_tree_str.push(upper_tree_path.clone());\n+                    get_use_tree_paths_from_path(upper_tree_path, use_tree_str);\n+                    return Some(use_tree);\n+                }\n+            }\n+        }\n+        None\n+    })?;\n+\n+    Some(use_tree_str)\n+}\n+\n+fn add_change_vis(\n+    vis: Option<ast::Visibility>,\n+    node_or_token_opt: Option<syntax::SyntaxElement>,\n+) -> Option<()> {\n+    if let Some(vis) = vis {\n+        if vis.syntax().text() == \"pub\" {\n+            ted::replace(vis.syntax(), make::visibility_pub_crate().syntax().clone_for_update());\n+        }\n+    } else {\n+        if let Some(node_or_token) = node_or_token_opt {\n+            let pub_crate_vis = make::visibility_pub_crate().clone_for_update();\n+            if let Some(node) = node_or_token.as_node() {\n+                ted::insert(ted::Position::before(node), pub_crate_vis.syntax());\n+            }\n+            if let Some(token) = node_or_token.as_token() {\n+                ted::insert(ted::Position::before(token), pub_crate_vis.syntax());\n+            }\n+        }\n+    }\n+\n+    Some(())\n+}\n+\n+fn compare_hir_and_ast_module(\n+    ast_module: &ast::Module,\n+    hir_module: hir::Module,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let hir_mod_name = hir_module.name(ctx.db())?;\n+    let ast_mod_name = ast_module.name()?;\n+    if hir_mod_name.to_string() != ast_mod_name.to_string() {\n+        return None;\n+    }\n+\n+    return Some(());\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_not_applicable_without_selection() {\n+        check_assist_not_applicable(\n+            extract_module,\n+            r\"\n+                $0pub struct PublicStruct {\n+                    field: i32,\n+                }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod thirdpartycrate {\n+                pub mod nest {\n+                    pub struct SomeType;\n+                    pub struct SomeType2;\n+                }\n+                pub struct SomeType1;\n+            }\n+\n+            mod bar {\n+                use crate::thirdpartycrate::{nest::{SomeType, SomeType2}, SomeType1};\n+\n+                pub struct PublicStruct {\n+                    field: PrivateStruct,\n+                    field1: SomeType1,\n+                }\n+\n+                impl PublicStruct {\n+                    pub fn new() -> Self {\n+                        Self { field: PrivateStruct::new(), field1: SomeType1 }\n+                    }\n+                }\n+\n+                fn foo() {\n+                    let _s = PrivateStruct::new();\n+                    let _a = bar();\n+                }\n+\n+                $0\n+                struct PrivateStruct {\n+                    inner: SomeType,\n+                }\n+\n+                pub struct PrivateStruct1 {\n+                    pub inner: i32,\n+                }\n+\n+                impl PrivateStruct {\n+                    fn new() -> Self {\n+                         PrivateStruct { inner: SomeType }\n+                    }\n+                }\n+\n+                fn bar() -> i32 {\n+                    2\n+                }\n+                $0\n+            }\n+            \",\n+            r\"\n+            mod thirdpartycrate {\n+                pub mod nest {\n+                    pub struct SomeType;\n+                    pub struct SomeType2;\n+                }\n+                pub struct SomeType1;\n+            }\n+\n+            mod bar {\n+                use crate::thirdpartycrate::{nest::{SomeType2}, SomeType1};\n+\n+                pub struct PublicStruct {\n+                    field: modname::PrivateStruct,\n+                    field1: SomeType1,\n+                }\n+\n+                impl PublicStruct {\n+                    pub fn new() -> Self {\n+                        Self { field: modname::PrivateStruct::new(), field1: SomeType1 }\n+                    }\n+                }\n+\n+                fn foo() {\n+                    let _s = modname::PrivateStruct::new();\n+                    let _a = modname::bar();\n+                }\n+\n+                mod modname {\n+                    use crate::thirdpartycrate::nest::SomeType;\n+\n+                    pub(crate) struct PrivateStruct {\n+                        pub(crate) inner: SomeType,\n+                    }\n+\n+                    pub(crate) struct PrivateStruct1 {\n+                        pub(crate) inner: i32,\n+                    }\n+\n+                    impl PrivateStruct {\n+                        pub(crate) fn new() -> Self {\n+                             PrivateStruct { inner: SomeType }\n+                        }\n+                    }\n+\n+                    pub(crate) fn bar() -> i32 {\n+                        2\n+                    }\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_module_for_function_only() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+                $0\n+                fn foo(name: i32) -> i32 {\n+                    name + 1\n+                }\n+                $0\n+\n+                fn bar(name: i32) -> i32 {\n+                    name + 2\n+                }\n+            \",\n+            r\"\n+                mod modname {\n+                    pub(crate) fn foo(name: i32) -> i32 {\n+                        name + 1\n+                    }\n+                }\n+\n+                fn bar(name: i32) -> i32 {\n+                    name + 2\n+                }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module_for_impl_having_corresponding_adt_in_selection() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod impl_play {\n+                $0\n+                struct A {}\n+\n+                impl A {\n+                    pub fn new_a() -> i32 {\n+                        2\n+                    }\n+                }\n+                $0\n+\n+                fn a() {\n+                    let _a = A::new_a();\n+                }\n+            }\n+            \",\n+            r\"\n+            mod impl_play {\n+                mod modname {\n+                    pub(crate) struct A {}\n+\n+                    impl A {\n+                        pub(crate) fn new_a() -> i32 {\n+                            2\n+                        }\n+                    }\n+                }\n+\n+                fn a() {\n+                    let _a = modname::A::new_a();\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_import_resolve_when_its_only_inside_selection() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod foo {\n+                pub struct PrivateStruct;\n+                pub struct PrivateStruct1;\n+            }\n+\n+            mod bar {\n+                use super::foo::{PrivateStruct, PrivateStruct1};\n+\n+                $0\n+                struct Strukt {\n+                    field: PrivateStruct,\n+                }\n+                $0\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct1,\n+                }\n+            }\n+            \",\n+            r\"\n+            mod foo {\n+                pub struct PrivateStruct;\n+                pub struct PrivateStruct1;\n+            }\n+\n+            mod bar {\n+                use super::foo::{PrivateStruct1};\n+\n+                mod modname {\n+                    use super::super::foo::PrivateStruct;\n+\n+                    pub(crate) struct Strukt {\n+                        pub(crate) field: PrivateStruct,\n+                    }\n+                }\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct1,\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_import_resolve_when_its_inside_and_outside_selection_and_source_not_in_same_mod() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod foo {\n+                pub struct PrivateStruct;\n+            }\n+\n+            mod bar {\n+                use super::foo::PrivateStruct;\n+\n+                $0\n+                struct Strukt {\n+                    field: PrivateStruct,\n+                }\n+                $0\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct,\n+                }\n+            }\n+            \",\n+            r\"\n+            mod foo {\n+                pub struct PrivateStruct;\n+            }\n+\n+            mod bar {\n+                use super::foo::PrivateStruct;\n+\n+                mod modname {\n+                    use super::super::foo::PrivateStruct;\n+\n+                    pub(crate) struct Strukt {\n+                        pub(crate) field: PrivateStruct,\n+                    }\n+                }\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct,\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_import_resolve_when_its_inside_and_outside_selection_and_source_is_in_same_mod() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod bar {\n+                pub struct PrivateStruct;\n+\n+                $0\n+                struct Strukt {\n+                    field: PrivateStruct,\n+                }\n+                $0\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct,\n+                }\n+            }\n+            \",\n+            r\"\n+            mod bar {\n+                pub struct PrivateStruct;\n+\n+                mod modname {\n+                    use super::PrivateStruct;\n+\n+                    pub(crate) struct Strukt {\n+                        pub(crate) field: PrivateStruct,\n+                    }\n+                }\n+\n+                struct Strukt1 {\n+                    field: PrivateStruct,\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module_for_correspoding_adt_of_impl_present_in_same_mod_but_not_in_selection() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod impl_play {\n+                struct A {}\n+\n+                $0\n+                impl A {\n+                    pub fn new_a() -> i32 {\n+                        2\n+                    }\n+                }\n+                $0\n+\n+                fn a() {\n+                    let _a = A::new_a();\n+                }\n+            }\n+            \",\n+            r\"\n+            mod impl_play {\n+                struct A {}\n+\n+                mod modname {\n+                    use super::A;\n+\n+                    impl A {\n+                        pub(crate) fn new_a() -> i32 {\n+                            2\n+                        }\n+                    }\n+                }\n+\n+                fn a() {\n+                    let _a = A::new_a();\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module_for_impl_not_having_corresponding_adt_in_selection_and_not_in_same_mod_but_with_super(\n+    ) {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod foo {\n+                pub struct A {}\n+            }\n+            mod impl_play {\n+                use super::foo::A;\n+\n+                $0\n+                impl A {\n+                    pub fn new_a() -> i32 {\n+                        2\n+                    }\n+                }\n+                $0\n+\n+                fn a() {\n+                    let _a = A::new_a();\n+                }\n+            }\n+            \",\n+            r\"\n+            mod foo {\n+                pub struct A {}\n+            }\n+            mod impl_play {\n+                use super::foo::A;\n+\n+                mod modname {\n+                    use super::super::foo::A;\n+\n+                    impl A {\n+                        pub(crate) fn new_a() -> i32 {\n+                            2\n+                        }\n+                    }\n+                }\n+\n+                fn a() {\n+                    let _a = A::new_a();\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_import_resolve_for_trait_bounds_on_function() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod impl_play2 {\n+                trait JustATrait {}\n+\n+                $0\n+                struct A {}\n+\n+                fn foo<T: JustATrait>(arg: T) -> T {\n+                    arg\n+                }\n+\n+                impl JustATrait for A {}\n+\n+                fn bar() {\n+                    let a = A {};\n+                    foo(a);\n+                }\n+                $0\n+            }\n+            \",\n+            r\"\n+            mod impl_play2 {\n+                trait JustATrait {}\n+\n+                mod modname {\n+                    use super::JustATrait;\n+\n+                    pub(crate) struct A {}\n+\n+                    pub(crate) fn foo<T: JustATrait>(arg: T) -> T {\n+                        arg\n+                    }\n+\n+                    impl JustATrait for A {}\n+\n+                    pub(crate) fn bar() {\n+                        let a = A {};\n+                        foo(a);\n+                    }\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module_for_module() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod impl_play2 {\n+                $0\n+                mod impl_play {\n+                    pub struct A {}\n+                }\n+                $0\n+            }\n+            \",\n+            r\"\n+            mod impl_play2 {\n+                mod modname {\n+                    pub(crate) mod impl_play {\n+                        pub struct A {}\n+                    }\n+                }\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extract_module_with_multiple_files() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+\n+            use foo::PrivateStruct;\n+\n+            pub struct Strukt {\n+                field: PrivateStruct,\n+            }\n+\n+            fn main() {\n+                $0\n+                struct Strukt1 {\n+                    field: Strukt,\n+                }\n+                $0\n+            }\n+            //- /foo.rs\n+            pub struct PrivateStruct;\n+            \",\n+            r\"\n+            mod foo;\n+\n+            use foo::PrivateStruct;\n+\n+            pub struct Strukt {\n+                field: PrivateStruct,\n+            }\n+\n+            fn main() {\n+                mod modname {\n+                    use super::Strukt;\n+\n+                    pub(crate) struct Strukt1 {\n+                        pub(crate) field: Strukt,\n+                    }\n+                }\n+            }\n+            \",\n+        )\n+    }\n+}"}, {"sha": "5210166738a5df4ec5f8ed84c9c52272e942cbfd", "filename": "crates/ide_assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=32b95ea3100d34e87e50ec2d2d42786b2927de9c", "patch": "@@ -140,7 +140,7 @@ fn process_usage(\n     None\n }\n \n-fn range_to_remove(node: &SyntaxNode) -> TextRange {\n+pub(crate) fn range_to_remove(node: &SyntaxNode) -> TextRange {\n     let up_to_comma = next_prev().find_map(|dir| {\n         node.siblings_with_tokens(dir)\n             .filter_map(|it| it.into_token())"}, {"sha": "1d72b5c0f97b7a0defbcd3c976d9a8e903a19ba6", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=32b95ea3100d34e87e50ec2d2d42786b2927de9c", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod destructure_tuple_binding;\n     mod expand_glob_import;\n     mod extract_function;\n+    mod extract_module;\n     mod extract_struct_from_enum_variant;\n     mod extract_type_alias;\n     mod extract_variable;\n@@ -273,6 +274,7 @@ mod handlers {\n             //\n             extract_variable::extract_variable,\n             extract_function::extract_function,\n+            extract_module::extract_module,\n             //\n             generate_getter::generate_getter,\n             generate_getter::generate_getter_mut,"}, {"sha": "9cf20e716e52c2913d2d054d6847f02d5541052f", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=32b95ea3100d34e87e50ec2d2d42786b2927de9c", "patch": "@@ -526,6 +526,35 @@ fn $0fun_name(n: i32) {\n     )\n }\n \n+#[test]\n+fn doctest_extract_module() {\n+    check_doc_test(\n+        \"extract_module\",\n+        r#####\"\n+$0\n+fn foo(name: i32) -> i32 {\n+    name + 1\n+}\n+$0\n+\n+fn bar(name: i32) -> i32 {\n+    name + 2\n+}\n+\"#####,\n+        r#####\"\n+mod modname {\n+    pub(crate) fn foo(name: i32) -> i32 {\n+        name + 1\n+    }\n+}\n+\n+fn bar(name: i32) -> i32 {\n+    name + 2\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_struct_from_enum_variant() {\n     check_doc_test("}, {"sha": "ed69973af92c23b638f968f0935c223a3e9fc66f", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b95ea3100d34e87e50ec2d2d42786b2927de9c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=32b95ea3100d34e87e50ec2d2d42786b2927de9c", "patch": "@@ -196,6 +196,12 @@ pub fn path_from_segments(\n         format!(\"use {};\", segments)\n     })\n }\n+\n+pub fn join_paths(paths: impl IntoIterator<Item = ast::Path>) -> ast::Path {\n+    let paths = paths.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n+    ast_from_text(&format!(\"use {};\", paths))\n+}\n+\n // FIXME: should not be pub\n pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(&format!(\"fn main() {{ let test = {}; }}\", text))"}]}