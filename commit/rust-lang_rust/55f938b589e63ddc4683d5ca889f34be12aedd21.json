{"sha": "55f938b589e63ddc4683d5ca889f34be12aedd21", "node_id": "C_kwDOAAsO6NoAKDU1ZjkzOGI1ODllNjNkZGM0NjgzZDVjYTg4OWYzNGJlMTJhZWRkMjE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-21T12:44:55Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-21T12:53:34Z"}, "message": "update docs for `simplify_type`", "tree": {"sha": "db3358a092315788497b71f26768d398ae41e714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db3358a092315788497b71f26768d398ae41e714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f938b589e63ddc4683d5ca889f34be12aedd21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f938b589e63ddc4683d5ca889f34be12aedd21", "html_url": "https://github.com/rust-lang/rust/commit/55f938b589e63ddc4683d5ca889f34be12aedd21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f938b589e63ddc4683d5ca889f34be12aedd21/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd", "html_url": "https://github.com/rust-lang/rust/commit/026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd"}], "stats": {"total": 126, "additions": 66, "deletions": 60}, "files": [{"sha": "02e29b3b3e3ee3b6996b7ae50bfeff1454e4fce7", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n@@ -2065,7 +2065,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplsVisitor<'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        SimplifyParams::No,\n+                        TreatParams::AsPlaceholders,\n                     );\n \n                     self.impls"}, {"sha": "9118e5dba12f92cdf8ef0b3a36be079d6d7d836c", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -49,36 +49,36 @@ where\n }\n \n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub enum SimplifyParams {\n-    Yes,\n-    No,\n+pub enum TreatParams {\n+    /// Treat parametes as bound types in the given environment.\n+    ///\n+    /// For this to be correct the input has to be fully normalized\n+    /// in its param env as it may otherwise cause us to ignore\n+    /// potentially applying impls.\n+    AsBoundTypes,\n+    AsPlaceholders,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n /// The idea is to get something simple that we can use to quickly decide if two types could unify,\n /// for example during method lookup.\n ///\n-/// A special case here are parameters and projections. Projections can be normalized to\n-/// a different type, meaning that `<T as Trait>::Assoc` and `u8` can be unified, even though\n-/// their outermost layer is different while parameters like `T` of impls are later replaced\n-/// with an inference variable, which then also allows unification with other types.\n+/// A special case here are parameters and projections, which are only injective\n+/// if they are treated as bound types.\n ///\n-/// When using `SimplifyParams::Yes`, we still return a simplified type for params and projections\u00b2,\n-/// the reasoning for this can be seen at the places doing this.\n+/// For example when storing impls based on their simplified self type, we treat\n+/// generic parameters as placeholders. We must not simplify them here,\n+/// as they can unify with any other type.\n ///\n+/// With projections we have to be even more careful, as even when treating them as bound types\n+/// this is still only correct if they are fully normalized.\n ///\n-/// \u00b9 meaning that if two outermost layers are different, then the whole types are also different.\n-/// \u00b2 FIXME(@lcnr): this seems like it can actually end up being unsound with the way it's used during\n-///   candidate selection. We do not consider non blanket impls for `<_ as Trait>::Assoc` even\n-///   though `_` can be inferred to a concrete type later at which point a concrete impl\n-///   could actually apply. After experimenting for about an hour I wasn't able to cause any issues\n-///   this way so I am not going to change this until we actually find an issue as I am really\n-///   interesting in getting an actual test for this.\n-pub fn simplify_type(\n-    tcx: TyCtxt<'_>,\n-    ty: Ty<'_>,\n-    can_simplify_params: SimplifyParams,\n+/// \u00b9 meaning that if the outermost layers are different, then the whole types are also different.\n+pub fn simplify_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    treat_params: TreatParams,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -91,7 +91,7 @@ pub fn simplify_type(\n         ty::Array(..) => Some(ArraySimplifiedType),\n         ty::Slice(..) => Some(SliceSimplifiedType),\n         ty::RawPtr(ptr) => Some(PtrSimplifiedType(ptr.mutbl)),\n-        ty::Dynamic(ref trait_info, ..) => match trait_info.principal_def_id() {\n+        ty::Dynamic(trait_info, ..) => match trait_info.principal_def_id() {\n             Some(principal_def_id) if !tcx.trait_is_auto(principal_def_id) => {\n                 Some(TraitSimplifiedType(principal_def_id))\n             }\n@@ -100,24 +100,21 @@ pub fn simplify_type(\n         ty::Ref(_, _, mutbl) => Some(RefSimplifiedType(mutbl)),\n         ty::FnDef(def_id, _) | ty::Closure(def_id, _) => Some(ClosureSimplifiedType(def_id)),\n         ty::Generator(def_id, _, _) => Some(GeneratorSimplifiedType(def_id)),\n-        ty::GeneratorWitness(ref tys) => {\n-            Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n-        }\n+        ty::GeneratorWitness(tys) => Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len())),\n         ty::Never => Some(NeverSimplifiedType),\n-        ty::Tuple(ref tys) => Some(TupleSimplifiedType(tys.len())),\n-        ty::FnPtr(ref f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n-        ty::Projection(_) | ty::Param(_) => {\n-            if can_simplify_params == SimplifyParams::Yes {\n-                // In normalized types, projections don't unify with\n-                // anything. when lazy normalization happens, this\n-                // will change. It would still be nice to have a way\n-                // to deal with known-not-to-unify-with-anything\n-                // projections (e.g., the likes of <__S as Encoder>::Error).\n+        ty::Tuple(tys) => Some(TupleSimplifiedType(tys.len())),\n+        ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n+        ty::Param(_) | ty::Projection(_) => match treat_params {\n+            // When treated as bound types, projections don't unify with\n+            // anything as long as they are fully normalized.\n+            //\n+            // We will have to be careful with lazy normalization here.\n+            TreatParams::AsBoundTypes => {\n+                debug!(\"treating `{}` as a bound type\", ty);\n                 Some(ParameterSimplifiedType)\n-            } else {\n-                None\n             }\n-        }\n+            TreatParams::AsPlaceholders => None,\n+        },\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,"}, {"sha": "38b6bada25754156b18b94b5e1053dc0bb407507", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ident, Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -150,7 +150,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::No) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholders) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -180,14 +180,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `SimplifyParams::Yes` to query `non_blanket_impls` while using\n-        // `SimplifyParams::No` while actually adding them.\n+        // Note that we're using `TreatParams::AsBoundTypes` to query `non_blanket_impls` while using\n+        // `TreatParams::AsPlaceholders` while actually adding them.\n         //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::Yes) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsBoundTypes) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -247,7 +247,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n         }\n \n         if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, SimplifyParams::No)\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsPlaceholders)\n         {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {"}, {"sha": "a0ea1d0d8859dd1f47d879c80e179526613e3603", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -19,7 +19,7 @@ use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -86,8 +86,8 @@ where\n         impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n     )\n     .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No);\n+        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsPlaceholders);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsPlaceholders);\n \n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully"}, {"sha": "99b9d8afc27b7b79790af2cd6d4d5ebad5e29193", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -36,7 +36,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -2180,8 +2180,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fast_reject_trait_refs(\n         &mut self,\n-        obligation: &TraitObligation<'_>,\n-        impl_trait_ref: &ty::TraitRef<'_>,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_trait_ref: &ty::TraitRef<'tcx>,\n     ) -> bool {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n@@ -2197,10 +2197,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let simplified_obligation_ty = fast_reject::simplify_type(\n                             self.tcx(),\n                             obligation_ty,\n-                            SimplifyParams::Yes,\n+                            TreatParams::AsBoundTypes,\n+                        );\n+                        let simplified_impl_ty = fast_reject::simplify_type(\n+                            self.tcx(),\n+                            impl_ty,\n+                            TreatParams::AsPlaceholders,\n                         );\n-                        let simplified_impl_ty =\n-                            fast_reject::simplify_type(self.tcx(), impl_ty, SimplifyParams::No);\n \n                         simplified_obligation_ty.is_some()\n                             && simplified_impl_ty.is_some()"}, {"sha": "8b23dcfe3808abce209899d91b369e28e7dfd85f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -2,7 +2,7 @@ use super::OverlapError;\n \n use crate::traits;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n \n@@ -49,7 +49,9 @@ impl ChildrenExt<'_> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -64,7 +66,9 @@ impl ChildrenExt<'_> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -312,7 +316,8 @@ impl GraphExt for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No);\n+        let simplified =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "94b61f7caf81495417f5644f7a3f88a353b330eb", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f938b589e63ddc4683d5ca889f34be12aedd21/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=55f938b589e63ddc4683d5ca889f34be12aedd21", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -1768,7 +1768,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(self.tcx, rcvr_ty, SimplifyParams::Yes)\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::AsBoundTypes)\n             {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n@@ -1783,7 +1784,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n                             let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), SimplifyParams::Yes);\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsBoundTypes);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}]}