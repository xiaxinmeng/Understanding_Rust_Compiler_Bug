{"sha": "6af36031e2f286e6cca37f14ede514fff46b6e6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjM2MDMxZTJmMjg2ZTZjY2EzN2YxNGVkZTUxNGZmZjQ2YjZlNmY=", "commit": {"author": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T07:50:24Z"}, "committer": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T09:09:38Z"}, "message": "Fix PEP8 in gdb pretty printer", "tree": {"sha": "9fc44e349f1589099e959b1487a2efb8242a4a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fc44e349f1589099e959b1487a2efb8242a4a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af36031e2f286e6cca37f14ede514fff46b6e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af36031e2f286e6cca37f14ede514fff46b6e6f", "html_url": "https://github.com/rust-lang/rust/commit/6af36031e2f286e6cca37f14ede514fff46b6e6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af36031e2f286e6cca37f14ede514fff46b6e6f/comments", "author": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9252525196505f33b1986c78068d63e567c31c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/9252525196505f33b1986c78068d63e567c31c43", "html_url": "https://github.com/rust-lang/rust/commit/9252525196505f33b1986c78068d63e567c31c43"}], "stats": {"total": 364, "additions": 188, "deletions": 176}, "files": [{"sha": "c5587bb10d1dacf3840b35dc5350055e1b61cbec", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 188, "deletions": 176, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/6af36031e2f286e6cca37f14ede514fff46b6e6f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/6af36031e2f286e6cca37f14ede514fff46b6e6f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=6af36031e2f286e6cca37f14ede514fff46b6e6f", "patch": "@@ -14,181 +14,189 @@\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n \n+\n def register_printers(objfile):\n-  \"Registers Rust pretty printers for the given objfile\"\n-  objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+    \"Registers Rust pretty printers for the given objfile\"\n+    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+\n \n def rust_pretty_printer_lookup_function(val):\n-  \"Returns the correct Rust pretty printer for the given value if there is one\"\n-  type_code = val.type.code\n-\n-  if type_code == gdb.TYPE_CODE_STRUCT:\n-    struct_kind = classify_struct(val.type)\n-\n-    if struct_kind == STRUCT_KIND_STR_SLICE:\n-      return RustStringSlicePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE:\n-      return RustTuplePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n-      return RustTupleStructPrinter(val, False)\n-\n-    if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n-      return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n-      return RustTupleStructPrinter(val, True)\n-\n-    if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n-      return RustStructPrinter(val, True)\n-\n-    return RustStructPrinter(val, False)\n-\n-  # Enum handling\n-  if type_code == gdb.TYPE_CODE_UNION:\n-    enum_members = list(val.type.fields())\n-    enum_member_count = len(enum_members)\n-\n-    if enum_member_count == 0:\n-      return RustStructPrinter(val, False)\n-\n-    if enum_member_count == 1:\n-      first_variant_name = enum_members[0].name\n-      if first_variant_name == None:\n-        # This is a singleton enum\n-        return rust_pretty_printer_lookup_function(val[enum_members[0]])\n-      else:\n-        assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n-        # This is a space-optimized enum.\n-        # This means this enum has only two states, and Rust uses one of the\n-        # fields somewhere in the struct to determine which of the two states\n-        # it's in. The location of the field is encoded in the name as something\n-        # like RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n-        last_separator_index = first_variant_name.rfind(\"$\")\n-        start_index = len(\"RUST$ENCODED$ENUM$\")\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-\n-        sole_variant_val = val[enum_members[0]]\n-        discriminant = sole_variant_val\n-        for disr_field_index in disr_field_indices:\n-          disr_field = get_field_at_index(discriminant, disr_field_index)\n-          discriminant = discriminant[disr_field]\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n-          discriminant = discriminant[get_field_at_index(discriminant, 0)]\n-\n-        if discriminant == 0:\n-          null_variant_name = first_variant_name[last_separator_index + 1:]\n-          return IdentityPrinter(null_variant_name)\n-\n-        return rust_pretty_printer_lookup_function(sole_variant_val)\n-\n-    # This is a regular enum, extract the discriminant\n-    discriminant_name, discriminant_val = extract_discriminant_value(val)\n-    return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n-\n-  # No pretty printer has been found\n-  return None\n+    \"Returns the correct Rust pretty printer for the given value if there is one\"\n+    type_code = val.type.code\n+\n+    if type_code == gdb.TYPE_CODE_STRUCT:\n+        struct_kind = classify_struct(val.type)\n+\n+        if struct_kind == STRUCT_KIND_STR_SLICE:\n+            return RustStringSlicePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE:\n+            return RustTuplePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n+            return RustTupleStructPrinter(val, False)\n+\n+        if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n+            return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n+            return RustTupleStructPrinter(val, True)\n+\n+        if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n+            return RustStructPrinter(val, True)\n+\n+        return RustStructPrinter(val, False)\n+\n+    # Enum handling\n+    if type_code == gdb.TYPE_CODE_UNION:\n+        enum_members = list(val.type.fields())\n+        enum_member_count = len(enum_members)\n+\n+        if enum_member_count == 0:\n+            return RustStructPrinter(val, False)\n+\n+        if enum_member_count == 1:\n+            first_variant_name = enum_members[0].name\n+            if first_variant_name is None:\n+                # This is a singleton enum\n+                return rust_pretty_printer_lookup_function(val[enum_members[0]])\n+            else:\n+                assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n+                # This is a space-optimized enum.\n+                # This means this enum has only two states, and Rust uses one\n+                # of the fields somewhere in the struct to determine which of\n+                # the two states it's in. The location of the field is encoded\n+                # in the name as something like\n+                # RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n+                last_separator_index = first_variant_name.rfind(\"$\")\n+                start_index = len(\"RUST$ENCODED$ENUM$\")\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+\n+                sole_variant_val = val[enum_members[0]]\n+                discriminant = sole_variant_val\n+                for disr_field_index in disr_field_indices:\n+                    disr_field = get_field_at_index(discriminant, disr_field_index)\n+                    discriminant = discriminant[disr_field]\n+\n+                # If the discriminant field is a fat pointer we have to consider the\n+                # first word as the true discriminant\n+                if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n+                    discriminant = discriminant[get_field_at_index(discriminant, 0)]\n+\n+                if discriminant == 0:\n+                    null_variant_name = first_variant_name[last_separator_index + 1:]\n+                    return IdentityPrinter(null_variant_name)\n+\n+                return rust_pretty_printer_lookup_function(sole_variant_val)\n+\n+        # This is a regular enum, extract the discriminant\n+        discriminant_name, discriminant_val = extract_discriminant_value(val)\n+        return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n+\n+    # No pretty printer has been found\n+    return None\n \n #=------------------------------------------------------------------------------\n # Pretty Printer Classes\n #=------------------------------------------------------------------------------\n \n+\n class RustStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n-\n-  def to_string(self):\n-    return self.val.type.tag\n-\n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      field_name = field.name\n-      # Normally the field name is used as a key to access the field value,\n-      # because that's also supported in older versions of GDB...\n-      field_key = field_name\n-      if field_name == None:\n-        field_name = \"\"\n-        # ... but for fields without a name (as in tuples), we have to fall back\n-        # to the newer method of using the field object directly as key. In\n-        # older versions of GDB, this will just fail.\n-        field_key = field\n-      name_value_tuple = ( field_name, self.val[field_key] )\n-      cs.append( name_value_tuple )\n-\n-    if self.hide_first_field:\n-      cs = cs[1:]\n-\n-    return cs\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n+\n+    def to_string(self):\n+        return self.val.type.tag\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            field_name = field.name\n+            # Normally the field name is used as a key to access the field\n+            # value, because that's also supported in older versions of GDB...\n+            field_key = field_name\n+            if field_name is None:\n+                field_name = \"\"\n+                # ... but for fields without a name (as in tuples), we have to\n+                # fall back to the newer method of using the field object\n+                # directly as key. In older versions of GDB, this will just\n+                # fail.\n+                field_key = field\n+            name_value_tuple = (field_name, self.val[field_key])\n+            cs.append(name_value_tuple)\n+\n+        if self.hide_first_field:\n+            cs = cs[1:]\n+\n+        return cs\n+\n \n class RustTuplePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n \n-  def to_string(self):\n-    return None\n+    def to_string(self):\n+        return None\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+        return cs\n \n-    return cs\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustTupleStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n \n-  def to_string(self):\n-    return self.val.type.tag\n+    def to_string(self):\n+        return self.val.type.tag\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-    if self.hide_first_field:\n-      cs = cs[1:]\n+        if self.hide_first_field:\n+            cs = cs[1:]\n \n-    return cs\n+        return cs\n+\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustStringSlicePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n+\n+    def to_string(self):\n+        slice_byte_len = self.val[\"length\"]\n+        return '\"%s\"' % self.val[\"data_ptr\"].string(encoding=\"utf-8\", length=slice_byte_len)\n \n-  def to_string(self):\n-    slice_byte_len = self.val[\"length\"]\n-    return '\"%s\"' % self.val[\"data_ptr\"].string(encoding = \"utf-8\",\n-                                                length = slice_byte_len)\n \n class RustCStyleEnumPrinter:\n-  def __init__(self, val):\n-    assert val.type.code == gdb.TYPE_CODE_ENUM\n-    self.val = val\n+    def __init__(self, val):\n+        assert val.type.code == gdb.TYPE_CODE_ENUM\n+        self.val = val\n+\n+    def to_string(self):\n+        return str(self.val)\n \n-  def to_string(self):\n-    return str(self.val)\n \n class IdentityPrinter:\n-  def __init__(self, string):\n-    self.string = string\n+    def __init__(self, string):\n+        self.string = string\n \n-  def to_string(self):\n-    return self.string\n+    def to_string(self):\n+        return self.string\n \n STRUCT_KIND_REGULAR_STRUCT  = 0\n STRUCT_KIND_TUPLE_STRUCT    = 1\n@@ -198,47 +206,51 @@ def to_string(self):\n STRUCT_KIND_CSTYLE_VARIANT  = 5\n STRUCT_KIND_STR_SLICE       = 6\n \n+\n def classify_struct(type):\n-  if type.tag == \"&str\":\n-    return STRUCT_KIND_STR_SLICE\n+    if type.tag == \"&str\":\n+        return STRUCT_KIND_STR_SLICE\n \n-  fields = list(type.fields())\n-  field_count = len(fields)\n+    fields = list(type.fields())\n+    field_count = len(fields)\n \n-  if field_count == 0:\n-    return STRUCT_KIND_REGULAR_STRUCT\n+    if field_count == 0:\n+        return STRUCT_KIND_REGULAR_STRUCT\n+\n+    if fields[0].name == \"RUST$ENUM$DISR\":\n+        if field_count == 1:\n+            return STRUCT_KIND_CSTYLE_VARIANT\n+        elif fields[1].name is None:\n+            return STRUCT_KIND_TUPLE_VARIANT\n+        else:\n+            return STRUCT_KIND_STRUCT_VARIANT\n \n-  if fields[0].name == \"RUST$ENUM$DISR\":\n-    if field_count == 1:\n-      return STRUCT_KIND_CSTYLE_VARIANT\n-    elif fields[1].name == None:\n-      return STRUCT_KIND_TUPLE_VARIANT\n-    else:\n-      return STRUCT_KIND_STRUCT_VARIANT\n+    if fields[0].name is None:\n+        if type.tag.startswith(\"(\"):\n+            return STRUCT_KIND_TUPLE\n+        else:\n+            return STRUCT_KIND_TUPLE_STRUCT\n \n-  if fields[0].name == None:\n-    if type.tag.startswith(\"(\"):\n-      return STRUCT_KIND_TUPLE\n-    else:\n-      return STRUCT_KIND_TUPLE_STRUCT\n+    return STRUCT_KIND_REGULAR_STRUCT\n \n-  return STRUCT_KIND_REGULAR_STRUCT\n \n def extract_discriminant_value(enum_val):\n-  assert enum_val.type.code == gdb.TYPE_CODE_UNION\n-  for variant_descriptor in enum_val.type.fields():\n-    variant_val = enum_val[variant_descriptor]\n-    for field in variant_val.type.fields():\n-      return (field.name, int(variant_val[field]))\n+    assert enum_val.type.code == gdb.TYPE_CODE_UNION\n+    for variant_descriptor in enum_val.type.fields():\n+        variant_val = enum_val[variant_descriptor]\n+        for field in variant_val.type.fields():\n+            return (field.name, int(variant_val[field]))\n+\n \n def first_field(val):\n-  for field in val.type.fields():\n-    return field\n+    for field in val.type.fields():\n+        return field\n+\n \n def get_field_at_index(val, index):\n-  i = 0\n-  for field in val.type.fields():\n-    if i == index:\n-      return field\n-    i += 1\n-  return None\n+    i = 0\n+    for field in val.type.fields():\n+        if i == index:\n+            return field\n+        i += 1\n+    return None"}]}