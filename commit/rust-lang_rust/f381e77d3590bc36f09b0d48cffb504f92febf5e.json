{"sha": "f381e77d3590bc36f09b0d48cffb504f92febf5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzODFlNzdkMzU5MGJjMzZmMDliMGQ0OGNmZmI1MDRmOTJmZWJmNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-01T02:53:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-01T02:53:13Z"}, "message": "Auto merge of #84662 - dtolnay:unwindsafe, r=Amanieu\n\nMove UnwindSafe, RefUnwindSafe, AssertUnwindSafe to core\n\nThey were previously only available in std::panic, not core::panic.\n\n- https://doc.rust-lang.org/1.51.0/std/panic/trait.UnwindSafe.html\n- https://doc.rust-lang.org/1.51.0/std/panic/trait.RefUnwindSafe.html\n- https://doc.rust-lang.org/1.51.0/std/panic/struct.AssertUnwindSafe.html\n\nWhere this is relevant: trait objects! Inside a `#![no_std]` library it's otherwise impossible to have a struct holding a trait object, and at the same time can be used from downstream std crates in a way that doesn't interfere with catch_unwind.\n\n```rust\n// common library\n\n#![no_std]\n\npub struct Thing {\n    pub(crate) x: &'static (dyn SomeTrait + Send + Sync),\n}\n\npub(crate) trait SomeTrait {...}\n```\n\n```rust\n// downstream application\n\nfn main() {\n    let thing: library::Thing = ...;\n    let _ = std::panic::catch_unwind(|| { let _ = thing; });  // does not work :(\n}\n```\n\nSee https://github.com/dtolnay/colorous/blob/a4131708e2f05d2377964981896ff62dbc9b027b/src/gradient.rs#L7-L15 for a real life example of needing to work around this problem. In particular that workaround would not even be viable if implementors of the trait were provided externally by a caller, as the `feature = \"std\"` would become non-additive in that case.\n\nWhat happens without the UnwindSafe constraints:\n\n```rust\nfn main() {\n    let gradient = colorous::VIRIDIS;\n    let _ = std::panic::catch_unwind(|| { let _ = gradient; });\n}\n```\n\n```console\nerror[E0277]: the type `(dyn colorous::gradient::EvalGradient + Send + Sync + 'static)` may contain interior mutability and a reference may not be safely transferrable across a catch_unwind boundary\n   --> src/main.rs:3:13\n    |\n3   |     let _ = std::panic::catch_unwind(|| { let _ = gradient; });\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn colorous::gradient::EvalGradient + Send + Sync + 'static)` may contain interior mutability and a reference may not be safely transferrable across a catch_unwind boundary\n    |\n   ::: .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:430:40\n    |\n430 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ---------- required by this bound in `catch_unwind`\n    |\n    = help: within `Gradient`, the trait `RefUnwindSafe` is not implemented for `(dyn colorous::gradient::EvalGradient + Send + Sync + 'static)`\n    = note: required because it appears within the type `&'static (dyn colorous::gradient::EvalGradient + Send + Sync + 'static)`\n    = note: required because it appears within the type `Gradient`\n    = note: required because of the requirements on the impl of `UnwindSafe` for `&Gradient`\n    = note: required because it appears within the type `[closure@src/main.rs:3:38: 3:62]`\n```", "tree": {"sha": "8c52fd6e92a72d6d24c314edd6f9eb239a057a80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c52fd6e92a72d6d24c314edd6f9eb239a057a80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f381e77d3590bc36f09b0d48cffb504f92febf5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f381e77d3590bc36f09b0d48cffb504f92febf5e", "html_url": "https://github.com/rust-lang/rust/commit/f381e77d3590bc36f09b0d48cffb504f92febf5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f381e77d3590bc36f09b0d48cffb504f92febf5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0a6babf191847038860207075667effc9a67dec", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a6babf191847038860207075667effc9a67dec", "html_url": "https://github.com/rust-lang/rust/commit/a0a6babf191847038860207075667effc9a67dec"}, {"sha": "d1586fc6bb7adcd99a682f929f78761231db99e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1586fc6bb7adcd99a682f929f78761231db99e8", "html_url": "https://github.com/rust-lang/rust/commit/d1586fc6bb7adcd99a682f929f78761231db99e8"}], "stats": {"total": 1300, "additions": 662, "deletions": 638}, "files": [{"sha": "0b3079fa59db602ace6aea67c1297380c36bf886", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -262,6 +262,7 @@ use core::marker::{self, PhantomData, Unpin, Unsize};\n use core::mem::size_of_val;\n use core::mem::{self, align_of_val_raw, forget};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n+use core::panic::{RefUnwindSafe, UnwindSafe};\n #[cfg(not(no_global_oom_handling))]\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -314,6 +315,9 @@ impl<T: ?Sized> !marker::Send for Rc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !marker::Sync for Rc<T> {}\n \n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n "}, {"sha": "3183a6db410b8bddbf6329a9f21531f508be20d8", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -19,6 +19,7 @@ use core::marker::{PhantomData, Unpin, Unsize};\n use core::mem::size_of_val;\n use core::mem::{self, align_of_val_raw};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n+use core::panic::{RefUnwindSafe, UnwindSafe};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n #[cfg(not(no_global_oom_handling))]\n@@ -240,6 +241,9 @@ unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n \n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n "}, {"sha": "463bec37265d5035c7cbd34bb46d3cd3bc174070", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 11, "deletions": 329, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -2,8 +2,18 @@\n \n #![stable(feature = \"core_panic_info\", since = \"1.41.0\")]\n \n+mod location;\n+mod panic_info;\n+mod unwind_safe;\n+\n use crate::any::Any;\n-use crate::fmt;\n+\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub use self::location::Location;\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub use self::panic_info::PanicInfo;\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub use self::unwind_safe::{AssertUnwindSafe, RefUnwindSafe, UnwindSafe};\n \n #[doc(hidden)]\n #[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\n@@ -39,334 +49,6 @@ pub macro panic_2021 {\n     ),\n }\n \n-/// A struct providing information about a panic.\n-///\n-/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n-/// function.\n-///\n-/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n-///         println!(\"panic occurred: {:?}\", s);\n-///     } else {\n-///         println!(\"panic occurred\");\n-///     }\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-#[lang = \"panic_info\"]\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-#[derive(Debug)]\n-pub struct PanicInfo<'a> {\n-    payload: &'a (dyn Any + Send),\n-    message: Option<&'a fmt::Arguments<'a>>,\n-    location: &'a Location<'a>,\n-}\n-\n-impl<'a> PanicInfo<'a> {\n-    #[unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    #[inline]\n-    pub fn internal_constructor(\n-        message: Option<&'a fmt::Arguments<'a>>,\n-        location: &'a Location<'a>,\n-    ) -> Self {\n-        struct NoPayload;\n-        PanicInfo { location, message, payload: &NoPayload }\n-    }\n-\n-    #[unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    #[inline]\n-    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n-        self.payload = info;\n-    }\n-\n-    /// Returns the payload associated with the panic.\n-    ///\n-    /// This will commonly, but not always, be a `&'static str` or [`String`].\n-    ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n-    ///         println!(\"panic occurred: {:?}\", s);\n-    ///     } else {\n-    ///         println!(\"panic occurred\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn payload(&self) -> &(dyn Any + Send) {\n-        self.payload\n-    }\n-\n-    /// If the `panic!` macro from the `core` crate (not from `std`)\n-    /// was used with a formatting string and some additional arguments,\n-    /// returns that message ready to be used for example with [`fmt::write`]\n-    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n-    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n-        self.message\n-    }\n-\n-    /// Returns information about the location from which the panic originated,\n-    /// if available.\n-    ///\n-    /// This method will currently always return [`Some`], but this may change\n-    /// in future versions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}' at line {}\",\n-    ///             location.file(),\n-    ///             location.line(),\n-    ///         );\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn location(&self) -> Option<&Location<'_>> {\n-        // NOTE: If this is changed to sometimes return None,\n-        // deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.\n-        Some(&self.location)\n-    }\n-}\n-\n-#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n-impl fmt::Display for PanicInfo<'_> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        formatter.write_str(\"panicked at \")?;\n-        if let Some(message) = self.message {\n-            write!(formatter, \"'{}', \", message)?\n-        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n-            write!(formatter, \"'{}', \", payload)?\n-        }\n-        // NOTE: we cannot use downcast_ref::<String>() here\n-        // since String is not available in libcore!\n-        // The payload is a String when `std::panic!` is called with multiple arguments,\n-        // but in that case the message is also available.\n-\n-        self.location.fmt(formatter)\n-    }\n-}\n-\n-/// A struct containing information about the location of a panic.\n-///\n-/// This structure is created by [`PanicInfo::location()`].\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(location) = panic_info.location() {\n-///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n-///     } else {\n-///         println!(\"panic occurred but can't get location information...\");\n-///     }\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-///\n-/// # Comparisons\n-///\n-/// Comparisons for equality and ordering are made in file, line, then column priority.\n-/// Files are compared as strings, not `Path`, which could be unexpected.\n-/// See [`Location::file`]'s documentation for more discussion.\n-#[lang = \"panic_location\"]\n-#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub struct Location<'a> {\n-    file: &'a str,\n-    line: u32,\n-    col: u32,\n-}\n-\n-impl<'a> Location<'a> {\n-    /// Returns the source location of the caller of this function. If that function's caller is\n-    /// annotated then its call location will be returned, and so on up the stack to the first call\n-    /// within a non-tracked function body.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::panic::Location;\n-    ///\n-    /// /// Returns the [`Location`] at which it is called.\n-    /// #[track_caller]\n-    /// fn get_caller_location() -> &'static Location<'static> {\n-    ///     Location::caller()\n-    /// }\n-    ///\n-    /// /// Returns a [`Location`] from within this function's definition.\n-    /// fn get_just_one_location() -> &'static Location<'static> {\n-    ///     get_caller_location()\n-    /// }\n-    ///\n-    /// let fixed_location = get_just_one_location();\n-    /// assert_eq!(fixed_location.file(), file!());\n-    /// assert_eq!(fixed_location.line(), 14);\n-    /// assert_eq!(fixed_location.column(), 5);\n-    ///\n-    /// // running the same untracked function in a different location gives us the same result\n-    /// let second_fixed_location = get_just_one_location();\n-    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n-    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n-    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n-    ///\n-    /// let this_location = get_caller_location();\n-    /// assert_eq!(this_location.file(), file!());\n-    /// assert_eq!(this_location.line(), 28);\n-    /// assert_eq!(this_location.column(), 21);\n-    ///\n-    /// // running the tracked function in a different location produces a different value\n-    /// let another_location = get_caller_location();\n-    /// assert_eq!(this_location.file(), another_location.file());\n-    /// assert_ne!(this_location.line(), another_location.line());\n-    /// assert_ne!(this_location.column(), another_location.column());\n-    /// ```\n-    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n-    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n-    #[track_caller]\n-    pub const fn caller() -> &'static Location<'static> {\n-        crate::intrinsics::caller_location()\n-    }\n-}\n-\n-impl<'a> Location<'a> {\n-    #![unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n-        Location { file, line, col }\n-    }\n-\n-    /// Returns the name of the source file from which the panic originated.\n-    ///\n-    /// # `&str`, not `&Path`\n-    ///\n-    /// The returned name refers to a source path on the compiling system, but it isn't valid to\n-    /// represent this directly as a `&Path`. The compiled code may run on a different system with\n-    /// a different `Path` implementation than the system providing the contents and this library\n-    /// does not currently have a different \"host path\" type.\n-    ///\n-    /// The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in\n-    /// the module system (usually using the `#[path = \"...\"]` attribute or similar), which can\n-    /// cause what appears to be identical code to return differing values from this function.\n-    ///\n-    /// # Cross-compilation\n-    ///\n-    /// This value is not suitable for passing to `Path::new` or similar constructors when the host\n-    /// platform and target platform differ.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}'\", location.file());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn file(&self) -> &str {\n-        self.file\n-    }\n-\n-    /// Returns the line number from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at line {}\", location.line());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn line(&self) -> u32 {\n-        self.line\n-    }\n-\n-    /// Returns the column from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at column {}\", location.column());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n-    pub fn column(&self) -> u32 {\n-        self.col\n-    }\n-}\n-\n-#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n-impl fmt::Display for Location<'_> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n-    }\n-}\n-\n /// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n /// and other panic runtimes. Not intended to be stabilized any time soon, do\n /// not use."}, {"sha": "a482414caaf9ae1c2149186bc6a849afe8452420", "filename": "library/core/src/panic/location.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -0,0 +1,189 @@\n+use crate::fmt;\n+\n+/// A struct containing information about the location of a panic.\n+///\n+/// This structure is created by [`PanicInfo::location()`].\n+///\n+/// [`PanicInfo::location()`]: crate::panic::PanicInfo::location\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     if let Some(location) = panic_info.location() {\n+///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n+///     } else {\n+///         println!(\"panic occurred but can't get location information...\");\n+///     }\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+///\n+/// # Comparisons\n+///\n+/// Comparisons for equality and ordering are made in file, line, then column priority.\n+/// Files are compared as strings, not `Path`, which could be unexpected.\n+/// See [`Location::file`]'s documentation for more discussion.\n+#[lang = \"panic_location\"]\n+#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub struct Location<'a> {\n+    file: &'a str,\n+    line: u32,\n+    col: u32,\n+}\n+\n+impl<'a> Location<'a> {\n+    /// Returns the source location of the caller of this function. If that function's caller is\n+    /// annotated then its call location will be returned, and so on up the stack to the first call\n+    /// within a non-tracked function body.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::panic::Location;\n+    ///\n+    /// /// Returns the [`Location`] at which it is called.\n+    /// #[track_caller]\n+    /// fn get_caller_location() -> &'static Location<'static> {\n+    ///     Location::caller()\n+    /// }\n+    ///\n+    /// /// Returns a [`Location`] from within this function's definition.\n+    /// fn get_just_one_location() -> &'static Location<'static> {\n+    ///     get_caller_location()\n+    /// }\n+    ///\n+    /// let fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), file!());\n+    /// assert_eq!(fixed_location.line(), 14);\n+    /// assert_eq!(fixed_location.column(), 5);\n+    ///\n+    /// // running the same untracked function in a different location gives us the same result\n+    /// let second_fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n+    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n+    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n+    ///\n+    /// let this_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), file!());\n+    /// assert_eq!(this_location.line(), 28);\n+    /// assert_eq!(this_location.column(), 21);\n+    ///\n+    /// // running the tracked function in a different location produces a different value\n+    /// let another_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), another_location.file());\n+    /// assert_ne!(this_location.line(), another_location.line());\n+    /// assert_ne!(this_location.column(), another_location.column());\n+    /// ```\n+    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n+    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n+    #[track_caller]\n+    pub const fn caller() -> &'static Location<'static> {\n+        crate::intrinsics::caller_location()\n+    }\n+\n+    /// Returns the name of the source file from which the panic originated.\n+    ///\n+    /// # `&str`, not `&Path`\n+    ///\n+    /// The returned name refers to a source path on the compiling system, but it isn't valid to\n+    /// represent this directly as a `&Path`. The compiled code may run on a different system with\n+    /// a different `Path` implementation than the system providing the contents and this library\n+    /// does not currently have a different \"host path\" type.\n+    ///\n+    /// The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in\n+    /// the module system (usually using the `#[path = \"...\"]` attribute or similar), which can\n+    /// cause what appears to be identical code to return differing values from this function.\n+    ///\n+    /// # Cross-compilation\n+    ///\n+    /// This value is not suitable for passing to `Path::new` or similar constructors when the host\n+    /// platform and target platform differ.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}'\", location.file());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn file(&self) -> &str {\n+        self.file\n+    }\n+\n+    /// Returns the line number from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at line {}\", location.line());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn line(&self) -> u32 {\n+        self.line\n+    }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n+}\n+\n+#[unstable(\n+    feature = \"panic_internals\",\n+    reason = \"internal details of the implementation of the `panic!` and related macros\",\n+    issue = \"none\"\n+)]\n+impl<'a> Location<'a> {\n+    #[doc(hidden)]\n+    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n+        Location { file, line, col }\n+    }\n+}\n+\n+#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n+impl fmt::Display for Location<'_> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n+    }\n+}"}, {"sha": "a52a0022e5d2bd7c2b02ba67d9d81e0597edc6e5", "filename": "library/core/src/panic/panic_info.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -0,0 +1,145 @@\n+use crate::any::Any;\n+use crate::fmt;\n+use crate::panic::Location;\n+\n+/// A struct providing information about a panic.\n+///\n+/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n+/// function.\n+///\n+/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n+///         println!(\"panic occurred: {:?}\", s);\n+///     } else {\n+///         println!(\"panic occurred\");\n+///     }\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+#[lang = \"panic_info\"]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+#[derive(Debug)]\n+pub struct PanicInfo<'a> {\n+    payload: &'a (dyn Any + Send),\n+    message: Option<&'a fmt::Arguments<'a>>,\n+    location: &'a Location<'a>,\n+}\n+\n+impl<'a> PanicInfo<'a> {\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` and related macros\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    #[inline]\n+    pub fn internal_constructor(\n+        message: Option<&'a fmt::Arguments<'a>>,\n+        location: &'a Location<'a>,\n+    ) -> Self {\n+        struct NoPayload;\n+        PanicInfo { location, message, payload: &NoPayload }\n+    }\n+\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` and related macros\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    #[inline]\n+    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n+        self.payload = info;\n+    }\n+\n+    /// Returns the payload associated with the panic.\n+    ///\n+    /// This will commonly, but not always, be a `&'static str` or [`String`].\n+    ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n+    ///         println!(\"panic occurred: {:?}\", s);\n+    ///     } else {\n+    ///         println!(\"panic occurred\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn payload(&self) -> &(dyn Any + Send) {\n+        self.payload\n+    }\n+\n+    /// If the `panic!` macro from the `core` crate (not from `std`)\n+    /// was used with a formatting string and some additional arguments,\n+    /// returns that message ready to be used for example with [`fmt::write`]\n+    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n+    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n+        self.message\n+    }\n+\n+    /// Returns information about the location from which the panic originated,\n+    /// if available.\n+    ///\n+    /// This method will currently always return [`Some`], but this may change\n+    /// in future versions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}' at line {}\",\n+    ///             location.file(),\n+    ///             location.line(),\n+    ///         );\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn location(&self) -> Option<&Location<'_>> {\n+        // NOTE: If this is changed to sometimes return None,\n+        // deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.\n+        Some(&self.location)\n+    }\n+}\n+\n+#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n+impl fmt::Display for PanicInfo<'_> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.write_str(\"panicked at \")?;\n+        if let Some(message) = self.message {\n+            write!(formatter, \"'{}', \", message)?\n+        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n+            write!(formatter, \"'{}', \", payload)?\n+        }\n+        // NOTE: we cannot use downcast_ref::<String>() here\n+        // since String is not available in libcore!\n+        // The payload is a String when `std::panic!` is called with multiple arguments,\n+        // but in that case the message is also available.\n+\n+        self.location.fmt(formatter)\n+    }\n+}"}, {"sha": "092b7cf0f2cd57b6223ab20866da1147e225867a", "filename": "library/core/src/panic/unwind_safe.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -0,0 +1,305 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::future::Future;\n+use crate::ops::{Deref, DerefMut};\n+use crate::pin::Pin;\n+use crate::ptr::{NonNull, Unique};\n+use crate::stream::Stream;\n+use crate::task::{Context, Poll};\n+\n+/// A marker trait which represents \"panic safe\" types in Rust.\n+///\n+/// This trait is implemented by default for many types and behaves similarly in\n+/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n+/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n+/// boundary with no fear of unwind safety.\n+///\n+/// [`catch_unwind`]: ../../std/panic/fn.catch_unwind.html\n+///\n+/// ## What is unwind safety?\n+///\n+/// In Rust a function can \"return\" early if it either panics or calls a\n+/// function which transitively panics. This sort of control flow is not always\n+/// anticipated, and has the possibility of causing subtle bugs through a\n+/// combination of two critical components:\n+///\n+/// 1. A data structure is in a temporarily invalid state when the thread\n+///    panics.\n+/// 2. This broken invariant is then later observed.\n+///\n+/// Typically in Rust, it is difficult to perform step (2) because catching a\n+/// panic involves either spawning a thread (which in turns makes it difficult\n+/// to later witness broken invariants) or using the `catch_unwind` function in this\n+/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n+/// problem in Rust because there are no uninitialized values (like in C or C++).\n+///\n+/// It is possible, however, for **logical** invariants to be broken in Rust,\n+/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n+/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n+/// memory unsafety.\n+///\n+/// That was a bit of a whirlwind tour of unwind safety, but for more information\n+/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n+///\n+/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n+///\n+/// ## What is `UnwindSafe`?\n+///\n+/// Now that we've got an idea of what unwind safety is in Rust, it's also\n+/// important to understand what this trait represents. As mentioned above, one\n+/// way to witness broken invariants is through the `catch_unwind` function in this\n+/// module as it allows catching a panic and then re-using the environment of\n+/// the closure.\n+///\n+/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n+/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n+/// panic). This trait is an auto trait, so it is automatically implemented for\n+/// many types, and it is also structurally composed (e.g., a struct is unwind\n+/// safe if all of its components are unwind safe).\n+///\n+/// Note, however, that this is not an unsafe trait, so there is not a succinct\n+/// contract that this trait is providing. Instead it is intended as more of a\n+/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n+/// witnessed and may need to be accounted for.\n+///\n+/// ## Who implements `UnwindSafe`?\n+///\n+/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n+/// unwind safe. The general idea is that any mutable state which can be shared\n+/// across `catch_unwind` is not unwind safe by default. This is because it is very\n+/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n+/// simply accessed as usual.\n+///\n+/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n+/// poisoning by default. They still allow witnessing a broken invariant, but\n+/// they already provide their own \"speed bumps\" to do so.\n+///\n+/// ## When should `UnwindSafe` be used?\n+///\n+/// It is not intended that most types or functions need to worry about this trait.\n+/// It is only used as a bound on the `catch_unwind` function and as mentioned\n+/// above, the lack of `unsafe` means it is mostly an advisory. The\n+/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n+/// implemented for any closed over variables passed to `catch_unwind`.\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"unwind_safe_trait\")]\n+#[rustc_on_unimplemented(\n+    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n+    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n+)]\n+pub auto trait UnwindSafe {}\n+\n+/// A marker trait representing types where a shared reference is considered\n+/// unwind safe.\n+///\n+/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n+/// interior mutability.\n+///\n+/// This is a \"helper marker trait\" used to provide impl blocks for the\n+/// [`UnwindSafe`] trait, for more information see that documentation.\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"ref_unwind_safe_trait\")]\n+#[rustc_on_unimplemented(\n+    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n+               transferrable across a catch_unwind boundary\",\n+    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n+             transferrable across a catch_unwind boundary\"\n+)]\n+pub auto trait RefUnwindSafe {}\n+\n+/// A simple wrapper around a type to assert that it is unwind safe.\n+///\n+/// When using [`catch_unwind`] it may be the case that some of the closed over\n+/// variables are not unwind safe. For example if `&mut T` is captured the\n+/// compiler will generate a warning indicating that it is not unwind safe. It\n+/// might not be the case, however, that this is actually a problem due to the\n+/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n+/// account. This wrapper struct is useful for a quick and lightweight\n+/// annotation that a variable is indeed unwind safe.\n+///\n+/// [`catch_unwind`]: ../../std/panic/fn.catch_unwind.html\n+///\n+/// # Examples\n+///\n+/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n+/// itself is unwind safe, bypassing all checks for all variables:\n+///\n+/// ```\n+/// use std::panic::{self, AssertUnwindSafe};\n+///\n+/// let mut variable = 4;\n+///\n+/// // This code will not compile because the closure captures `&mut variable`\n+/// // which is not considered unwind safe by default.\n+///\n+/// // panic::catch_unwind(|| {\n+/// //     variable += 3;\n+/// // });\n+///\n+/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n+/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n+///     variable += 3;\n+/// }));\n+/// // ...\n+/// ```\n+///\n+/// Wrapping the entire closure amounts to a blanket assertion that all captured\n+/// variables are unwind safe. This has the downside that if new captures are\n+/// added in the future, they will also be considered unwind safe. Therefore,\n+/// you may prefer to just wrap individual captures, as shown below. This is\n+/// more annotation, but it ensures that if a new capture is added which is not\n+/// unwind safe, you will get a compilation error at that time, which will\n+/// allow you to consider whether that new capture in fact represent a bug or\n+/// not.\n+///\n+/// ```\n+/// use std::panic::{self, AssertUnwindSafe};\n+///\n+/// let mut variable = 4;\n+/// let other_capture = 3;\n+///\n+/// let result = {\n+///     let mut wrapper = AssertUnwindSafe(&mut variable);\n+///     panic::catch_unwind(move || {\n+///         **wrapper += other_capture;\n+///     })\n+/// };\n+/// // ...\n+/// ```\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n+\n+// Implementations of the `UnwindSafe` trait:\n+//\n+// * By default everything is unwind safe\n+// * pointers T contains mutability of some form are not unwind safe\n+// * Unique, an owning pointer, lifts an implementation\n+// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n+// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> !UnwindSafe for &mut T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n+#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n+impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n+\n+// Pretty simple implementations for the `RefUnwindSafe` marker trait,\n+// basically just saying that `UnsafeCell` is the\n+// only thing which doesn't implement it (which then transitively applies to\n+// everything else).\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicIsize {}\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicI8 {}\n+#[cfg(target_has_atomic_load_store = \"16\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicI16 {}\n+#[cfg(target_has_atomic_load_store = \"32\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicI32 {}\n+#[cfg(target_has_atomic_load_store = \"64\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicI64 {}\n+#[cfg(target_has_atomic_load_store = \"128\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicI128 {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicUsize {}\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicU8 {}\n+#[cfg(target_has_atomic_load_store = \"16\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicU16 {}\n+#[cfg(target_has_atomic_load_store = \"32\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicU32 {}\n+#[cfg(target_has_atomic_load_store = \"64\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicU64 {}\n+#[cfg(target_has_atomic_load_store = \"128\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicU128 {}\n+\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for crate::sync::atomic::AtomicBool {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl<T> RefUnwindSafe for crate::sync::atomic::AtomicPtr<T> {}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> Deref for AssertUnwindSafe<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> DerefMut for AssertUnwindSafe<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n+        (self.0)()\n+    }\n+}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n+    }\n+}\n+\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+impl<F: Future> Future for AssertUnwindSafe<F> {\n+    type Output = F::Output;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        // SAFETY: pin projection. AssertUnwindSafe follows structural pinning.\n+        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n+        F::poll(pinned_field, cx)\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: Stream> Stream for AssertUnwindSafe<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n+        // SAFETY: pin projection. AssertUnwindSafe follows structural pinning.\n+        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}"}, {"sha": "c1c039584979d3817f876da3929daf69d1fb0433", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 4, "deletions": 309, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381e77d3590bc36f09b0d48cffb504f92febf5e/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=f381e77d3590bc36f09b0d48cffb504f92febf5e", "patch": "@@ -3,19 +3,9 @@\n #![stable(feature = \"std_panic\", since = \"1.9.0\")]\n \n use crate::any::Any;\n-use crate::cell::UnsafeCell;\n use crate::collections;\n-use crate::fmt;\n-use crate::future::Future;\n-use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n-use crate::pin::Pin;\n-use crate::ptr::{NonNull, Unique};\n-use crate::rc::Rc;\n-use crate::stream::Stream;\n-use crate::sync::atomic;\n-use crate::sync::{Arc, Mutex, RwLock};\n-use crate::task::{Context, Poll};\n+use crate::sync::{Mutex, RwLock};\n use crate::thread::Result;\n \n #[doc(hidden)]\n@@ -45,6 +35,9 @@ pub use crate::panicking::{set_hook, take_hook};\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use core::panic::{Location, PanicInfo};\n \n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub use core::panic::{AssertUnwindSafe, RefUnwindSafe, UnwindSafe};\n+\n /// Panic the current thread with the given message as the panic payload.\n ///\n /// The message can be of any (`Any + Send`) type, not just strings.\n@@ -60,259 +53,16 @@ pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n     crate::panicking::begin_panic(msg);\n }\n \n-/// A marker trait which represents \"panic safe\" types in Rust.\n-///\n-/// This trait is implemented by default for many types and behaves similarly in\n-/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n-/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n-/// boundary with no fear of unwind safety.\n-///\n-/// ## What is unwind safety?\n-///\n-/// In Rust a function can \"return\" early if it either panics or calls a\n-/// function which transitively panics. This sort of control flow is not always\n-/// anticipated, and has the possibility of causing subtle bugs through a\n-/// combination of two critical components:\n-///\n-/// 1. A data structure is in a temporarily invalid state when the thread\n-///    panics.\n-/// 2. This broken invariant is then later observed.\n-///\n-/// Typically in Rust, it is difficult to perform step (2) because catching a\n-/// panic involves either spawning a thread (which in turns makes it difficult\n-/// to later witness broken invariants) or using the `catch_unwind` function in this\n-/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n-/// problem in Rust because there are no uninitialized values (like in C or C++).\n-///\n-/// It is possible, however, for **logical** invariants to be broken in Rust,\n-/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n-/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n-/// memory unsafety.\n-///\n-/// That was a bit of a whirlwind tour of unwind safety, but for more information\n-/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n-///\n-/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n-///\n-/// ## What is `UnwindSafe`?\n-///\n-/// Now that we've got an idea of what unwind safety is in Rust, it's also\n-/// important to understand what this trait represents. As mentioned above, one\n-/// way to witness broken invariants is through the `catch_unwind` function in this\n-/// module as it allows catching a panic and then re-using the environment of\n-/// the closure.\n-///\n-/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n-/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n-/// panic). This trait is an auto trait, so it is automatically implemented for\n-/// many types, and it is also structurally composed (e.g., a struct is unwind\n-/// safe if all of its components are unwind safe).\n-///\n-/// Note, however, that this is not an unsafe trait, so there is not a succinct\n-/// contract that this trait is providing. Instead it is intended as more of a\n-/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n-/// witnessed and may need to be accounted for.\n-///\n-/// ## Who implements `UnwindSafe`?\n-///\n-/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n-/// unwind safe. The general idea is that any mutable state which can be shared\n-/// across `catch_unwind` is not unwind safe by default. This is because it is very\n-/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n-/// simply accessed as usual.\n-///\n-/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n-/// poisoning by default. They still allow witnessing a broken invariant, but\n-/// they already provide their own \"speed bumps\" to do so.\n-///\n-/// ## When should `UnwindSafe` be used?\n-///\n-/// It is not intended that most types or functions need to worry about this trait.\n-/// It is only used as a bound on the `catch_unwind` function and as mentioned\n-/// above, the lack of `unsafe` means it is mostly an advisory. The\n-/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n-/// implemented for any closed over variables passed to `catch_unwind`.\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"unwind_safe_trait\")]\n-#[rustc_on_unimplemented(\n-    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n-    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n-)]\n-pub auto trait UnwindSafe {}\n-\n-/// A marker trait representing types where a shared reference is considered\n-/// unwind safe.\n-///\n-/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n-/// interior mutability.\n-///\n-/// This is a \"helper marker trait\" used to provide impl blocks for the\n-/// [`UnwindSafe`] trait, for more information see that documentation.\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"ref_unwind_safe_trait\")]\n-#[rustc_on_unimplemented(\n-    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n-               transferrable across a catch_unwind boundary\",\n-    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n-             transferrable across a catch_unwind boundary\"\n-)]\n-pub auto trait RefUnwindSafe {}\n-\n-/// A simple wrapper around a type to assert that it is unwind safe.\n-///\n-/// When using [`catch_unwind`] it may be the case that some of the closed over\n-/// variables are not unwind safe. For example if `&mut T` is captured the\n-/// compiler will generate a warning indicating that it is not unwind safe. It\n-/// might not be the case, however, that this is actually a problem due to the\n-/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n-/// account. This wrapper struct is useful for a quick and lightweight\n-/// annotation that a variable is indeed unwind safe.\n-///\n-/// # Examples\n-///\n-/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n-/// itself is unwind safe, bypassing all checks for all variables:\n-///\n-/// ```\n-/// use std::panic::{self, AssertUnwindSafe};\n-///\n-/// let mut variable = 4;\n-///\n-/// // This code will not compile because the closure captures `&mut variable`\n-/// // which is not considered unwind safe by default.\n-///\n-/// // panic::catch_unwind(|| {\n-/// //     variable += 3;\n-/// // });\n-///\n-/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n-/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n-///     variable += 3;\n-/// }));\n-/// // ...\n-/// ```\n-///\n-/// Wrapping the entire closure amounts to a blanket assertion that all captured\n-/// variables are unwind safe. This has the downside that if new captures are\n-/// added in the future, they will also be considered unwind safe. Therefore,\n-/// you may prefer to just wrap individual captures, as shown below. This is\n-/// more annotation, but it ensures that if a new capture is added which is not\n-/// unwind safe, you will get a compilation error at that time, which will\n-/// allow you to consider whether that new capture in fact represent a bug or\n-/// not.\n-///\n-/// ```\n-/// use std::panic::{self, AssertUnwindSafe};\n-///\n-/// let mut variable = 4;\n-/// let other_capture = 3;\n-///\n-/// let result = {\n-///     let mut wrapper = AssertUnwindSafe(&mut variable);\n-///     panic::catch_unwind(move || {\n-///         **wrapper += other_capture;\n-///     })\n-/// };\n-/// // ...\n-/// ```\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n-\n-// Implementations of the `UnwindSafe` trait:\n-//\n-// * By default everything is unwind safe\n-// * pointers T contains mutability of some form are not unwind safe\n-// * Unique, an owning pointer, lifts an implementation\n-// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n-// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: ?Sized> !UnwindSafe for &mut T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n-#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: ?Sized> UnwindSafe for Mutex<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: ?Sized> UnwindSafe for RwLock<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n-\n-// not covered via the Shared impl above b/c the inner contents use\n-// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n-// impl up one level to Arc/Rc itself\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}\n-\n-// Pretty simple implementations for the `RefUnwindSafe` marker trait,\n-// basically just saying that `UnsafeCell` is the\n-// only thing which doesn't implement it (which then transitively applies to\n-// everything else).\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n \n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicIsize {}\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI8 {}\n-#[cfg(target_has_atomic_load_store = \"16\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI16 {}\n-#[cfg(target_has_atomic_load_store = \"32\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI32 {}\n-#[cfg(target_has_atomic_load_store = \"64\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI64 {}\n-#[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n-impl RefUnwindSafe for atomic::AtomicI128 {}\n-\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU8 {}\n-#[cfg(target_has_atomic_load_store = \"16\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU16 {}\n-#[cfg(target_has_atomic_load_store = \"32\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU32 {}\n-#[cfg(target_has_atomic_load_store = \"64\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU64 {}\n-#[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n-impl RefUnwindSafe for atomic::AtomicU128 {}\n-\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicBool {}\n-\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n-\n // https://github.com/rust-lang/rust/issues/62301\n #[stable(feature = \"hashbrown\", since = \"1.36.0\")]\n impl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\n@@ -323,61 +73,6 @@ where\n {\n }\n \n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> Deref for AssertUnwindSafe<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &self.0\n-    }\n-}\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> DerefMut for AssertUnwindSafe<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.0\n-    }\n-}\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n-    type Output = R;\n-\n-    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n-        (self.0)()\n-    }\n-}\n-\n-#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n-impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n-    }\n-}\n-\n-#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-impl<F: Future> Future for AssertUnwindSafe<F> {\n-    type Output = F::Output;\n-\n-    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, cx)\n-    }\n-}\n-\n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<S: Stream> Stream for AssertUnwindSafe<S> {\n-    type Item = S::Item;\n-\n-    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n-        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-}\n-\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure"}]}