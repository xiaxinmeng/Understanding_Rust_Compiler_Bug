{"sha": "ed938f08a949cb487f7513d4f22f92355a40d2f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkOTM4ZjA4YTk0OWNiNDg3Zjc1MTNkNGYyMmY5MjM1NWE0MGQyZjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-26T03:16:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-06T04:07:02Z"}, "message": "rustc: Attempt to handle super long linker invocations\n\nThis commit adds logic to the compiler to attempt to handle super long linker\ninvocations by falling back to the `@`-file syntax if the invoked command is too\nlarge. Each OS has a limit on how many arguments and how large the arguments can\nbe when spawning a new process, and linkers tend to be one of those programs\nthat can hit the limit!\n\nThe logic implemented here is to unconditionally attempt to spawn a linker and\nthen if it fails to spawn with an error from the OS that indicates the command\nline is too big we attempt a fallback. The fallback is roughly the same for all\nlinkers where an argument pointing to a file, prepended with `@`, is passed.\nThis file then contains all the various arguments that we want to pass to the\nlinker.\n\nCloses #41190", "tree": {"sha": "7ab91cf4fa734cef75f13d7e333cdf41df09a56f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ab91cf4fa734cef75f13d7e333cdf41df09a56f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed938f08a949cb487f7513d4f22f92355a40d2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed938f08a949cb487f7513d4f22f92355a40d2f3", "html_url": "https://github.com/rust-lang/rust/commit/ed938f08a949cb487f7513d4f22f92355a40d2f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed938f08a949cb487f7513d4f22f92355a40d2f3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "html_url": "https://github.com/rust-lang/rust/commit/2f1ef9ef1181298d46e79d5dde6bafeb6483926f"}], "stats": {"total": 322, "additions": 316, "deletions": 6}, "files": [{"sha": "ea68e3b28b668e8047630f476b673c51fc0ec071", "filename": "src/librustc_trans/back/command.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A thin wrapper around `Command` in the standard library which allows us to\n+//! read the arguments that are built up.\n+\n+use std::ffi::{OsStr, OsString};\n+use std::fmt;\n+use std::io;\n+use std::process::{self, Output, Child};\n+\n+pub struct Command {\n+    program: OsString,\n+    args: Vec<OsString>,\n+    env: Vec<(OsString, OsString)>,\n+}\n+\n+impl Command {\n+    pub fn new<P: AsRef<OsStr>>(program: P) -> Command {\n+        Command::_new(program.as_ref())\n+    }\n+\n+    fn _new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_owned(),\n+            args: Vec::new(),\n+            env: Vec::new(),\n+        }\n+    }\n+\n+    pub fn arg<P: AsRef<OsStr>>(&mut self, arg: P) -> &mut Command {\n+        self._arg(arg.as_ref());\n+        self\n+    }\n+\n+    pub fn args<I>(&mut self, args: I) -> &mut Command\n+        where I: IntoIterator,\n+              I::Item: AsRef<OsStr>,\n+    {\n+        for arg in args {\n+            self._arg(arg.as_ref());\n+        }\n+        self\n+    }\n+\n+    fn _arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_owned());\n+    }\n+\n+    pub fn env<K, V>(&mut self, key: K, value: V) -> &mut Command\n+        where K: AsRef<OsStr>,\n+              V: AsRef<OsStr>\n+    {\n+        self._env(key.as_ref(), value.as_ref());\n+        self\n+    }\n+\n+    pub fn envs<I, K, V>(&mut self, envs: I) -> &mut Command\n+        where I: IntoIterator<Item=(K, V)>,\n+              K: AsRef<OsStr>,\n+              V: AsRef<OsStr>\n+    {\n+        for (key, value) in envs {\n+            self._env(key.as_ref(), value.as_ref());\n+        }\n+        self\n+    }\n+\n+    fn _env(&mut self, key: &OsStr, value: &OsStr) {\n+        self.env.push((key.to_owned(), value.to_owned()));\n+    }\n+\n+    pub fn output(&mut self) -> io::Result<Output> {\n+        self.command().output()\n+    }\n+\n+    pub fn spawn(&mut self) -> io::Result<Child> {\n+        self.command().spawn()\n+    }\n+\n+    pub fn command(&self) -> process::Command {\n+        let mut ret = process::Command::new(&self.program);\n+        ret.args(&self.args);\n+        ret.envs(self.env.clone());\n+        return ret\n+    }\n+\n+    // extensions\n+\n+    pub fn get_program(&self) -> &OsStr {\n+        &self.program\n+    }\n+\n+    pub fn get_args(&self) -> &[OsString] {\n+        &self.args\n+    }\n+\n+    pub fn get_env(&self) -> &[(OsString, OsString)] {\n+        &self.env\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.command().fmt(f)\n+    }\n+}"}, {"sha": "ff95acf5d98ea1868112aa9e0abb9a0af48b2cdc", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 106, "deletions": 5, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -12,6 +12,7 @@ extern crate rustc_trans_utils;\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n+use super::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n@@ -38,11 +39,12 @@ use std::ascii;\n use std::char;\n use std::env;\n use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, Read, Write};\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::io::{self, Read, Write, BufWriter};\n use std::mem;\n use std::path::{Path, PathBuf};\n-use std::process::Command;\n+use std::process::{Output, Stdio};\n use std::str;\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n@@ -125,8 +127,13 @@ pub fn msvc_link_exe_cmd(sess: &Session) -> (Command, Vec<(OsString, OsString)>)\n     let tool = windows_registry::find_tool(target, \"link.exe\");\n \n     if let Some(tool) = tool {\n+        let mut cmd = Command::new(tool.path());\n+        cmd.args(tool.args());\n+        for &(ref k, ref v) in tool.env() {\n+            cmd.env(k, v);\n+        }\n         let envs = tool.env().to_vec();\n-        (tool.to_command(), envs)\n+        (cmd, envs)\n     } else {\n         debug!(\"Failed to locate linker.\");\n         (Command::new(\"link.exe\"), vec![])\n@@ -797,7 +804,9 @@ fn link_natively(sess: &Session,\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = time(sess.time_passes(), \"running linker\", || cmd.output());\n+        prog = time(sess.time_passes(), \"running linker\", || {\n+            exec_linker(sess, &mut cmd, tmpdir)\n+        });\n         if !retry_on_segfault || i > 3 {\n             break\n         }\n@@ -875,6 +884,98 @@ fn link_natively(sess: &Session,\n     }\n }\n \n+fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n+    -> io::Result<Output>\n+{\n+    // When attempting to spawn the linker we run a risk of blowing out the\n+    // size limits for spawning a new process with respect to the arguments\n+    // we pass on the command line.\n+    //\n+    // Here we attempt to handle errors from the OS saying \"your list of\n+    // arguments is too big\" by reinvoking the linker again with an `@`-file\n+    // that contains all the arguments. The theory is that this is then\n+    // accepted on all linkers and the linker will read all its options out of\n+    // there instead of looking at the command line.\n+    match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+        Ok(child) => return child.wait_with_output(),\n+        Err(ref e) if command_line_too_big(e) => {}\n+        Err(e) => return Err(e)\n+    }\n+\n+    let file = tmpdir.join(\"linker-arguments\");\n+    let mut cmd2 = Command::new(cmd.get_program());\n+    cmd2.arg(format!(\"@{}\", file.display()));\n+    for &(ref k, ref v) in cmd.get_env() {\n+        cmd2.env(k, v);\n+    }\n+    let mut f = BufWriter::new(File::create(&file)?);\n+    for arg in cmd.get_args() {\n+        writeln!(f, \"{}\", Escape {\n+            arg: arg.to_str().unwrap(),\n+            is_like_msvc: sess.target.target.options.is_like_msvc,\n+        })?;\n+    }\n+    f.into_inner()?;\n+    return cmd2.output();\n+\n+    #[cfg(unix)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(::libc::E2BIG)\n+    }\n+\n+    #[cfg(windows)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n+        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n+    }\n+\n+    struct Escape<'a> {\n+        arg: &'a str,\n+        is_like_msvc: bool,\n+    }\n+\n+    impl<'a> fmt::Display for Escape<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            if self.is_like_msvc {\n+                // This is \"documented\" at\n+                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n+                //\n+                // Unfortunately there's not a great specification of the\n+                // syntax I could find online (at least) but some local\n+                // testing showed that this seemed sufficient-ish to catch\n+                // at least a few edge cases.\n+                write!(f, \"\\\"\")?;\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\"' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+                write!(f, \"\\\"\")?;\n+            } else {\n+                // This is documented at https://linux.die.net/man/1/ld, namely:\n+                //\n+                // > Options in file are separated by whitespace. A whitespace\n+                // > character may be included in an option by surrounding the\n+                // > entire option in either single or double quotes. Any\n+                // > character (including a backslash) may be included by\n+                // > prefixing the character to be included with a backslash.\n+                //\n+                // We put an argument on each line, so all we need to do is\n+                // ensure the line is interpreted as one whole argument.\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\\\\' |\n+                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              crate_type: config::CrateType,"}, {"sha": "487d9e059458c6db2b4eeb63f6f5d8cf4a454256", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -14,11 +14,11 @@ use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n-use std::process::Command;\n \n use context::SharedCrateContext;\n \n use back::archive;\n+use back::command::Command;\n use back::symbol_export::ExportedSymbols;\n use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};"}, {"sha": "1bb9ce432dfbe66d8576772662204834cc64852d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -68,6 +68,7 @@ pub use llvm_util::{init, target_features, print_version, print_passes, print, e\n \n pub mod back {\n     mod archive;\n+    mod command;\n     pub(crate) mod linker;\n     pub mod link;\n     mod lto;"}, {"sha": "309a27fe503ad6fa0cffef92866bc03e88cd0e07", "filename": "src/test/run-make/long-linker-command-lines/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2FMakefile?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs -g\n+\tRUSTC=\"$(RUSTC_ORIGINAL)\" $(call RUN,foo)"}, {"sha": "e6fd6b653667fc535d051d610285ab08d58a7785", "filename": "src/test/run-make/long-linker-command-lines/foo.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines%2Ffoo.rs?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a test which attempts to blow out the system limit with how many\n+// arguments can be passed to a process. This'll successively call rustc with\n+// larger and larger argument lists in an attempt to find one that's way too\n+// big for the system at hand. This file itself is then used as a \"linker\" to\n+// detect when the process creation succeeds.\n+//\n+// Eventually we should see an argument that looks like `@` as we switch from\n+// passing literal arguments to passing everything in the file.\n+\n+use std::env;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write, Read};\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let tmpdir = PathBuf::from(env::var_os(\"TMPDIR\").unwrap());\n+    let ok = tmpdir.join(\"ok\");\n+    if env::var(\"YOU_ARE_A_LINKER\").is_ok() {\n+        if let Some(file) = env::args().find(|a| a.contains(\"@\")) {\n+            fs::copy(&file[1..], &ok).unwrap();\n+        }\n+        return\n+    }\n+\n+    let rustc = env::var_os(\"RUSTC\").unwrap_or(\"rustc\".into());\n+    let me_as_linker = format!(\"linker={}\", env::current_exe().unwrap().display());\n+    for i in (1..).map(|i| i * 100) {\n+        println!(\"attempt: {}\", i);\n+        let file = tmpdir.join(\"bar.rs\");\n+        let mut f = BufWriter::new(File::create(&file).unwrap());\n+        let mut lib_name = String::new();\n+        for _ in 0..i {\n+            lib_name.push_str(\"foo\");\n+        }\n+        for j in 0..i {\n+            writeln!(f, \"#[link(name = \\\"{}{}\\\")]\", lib_name, j).unwrap();\n+        }\n+        writeln!(f, \"extern {{}}\\nfn main() {{}}\").unwrap();\n+        f.into_inner().unwrap();\n+\n+        drop(fs::remove_file(&ok));\n+        let output = Command::new(&rustc)\n+            .arg(&file)\n+            .arg(\"-C\").arg(&me_as_linker)\n+            .arg(\"--out-dir\").arg(&tmpdir)\n+            .env(\"YOU_ARE_A_LINKER\", \"1\")\n+            .output()\n+            .unwrap();\n+\n+        if !output.status.success() {\n+            let stderr = String::from_utf8_lossy(&output.stderr);\n+            panic!(\"status: {}\\nstdout:\\n{}\\nstderr:\\n{}\",\n+                   output.status,\n+                   String::from_utf8_lossy(&output.stdout),\n+                   stderr.lines().map(|l| {\n+                       if l.len() > 200 {\n+                           format!(\"{}...\\n\", &l[..200])\n+                       } else {\n+                           format!(\"{}\\n\", l)\n+                       }\n+                   }).collect::<String>());\n+        }\n+\n+        if !ok.exists() {\n+            continue\n+        }\n+\n+        let mut contents = String::new();\n+        File::open(&ok).unwrap().read_to_string(&mut contents).unwrap();\n+\n+        for j in 0..i {\n+            assert!(contents.contains(&format!(\"{}{}\", lib_name, j)));\n+        }\n+\n+        break\n+    }\n+}"}, {"sha": "27f235d54d46bc74567b6b9020d5303ce2ebe8d7", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ed938f08a949cb487f7513d4f22f92355a40d2f3/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=ed938f08a949cb487f7513d4f22f92355a40d2f3", "patch": "@@ -5,6 +5,7 @@ HOST_RPATH_ENV = \\\n TARGET_RPATH_ENV = \\\n     $(LD_LIB_PATH_ENVVAR)=\"$(TMPDIR):$(TARGET_RPATH_DIR):$($(LD_LIB_PATH_ENVVAR))\"\n \n+RUSTC_ORIGINAL := $(RUSTC)\n BARE_RUSTC := $(HOST_RPATH_ENV) '$(RUSTC)'\n RUSTC := $(BARE_RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR) $(RUSTFLAGS)\n #CC := $(CC) -L $(TMPDIR)"}]}