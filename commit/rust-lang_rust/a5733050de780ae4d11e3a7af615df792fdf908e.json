{"sha": "a5733050de780ae4d11e3a7af615df792fdf908e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NzMzMDUwZGU3ODBhZTRkMTFlM2E3YWY2MTVkZjc5MmZkZjkwOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-14T17:24:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-14T17:24:18Z"}, "message": "Auto merge of #53354 - kennytm:rollup, r=kennytm\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #53112 (pretty print BTreeSet)\n - #53208 (Don't panic on std::env::vars() when env is null.)\n - #53226 (driver: set the syntax edition in phase 1)\n - #53229 (Make sure rlimit is only ever increased)\n - #53233 (targets: aarch64: Add bare-metal aarch64 target)\n - #53239 (rustc_codegen_llvm: Restore the closure env alloca hack for LLVM 5.)\n - #53246 (A few cleanups)\n - #53257 (Idiomatic improvements to IP method)\n - #53274 (Remove statics field from CodegenCx)\n - #53290 (Make LLVM emit assembly comments with -Z asm-comments)\n - #53317 (Mark prior failure to avoid ICE)", "tree": {"sha": "df7f2e100045edfc854e480aaf204711b6560626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df7f2e100045edfc854e480aaf204711b6560626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5733050de780ae4d11e3a7af615df792fdf908e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5733050de780ae4d11e3a7af615df792fdf908e", "html_url": "https://github.com/rust-lang/rust/commit/a5733050de780ae4d11e3a7af615df792fdf908e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5733050de780ae4d11e3a7af615df792fdf908e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f09bbed4ef12c5f9db198c22f50b608ea6c6d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f09bbed4ef12c5f9db198c22f50b608ea6c6d5", "html_url": "https://github.com/rust-lang/rust/commit/23f09bbed4ef12c5f9db198c22f50b608ea6c6d5"}, {"sha": "8e7f69af9ce5ec270b79a5125635cacfaeb936ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7f69af9ce5ec270b79a5125635cacfaeb936ba", "html_url": "https://github.com/rust-lang/rust/commit/8e7f69af9ce5ec270b79a5125635cacfaeb936ba"}], "stats": {"total": 715, "additions": 486, "deletions": 229}, "files": [{"sha": "e64d863717da0019773a6eb0c861ebfd15d32aa1", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -48,6 +48,7 @@\n TYPE_KIND_REGULAR_UNION     = 17\n TYPE_KIND_OS_STRING         = 18\n TYPE_KIND_STD_VECDEQUE      = 19\n+TYPE_KIND_STD_BTREESET      = 20\n \n ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n@@ -71,6 +72,9 @@\n                             STD_VECDEQUE_FIELD_NAME_HEAD,\n                             STD_VECDEQUE_FIELD_NAME_BUF]\n \n+# std::collections::BTreeSet<> related constants\n+STD_BTREESET_FIELD_NAMES = [\"map\"]\n+\n # std::String related constants\n STD_STRING_FIELD_NAMES = [\"vec\"]\n \n@@ -175,6 +179,11 @@ def __classify_struct(self):\n             self.__conforms_to_field_layout(STD_VECDEQUE_FIELD_NAMES)):\n             return TYPE_KIND_STD_VECDEQUE\n \n+        # STD COLLECTION BTREESET\n+        if (unqualified_type_name.startswith(\"BTreeSet<\") and\n+                self.__conforms_to_field_layout(STD_BTREESET_FIELD_NAMES)):\n+            return TYPE_KIND_STD_BTREESET\n+\n         # STD STRING\n         if (unqualified_type_name.startswith(\"String\") and\n             self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n@@ -358,6 +367,19 @@ def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n     return (tail, head, data_ptr, capacity)\n \n \n+def extract_length_and_ptr_from_std_btreeset(vec_val):\n+    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_BTREESET\n+    map = vec_val.get_child_at_index(0)\n+    root = map.get_child_at_index(0)\n+    length = map.get_child_at_index(1).as_integer()\n+    node = root.get_child_at_index(0)\n+    ptr = node.get_child_at_index(0)\n+    unique_ptr_val = ptr.get_child_at_index(0)\n+    data_ptr = unique_ptr_val.get_child_at_index(0)\n+    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n+    return (length, data_ptr)\n+\n+\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)"}, {"sha": "fae1fd0cac30dde40b36f28e31a5b1a9215d340c", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -127,6 +127,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n         return RustStdVecDequePrinter(val)\n \n+    if type_kind == rustpp.TYPE_KIND_STD_BTREESET:\n+        return RustStdBTreeSetPrinter(val)\n+\n     if type_kind == rustpp.TYPE_KIND_STD_STRING:\n         return RustStdStringPrinter(val)\n \n@@ -299,6 +302,29 @@ def children(self):\n             yield (str(index), (gdb_ptr + index).dereference())\n \n \n+class RustStdBTreeSetPrinter(object):\n+    def __init__(self, val):\n+        self.__val = val\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+    def to_string(self):\n+        (length, data_ptr) = \\\n+            rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n+        return (self.__val.type.get_unqualified_type_name() +\n+                (\"(len: %i)\" % length))\n+\n+    def children(self):\n+        (length, data_ptr) = \\\n+            rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n+        val = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(3)\n+        gdb_ptr = val.get_wrapped_value()\n+        for index in xrange(length):\n+            yield (str(index), gdb_ptr[index])\n+\n+\n class RustStdStringPrinter(object):\n     def __init__(self, val):\n         self.__val = val"}, {"sha": "e2380f0fe2ff389464c4fb302de6bf7849e9d6b1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -411,7 +411,7 @@ impl<'a> Parser<'a> {\n \n         // fill character\n         if let Some(&(_, c)) = self.cur.peek() {\n-            match self.cur.clone().skip(1).next() {\n+            match self.cur.clone().nth(1) {\n                 Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n                     spec.fill = Some(c);\n                     self.cur.next();\n@@ -504,13 +504,11 @@ impl<'a> Parser<'a> {\n             if word.is_empty() {\n                 self.cur = tmp;\n                 CountImplied\n+            } else if self.consume('$') {\n+                CountIsName(word)\n             } else {\n-                if self.consume('$') {\n-                    CountIsName(word)\n-                } else {\n-                    self.cur = tmp;\n-                    CountImplied\n-                }\n+                self.cur = tmp;\n+                CountImplied\n             }\n         }\n     }"}, {"sha": "9fa48adebdf07a523411152409a2e1465c07fc37", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -420,7 +420,8 @@ impl<'a> Id<'a> {\n         if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' ) {\n             return Err(());\n         }\n-        return Ok(Id { name: name });\n+\n+        Ok(Id { name })\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n@@ -533,10 +534,10 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     /// This includes quotes or suitable delimiters.\n     pub fn to_dot_string(&self) -> String {\n-        match self {\n-            &LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n-            &EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n-            &HtmlStr(ref s) => format!(\"<{}>\", s),\n+        match *self {\n+            LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n+            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n+            HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n "}, {"sha": "45279f18117c16329e8c45b4c584e89cd47f607b", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -536,23 +536,21 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n         // Check whether we should use scientific notation.\n         let scientific = if width == 0 {\n             true\n+        } else if exp >= 0 {\n+            // 765e3 --> 765000\n+            //              ^^^\n+            // But we shouldn't make the number look more precise than it is.\n+            exp as usize > width || digits + exp as usize > precision\n         } else {\n-            if exp >= 0 {\n-                // 765e3 --> 765000\n-                //              ^^^\n-                // But we shouldn't make the number look more precise than it is.\n-                exp as usize > width || digits + exp as usize > precision\n+            // Power of the most significant digit.\n+            let msd = exp + (digits - 1) as ExpInt;\n+            if msd >= 0 {\n+                // 765e-2 == 7.65\n+                false\n             } else {\n-                // Power of the most significant digit.\n-                let msd = exp + (digits - 1) as ExpInt;\n-                if msd >= 0 {\n-                    // 765e-2 == 7.65\n-                    false\n-                } else {\n-                    // 765e-5 == 0.00765\n-                    //           ^ ^^\n-                    -msd as usize > width\n-                }\n+                // 765e-5 == 0.00765\n+                //           ^ ^^\n+                -msd as usize > width\n             }\n         };\n \n@@ -702,7 +700,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n         //   exponent = 1..10\n         //   significand = 1..1\n         IeeeFloat {\n-            sig: [!0 & ((1 << S::PRECISION) - 1)],\n+            sig: [(1 << S::PRECISION) - 1],\n             exp: S::MAX_EXP,\n             category: Category::Normal,\n             sign: false,\n@@ -1507,10 +1505,11 @@ impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n         }\n \n         // If this is a truncation, perform the shift.\n-        let mut loss = Loss::ExactlyZero;\n-        if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n-            loss = sig::shift_right(&mut r.sig, &mut 0, -shift as usize);\n-        }\n+        let loss = if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            sig::shift_right(&mut r.sig, &mut 0, -shift as usize)\n+        } else {\n+            Loss::ExactlyZero\n+        };\n \n         // If this is an extension, perform the shift.\n         if shift > 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n@@ -1738,27 +1737,25 @@ impl<S: Semantics> IeeeFloat<S> {\n                 bit_pos -= 4;\n                 if bit_pos >= 0 {\n                     r.sig[0] |= (hex_value as Limb) << bit_pos;\n-                } else {\n-                    // If zero or one-half (the hexadecimal digit 8) are followed\n-                    // by non-zero, they're a little more than zero or one-half.\n-                    if let Some(ref mut loss) = loss {\n-                        if hex_value != 0 {\n-                            if *loss == Loss::ExactlyZero {\n-                                *loss = Loss::LessThanHalf;\n-                            }\n-                            if *loss == Loss::ExactlyHalf {\n-                                *loss = Loss::MoreThanHalf;\n-                            }\n+                // If zero or one-half (the hexadecimal digit 8) are followed\n+                // by non-zero, they're a little more than zero or one-half.\n+                } else if let Some(ref mut loss) = loss {\n+                    if hex_value != 0 {\n+                        if *loss == Loss::ExactlyZero {\n+                            *loss = Loss::LessThanHalf;\n+                        }\n+                        if *loss == Loss::ExactlyHalf {\n+                            *loss = Loss::MoreThanHalf;\n                         }\n-                    } else {\n-                        loss = Some(match hex_value {\n-                            0 => Loss::ExactlyZero,\n-                            1..=7 => Loss::LessThanHalf,\n-                            8 => Loss::ExactlyHalf,\n-                            9..=15 => Loss::MoreThanHalf,\n-                            _ => unreachable!(),\n-                        });\n                     }\n+                } else {\n+                    loss = Some(match hex_value {\n+                        0 => Loss::ExactlyZero,\n+                        1..=7 => Loss::LessThanHalf,\n+                        8 => Loss::ExactlyHalf,\n+                        9..=15 => Loss::MoreThanHalf,\n+                        _ => unreachable!(),\n+                    });\n                 }\n             } else if c == 'p' || c == 'P' {\n                 if !any_digits {\n@@ -2309,9 +2306,9 @@ mod sig {\n \n     /// One, not zero, based LSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn olsb(limbs: &[Limb]) -> usize {\n-        for i in 0..limbs.len() {\n-            if limbs[i] != 0 {\n-                return i * LIMB_BITS + limbs[i].trailing_zeros() as usize + 1;\n+        for (i, &limb) in limbs.iter().enumerate() {\n+            if limb != 0 {\n+                return i * LIMB_BITS + limb.trailing_zeros() as usize + 1;\n             }\n         }\n \n@@ -2320,9 +2317,9 @@ mod sig {\n \n     /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn omsb(limbs: &[Limb]) -> usize {\n-        for i in (0..limbs.len()).rev() {\n-            if limbs[i] != 0 {\n-                return (i + 1) * LIMB_BITS - limbs[i].leading_zeros() as usize;\n+        for (i, &limb) in limbs.iter().enumerate().rev() {\n+            if limb != 0 {\n+                return (i + 1) * LIMB_BITS - limb.leading_zeros() as usize;\n             }\n         }\n \n@@ -2378,7 +2375,7 @@ mod sig {\n                     limb = dst[i - jump];\n                     if shift > 0 {\n                         limb <<= shift;\n-                        if i >= jump + 1 {\n+                        if i > jump {\n                             limb |= dst[i - jump - 1] >> (LIMB_BITS - shift);\n                         }\n                     }\n@@ -2448,7 +2445,7 @@ mod sig {\n         let n = dst_limbs * LIMB_BITS - shift;\n         if n < src_bits {\n             let mask = (1 << (src_bits - n)) - 1;\n-            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << n % LIMB_BITS;\n+            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << (n % LIMB_BITS);\n         } else if n > src_bits && src_bits % LIMB_BITS > 0 {\n             dst[dst_limbs - 1] &= (1 << (src_bits % LIMB_BITS)) - 1;\n         }"}, {"sha": "d60983d7697b7e4a94fdfd73a36a2eca4f311251", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -180,6 +180,8 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n \n+    let asm_comments = sess.asm_comments();\n+\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n@@ -193,6 +195,7 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n                 fdata_sections,\n                 trap_unreachable,\n                 singlethread,\n+                asm_comments,\n             )\n         };\n "}, {"sha": "770a22ad65842e0916ec185709828ea86d9efaa5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -230,7 +230,6 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n     }\n \n     cx.instances.borrow_mut().insert(instance, g);\n-    cx.statics.borrow_mut().insert(g, def_id);\n     g\n }\n "}, {"sha": "32ea2c5eb8f354484150233a01af17b36ce900ba", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -13,7 +13,6 @@ use common;\n use llvm;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n use debuginfo;\n use callee;\n use base;\n@@ -78,9 +77,6 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// Cache of emitted const globals (value -> global)\n     pub const_globals: RefCell<FxHashMap<&'a Value, &'a Value>>,\n \n-    /// Mapping from static definitions to their DefId's.\n-    pub statics: RefCell<FxHashMap<&'a Value, DefId>>,\n-\n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when codegen is complete.\n     /// (We have to make sure we don't invalidate any Values referring\n@@ -297,7 +293,6 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n             const_cstr_cache: RefCell::new(FxHashMap()),\n             const_unsized: RefCell::new(FxHashMap()),\n             const_globals: RefCell::new(FxHashMap()),\n-            statics: RefCell::new(FxHashMap()),\n             statics_to_rauw: RefCell::new(Vec::new()),\n             used_statics: RefCell::new(Vec::new()),\n             lltypes: RefCell::new(FxHashMap()),"}, {"sha": "eec8a3a169ced95503e2aa6f240c2a59ed384c46", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -1455,7 +1455,8 @@ extern \"C\" {\n                                        FunctionSections: bool,\n                                        DataSections: bool,\n                                        TrapUnreachable: bool,\n-                                       Singlethread: bool)\n+                                       Singlethread: bool,\n+                                       AsmComments: bool)\n                                        -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>, M: &'a Module);"}, {"sha": "8bb049be30549a237b68b2703767e3d3a61af013", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -574,6 +574,25 @@ fn arg_local_refs(\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n+            // Store the pointer to closure data in an alloca for debuginfo\n+            // because that's what the llvm.dbg.declare intrinsic expects.\n+\n+            // FIXME(eddyb) this shouldn't be necessary but SROA seems to\n+            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e. it\n+            // doesn't actually strip the offset when splitting the closure\n+            // environment into its components so it ends up out of bounds.\n+            // (cuviper) It seems to be fine without the alloca on LLVM 6 and later.\n+            let env_alloca = !env_ref && unsafe { llvm::LLVMRustVersionMajor() < 6 };\n+            let env_ptr = if env_alloca {\n+                let scratch = PlaceRef::alloca(bx,\n+                    bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    \"__debuginfo_env_ptr\");\n+                bx.store(place.llval, scratch.llval, scratch.align);\n+                scratch.llval\n+            } else {\n+                place.llval\n+            };\n+\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n@@ -585,7 +604,10 @@ fn arg_local_refs(\n                 };\n \n                 // The environment and the capture can each be indirect.\n-                let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n+\n+                // FIXME(eddyb) see above why we sometimes have to keep\n+                // a pointer in an alloca for debuginfo atm.\n+                let mut ops = if env_ref || env_alloca { &ops[..] } else { &ops[1..] };\n \n                 let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n                     ty\n@@ -595,7 +617,7 @@ fn arg_local_refs(\n                 };\n \n                 let variable_access = VariableAccess::IndirectVariable {\n-                    alloca: place.llval,\n+                    alloca: env_ptr,\n                     address_operations: &ops\n                 };\n                 declare_local("}, {"sha": "80c4df1d6b0050e353cb454b39e45fdec000055f", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -143,7 +143,6 @@ fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n \n     cx.instances.borrow_mut().insert(instance, g);\n-    cx.statics.borrow_mut().insert(g, def_id);\n }\n \n fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,"}, {"sha": "e5042a4a02076634d1d6f3d5662541a93613f50c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -57,7 +57,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n-use syntax_pos::FileName;\n+use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n use derive_registrar;\n@@ -670,6 +670,7 @@ pub fn phase_1_parse_input<'a>(\n ) -> PResult<'a, ast::Crate> {\n     sess.diagnostic()\n         .set_continue_after_error(control.continue_parse_after_error);\n+    hygiene::set_default_edition(sess.edition());\n \n     if sess.profile_queries() {\n         profile::begin(sess);"}, {"sha": "d25d57a004b5f64eeb6c6c25174ca2410a7ed71d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -110,7 +110,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n-use syntax_pos::{hygiene, DUMMY_SP, MultiSpan, FileName};\n+use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n #[cfg(test)]\n mod test;\n@@ -478,7 +478,6 @@ pub fn run_compiler<'a>(args: &[String],\n         };\n \n         let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n-        hygiene::set_default_edition(sopts.edition);\n \n         driver::spawn_thread_pool(sopts, |sopts| {\n             run_compiler_with_pool(matches, sopts, cfg, callbacks, file_loader, emitter_dest)\n@@ -1513,7 +1512,7 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n             true\n         } else if rlim.rlim_max < STACK_SIZE as libc::rlim_t {\n             true\n-        } else {\n+        } else if rlim.rlim_cur < STACK_SIZE as libc::rlim_t {\n             std::rt::deinit_stack_guard();\n             rlim.rlim_cur = STACK_SIZE as libc::rlim_t;\n             if libc::setrlimit(libc::RLIMIT_STACK, &mut rlim) != 0 {\n@@ -1525,6 +1524,8 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n                 std::rt::update_stack_guard();\n                 false\n             }\n+        } else {\n+            false\n         }\n     };\n "}, {"sha": "cfba0614adcd6c4b3033b27ac3acd900f874283f", "filename": "src/librustc_target/spec/aarch64_unknown_none.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Generic AArch64 target for bare-metal code\n+//\n+// Can be used in conjunction with the `target-feature` and\n+// `target-cpu` compiler flags to opt-in more hardware-specific\n+// features.\n+//\n+// For example, `-C target-cpu=cortex-a53`.\n+\n+use super::{LldFlavor, LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+\n+pub fn target() -> Result<Target, String> {\n+    let opts = TargetOptions {\n+        linker: Some(\"rust-lld\".to_owned()),\n+        executables: true,\n+        relocation_model: \"static\".to_string(),\n+        disable_redzone: true,\n+        linker_is_gnu: true,\n+        max_atomic_width: Some(128),\n+        panic_strategy: PanicStrategy::Abort,\n+        abi_blacklist: super::arm_base::abi_blacklist(),\n+        .. Default::default()\n+    };\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-none\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+        options: opts,\n+    })\n+}"}, {"sha": "d55762e03eee3d3e3a40a8ded6e9c1f060a6ea2d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -380,6 +380,8 @@ supported_targets! {\n     (\"x86_64-unknown-hermit\", x86_64_unknown_hermit),\n \n     (\"riscv32imac-unknown-none-elf\", riscv32imac_unknown_none_elf),\n+\n+    (\"aarch64-unknown-none\", aarch64_unknown_none),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target.\n@@ -765,14 +767,10 @@ impl Target {\n         // the JSON parser is not updated to match the structs.\n \n         let get_req_field = |name: &str| {\n-            match obj.find(name)\n-                     .map(|s| s.as_string())\n-                     .and_then(|os| os.map(|s| s.to_string())) {\n-                Some(val) => Ok(val),\n-                None => {\n-                    return Err(format!(\"Field {} in target specification is required\", name))\n-                }\n-            }\n+            obj.find(name)\n+               .map(|s| s.as_string())\n+               .and_then(|os| os.map(|s| s.to_string()))\n+               .ok_or_else(|| format!(\"Field {} in target specification is required\", name))\n         };\n \n         let get_opt_field = |name: &str, default: &str| {"}, {"sha": "43edb23504480f0fe485855a480e5bb4e5f8e46e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -5154,6 +5154,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             None\n         } {\n+            self.set_tainted_by_errors(); // #53251\n             err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n         }\n "}, {"sha": "569815c833adaa533fad4dfee5143cbd959a01e0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -37,7 +37,7 @@ use syntax::codemap::CodeMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::with_globals;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName, hygiene};\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -562,7 +562,6 @@ impl Collector {\n                     rustc_driver::in_named_rustc_thread(name, move || with_globals(move || {\n                         io::set_panic(panic);\n                         io::set_print(print);\n-                        hygiene::set_default_edition(edition);\n                         run_test(&test,\n                                  &cratename,\n                                  &filename,"}, {"sha": "7f3736e82caa66e10de1f1a1782f0b4a2a8e96f6", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -22,7 +22,7 @@ pub trait ToHex {\n     fn to_hex(&self) -> String;\n }\n \n-const CHARS: &'static [u8] = b\"0123456789abcdef\";\n+const CHARS: &[u8] = b\"0123456789abcdef\";\n \n impl ToHex for [u8] {\n     /// Turn a vector of `u8` bytes into a hexadecimal string."}, {"sha": "0361718eb7337d9fb9003605b4bdbaa6dc116189", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -438,7 +438,7 @@ fn escape_char(writer: &mut dyn fmt::Write, v: char) -> EncodeResult {\n }\n \n fn spaces(wr: &mut dyn fmt::Write, mut n: usize) -> EncodeResult {\n-    const BUF: &'static str = \"                \";\n+    const BUF: &str = \"                \";\n \n     while n >= BUF.len() {\n         wr.write_str(BUF)?;\n@@ -799,21 +799,21 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             escape_str(self.writer, name)\n         } else {\n             if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-            write!(self.writer, \"{{\\n\")?;\n+            writeln!(self.writer, \"{{\")?;\n             self.curr_indent += self.indent;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"\\\"variant\\\": \")?;\n             escape_str(self.writer, name)?;\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n             spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"\\\"fields\\\": [\\n\")?;\n+            writeln!(self.writer, \"\\\"fields\\\": [\")?;\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"]\\n\")?;\n+            writeln!(self.writer, \"]\")?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n             Ok(())\n@@ -825,7 +825,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n@@ -864,7 +864,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n         }\n@@ -876,9 +876,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         escape_str(self.writer, name)?;\n@@ -940,7 +940,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"]\")?;\n         }\n@@ -952,9 +952,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n@@ -971,7 +971,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n         }\n@@ -983,9 +983,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         self.is_emitting_map_key = true;\n@@ -1387,10 +1387,10 @@ impl Stack {\n \n     // Used by Parser to test whether the top-most element is an index.\n     fn last_is_index(&self) -> bool {\n-        if self.is_empty() { return false; }\n-        return match *self.stack.last().unwrap() {\n-            InternalIndex(_) => true,\n-            _ => false,\n+        if let Some(InternalIndex(_)) = self.stack.last() {\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -1530,19 +1530,17 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             }\n \n             F64Value(res)\n-        } else {\n-            if neg {\n-                let res = (res as i64).wrapping_neg();\n+        } else if neg {\n+            let res = (res as i64).wrapping_neg();\n \n-                // Make sure we didn't underflow.\n-                if res > 0 {\n-                    Error(SyntaxError(InvalidNumber, self.line, self.col))\n-                } else {\n-                    I64Value(res)\n-                }\n+            // Make sure we didn't underflow.\n+            if res > 0 {\n+                Error(SyntaxError(InvalidNumber, self.line, self.col))\n             } else {\n-                U64Value(res)\n+                I64Value(res)\n             }\n+        } else {\n+            U64Value(res)\n         }\n     }\n "}, {"sha": "eee95d9fa67774406bb3569ab95fb9a0a8672621", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -103,8 +103,8 @@ pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W)\n     loop {\n         let mut byte = (value as u8) & 0x7f;\n         value >>= 7;\n-        let more = !((((value == 0) && ((byte & 0x40) == 0)) ||\n-                      ((value == -1) && ((byte & 0x40) != 0))));\n+        let more = !(((value == 0) && ((byte & 0x40) == 0)) ||\n+                     ((value == -1) && ((byte & 0x40) != 0)));\n \n         if more {\n             byte |= 0x80; // Mark this byte to show that more bytes will follow."}, {"sha": "9a610cd7d6ba3978df157f3209a7d5d98d865ff1", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -160,9 +160,9 @@ impl IpAddr {\n     /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_unspecified(&self) -> bool {\n-        match *self {\n-            IpAddr::V4(ref a) => a.is_unspecified(),\n-            IpAddr::V6(ref a) => a.is_unspecified(),\n+        match self {\n+            IpAddr::V4(ip) => ip.is_unspecified(),\n+            IpAddr::V6(ip) => ip.is_unspecified(),\n         }\n     }\n \n@@ -185,9 +185,9 @@ impl IpAddr {\n     /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_loopback(&self) -> bool {\n-        match *self {\n-            IpAddr::V4(ref a) => a.is_loopback(),\n-            IpAddr::V6(ref a) => a.is_loopback(),\n+        match self {\n+            IpAddr::V4(ip) => ip.is_loopback(),\n+            IpAddr::V6(ip) => ip.is_loopback(),\n         }\n     }\n \n@@ -214,9 +214,9 @@ impl IpAddr {\n     /// }\n     /// ```\n     pub fn is_global(&self) -> bool {\n-        match *self {\n-            IpAddr::V4(ref a) => a.is_global(),\n-            IpAddr::V6(ref a) => a.is_global(),\n+        match self {\n+            IpAddr::V4(ip) => ip.is_global(),\n+            IpAddr::V6(ip) => ip.is_global(),\n         }\n     }\n \n@@ -239,9 +239,9 @@ impl IpAddr {\n     /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_multicast(&self) -> bool {\n-        match *self {\n-            IpAddr::V4(ref a) => a.is_multicast(),\n-            IpAddr::V6(ref a) => a.is_multicast(),\n+        match self {\n+            IpAddr::V4(ip) => ip.is_multicast(),\n+            IpAddr::V6(ip) => ip.is_multicast(),\n         }\n     }\n \n@@ -268,9 +268,9 @@ impl IpAddr {\n     /// }\n     /// ```\n     pub fn is_documentation(&self) -> bool {\n-        match *self {\n-            IpAddr::V4(ref a) => a.is_documentation(),\n-            IpAddr::V6(ref a) => a.is_documentation(),\n+        match self {\n+            IpAddr::V4(ip) => ip.is_documentation(),\n+            IpAddr::V6(ip) => ip.is_documentation(),\n         }\n     }\n \n@@ -293,7 +293,7 @@ impl IpAddr {\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n-        match *self {\n+        match self {\n             IpAddr::V4(_) => true,\n             IpAddr::V6(_) => false,\n         }\n@@ -318,7 +318,7 @@ impl IpAddr {\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n-        match *self {\n+        match self {\n             IpAddr::V4(_) => false,\n             IpAddr::V6(_) => true,\n         }\n@@ -483,11 +483,11 @@ impl Ipv4Addr {\n     /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_private(&self) -> bool {\n-        match (self.octets()[0], self.octets()[1]) {\n-            (10, _) => true,\n-            (172, b) if b >= 16 && b <= 31 => true,\n-            (192, 168) => true,\n-            _ => false\n+        match self.octets() {\n+            [10, ..] => true,\n+            [172, b, ..] if b >= 16 && b <= 31 => true,\n+            [192, 168, ..] => true,\n+            _ => false,\n         }\n     }\n \n@@ -509,7 +509,10 @@ impl Ipv4Addr {\n     /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_link_local(&self) -> bool {\n-        self.octets()[0] == 169 && self.octets()[1] == 254\n+        match self.octets() {\n+            [169, 254, ..] => true,\n+            _ => false,\n+        }\n     }\n \n     /// Returns [`true`] if the address appears to be globally routable.\n@@ -612,11 +615,11 @@ impl Ipv4Addr {\n     /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_documentation(&self) -> bool {\n-        match(self.octets()[0], self.octets()[1], self.octets()[2], self.octets()[3]) {\n-            (192, 0, 2, _) => true,\n-            (198, 51, 100, _) => true,\n-            (203, 0, 113, _) => true,\n-            _ => false\n+        match self.octets() {\n+            [192, 0, 2, _] => true,\n+            [198, 51, 100, _] => true,\n+            [203, 0, 113, _] => true,\n+            _ => false,\n         }\n     }\n \n@@ -666,9 +669,9 @@ impl Ipv4Addr {\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n impl fmt::Display for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            IpAddr::V4(ref a) => a.fmt(fmt),\n-            IpAddr::V6(ref a) => a.fmt(fmt),\n+        match self {\n+            IpAddr::V4(ip) => ip.fmt(fmt),\n+            IpAddr::V6(ip) => ip.fmt(fmt),\n         }\n     }\n }\n@@ -717,8 +720,8 @@ impl PartialEq for Ipv4Addr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<Ipv4Addr> for IpAddr {\n     fn eq(&self, other: &Ipv4Addr) -> bool {\n-        match *self {\n-            IpAddr::V4(ref v4) => v4 == other,\n+        match self {\n+            IpAddr::V4(v4) => v4 == other,\n             IpAddr::V6(_) => false,\n         }\n     }\n@@ -727,8 +730,8 @@ impl PartialEq<Ipv4Addr> for IpAddr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<IpAddr> for Ipv4Addr {\n     fn eq(&self, other: &IpAddr) -> bool {\n-        match *other {\n-            IpAddr::V4(ref v4) => self == v4,\n+        match other {\n+            IpAddr::V4(v4) => self == v4,\n             IpAddr::V6(_) => false,\n         }\n     }\n@@ -755,8 +758,8 @@ impl PartialOrd for Ipv4Addr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialOrd<Ipv4Addr> for IpAddr {\n     fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n-        match *self {\n-            IpAddr::V4(ref v4) => v4.partial_cmp(other),\n+        match self {\n+            IpAddr::V4(v4) => v4.partial_cmp(other),\n             IpAddr::V6(_) => Some(Ordering::Greater),\n         }\n     }\n@@ -765,8 +768,8 @@ impl PartialOrd<Ipv4Addr> for IpAddr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialOrd<IpAddr> for Ipv4Addr {\n     fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match *other {\n-            IpAddr::V4(ref v4) => self.partial_cmp(v4),\n+        match other {\n+            IpAddr::V4(v4) => self.partial_cmp(v4),\n             IpAddr::V6(_) => Some(Ordering::Less),\n         }\n     }\n@@ -1335,19 +1338,19 @@ impl PartialEq for Ipv6Addr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<IpAddr> for Ipv6Addr {\n     fn eq(&self, other: &IpAddr) -> bool {\n-        match *other {\n+        match other {\n             IpAddr::V4(_) => false,\n-            IpAddr::V6(ref v6) => self == v6,\n+            IpAddr::V6(v6) => self == v6,\n         }\n     }\n }\n \n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<Ipv6Addr> for IpAddr {\n     fn eq(&self, other: &Ipv6Addr) -> bool {\n-        match *self {\n+        match self {\n             IpAddr::V4(_) => false,\n-            IpAddr::V6(ref v6) => v6 == other,\n+            IpAddr::V6(v6) => v6 == other,\n         }\n     }\n }\n@@ -1372,19 +1375,19 @@ impl PartialOrd for Ipv6Addr {\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialOrd<Ipv6Addr> for IpAddr {\n     fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n-        match *self {\n+        match self {\n             IpAddr::V4(_) => Some(Ordering::Less),\n-            IpAddr::V6(ref v6) => v6.partial_cmp(other),\n+            IpAddr::V6(v6) => v6.partial_cmp(other),\n         }\n     }\n }\n \n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialOrd<IpAddr> for Ipv6Addr {\n     fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match *other {\n+        match other {\n             IpAddr::V4(_) => Some(Ordering::Greater),\n-            IpAddr::V6(ref v6) => self.partial_cmp(v6),\n+            IpAddr::V6(v6) => self.partial_cmp(v6),\n         }\n     }\n }"}, {"sha": "f8f0bbd5bc25070cb042394e56ba9ead29009e34", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -414,12 +414,8 @@ pub fn env() -> Env {\n     unsafe {\n         let _guard = ENV_LOCK.lock();\n         let mut environ = *environ();\n-        if environ == ptr::null() {\n-            panic!(\"os::env() failure getting env string from OS: {}\",\n-                   io::Error::last_os_error());\n-        }\n         let mut result = Vec::new();\n-        while *environ != ptr::null() {\n+        while environ != ptr::null() && *environ != ptr::null() {\n             if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                 result.push(key_value);\n             }"}, {"sha": "adfc7078ebacb6d05f86981a06c01c5b1c86c5d4", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -60,8 +60,8 @@ impl error::Error for Error {\n \n     fn cause(&self) -> Option<&dyn error::Error> {\n         use self::Error::*;\n-        match self {\n-            &IoError(ref e) => Some(e),\n+        match *self {\n+            IoError(ref e) => Some(e),\n             _ => None,\n         }\n     }\n@@ -70,10 +70,10 @@ impl error::Error for Error {\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::Error::*;\n-        match self {\n-            &TermUnset => Ok(()),\n-            &MalformedTerminfo(ref e) => e.fmt(f),\n-            &IoError(ref e) => e.fmt(f),\n+        match *self {\n+            TermUnset => Ok(()),\n+            MalformedTerminfo(ref e) => e.fmt(f),\n+            IoError(ref e) => e.fmt(f),\n         }\n     }\n }\n@@ -109,9 +109,9 @@ impl TermInfo {\n     }\n     // Keep the metadata small\n     fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n-        let file = File::open(path).map_err(|e| Error::IoError(e))?;\n+        let file = File::open(path).map_err(Error::IoError)?;\n         let mut reader = BufReader::new(file);\n-        parse(&mut reader, false).map_err(|e| Error::MalformedTerminfo(e))\n+        parse(&mut reader, false).map_err(Error::MalformedTerminfo)\n     }\n }\n "}, {"sha": "31e1b18485ca40451aaa0e9953bf65689c1d7ca8", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -12,8 +12,6 @@\n \n use self::Param::*;\n use self::States::*;\n-use self::FormatState::*;\n-use self::FormatOp::*;\n \n use std::iter::repeat;\n \n@@ -36,9 +34,9 @@ enum States {\n \n #[derive(Copy, PartialEq, Clone)]\n enum FormatState {\n-    FormatStateFlags,\n-    FormatStateWidth,\n-    FormatStatePrecision,\n+    Flags,\n+    Width,\n+    Precision,\n }\n \n /// Types of parameters a capability can use\n@@ -210,22 +208,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                         if let Some(arg) = stack.pop() {\n                             let flags = Flags::new();\n                             let res = format(arg, FormatOp::from_char(cur), flags)?;\n-                            output.extend(res.iter().map(|x| *x));\n+                            output.extend(res.iter().cloned());\n                         } else {\n                             return Err(\"stack is empty\".to_string());\n                         }\n                     }\n                     ':' | '#' | ' ' | '.' | '0'..='9' => {\n                         let mut flags = Flags::new();\n-                        let mut fstate = FormatStateFlags;\n+                        let mut fstate = FormatState::Flags;\n                         match cur {\n                             ':' => (),\n                             '#' => flags.alternate = true,\n                             ' ' => flags.space = true,\n-                            '.' => fstate = FormatStatePrecision,\n+                            '.' => fstate = FormatState::Precision,\n                             '0'..='9' => {\n                                 flags.width = cur as usize - '0' as usize;\n-                                fstate = FormatStateWidth;\n+                                fstate = FormatState::Width;\n                             }\n                             _ => unreachable!(),\n                         }\n@@ -318,43 +316,43 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n                         if let Some(arg) = stack.pop() {\n                             let res = format(arg, FormatOp::from_char(cur), *flags)?;\n-                            output.extend(res.iter().map(|x| *x));\n+                            output.extend(res.iter().cloned());\n                             // will cause state to go to Nothing\n                             old_state = FormatPattern(*flags, *fstate);\n                         } else {\n                             return Err(\"stack is empty\".to_string());\n                         }\n                     }\n-                    (FormatStateFlags, '#') => {\n+                    (FormatState::Flags, '#') => {\n                         flags.alternate = true;\n                     }\n-                    (FormatStateFlags, '-') => {\n+                    (FormatState::Flags, '-') => {\n                         flags.left = true;\n                     }\n-                    (FormatStateFlags, '+') => {\n+                    (FormatState::Flags, '+') => {\n                         flags.sign = true;\n                     }\n-                    (FormatStateFlags, ' ') => {\n+                    (FormatState::Flags, ' ') => {\n                         flags.space = true;\n                     }\n-                    (FormatStateFlags, '0'..='9') => {\n+                    (FormatState::Flags, '0'..='9') => {\n                         flags.width = cur as usize - '0' as usize;\n-                        *fstate = FormatStateWidth;\n+                        *fstate = FormatState::Width;\n                     }\n-                    (FormatStateFlags, '.') => {\n-                        *fstate = FormatStatePrecision;\n+                    (FormatState::Flags, '.') => {\n+                        *fstate = FormatState::Precision;\n                     }\n-                    (FormatStateWidth, '0'..='9') => {\n+                    (FormatState::Width, '0'..='9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                         if flags.width < old {\n                             return Err(\"format width overflow\".to_string());\n                         }\n                     }\n-                    (FormatStateWidth, '.') => {\n-                        *fstate = FormatStatePrecision;\n+                    (FormatState::Width, '.') => {\n+                        *fstate = FormatState::Precision;\n                     }\n-                    (FormatStatePrecision, '0'..='9') => {\n+                    (FormatState::Precision, '0'..='9') => {\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n@@ -437,31 +435,31 @@ impl Flags {\n \n #[derive(Copy, Clone)]\n enum FormatOp {\n-    FormatDigit,\n-    FormatOctal,\n-    FormatHex,\n-    FormatHEX,\n-    FormatString,\n+    Digit,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n+    String,\n }\n \n impl FormatOp {\n     fn from_char(c: char) -> FormatOp {\n         match c {\n-            'd' => FormatDigit,\n-            'o' => FormatOctal,\n-            'x' => FormatHex,\n-            'X' => FormatHEX,\n-            's' => FormatString,\n+            'd' => FormatOp::Digit,\n+            'o' => FormatOp::Octal,\n+            'x' => FormatOp::LowerHex,\n+            'X' => FormatOp::UpperHex,\n+            's' => FormatOp::String,\n             _ => panic!(\"bad FormatOp char\"),\n         }\n     }\n     fn to_char(self) -> char {\n         match self {\n-            FormatDigit => 'd',\n-            FormatOctal => 'o',\n-            FormatHex => 'x',\n-            FormatHEX => 'X',\n-            FormatString => 's',\n+            FormatOp::Digit => 'd',\n+            FormatOp::Octal => 'o',\n+            FormatOp::LowerHex => 'x',\n+            FormatOp::UpperHex => 'X',\n+            FormatOp::String => 's',\n         }\n     }\n }\n@@ -470,7 +468,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     let mut s = match val {\n         Number(d) => {\n             match op {\n-                FormatDigit => {\n+                FormatOp::Digit => {\n                     if flags.sign {\n                         format!(\"{:+01$}\", d, flags.precision)\n                     } else if d < 0 {\n@@ -482,35 +480,35 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n                         format!(\"{:01$}\", d, flags.precision)\n                     }\n                 }\n-                FormatOctal => {\n+                FormatOp::Octal => {\n                     if flags.alternate {\n                         // Leading octal zero counts against precision.\n                         format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n                     } else {\n                         format!(\"{:01$o}\", d, flags.precision)\n                     }\n                 }\n-                FormatHex => {\n+                FormatOp::LowerHex => {\n                     if flags.alternate && d != 0 {\n                         format!(\"0x{:01$x}\", d, flags.precision)\n                     } else {\n                         format!(\"{:01$x}\", d, flags.precision)\n                     }\n                 }\n-                FormatHEX => {\n+                FormatOp::UpperHex => {\n                     if flags.alternate && d != 0 {\n                         format!(\"0X{:01$X}\", d, flags.precision)\n                     } else {\n                         format!(\"{:01$X}\", d, flags.precision)\n                     }\n                 }\n-                FormatString => return Err(\"non-number on stack with %s\".to_string()),\n+                FormatOp::String => return Err(\"non-number on stack with %s\".to_string()),\n             }\n             .into_bytes()\n         }\n         Words(s) => {\n             match op {\n-                FormatString => {\n+                FormatOp::String => {\n                     let mut s = s.into_bytes();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);"}, {"sha": "e0b60eead497a6b45b0f98f3a9eaf761cce31ee7", "filename": "src/libterm/win.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -198,11 +198,11 @@ impl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n         Ok(true)\n     }\n \n-    fn get_ref<'a>(&'a self) -> &'a T {\n+    fn get_ref(&self) -> &T {\n         &self.buf\n     }\n \n-    fn get_mut<'a>(&'a mut self) -> &'a mut T {\n+    fn get_mut(&mut self) -> &mut T {\n         &mut self.buf\n     }\n "}, {"sha": "d9fbd494ab3484ed3f4ae519eb08380291479895", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -366,7 +366,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool PositionIndependentExecutable, bool FunctionSections,\n     bool DataSections,\n     bool TrapUnreachable,\n-    bool Singlethread) {\n+    bool Singlethread,\n+    bool AsmComments) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -393,6 +394,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   }\n   Options.DataSections = DataSections;\n   Options.FunctionSections = FunctionSections;\n+  Options.MCOptions.AsmVerbose = AsmComments;\n+  Options.MCOptions.PreserveAsmComments = AsmComments;\n \n   if (TrapUnreachable) {\n     // Tell LLVM to codegen `unreachable` into an explicit trap instruction."}, {"sha": "18d73bf5677bce950c35c9dece69f5837e0cc0ce", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows failing on win32 bot\n+// ignore-freebsd: gdb package too new\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// min-gdb-version 7.7\n+// min-lldb-version: 310\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command: run\n+\n+// gdb-command: print btree_set\n+// gdb-check:$1 = BTreeSet<i32>(len: 3) = {3, 5, 7}\n+\n+// gdb-command: print vec_deque\n+// gdb-check:$2 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n+\n+#![allow(unused_variables)]\n+use std::collections::BTreeSet;\n+use std::collections::VecDeque;\n+\n+\n+fn main() {\n+\n+    // BTreeSet\n+    let mut btree_set = BTreeSet::new();\n+    btree_set.insert(5);\n+    btree_set.insert(3);\n+    btree_set.insert(7);\n+\n+    // VecDeque\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.push_back(5);\n+    vec_deque.push_back(3);\n+    vec_deque.push_back(7);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "296764269dec058da0f1d614bf3bb3c263f0df1b", "filename": "src/test/run-pass/env-null-vars.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Frun-pass%2Fenv-null-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Frun-pass%2Fenv-null-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-null-vars.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-wasm32-bare no libc to test ffi with\n+\n+// issue-53200\n+\n+#![feature(libc)]\n+extern crate libc;\n+\n+use std::env;\n+\n+// FIXME: more platforms?\n+#[cfg(target_os = \"linux\")]\n+fn main() {\n+    unsafe { libc::clearenv(); }\n+    assert_eq!(env::vars().count(), 0);\n+}\n+\n+#[cfg(not(target_os = \"linux\"))]\n+fn main() {}"}, {"sha": "21ad5159946fd701d89b9e30617664b95b92b0fb", "filename": "src/test/rustdoc/async-fn.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-fn.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+// compile-flags:-Z unstable-options\n+\n+// FIXME: once `--edition` is stable in rustdoc, remove that `compile-flags` directive\n+\n+#![feature(rust_2018_preview, async_await, futures_api)]\n+\n+// @has async_fn/struct.S.html\n+// @has - '//code' 'pub async fn f()'\n+pub struct S;\n+\n+impl S {\n+    pub async fn f() {}\n+}"}, {"sha": "aa9da744566f76c2efdc951f5458e681e0b1474f", "filename": "src/test/ui/issue-53251.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fui%2Fissue-53251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fui%2Fissue-53251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53251.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn f() {}\n+}\n+\n+macro_rules! impl_add {\n+    ($($n:ident)*) => {\n+        $(\n+            fn $n() {\n+                S::f::<i64>();\n+                //~^ ERROR too many type parameters provided\n+            }\n+        )*\n+    }\n+}\n+\n+impl_add!(a b);"}, {"sha": "bf99e73f0d985ac9809af96217a55096e435990d", "filename": "src/test/ui/issue-53251.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fui%2Fissue-53251.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftest%2Fui%2Fissue-53251.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53251.stderr?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -0,0 +1,17 @@\n+error[E0601]: `main` function not found in crate `issue_53251`\n+   |\n+   = note: consider adding a `main` function to `$DIR/issue-53251.rs`\n+\n+error[E0087]: too many type parameters provided: expected at most 0 type parameters, found 1 type parameter\n+  --> $DIR/issue-53251.rs:21:24\n+   |\n+LL |                 S::f::<i64>();\n+   |                        ^^^ expected 0 type parameters\n+...\n+LL | impl_add!(a b);\n+   | --------------- in this macro invocation\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0087, E0601.\n+For more information about an error, try `rustc --explain E0087`."}, {"sha": "d1071231530d68f6929e0fb2b3814593f1f7c834", "filename": "src/tools/compiletest/src/raise_fd_limit.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5733050de780ae4d11e3a7af615df792fdf908e/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs?ref=a5733050de780ae4d11e3a7af615df792fdf908e", "patch": "@@ -57,14 +57,16 @@ pub unsafe fn raise_fd_limit() {\n         panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n     }\n \n-    // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard\n-    // limit\n-    rlim.rlim_cur = cmp::min(maxfiles as libc::rlim_t, rlim.rlim_max);\n+    // Make sure we're only ever going to increase the rlimit.\n+    if rlim.rlim_cur < maxfiles as libc::rlim_t {\n+        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit.\n+        rlim.rlim_cur = cmp::min(maxfiles as libc::rlim_t, rlim.rlim_max);\n \n-    // Set our newly-increased resource limit\n-    if libc::setrlimit(libc::RLIMIT_NOFILE, &rlim) != 0 {\n-        let err = io::Error::last_os_error();\n-        panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+        // Set our newly-increased resource limit.\n+        if libc::setrlimit(libc::RLIMIT_NOFILE, &rlim) != 0 {\n+            let err = io::Error::last_os_error();\n+            panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+        }\n     }\n }\n "}]}