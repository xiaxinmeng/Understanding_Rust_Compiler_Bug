{"sha": "1b275d08ad6299a1f9b31650ba906a18846d5461", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMjc1ZDA4YWQ2Mjk5YTFmOWIzMTY1MGJhOTA2YTE4ODQ2ZDU0NjE=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-11T19:50:17Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-18T15:11:34Z"}, "message": "document `const_evaluatable`", "tree": {"sha": "1ddbb2d87670ac6e83f91070a9371a6e58fd1003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ddbb2d87670ac6e83f91070a9371a6e58fd1003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b275d08ad6299a1f9b31650ba906a18846d5461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b275d08ad6299a1f9b31650ba906a18846d5461", "html_url": "https://github.com/rust-lang/rust/commit/1b275d08ad6299a1f9b31650ba906a18846d5461", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b275d08ad6299a1f9b31650ba906a18846d5461/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fff155d2a2b10958454e4958197dda103644ad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fff155d2a2b10958454e4958197dda103644ad4", "html_url": "https://github.com/rust-lang/rust/commit/7fff155d2a2b10958454e4958197dda103644ad4"}], "stats": {"total": 50, "additions": 47, "deletions": 3}, "files": [{"sha": "db79de06d5e4cb2b74ac191699f38d068c6285a4", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b275d08ad6299a1f9b31650ba906a18846d5461/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b275d08ad6299a1f9b31650ba906a18846d5461/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=1b275d08ad6299a1f9b31650ba906a18846d5461", "patch": "@@ -1,3 +1,13 @@\n+//! Checking that constant values used in types can be successfully evaluated.\n+//!\n+//! For concrete constants, this is fairly simple as we can just try and evaluate it.\n+//!\n+//! When dealing with polymorphic constants, for example `std::mem::size_of::<T>() - 1`,\n+//! this is not as easy.\n+//!\n+//! In this case we try to build an abstract representation of this constant using\n+//! `mir_abstract_const` which can then be checked for structural equality with other\n+//! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -129,13 +139,19 @@ impl AbstractConst<'tcx> {\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n+    /// The current WIP node tree.\n     nodes: IndexVec<NodeId, Node<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n+    /// We only allow field accesses if they access\n+    /// the result of a checked operation.\n     checked_op_locals: BitSet<mir::Local>,\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n+        // We only allow consts without control flow, so\n+        // we check for cycles here which simplifies the\n+        // rest of this implementation.\n         if body.is_cfg_cyclic() {\n             return None;\n         }\n@@ -154,17 +170,21 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n         })\n     }\n-\n     fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n         debug!(\"operand_to_node: op={:?}\", op);\n         const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n         match op {\n             mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                // Do not allow any projections.\n+                //\n+                // One exception are field accesses on the result of checked operations,\n+                // which are required to support things like `1 + 2`.\n                 if let Some(p) = p.as_local() {\n                     debug_assert!(!self.checked_op_locals.contains(p));\n                     Some(self.locals[p])\n                 } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow field accesses on the result of checked operations.\n+                    // Only allow field accesses if the given local\n+                    // contains the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n                         Some(self.locals[p.local])\n                     } else {\n@@ -238,6 +258,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n+    /// Possible return values:\n+    ///\n+    /// - `None`: unsupported terminator, stop building\n+    /// - `Some(None)`: supported terminator, finish building\n+    /// - `Some(Some(block))`: support terminator, build `block` next\n     fn build_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -250,7 +275,18 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 ref func,\n                 ref args,\n                 destination: Some((ref place, target)),\n+                // We do not care about `cleanup` here. Any branch which\n+                // uses `cleanup` will fail const-eval and they therefore\n+                // do not matter when checking for const evaluatability.\n+                //\n+                // Do note that even if `panic::catch_unwind` is made const,\n+                // we still do not have to care about this, as we do not look\n+                // into functions.\n                 cleanup: _,\n+                // Do not allow overloaded operators for now,\n+                // we probably do want to allow this in the future.\n+                //\n+                // This is currently fairly irrelevant as it requires `const Trait`s.\n                 from_hir_call: true,\n                 fn_span: _,\n             } => {\n@@ -264,10 +300,14 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n                 Some(Some(target))\n             }\n+            // We only allow asserts for checked operations.\n+            //\n+            // These asserts seem to all have the form `!_local.0` so\n+            // we only allow exactly that.\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n                 let p = match cond {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n-                    mir::Operand::Constant(_) => bug!(\"Unexpected assert\"),\n+                    mir::Operand::Constant(_) => bug!(\"unexpected assert\"),\n                 };\n \n                 const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n@@ -285,8 +325,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n+    /// Builds the abstract const by walking the mir from start to finish\n+    /// and bailing out when encountering an unsupported operation.\n     fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n         let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n+        // We checked for a cyclic cfg above, so this should terminate.\n         loop {\n             debug!(\"AbstractConstBuilder: block={:?}\", block);\n             for stmt in block.statements.iter() {\n@@ -340,6 +383,7 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     false\n }\n \n+/// Tries to unify two abstract constants using structural equality.\n pub(super) fn try_unify<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: AbstractConst<'tcx>,"}]}