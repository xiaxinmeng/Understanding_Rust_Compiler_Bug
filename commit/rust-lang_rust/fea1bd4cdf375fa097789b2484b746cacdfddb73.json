{"sha": "fea1bd4cdf375fa097789b2484b746cacdfddb73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYTFiZDRjZGYzNzVmYTA5Nzc4OWIyNDg0Yjc0NmNhY2RmZGRiNzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-22T00:10:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-10-01T19:33:02Z"}, "message": "std: Move platform specific memchr code into sys", "tree": {"sha": "f5ef33bb7abcc51b80c604d0f68802ba804ccd93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ef33bb7abcc51b80c604d0f68802ba804ccd93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fea1bd4cdf375fa097789b2484b746cacdfddb73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fea1bd4cdf375fa097789b2484b746cacdfddb73", "html_url": "https://github.com/rust-lang/rust/commit/fea1bd4cdf375fa097789b2484b746cacdfddb73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fea1bd4cdf375fa097789b2484b746cacdfddb73/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c215623020b878353d115b6ddb728a960890a98", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c215623020b878353d115b6ddb728a960890a98", "html_url": "https://github.com/rust-lang/rust/commit/5c215623020b878353d115b6ddb728a960890a98"}], "stats": {"total": 580, "additions": 309, "deletions": 271}, "files": [{"sha": "7c8c97a6caf9cfc2dd3f188def54060449c822d4", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 4, "deletions": 271, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -11,8 +11,6 @@\n // Original implementation taken from rust-memchr\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-\n-\n /// A safe interface to `memchr`.\n ///\n /// Returns the index corresponding to the first occurrence of `needle` in\n@@ -32,32 +30,9 @@\n /// let haystack = b\"the quick brown fox\";\n /// assert_eq!(memchr(b'k', haystack), Some(8));\n /// ```\n+#[inline]\n pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-    // libc memchr\n-    #[cfg(not(target_os = \"windows\"))]\n-    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc;\n-\n-        let p = unsafe {\n-            libc::memchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len() as libc::size_t)\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    // use fallback on windows, since it's faster\n-    #[cfg(target_os = \"windows\")]\n-    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        fallback::memchr(needle, haystack)\n-    }\n-\n-    memchr_specific(needle, haystack)\n+    ::sys::memchr::memchr(needle, haystack)\n }\n \n /// A safe interface to `memrchr`.\n@@ -75,251 +50,9 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n /// let haystack = b\"the quick brown fox\";\n /// assert_eq!(memrchr(b'o', haystack), Some(17));\n /// ```\n+#[inline]\n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc;\n-\n-        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n-        let p = unsafe {\n-            libc::memrchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len() as libc::size_t)\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        fallback::memrchr(needle, haystack)\n-    }\n-\n-    memrchr_specific(needle, haystack)\n-}\n-\n-#[allow(dead_code)]\n-mod fallback {\n-    use cmp;\n-    use mem;\n-\n-    const LO_U64: u64 = 0x0101010101010101;\n-    const HI_U64: u64 = 0x8080808080808080;\n-\n-    // use truncation\n-    const LO_USIZE: usize = LO_U64 as usize;\n-    const HI_USIZE: usize = HI_U64 as usize;\n-\n-    /// Return `true` if `x` contains any zero byte.\n-    ///\n-    /// From *Matters Computational*, J. Arndt\n-    ///\n-    /// \"The idea is to subtract one from each of the bytes and then look for\n-    /// bytes where the borrow propagated all the way to the most significant\n-    /// bit.\"\n-    #[inline]\n-    fn contains_zero_byte(x: usize) -> bool {\n-        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n-    }\n-\n-    #[cfg(target_pointer_width = \"32\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep\n-    }\n-\n-    #[cfg(target_pointer_width = \"64\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep = rep << 32 | rep;\n-        rep\n-    }\n-\n-    /// Return the first index matching the byte `a` in `text`.\n-    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned initial part, before the first word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the last remaining part, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search up to an aligned boundary\n-        let align = (ptr as usize) & (usize_bytes- 1);\n-        let mut offset;\n-        if align > 0 {\n-            offset = cmp::min(usize_bytes - align, len);\n-            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n-                return Some(index);\n-            }\n-        } else {\n-            offset = 0;\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        if len >= 2 * usize_bytes {\n-            while offset <= len - 2 * usize_bytes {\n-                unsafe {\n-                    let u = *(ptr.offset(offset as isize) as *const usize);\n-                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                    // break if there is a matching byte\n-                    let zu = contains_zero_byte(u ^ repeated_x);\n-                    let zv = contains_zero_byte(v ^ repeated_x);\n-                    if zu || zv {\n-                        break;\n-                    }\n-                }\n-                offset += usize_bytes * 2;\n-            }\n-        }\n-\n-        // find the byte after the point the body loop stopped\n-        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n-    }\n-\n-    /// Return the last index matching the byte `a` in `text`.\n-    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned tail, after the last word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the first remaining bytes, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search to an aligned boundary\n-        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n-        let mut offset;\n-        if end_align > 0 {\n-            offset = if end_align >= len { 0 } else { len - end_align };\n-            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n-                return Some(offset + index);\n-            }\n-        } else {\n-            offset = len;\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        while offset >= 2 * usize_bytes {\n-            unsafe {\n-                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n-                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n-\n-                // break if there is a matching byte\n-                let zu = contains_zero_byte(u ^ repeated_x);\n-                let zv = contains_zero_byte(v ^ repeated_x);\n-                if zu || zv {\n-                    break;\n-                }\n-            }\n-            offset -= 2 * usize_bytes;\n-        }\n-\n-        // find the byte before the point the body loop stopped\n-        text[..offset].iter().rposition(|elt| *elt == x)\n-    }\n-\n-    // test fallback implementations on all platforms\n-    #[test]\n-    fn matches_one() {\n-        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin() {\n-        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end() {\n-        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul() {\n-        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul() {\n-        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty() {\n-        assert_eq!(None, memchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match() {\n-        assert_eq!(None, memchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn matches_one_reversed() {\n-        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin_reversed() {\n-        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul_reversed() {\n-        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn each_alignment_reversed() {\n-        let mut data = [1u8; 64];\n-        let needle = 2;\n-        let pos = 40;\n-        data[pos] = needle;\n-        for start in 0..16 {\n-            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n-        }\n-    }\n+    ::sys::memchr::memrchr(needle, haystack)\n }\n \n #[cfg(test)]"}, {"sha": "3824a5fb5284c85c430f148704c8a5516ddb44f1", "filename": "src/libstd/sys/common/memchr.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+#[allow(dead_code)]\n+pub mod fallback {\n+    use cmp;\n+    use mem;\n+\n+    const LO_U64: u64 = 0x0101010101010101;\n+    const HI_U64: u64 = 0x8080808080808080;\n+\n+    // use truncation\n+    const LO_USIZE: usize = LO_U64 as usize;\n+    const HI_USIZE: usize = HI_U64 as usize;\n+\n+    /// Return `true` if `x` contains any zero byte.\n+    ///\n+    /// From *Matters Computational*, J. Arndt\n+    ///\n+    /// \"The idea is to subtract one from each of the bytes and then look for\n+    /// bytes where the borrow propagated all the way to the most significant\n+    /// bit.\"\n+    #[inline]\n+    fn contains_zero_byte(x: usize) -> bool {\n+        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep = rep << 32 | rep;\n+        rep\n+    }\n+\n+    /// Return the first index matching the byte `a` in `text`.\n+    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned initial part, before the first word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the last remaining part, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n+\n+        // search up to an aligned boundary\n+        let align = (ptr as usize) & (usize_bytes- 1);\n+        let mut offset;\n+        if align > 0 {\n+            offset = cmp::min(usize_bytes - align, len);\n+            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+                return Some(index);\n+            }\n+        } else {\n+            offset = 0;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        if len >= 2 * usize_bytes {\n+            while offset <= len - 2 * usize_bytes {\n+                unsafe {\n+                    let u = *(ptr.offset(offset as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n+\n+                    // break if there is a matching byte\n+                    let zu = contains_zero_byte(u ^ repeated_x);\n+                    let zv = contains_zero_byte(v ^ repeated_x);\n+                    if zu || zv {\n+                        break;\n+                    }\n+                }\n+                offset += usize_bytes * 2;\n+            }\n+        }\n+\n+        // find the byte after the point the body loop stopped\n+        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    }\n+\n+    /// Return the last index matching the byte `a` in `text`.\n+    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned tail, after the last word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the first remaining bytes, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n+\n+        // search to an aligned boundary\n+        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n+        let mut offset;\n+        if end_align > 0 {\n+            offset = if end_align >= len { 0 } else { len - end_align };\n+            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+                return Some(offset + index);\n+            }\n+        } else {\n+            offset = len;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        while offset >= 2 * usize_bytes {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset -= 2 * usize_bytes;\n+        }\n+\n+        // find the byte before the point the body loop stopped\n+        text[..offset].iter().rposition(|elt| *elt == x)\n+    }\n+\n+    // test fallback implementations on all platforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn each_alignment_reversed() {\n+        let mut data = [1u8; 64];\n+        let needle = 2;\n+        let pos = 40;\n+        data[pos] = needle;\n+        for start in 0..16 {\n+            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n+        }\n+    }\n+}"}, {"sha": "9a46c617b97262fd53e7312094080882f39a6faf", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -31,6 +31,7 @@ pub mod at_exit_imp;\n pub mod backtrace;\n pub mod condvar;\n pub mod io;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod poison;"}, {"sha": "5038e0750c8d22173a46a617516bf93b1100078d", "filename": "src/libstd/sys/unix/memchr.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    use libc;\n+\n+    let p = unsafe {\n+        libc::memchr(\n+            haystack.as_ptr() as *const libc::c_void,\n+            needle as libc::c_int,\n+            haystack.len() as libc::size_t)\n+    };\n+    if p.is_null() {\n+        None\n+    } else {\n+        Some(p as usize - (haystack.as_ptr() as usize))\n+    }\n+}\n+\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        ::sys_common::memchr::fallback::memrchr(needle, haystack)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}"}, {"sha": "c4763e1739e4497fa882bf09ff8c5788b07330e2", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -38,6 +38,7 @@ pub mod env;\n pub mod ext;\n pub mod fd;\n pub mod fs;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;"}, {"sha": "5a5386acaa5311a748976be4fbc183e612b1d696", "filename": "src/libstd/sys/windows/memchr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+// Fallback memchr is fastest on windows\n+pub use sys_common::memchr::fallback::{memchr, memrchr};"}, {"sha": "df9cef33927815fa2551bf1c105275dee9166ad0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1bd4cdf375fa097789b2484b746cacdfddb73/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=fea1bd4cdf375fa097789b2484b746cacdfddb73", "patch": "@@ -26,6 +26,7 @@ pub mod env;\n pub mod ext;\n pub mod fs;\n pub mod handle;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;"}]}