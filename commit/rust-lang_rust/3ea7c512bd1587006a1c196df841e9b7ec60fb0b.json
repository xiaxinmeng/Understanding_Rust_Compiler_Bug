{"sha": "3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "node_id": "C_kwDOAAsO6NoAKDNlYTdjNTEyYmQxNTg3MDA2YTFjMTk2ZGY4NDFlOWI3ZWM2MGZiMGI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-27T19:27:59Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-06T18:44:22Z"}, "message": "Fall back to bidirectional normalizes-to if no subst-eq in alias-eq goal", "tree": {"sha": "959d305a2703a59cfba5b8d579b7744ad0c0f726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959d305a2703a59cfba5b8d579b7744ad0c0f726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "html_url": "https://github.com/rust-lang/rust/commit/3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "html_url": "https://github.com/rust-lang/rust/commit/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2"}], "stats": {"total": 168, "additions": 145, "deletions": 23}, "files": [{"sha": "66a4d36a1e5a7b0628c4e429025ce8c5b84bf594", "filename": "compiler/rustc_trait_selection/src/solve/alias_relate.rs", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs?ref=3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "patch": "@@ -79,11 +79,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     // them. This is necessary for inference during typeck.\n                     //\n                     // As this is incomplete, we must not do so during coherence.\n-                    match (self.solver_mode(), subst_relate_response) {\n-                        (SolverMode::Normal, Ok(response)) => Ok(response),\n-                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n-                            self.flounder(&candidates)\n+                    match self.solver_mode() {\n+                        SolverMode::Normal => {\n+                            if let Ok(subst_relate_response) = subst_relate_response {\n+                                Ok(subst_relate_response)\n+                            } else if let Ok(bidirectional_normalizes_to_response) = self\n+                                .assemble_bidirectional_normalizes_to_candidate(\n+                                    param_env, lhs, rhs, direction,\n+                                )\n+                            {\n+                                Ok(bidirectional_normalizes_to_response)\n+                            } else {\n+                                self.flounder(&candidates)\n+                            }\n                         }\n+                        SolverMode::Coherence => self.flounder(&candidates),\n                     }\n                 }\n             }\n@@ -100,29 +110,42 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         invert: Invert,\n     ) -> QueryResult<'tcx> {\n         self.probe(|ecx| {\n-            let other = match direction {\n-                // This is purely an optimization.\n-                ty::AliasRelationDirection::Equate => other,\n-\n-                ty::AliasRelationDirection::Subtype => {\n-                    let fresh = ecx.next_term_infer_of_kind(other);\n-                    let (sub, sup) = match invert {\n-                        Invert::No => (fresh, other),\n-                        Invert::Yes => (other, fresh),\n-                    };\n-                    ecx.sub(param_env, sub, sup)?;\n-                    fresh\n-                }\n-            };\n-            ecx.add_goal(Goal::new(\n-                ecx.tcx(),\n-                param_env,\n-                ty::Binder::dummy(ty::ProjectionPredicate { projection_ty: alias, term: other }),\n-            ));\n+            ecx.normalizes_to_inner(param_env, alias, other, direction, invert)?;\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n+    fn normalizes_to_inner(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> Result<(), NoSolution> {\n+        let other = match direction {\n+            // This is purely an optimization.\n+            ty::AliasRelationDirection::Equate => other,\n+\n+            ty::AliasRelationDirection::Subtype => {\n+                let fresh = self.next_term_infer_of_kind(other);\n+                let (sub, sup) = match invert {\n+                    Invert::No => (fresh, other),\n+                    Invert::Yes => (other, fresh),\n+                };\n+                self.sub(param_env, sub, sup)?;\n+                fresh\n+            }\n+        };\n+        self.add_goal(Goal::new(\n+            self.tcx(),\n+            param_env,\n+            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty: alias, term: other }),\n+        ));\n+\n+        Ok(())\n+    }\n+\n     fn assemble_subst_relate_candidate(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -143,4 +166,30 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n+\n+    fn assemble_bidirectional_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: ty::Term<'tcx>,\n+        rhs: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                lhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                rhs,\n+                direction,\n+                Invert::No,\n+            )?;\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                rhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            )?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n }"}, {"sha": "99a3d02bd1aeae101b641c99bc084e0e4b8cabec", "filename": "tests/ui/traits/new-solver/tait-eq-proj-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs?ref=3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+// Similar to tests/ui/traits/new-solver/tait-eq-proj.rs\n+// but check the alias-sub relation in the other direction.\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn a() {\n+    let x: Tait = mk();\n+    let mut array = mk();\n+    let mut z = IntoIterator::into_iter(array);\n+    z = x;\n+    array = [0i32; 32];\n+}\n+\n+fn main() {}"}, {"sha": "01141b2819a8d5af026f6f248ecc627a9f6a3a6f", "filename": "tests/ui/traits/new-solver/tait-eq-proj.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs?ref=3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+/*\n+\n+Consider the goal - AliasRelate(Tait, <[i32; 32] as IntoIterator>::IntoIter)\n+which is registered on the line above.\n+\n+A. SubstRelate - fails (of course).\n+\n+B. NormalizesToRhs - Tait normalizes-to <[i32; 32] as IntoIterator>::IntoIter\n+    * infer definition - Tait := <[i32; 32] as IntoIterator>::IntoIter\n+\n+C. NormalizesToLhs - <[i32; 32] as IntoIterator>::IntoIter normalizes-to Tait\n+    * Find impl candidate, after substitute - std::array::IntoIter<i32, 32>\n+    * Equate std::array::IntoIter<i32, 32> and Tait\n+        * infer definition - Tait := std::array::IntoIter<i32, 32>\n+\n+B and C are not equal, but they are equivalent modulo normalization.\n+\n+We get around this by evaluating both the NormalizesToRhs and NormalizesToLhs\n+goals together. Essentially:\n+    A alias-relate B if A normalizes-to B and B normalizes-to A.\n+\n+*/\n+\n+fn a() {\n+    let _: Tait = IntoIterator::into_iter([0i32; 32]);\n+}\n+\n+fn main() {}"}, {"sha": "532c4c39bd499f79e75f766523126522d65345fd", "filename": "tests/ui/traits/new-solver/tait-eq-tait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea7c512bd1587006a1c196df841e9b7ec60fb0b/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs?ref=3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Not exactly sure if this is the inference behavior we *want*,\n+// but it is a side-effect of the lazy normalization of TAITs.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Sized;\n+type Tait2 = impl Sized;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn main() {\n+    let x: Tait = 1u32;\n+    let y: Tait2 = x;\n+}"}]}