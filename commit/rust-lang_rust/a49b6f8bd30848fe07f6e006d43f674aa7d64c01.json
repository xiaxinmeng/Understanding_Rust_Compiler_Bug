{"sha": "a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OWI2ZjhiZDMwODQ4ZmUwN2Y2ZTAwNmQ0M2Y2NzRhYTdkNjRjMDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-10T09:29:07Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-10T09:29:07Z"}, "message": "Rollup merge of #23201 - pnkfelix:fsk-struct-ooe-23112, r=nikomatsakis\n\n For FRU, eval field exprs (into scratch temps) before base expr\n\nFix #23112.", "tree": {"sha": "b8b27f83995c7811caf2274f8e7272aa2d1012ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8b27f83995c7811caf2274f8e7272aa2d1012ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "html_url": "https://github.com/rust-lang/rust/commit/a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621ccf58c47f483abb7d18fdde723f246b7f4add", "url": "https://api.github.com/repos/rust-lang/rust/commits/621ccf58c47f483abb7d18fdde723f246b7f4add", "html_url": "https://github.com/rust-lang/rust/commit/621ccf58c47f483abb7d18fdde723f246b7f4add"}, {"sha": "3dbf969103adf5e84b1b76d67193608ad2eb3200", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbf969103adf5e84b1b76d67193608ad2eb3200", "html_url": "https://github.com/rust-lang/rust/commit/3dbf969103adf5e84b1b76d67193608ad2eb3200"}], "stats": {"total": 163, "additions": 137, "deletions": 26}, "files": [{"sha": "ecdc7c06bb19dfa8eb629b1a16f17b0d8e763bc8", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "patch": "@@ -1500,8 +1500,45 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    // First we trans the base, if we have one, to the dest\n-    if let Some(base) = optbase {\n+    if ty::type_is_simd(bcx.tcx(), ty) {\n+        // Issue 23112: The original logic appeared vulnerable to same\n+        // order-of-eval bug. But, SIMD values are tuple-structs;\n+        // i.e. functional record update (FRU) syntax is unavailable.\n+        //\n+        // To be safe, double-check that we did not get here via FRU.\n+        assert!(optbase.is_none());\n+\n+        // This is the constructor of a SIMD type, such types are\n+        // always primitive machine types and so do not have a\n+        // destructor or require any clean-up.\n+        let llty = type_of::type_of(bcx.ccx(), ty);\n+\n+        // keep a vector as a register, and running through the field\n+        // `insertelement`ing them directly into that register\n+        // (i.e. avoid GEPi and `store`s to an alloca) .\n+        let mut vec_val = C_undef(llty);\n+\n+        for &(i, ref e) in fields {\n+            let block_datum = trans(bcx, &**e);\n+            bcx = block_datum.bcx;\n+            let position = C_uint(bcx.ccx(), i);\n+            let value = block_datum.datum.to_llscalarish(bcx);\n+            vec_val = InsertElement(bcx, vec_val, value, position);\n+        }\n+        Store(bcx, vec_val, addr);\n+    } else if let Some(base) = optbase {\n+        // Issue 23112: If there is a base, then order-of-eval\n+        // requires field expressions eval'ed before base expression.\n+\n+        // First, trans field expressions to temporary scratch values.\n+        let scratch_vals: Vec<_> = fields.iter().map(|&(i, ref e)| {\n+            let datum = unpack_datum!(bcx, trans(bcx, &**e));\n+            (i, datum)\n+        }).collect();\n+\n+        debug_location.apply(bcx.fcx);\n+\n+        // Second, trans the base to the dest.\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n@@ -1520,31 +1557,14 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-    }\n-\n-    debug_location.apply(bcx.fcx);\n-\n-    if ty::type_is_simd(bcx.tcx(), ty) {\n-        // This is the constructor of a SIMD type, such types are\n-        // always primitive machine types and so do not have a\n-        // destructor or require any clean-up.\n-        let llty = type_of::type_of(bcx.ccx(), ty);\n-\n-        // keep a vector as a register, and running through the field\n-        // `insertelement`ing them directly into that register\n-        // (i.e. avoid GEPi and `store`s to an alloca) .\n-        let mut vec_val = C_undef(llty);\n \n-        for &(i, ref e) in fields {\n-            let block_datum = trans(bcx, &**e);\n-            bcx = block_datum.bcx;\n-            let position = C_uint(bcx.ccx(), i);\n-            let value = block_datum.datum.to_llscalarish(bcx);\n-            vec_val = InsertElement(bcx, vec_val, value, position);\n+        // Finally, move scratch field values into actual field locations\n+        for (i, datum) in scratch_vals.into_iter() {\n+            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+            bcx = datum.store_to(bcx, dest);\n         }\n-        Store(bcx, vec_val, addr);\n     } else {\n-        // Now, we just overwrite the fields we've explicitly specified\n+        // No base means we can write all fields directly in place.\n         for &(i, ref e) in fields {\n             let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n             let e_ty = expr_ty_adjusted(bcx, &**e);"}, {"sha": "a64477242c08fb43eb7b2fadbc81c5e866c95b50", "filename": "src/test/run-pass/struct-order-of-eval-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs?ref=a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "patch": "@@ -12,11 +12,12 @@ struct S { f0: String, f1: int }\n \n pub fn main() {\n     let s = \"Hello, world!\".to_string();\n-    let _s = S {\n+    let s = S {\n         f0: s.to_string(),\n         ..S {\n             f0: s,\n             f1: 23\n         }\n     };\n+    assert_eq!(s.f0, \"Hello, world!\");\n }"}, {"sha": "359ecdab630eccc56fefe0bd811ac916dbc81bd4", "filename": "src/test/run-pass/struct-order-of-eval-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs?ref=a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "patch": "@@ -15,8 +15,9 @@ struct S {\n \n pub fn main() {\n     let s = \"Hello, world!\".to_string();\n-    let _s = S {\n+    let s = S {\n         f1: s.to_string(),\n         f0: s\n     };\n+    assert_eq!(s.f0, \"Hello, world!\");\n }"}, {"sha": "856ed7c105e8a29add09aec52b547f8bd6886580", "filename": "src/test/run-pass/struct-order-of-eval-3.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs?ref=a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that functional-record-update order-of-eval is as expected\n+// even when no Drop-implementations are involved.\n+\n+use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+struct W { wrapped: u32 }\n+struct S { f0: W, _f1: i32 }\n+\n+pub fn main() {\n+    const VAL: u32 = 0x89AB_CDEF;\n+    let w = W { wrapped: VAL };\n+    let s = S {\n+        f0: { event(0x01); W { wrapped: w.wrapped + 1 } },\n+        ..S {\n+            f0: { event(0x02); w},\n+            _f1: 23\n+        }\n+    };\n+    assert_eq!(s.f0.wrapped, VAL + 1);\n+    let actual = event_log();\n+    let expect = 0x01_02;\n+    assert!(expect == actual,\n+            \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n+}\n+\n+static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+fn event_log() -> usize {\n+    LOG.load(Ordering::SeqCst)\n+}\n+\n+fn event(tag: u8) {\n+    let old_log = LOG.load(Ordering::SeqCst);\n+    let new_log = (old_log << 8) + tag as usize;\n+    LOG.store(new_log, Ordering::SeqCst);\n+}"}, {"sha": "25923beffdde4e871e630d2829fbc0d10a1f2938", "filename": "src/test/run-pass/struct-order-of-eval-4.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b6f8bd30848fe07f6e006d43f674aa7d64c01/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs?ref=a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that struct-literal expression order-of-eval is as expected\n+// even when no Drop-implementations are involved.\n+\n+use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+struct W { wrapped: u32 }\n+struct S { f0: W, _f1: i32 }\n+\n+pub fn main() {\n+    const VAL: u32 = 0x89AB_CDEF;\n+    let w = W { wrapped: VAL };\n+    let s = S {\n+        _f1: { event(0x01); 23 },\n+        f0: { event(0x02); w },\n+    };\n+    assert_eq!(s.f0.wrapped, VAL);\n+    let actual = event_log();\n+    let expect = 0x01_02;\n+    assert!(expect == actual,\n+            \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n+}\n+\n+static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+fn event_log() -> usize {\n+    LOG.load(Ordering::SeqCst)\n+}\n+\n+fn event(tag: u8) {\n+    let old_log = LOG.load(Ordering::SeqCst);\n+    let new_log = (old_log << 8) + tag as usize;\n+    LOG.store(new_log, Ordering::SeqCst);\n+}"}]}