{"sha": "f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZmU5OWM3OThjYjY1MjgwYTlhNTZmNDQyYjM3MWFkY2I3YjhhYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-03T13:42:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-03T13:42:08Z"}, "message": "Auto merge of #70734 - Dylan-DPC:rollup-xmncatq, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #70696 (Extend #69020 test to include reversed operand order.)\n - #70706 (Minor cleanup in rustdoc --check-theme)\n - #70725 (Avoid `.unwrap()`s on `.span_to_snippet(...)`s)\n - #70728 (Minor doc improvements on `AllocRef`)\n - #70730 (Fix link in task::Wake docs)\n - #70731 (Minor follow-up after renaming librustc(_middle))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c35a82154a7b29f313d43ce08a69616c585231fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35a82154a7b29f313d43ce08a69616c585231fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "html_url": "https://github.com/rust-lang/rust/commit/f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d", "html_url": "https://github.com/rust-lang/rust/commit/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d"}, {"sha": "04824f302a9d28e6437d2ad0749c9e3cc4f36b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/04824f302a9d28e6437d2ad0749c9e3cc4f36b9e", "html_url": "https://github.com/rust-lang/rust/commit/04824f302a9d28e6437d2ad0749c9e3cc4f36b9e"}], "stats": {"total": 576, "additions": 356, "deletions": 220}, "files": [{"sha": "a64d5d7a63ba0714317565ab1bc84faf3a971545", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -12,10 +12,12 @@ use crate::sync::Arc;\n /// to the tasks that are executed on that executor.\n ///\n /// This trait is a memory-safe and ergonomic alternative to constructing a\n-/// [`RawWaker`]. It supports the common executor design in which the data\n-/// used to wake up a task is stored in an [`Arc`]. Some executors (especially\n+/// [`RawWaker`]. It supports the common executor design in which the data used\n+/// to wake up a task is stored in an [`Arc`][arc]. Some executors (especially\n /// those for embedded systems) cannot use this API, which is why [`RawWaker`]\n /// exists as an alternative for those systems.\n+///\n+/// [arc]: ../../std/sync/struct.Arc.html\n #[unstable(feature = \"wake_trait\", issue = \"69912\")]\n pub trait Wake {\n     /// Wake this task."}, {"sha": "e1892edb7c7f3014852ecf9bbfcbd58d1fb30b2f", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -119,7 +119,7 @@ pub enum ReallocPlacement {\n ///\n /// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n-/// `libc::malloc`), this case must be caught.\n+/// `libc::malloc`), this must be caught by the implementation.\n ///\n /// ### Currently allocated memory\n ///\n@@ -157,18 +157,20 @@ pub enum ReallocPlacement {\n /// # Safety\n ///\n /// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n-///   until the instance and all of its clones are dropped, and\n+///   until the instance and all of its clones are dropped,\n ///\n /// * cloning or moving the allocator must not invalidate memory blocks returned from this\n-///   allocator. A cloned allocator must behave like the same allocator.\n+///   allocator. A cloned allocator must behave like the same allocator, and\n ///\n /// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n ///   method of the allocator.\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    /// On success, returns a memory block meeting the size and alignment guarantees of `layout`.\n+    /// Attempts to allocate a block of memory.\n+    ///\n+    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n     ///\n     /// The returned block may have a larger size than specified by `layout.size()` and is\n     /// initialized as specified by [`init`], all the way up to the returned size of the block.\n@@ -190,26 +192,26 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n \n-    /// Deallocates the memory denoted by `memory`.\n+    /// Deallocates the memory referenced by `ptr`.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator, and\n-    /// * `layout` must [*fit*] the `ptr`.\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n+    /// * `layout` must [*fit*] that block of memory.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n     ///\n-    /// If `ReallocPlacement::MayMove` is used then ownership of the memory block referenced by `ptr`\n+    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n     /// is transferred to this allocator. The memory may or may not be freed, and should be\n     /// considered unusable (unless of course it is transferred back to the caller again via the\n     /// return value of this method).\n@@ -227,17 +229,18 @@ pub unsafe trait AllocRef {\n     ///     the size of the `MemoryBlock` returned by the `grow` call.\n     ///\n     /// [`InPlace`]: ReallocPlacement::InPlace\n+    /// [`MayMove`]: ReallocPlacement::MayMove\n     /// [`placement`]: ReallocPlacement\n     /// [`init`]: AllocInit\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n     // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly greater than `memory.size` or both are zero\n-    /// * `new_size` must be greater than or equal to `layout.size()`\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n     ///\n@@ -289,8 +292,8 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n@@ -310,20 +313,20 @@ pub unsafe trait AllocRef {\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n     // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly smaller than `memory.size` or both are zero\n-    /// * `new_size` must be smaller than or equal to `layout.size()`\n+    /// * `new_size` must be smaller than or equal to `layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     ///\n     /// # Errors\n     ///\n     /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n-    /// constraints of the allocator, or if growing otherwise fails.\n+    /// constraints of the allocator, or if shrinking otherwise fails.\n     ///\n     /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n     /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement"}, {"sha": "6165941eb3dae0e68d8aefe1a90ddb682ccce41c", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -169,7 +169,8 @@ pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n /// Implementations of `Clone` for primitive types.\n ///\n /// Implementations that cannot be described in Rust\n-/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc_middle.\n+/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n+/// in `rustc_trait_selection`.\n mod impls {\n \n     use super::Clone;"}, {"sha": "35bceaa25c36e8dc8fce428a30d37695aa994331", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -759,7 +759,8 @@ impl<T: ?Sized> Unpin for *mut T {}\n /// Implementations of `Copy` for primitive types.\n ///\n /// Implementations that cannot be described in Rust\n-/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc_middle.\n+/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n+/// in `rustc_trait_selection`.\n mod copy_impls {\n \n     use super::Copy;"}, {"sha": "cb0fb8795e581edbd5dd7c6acdae66e4758e65f1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -6,7 +6,8 @@\n //! They can be used as targets of transmutes in unsafe code for manipulating\n //! the raw representations directly.\n //!\n-//! Their definition should always match the ABI defined in `rustc_target::abi`.\n+//! Their definition should always match the ABI defined in\n+//! `rustc_middle::ty::layout`.\n \n /// The representation of a trait object like `&SomeTrait`.\n ///"}, {"sha": "141424fc0c7819aafbdf62aaa738126eefc85c21", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -1,5 +1,5 @@\n //! This module provides linkage between libgraphviz traits and\n-//! `rustc_middle::middle::typeck::infer::region_constraints`, generating a\n+//! `rustc_trait_selection::infer::region_constraints`, generating a\n //! rendering of the graph represented by the list of `Constraint`\n //! instances (which make up the edges of the graph), as well as the\n //! origin for each constraint (which are attached to the labels on"}, {"sha": "303f43b0ee210c558de521fdcb547e210461ad18", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -202,7 +202,7 @@ pub(crate) enum Cause {\n ///\n /// For more information about this translation, see\n /// `InferCtxt::process_registered_region_obligations` and\n-/// `InferCtxt::type_must_outlive` in `rustc_middle::infer::outlives`.\n+/// `InferCtxt::type_must_outlive` in `rustc_infer::infer::InferCtxt`.\n #[derive(Clone, Debug)]\n pub struct TypeTest<'tcx> {\n     /// The type `T` that must outlive the region."}, {"sha": "a118fe2db712425fdacf74fffc4301eaad999e7b", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -1053,7 +1053,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// regions which are extracted and stored as having occurred at\n     /// `locations`.\n     ///\n-    /// **Any `rustc_middle::infer` operations that might generate region\n+    /// **Any `rustc_infer::infer` operations that might generate region\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     fn fully_perform_op<R>("}, {"sha": "b3764d2d47be14aa587994edb16fe78a9f47ee9a", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -165,9 +165,9 @@ impl<'a> Parser<'a> {\n                     // Rewind to before attempting to parse the type and continue parsing.\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n-\n-                    let snippet = self.span_to_snippet(pat.span).unwrap();\n-                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n+                    if let Ok(snip) = self.span_to_snippet(pat.span) {\n+                        err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snip));\n+                    }\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n             }"}, {"sha": "485480d020f5b9f6d3083684143ae25a47caec1c", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -27,8 +27,8 @@ pub struct Context {\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n     /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in `infer::region_constraints` for more\n-    /// details.\n+    /// the README in `rustc_trait_selection::infer::region_constraints`\n+    /// for more details.\n     root_id: Option<hir::ItemLocalId>,\n \n     /// The scope that contains any new variables declared, plus its depth in"}, {"sha": "ad81aa306857b121ac28922b2e4c4387b3ca7990", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -438,7 +438,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n         // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n         // a parent stability annotation which indicates that this is private\n         // with the `rustc_private` feature. This is intended for use when\n-        // compiling librustc_middle crates themselves so we can leverage crates.io\n+        // compiling `librustc_*` crates themselves so we can leverage crates.io\n         // while maintaining the invariant that all sysroot crates are unstable\n         // by default and are unable to be used.\n         if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {"}, {"sha": "4347512eda01caf9edec860bcad9a1e3f3a7f9b1", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -143,8 +143,8 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     // FIXME: This is a quick hack to make the rustc binary able to locate\n     // Rust libraries in Linux environments where libraries might be installed\n     // to lib64/lib32. This would be more foolproof by basing the sysroot off\n-    // of the directory where librustc_middle is located, rather than where the rustc\n-    // binary is.\n+    // of the directory where `librustc_driver` is located, rather than\n+    // where the rustc binary is.\n     // If --libdir is set during configuration to the value other than\n     // \"lib\" (i.e., non-default), this value is used (see issue #16552).\n "}, {"sha": "b16d513d9239fea2bef065694e5eb0687fc945df", "filename": "src/librustc_session/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_session%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_session%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -195,7 +195,7 @@ pub enum BuiltinLintDiagnostics {\n }\n \n /// Lints that are buffered up early on in the `Session` before the\n-/// `LintLevels` is calculated. These are later passed to `librustc_middle`.\n+/// `LintLevels` is calculated.\n #[derive(PartialEq)]\n pub struct BufferedEarlyLint {\n     /// The span of code that we are linting on.\n@@ -207,7 +207,8 @@ pub struct BufferedEarlyLint {\n     /// The `NodeId` of the AST node that generated the lint.\n     pub node_id: NodeId,\n \n-    /// A lint Id that can be passed to `rustc_session::lint::Lint::from_parser_lint_id`.\n+    /// A lint Id that can be passed to\n+    /// `rustc_lint::early::EarlyContextAndPass::check_id`.\n     pub lint_id: LintId,\n \n     /// Customization of the `DiagnosticBuilder<'_>` for the lint."}, {"sha": "5a9a96887f66a31f41a4b737d677d2d4b24c006e", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -65,7 +65,7 @@ pub trait InferCtxtExt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>);\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -611,10 +611,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     )\n                 } else {\n                     let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n+                        .and_then(|did| {\n+                            let node = self.tcx.hir().get_if_local(did)?;\n+                            let (found_span, found) = self.get_fn_like_arguments(node)?;\n+                            Some((Some(found_span), found))\n                         })\n                         .unwrap_or((found_span, found));\n \n@@ -672,43 +672,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n-        match node {\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+        let sm = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n+        Some(match node {\n             Node::Expr(&hir::Expr {\n                 kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n-                self.tcx\n-                    .hir()\n-                    .body(id)\n+                sm.guess_head_span(span),\n+                hir.body(id)\n                     .params\n                     .iter()\n                     .map(|arg| {\n                         if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n                             *arg.pat\n                         {\n-                            ArgKind::Tuple(\n+                            Some(ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter()\n                                     .map(|pat| {\n-                                        let snippet = self\n-                                            .tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .span_to_snippet(pat.span)\n-                                            .unwrap();\n-                                        (snippet, \"_\".to_owned())\n+                                        sm.span_to_snippet(pat.span)\n+                                            .ok()\n+                                            .map(|snippet| (snippet, \"_\".to_owned()))\n                                     })\n-                                    .collect::<Vec<_>>(),\n-                            )\n+                                    .collect::<Option<Vec<_>>>()?,\n+                            ))\n                         } else {\n-                            let name =\n-                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n-                            ArgKind::Arg(name, \"_\".to_owned())\n+                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n+                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n                         }\n                     })\n-                    .collect::<Vec<ArgKind>>(),\n+                    .collect::<Option<Vec<ArgKind>>>()?,\n             ),\n             Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n             | Node::ImplItem(&hir::ImplItem {\n@@ -721,7 +716,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n+                sm.guess_head_span(span),\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -735,16 +730,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .collect::<Vec<ArgKind>>(),\n             ),\n             Node::Ctor(ref variant_data) => {\n-                let span = variant_data\n-                    .ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span(hir_id))\n-                    .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().guess_head_span(span);\n-\n+                let span = variant_data.ctor_hir_id().map(|id| hir.span(id)).unwrap_or(DUMMY_SP);\n+                let span = sm.guess_head_span(span);\n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        }\n+        })\n     }\n \n     /// Reports an error when the number of arguments needed by a"}, {"sha": "fcec29aaa8ecb51688a98cf79d091d50edc39088", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -732,12 +732,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 true\n             };\n \n+        let sm = self.tcx.sess.source_map();\n         let (snippet, last_ty) =\n             if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n                 // Verify that we're dealing with a return `dyn Trait`\n                 ret_ty.span.overlaps(span),\n                 &ret_ty.kind,\n-                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                sm.span_to_snippet(ret_ty.span),\n                 // If any of the return types does not conform to the trait, then we can't\n                 // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n                 all_returns_conform_to_trait,\n@@ -775,26 +776,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if is_object_safe {\n                 // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n                 // Get all the return values and collect their span and suggestion.\n-                let mut suggestions = visitor\n+                if let Some(mut suggestions) = visitor\n                     .returns\n                     .iter()\n                     .map(|expr| {\n-                        (\n-                            expr.span,\n-                            format!(\n-                                \"Box::new({})\",\n-                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n-                            ),\n-                        )\n+                        let snip = sm.span_to_snippet(expr.span).ok()?;\n+                        Some((expr.span, format!(\"Box::new({})\", snip)))\n                     })\n-                    .collect::<Vec<_>>();\n-                // Add the suggestion for the return type.\n-                suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n-                err.multipart_suggestion(\n-                    \"return a boxed trait object instead\",\n-                    suggestions,\n-                    Applicability::MaybeIncorrect,\n-                );\n+                    .collect::<Option<Vec<_>>>()\n+                {\n+                    // Add the suggestion for the return type.\n+                    suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n+                    err.multipart_suggestion(\n+                        \"return a boxed trait object instead\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             } else {\n                 // This is currently not possible to trigger because E0038 takes precedence, but\n                 // leave it in for completeness in case anything changes in an earlier stage."}, {"sha": "e4ca7d4cde7dc3a97beeec55131cddb348e2f52b", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -1010,7 +1010,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // type.\n                 //\n                 // NOTE: This should be kept in sync with the similar code in\n-                // `rustc_middle::ty::instance::resolve_associated_item()`.\n+                // `rustc_ty::instance::resolve_associated_item()`.\n                 let node_item =\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;"}, {"sha": "33ecbe72a8c4f361408113500cc762f5b7d2f23b", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -1,5 +1,6 @@\n //! Provider for the `implied_outlives_bounds` query.\n-//! Do not call this query directory. See [`rustc_middle::traits::query::implied_outlives_bounds`].\n+//! Do not call this query directory. See\n+//! [`rustc_trait_selection::traits::query::type_op::implied_outlives_bounds`].\n \n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{self, Canonical};"}, {"sha": "677e373f2f4894c2aab5cd41f0ef91a786d8ac51", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -118,7 +118,7 @@ fn resolve_associated_item<'tcx>(\n             // Since this is a trait item, we need to see if the item is either a trait default item\n             // or a specialization because we can't resolve those unless we can `Reveal::All`.\n             // NOTE: This should be kept in sync with the similar code in\n-            // `rustc_middle::traits::project::assemble_candidates_from_impls()`.\n+            // `rustc_trait_selection::traits::project::assemble_candidates_from_impls()`.\n             let eligible = if leaf_def.is_final() {\n                 // Non-specializable items are always projectable.\n                 true"}, {"sha": "2ccf7890c3042327dc23048edfd04990605d907a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -432,18 +432,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let expr_map_node = self.tcx.hir().get_if_local(expr_def_id).unwrap();\n+        let hir = self.tcx.hir();\n+        let expr_map_node = hir.get_if_local(expr_def_id).unwrap();\n         let expected_args: Vec<_> = expected_sig\n             .sig\n             .inputs()\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(ty, None))\n             .collect();\n-        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n-        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n+            Some((sp, args)) => (Some(sp), args),\n+            None => (None, Vec::new()),\n+        };\n+        let expected_span =\n+            expected_sig.cause_span.unwrap_or_else(|| hir.span_if_local(expr_def_id).unwrap());\n         self.report_arg_count_mismatch(\n             expected_span,\n-            Some(closure_span),\n+            closure_span,\n             expected_args,\n             found_args,\n             true,"}, {"sha": "cac9113fd5d30e2d3007ea229b156cd63efb4c4c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// If one of the types is an uncalled function and calling it would yield the other type,\n-    /// suggest calling the function. Returns whether a suggestion was given.\n+    /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n     fn add_type_neq_err_label(\n         &self,\n         err: &mut rustc_errors::DiagnosticBuilder<'_>,\n@@ -514,24 +514,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .lookup_op_method(fn_sig.output(), &[other_ty], Op::Binary(op, is_assign))\n                 .is_ok()\n             {\n-                let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n-                    (\n-                        format!(\"{}( /* arguments */ )\", source_map.span_to_snippet(span).unwrap()),\n-                        Applicability::HasPlaceholders,\n-                    )\n-                } else {\n-                    (\n-                        format!(\"{}()\", source_map.span_to_snippet(span).unwrap()),\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                };\n+                if let Ok(snippet) = source_map.span_to_snippet(span) {\n+                    let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n+                        (format!(\"{}( /* arguments */ )\", snippet), Applicability::HasPlaceholders)\n+                    } else {\n+                        (format!(\"{}()\", snippet), Applicability::MaybeIncorrect)\n+                    };\n \n-                err.span_suggestion(\n-                    span,\n-                    \"you might have forgotten to call this function\",\n-                    variable_snippet,\n-                    applicability,\n-                );\n+                    err.span_suggestion(\n+                        span,\n+                        \"you might have forgotten to call this function\",\n+                        variable_snippet,\n+                        applicability,\n+                    );\n+                }\n                 return true;\n             }\n         }"}, {"sha": "c8eb271c807d62f032d92c9f335e00fa6b19cab5", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -8,18 +8,6 @@ use rustc_errors::Handler;\n #[cfg(test)]\n mod tests;\n \n-macro_rules! try_something {\n-    ($e:expr, $diag:expr, $out:expr) => {{\n-        match $e {\n-            Ok(c) => c,\n-            Err(e) => {\n-                $diag.struct_err(&e.to_string()).emit();\n-                return $out;\n-            }\n-        }\n-    }};\n-}\n-\n #[derive(Debug, Clone, Eq)]\n pub struct CssPath {\n     pub name: String,\n@@ -265,7 +253,13 @@ pub fn test_theme_against<P: AsRef<Path>>(\n     against: &CssPath,\n     diag: &Handler,\n ) -> (bool, Vec<String>) {\n-    let data = try_something!(fs::read(f), diag, (false, vec![]));\n+    let data = match fs::read(f) {\n+        Ok(c) => c,\n+        Err(e) => {\n+            diag.struct_err(&e.to_string()).emit();\n+            return (false, vec![]);\n+        }\n+    };\n \n     let paths = load_css_paths(&data);\n     let mut ret = vec![];"}, {"sha": "9840cfa43044f2a3a930a3e45c66f912cdf96504", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -289,10 +289,10 @@ pub fn rust_oom(layout: Layout) -> ! {\n pub mod __default_lib_allocator {\n     use super::{GlobalAlloc, Layout, System};\n     // These magic symbol names are used as a fallback for implementing the\n-    // `__rust_alloc` etc symbols (see `src/liballoc/alloc.rs) when there is\n+    // `__rust_alloc` etc symbols (see `src/liballoc/alloc.rs`) when there is\n     // no `#[global_allocator]` attribute.\n \n-    // for symbol names src/librustc_middle/middle/allocator.rs\n+    // for symbol names src/librustc_ast/expand/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n \n     // linkage directives are provided as part of the current compiler allocator"}, {"sha": "510a13ea5b1be0348d5be4d4e921043b315f4c92", "filename": "src/test/ui/associated-const/issue-69020-assoc-const-arith-overflow.noopt.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.noopt.stderr?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -0,0 +1,54 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:29:22\n+   |\n+LL |     const NEG: i32 = -i32::MIN + T::NEG;\n+   |                      ^^^^^^^^^ attempt to negate with overflow\n+   |\n+   = note: `#[deny(arithmetic_overflow)]` on by default\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:31:35\n+   |\n+LL |     const NEG_REV: i32 = T::NEG + (-i32::MIN);\n+   |                                   ^^^^^^^^^^^ attempt to negate with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:34:22\n+   |\n+LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n+   |                      ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:36:36\n+   |\n+LL |     const ADD_REV: i32 =  T::ADD + (i32::MAX+1);\n+   |                                    ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:39:22\n+   |\n+LL |     const DIV: i32 = (1/0) + T::DIV;\n+   |                      ^^^^^ attempt to divide by zero\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:41:35\n+   |\n+LL |     const DIV_REV: i32 = T::DIV + (1/0);\n+   |                                   ^^^^^ attempt to divide by zero\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:44:22\n+   |\n+LL |     const OOB: i32 = [1][1] + T::OOB;\n+   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:46:35\n+   |\n+LL |     const OOB_REV: i32 = T::OOB + [1][1];\n+   |                                   ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "510a13ea5b1be0348d5be4d4e921043b315f4c92", "filename": "src/test/ui/associated-const/issue-69020-assoc-const-arith-overflow.opt.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt.stderr?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -0,0 +1,54 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:29:22\n+   |\n+LL |     const NEG: i32 = -i32::MIN + T::NEG;\n+   |                      ^^^^^^^^^ attempt to negate with overflow\n+   |\n+   = note: `#[deny(arithmetic_overflow)]` on by default\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:31:35\n+   |\n+LL |     const NEG_REV: i32 = T::NEG + (-i32::MIN);\n+   |                                   ^^^^^^^^^^^ attempt to negate with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:34:22\n+   |\n+LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n+   |                      ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:36:36\n+   |\n+LL |     const ADD_REV: i32 =  T::ADD + (i32::MAX+1);\n+   |                                    ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:39:22\n+   |\n+LL |     const DIV: i32 = (1/0) + T::DIV;\n+   |                      ^^^^^ attempt to divide by zero\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:41:35\n+   |\n+LL |     const DIV_REV: i32 = T::DIV + (1/0);\n+   |                                   ^^^^^ attempt to divide by zero\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:44:22\n+   |\n+LL |     const OOB: i32 = [1][1] + T::OOB;\n+   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:46:35\n+   |\n+LL |     const OOB_REV: i32 = T::OOB + [1][1];\n+   |                                   ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "510a13ea5b1be0348d5be4d4e921043b315f4c92", "filename": "src/test/ui/associated-const/issue-69020-assoc-const-arith-overflow.opt_with_overflow_checks.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.opt_with_overflow_checks.stderr?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -0,0 +1,54 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:29:22\n+   |\n+LL |     const NEG: i32 = -i32::MIN + T::NEG;\n+   |                      ^^^^^^^^^ attempt to negate with overflow\n+   |\n+   = note: `#[deny(arithmetic_overflow)]` on by default\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:31:35\n+   |\n+LL |     const NEG_REV: i32 = T::NEG + (-i32::MIN);\n+   |                                   ^^^^^^^^^^^ attempt to negate with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:34:22\n+   |\n+LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n+   |                      ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:36:36\n+   |\n+LL |     const ADD_REV: i32 =  T::ADD + (i32::MAX+1);\n+   |                                    ^^^^^^^^^^^^ attempt to add with overflow\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:39:22\n+   |\n+LL |     const DIV: i32 = (1/0) + T::DIV;\n+   |                      ^^^^^ attempt to divide by zero\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:41:35\n+   |\n+LL |     const DIV_REV: i32 = T::DIV + (1/0);\n+   |                                   ^^^^^ attempt to divide by zero\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:44:22\n+   |\n+LL |     const OOB: i32 = [1][1] + T::OOB;\n+   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: this operation will panic at runtime\n+  --> $DIR/issue-69020-assoc-const-arith-overflow.rs:46:35\n+   |\n+LL |     const OOB_REV: i32 = T::OOB + [1][1];\n+   |                                   ^^^^^^ index out of bounds: the len is 1 but the index is 1\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "850f65ae9d183b9c8a70f874b4c51dcd80fa9182", "filename": "src/test/ui/associated-const/issue-69020-assoc-const-arith-overflow.rs", "status": "renamed", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-69020-assoc-const-arith-overflow.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -9,21 +9,40 @@ use std::i32;\n \n pub trait Foo {\n     const NEG: i32;\n+    const NEG_REV: i32;\n+\n     const ADD: i32;\n+    const ADD_REV: i32;\n+\n     const DIV: i32;\n+    const DIV_REV: i32;\n+\n     const OOB: i32;\n+    const OOB_REV: i32;\n }\n \n-// These constants cannot be evaluated already (they depend on `T::N`), so\n-// they can just be linted like normal run-time code.  But codegen works\n-// a bit different in const context, so this test makes sure that we still catch overflow.\n+// These constants cannot be evaluated already (they depend on `T::N`), so they can just be linted\n+// like normal run-time code. But codegen works a bit different in const context, so this test\n+// makes sure that we still catch overflow. Also make sure we emit the same lints if we reverse the\n+// operands (so that the generic operand comes first).\n impl<T: Foo> Foo for Vec<T> {\n     const NEG: i32 = -i32::MIN + T::NEG;\n     //~^ ERROR arithmetic operation will overflow\n+    const NEG_REV: i32 = T::NEG + (-i32::MIN);\n+    //~^ ERROR arithmetic operation will overflow\n+\n     const ADD: i32 = (i32::MAX+1) + T::ADD;\n     //~^ ERROR arithmetic operation will overflow\n+    const ADD_REV: i32 =  T::ADD + (i32::MAX+1);\n+    //~^ ERROR arithmetic operation will overflow\n+\n     const DIV: i32 = (1/0) + T::DIV;\n     //~^ ERROR operation will panic\n+    const DIV_REV: i32 = T::DIV + (1/0);\n+    //~^ ERROR operation will panic\n+\n     const OOB: i32 = [1][1] + T::OOB;\n     //~^ ERROR operation will panic\n+    const OOB_REV: i32 = T::OOB + [1][1];\n+    //~^ ERROR operation will panic\n }", "previous_filename": "src/test/ui/consts/issue-69020.rs"}, {"sha": "c48a106ef4656ce0287be97b5ec7b186d9c79fbc", "filename": "src/test/ui/consts/issue-69020.noopt.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.noopt.stderr?ref=34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d", "patch": "@@ -1,30 +0,0 @@\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:21:22\n-   |\n-LL |     const NEG: i32 = -i32::MIN + T::NEG;\n-   |                      ^^^^^^^^^ attempt to negate with overflow\n-   |\n-   = note: `#[deny(arithmetic_overflow)]` on by default\n-\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:23:22\n-   |\n-LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n-   |                      ^^^^^^^^^^^^ attempt to add with overflow\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:25:22\n-   |\n-LL |     const DIV: i32 = (1/0) + T::DIV;\n-   |                      ^^^^^ attempt to divide by zero\n-   |\n-   = note: `#[deny(unconditional_panic)]` on by default\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:27:22\n-   |\n-LL |     const OOB: i32 = [1][1] + T::OOB;\n-   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "c48a106ef4656ce0287be97b5ec7b186d9c79fbc", "filename": "src/test/ui/consts/issue-69020.opt.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt.stderr?ref=34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d", "patch": "@@ -1,30 +0,0 @@\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:21:22\n-   |\n-LL |     const NEG: i32 = -i32::MIN + T::NEG;\n-   |                      ^^^^^^^^^ attempt to negate with overflow\n-   |\n-   = note: `#[deny(arithmetic_overflow)]` on by default\n-\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:23:22\n-   |\n-LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n-   |                      ^^^^^^^^^^^^ attempt to add with overflow\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:25:22\n-   |\n-LL |     const DIV: i32 = (1/0) + T::DIV;\n-   |                      ^^^^^ attempt to divide by zero\n-   |\n-   = note: `#[deny(unconditional_panic)]` on by default\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:27:22\n-   |\n-LL |     const OOB: i32 = [1][1] + T::OOB;\n-   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "c48a106ef4656ce0287be97b5ec7b186d9c79fbc", "filename": "src/test/ui/consts/issue-69020.opt_with_overflow_checks.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-69020.opt_with_overflow_checks.stderr?ref=34f7f55e7aad1cedbddf6fecb4f293377d0cfd1d", "patch": "@@ -1,30 +0,0 @@\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:21:22\n-   |\n-LL |     const NEG: i32 = -i32::MIN + T::NEG;\n-   |                      ^^^^^^^^^ attempt to negate with overflow\n-   |\n-   = note: `#[deny(arithmetic_overflow)]` on by default\n-\n-error: this arithmetic operation will overflow\n-  --> $DIR/issue-69020.rs:23:22\n-   |\n-LL |     const ADD: i32 = (i32::MAX+1) + T::ADD;\n-   |                      ^^^^^^^^^^^^ attempt to add with overflow\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:25:22\n-   |\n-LL |     const DIV: i32 = (1/0) + T::DIV;\n-   |                      ^^^^^ attempt to divide by zero\n-   |\n-   = note: `#[deny(unconditional_panic)]` on by default\n-\n-error: this operation will panic at runtime\n-  --> $DIR/issue-69020.rs:27:22\n-   |\n-LL |     const OOB: i32 = [1][1] + T::OOB;\n-   |                      ^^^^^^ index out of bounds: the len is 1 but the index is 1\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "c2683157f797fa4bfaa58e7e8ae063a05cd1ec83", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -0,0 +1,10 @@\n+fn a() -> i32 {\n+    3\n+}\n+\n+pub fn main() {\n+    assert_eq!(a, 0);\n+    //~^ ERROR binary operation `==` cannot\n+    //~| ERROR mismatched types\n+    //~| ERROR doesn't implement\n+}"}, {"sha": "467c15cc52d45d5efd4f9d87f1a6440f80f52bdf", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -0,0 +1,41 @@\n+error[E0369]: binary operation `==` cannot be applied to type `fn() -> i32 {a}`\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     fn() -> i32 {a}\n+   |     {integer}\n+   |     help: you might have forgotten to call this function: `*left_val()`\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^ expected fn item, found integer\n+   |\n+   = note: expected fn item `fn() -> i32 {a}`\n+                 found type `i32`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `fn() -> i32 {a}` doesn't implement `std::fmt::Debug`\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL | fn a() -> i32 {\n+   |    - consider calling this function\n+...\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^ `fn() -> i32 {a}` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `fn() -> i32 {a}`\n+   = help: use parentheses to call the function: `a()`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `&fn() -> i32 {a}`\n+   = note: required by `std::fmt::Debug::fmt`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0369.\n+For more information about an error, try `rustc --explain E0277`."}]}