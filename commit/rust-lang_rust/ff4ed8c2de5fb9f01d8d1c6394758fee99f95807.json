{"sha": "ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNGVkOGMyZGU1ZmI5ZjAxZDhkMWM2Mzk0NzU4ZmVlOTlmOTU4MDc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:51:59Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:51:59Z"}, "message": "Rename `hair::Pattern` to `hair::Pat`", "tree": {"sha": "68a48ee20c499711ce0d8d03f643026f3a30ecd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68a48ee20c499711ce0d8d03f643026f3a30ecd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "html_url": "https://github.com/rust-lang/rust/commit/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ff44873d7d12951a52b7f1d50560cd45d5ea2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ff44873d7d12951a52b7f1d50560cd45d5ea2c", "html_url": "https://github.com/rust-lang/rust/commit/79ff44873d7d12951a52b7f1d50560cd45d5ea2c"}], "stats": {"total": 221, "additions": 108, "deletions": 113}, "files": [{"sha": "8db06aa375e238066ac010bbfaadf5437fee6fad", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -298,7 +298,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n-        irrefutable_pat: Pattern<'tcx>,\n+        irrefutable_pat: Pat<'tcx>,\n         initializer: ExprRef<'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // dubious way, so it may be that the test is kind of\n             // broken.\n             PatKind::AscribeUserType {\n-                subpattern: Pattern {\n+                subpattern: Pat {\n                     kind: box PatKind::Binding {\n                         mode: BindingMode::ByValue,\n                         var,\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n-        irrefutable_pat: Pattern<'tcx>,\n+        irrefutable_pat: Pat<'tcx>,\n         initializer: &Place<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n-        pattern: &Pattern<'tcx>,\n+        pattern: &Pat<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn visit_bindings(\n         &mut self,\n-        pattern: &Pattern<'tcx>,\n+        pattern: &Pat<'tcx>,\n         pattern_user_ty: UserTypeProjections,\n         f: &mut impl FnMut(\n             &mut Self,\n@@ -718,7 +718,7 @@ pub struct MatchPair<'pat, 'tcx> {\n     place: Place<'tcx>,\n \n     // ... must match this pattern.\n-    pattern: &'pat Pattern<'tcx>,\n+    pattern: &'pat Pat<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -1339,7 +1339,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Pattern binding - used for `let` and function parameters as well.\n+// Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Initializes each of the bindings from the candidate by"}, {"sha": "d8bb0b4f6cc57d3c091912d254d1795e1630d683", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -722,9 +722,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn candidate_after_slice_test<'pat>(&mut self,\n                                         match_pair_index: usize,\n                                         candidate: &mut Candidate<'pat, 'tcx>,\n-                                        prefix: &'pat [Pattern<'tcx>],\n-                                        opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                        suffix: &'pat [Pattern<'tcx>]) {\n+                                        prefix: &'pat [Pat<'tcx>],\n+                                        opt_slice: Option<&'pat Pat<'tcx>>,\n+                                        suffix: &'pat [Pat<'tcx>]) {\n         let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix(\n             &mut candidate.match_pairs,"}, {"sha": "83fb924af63812529feea8778f3f73b7c656c3b8", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -22,9 +22,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n                                      place: &Place<'tcx>,\n-                                     prefix: &'pat [Pattern<'tcx>],\n-                                     opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                     suffix: &'pat [Pattern<'tcx>]) {\n+                                     prefix: &'pat [Pat<'tcx>],\n+                                     opt_slice: Option<&'pat Pat<'tcx>>,\n+                                     suffix: &'pat [Pat<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         let min_length = min_length.try_into().unwrap();\n \n@@ -101,7 +101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub fn new(place: Place<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             place,\n             pattern,"}, {"sha": "33d67dcf914480f5d2bf344a5b83490bf5de4d43", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -78,7 +78,7 @@ fn mirror_stmts<'a, 'tcx>(\n                 if let Some(ty) = &local.ty {\n                     if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n                         debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                        pattern = Pattern {\n+                        pattern = Pat {\n                             ty: pattern.ty,\n                             span: pattern.span,\n                             kind: Box::new(PatKind::AscribeUserType {"}, {"sha": "f7cd29f2e67ef591e02af4607b812c2961cf5feb", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -153,16 +153,13 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n-        Pattern::from_hir(tcx,\n-                          self.param_env.and(self.identity_substs),\n-                          self.tables(),\n-                          p)\n+        Pat::from_hir(tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n     }\n \n     pub fn trait_method(&mut self,"}, {"sha": "a76377d24bdf95bf1b4a52600c0c5cf6a1c33e11", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -20,7 +20,7 @@ pub mod cx;\n mod constant;\n \n pub mod pattern;\n-pub use self::pattern::{BindingMode, Pattern, PatKind, PatRange, FieldPat};\n+pub use self::pattern::{BindingMode, Pat, PatKind, PatRange, FieldPat};\n pub(crate) use self::pattern::PatTyProj;\n \n mod util;\n@@ -83,7 +83,7 @@ pub enum StmtKind<'tcx> {\n         /// `let <PAT> = ...`\n         ///\n         /// if a type is included, it is added as an ascription pattern\n-        pattern: Pattern<'tcx>,\n+        pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n@@ -293,7 +293,7 @@ pub struct FruInfo<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub pattern: Pattern<'tcx>,\n+    pub pattern: Pat<'tcx>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n@@ -304,7 +304,7 @@ pub struct Arm<'tcx> {\n impl Arm<'tcx> {\n     // HACK(or_patterns; Centril | dlrobertson): Remove this and\n     // correctly handle each case in which this method is used.\n-    pub fn top_pats_hack(&self) -> &[Pattern<'tcx>] {\n+    pub fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n         match &*self.pattern.kind {\n             PatKind::Or { pats } => pats,\n             _ => std::slice::from_ref(&self.pattern),"}, {"sha": "75a84f6ec648b6dec057bc4fb00705574679817c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -163,7 +163,7 @@ use self::WitnessPreference::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{FieldPat, Pattern, PatKind, PatRange};\n+use super::{FieldPat, Pat, PatKind, PatRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n@@ -188,9 +188,7 @@ use std::ops::RangeInclusive;\n use std::u128;\n use std::convert::TryInto;\n \n-pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n-                                -> &'a Pattern<'tcx>\n-{\n+pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> &'a Pat<'tcx> {\n     cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n@@ -243,7 +241,7 @@ impl LiteralExpander<'tcx> {\n }\n \n impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n-    fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n+    fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind, pat.kind);\n         match (&pat.ty.kind, &*pat.kind) {\n             (\n@@ -253,11 +251,11 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n                     ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n                 } },\n             ) => {\n-                Pattern {\n+                Pat {\n                     ty: pat.ty,\n                     span: pat.span,\n                     kind: box PatKind::Deref {\n-                        subpattern: Pattern {\n+                        subpattern: Pat {\n                             ty: rty,\n                             span: pat.span,\n                             kind: box PatKind::Constant { value: self.tcx.mk_const(Const {\n@@ -276,7 +274,7 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     }\n }\n \n-impl<'tcx> Pattern<'tcx> {\n+impl<'tcx> Pat<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n             PatKind::Binding { subpattern: None, .. } | PatKind::Wild =>\n@@ -288,14 +286,14 @@ impl<'tcx> Pattern<'tcx> {\n \n /// A 2D matrix. Nx1 matrices are very common, which is why `SmallVec[_; 2]`\n /// works well for each row.\n-pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pattern<'tcx>; 2]>>);\n+pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pat<'tcx>; 2]>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n-    pub fn push(&mut self, row: SmallVec<[&'p Pattern<'tcx>; 2]>) {\n+    pub fn push(&mut self, row: SmallVec<[&'p Pat<'tcx>; 2]>) {\n         self.0.push(row)\n     }\n }\n@@ -344,9 +342,9 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n+impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pat<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n     fn from_iter<T>(iter: T) -> Self\n-        where T: IntoIterator<Item=SmallVec<[&'p Pattern<'tcx>; 2]>>\n+        where T: IntoIterator<Item=SmallVec<[&'p Pat<'tcx>; 2]>>\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -362,8 +360,8 @@ pub struct MatchCheckCtxt<'a, 'tcx> {\n     /// statement.\n     pub module: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n-    pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+    pub pattern_arena: &'a TypedArena<Pat<'tcx>>,\n+    pub byte_array_map: FxHashMap<*const Pat<'tcx>, Vec<&'a Pat<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -395,7 +393,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool {\n+    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pat<'tcx>) -> bool {\n         match *pattern.kind {\n             PatKind::Variant { adt_def, variant_index, .. } => {\n                 let ref variant = adt_def.variants[variant_index];\n@@ -514,10 +512,10 @@ struct PatCtxt<'tcx> {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Clone, Debug)]\n-pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n+pub struct Witness<'tcx>(Vec<Pat<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    pub fn single_pattern(self) -> Pattern<'tcx> {\n+    pub fn single_pattern(self) -> Pat<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -531,7 +529,7 @@ impl<'tcx> Witness<'tcx> {\n     {\n         let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n         self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n-            Pattern {\n+            Pat {\n                 ty,\n                 span: DUMMY_SP,\n                 kind: box PatKind::Wild,\n@@ -617,7 +615,7 @@ impl<'tcx> Witness<'tcx> {\n             }\n         };\n \n-        self.0.push(Pattern {\n+        self.0.push(Pat {\n             ty,\n             span: DUMMY_SP,\n             kind: Box::new(pat),\n@@ -710,7 +708,7 @@ fn all_constructors<'a, 'tcx>(\n \n fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n where\n-    I: Iterator<Item = &'p Pattern<'tcx>>,\n+    I: Iterator<Item = &'p Pat<'tcx>>,\n     'tcx: 'p,\n {\n     // The exhaustiveness-checking paper does not include any details on\n@@ -874,7 +872,7 @@ impl<'tcx> IntRange<'tcx> {\n     fn from_pat(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        mut pat: &Pattern<'tcx>,\n+        mut pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n@@ -1070,7 +1068,7 @@ fn compute_missing_ctors<'tcx>(\n pub fn is_useful<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &[&Pattern<'tcx>],\n+    v: &[&Pat<'tcx>],\n     witness: WitnessPreference,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n@@ -1247,7 +1245,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor.\n                         pats.into_iter().map(|mut witness| {\n-                            witness.0.push(Pattern {\n+                            witness.0.push(Pat {\n                                 ty: pcx.ty,\n                                 span: DUMMY_SP,\n                                 kind: box PatKind::Wild,\n@@ -1285,15 +1283,15 @@ pub fn is_useful<'p, 'a, 'tcx>(\n fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n-    v: &[&Pattern<'tcx>],\n+    v: &[&Pat<'tcx>],\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n-        Pattern {\n+        Pat {\n             ty,\n             span: DUMMY_SP,\n             kind: box PatKind::Wild,\n@@ -1325,7 +1323,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-                          pat: &Pattern<'tcx>,\n+                          pat: &Pat<'tcx>,\n                           pcx: PatCtxt<'tcx>)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n@@ -1446,9 +1444,9 @@ fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     _span: Span,\n     const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pattern<'tcx>],\n-    slice: &Option<Pattern<'tcx>>,\n-    suffix: &[Pattern<'tcx>],\n+    prefix: &[Pat<'tcx>],\n+    slice: &Option<Pat<'tcx>>,\n+    suffix: &[Pat<'tcx>],\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.kind) {\n@@ -1625,8 +1623,8 @@ fn constructor_intersects_pattern<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n-    pat: &'p Pattern<'tcx>,\n-) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n+    pat: &'p Pat<'tcx>,\n+) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n     if should_treat_range_exhaustively(tcx, ctor) {\n         match (IntRange::from_ctor(tcx, param_env, ctor), IntRange::from_pat(tcx, param_env, pat)) {\n             (Some(ctor), Some(pat)) => {\n@@ -1654,7 +1652,7 @@ fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n-    pat: &Pattern<'tcx>,\n+    pat: &Pat<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n@@ -1715,8 +1713,8 @@ fn constructor_covered_by_range<'tcx>(\n \n fn patterns_for_variant<'p, 'tcx>(\n     subpatterns: &'p [FieldPat<'tcx>],\n-    wild_patterns: &[&'p Pattern<'tcx>])\n-    -> SmallVec<[&'p Pattern<'tcx>; 2]>\n+    wild_patterns: &[&'p Pat<'tcx>])\n+    -> SmallVec<[&'p Pat<'tcx>; 2]>\n {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n@@ -1738,10 +1736,10 @@ fn patterns_for_variant<'p, 'tcx>(\n /// fields filled with wild patterns.\n fn specialize<'p, 'a: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'p Pattern<'tcx>],\n+    r: &[&'p Pat<'tcx>],\n     constructor: &Constructor<'tcx>,\n-    wild_patterns: &[&'p Pattern<'tcx>],\n-) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n+    wild_patterns: &[&'p Pat<'tcx>],\n+) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n     let pat = &r[0];\n \n     let head = match *pat.kind {\n@@ -1827,7 +1825,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                             ).ok()?;\n                             let scalar = scalar.not_undef().ok()?;\n                             let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                            let pattern = Pattern {\n+                            let pattern = Pat {\n                                 ty,\n                                 span: pat.span,\n                                 kind: box PatKind::Constant { value },"}, {"sha": "4572519683d4f20ed0a50f255b151553f6677bd5", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -2,7 +2,7 @@ use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n-use super::{Pattern, PatCtxt, PatternError, PatKind};\n+use super::{PatCtxt, PatternError, PatKind};\n \n use rustc::middle::borrowck::SignalledError;\n use rustc::session::Session;\n@@ -335,7 +335,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n // Check for unreachable patterns\n fn check_arms<'tcx>(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-    arms: &[(Vec<(&Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+    arms: &[(Vec<(&super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n     source: hir::MatchSource,\n ) {\n     let mut seen = Matrix::empty();\n@@ -420,8 +420,8 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n-) -> Result<(), Vec<Pattern<'tcx>>> {\n-    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+) -> Result<(), Vec<super::Pat<'tcx>>> {\n+    let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n     match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n@@ -458,7 +458,7 @@ fn check_exhaustive<'tcx>(\n     .emit();\n }\n \n-fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n+fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     const LIMIT: usize = 3;\n     match witnesses {\n         [] => bug!(),\n@@ -475,7 +475,7 @@ fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n     }\n }\n \n-fn pattern_not_convered_label(witnesses: &[Pattern<'_>], joined_patterns: &str) -> String {\n+fn pattern_not_convered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n }\n \n@@ -484,7 +484,7 @@ fn adt_defined_here(\n     cx: &MatchCheckCtxt<'_, '_>,\n     err: &mut DiagnosticBuilder<'_>,\n     ty: Ty<'_>,\n-    witnesses: &[Pattern<'_>],\n+    witnesses: &[super::Pat<'_>],\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind {\n@@ -500,7 +500,7 @@ fn adt_defined_here(\n     }\n }\n \n-fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n+fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n     if let ty::Adt(def, _) = ty.kind {\n         // Don't point at variants that have already been covered due to other patterns to avoid"}, {"sha": "4d2fee3d160ede89a684f6a4b7f39bc21959991b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ed8c2de5fb9f01d8d1c6394758fee99f95807/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ff4ed8c2de5fb9f01d8d1c6394758fee99f95807", "patch": "@@ -50,11 +50,11 @@ pub enum BindingMode {\n #[derive(Clone, Debug)]\n pub struct FieldPat<'tcx> {\n     pub field: Field,\n-    pub pattern: Pattern<'tcx>,\n+    pub pattern: Pat<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Pattern<'tcx> {\n+pub struct Pat<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n     pub kind: Box<PatKind<'tcx>>,\n@@ -121,7 +121,7 @@ pub enum PatKind<'tcx> {\n \n     AscribeUserType {\n         ascription: Ascription<'tcx>,\n-        subpattern: Pattern<'tcx>,\n+        subpattern: Pat<'tcx>,\n     },\n \n     /// `x`, `ref x`, `x @ P`, etc.\n@@ -131,7 +131,7 @@ pub enum PatKind<'tcx> {\n         mode: BindingMode,\n         var: hir::HirId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<Pattern<'tcx>>,\n+        subpattern: Option<Pat<'tcx>>,\n     },\n \n     /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n@@ -151,7 +151,7 @@ pub enum PatKind<'tcx> {\n \n     /// `box P`, `&P`, `&mut P`, etc.\n     Deref {\n-        subpattern: Pattern<'tcx>,\n+        subpattern: Pat<'tcx>,\n     },\n \n     Constant {\n@@ -164,22 +164,22 @@ pub enum PatKind<'tcx> {\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n     /// e.g., `&[ref xs @ ..]`.\n     Slice {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n     },\n \n     /// Fixed match against an array; irrefutable.\n     Array {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n     },\n \n     /// An or-pattern, e.g. `p | q`.\n     /// Invariant: `pats.len() >= 2`.\n     Or {\n-        pats: Vec<Pattern<'tcx>>,\n+        pats: Vec<Pat<'tcx>>,\n     },\n }\n \n@@ -190,7 +190,7 @@ pub struct PatRange<'tcx> {\n     pub end: RangeEnd,\n }\n \n-impl<'tcx> fmt::Display for Pattern<'tcx> {\n+impl<'tcx> fmt::Display for Pat<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Printing lists is a chore.\n         let mut first = true;\n@@ -356,7 +356,7 @@ pub struct PatCtxt<'a, 'tcx> {\n     include_lint_checks: bool,\n }\n \n-impl<'a, 'tcx> Pattern<'tcx> {\n+impl<'a, 'tcx> Pat<'tcx> {\n     pub fn from_hir(\n         tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n             let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n             tcx.sess.delay_span_bug(pat.span, &msg);\n         }\n-        debug!(\"Pattern::from_hir({:?}) = {:?}\", pat, result);\n+        debug!(\"Pat::from_hir({:?}) = {:?}\", pat, result);\n         result\n     }\n }\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         self\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             .rev()\n             .fold(unadjusted_pat, |pat, ref_ty| {\n                     debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n-                    Pattern {\n+                    Pat {\n                         span: pat.span,\n                         ty: ref_ty,\n                         kind: Box::new(PatKind::Deref { subpattern: pat }),\n@@ -440,13 +440,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         match self.lower_lit(expr) {\n             PatKind::AscribeUserType {\n                 ascription: lo_ascription,\n-                subpattern: Pattern { kind: box kind, .. },\n+                subpattern: Pat { kind: box kind, .. },\n             } => (kind, Some(lo_ascription)),\n             kind => (kind, None),\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n         let kind = match pat.kind {\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     if let Some(ascription) = ascription {\n                         kind = PatKind::AscribeUserType {\n                             ascription: *ascription,\n-                            subpattern: Pattern { span: pat.span, ty, kind: Box::new(kind), },\n+                            subpattern: Pat { span: pat.span, ty, kind: Box::new(kind), },\n                         };\n                     }\n                 }\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 match ty.kind {\n                     ty::Ref(_, ty, _) =>\n                         PatKind::Deref {\n-                            subpattern: Pattern {\n+                            subpattern: Pat {\n                                 ty,\n                                 span: pat.span,\n                                 kind: Box::new(self.slice_or_array_pattern(\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     ty::Array(..) =>\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n                     ty::Error => { // Avoid ICE\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ =>\n                         span_bug!(\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                         PatKind::Leaf { subpatterns }\n                     }\n                     ty::Error => { // Avoid ICE (#50577)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 }\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let var_ty = self.tables.node_type(pat.hir_id);\n                 if let ty::Error = var_ty.kind {\n                     // Avoid ICE\n-                    return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n+                    return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                 };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n                     ty::Error => { // Avoid ICE (#50585)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span,\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n@@ -682,28 +682,28 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n         };\n \n-        Pattern {\n+        Pat {\n             span: pat.span,\n             ty,\n             kind: Box::new(kind),\n         }\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pat<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>>\n     {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n     fn flatten_nested_slice_patterns(\n         &mut self,\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>)\n-        -> (Vec<Pattern<'tcx>>, Option<Pattern<'tcx>>, Vec<Pattern<'tcx>>)\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>)\n+        -> (Vec<Pat<'tcx>>, Option<Pat<'tcx>>, Vec<Pat<'tcx>>)\n     {\n         let orig_slice = match slice {\n             Some(orig_slice) => orig_slice,\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 (orig_prefix, slice, suffix)\n             }\n             _ => {\n-                (orig_prefix, Some(Pattern {\n+                (orig_prefix, Some(Pat {\n                     kind: box kind, ..orig_slice\n                 }), orig_suffix)\n             }\n@@ -825,7 +825,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n             debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n             kind = PatKind::AscribeUserType {\n-                subpattern: Pattern {\n+                subpattern: Pat {\n                     span,\n                     ty,\n                     kind: Box::new(kind),\n@@ -848,7 +848,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                   qpath: &hir::QPath,\n                   id: hir::HirId,\n                   span: Span)\n-                  -> Pattern<'tcx> {\n+                  -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n         let is_associated_const = match res {\n@@ -879,7 +879,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                                 let user_provided_types = self.tables().user_provided_types();\n                                 return if let Some(u_ty) = user_provided_types.get(id) {\n                                     let user_ty = PatTyProj::from_user_type(*u_ty);\n-                                    Pattern {\n+                                    Pat {\n                                         span,\n                                         kind: Box::new(\n                                             PatKind::AscribeUserType {\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             _ => self.lower_variant_or_leaf(res, id, span, ty, vec![]),\n         };\n \n-        Pattern {\n+        Pat {\n             span,\n             ty,\n             kind: Box::new(kind),\n@@ -986,7 +986,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n-    ) -> Pattern<'tcx> {\n+    ) -> Pat<'tcx> {\n         // This method is just a warpper handling a validity check; the heavy lifting is\n         // performed by the recursive const_to_pat_inner method, which is not meant to be\n         // invoked except by this method.\n@@ -1057,7 +1057,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         // value, so that we will not subsequently issue an irrelevant\n         // lint for the same const value.\n         saw_const_match_error: &mut bool,\n-    ) -> Pattern<'tcx> {\n+    ) -> Pat<'tcx> {\n \n         let mut adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n         };\n \n-        Pattern {\n+        Pat {\n             span,\n             ty: cv.ty,\n             kind: Box::new(kind),\n@@ -1313,7 +1313,7 @@ pub trait PatternFoldable<'tcx> : Sized {\n }\n \n pub trait PatternFolder<'tcx> : Sized {\n-    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n+    fn fold_pattern(&mut self, pattern: &Pat<'tcx>) -> Pat<'tcx> {\n         pattern.super_fold_with(self)\n     }\n \n@@ -1370,13 +1370,13 @@ impl<'tcx> PatternFoldable<'tcx> for FieldPat<'tcx> {\n     }\n }\n \n-impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n+impl<'tcx> PatternFoldable<'tcx> for Pat<'tcx> {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_pattern(self)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Pattern {\n+        Pat {\n             ty: self.ty.fold_with(folder),\n             span: self.span.fold_with(folder),\n             kind: self.kind.fold_with(folder)"}]}