{"sha": "d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "node_id": "C_kwDOAAsO6NoAKGQxZjE0ZWUxYjAxZGQzOWNkNzljZDljZGQ3MWU5MWJhNTIxOTAxZmU", "commit": {"author": {"name": "nidnogg", "email": "henriquevt98@gmail.com", "date": "2022-08-19T18:36:09Z"}, "committer": {"name": "nidnogg", "email": "henriquevt98@gmail.com", "date": "2022-08-22T02:22:54Z"}, "message": "Added several more migrations under ops.rs, failing some tests though", "tree": {"sha": "0944f79628b62d2b5bffd77df99b996dfbd683f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0944f79628b62d2b5bffd77df99b996dfbd683f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "html_url": "https://github.com/rust-lang/rust/commit/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/comments", "author": {"login": "nidnogg", "id": 17261185, "node_id": "MDQ6VXNlcjE3MjYxMTg1", "avatar_url": "https://avatars.githubusercontent.com/u/17261185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nidnogg", "html_url": "https://github.com/nidnogg", "followers_url": "https://api.github.com/users/nidnogg/followers", "following_url": "https://api.github.com/users/nidnogg/following{/other_user}", "gists_url": "https://api.github.com/users/nidnogg/gists{/gist_id}", "starred_url": "https://api.github.com/users/nidnogg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nidnogg/subscriptions", "organizations_url": "https://api.github.com/users/nidnogg/orgs", "repos_url": "https://api.github.com/users/nidnogg/repos", "events_url": "https://api.github.com/users/nidnogg/events{/privacy}", "received_events_url": "https://api.github.com/users/nidnogg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nidnogg", "id": 17261185, "node_id": "MDQ6VXNlcjE3MjYxMTg1", "avatar_url": "https://avatars.githubusercontent.com/u/17261185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nidnogg", "html_url": "https://github.com/nidnogg", "followers_url": "https://api.github.com/users/nidnogg/followers", "following_url": "https://api.github.com/users/nidnogg/following{/other_user}", "gists_url": "https://api.github.com/users/nidnogg/gists{/gist_id}", "starred_url": "https://api.github.com/users/nidnogg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nidnogg/subscriptions", "organizations_url": "https://api.github.com/users/nidnogg/orgs", "repos_url": "https://api.github.com/users/nidnogg/repos", "events_url": "https://api.github.com/users/nidnogg/events{/privacy}", "received_events_url": "https://api.github.com/users/nidnogg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e8aaf830578d71ac55c6e612dbcff7aef766d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e8aaf830578d71ac55c6e612dbcff7aef766d2", "html_url": "https://github.com/rust-lang/rust/commit/33e8aaf830578d71ac55c6e612dbcff7aef766d2"}], "stats": {"total": 285, "additions": 187, "deletions": 98}, "files": [{"sha": "7fa6a67a7f91d3142a780b841d40d714deeb8cd3", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "patch": "@@ -111,3 +111,84 @@ pub(crate) struct UnstableConstFn {\n     pub span: Span,\n     pub def_id: String,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefs {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefsRaw {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+pub(crate) struct NonConstFmtMacroCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::non_const_fn_call, code = \"E0015\")]\n+pub(crate) struct NonConstFnCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path_str: String,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::unallowed_op_in_const_context)]\n+pub(crate) struct UnallowedOpInConstContext {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+pub(crate) struct UnallowedHeapAllocations {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+pub(crate) struct UnallowedInlineAsm {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+pub(crate) struct InteriorMutableDataRefer {\n+    #[primary_span]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(const_eval::interior_mutability_borrow)]\n+pub(crate) struct InteriorMutabilityBorrow {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "e2cf9b2b3c14d0c7be1344a98b4ee3b121557060", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 57, "deletions": 97, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "patch": "@@ -24,8 +24,11 @@ use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n use crate::errors::{\n-    MutDerefErr, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall, UnstableConstFn,\n+    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n+    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n+    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n+    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n+    UnallowedOpInConstContext, UnstableConstFn,\n };\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n@@ -305,22 +308,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 err\n             }\n             _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                struct_span_err!(\n-                    ccx.tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const formatting macro in {}s\",\n-                    ccx.const_kind(),\n-                )\n+                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n             }\n-            _ => struct_span_err!(\n-                ccx.tcx.sess,\n+            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n                 span,\n-                E0015,\n-                \"cannot call non-const fn `{}` in {}s\",\n-                ccx.tcx.def_path_str_with_substs(callee, substs),\n-                ccx.const_kind(),\n-            ),\n+                def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n+                kind: ccx.const_kind(),\n+            }),\n         };\n \n         err.note(&format!(\n@@ -387,9 +381,12 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n-            feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n+            ccx.tcx.sess.create_feature_err(\n+                UnallowedOpInConstContext { span, msg },\n+                sym::const_async_blocks,\n+            )\n         } else {\n-            ccx.tcx.sess.struct_span_err(span, &msg)\n+            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -402,23 +399,11 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n+        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n             span,\n-            E0010,\n-            \"allocations are not allowed in {}s\",\n-            ccx.const_kind()\n-        );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"The value of statics and constants must be known at compile time, \\\n-                 and they live for the entire lifetime of a program. Creating a boxed \\\n-                 value allocates memory on the heap at runtime, and therefore cannot \\\n-                 be done at compile time.\",\n-            );\n-        }\n-        err\n+            kind: ccx.const_kind(),\n+            teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n+        })\n     }\n }\n \n@@ -430,13 +415,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"inline assembly is not allowed in {}s\",\n-            ccx.const_kind()\n-        )\n+        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -482,12 +461,7 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_refs_to_cell,\n-            span,\n-            \"cannot borrow here, since the borrowed element may contain interior mutability\",\n-        )\n+        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -502,32 +476,22 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0492,\n-            \"{}s cannot refer to interior mutable data\",\n-            ccx.const_kind(),\n-        );\n-        err.span_label(\n-            span,\n-            \"this borrow of an interior mutable value may end up in the final value\",\n-        );\n+        // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            err.help(\n-                \"to fix this, the value can be extracted to a separate \\\n-                `static` item and then referenced\",\n-            );\n-        }\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"A constant containing interior mutable data behind a reference can allow you\n-                 to modify that data. This would make multiple uses of a constant to be able to\n-                 see different values and allow circumventing the `Send` and `Sync` requirements\n-                 for shared mutable data, which is unsound.\",\n-            );\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: Some(()),\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n+        } else {\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: None,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n         }\n-        err\n     }\n }\n \n@@ -553,33 +517,29 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let raw = match self.0 {\n-            hir::BorrowKind::Raw => \"raw \",\n-            hir::BorrowKind::Ref => \"\",\n-        };\n-\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0764,\n-            \"{}mutable references are not allowed in the final value of {}s\",\n-            raw,\n-            ccx.const_kind(),\n-        );\n-\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"References in statics and constants may only refer \\\n-                      to immutable values.\\n\\n\\\n-                      Statics are shared everywhere, and if they refer to \\\n-                      mutable data one might violate memory safety since \\\n-                      holding multiple mutable references to shared data \\\n-                      is not allowed.\\n\\n\\\n-                      If you really want global mutable state, try using \\\n-                      static mut or a global UnsafeCell.\",\n-            );\n+        // let raw = match self.0 {\n+        //     hir::BorrowKind::Raw => \"raw \",\n+        //     hir::BorrowKind::Ref => \"\",\n+        // };\n+\n+        // ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+        //     span,\n+        //     raw,\n+        //     kind: ccx.const_kind(),\n+        //     teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+        // })\n+        match self.0 {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n         }\n-        err\n     }\n }\n "}, {"sha": "24604869dd13ad76544e54de329f256e6799a6ca", "filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl?ref=d1f14ee1b01dd39cd79cd9cdd71e91ba521901fe", "patch": "@@ -34,4 +34,52 @@ const_evaL_max_num_nodes_exceeded = maximum number of nodes exceeded in constant\n \n const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n \n-const_eval_unstable_const_fn = `{$def_id}` is not yet stable as a const fn\n\\ No newline at end of file\n+const_eval_unstable_const_fn = `{$def_id}` is not yet stable as a const fn\n+\n+const_eval_unallowed_mutable_refs =\n+    mutable references are not allowed in the final value of {$kind}s\n+    .teach_note = \n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory \n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_unallowed_mutable_refs_raw =\n+    raw mutable references are not allowed in the final value of {$kind}s\n+    .teach_note = \n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory \n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_non_const_fmt_macro_call = \n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call = \n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_unallowed_op_in_const_context = \n+    {$msg}\n+\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note = \n+        The value of statics and constants must be known at compile time, and they live for the entire \n+        lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and \n+        therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n+\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note = \n+        A constant containing interior mutable data behind a reference can allow you to modify that data. \n+        This would make multiple uses of a constant to be able to see different values and allow circumventing \n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+\n+const_eval_interior_mutability_borrow = \n+    cannot borrow here, since the borrowed element may contain interior mutability\n\\ No newline at end of file"}]}