{"sha": "d88750371dcd333482037dd87cfaaddd1b301685", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ODc1MDM3MWRjZDMzMzQ4MjAzN2RkODdjZmFhZGRkMWIzMDE2ODU=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-03-02T06:37:37Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-03-02T06:37:37Z"}, "message": "Refactor suggested by krishna-veerareddy", "tree": {"sha": "3dc5973231157d54a547cc0cd0df0a4a158aef12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc5973231157d54a547cc0cd0df0a4a158aef12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d88750371dcd333482037dd87cfaaddd1b301685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d88750371dcd333482037dd87cfaaddd1b301685", "html_url": "https://github.com/rust-lang/rust/commit/d88750371dcd333482037dd87cfaaddd1b301685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d88750371dcd333482037dd87cfaaddd1b301685/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6d29940979aeb6bed98dcce67c4faa4e9df312", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6d29940979aeb6bed98dcce67c4faa4e9df312", "html_url": "https://github.com/rust-lang/rust/commit/0a6d29940979aeb6bed98dcce67c4faa4e9df312"}], "stats": {"total": 149, "additions": 65, "deletions": 84}, "files": [{"sha": "f2e6bd7da176cea80abe951c3f39748445de7486", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 65, "deletions": 84, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/d88750371dcd333482037dd87cfaaddd1b301685/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88750371dcd333482037dd87cfaaddd1b301685/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=d88750371dcd333482037dd87cfaaddd1b301685", "patch": "@@ -420,103 +420,84 @@ fn is_zero(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n-    if let Some((cond, body, Some(else_body))) = higher::if_block(&expr) {\n+/// If the expressions are not opposites, return None\n+/// Otherwise, return true if expr2 = -expr1, false if expr1 = -expr2 and return the positive\n+/// expression\n+fn are_opposites<'a>(\n+    cx: &LateContext<'_, '_>,\n+    expr1: &'a Expr<'a>,\n+    expr2: &'a Expr<'a>,\n+) -> Option<(bool, &'a Expr<'a>)> {\n+    if let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(expr1_inner),\n+            ..\n+        },\n+        _,\n+    ) = &expr1.kind\n+    {\n         if let ExprKind::Block(\n             Block {\n                 stmts: [],\n-                expr:\n-                    Some(Expr {\n-                        kind: ExprKind::Unary(UnOp::UnNeg, else_expr),\n-                        ..\n-                    }),\n+                expr: Some(expr2_inner),\n                 ..\n             },\n             _,\n-        ) = else_body.kind\n+        ) = &expr2.kind\n         {\n-            if let ExprKind::Block(\n-                Block {\n-                    stmts: [],\n-                    expr: Some(body),\n-                    ..\n-                },\n-                _,\n-            ) = &body.kind\n-            {\n-                if are_exprs_equal(cx, else_expr, body) {\n-                    if is_testing_positive(cx, cond, body) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            SUBOPTIMAL_FLOPS,\n-                            expr.span,\n-                            \"This looks like you've implemented your own absolute value function\",\n-                            \"try\",\n-                            format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if is_testing_negative(cx, cond, body) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            SUBOPTIMAL_FLOPS,\n-                            expr.span,\n-                            \"This looks like you've implemented your own negative absolute value function\",\n-                            \"try\",\n-                            format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+            if let ExprKind::Unary(UnOp::UnNeg, expr1_neg) = &expr1_inner.kind {\n+                if are_exprs_equal(cx, expr1_neg, expr2_inner) {\n+                    return Some((false, expr2_inner));\n                 }\n             }\n-        }\n-        if let ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr:\n-                    Some(Expr {\n-                        kind: ExprKind::Unary(UnOp::UnNeg, else_expr),\n-                        ..\n-                    }),\n-                ..\n-            },\n-            _,\n-        ) = &body.kind\n-        {\n-            if let ExprKind::Block(\n-                Block {\n-                    stmts: [],\n-                    expr: Some(body),\n-                    ..\n-                },\n-                _,\n-            ) = &else_body.kind\n-            {\n-                if are_exprs_equal(cx, else_expr, body) {\n-                    if is_testing_negative(cx, cond, body) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            SUBOPTIMAL_FLOPS,\n-                            expr.span,\n-                            \"This looks like you've implemented your own absolute value function\",\n-                            \"try\",\n-                            format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if is_testing_positive(cx, cond, body) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            SUBOPTIMAL_FLOPS,\n-                            expr.span,\n-                            \"This looks like you've implemented your own negative absolute value function\",\n-                            \"try\",\n-                            format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+            if let ExprKind::Unary(UnOp::UnNeg, expr2_neg) = &expr2_inner.kind {\n+                if are_exprs_equal(cx, expr1_inner, expr2_neg) {\n+                    return Some((true, expr1_inner));\n                 }\n             }\n         }\n     }\n+    None\n+}\n+\n+fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if let Some((cond, body, Some(else_body))) = higher::if_block(&expr) {\n+        if let Some((expr1_pos, body)) = are_opposites(cx, body, else_body) {\n+            let pos_abs_sugg = (\n+                \"This looks like you've implemented your own absolute value function\",\n+                format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let neg_abs_sugg = (\n+                \"This looks like you've implemented your own negative absolute value function\",\n+                format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let sugg = if is_testing_positive(cx, cond, body) {\n+                if expr1_pos {\n+                    pos_abs_sugg\n+                } else {\n+                    neg_abs_sugg\n+                }\n+            } else if is_testing_negative(cx, cond, body) {\n+                if expr1_pos {\n+                    neg_abs_sugg\n+                } else {\n+                    pos_abs_sugg\n+                }\n+            } else {\n+                return;\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                sugg.0,\n+                \"try\",\n+                sugg.1,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {"}]}