{"sha": "826aeea007a99192c992688fb52ebc6530f715c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNmFlZWEwMDdhOTkxOTJjOTkyNjg4ZmI1MmViYzY1MzBmNzE1Yzc=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-12T18:44:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-13T02:52:29Z"}, "message": "libcore: remove fails from slice.rs and remove duplicated length checking\n\ncore::slice::raw::{shift_ptr,pop_ptr} now returns Option<*T> rather than\n*T. They no longer fail on empty slices.\n\n[breaking-change]", "tree": {"sha": "e54811a6841146d8d3e7dee4cd6a2672c71f6555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e54811a6841146d8d3e7dee4cd6a2672c71f6555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/826aeea007a99192c992688fb52ebc6530f715c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/826aeea007a99192c992688fb52ebc6530f715c7", "html_url": "https://github.com/rust-lang/rust/commit/826aeea007a99192c992688fb52ebc6530f715c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/826aeea007a99192c992688fb52ebc6530f715c7/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a707140cb68cbe9aaa99b820fcd4660dc1ea466", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a707140cb68cbe9aaa99b820fcd4660dc1ea466", "html_url": "https://github.com/rust-lang/rust/commit/0a707140cb68cbe9aaa99b820fcd4660dc1ea466"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "d08e5492c82ad9e3f5fafac00f9bf171835bd112", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/826aeea007a99192c992688fb52ebc6530f715c7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826aeea007a99192c992688fb52ebc6530f715c7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=826aeea007a99192c992688fb52ebc6530f715c7", "patch": "@@ -505,7 +505,7 @@ pub trait ImmutableVector<'a, T> {\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n     /**\n-     * Returns a mutable reference to the first element in this slice\n+     * Returns an immutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n@@ -523,7 +523,7 @@ pub trait ImmutableVector<'a, T> {\n     fn shift_ref(&mut self) -> Option<&'a T>;\n \n     /**\n-     * Returns a mutable reference to the last element in this slice\n+     * Returns an immutable reference to the last element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n@@ -693,18 +693,22 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     fn shift_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::shift_ptr(s))\n+            match raw::shift_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n         }\n     }\n \n     fn pop_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::pop_ptr(s))\n+            match raw::pop_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n         }\n     }\n }\n@@ -1059,22 +1063,26 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::shift_ptr(s) as *mut _))\n+            match raw::shift_ptr(s) {\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n+            }\n         }\n     }\n \n     fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::pop_ptr(s) as *mut _))\n+            match raw::pop_ptr(s) {\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n+            }\n         }\n     }\n \n@@ -1165,6 +1173,7 @@ pub mod raw {\n     use iter::Iterator;\n     use ptr::RawPtr;\n     use raw::Slice;\n+    use option::{None, Option, Some};\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n@@ -1198,27 +1207,29 @@ pub mod raw {\n \n     /**\n      * Returns a pointer to first element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n+     * slice so it no longer contains that element. Returns None\n+     * if the slice is empty. O(1).\n      */\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n+     #[inline]\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+        if slice.len == 0 { return None; }\n         let head: *T = slice.data;\n         slice.data = slice.data.offset(1);\n         slice.len -= 1;\n-        head\n+        Some(head)\n     }\n \n     /**\n      * Returns a pointer to last element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n+     * slice so it no longer contains that element. Returns None\n+     * if the slice is empty. O(1).\n      */\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n+     #[inline]\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+        if slice.len == 0 { return None; }\n         let tail: *T = slice.data.offset((slice.len - 1) as int);\n         slice.len -= 1;\n-        tail\n+        Some(tail)\n     }\n }\n "}]}