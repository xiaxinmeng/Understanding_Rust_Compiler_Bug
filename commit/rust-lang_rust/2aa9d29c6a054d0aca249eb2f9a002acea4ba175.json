{"sha": "2aa9d29c6a054d0aca249eb2f9a002acea4ba175", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTlkMjljNmEwNTRkMGFjYTI0OWViMmY5YTAwMmFjZWE0YmExNzU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-21T19:07:28Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-21T20:14:10Z"}, "message": "Remove unused code", "tree": {"sha": "b134f267513787172a7ebb28f6ff4d663209c93e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b134f267513787172a7ebb28f6ff4d663209c93e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa9d29c6a054d0aca249eb2f9a002acea4ba175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa9d29c6a054d0aca249eb2f9a002acea4ba175", "html_url": "https://github.com/rust-lang/rust/commit/2aa9d29c6a054d0aca249eb2f9a002acea4ba175", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa9d29c6a054d0aca249eb2f9a002acea4ba175/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d88f607ed831cf692387703c34441019b8db96", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d88f607ed831cf692387703c34441019b8db96", "html_url": "https://github.com/rust-lang/rust/commit/67d88f607ed831cf692387703c34441019b8db96"}], "stats": {"total": 294, "additions": 3, "deletions": 291}, "files": [{"sha": "70f915bf8c4db1fd02d38d09b1f50a45bd28ec1d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 291, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/2aa9d29c6a054d0aca249eb2f9a002acea4ba175/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa9d29c6a054d0aca249eb2f9a002acea4ba175/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2aa9d29c6a054d0aca249eb2f9a002acea4ba175", "patch": "@@ -1,12 +1,11 @@\n-use crate::ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n+use crate::ast::{self, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n use crate::attr;\n-use crate::source_map::{dummy_spanned, respan, Spanned};\n+use crate::source_map::{respan, Spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Symbol};\n use crate::ThinVec;\n \n-use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n // Left so that Cargo tests don't break, this can be removed once those no longer use it\n@@ -51,42 +50,6 @@ impl<'a> ExtCtxt<'a> {\n         ast::Path { span, segments }\n     }\n \n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident`.\n-    pub fn qpath(&self,\n-             self_type: P<ast::Ty>,\n-             trait_path: ast::Path,\n-             ident: ast::Ident)\n-             -> (ast::QSelf, ast::Path) {\n-        self.qpath_all(self_type, trait_path, ident, vec![], vec![])\n-    }\n-\n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A = Bar>`.\n-    pub fn qpath_all(&self,\n-                 self_type: P<ast::Ty>,\n-                 trait_path: ast::Path,\n-                 ident: ast::Ident,\n-                 args: Vec<ast::GenericArg>,\n-                 constraints: Vec<ast::AssocTyConstraint>)\n-                 -> (ast::QSelf, ast::Path) {\n-        let mut path = trait_path;\n-        let args = if !args.is_empty() || !constraints.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints, span: ident.span }.into()\n-        } else {\n-            None\n-        };\n-        path.segments.push(ast::PathSegment { ident, id: ast::DUMMY_NODE_ID, args });\n-\n-        (ast::QSelf {\n-            ty: self_type,\n-            path_span: path.span,\n-            position: path.segments.len() - 1\n-        }, path)\n-    }\n-\n     pub fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy {\n             ty,\n@@ -219,14 +182,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            span: expr.span,\n-            node: ast::StmtKind::Semi(expr),\n-        }\n-    }\n-\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n@@ -250,34 +205,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_let_typed(&self,\n-                      sp: Span,\n-                      mutbl: bool,\n-                      ident: ast::Ident,\n-                      typ: P<ast::Ty>,\n-                      ex: P<ast::Expr>)\n-                      -> ast::Stmt {\n-        let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n-        } else {\n-            self.pat_ident(sp, ident)\n-        };\n-        let local = P(ast::Local {\n-            pat,\n-            ty: Some(typ),\n-            init: Some(ex),\n-            id: ast::DUMMY_NODE_ID,\n-            span: sp,\n-            attrs: ThinVec::new(),\n-        });\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n-            span: sp,\n-        }\n-    }\n-\n     // Generates `let _: Type;`, which is usually used for type assertions.\n     pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n@@ -332,11 +259,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    /// Constructs a `QPath` expression.\n-    pub fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Path(Some(qself), path))\n-    }\n-\n     pub fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n@@ -350,27 +272,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr_unary(sp, UnOp::Deref, e)\n-    }\n-    pub fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Unary(op, e))\n+        self.expr(sp, ast::ExprKind::Unary(UnOp::Deref, e))\n     }\n \n-    pub fn expr_field_access(\n-        &self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident,\n-    ) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n-    }\n-    pub fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let ident = Ident::new(sym::integer(idx), sp);\n-        self.expr(sp, ast::ExprKind::Field(expr, ident))\n-    }\n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n     }\n-    pub fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Mutable, e))\n-    }\n \n     pub fn expr_call(\n         &self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>,\n@@ -426,39 +333,17 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n                                               ast::LitIntType::Unsigned(ast::UintTy::Usize)))\n     }\n-    pub fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n-        if i < 0 {\n-            let i = (-i) as u128;\n-            let lit_ty = ast::LitIntType::Signed(ast::IntTy::Isize);\n-            let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n-            self.expr_unary(sp, ast::UnOp::Neg, lit)\n-        } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n-                                                ast::LitIntType::Signed(ast::IntTy::Isize)))\n-        }\n-    }\n     pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128,\n                                             ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n-    pub fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n-                                            ast::LitIntType::Unsigned(ast::UintTy::U16)))\n-    }\n-    pub fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n-    }\n     pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n     pub fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n-    pub fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr_call_global(sp, self.std_path(&[sym::vec, sym::Vec, sym::new]),\n-                              Vec::new())\n-    }\n     pub fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n@@ -475,16 +360,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n-    pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n-        let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n-        let none = self.path_global(sp, none);\n-        self.expr_path(none)\n-    }\n-\n-    pub fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Break(None, None))\n-    }\n-\n     pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n@@ -513,11 +388,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, ok, vec![expr])\n     }\n \n-    pub fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n-        self.expr_call_global(sp, err, vec![expr])\n-    }\n-\n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let ok_path = self.path_global(sp, ok);\n@@ -634,10 +504,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    pub fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Loop(block, None))\n-    }\n-\n     pub fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n@@ -681,16 +547,6 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts(&self,\n-                    span: Span,\n-                    ids: Vec<ast::Ident>,\n-                    stmts: Vec<ast::Stmt>)\n-                    -> P<ast::Expr> {\n-        self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n-    }\n-    pub fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.expr_block(self.block(span, stmts)))\n-    }\n     pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n@@ -732,43 +588,6 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn item_fn_poly(&self,\n-                    span: Span,\n-                    name: Ident,\n-                    inputs: Vec<ast::Param> ,\n-                    output: P<ast::Ty>,\n-                    generics: Generics,\n-                    body: P<ast::Block>) -> P<ast::Item> {\n-        self.item(span,\n-                  name,\n-                  Vec::new(),\n-                  ast::ItemKind::Fn(self.fn_decl(inputs, ast::FunctionRetTy::Ty(output)),\n-                              ast::FnHeader {\n-                                  unsafety: ast::Unsafety::Normal,\n-                                  asyncness: dummy_spanned(ast::IsAsync::NotAsync),\n-                                  constness: dummy_spanned(ast::Constness::NotConst),\n-                                  abi: Abi::Rust,\n-                              },\n-                              generics,\n-                              body))\n-    }\n-\n-    pub fn item_fn(&self,\n-               span: Span,\n-               name: Ident,\n-               inputs: Vec<ast::Param> ,\n-               output: P<ast::Ty>,\n-               body: P<ast::Block>\n-              ) -> P<ast::Item> {\n-        self.item_fn_poly(\n-            span,\n-            name,\n-            inputs,\n-            output,\n-            Generics::default(),\n-            body)\n-    }\n-\n     pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n@@ -799,52 +618,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn item_enum_poly(&self, span: Span, name: Ident,\n-                      enum_definition: ast::EnumDef,\n-                      generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n-    }\n-\n-    pub fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> P<ast::Item> {\n-        self.item_enum_poly(span, name, enum_definition,\n-                            Generics::default())\n-    }\n-\n-    pub fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::VariantData) -> P<ast::Item> {\n-        self.item_struct_poly(\n-            span,\n-            name,\n-            struct_def,\n-            Generics::default()\n-        )\n-    }\n-\n-    pub fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n-    }\n-\n-    pub fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute>,\n-                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n-        self.item(\n-            span,\n-            name,\n-            attrs,\n-            ast::ItemKind::Mod(ast::Mod {\n-                inner: inner_span,\n-                items,\n-                inline: true\n-            })\n-        )\n-    }\n-\n-    pub fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::ExternCrate(None))\n-    }\n-\n     pub fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n@@ -864,15 +637,6 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n-    pub fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::TyAlias(ty, generics))\n-    }\n-\n-    pub fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n-        self.item_ty_poly(span, name, ty, Generics::default())\n-    }\n-\n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n         attr::mk_attr_outer(mi)\n     }\n@@ -894,56 +658,4 @@ impl<'a> ExtCtxt<'a> {\n                        -> ast::MetaItem {\n         attr::mk_name_value_item(Ident::new(name, span), lit_kind, span)\n     }\n-\n-    pub fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n-        P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: Ident::invalid(),\n-            attrs: vec![],\n-            node: ast::ItemKind::Use(vp),\n-            vis,\n-            span: sp,\n-            tokens: None,\n-        })\n-    }\n-\n-    pub fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n-        self.item_use_simple_(sp, vis, None, path)\n-    }\n-\n-    pub fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        rename: Option<ast::Ident>, path: ast::Path) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: path,\n-            kind: ast::UseTreeKind::Simple(rename, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        }))\n-    }\n-\n-    pub fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n-        let imports = imports.iter().map(|id| {\n-            (ast::UseTree {\n-                span: sp,\n-                prefix: self.path(sp, vec![*id]),\n-                kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-            }, ast::DUMMY_NODE_ID)\n-        }).collect();\n-\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Nested(imports),\n-        }))\n-    }\n-\n-    pub fn item_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Glob,\n-        }))\n-    }\n }"}]}