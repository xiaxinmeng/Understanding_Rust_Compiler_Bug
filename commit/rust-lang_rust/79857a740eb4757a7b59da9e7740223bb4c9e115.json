{"sha": "79857a740eb4757a7b59da9e7740223bb4c9e115", "node_id": "C_kwDOAAsO6NoAKDc5ODU3YTc0MGViNDc1N2E3YjU5ZGE5ZTc3NDAyMjNiYjRjOWUxMTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-16T20:30:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-16T20:30:48Z"}, "message": "Rollup merge of #99213 - davidtwco:translation-migrate-passes, r=compiler-errors\n\nmigrate some of `rustc_passes::check_attr`'s diagnostics and derive improvements\n\n- Implements `IntoDiagnosticArg` for `char` using its `Debug` implementation and introduces a macro for those types which just delegate the implementation to `ToString`.\n- Apply the `#[rustc_lint_diagnostics]` attribute to `LintDiagnosticBuilder::build` so that diagnostic migration lints will trigger for it - some diagnostics in `rustc_privacy` need updated after this since the lints apply to that crate.\n- Add support for `MultiSpan` with any of the attributes that work on a `Span` in the diagnostic derive (`SessionDiagnostic` + `LintDiagnostic`). Requires that diagnostic logic generated for these attributes are emitted in the by-move block rather than the by-ref block that they would normally have been generated in.\n- Both diagnostic and subdiagnostic derives were missing the ability to add warnings to diagnostics - this is made more difficult by the `warn` attribute already existing, so this name being unavailable for the derives to use. `#[warn_]` is used instead, which requires special-casing so that `{span_,}warn` is called instead of `{span_,}warn_`.\n- Migrate half of the `rustc_passes::check_attr` diagnostics to using diagnostic derives and being translatable. I got tired after a while. I modified some diagnostic output for consistency while doing this, nothing too crazy.\n\nr? `@compiler-errors`", "tree": {"sha": "aef4fc0a9a18a57aa16f423aab4b313eef17d6bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef4fc0a9a18a57aa16f423aab4b313eef17d6bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79857a740eb4757a7b59da9e7740223bb4c9e115", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi0x/5CRBK7hj4Ov3rIwAAIXUIABojPmUK9XoDCBjMv/oyi96a\n4YEOJaoY2iKULPC08wo4CHO+kt2oakRNG/MdRbHN8cwOzcMtlLmK39l53hNtk5i+\nEhrUGIRW+7a44CFsy3hpcnUQyVxjnaEY0wZggcvH7vLqSs1FeeBUshKYF023nNTM\n7FyAB/yslHs87oRwK9TR1zAlcyWgPz2txs3J//j3zJxpxAwE9zJ92tRscOz/eHCj\n9Pu9P2TaDgIBErc7m0170L2fIvaMf/KnHfphzVymfWBLOOsz06lfUlyx3OqxdaT+\nDZQj/091pAOp9H58jPpk33JSbgpL0/Z9feVozdAwIYEfuJIKNbWfq+kIorKqImU=\n=BWeY\n-----END PGP SIGNATURE-----\n", "payload": "tree aef4fc0a9a18a57aa16f423aab4b313eef17d6bf\nparent 6f8fb911ad504b77549cf3256a09465621beab9d\nparent 78b19a90b7d728f3bde6a70a2509ae177561ce5f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1658003448 +0200\ncommitter GitHub <noreply@github.com> 1658003448 +0200\n\nRollup merge of #99213 - davidtwco:translation-migrate-passes, r=compiler-errors\n\nmigrate some of `rustc_passes::check_attr`'s diagnostics and derive improvements\n\n- Implements `IntoDiagnosticArg` for `char` using its `Debug` implementation and introduces a macro for those types which just delegate the implementation to `ToString`.\n- Apply the `#[rustc_lint_diagnostics]` attribute to `LintDiagnosticBuilder::build` so that diagnostic migration lints will trigger for it - some diagnostics in `rustc_privacy` need updated after this since the lints apply to that crate.\n- Add support for `MultiSpan` with any of the attributes that work on a `Span` in the diagnostic derive (`SessionDiagnostic` + `LintDiagnostic`). Requires that diagnostic logic generated for these attributes are emitted in the by-move block rather than the by-ref block that they would normally have been generated in.\n- Both diagnostic and subdiagnostic derives were missing the ability to add warnings to diagnostics - this is made more difficult by the `warn` attribute already existing, so this name being unavailable for the derives to use. `#[warn_]` is used instead, which requires special-casing so that `{span_,}warn` is called instead of `{span_,}warn_`.\n- Migrate half of the `rustc_passes::check_attr` diagnostics to using diagnostic derives and being translatable. I got tired after a while. I modified some diagnostic output for consistency while doing this, nothing too crazy.\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79857a740eb4757a7b59da9e7740223bb4c9e115", "html_url": "https://github.com/rust-lang/rust/commit/79857a740eb4757a7b59da9e7740223bb4c9e115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79857a740eb4757a7b59da9e7740223bb4c9e115/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8fb911ad504b77549cf3256a09465621beab9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8fb911ad504b77549cf3256a09465621beab9d", "html_url": "https://github.com/rust-lang/rust/commit/6f8fb911ad504b77549cf3256a09465621beab9d"}, {"sha": "78b19a90b7d728f3bde6a70a2509ae177561ce5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b19a90b7d728f3bde6a70a2509ae177561ce5f", "html_url": "https://github.com/rust-lang/rust/commit/78b19a90b7d728f3bde6a70a2509ae177561ce5f"}], "stats": {"total": 1808, "additions": 1090, "deletions": 718}, "files": [{"sha": "9a8d9d40b6e45a3c2b2ebc82cd95b15b6aa7a0de", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -4239,6 +4239,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\","}, {"sha": "e4c9a4dad7b4815cf164781bcab0d7cc870d30b0", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -0,0 +1,151 @@\n+-passes-previously-accepted =\n+    this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+\n+-passes-see-issue =\n+    see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n+\n+passes-outer-crate-level-attr =\n+    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+\n+passes-inner-crate-level-attr =\n+    crate-level attribute should be in the root module\n+\n+passes-ignored-attr-with-macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"80564\")}\n+\n+passes-ignored-attr = `#[{$sym}]` is ignored on struct fields and match arms\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"80564\")}\n+\n+passes-inline-ignored-function-prototype = `#[inline]` is ignored on function prototypes\n+\n+passes-inline-ignored-constants = `#[inline]` is ignored on constants\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"65833\")}\n+\n+passes-inline-not-fn-or-closure = attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes-no-coverage-ignored-function-prototype = `#[no_coverage]` is ignored on function prototypes\n+\n+passes-no-coverage-propagate =\n+    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+\n+passes-no-coverage-fn-defn = `#[no_coverage]` may only be applied to function definitions\n+\n+passes-no-coverage-not-coverable = `#[no_coverage]` must be applied to coverable code\n+    .label = not coverable code\n+\n+passes-should-be-applied-to-fn = attribute should be applied to a function definition\n+    .label = not a function definition\n+\n+passes-naked-tracked-caller = cannot use `#[track_caller]` with `#[naked]`\n+\n+passes-should-be-applied-to-struct-enum = attribute should be applied to a struct or enum\n+    .label = not a struct or enum\n+\n+passes-should-be-applied-to-trait = attribute should be applied to a trait\n+    .label = not a trait\n+\n+passes-target-feature-on-statement = {passes-should-be-applied-to-fn}\n+    .warn = {-passes-previously-accepted}\n+    .label = {passes-should-be-applied-to-fn.label}\n+\n+passes-should-be-applied-to-static = attribute should be applied to a static\n+    .label = not a static\n+\n+passes-doc-expect-str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+\n+passes-doc-alias-empty = {$attr_str} attribute cannot have empty value\n+\n+passes-doc-alias-bad-char = {$char_} character isn't allowed in {$attr_str}\n+\n+passes-doc-alias-start-end = {$attr_str} cannot start or end with ' '\n+\n+passes-doc-alias-bad-location = {$attr_str} isn't allowed on {$location}\n+\n+passes-doc-alias-not-an-alias = {$attr_str} is the same as the item's name\n+\n+passes-doc-alias-duplicated = doc alias is duplicated\n+    .label = first defined here\n+\n+passes-doc-alias-not-string-literal = `#[doc(alias(\"a\"))]` expects string literals\n+\n+passes-doc-alias-malformed =\n+    doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+\n+passes-doc-keyword-empty-mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+\n+passes-doc-keyword-not-mod = `#[doc(keyword = \"...\")]` should be used on modules\n+\n+passes-doc-keyword-invalid-ident = `{$doc_keyword}` is not a valid identifier\n+\n+passes-doc-tuple-variadic-not-first =\n+    `#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\n+\n+passes-doc-keyword-only-impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+\n+passes-doc-inline-conflict-first = this attribute...\n+passes-doc-inline-conflict-second = ...conflicts with this attribute\n+passes-doc-inline-conflict = conflicting doc inlining attributes\n+    .help = remove one of the conflicting attributes\n+\n+passes-doc-inline-only-use = this attribute can only be applied to a `use` item\n+    .label = only applicable on `use` items\n+    .not-a-use-item-label = not a `use` item\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n+\n+passes-doc-attr-not-crate-level =\n+    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+\n+passes-attr-crate-level = this attribute can only be applied at the crate level\n+    .suggestion = to apply to the crate, use an inner attribute\n+    .help = to apply to the crate, use an inner attribute\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n+\n+passes-doc-test-unknown = unknown `doc(test)` attribute `{$path}`\n+\n+passes-doc-test-takes-list = `#[doc(test(...)]` takes a list of attributes\n+\n+passes-doc-primitive = `doc(primitive)` should never have been stable\n+\n+passes-doc-test-unknown-any = unknown `doc` attribute `{$path}`\n+\n+passes-doc-test-unknown-spotlight = unknown `doc` attribute `{$path}`\n+    .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n+    .suggestion = use `notable_trait` instead\n+    .no-op-note = `doc(spotlight)` is now a no-op\n+\n+passes-doc-test-unknown-include = unknown `doc` attribute `{$path}`\n+    .suggestion = use `doc = include_str!` instead\n+\n+passes-doc-invalid = invalid `doc` attribute\n+\n+passes-pass-by-value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+    .label = is not a struct, enum or type alias\n+\n+passes-allow-incoherent-impl =\n+    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n+    .label = the only currently supported targets are inherent methods\n+\n+passes-has-incoherent-inherent-impl =\n+    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n+    .label = only adts, extern types and traits are supported\n+\n+passes-must-use-async =\n+    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n+    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n+\n+passes-must-use-no-effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+\n+passes-must-not-suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+    .label = is not a struct, enum, or trait\n+\n+passes-cold = {passes-should-be-applied-to-fn}\n+    .warn = {-passes-previously-accepted}\n+    .label = {passes-should-be-applied-to-fn.label}\n+\n+passes-link = attribute should be applied to an `extern` block with non-Rust ABI\n+    .warn = {-passes-previously-accepted}\n+    .label = not an `extern` block"}, {"sha": "f8a750da93f8d3442af9adb9b59b813d1cb4c9bb", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -10,3 +10,12 @@ privacy-unnamed-item-is-private = {$kind} is private\n privacy-in-public-interface = {$vis_descr} {$kind} `{$descr}` in public interface\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility-label = `{$descr}` declared as {$vis_descr}\n+\n+privacy-from-private-dep-in-public-interface =\n+    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n+\n+private-in-public-lint =\n+    {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n+        [trait] E0445\n+        *[other] E0446\n+    })"}, {"sha": "a3040f83fdfc7d5ee57b8fe064f35061b462f579", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -37,6 +37,7 @@ fluent_messages! {\n     expand => \"../locales/en-US/expand.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n+    passes => \"../locales/en-US/passes.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n }"}, {"sha": "267beb514847c8e71219668a8a87e181ea002689", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 34, "deletions": 77, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -40,6 +40,35 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n+macro_rules! into_diagnostic_arg_using_display {\n+    ($( $ty:ty ),+ $(,)?) => {\n+        $(\n+            impl IntoDiagnosticArg for $ty {\n+                fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+                    self.to_string().into_diagnostic_arg()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+into_diagnostic_arg_using_display!(\n+    i8,\n+    u8,\n+    i16,\n+    u16,\n+    i32,\n+    u32,\n+    i64,\n+    u64,\n+    i128,\n+    u128,\n+    std::num::NonZeroU32,\n+    hir::Target,\n+    Edition,\n+    Ident,\n+);\n+\n impl IntoDiagnosticArg for bool {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         if self {\n@@ -50,81 +79,9 @@ impl IntoDiagnosticArg for bool {\n     }\n }\n \n-impl IntoDiagnosticArg for i8 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u8 {\n+impl IntoDiagnosticArg for char {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i16 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u16 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i64 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u64 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i128 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u128 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for String {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for std::num::NonZeroU32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for Edition {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self)))\n     }\n }\n \n@@ -134,15 +91,15 @@ impl IntoDiagnosticArg for Symbol {\n     }\n }\n \n-impl IntoDiagnosticArg for Ident {\n+impl<'a> IntoDiagnosticArg for &'a str {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         self.to_string().into_diagnostic_arg()\n     }\n }\n \n-impl<'a> IntoDiagnosticArg for &'a str {\n+impl IntoDiagnosticArg for String {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        self.to_string().into_diagnostic_arg()\n+        DiagnosticArgValue::Str(Cow::Owned(self))\n     }\n }\n "}, {"sha": "9e68ee282e65235634506aab28e2d97c41e698da", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -595,6 +595,7 @@ macro_rules! error_code {\n pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a, G>);\n \n impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n+    #[rustc_lint_diagnostics]\n     /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n     pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n         self.0.set_primary_message(msg);"}, {"sha": "6b5b8b5932018abfb6e5d54b55dc38853885b0a5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -59,7 +59,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                         return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some(DiagnosticDeriveKind::Lint), _) => {\n-                        span_err(span, \"only `#[error(..)]` and `#[warn(..)]` are supported\")\n+                        span_err(span, \"only `#[error(..)]` and `#[warning(..)]` are supported\")\n                             .help(\"use the `#[error(...)]` attribute to create a error\")\n                             .emit();\n                         return DiagnosticDeriveError::ErrorHandled.to_compile_error();"}, {"sha": "5c5275b7cfb928256231d848423b019a2cdb2829", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 115, "deletions": 75, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -8,12 +8,13 @@ use crate::diagnostics::utils::{\n     report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n     Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n-use proc_macro2::{Ident, TokenStream};\n+use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+    parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n+    Path, Type,\n };\n use synstructure::{BindingInfo, Structure};\n \n@@ -80,8 +81,8 @@ impl DiagnosticDeriveBuilder {\n     }\n \n     pub fn body<'s>(&mut self, structure: &mut Structure<'s>) -> (TokenStream, TokenStream) {\n-        // Keep track of which fields are subdiagnostics or have no attributes.\n-        let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n+        // Keep track of which fields need to be handled with a by-move binding.\n+        let mut needs_moved = std::collections::HashSet::new();\n \n         // Generates calls to `span_label` and similar functions based on the attributes\n         // on fields. Code for suggestions uses formatting machinery and the value of\n@@ -92,16 +93,11 @@ impl DiagnosticDeriveBuilder {\n         let attrs = structure\n             .clone()\n             .filter(|field_binding| {\n-                let attrs = &field_binding.ast().attrs;\n-\n-                (!attrs.is_empty()\n-                    && attrs.iter().all(|attr| {\n-                        \"subdiagnostic\" != attr.path.segments.last().unwrap().ident.to_string()\n-                    }))\n-                    || {\n-                        subdiagnostics_or_empty.insert(field_binding.binding.clone());\n-                        false\n-                    }\n+                let ast = &field_binding.ast();\n+                !self.needs_move(ast) || {\n+                    needs_moved.insert(field_binding.binding.clone());\n+                    false\n+                }\n             })\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n@@ -111,12 +107,41 @@ impl DiagnosticDeriveBuilder {\n         // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n         // argument to the diagnostic so that it can be referred to by Fluent messages.\n         let args = structure\n-            .filter(|field_binding| subdiagnostics_or_empty.contains(&field_binding.binding))\n+            .filter(|field_binding| needs_moved.contains(&field_binding.binding))\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n         (attrs, args)\n     }\n \n+    /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n+    /// call (like `span_label`).\n+    fn should_generate_set_arg(&self, field: &Field) -> bool {\n+        field.attrs.is_empty()\n+    }\n+\n+    /// Returns `true` if `field` needs to have code generated in the by-move branch of the\n+    /// generated derive rather than the by-ref branch.\n+    fn needs_move(&self, field: &Field) -> bool {\n+        let generates_set_arg = self.should_generate_set_arg(field);\n+        let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n+        // FIXME(davidtwco): better support for one field needing to be in the by-move and\n+        // by-ref branches.\n+        let is_subdiagnostic = field\n+            .attrs\n+            .iter()\n+            .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n+            .any(|attr| attr == \"subdiagnostic\");\n+\n+        // `set_arg` calls take their argument by-move..\n+        generates_set_arg\n+            // If this is a `MultiSpan` field then it needs to be moved to be used by any\n+            // attribute..\n+            || is_multispan\n+            // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n+            // unlikely to be `Copy`..\n+            || is_subdiagnostic\n+    }\n+\n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n@@ -131,16 +156,20 @@ impl DiagnosticDeriveBuilder {\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        let is_help_or_note = matches!(name, \"help\" | \"note\");\n+        let is_help_note_or_warn = matches!(name, \"help\" | \"note\" | \"warn_\");\n \n         let nested = match meta {\n             // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n             // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n             Meta::List(MetaList { ref nested, .. }) => nested,\n             // Subdiagnostics without spans can be applied to the type too, and these are just\n             // paths: `#[help]` and `#[note]`\n-            Meta::Path(_) if is_help_or_note => {\n-                let fn_name = proc_macro2::Ident::new(name, attr.span());\n+            Meta::Path(_) if is_help_note_or_warn => {\n+                let fn_name = if name == \"warn_\" {\n+                    Ident::new(\"warn\", attr.span())\n+                } else {\n+                    Ident::new(name, attr.span())\n+                };\n                 return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n             }\n             _ => throw_invalid_attr!(attr, &meta),\n@@ -152,9 +181,11 @@ impl DiagnosticDeriveBuilder {\n             \"error\" => self.kind.set_once((DiagnosticDeriveKind::Error, span)),\n             \"warning\" => self.kind.set_once((DiagnosticDeriveKind::Warn, span)),\n             \"lint\" => self.kind.set_once((DiagnosticDeriveKind::Lint, span)),\n-            \"help\" | \"note\" => (),\n+            \"help\" | \"note\" | \"warn_\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n+                diag.help(\n+                    \"only `error`, `warning`, `help`, `note` and `warn_` are valid attributes\",\n+                )\n             }),\n         }\n \n@@ -163,22 +194,24 @@ impl DiagnosticDeriveBuilder {\n         let mut nested_iter = nested.into_iter();\n         if let Some(nested_attr) = nested_iter.next() {\n             // Report an error if there are any other list items after the path.\n-            if is_help_or_note && nested_iter.next().is_some() {\n+            if is_help_note_or_warn && nested_iter.next().is_some() {\n                 throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n+                    diag.help(\n+                        \"`help`, `note` and `warn_` struct attributes can only have one argument\",\n+                    )\n                 });\n             }\n \n             match nested_attr {\n-                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n+                NestedMeta::Meta(Meta::Path(path)) if is_help_note_or_warn => {\n                     let fn_name = proc_macro2::Ident::new(name, attr.span());\n                     return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n                 }\n                 NestedMeta::Meta(Meta::Path(path)) => {\n                     self.slug.set_once((path.clone(), span));\n                 }\n                 NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                    if !is_help_or_note\n+                    if !is_help_note_or_warn\n                         && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n                 {\n                     // don't error for valid follow-up attributes\n@@ -227,57 +260,55 @@ impl DiagnosticDeriveBuilder {\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        let inner_ty = FieldInnerTy::from_type(&field.ty);\n-\n-        // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n-        // borrow it to avoid requiring clones - this must therefore be the last use of\n-        // each field (for example, any formatting machinery that might refer to a field\n-        // should be generated already).\n-        if field.attrs.is_empty() {\n+        if self.should_generate_set_arg(&field) {\n             let diag = &self.diag;\n             let ident = field.ident.as_ref().unwrap();\n-            quote! {\n+            return quote! {\n                 #diag.set_arg(\n                     stringify!(#ident),\n                     #field_binding\n                 );\n-            }\n-        } else {\n-            field\n-                .attrs\n-                .iter()\n-                .map(move |attr| {\n-                    let name = attr.path.segments.last().unwrap().ident.to_string();\n-                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n-                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n-                            (quote! { #field_binding.clone() }, false)\n-                        }\n-                        // `subdiagnostics` are not derefed because they are bound by value.\n-                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n-                        _ => (quote! { *#field_binding }, true),\n-                    };\n-\n-                    let generated_code = self\n-                        .generate_inner_field_code(\n-                            attr,\n-                            FieldInfo {\n-                                binding: binding_info,\n-                                ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                                span: &field.span(),\n-                            },\n-                            binding,\n-                        )\n-                        .unwrap_or_else(|v| v.to_compile_error());\n-\n-                    if needs_destructure {\n-                        inner_ty.with(field_binding, generated_code)\n-                    } else {\n-                        generated_code\n-                    }\n-                })\n-                .collect()\n+            };\n         }\n+\n+        let needs_move = self.needs_move(&field);\n+        let inner_ty = FieldInnerTy::from_type(&field.ty);\n+\n+        field\n+            .attrs\n+            .iter()\n+            .map(move |attr| {\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let needs_clone =\n+                    name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n+                let (binding, needs_destructure) = if needs_clone {\n+                    // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+                    (quote! { #field_binding.clone() }, false)\n+                } else if needs_move {\n+                    (quote! { #field_binding }, true)\n+                } else {\n+                    (quote! { *#field_binding }, true)\n+                };\n+\n+                let generated_code = self\n+                    .generate_inner_field_code(\n+                        attr,\n+                        FieldInfo {\n+                            binding: binding_info,\n+                            ty: inner_ty.inner_type().unwrap_or(&field.ty),\n+                            span: &field.span(),\n+                        },\n+                        binding,\n+                    )\n+                    .unwrap_or_else(|v| v.to_compile_error());\n+\n+                if needs_destructure {\n+                    inner_ty.with(field_binding, generated_code)\n+                } else {\n+                    generated_code\n+                }\n+            })\n+            .collect()\n     }\n \n     fn generate_inner_field_code(\n@@ -324,10 +355,12 @@ impl DiagnosticDeriveBuilder {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n             }\n-            \"note\" | \"help\" => {\n-                let path = match name {\n-                    \"note\" => parse_quote! { _subdiag::note },\n-                    \"help\" => parse_quote! { _subdiag::help },\n+            \"note\" | \"help\" | \"warn_\" => {\n+                let warn_ident = Ident::new(\"warn\", Span::call_site());\n+                let (ident, path) = match name {\n+                    \"note\" => (ident, parse_quote! { _subdiag::note }),\n+                    \"help\" => (ident, parse_quote! { _subdiag::help }),\n+                    \"warn_\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n                     _ => unreachable!(),\n                 };\n                 if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n@@ -364,10 +397,10 @@ impl DiagnosticDeriveBuilder {\n             \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n                 return self.generate_inner_field_code_suggestion(attr, info);\n             }\n-            \"label\" | \"help\" | \"note\" => (),\n+            \"label\" | \"help\" | \"note\" | \"warn_\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n                 diag.help(\n-                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n+                    \"only `label`, `help`, `note`, `warn` or `suggestion{,_short,_hidden,_verbose}` are \\\n                      valid field attributes\",\n                 )\n             }),\n@@ -396,7 +429,14 @@ impl DiagnosticDeriveBuilder {\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n             }\n             \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            \"note\" | \"help\" => report_type_error(attr, \"`Span` or `()`\")?,\n+            // `warn_` must be special-cased because the attribute `warn` already has meaning and\n+            // so isn't used, despite the diagnostic API being named `warn`.\n+            \"warn_\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n+                .add_spanned_subdiagnostic(binding, &Ident::new(\"warn\", Span::call_site()), msg)),\n+            \"warn_\" if type_is_unit(&info.ty) => {\n+                Ok(self.add_subdiagnostic(&Ident::new(\"warn\", Span::call_site()), msg))\n+            }\n+            \"note\" | \"help\" | \"warn_\" => report_type_error(attr, \"`Span` or `()`\")?,\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "1170d2b3c59a47749a10de6d4e15aedfdc6be18c", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -260,10 +260,12 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             #generated\n \n             pub mod _subdiag {\n-                pub const note: crate::SubdiagnosticMessage =\n-                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n                 pub const help: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                pub const note: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                pub const warn: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"warn\"));\n                 pub const label: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n                 pub const suggestion: crate::SubdiagnosticMessage ="}, {"sha": "edf4dbed9853eeb8e2dbc8266ba3e92dc3012588", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -37,6 +37,8 @@ enum SubdiagnosticKind {\n     Note,\n     /// `#[help(...)]`\n     Help,\n+    /// `#[warn_(...)]`\n+    Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n     Suggestion(SubdiagnosticSuggestionKind),\n }\n@@ -49,6 +51,7 @@ impl FromStr for SubdiagnosticKind {\n             \"label\" => Ok(SubdiagnosticKind::Label),\n             \"note\" => Ok(SubdiagnosticKind::Note),\n             \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"warn_\" => Ok(SubdiagnosticKind::Warn),\n             \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n             \"suggestion_short\" => {\n                 Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n@@ -70,6 +73,7 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Label => write!(f, \"label\"),\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n             SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n                 write!(f, \"suggestion\")\n             }"}, {"sha": "002abb152f7597a788fa4cbb954febfa6e94d00e", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -85,7 +85,13 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"`Span`\")\n+    if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(&info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    {\n+        report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n+    }\n+\n+    Ok(())\n }\n \n /// Inner type of a field and type of wrapper."}, {"sha": "ab509b26f1c55eeb4a1b6a5469f6cff33a1e5c0b", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -130,8 +130,9 @@ decl_derive!(\n         warning,\n         error,\n         lint,\n-        note,\n         help,\n+        note,\n+        warn_,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -148,8 +149,9 @@ decl_derive!(\n         warning,\n         error,\n         lint,\n-        note,\n         help,\n+        note,\n+        warn_,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -166,6 +168,7 @@ decl_derive!(\n         label,\n         help,\n         note,\n+        warn_,\n         suggestion,\n         suggestion_short,\n         suggestion_hidden,"}, {"sha": "faa9c493d88751b00196dd43ba6afa43a3058a58", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "d96e7d3efe83db095dc1e2180e8b60683d7cf5b9", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 246, "deletions": 444, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -4,9 +4,10 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n+use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -175,16 +176,20 @@ impl CheckAttrVisitor<'_> {\n                 if let Some(BuiltinAttribute { type_: AttributeType::CrateLevel, .. }) =\n                     attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name))\n                 {\n-                    self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                        let msg = match attr.style {\n-                            ast::AttrStyle::Outer => {\n-                                \"crate-level attribute should be an inner attribute: add an exclamation \\\n-                                 mark: `#![foo]`\"\n-                            }\n-                            ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n-                        };\n-                        lint.build(msg).emit();\n-                    });\n+                    match attr.style {\n+                        ast::AttrStyle::Outer => self.tcx.emit_spanned_lint(\n+                            UNUSED_ATTRIBUTES,\n+                            hir_id,\n+                            attr.span,\n+                            errors::OuterCrateLevelAttr,\n+                        ),\n+                        ast::AttrStyle::Inner => self.tcx.emit_spanned_lint(\n+                            UNUSED_ATTRIBUTES,\n+                            hir_id,\n+                            attr.span,\n+                            errors::InnerCrateLevelAttr,\n+                        ),\n+                    }\n                 }\n             }\n \n@@ -209,37 +214,21 @@ impl CheckAttrVisitor<'_> {\n     }\n \n     fn inline_attr_str_error_with_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(&format!(\n-                \"`#[{sym}]` is ignored on struct fields, match arms and macro defs\",\n-            ))\n-            .warn(\n-                \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-            )\n-            .note(\n-                \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n-                 for more information\",\n-            )\n-            .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::IgnoredAttrWithMacro { sym },\n+        );\n     }\n \n     fn inline_attr_str_error_without_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(&format!(\"`#[{sym}]` is ignored on struct fields and match arms\"))\n-                .warn(\n-                    \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-                )\n-                .note(\n-                    \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n-                 for more information\",\n-                )\n-                .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::IgnoredAttr { sym },\n+        );\n     }\n \n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n@@ -249,29 +238,25 @@ impl CheckAttrVisitor<'_> {\n             | Target::Closure\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[inline]` is ignored on function prototypes\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredInlineAttrFnProto,\n+                );\n                 true\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n             // just a lint, because we previously erroneously allowed it and some crates used it\n             // accidentally, to to be compatible with crates depending on them, we can't throw an\n             // error here.\n             Target::AssocConst => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[inline]` is ignored on constants\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .note(\n-                            \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n-                             for more information\",\n-                        )\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredInlineAttrConstants,\n+                );\n                 true\n             }\n             // FIXME(#80564): Same for fields, arms, and macro defs\n@@ -280,14 +265,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0518,\n-                    \"attribute should be applied to function or closure\",\n-                )\n-                .span_label(span, \"not a function or closure\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::InlineNotFnOrClosure {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -309,36 +290,40 @@ impl CheckAttrVisitor<'_> {\n \n             // function prototypes can't be covered\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` is ignored on function prototypes\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoverageFnProto,\n+                );\n                 true\n             }\n \n             Target::Mod | Target::ForeignMod | Target::Impl | Target::Trait => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoveragePropagate,\n+                );\n                 true\n             }\n \n             Target::Expression | Target::Statement | Target::Arm => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` may only be applied to function definitions\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoverageFnDefn,\n+                );\n                 true\n             }\n \n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0788,\n-                    \"`#[no_coverage]` must be applied to coverable code\",\n-                )\n-                .span_label(span, \"not coverable code\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::IgnoredNoCoverageNotCoverable {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -389,14 +374,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a function definition\",\n-                    )\n-                    .span_label(span, \"not a function definition\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -408,14 +389,10 @@ impl CheckAttrVisitor<'_> {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a function definition\",\n-                    )\n-                    .span_label(span, \"not a function definition\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -432,13 +409,7 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         match target {\n             _ if attrs.iter().any(|attr| attr.has_name(sym::naked)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr_span,\n-                    E0736,\n-                    \"cannot use `#[track_caller]` with `#[naked]`\",\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(errors::NakedTrackedCaller { attr_span });\n                 false\n             }\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => true,\n@@ -453,14 +424,9 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr_span,\n-                    E0739,\n-                    \"attribute should be applied to function\"\n-                )\n-                .span_label(span, \"not a function\")\n-                .emit();\n+                self.tcx\n+                    .sess\n+                    .emit_err(errors::TrackedCallerWrongLocation { attr_span, defn_span: span });\n                 false\n             }\n         }\n@@ -485,14 +451,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0701,\n-                    \"attribute can only be applied to a struct or enum\"\n-                )\n-                .span_label(span, \"not a struct or enum\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::NonExhaustiveWrongLocation {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -511,11 +473,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(span, \"not a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToTrait {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -531,11 +492,10 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(span, \"not a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToTrait {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -555,16 +515,12 @@ impl CheckAttrVisitor<'_> {\n             // FIXME: #[target_feature] was previously erroneously allowed on statements and some\n             // crates used this, so only emit a warning.\n             Target::Statement => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::TargetFeatureOnStatement,\n+                );\n                 true\n             }\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -576,11 +532,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(span, \"not a function\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -591,24 +546,17 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::ForeignStatic | Target::Static => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a static\")\n-                    .span_label(span, \"not a static\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToStatic {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n     }\n \n     fn doc_attr_str_error(&self, meta: &NestedMetaItem, attr_name: &str) {\n-        self.tcx\n-            .sess\n-            .struct_span_err(\n-                meta.span(),\n-                &format!(\"doc {0} attribute expects a string: #[doc({0} = \\\"a\\\")]\", attr_name),\n-            )\n-            .emit();\n+        self.tcx.sess.emit_err(errors::DocExpectStr { attr_span: meta.span(), attr_name });\n     }\n \n     fn check_doc_alias_value(\n@@ -621,46 +569,29 @@ impl CheckAttrVisitor<'_> {\n         aliases: &mut FxHashMap<String, Span>,\n     ) -> bool {\n         let tcx = self.tcx;\n-        let err_fn = move |span: Span, msg: &str| {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\n-                    \"`#[doc(alias{})]` {}\",\n-                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n-                    msg,\n-                ),\n-            );\n-            false\n-        };\n+        let span = meta.name_value_literal_span().unwrap_or_else(|| meta.span());\n+        let attr_str =\n+            &format!(\"`#[doc(alias{})]`\", if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" });\n         if doc_alias == kw::Empty {\n-            return err_fn(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                \"attribute cannot have empty value\",\n-            );\n+            tcx.sess.emit_err(errors::DocAliasEmpty { span, attr_str });\n+            return false;\n         }\n \n         let doc_alias_str = doc_alias.as_str();\n         if let Some(c) = doc_alias_str\n             .chars()\n             .find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n         {\n-            self.tcx.sess.span_err(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                &format!(\n-                    \"{:?} character isn't allowed in `#[doc(alias{})]`\",\n-                    c,\n-                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n-                ),\n-            );\n+            tcx.sess.emit_err(errors::DocAliasBadChar { span, attr_str, char_: c });\n             return false;\n         }\n         if doc_alias_str.starts_with(' ') || doc_alias_str.ends_with(' ') {\n-            return err_fn(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                \"cannot start or end with ' '\",\n-            );\n+            tcx.sess.emit_err(errors::DocAliasStartEnd { span, attr_str });\n+            return false;\n         }\n-        if let Some(err) = match target {\n+\n+        let span = meta.span();\n+        if let Some(location) = match target {\n             Target::Impl => Some(\"implementation block\"),\n             Target::ForeignMod => Some(\"extern block\"),\n             Target::AssocTy => {\n@@ -686,19 +617,21 @@ impl CheckAttrVisitor<'_> {\n             Target::Param => return false,\n             _ => None,\n         } {\n-            return err_fn(meta.span(), &format!(\"isn't allowed on {}\", err));\n+            tcx.sess.emit_err(errors::DocAliasBadLocation { span, attr_str, location });\n+            return false;\n         }\n         let item_name = self.tcx.hir().name(hir_id);\n         if item_name == doc_alias {\n-            return err_fn(meta.span(), \"is the same as the item's name\");\n+            tcx.sess.emit_err(errors::DocAliasNotAnAlias { span, attr_str });\n+            return false;\n         }\n-        let span = meta.span();\n         if let Err(entry) = aliases.try_insert(doc_alias_str.to_owned(), span) {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, span, |lint| {\n-                lint.build(\"doc alias is duplicated\")\n-                    .span_label(*entry.entry.get(), \"first defined here\")\n-                    .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                span,\n+                errors::DocAliasDuplicated { first_defn: *entry.entry.get() },\n+            );\n         }\n         true\n     }\n@@ -723,22 +656,12 @@ impl CheckAttrVisitor<'_> {\n                         _ => {\n                             self.tcx\n                                 .sess\n-                                .struct_span_err(\n-                                    v.span(),\n-                                    \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n-                                )\n-                                .emit();\n+                                .emit_err(errors::DocAliasNotStringLiteral { span: v.span() });\n                             errors += 1;\n                         }\n                     },\n                     None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                v.span(),\n-                                \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(errors::DocAliasNotStringLiteral { span: v.span() });\n                         errors += 1;\n                     }\n                 }\n@@ -747,14 +670,7 @@ impl CheckAttrVisitor<'_> {\n         } else if let Some(doc_alias) = meta.value_str() {\n             self.check_doc_alias_value(meta, doc_alias, hir_id, target, false, aliases)\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.span(),\n-                    \"doc alias attribute expects a string `#[doc(alias = \\\"a\\\")]` or a list of \\\n-                     strings `#[doc(alias(\\\"a\\\", \\\"b\\\"))]`\",\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocAliasMalformed { span: meta.span() });\n             false\n         }\n     }\n@@ -771,35 +687,20 @@ impl CheckAttrVisitor<'_> {\n         }) {\n             Some(ItemKind::Mod(ref module)) => {\n                 if !module.item_ids.is_empty() {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            meta.span(),\n-                            \"`#[doc(keyword = \\\"...\\\")]` can only be used on empty modules\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::DocKeywordEmptyMod { span: meta.span() });\n                     return false;\n                 }\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta.span(),\n-                        \"`#[doc(keyword = \\\"...\\\")]` can only be used on modules\",\n-                    )\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DocKeywordNotMod { span: meta.span() });\n                 return false;\n             }\n         }\n         if !rustc_lexer::is_ident(doc_keyword.as_str()) {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                    &format!(\"`{doc_keyword}` is not a valid identifier\"),\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocKeywordInvalidIdent {\n+                span: meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                doc_keyword,\n+            });\n             return false;\n         }\n         true\n@@ -812,24 +713,12 @@ impl CheckAttrVisitor<'_> {\n         }) {\n             Some(ItemKind::Impl(ref i)) => {\n                 if !matches!(&i.self_ty.kind, hir::TyKind::Tup([_])) {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            meta.span(),\n-                            \"`#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::DocTupleVariadicNotFirst { span: meta.span() });\n                     return false;\n                 }\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta.span(),\n-                        \"`#[doc(keyword = \\\"...\\\")]` can only be used on impl blocks\",\n-                    )\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DocKeywordOnlyImpl { span: meta.span() });\n                 return false;\n             }\n         }\n@@ -858,13 +747,9 @@ impl CheckAttrVisitor<'_> {\n             if let Some((prev_inline, prev_span)) = *specified_inline {\n                 if do_inline != prev_inline {\n                     let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, \"this attribute...\");\n-                    spans.push_span_label(meta.span(), \"...conflicts with this attribute\");\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(spans, \"conflicting doc inlining attributes\")\n-                        .help(\"remove one of the conflicting attributes\")\n-                        .emit();\n+                    spans.push_span_label(prev_span, fluent::passes::doc_inline_conflict_first);\n+                    spans.push_span_label(meta.span(), fluent::passes::doc_inline_conflict_second);\n+                    self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n                     return false;\n                 }\n                 true\n@@ -873,23 +758,14 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n         } else {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                |lint| {\n-                    let mut err = lint.build(\n-                        \"this attribute can only be applied to a `use` item\",\n-                    );\n-                    err.span_label(meta.span(), \"only applicable on `use` items\");\n-                    if attr.style == AttrStyle::Outer {\n-                        err.span_label(\n-                            self.tcx.hir().span(hir_id),\n-                            \"not a `use` item\",\n-                        );\n-                    }\n-                    err.note(\"read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\")\n-                        .emit();\n+                errors::DocInlineOnlyUse {\n+                    attr_span: meta.span(),\n+                    item_span: (attr.style == AttrStyle::Outer)\n+                        .then(|| self.tcx.hir().span(hir_id)),\n                 },\n             );\n             false\n@@ -904,15 +780,7 @@ impl CheckAttrVisitor<'_> {\n         attr_name: &str,\n     ) -> bool {\n         if CRATE_HIR_ID == hir_id {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.span(),\n-                    &format!(\n-                        \"`#![doc({attr_name} = \\\"...\\\")]` isn't allowed as a crate-level attribute\",\n-                    ),\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocAttrNotCrateLevel { span: meta.span(), attr_name });\n             return false;\n         }\n         true\n@@ -926,36 +794,25 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n     ) -> bool {\n         if hir_id != CRATE_HIR_ID {\n-            self.tcx.struct_span_lint_hir(\n-                INVALID_DOC_ATTRIBUTES,\n-                hir_id,\n-                meta.span(),\n-                |lint| {\n-                    let mut err = lint.build(\n-                        \"this attribute can only be applied at the crate level\",\n-                    );\n-                    if attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID {\n-                        if let Ok(mut src) =\n-                            self.tcx.sess.source_map().span_to_snippet(attr.span)\n-                        {\n-                            src.insert(1, '!');\n-                            err.span_suggestion_verbose(\n-                                attr.span,\n-                                \"to apply to the crate, use an inner attribute\",\n-                                src,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            err.span_help(\n-                                attr.span,\n-                                \"to apply to the crate, use an inner attribute\",\n-                            );\n-                        }\n+            self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n+                let mut err = lint.build(fluent::passes::attr_crate_level);\n+                if attr.style == AttrStyle::Outer\n+                    && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID\n+                {\n+                    if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n+                        src.insert(1, '!');\n+                        err.span_suggestion_verbose(\n+                            attr.span,\n+                            fluent::passes::suggestion,\n+                            src,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_help(attr.span, fluent::passes::help);\n                     }\n-                    err.note(\"read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\")\n-                        .emit();\n-                },\n-            );\n+                }\n+                err.note(fluent::passes::note).emit();\n+            });\n             return false;\n         }\n         true\n@@ -970,28 +827,27 @@ impl CheckAttrVisitor<'_> {\n                 match i_meta.name_or_empty() {\n                     sym::attr | sym::no_crate_inject => {}\n                     _ => {\n-                        self.tcx.struct_span_lint_hir(\n+                        self.tcx.emit_spanned_lint(\n                             INVALID_DOC_ATTRIBUTES,\n                             hir_id,\n                             i_meta.span(),\n-                            |lint| {\n-                                lint.build(&format!(\n-                                    \"unknown `doc(test)` attribute `{}`\",\n-                                    rustc_ast_pretty::pprust::path_to_string(\n-                                        &i_meta.meta_item().unwrap().path\n-                                    ),\n-                                ))\n-                                .emit();\n+                            errors::DocTestUnknown {\n+                                path: rustc_ast_pretty::pprust::path_to_string(\n+                                    &i_meta.meta_item().unwrap().path,\n+                                ),\n                             },\n                         );\n                         is_valid = false;\n                     }\n                 }\n             }\n         } else {\n-            self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n-                lint.build(\"`#[doc(test(...)]` takes a list of attributes\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                INVALID_DOC_ATTRIBUTES,\n+                hir_id,\n+                meta.span(),\n+                errors::DocTestTakesList,\n+            );\n             is_valid = false;\n         }\n         is_valid\n@@ -1093,79 +949,66 @@ impl CheckAttrVisitor<'_> {\n \n                         sym::primitive => {\n                             if !self.tcx.features().rustdoc_internals {\n-                                self.tcx.struct_span_lint_hir(\n+                                self.tcx.emit_spanned_lint(\n                                     INVALID_DOC_ATTRIBUTES,\n                                     hir_id,\n                                     i_meta.span,\n-                                    |lint| {\n-                                        let mut diag = lint.build(\n-                                            \"`doc(primitive)` should never have been stable\",\n-                                        );\n-                                        diag.emit();\n-                                    },\n+                                    errors::DocPrimitive,\n                                 );\n                             }\n                         }\n \n                         _ => {\n-                            self.tcx.struct_span_lint_hir(\n-                                INVALID_DOC_ATTRIBUTES,\n-                                hir_id,\n-                                i_meta.span,\n-                                |lint| {\n-                                    let mut diag = lint.build(&format!(\n-                                        \"unknown `doc` attribute `{}`\",\n-                                        rustc_ast_pretty::pprust::path_to_string(&i_meta.path),\n-                                    ));\n-                                    if i_meta.has_name(sym::spotlight) {\n-                                        diag.note(\n-                                            \"`doc(spotlight)` was renamed to `doc(notable_trait)`\",\n-                                        );\n-                                        diag.span_suggestion_short(\n-                                            i_meta.span,\n-                                            \"use `notable_trait` instead\",\n-                                            \"notable_trait\",\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        diag.note(\"`doc(spotlight)` is now a no-op\");\n+                            let path = rustc_ast_pretty::pprust::path_to_string(&i_meta.path);\n+                            if i_meta.has_name(sym::spotlight) {\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownSpotlight {\n+                                        path,\n+                                        span: i_meta.span\n                                     }\n-                                    if i_meta.has_name(sym::include) {\n-                                        if let Some(value) = i_meta.value_str() {\n-                                            // if there are multiple attributes, the suggestion would suggest deleting all of them, which is incorrect\n-                                            let applicability = if list.len() == 1 {\n-                                                Applicability::MachineApplicable\n-                                            } else {\n-                                                Applicability::MaybeIncorrect\n-                                            };\n-                                            let inner = if attr.style == AttrStyle::Inner {\n-                                                \"!\"\n-                                            } else {\n-                                                \"\"\n-                                            };\n-                                            diag.span_suggestion(\n-                                                attr.meta().unwrap().span,\n-                                                \"use `doc = include_str!` instead\",\n-                                                format!(\n-                                                    \"#{inner}[doc = include_str!(\\\"{value}\\\")]\",\n-                                                ),\n-                                                applicability,\n-                                            );\n-                                        }\n+                                );\n+                            } else if i_meta.has_name(sym::include) &&\n+                                    let Some(value) = i_meta.value_str() {\n+                                let applicability = if list.len() == 1 {\n+                                    Applicability::MachineApplicable\n+                                } else {\n+                                    Applicability::MaybeIncorrect\n+                                };\n+                                // If there are multiple attributes, the suggestion would suggest\n+                                // deleting all of them, which is incorrect.\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownInclude {\n+                                        path,\n+                                        value: value.to_string(),\n+                                        inner: (attr.style == AttrStyle::Inner)\n+                                            .then_some(\"!\")\n+                                            .unwrap_or(\"\"),\n+                                        sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n-                                    diag.emit();\n-                                },\n-                            );\n+                                );\n+                            } else {\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownAny { path }\n+                                );\n+                            }\n                             is_valid = false;\n                         }\n                     }\n                 } else {\n-                    self.tcx.struct_span_lint_hir(\n+                    self.tcx.emit_spanned_lint(\n                         INVALID_DOC_ATTRIBUTES,\n                         hir_id,\n                         meta.span(),\n-                        |lint| {\n-                            lint.build(\"invalid `doc` attribute\").emit();\n-                        },\n+                        errors::DocInvalid,\n                     );\n                     is_valid = false;\n                 }\n@@ -1180,14 +1023,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Struct | Target::Enum | Target::TyAlias => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`pass_by_value` attribute should be applied to a struct, enum or type alias.\",\n-                    )\n-                    .span_label(span, \"is not a struct, enum or type alias\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::PassByValue { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1197,14 +1033,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Method(MethodKind::Inherent) => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`rustc_allow_incoherent_impl` attribute should be applied to impl items.\",\n-                    )\n-                    .span_label(span, \"the only currently supported targets are inherent methods\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AllowIncoherentImpl { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1223,12 +1052,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\",\n-                    )\n-                    .span_label(span, \"only adts, extern types and traits are supported\")\n-                    .emit();\n+                    .emit_err(errors::HasIncoherentInherentImpl { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1238,19 +1062,12 @@ impl CheckAttrVisitor<'_> {\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);\n         if let Some(kind) = node.fn_kind() && let rustc_hir::IsAsync::Async = kind.asyncness() {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\n-                    \"`must_use` attribute on `async` functions \\\n-                    applies to the anonymous `Future` returned by the \\\n-                    function, not the value within\",\n-                )\n-                .span_label(\n-                    span,\n-                    \"this attribute does nothing, the `Future`s \\\n-                    returned by async functions are already `must_use`\",\n-                )\n-                .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::MustUseAsync { span }\n+            );\n         }\n \n         if !matches!(\n@@ -1278,12 +1095,12 @@ impl CheckAttrVisitor<'_> {\n                 _ => \"a\",\n             };\n \n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(&format!(\n-                    \"`#[must_use]` has no effect when applied to {article} {target}\"\n-                ))\n-                .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::MustUseNoEffect { article, target },\n+            );\n         }\n \n         // For now, its always valid\n@@ -1295,11 +1112,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Struct | Target::Enum | Target::Union | Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"`must_not_suspend` attribute should be applied to a struct, enum, or trait\")\n-                        .span_label(span, \"is not a struct, enum, or trait\")\n-                        .emit();\n+                self.tcx.sess.emit_err(errors::MustNotSuspend { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1319,16 +1132,12 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions and some crates used\n                 // this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::Cold { span },\n+                );\n             }\n         }\n     }\n@@ -1343,19 +1152,12 @@ impl CheckAttrVisitor<'_> {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            let mut diag =\n-                lint.build(\"attribute should be applied to an `extern` block with non-Rust ABI\");\n-            diag.warn(\n-                \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-            );\n-            if target != Target::ForeignMod {\n-                diag.span_label(span, \"not an `extern` block\");\n-            }\n-            diag.emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::Link { span: (target != Target::ForeignMod).then_some(span) },\n+        );\n     }\n \n     /// Checks if `#[link_name]` is applied to an item other than a foreign function or static."}, {"sha": "f8e8720ab5474231a487f2c7fd2d251e611fc62b", "filename": "compiler/rustc_passes/src/errors.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -0,0 +1,362 @@\n+use rustc_errors::{Applicability, MultiSpan};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::outer_crate_level_attr)]\n+pub struct OuterCrateLevelAttr;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inner_crate_level_attr)]\n+pub struct InnerCrateLevelAttr;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::ignored_attr_with_macro)]\n+pub struct IgnoredAttrWithMacro<'a> {\n+    pub sym: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::ignored_attr)]\n+pub struct IgnoredAttr<'a> {\n+    pub sym: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inline_ignored_function_prototype)]\n+pub struct IgnoredInlineAttrFnProto;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inline_ignored_constants)]\n+#[warn_]\n+#[note]\n+pub struct IgnoredInlineAttrConstants;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::inline_not_fn_or_closure, code = \"E0518\")]\n+pub struct InlineNotFnOrClosure {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_ignored_function_prototype)]\n+pub struct IgnoredNoCoverageFnProto;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_propagate)]\n+pub struct IgnoredNoCoveragePropagate;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_fn_defn)]\n+pub struct IgnoredNoCoverageFnDefn;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::no_coverage_not_coverable, code = \"E0788\")]\n+pub struct IgnoredNoCoverageNotCoverable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_fn)]\n+pub struct AttrShouldBeAppliedToFn {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::naked_tracked_caller, code = \"E0736\")]\n+pub struct NakedTrackedCaller {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_fn, code = \"E0739\")]\n+pub struct TrackedCallerWrongLocation {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_struct_enum, code = \"E0701\")]\n+pub struct NonExhaustiveWrongLocation {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_trait)]\n+pub struct AttrShouldBeAppliedToTrait {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::target_feature_on_statement)]\n+pub struct TargetFeatureOnStatement;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_static)]\n+pub struct AttrShouldBeAppliedToStatic {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_expect_str)]\n+pub struct DocExpectStr<'a> {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    pub attr_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_empty)]\n+pub struct DocAliasEmpty<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_bad_char)]\n+pub struct DocAliasBadChar<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+    pub char_: char,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_start_end)]\n+pub struct DocAliasStartEnd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_bad_location)]\n+pub struct DocAliasBadLocation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+    pub location: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_not_an_alias)]\n+pub struct DocAliasNotAnAlias<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_alias_duplicated)]\n+pub struct DocAliasDuplicated {\n+    #[label]\n+    pub first_defn: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_not_string_literal)]\n+pub struct DocAliasNotStringLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_malformed)]\n+pub struct DocAliasMalformed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_empty_mod)]\n+pub struct DocKeywordEmptyMod {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_not_mod)]\n+pub struct DocKeywordNotMod {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_invalid_ident)]\n+pub struct DocKeywordInvalidIdent {\n+    #[primary_span]\n+    pub span: Span,\n+    pub doc_keyword: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_tuple_variadic_not_first)]\n+pub struct DocTupleVariadicNotFirst {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_only_impl)]\n+pub struct DocKeywordOnlyImpl {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_inline_conflict)]\n+#[help]\n+pub struct DocKeywordConflict {\n+    #[primary_span]\n+    pub spans: MultiSpan,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_inline_only_use)]\n+#[note]\n+pub struct DocInlineOnlyUse {\n+    #[label]\n+    pub attr_span: Span,\n+    #[label(passes::not_a_use_item_label)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_attr_not_crate_level)]\n+pub struct DocAttrNotCrateLevel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_name: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown)]\n+pub struct DocTestUnknown {\n+    pub path: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_takes_list)]\n+pub struct DocTestTakesList;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_primitive)]\n+pub struct DocPrimitive;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_any)]\n+pub struct DocTestUnknownAny {\n+    pub path: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_spotlight)]\n+#[note]\n+#[note(passes::no_op_note)]\n+pub struct DocTestUnknownSpotlight {\n+    pub path: String,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"notable_trait\")]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_include)]\n+pub struct DocTestUnknownInclude {\n+    pub path: String,\n+    pub value: String,\n+    pub inner: &'static str,\n+    #[suggestion(code = \"#{inner}[doc = include_str!(\\\"{value}\\\")]\")]\n+    pub sugg: (Span, Applicability),\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_invalid)]\n+pub struct DocInvalid;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::pass_by_value)]\n+pub struct PassByValue {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::allow_incoherent_impl)]\n+pub struct AllowIncoherentImpl {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::has_incoherent_inherent_impl)]\n+pub struct HasIncoherentInherentImpl {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::must_use_async)]\n+pub struct MustUseAsync {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::must_use_no_effect)]\n+pub struct MustUseNoEffect {\n+    pub article: &'static str,\n+    pub target: rustc_hir::Target,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::must_not_suspend)]\n+pub struct MustNotSuspend {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::cold)]\n+#[warn_]\n+pub struct Cold {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link)]\n+#[warn_]\n+pub struct Link {\n+    #[label]\n+    pub span: Option<Span>,\n+}"}, {"sha": "7b2f83958af85cd31c4bf0f3ebd87a7c5e8aa87e", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -7,8 +7,8 @@\n #![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(iter_intersperse)]\n-#![feature(let_else)]\n #![feature(let_chains)]\n+#![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(try_blocks)]\n@@ -27,6 +27,7 @@ pub mod dead;\n mod debugger_visualizer;\n mod diagnostic_items;\n pub mod entry;\n+mod errors;\n pub mod hir_id_validator;\n pub mod hir_stats;\n mod lang_items;"}, {"sha": "b0fac91f6ebc35831e6790f8406bdf358272d041", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,4 +1,4 @@\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -73,3 +73,19 @@ pub struct InPublicInterface<'a> {\n     #[label(privacy::visibility_label)]\n     pub vis_span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[lint(privacy::from_private_dep_in_public_interface)]\n+pub struct FromPrivateDependencyInPublicInterface<'a> {\n+    pub kind: &'a str,\n+    pub descr: String,\n+    pub krate: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(privacy::private_in_public_lint)]\n+pub struct PrivateInPublicLint<'a> {\n+    pub vis_descr: &'static str,\n+    pub kind: &'a str,\n+    pub descr: String,\n+}"}, {"sha": "9a835808d4935518ea21e24dd95189aa85a477ab", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -38,8 +38,8 @@ use std::ops::ControlFlow;\n use std::{cmp, fmt, mem};\n \n use errors::{\n-    FieldIsPrivate, FieldIsPrivateLabel, InPublicInterface, InPublicInterfaceTraits, ItemIsPrivate,\n-    UnnamedItemIsPrivate,\n+    FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n+    InPublicInterfaceTraits, ItemIsPrivate, PrivateInPublicLint, UnnamedItemIsPrivate,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -1716,19 +1716,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         if self.leaks_private_dep(def_id) {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n                 self.tcx.hir().local_def_id_to_hir_id(self.item_def_id),\n                 self.tcx.def_span(self.item_def_id.to_def_id()),\n-                |lint| {\n-                    lint.build(&format!(\n-                        \"{} `{}` from private dependency '{}' in public \\\n-                                                interface\",\n-                        kind,\n-                        descr,\n-                        self.tcx.crate_name(def_id.krate)\n-                    ))\n-                    .emit();\n+                FromPrivateDependencyInPublicInterface {\n+                    kind,\n+                    descr: descr.to_string(),\n+                    krate: self.tcx.crate_name(def_id.krate),\n                 },\n             );\n         }\n@@ -1754,12 +1749,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                 }\n             };\n             let span = self.tcx.def_span(self.item_def_id.to_def_id());\n+            let descr = descr.to_string();\n             if self.has_old_errors\n                 || self.in_assoc_ty\n                 || self.tcx.resolutions(()).has_pub_restricted\n             {\n                 let descr = descr.to_string();\n-                let vis_span = self.tcx.def_span(def_id);\n+                let vis_span =\n+                    self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n                 if kind == \"trait\" {\n                     self.tcx.sess.emit_err(InPublicInterfaceTraits {\n                         span,\n@@ -1778,19 +1775,11 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                     });\n                 }\n             } else {\n-                let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.struct_span_lint_hir(\n+                self.tcx.emit_spanned_lint(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n                     span,\n-                    |lint| {\n-                        lint.build(&format!(\n-                            \"{} (error {})\",\n-                            format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr),\n-                            err_code\n-                        ))\n-                        .emit();\n-                    },\n+                    PrivateInPublicLint { vis_descr, kind, descr },\n                 );\n             }\n         }"}, {"sha": "a4fa3817905c7dbc428514fd99fa9321b10f10b9", "filename": "src/test/rustdoc-ui/invalid-doc-attr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(warnings)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n@@ -29,7 +29,7 @@ LL | pub fn foo() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: this attribute can only be applied at the crate level\n   --> $DIR/invalid-doc-attr.rs:15:12\n@@ -39,7 +39,7 @@ LL |     #![doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: conflicting doc inlining attributes\n   --> $DIR/invalid-doc-attr.rs:28:7\n@@ -59,7 +59,7 @@ LL |     #[doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:22:11\n@@ -72,7 +72,7 @@ LL |     pub fn baz() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: aborting due to 6 previous errors\n "}, {"sha": "0a210cbdc94307677afd1428e626190bb68503eb", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_middle;\n use rustc_middle::ty::Ty;\n \n extern crate rustc_errors;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n \n extern crate rustc_session;\n \n@@ -140,7 +140,7 @@ struct CodeNotProvided {}\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n-    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     foo: String,\n }\n \n@@ -165,7 +165,7 @@ struct ErrorWithField {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     name: String,\n }\n \n@@ -208,7 +208,7 @@ struct LabelOnSpan {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnNonSpan {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     id: u32,\n }\n \n@@ -538,7 +538,7 @@ struct LabelWithTrailingList {\n \n #[derive(SessionDiagnostic)]\n #[lint(typeck::ambiguous_lifetime_bound)]\n-//~^ ERROR only `#[error(..)]` and `#[warn(..)]` are supported\n+//~^ ERROR only `#[error(..)]` and `#[warning(..)]` are supported\n struct LintsBad {\n }\n \n@@ -552,3 +552,17 @@ struct LintsGood {\n //~^ ERROR only `#[lint(..)]` is supported\n struct ErrorsBad {\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct ErrorWithMultiSpan {\n+    #[primary_span]\n+    span: MultiSpan,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[warn_]\n+struct ErrorWithWarn {\n+    val: String,\n+}"}, {"sha": "c1080aa24521f7735bac376335686928b7c5dc76", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -21,7 +21,7 @@ error: `#[nonsense(...)]` is not a valid attribute\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: only `error`, `warning`, `help` and `note` are valid attributes\n+   = help: only `error`, `warning`, `help`, `note` and `warn_` are valid attributes\n \n error: diagnostic kind not specified\n   --> $DIR/diagnostic-derive.rs:53:1\n@@ -233,7 +233,7 @@ LL | | struct SlugNotProvided {}\n    |\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:142:5\n    |\n LL |     #[primary_span]\n@@ -247,7 +247,7 @@ LL |     #[nonsense]\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:167:5\n    |\n LL |     #[label(typeck::label)]\n@@ -279,7 +279,7 @@ LL | #[derive(SessionDiagnostic)]\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:210:5\n    |\n LL |     #[label(typeck::label)]\n@@ -363,7 +363,7 @@ error: `#[label(...)]` is not a valid attribute\n LL |     #[label(typeck::label, foo(\"...\"))]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: only `#[error(..)]` and `#[warn(..)]` are supported\n+error: only `#[error(..)]` and `#[warning(..)]` are supported\n   --> $DIR/diagnostic-derive.rs:540:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound)]"}, {"sha": "16da25c402b570eac91383ed760b915a6d9ffc2b", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -244,7 +244,7 @@ enum V {\n //~^ ERROR label without `#[primary_span]` field\n struct W {\n     #[primary_span]\n-    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     span: String,\n }\n \n@@ -508,3 +508,15 @@ enum AX {\n         span: Span,\n     }\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+#[warn_(parser::add_paren)]\n+struct AY {\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[warn_(parser::add_paren)]\n+struct AZ {\n+    #[primary_span]\n+    span: Span,\n+}"}, {"sha": "a289c4fffd9365e6882e9bd0a60fff2d420c6988", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -120,7 +120,7 @@ error: subdiagnostic kind not specified\n LL |     B {\n    |     ^\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/subdiagnostic-derive.rs:246:5\n    |\n LL |     #[primary_span]"}, {"sha": "a4fa3817905c7dbc428514fd99fa9321b10f10b9", "filename": "src/test/ui/attributes/invalid-doc-attr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(warnings)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n@@ -29,7 +29,7 @@ LL | pub fn foo() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: this attribute can only be applied at the crate level\n   --> $DIR/invalid-doc-attr.rs:15:12\n@@ -39,7 +39,7 @@ LL |     #![doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: conflicting doc inlining attributes\n   --> $DIR/invalid-doc-attr.rs:28:7\n@@ -59,7 +59,7 @@ LL |     #[doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:22:11\n@@ -72,7 +72,7 @@ LL |     pub fn baz() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a8dba0ba37d3ad817ee27f151ddae7ad3e6b9ac0", "filename": "src/test/ui/attributes/multiple-invalid.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -7,14 +7,14 @@ LL | #[inline]\n LL | const FOO: u8 = 0;\n    | ------------------ not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/multiple-invalid.rs:6:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | const FOO: u8 = 0;\n-   | ------------------ not a function\n+   | ------------------ not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5d6796b49448a5dc50b3cea07535c524aef5d98c", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -259,7 +259,7 @@ warning: crate-level attribute should be an inner attribute: add an exclamation\n LL | #[no_std]\n    | ^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:453:1\n    |\n LL |   #[cold]\n@@ -272,7 +272,7 @@ LL | |     mod inner { #![cold] }\n ...  |\n LL | |\n LL | | }\n-   | |_- not a function\n+   | |_- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n@@ -399,7 +399,7 @@ warning: `#[proc_macro_derive]` only has an effect on functions\n LL | #![proc_macro_derive()]\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:62:1\n    |\n LL | #![cold]\n@@ -743,35 +743,35 @@ warning: crate-level attribute should be an inner attribute: add an exclamation\n LL |     #[no_std] impl S { }\n    |     ^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:459:17\n    |\n LL |     mod inner { #![cold] }\n-   |     ------------^^^^^^^^-- not a function\n+   |     ------------^^^^^^^^-- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:466:5\n    |\n LL |     #[cold] struct S;\n-   |     ^^^^^^^ --------- not a function\n+   |     ^^^^^^^ --------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:471:5\n    |\n LL |     #[cold] type T = S;\n-   |     ^^^^^^^ ----------- not a function\n+   |     ^^^^^^^ ----------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:476:5\n    |\n LL |     #[cold] impl S { }\n-   |     ^^^^^^^ ---------- not a function\n+   |     ^^^^^^^ ---------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "8f6dde665e6284242a8fe8da2a669977fee72856", "filename": "src/test/ui/future-incompatible-lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -22,7 +22,7 @@ LL | #![deny(future_incompatible)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(future_incompatible)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "100965de1aa8496d2a5b5940621fead045e58a70", "filename": "src/test/ui/issues/issue-54044.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,11 +1,11 @@\n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-54044.rs:3:1\n    |\n LL | #[cold]\n    | ^^^^^^^\n ...\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n    |\n note: the lint level is defined here\n   --> $DIR/issue-54044.rs:1:9\n@@ -14,14 +14,14 @@ LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-54044.rs:9:5\n    |\n LL |     #[cold]\n    |     ^^^^^^^\n ...\n LL |     5;\n-   |     - not a function\n+   |     - not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "45fa69d6fd7087eebd63be3c9b87cbe54bece7c1", "filename": "src/test/ui/issues/issue-78957.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -4,11 +4,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo<#[inline] const N: usize>;\n    |                ^^^^^^^^^ -------------- not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:7:16\n    |\n LL | pub struct Bar<#[cold] const N: usize>;\n-   |                ^^^^^^^ -------------- not a function\n+   |                ^^^^^^^ -------------- not a function definition\n    |\n note: the lint level is defined here\n   --> $DIR/issue-78957.rs:1:9\n@@ -29,11 +29,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo2<#[inline] 'a>(PhantomData<&'a ()>);\n    |                 ^^^^^^^^^ -- not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:15:17\n    |\n LL | pub struct Bar2<#[cold] 'a>(PhantomData<&'a ()>);\n-   |                 ^^^^^^^ -- not a function\n+   |                 ^^^^^^^ -- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n@@ -49,11 +49,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo3<#[inline] T>(PhantomData<T>);\n    |                 ^^^^^^^^^ - not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:23:17\n    |\n LL | pub struct Bar3<#[cold] T>(PhantomData<T>);\n-   |                 ^^^^^^^ - not a function\n+   |                 ^^^^^^^ - not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "b13e418e664a6a7fd3e598214e67a4906227e3d0", "filename": "src/test/ui/macros/issue-68060.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,11 +1,11 @@\n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-68060.rs:4:13\n    |\n LL |             #[target_feature(enable = \"\")]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL |             |_| (),\n-   |             ------ not a function\n+   |             ------ not a function definition\n \n error: aborting due to previous error\n "}, {"sha": "0bf620934ec7b30e9c8cfee8ee6770fffc79a789", "filename": "src/test/ui/marker_trait_attr/marker-attribute-on-non-trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,23 +1,23 @@\n #![feature(marker_trait_attr)]\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n struct Struct {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n impl Struct {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n union Union {\n     x: i32,\n }\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n const CONST: usize = 10;\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n fn function() {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n type Type = ();\n \n fn main() {}"}, {"sha": "19a5290dd7eb640409dc55829c159cfd52cf55bb", "filename": "src/test/ui/marker_trait_attr/marker-attribute-on-non-trait.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,20 +1,20 @@\n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:3:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | struct Struct {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:6:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | impl Struct {}\n    | -------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:9:1\n    |\n LL |   #[marker]\n@@ -24,23 +24,23 @@ LL | |     x: i32,\n LL | | }\n    | |_- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:14:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | const CONST: usize = 10;\n    | ------------------------ not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:17:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | fn function() {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:20:1\n    |\n LL | #[marker]"}, {"sha": "143f9a3009b6171846dcd3e1715c9e694deaafc1", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -3,11 +3,11 @@\n struct Foo;\n \n #[non_exhaustive]\n-//~^ ERROR attribute can only be applied to a struct or enum [E0701]\n+//~^ ERROR attribute should be applied to a struct or enum [E0701]\n trait Bar { }\n \n #[non_exhaustive]\n-//~^ ERROR attribute can only be applied to a struct or enum [E0701]\n+//~^ ERROR attribute should be applied to a struct or enum [E0701]\n union Baz {\n     f1: u16,\n     f2: u16"}, {"sha": "136cd763b05c17865c12c4dddfa96e67503d714c", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -4,7 +4,7 @@ error: malformed `non_exhaustive` attribute input\n LL | #[non_exhaustive(anything)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[non_exhaustive]`\n \n-error[E0701]: attribute can only be applied to a struct or enum\n+error[E0701]: attribute should be applied to a struct or enum\n   --> $DIR/invalid-attribute.rs:5:1\n    |\n LL | #[non_exhaustive]\n@@ -13,7 +13,7 @@ LL |\n LL | trait Bar { }\n    | ------------- not a struct or enum\n \n-error[E0701]: attribute can only be applied to a struct or enum\n+error[E0701]: attribute should be applied to a struct or enum\n   --> $DIR/invalid-attribute.rs:9:1\n    |\n LL |   #[non_exhaustive]"}, {"sha": "2d2b01b6f947aea42b4b864f3d453ea9aed78ef0", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,5 +1,5 @@\n #[track_caller]\n struct S;\n-//~^^ ERROR attribute should be applied to function\n+//~^^ ERROR attribute should be applied to a function definition\n \n fn main() {}"}, {"sha": "b36597bded9414c2fc828953a3b0114492903802", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,10 +1,10 @@\n-error[E0739]: attribute should be applied to function\n+error[E0739]: attribute should be applied to a function definition\n   --> $DIR/only-for-fns.rs:1:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n LL | struct S;\n-   | --------- not a function\n+   | --------- not a function definition\n \n error: aborting due to previous error\n "}, {"sha": "68a8802b2f6455fdb9b445fae0368323b5679ac7", "filename": "src/test/ui/rustdoc/doc_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -15,6 +15,6 @@ fn foo() {}\n // Regression test for the ICE described in #83512.\n trait Foo {\n     #[doc(keyword = \"match\")]\n-    //~^ ERROR: `#[doc(keyword = \"...\")]` can only be used on modules\n+    //~^ ERROR: `#[doc(keyword = \"...\")]` should be used on modules\n     fn quux() {}\n }"}, {"sha": "a1d0e4ffc09387680100ec8a79e798edde4c7249", "filename": "src/test/ui/rustdoc/doc_keyword.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -1,16 +1,16 @@\n-error: `#[doc(keyword = \"...\")]` can only be used on empty modules\n+error: `#[doc(keyword = \"...\")]` should be used on empty modules\n   --> $DIR/doc_keyword.rs:6:7\n    |\n LL | #[doc(keyword = \"hell\")]\n    |       ^^^^^^^^^^^^^^^^\n \n-error: `#[doc(keyword = \"...\")]` can only be used on modules\n+error: `#[doc(keyword = \"...\")]` should be used on modules\n   --> $DIR/doc_keyword.rs:11:7\n    |\n LL | #[doc(keyword = \"hall\")]\n    |       ^^^^^^^^^^^^^^^^\n \n-error: `#[doc(keyword = \"...\")]` can only be used on modules\n+error: `#[doc(keyword = \"...\")]` should be used on modules\n   --> $DIR/doc_keyword.rs:17:11\n    |\n LL |     #[doc(keyword = \"match\")]"}, {"sha": "889ced9752bd4520b3460ac8cc78ec679a28c157", "filename": "src/test/ui/target-feature/invalid-attribute.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -34,43 +34,43 @@ LL | fn bar() {}\n    = note: see issue #69098 <https://github.com/rust-lang/rust/issues/69098> for more information\n    = help: add `#![feature(target_feature_11)]` to the crate attributes to enable\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:34:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | mod another {}\n-   | -------------- not a function\n+   | -------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:39:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | const FOO: usize = 7;\n-   | --------------------- not a function\n+   | --------------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:44:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:49:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | enum Bar {}\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:54:1\n    |\n LL |   #[target_feature(enable = \"sse2\")]\n@@ -81,24 +81,24 @@ LL | |\n LL | |     f1: u16,\n LL | |     f2: u16,\n LL | | }\n-   | |_- not a function\n+   | |_- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:62:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | trait Baz {}\n-   | ------------ not a function\n+   | ------------ not a function definition\n \n error: cannot use `#[inline(always)]` with `#[target_feature]`\n   --> $DIR/invalid-attribute.rs:67:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:85:5\n    |\n LL |       #[target_feature(enable = \"sse2\")]\n@@ -108,16 +108,16 @@ LL | /     unsafe {\n LL | |         foo();\n LL | |         bar();\n LL | |     }\n-   | |_____- not a function\n+   | |_____- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:93:5\n    |\n LL |     #[target_feature(enable = \"sse2\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |     || {};\n-   |     ----- not a function\n+   |     ----- not a function definition\n \n error[E0658]: `#[target_feature(..)]` can only be applied to `unsafe` functions\n   --> $DIR/invalid-attribute.rs:77:5"}, {"sha": "1f896da94db57c279aefcae77bcef77009587a66", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -36,11 +36,11 @@ trait Tr5 {\n }\n \n #[rustc_must_implement_one_of(abc, xyz)]\n-//~^ attribute can only be applied to a trait\n+//~^ attribute should be applied to a trait\n fn function() {}\n \n #[rustc_must_implement_one_of(abc, xyz)]\n-//~^ attribute can only be applied to a trait\n+//~^ attribute should be applied to a trait\n struct Struct {}\n \n fn main() {}"}, {"sha": "869184f0d1a69fc3f28f5ccd186116077158f634", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79857a740eb4757a7b59da9e7740223bb4c9e115/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr?ref=79857a740eb4757a7b59da9e7740223bb4c9e115", "patch": "@@ -4,7 +4,7 @@ error: malformed `rustc_must_implement_one_of` attribute input\n LL | #[rustc_must_implement_one_of]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_must_implement_one_of(function1, function2, ...)]`\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/rustc_must_implement_one_of_misuse.rs:38:1\n    |\n LL | #[rustc_must_implement_one_of(abc, xyz)]\n@@ -13,7 +13,7 @@ LL |\n LL | fn function() {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/rustc_must_implement_one_of_misuse.rs:42:1\n    |\n LL | #[rustc_must_implement_one_of(abc, xyz)]"}]}