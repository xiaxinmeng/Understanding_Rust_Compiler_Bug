{"sha": "62c8256b9f6f219712a2403e7b7cf1e67a5a31d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzgyNTZiOWY2ZjIxOTcxMmEyNDAzZTdiN2NmMWU2N2E1YTMxZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T04:13:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T04:13:26Z"}, "message": "Auto merge of #31068 - sfackler:bufwriter-panic, r=alexcrichton\n\nWe don't want to write the same data twice.\n\nCloses #30888\n\nr? @alexcrichton", "tree": {"sha": "80bdecd6c79439166bb1111d530f4d47cb465563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80bdecd6c79439166bb1111d530f4d47cb465563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4", "html_url": "https://github.com/rust-lang/rust/commit/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "html_url": "https://github.com/rust-lang/rust/commit/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9"}, {"sha": "334bee348940dad95dd7f390ddca5ed5db8213f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/334bee348940dad95dd7f390ddca5ed5db8213f6", "html_url": "https://github.com/rust-lang/rust/commit/334bee348940dad95dd7f390ddca5ed5db8213f6"}], "stats": {"total": 43, "additions": 40, "deletions": 3}, "files": [{"sha": "625818a295a42d25ebdd539897540f5b28b80391", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c8256b9f6f219712a2403e7b7cf1e67a5a31d4/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=62c8256b9f6f219712a2403e7b7cf1e67a5a31d4", "patch": "@@ -300,6 +300,10 @@ impl<R: Seek> Seek for BufReader<R> {\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n+    // #30888: If the inner writer panics in a call to write, we don't want to\n+    // write the buffered data a second time in BufWriter's destructor. This\n+    // flag tells the Drop impl if it should skip the flush.\n+    panicked: bool,\n }\n \n /// An error returned by `into_inner` which combines an error that\n@@ -364,6 +368,7 @@ impl<W: Write> BufWriter<W> {\n         BufWriter {\n             inner: Some(inner),\n             buf: Vec::with_capacity(cap),\n+            panicked: false,\n         }\n     }\n \n@@ -372,7 +377,11 @@ impl<W: Write> BufWriter<W> {\n         let len = self.buf.len();\n         let mut ret = Ok(());\n         while written < len {\n-            match self.inner.as_mut().unwrap().write(&self.buf[written..]) {\n+            self.panicked = true;\n+            let r = self.inner.as_mut().unwrap().write(&self.buf[written..]);\n+            self.panicked = false;\n+\n+            match r {\n                 Ok(0) => {\n                     ret = Err(Error::new(ErrorKind::WriteZero,\n                                          \"failed to write the buffered data\"));\n@@ -455,7 +464,10 @@ impl<W: Write> Write for BufWriter<W> {\n             try!(self.flush_buf());\n         }\n         if buf.len() >= self.buf.capacity() {\n-            self.inner.as_mut().unwrap().write(buf)\n+            self.panicked = true;\n+            let r = self.inner.as_mut().unwrap().write(buf);\n+            self.panicked = false;\n+            r\n         } else {\n             let amt = cmp::min(buf.len(), self.buf.capacity());\n             Write::write(&mut self.buf, &buf[..amt])\n@@ -489,7 +501,7 @@ impl<W: Write + Seek> Seek for BufWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Drop for BufWriter<W> {\n     fn drop(&mut self) {\n-        if self.inner.is_some() {\n+        if self.inner.is_some() && !self.panicked {\n             // dtors should not panic, so we ignore a failed flush\n             let _r = self.flush_buf();\n         }\n@@ -777,6 +789,8 @@ mod tests {\n     use prelude::v1::*;\n     use io::prelude::*;\n     use io::{self, BufReader, BufWriter, LineWriter, SeekFrom};\n+    use sync::atomic::{AtomicUsize, Ordering};\n+    use thread;\n     use test;\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -1065,6 +1079,29 @@ mod tests {\n         panic!();\n     }\n \n+    #[test]\n+    fn panic_in_write_doesnt_flush_in_drop() {\n+        static WRITES: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct PanicWriter;\n+\n+        impl Write for PanicWriter {\n+            fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n+                WRITES.fetch_add(1, Ordering::SeqCst);\n+                panic!();\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+\n+        thread::spawn(|| {\n+            let mut writer = BufWriter::new(PanicWriter);\n+            writer.write(b\"hello world\");\n+            writer.flush();\n+        }).join().err().unwrap();\n+\n+        assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n+    }\n+\n     #[bench]\n     fn bench_buffered_reader(b: &mut test::Bencher) {\n         b.iter(|| {"}]}