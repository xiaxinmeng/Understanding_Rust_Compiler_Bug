{"sha": "ef9781358daa0a70bdaf11c9f792210ea30dd396", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOTc4MTM1OGRhYTBhNzBiZGFmMTFjOWY3OTIyMTBlYTMwZGQzOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T10:30:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T10:30:11Z"}, "message": "Auto merge of #52555 - petrochenkov:mresfact, r=alexcrichton\n\nresolve: Some renaming, refactoring and comments\n\nCommits are self-descriptive.\nThe only functional change is https://github.com/rust-lang/rust/commit/34bf2f572e33d4df1459413b5014ca98fc9fa4e0 that tightens shadowing rules for macro paths (makes the second and third cases in `test/ui/imports/glob-shadowing.rs` an error).", "tree": {"sha": "bf8c92645e52a9f85376cb16b56816f6d42fd2d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf8c92645e52a9f85376cb16b56816f6d42fd2d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef9781358daa0a70bdaf11c9f792210ea30dd396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9781358daa0a70bdaf11c9f792210ea30dd396", "html_url": "https://github.com/rust-lang/rust/commit/ef9781358daa0a70bdaf11c9f792210ea30dd396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef9781358daa0a70bdaf11c9f792210ea30dd396/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd455ef165f110143b97106b4e7cd8c83cd21f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd455ef165f110143b97106b4e7cd8c83cd21f03", "html_url": "https://github.com/rust-lang/rust/commit/bd455ef165f110143b97106b4e7cd8c83cd21f03"}, {"sha": "382285a01de393ecc9dd2c78c2518299d8749c12", "url": "https://api.github.com/repos/rust-lang/rust/commits/382285a01de393ecc9dd2c78c2518299d8749c12", "html_url": "https://github.com/rust-lang/rust/commit/382285a01de393ecc9dd2c78c2518299d8749c12"}], "stats": {"total": 410, "additions": 246, "deletions": 164}, "files": [{"sha": "0ae45b3123259a2b7dbb4c7286d3207757f3f3b4", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -103,7 +103,7 @@ impl<K, V> LeafNode<K, V> {\n     }\n \n     fn is_shared_root(&self) -> bool {\n-        self as *const _ == &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V>\n+        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n "}, {"sha": "c16029d33205e6875ad9902aa2f80b285f03b91a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -39,7 +39,7 @@ use hir::intravisit;\n use hir;\n use lint::builtin::BuiltinLintDiagnostics;\n use session::{Session, DiagnosticMessageId};\n-use std::hash;\n+use std::{hash, ptr};\n use syntax::ast;\n use syntax::codemap::{MultiSpan, ExpnFormat};\n use syntax::edition::Edition;\n@@ -354,7 +354,7 @@ pub struct LintId {\n \n impl PartialEq for LintId {\n     fn eq(&self, other: &LintId) -> bool {\n-        (self.lint as *const Lint) == (other.lint as *const Lint)\n+        ptr::eq(self.lint, other.lint)\n     }\n }\n "}, {"sha": "bd24b93f0293f63353adda235e86d9b54a72974c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -47,7 +47,7 @@ use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n use std::vec::IntoIter;\n-use std::mem;\n+use std::{mem, ptr};\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n@@ -527,8 +527,7 @@ impl<'tcx> PartialOrd for TyS<'tcx> {\n impl<'tcx> PartialEq for TyS<'tcx> {\n     #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n-        // (self as *const _) == (other as *const _)\n-        (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n+        ptr::eq(self, other)\n     }\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n@@ -678,7 +677,7 @@ impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n impl<T: PartialEq> PartialEq for Slice<T> {\n     #[inline]\n     fn eq(&self, other: &Slice<T>) -> bool {\n-        (self as *const _) == (other as *const _)\n+        ptr::eq(self, other)\n     }\n }\n impl<T: Eq> Eq for Slice<T> {}\n@@ -1730,7 +1729,7 @@ impl Ord for AdtDef {\n impl PartialEq for AdtDef {\n     // AdtDef are always interned and this is part of TyS equality\n     #[inline]\n-    fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n+    fn eq(&self, other: &Self) -> bool { ptr::eq(self, other) }\n }\n \n impl Eq for AdtDef {}"}, {"sha": "56a8c13a8d3b80864e2e19c29f5767d51f9b1518", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -20,7 +20,7 @@ use ty::query::plumbing::CycleError;\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n use std::process;\n-use std::fmt;\n+use std::{fmt, ptr};\n use std::collections::HashSet;\n #[cfg(parallel_queries)]\n use {\n@@ -124,7 +124,7 @@ impl<'tcx> QueryJob<'tcx> {\n         while let Some(job) = current_job {\n             cycle.insert(0, job.info.clone());\n \n-            if &*job as *const _ == self as *const _ {\n+            if ptr::eq(&*job, self) {\n                 // This is the end of the cycle\n                 // The span entry we included was for the usage\n                 // of the cycle itself, and not part of the cycle"}, {"sha": "ef0d57c7b7ce7a6bc7b6a8b82232892a84ee0b3c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -56,29 +56,30 @@ extern crate rustc_cratesio_shim;\n \n pub use rustc_serialize::hex::ToHex;\n \n-pub mod array_vec;\n pub mod accumulate_vec;\n-pub mod small_vec;\n+pub mod array_vec;\n pub mod base_n;\n pub mod bitslice;\n pub mod bitvec;\n+pub mod flock;\n+pub mod fx;\n+pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n+pub mod owning_ref;\n+pub mod ptr_key;\n pub mod sip128;\n+pub mod small_vec;\n pub mod snapshot_map;\n pub use ena::snapshot_vec;\n+pub mod sorted_map;\n pub mod stable_hasher;\n-pub mod transitive_relation;\n-pub use ena::unify;\n-pub mod fx;\n-pub mod tuple_slice;\n-pub mod graph;\n-pub mod flock;\n pub mod sync;\n-pub mod owning_ref;\n pub mod tiny_list;\n-pub mod sorted_map;\n+pub mod transitive_relation;\n+pub mod tuple_slice;\n+pub use ena::unify;\n pub mod work_queue;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "6835dab38df0a3159a63ceb28d55fd12815accb5", "filename": "src/librustc_data_structures/ptr_key.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_data_structures%2Fptr_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_data_structures%2Fptr_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fptr_key.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{hash, ptr};\n+use std::ops::Deref;\n+\n+/// A wrapper around reference that compares and hashes like a pointer.\n+/// Can be used as a key in sets/maps indexed by pointers to avoid `unsafe`.\n+#[derive(Debug)]\n+pub struct PtrKey<'a, T: 'a>(pub &'a T);\n+\n+impl<'a, T> Clone for PtrKey<'a, T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<'a, T> Copy for PtrKey<'a, T> {}\n+\n+impl<'a, T> PartialEq for PtrKey<'a, T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        ptr::eq(self.0, rhs.0)\n+    }\n+}\n+\n+impl<'a, T> Eq for PtrKey<'a, T> {}\n+\n+impl<'a, T> hash::Hash for PtrKey<'a, T> {\n+    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n+        (self.0 as *const T).hash(hasher)\n+    }\n+}\n+\n+impl<'a, T> Deref for PtrKey<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}"}, {"sha": "da2847dc557930b5d8c12528f16101563112ce3b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -651,7 +651,7 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.global_macros.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.macro_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n@@ -704,8 +704,7 @@ impl<'a> Resolver<'a> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS,\n-                                                          false, false, span);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, span);\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);"}, {"sha": "9fe25aaa6c01f8af30ace9559b5ddac675189e5c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -1393,7 +1393,7 @@ pub struct Resolver<'a> {\n \n     crate_loader: &'a mut dyn CrateLoader,\n     macro_names: FxHashSet<Ident>,\n-    global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    macro_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     lexical_macro_resolutions: Vec<(Ident, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n@@ -1715,7 +1715,7 @@ impl<'a> Resolver<'a> {\n \n             crate_loader,\n             macro_names: FxHashSet(),\n-            global_macros: FxHashMap(),\n+            macro_prelude: FxHashMap(),\n             all_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             macro_map: FxHashMap(),\n@@ -2002,7 +2002,6 @@ impl<'a> Resolver<'a> {\n                                module: Module<'a>,\n                                mut ident: Ident,\n                                ns: Namespace,\n-                               ignore_unresolved_invocations: bool,\n                                record_used: bool,\n                                span: Span)\n                                -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -2012,7 +2011,7 @@ impl<'a> Resolver<'a> {\n             self.current_module = self.macro_def_scope(def);\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n-            module, ident, ns, ignore_unresolved_invocations, record_used, span,\n+            module, ident, ns, false, record_used, span,\n         );\n         self.current_module = orig_current_module;\n         result\n@@ -2518,7 +2517,7 @@ impl<'a> Resolver<'a> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, false, span).is_err() {\n+            if self.resolve_ident_in_module(module, ident, ns, false, span).is_err() {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n                 resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n             }\n@@ -3225,7 +3224,7 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_global = self.global_macros.get(&path[0].name).cloned()\n+        let is_global = self.macro_prelude.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n         if primary_ns != MacroNS && (is_global ||\n                                      self.macro_names.contains(&path[0].modern())) {\n@@ -3468,7 +3467,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n@@ -3762,7 +3761,7 @@ impl<'a> Resolver<'a> {\n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n             if let Ok(binding) =\n-                    self.resolve_ident_in_module(module, ident, ns, false, false, module.span) {\n+                    self.resolve_ident_in_module(module, ident, ns, false, module.span) {\n                 let def = binding.def();\n                 if filter_fn(def) {\n                     return Some(if self.has_self.contains(&def.def_id()) {\n@@ -4075,7 +4074,7 @@ impl<'a> Resolver<'a> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, false, module.span).is_ok() {\n+            if self.resolve_ident_in_module(module, ident, ns, false, module.span).is_ok() {\n                 let def_id = module.def_id().unwrap();\n                 found_traits.push(TraitCandidate { def_id: def_id, import_id: None });\n             }"}, {"sha": "0ad652b4710ce7df95b7c954655e548742cf66f1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -220,7 +220,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.global_macros.insert(ident.name, binding);\n+        self.macro_prelude.insert(ident.name, binding);\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -238,7 +238,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.global_macros.get(&name).cloned() {\n+            match self.macro_prelude.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -274,7 +274,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     }\n                     let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.global_macros.contains_key(&legacy_name) {\n+                    if !self.macro_prelude.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -565,7 +565,7 @@ impl<'a> Resolver<'a> {\n                     module, ident, ns, true, record_used, path_span,\n                 ).map(MacroBinding::Modern)\n             } else {\n-                self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n+                self.macro_prelude.get(&ident.name).cloned().ok_or(determinacy)\n                     .map(MacroBinding::Global)\n             };\n             self.current_module = orig_current_module;\n@@ -588,8 +588,7 @@ impl<'a> Resolver<'a> {\n                             return potential_illegal_shadower;\n                         }\n                     }\n-                    if binding.expansion != Mark::root() ||\n-                       (binding.is_glob_import() && module.unwrap().def().is_some()) {\n+                    if binding.is_glob_import() || binding.expansion != Mark::root() {\n                         potential_illegal_shadower = result;\n                     } else {\n                         return result;\n@@ -652,7 +651,7 @@ impl<'a> Resolver<'a> {\n \n         let binding = if let Some(binding) = binding {\n             MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.global_macros.get(&ident.name).cloned() {\n+        } else if let Some(binding) = self.macro_prelude.get(&ident.name).cloned() {\n             if !self.use_extern_macros {\n                 self.record_use(ident, MacroNS, binding, DUMMY_SP);\n             }\n@@ -762,8 +761,8 @@ impl<'a> Resolver<'a> {\n         // Then check global macros.\n         }.or_else(|| {\n             // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let global_macros = self.global_macros.clone();\n-            let names = global_macros.iter().filter_map(|(name, binding)| {\n+            let macro_prelude = self.macro_prelude.clone();\n+            let names = macro_prelude.iter().filter_map(|(name, binding)| {\n                 if binding.get_macro(self).kind() == kind {\n                     Some(name)\n                 } else {"}, {"sha": "50eb89be6901133be930ac4389916c79427bf3c3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 70, "deletions": 123, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -17,6 +17,7 @@ use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n+use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n use rustc::lint::builtin::{DUPLICATE_MACRO_EXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE};\n@@ -104,67 +105,20 @@ impl<'a> ImportDirective<'a> {\n #[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n-    /// The single imports that define the name in the namespace.\n-    single_imports: SingleImports<'a>,\n+    /// Single imports that may define the name in the namespace.\n+    /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n+    single_imports: FxHashSet<PtrKey<'a, ImportDirective<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    shadows_glob: Option<&'a NameBinding<'a>>,\n-}\n-\n-#[derive(Clone, Debug)]\n-enum SingleImports<'a> {\n-    /// No single imports can define the name in the namespace.\n-    None,\n-    /// Only the given single import can define the name in the namespace.\n-    MaybeOne(&'a ImportDirective<'a>),\n-    /// Only one of these two single imports can define the name in the namespace.\n-    MaybeTwo(&'a ImportDirective<'a>, &'a ImportDirective<'a>),\n-    /// At least one single import will define the name in the namespace.\n-    AtLeastOne,\n-}\n-\n-impl<'a> Default for SingleImports<'a> {\n-    /// Creates a `SingleImports<'a>` of None type.\n-    fn default() -> Self {\n-        SingleImports::None\n-    }\n-}\n-\n-impl<'a> SingleImports<'a> {\n-    fn add_directive(&mut self, directive: &'a ImportDirective<'a>, use_extern_macros: bool) {\n-        match *self {\n-            SingleImports::None => *self = SingleImports::MaybeOne(directive),\n-            SingleImports::MaybeOne(directive_one) => *self = if use_extern_macros {\n-                SingleImports::MaybeTwo(directive_one, directive)\n-            } else {\n-                SingleImports::AtLeastOne\n-            },\n-            // If three single imports can define the name in the namespace, we can assume that at\n-            // least one of them will define it since otherwise we'd get duplicate errors in one of\n-            // other namespaces.\n-            SingleImports::MaybeTwo(..) => *self = SingleImports::AtLeastOne,\n-            SingleImports::AtLeastOne => {}\n-        };\n-    }\n-\n-    fn directive_failed(&mut self, dir: &'a ImportDirective<'a>) {\n-        match *self {\n-            SingleImports::None => unreachable!(),\n-            SingleImports::MaybeOne(_) => *self = SingleImports::None,\n-            SingleImports::MaybeTwo(dir1, dir2) =>\n-                *self = SingleImports::MaybeOne(if ptr::eq(dir1, dir) { dir1 } else { dir2 }),\n-            SingleImports::AtLeastOne => {}\n-        }\n-    }\n+    shadowed_glob: Option<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n     // Returns the binding for the name if it is known or None if it not known.\n     fn binding(&self) -> Option<&'a NameBinding<'a>> {\n-        self.binding.and_then(|binding| match self.single_imports {\n-            SingleImports::None => Some(binding),\n-            _ if !binding.is_glob_import() => Some(binding),\n-            _ => None, // The binding could be shadowed by a single import, so it is not known.\n+        self.binding.and_then(|binding| {\n+            if !binding.is_glob_import() ||\n+               self.single_imports.is_empty() { Some(binding) } else { None }\n         })\n     }\n }\n@@ -177,7 +131,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n+    /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n     pub fn resolve_ident_in_module_unadjusted(&mut self,\n                                               module: Module<'a>,\n                                               ident: Ident,\n@@ -194,7 +148,7 @@ impl<'a> Resolver<'a> {\n \n         if record_used {\n             if let Some(binding) = resolution.binding {\n-                if let Some(shadowed_glob) = resolution.shadows_glob {\n+                if let Some(shadowed_glob) = resolution.shadowed_glob {\n                     let name = ident.name;\n                     // Forbid expanded shadowing to avoid time travel.\n                     if restricted_shadowing &&\n@@ -227,81 +181,72 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err(Determined) }\n         };\n \n-        // Items and single imports are not shadowable.\n+        // Items and single imports are not shadowable, if we have one, then it's determined.\n         if let Some(binding) = resolution.binding {\n             if !binding.is_glob_import() {\n                 return check_usable(self, binding);\n             }\n         }\n \n-        // Check if a single import can still define the name.\n-        let resolve_single_import = |this: &mut Self, directive: &'a ImportDirective<'a>| {\n-            let module = match directive.imported_module.get() {\n-                Some(module) => module,\n-                None => return false,\n-            };\n-            let ident = match directive.subclass {\n+        // --- From now on we either have a glob resolution or no resolution. ---\n+\n+        // Check if one of single imports can still define the name,\n+        // if it can then our result is not determined and can be invalidated.\n+        for single_import in &resolution.single_imports {\n+            if !self.is_accessible(single_import.vis.get()) {\n+                continue;\n+            }\n+            let module = unwrap_or!(single_import.imported_module.get(), return Err(Undetermined));\n+            let ident = match single_import.subclass {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match this.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n-                Err(Determined) => {}\n-                _ => return false,\n-            }\n-            true\n-        };\n-        match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Err(Undetermined),\n-            SingleImports::MaybeOne(directive) => {\n-                let accessible = self.is_accessible(directive.vis.get());\n-                if accessible {\n-                    if !resolve_single_import(self, directive) {\n-                        return Err(Undetermined)\n-                    }\n-                }\n-            }\n-            SingleImports::MaybeTwo(directive1, directive2) => {\n-                let accessible1 = self.is_accessible(directive1.vis.get());\n-                let accessible2 = self.is_accessible(directive2.vis.get());\n-                if accessible1 && accessible2 {\n-                    if !resolve_single_import(self, directive1) &&\n-                       !resolve_single_import(self, directive2) {\n-                        return Err(Undetermined)\n-                    }\n-                } else if accessible1 {\n-                    if !resolve_single_import(self, directive1) {\n-                        return Err(Undetermined)\n-                    }\n-                } else {\n-                    if !resolve_single_import(self, directive2) {\n-                        return Err(Undetermined)\n-                    }\n-                }\n+            match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n+                Err(Determined) => continue,\n+                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n-            SingleImports::None => {},\n         }\n \n-        let no_unresolved_invocations =\n-            restricted_shadowing || module.unresolved_invocations.borrow().is_empty();\n-        match resolution.binding {\n-            // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n-            Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n-                return check_usable(self, binding),\n-            None if no_unresolved_invocations => {}\n-            _ => return Err(Undetermined),\n+        // So we have a resolution that's from a glob import. This resolution is determined\n+        // if it cannot be shadowed by some new item/import expanded from a macro.\n+        // This happens either if there are no unexpanded macros, or expanded names cannot\n+        // shadow globs (that happens in macro namespace or with restricted shadowing).\n+        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        if let Some(binding) = resolution.binding {\n+            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n+                return check_usable(self, binding);\n+            } else {\n+                return Err(Undetermined);\n+            }\n         }\n \n-        // Check if the globs are determined\n-        if restricted_shadowing && module.def().is_some() {\n+        // --- From now on we have no resolution. ---\n+\n+        // Now we are in situation when new item/import can appear only from a glob or a macro\n+        // expansion. With restricted shadowing names from globs and macro expansions cannot\n+        // shadow names from outer scopes, so we can freely fallback from module search to search\n+        // in outer scopes. To continue search in outer scopes we have to lie a bit and return\n+        // `Determined` to `resolve_lexical_macro_path_segment` even if the correct answer\n+        // for in-module resolution could be `Undetermined`.\n+        if restricted_shadowing {\n             return Err(Determined);\n         }\n-        for directive in module.globs.borrow().iter() {\n-            if !self.is_accessible(directive.vis.get()) {\n+\n+        // Check if one of unexpanded macros can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        if unexpanded_macros {\n+            return Err(Undetermined);\n+        }\n+\n+        // Check if one of glob imports can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        for glob_import in module.globs.borrow().iter() {\n+            if !self.is_accessible(glob_import.vis.get()) {\n                 continue\n             }\n-            let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n+            let module = unwrap_or!(glob_import.imported_module.get(), return Err(Undetermined));\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.span.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n+            match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -310,11 +255,13 @@ impl<'a> Resolver<'a> {\n                 module, ident, ns, false, false, path_span,\n             );\n             self.current_module = orig_current_module;\n-            if let Err(Undetermined) = result {\n-                return Err(Undetermined);\n+            match result {\n+                Err(Determined) => continue,\n+                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n \n+        // No resolution and no one else can define the name - determinate error.\n         Err(Determined)\n     }\n \n@@ -348,7 +295,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, type_ns_only, .. } => {\n                 self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.add_directive(directive, this.use_extern_macros);\n+                    resolution.single_imports.insert(PtrKey(directive));\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -401,7 +348,7 @@ impl<'a> Resolver<'a> {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n                        !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n-                        resolution.shadows_glob = Some(binding);\n+                        resolution.shadowed_glob = Some(binding);\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n@@ -414,7 +361,7 @@ impl<'a> Resolver<'a> {\n                         resolution.binding = Some(this.ambiguity(binding, old_binding));\n                     } else {\n                         resolution.binding = Some(binding);\n-                        resolution.shadows_glob = Some(old_binding);\n+                        resolution.shadowed_glob = Some(old_binding);\n                     }\n                 } else {\n                     return Err(old_binding);\n@@ -455,7 +402,7 @@ impl<'a> Resolver<'a> {\n                 _ if old_binding.is_some() => return t,\n                 None => return t,\n                 Some(binding) => match old_binding {\n-                    Some(old_binding) if old_binding as *const _ == binding as *const _ => return t,\n+                    Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n                     _ => (binding, t),\n                 }\n             }\n@@ -630,7 +577,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                                             source,\n                                                             ns,\n                                                             false,\n-                                                            false,\n                                                             directive.span));\n             } else {\n                 return\n@@ -641,7 +587,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.directive_failed(directive)\n+                        resolution.single_imports.remove(&PtrKey(directive));\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n@@ -803,7 +749,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, false, true, span) {\n+                match this.resolve_ident_in_module(module, ident, ns, true, span) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n@@ -827,7 +773,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 _ => Some(&i.name),\n                             }\n                         },\n-                        NameResolution { single_imports: SingleImports::None, .. } => None,\n+                        NameResolution { ref single_imports, .. }\n+                            if single_imports.is_empty() => None,\n                         _ => Some(&i.name),\n                     }\n                 });\n@@ -973,7 +920,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n         let mut exported_macro_names = FxHashMap();\n-        if module as *const _ == self.graph_root as *const _ {\n+        if ptr::eq(module, self.graph_root) {\n             let macro_exports = mem::replace(&mut self.macro_exports, Vec::new());\n             for export in macro_exports.into_iter().rev() {\n                 if let Some(later_span) = exported_macro_names.insert(export.ident.modern(),"}, {"sha": "e4f55137e660fbb2561e9f1cc88a137b219c38ff", "filename": "src/test/ui/imports/glob-shadowing.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+mod m {\n+    pub macro env($e: expr) { $e }\n+    pub macro fenv() { 0 }\n+}\n+\n+mod glob_in_normal_module {\n+    use m::*;\n+    fn check() {\n+        let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n+    }\n+}\n+\n+mod glob_in_block_module {\n+    fn block() {\n+        use m::*;\n+        fn check() {\n+            let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n+        }\n+    }\n+}\n+\n+mod glob_shadows_item {\n+    pub macro fenv($e: expr) { $e }\n+    fn block() {\n+        use m::*;\n+        fn check() {\n+            let x = fenv!(); //~ ERROR `fenv` is ambiguous\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7f61cd6c76d6ad3c484bb494f21908315e986e22", "filename": "src/test/ui/imports/glob-shadowing.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -0,0 +1,49 @@\n+error[E0659]: `env` is ambiguous\n+  --> $DIR/glob-shadowing.rs:21:17\n+   |\n+LL |         let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n+   |                 ^^^\n+   |\n+note: `env` could refer to the name imported here\n+  --> $DIR/glob-shadowing.rs:19:9\n+   |\n+LL |     use m::*;\n+   |         ^^^^\n+   = note: `env` is also a builtin macro\n+   = note: consider adding an explicit import of `env` to disambiguate\n+\n+error[E0659]: `env` is ambiguous\n+  --> $DIR/glob-shadowing.rs:29:21\n+   |\n+LL |             let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n+   |                     ^^^\n+   |\n+note: `env` could refer to the name imported here\n+  --> $DIR/glob-shadowing.rs:27:13\n+   |\n+LL |         use m::*;\n+   |             ^^^^\n+   = note: `env` is also a builtin macro\n+   = note: consider adding an explicit import of `env` to disambiguate\n+\n+error[E0659]: `fenv` is ambiguous\n+  --> $DIR/glob-shadowing.rs:39:21\n+   |\n+LL |             let x = fenv!(); //~ ERROR `fenv` is ambiguous\n+   |                     ^^^^\n+   |\n+note: `fenv` could refer to the name imported here\n+  --> $DIR/glob-shadowing.rs:37:13\n+   |\n+LL |         use m::*;\n+   |             ^^^^\n+note: `fenv` could also refer to the name defined here\n+  --> $DIR/glob-shadowing.rs:35:5\n+   |\n+LL |     pub macro fenv($e: expr) { $e }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: consider adding an explicit import of `fenv` to disambiguate\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}]}