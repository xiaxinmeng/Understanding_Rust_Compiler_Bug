{"sha": "f4d294f32c570a8b5494e288eae8652bc2372bb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZDI5NGYzMmM1NzBhOGI1NDk0ZTI4OGVhZTg2NTJiYzIzNzJiYjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-08T22:57:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-08T22:57:51Z"}, "message": "Simplify event processing", "tree": {"sha": "ce528572ac839678a2aa975a542067315544f7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce528572ac839678a2aa975a542067315544f7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4d294f32c570a8b5494e288eae8652bc2372bb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d294f32c570a8b5494e288eae8652bc2372bb9", "html_url": "https://github.com/rust-lang/rust/commit/f4d294f32c570a8b5494e288eae8652bc2372bb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4d294f32c570a8b5494e288eae8652bc2372bb9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f6c442a3f2f660803f598d70f3f69b469637829", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6c442a3f2f660803f598d70f3f69b469637829", "html_url": "https://github.com/rust-lang/rust/commit/1f6c442a3f2f660803f598d70f3f69b469637829"}], "stats": {"total": 54, "additions": 25, "deletions": 29}, "files": [{"sha": "9fd56b996dc93c0dfb0f2fa5d99e94b32d676f0f", "filename": "src/parser_impl/event.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f4d294f32c570a8b5494e288eae8652bc2372bb9/src%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d294f32c570a8b5494e288eae8652bc2372bb9/src%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser_impl%2Fevent.rs?ref=f4d294f32c570a8b5494e288eae8652bc2372bb9", "patch": "@@ -7,6 +7,7 @@\n //! tree builder: the parser produces a stream of events like\n //! `start node`, `finish node`, and `FileBuilder` converts\n //! this stream to a real tree.\n+use std::mem;\n use {\n     lexer::Token,\n     parser_impl::Sink,\n@@ -77,8 +78,11 @@ pub(crate) enum Event {\n     },\n }\n \n-pub(super) fn process<'a, S: Sink<'a>>(builder: &mut S, tokens: &[Token], events: Vec<Event>) {\n-    let mut next_tok_idx = 0;\n+\n+pub(super) fn process<'a, S: Sink<'a>>(builder: &mut S, tokens: &[Token], mut events: Vec<Event>) {\n+    fn tombstone() -> Event {\n+        Event::Start { kind: TOMBSTONE, forward_parent: None }\n+    }\n     let eat_ws = |idx: &mut usize, builder: &mut S| {\n         while let Some(token) = tokens.get(*idx) {\n             if !token.kind.is_trivia() {\n@@ -89,58 +93,50 @@ pub(super) fn process<'a, S: Sink<'a>>(builder: &mut S, tokens: &[Token], events\n         }\n     };\n \n+    let events: &mut [Event] = &mut events;\n     let mut depth = 0;\n-    let mut holes = Vec::new();\n     let mut forward_parents = Vec::new();\n-\n-    for (i, event) in events.iter().enumerate() {\n-        if holes.last() == Some(&i) {\n-            holes.pop();\n-            continue;\n-        }\n-\n-        match event {\n-            &Event::Start {\n+    let mut next_tok_idx = 0;\n+    for i in 0..events.len() {\n+        match mem::replace(&mut events[i], tombstone()) {\n+            Event::Start {\n                 kind: TOMBSTONE, ..\n             } => (),\n \n-            &Event::Start { .. } => {\n-                forward_parents.clear();\n+            Event::Start { kind, forward_parent } => {\n+                forward_parents.push(kind);\n                 let mut idx = i;\n-                loop {\n-                    let (kind, fwd) = match events[idx] {\n+                let mut fp = forward_parent;\n+                while let Some(fwd) = fp {\n+                    idx += fwd as usize;\n+                    fp = match mem::replace(&mut events[idx], tombstone()) {\n                         Event::Start {\n                             kind,\n                             forward_parent,\n-                        } => (kind, forward_parent),\n+                        } => {\n+                            forward_parents.push(kind);\n+                            forward_parent\n+                        },\n                         _ => unreachable!(),\n                     };\n-                    forward_parents.push((idx, kind));\n-                    if let Some(fwd) = fwd {\n-                        idx += fwd as usize;\n-                    } else {\n-                        break;\n-                    }\n                 }\n-                for &(idx, kind) in forward_parents.iter().into_iter().rev() {\n+                for kind in forward_parents.drain(..).rev() {\n                     if depth > 0 {\n                         eat_ws(&mut next_tok_idx, builder);\n                     }\n                     depth += 1;\n                     builder.start_internal(kind);\n-                    holes.push(idx);\n                 }\n-                holes.pop();\n             }\n-            &Event::Finish => {\n+            Event::Finish => {\n                 depth -= 1;\n                 if depth == 0 {\n                     eat_ws(&mut next_tok_idx, builder);\n                 }\n \n                 builder.finish_internal();\n             }\n-            &Event::Token {\n+            Event::Token {\n                 kind,\n                 mut n_raw_tokens,\n             } => {\n@@ -152,7 +148,7 @@ pub(super) fn process<'a, S: Sink<'a>>(builder: &mut S, tokens: &[Token], events\n                 }\n                 builder.leaf(kind, len);\n             }\n-            &Event::Error { ref msg } => builder.error(msg.clone()),\n+            Event::Error { msg } => builder.error(msg),\n         }\n     }\n }"}]}