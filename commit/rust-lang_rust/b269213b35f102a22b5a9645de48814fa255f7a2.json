{"sha": "b269213b35f102a22b5a9645de48814fa255f7a2", "node_id": "C_kwDOAAsO6NoAKGIyNjkyMTNiMzVmMTAyYTIyYjVhOTY0NWRlNDg4MTRmYTI1NWY3YTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-02T21:16:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-02T21:16:12Z"}, "message": "Rollup merge of #91387 - graydon:E0038-clarification, r=wesleywiser\n\nClarify and tidy up explanation of E0038\n\nI ran into E0038 (specifically the `Self:Sized` constraint on object-safety) the other day and it seemed to me that the explanations I found floating around the internet were a bit .. wrong. Like they didn't make sense. And then I went and checked the official explanation here and it didn't make sense either.\n\nAs far as I can tell (reading through the history of the RFCs), two totally different aspects of object-safety have got tangled up in much of the writing on the subject:\n  - Object-safety related to \"not even theoretically possible\" issues. This includes things like \"methods that take or return Self by value\", which obviously will never work for an unsized type in a world with fixed-size stack frames (and it'd be an opaque type anyways, which, ugh). This sort of thing was originally decided method-by-method, with non-object-safe methods stripped from objects; but in [RFC 0255](https://rust-lang.github.io/rfcs/0255-object-safety.html) this sort of per-impossible-method reasoning was made into a per-trait safety property (with the escape hatch left in where users could mark methods `where Self:Sized` to have them stripped before the trait's object safety is considered).\n  - Object-safety related to \"totally possible but ergonomically a little awkward\" issues. Specifically in a trait with `Trait:Sized`, there's no a priori reason why this constraint makes the trait impossible to make into an object -- imagine it had nothing but harmless `&self`-taking methods. No problem! Who cares if the Trait requires its implementing types to be sized? As far as I can tell reading the history here, in both RFC 0255 and then later in [RFC 0546](https://rust-lang.github.io/rfcs/0546-Self-not-sized-by-default.html) it seems that the motivation for making `Trait:Sized` be non-object-safe has _nothing to do_ with the impossibility of making objects out of such types, and everything to do with enabling \"[a trait object SomeTrait to implement the trait SomeTrait](https://rust-lang.github.io/rfcs/0546-Self-not-sized-by-default.html#motivation)\". That is, since `dyn Trait` is unsized, if `Trait:Sized` then you can never have the automatic (and reasonable) ergonomic implicit `impl Trait for dyn Trait`. And the authors of that RFC really wanted that automatic implicit implementation of `Trait` for `dyn Trait`. So they just defined `Trait:Sized` as non-object safe -- no `dyn Trait` can ever exist that the compiler can't synthesize such an impl for. Well enough!\n\nHowever, I noticed in my reading-and-reconstruction that lots of documentation on the internet, including forum and Q&A site answers and (most worrying) the compiler explanation all kinda grasp at something like the first (\"not theoretically possible\") explanation, and fail to mention the second (\"just an ergonomic constraint\") explanation. So I figured I'd clean up the docs to clarify, maybe confuse the next person less (unless of course I'm misreading the history here and misunderstanding motives -- please let me know if so!)\n\nWhile here I also did some cleanups:\n\n  - Rewrote the preamble, trying to help the user get a little better oriented (I found the existing preamble a bit scattered).\n  - Modernized notation (using `dyn Trait`)\n  - Changed the section headings to all be written with the same logical sense: to all be written as \"conditions that violate object safety\" rather than a mix of that and the negated form \"conditions that must not happen in order to ensure object safety\".\n\nI think there's a fair bit more to clean up in this doc -- the later sections get a bit rambly and I suspect there should be a completely separated-out section covering the `where Self:Sized` escape hatch for instructing the compiler to \"do the old thing\" and strip methods off traits when turning them into objects (it's a bit buried as a digression in the individual sub-error sections). But I did what I had time for now.", "tree": {"sha": "edcb77944232d11c5f484ca5fbed824cae0737d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edcb77944232d11c5f484ca5fbed824cae0737d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b269213b35f102a22b5a9645de48814fa255f7a2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhqTecCRBK7hj4Ov3rIwAA1WwIAFdA7/oDxXGPF20foa8gcVcf\n58eIoeppKuu2qntom7//X5u7TgJVjxoUNuBf2OWQ8rUJz6kTBVlsCUeDbDHZ/9tc\niX6aeqCll1x06emusB4y3G0zKSiMJMe8Lr4nzN9+ErJ3YmWUVgVWHU5mQgdjgJE7\nTEHNIEQCJa2CBeqGZ0xZ8AXO7uAS47dz4CcxitoN/0IP+szPGT9499AVWJpV2Yux\nv1FfOUReg2YkY4Yxy/vjY2vCAnn+PxNF/E4r619HElCBOiB3i3akjmXIGhYQfJRw\nXKTu+Xy8tlem+m7Lponk5nPScpTpSb/yfElW/jQ8xOsa/qGSDbEz6jRttv1/SbE=\n=KrgA\n-----END PGP SIGNATURE-----\n", "payload": "tree edcb77944232d11c5f484ca5fbed824cae0737d4\nparent 7483211ed52911e539771067a4436d0693552cdc\nparent 7907fa8ec4cd4e7b60687e3f06b12e2b8fff6a04\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638479772 +0100\ncommitter GitHub <noreply@github.com> 1638479772 +0100\n\nRollup merge of #91387 - graydon:E0038-clarification, r=wesleywiser\n\nClarify and tidy up explanation of E0038\n\nI ran into E0038 (specifically the `Self:Sized` constraint on object-safety) the other day and it seemed to me that the explanations I found floating around the internet were a bit .. wrong. Like they didn't make sense. And then I went and checked the official explanation here and it didn't make sense either.\n\nAs far as I can tell (reading through the history of the RFCs), two totally different aspects of object-safety have got tangled up in much of the writing on the subject:\n  - Object-safety related to \"not even theoretically possible\" issues. This includes things like \"methods that take or return Self by value\", which obviously will never work for an unsized type in a world with fixed-size stack frames (and it'd be an opaque type anyways, which, ugh). This sort of thing was originally decided method-by-method, with non-object-safe methods stripped from objects; but in [RFC 0255](https://rust-lang.github.io/rfcs/0255-object-safety.html) this sort of per-impossible-method reasoning was made into a per-trait safety property (with the escape hatch left in where users could mark methods `where Self:Sized` to have them stripped before the trait's object safety is considered).\n  - Object-safety related to \"totally possible but ergonomically a little awkward\" issues. Specifically in a trait with `Trait:Sized`, there's no a priori reason why this constraint makes the trait impossible to make into an object -- imagine it had nothing but harmless `&self`-taking methods. No problem! Who cares if the Trait requires its implementing types to be sized? As far as I can tell reading the history here, in both RFC 0255 and then later in [RFC 0546](https://rust-lang.github.io/rfcs/0546-Self-not-sized-by-default.html) it seems that the motivation for making `Trait:Sized` be non-object-safe has _nothing to do_ with the impossibility of making objects out of such types, and everything to do with enabling \"[a trait object SomeTrait to implement the trait SomeTrait](https://rust-lang.github.io/rfcs/0546-Self-not-sized-by-default.html#motivation)\". That is, since `dyn Trait` is unsized, if `Trait:Sized` then you can never have the automatic (and reasonable) ergonomic implicit `impl Trait for dyn Trait`. And the authors of that RFC really wanted that automatic implicit implementation of `Trait` for `dyn Trait`. So they just defined `Trait:Sized` as non-object safe -- no `dyn Trait` can ever exist that the compiler can't synthesize such an impl for. Well enough!\n\nHowever, I noticed in my reading-and-reconstruction that lots of documentation on the internet, including forum and Q&A site answers and (most worrying) the compiler explanation all kinda grasp at something like the first (\"not theoretically possible\") explanation, and fail to mention the second (\"just an ergonomic constraint\") explanation. So I figured I'd clean up the docs to clarify, maybe confuse the next person less (unless of course I'm misreading the history here and misunderstanding motives -- please let me know if so!)\n\nWhile here I also did some cleanups:\n\n  - Rewrote the preamble, trying to help the user get a little better oriented (I found the existing preamble a bit scattered).\n  - Modernized notation (using `dyn Trait`)\n  - Changed the section headings to all be written with the same logical sense: to all be written as \"conditions that violate object safety\" rather than a mix of that and the negated form \"conditions that must not happen in order to ensure object safety\".\n\nI think there's a fair bit more to clean up in this doc -- the later sections get a bit rambly and I suspect there should be a completely separated-out section covering the `where Self:Sized` escape hatch for instructing the compiler to \"do the old thing\" and strip methods off traits when turning them into objects (it's a bit buried as a digression in the individual sub-error sections). But I did what I had time for now.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b269213b35f102a22b5a9645de48814fa255f7a2", "html_url": "https://github.com/rust-lang/rust/commit/b269213b35f102a22b5a9645de48814fa255f7a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b269213b35f102a22b5a9645de48814fa255f7a2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7483211ed52911e539771067a4436d0693552cdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7483211ed52911e539771067a4436d0693552cdc", "html_url": "https://github.com/rust-lang/rust/commit/7483211ed52911e539771067a4436d0693552cdc"}, {"sha": "7907fa8ec4cd4e7b60687e3f06b12e2b8fff6a04", "url": "https://api.github.com/repos/rust-lang/rust/commits/7907fa8ec4cd4e7b60687e3f06b12e2b8fff6a04", "html_url": "https://github.com/rust-lang/rust/commit/7907fa8ec4cd4e7b60687e3f06b12e2b8fff6a04"}], "stats": {"total": 97, "additions": 65, "deletions": 32}, "files": [{"sha": "ca2eaa54057fabb1f561ebd9631fb9c3f7cccbf1", "filename": "compiler/rustc_error_codes/src/error_codes/E0038.md", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b269213b35f102a22b5a9645de48814fa255f7a2/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/b269213b35f102a22b5a9645de48814fa255f7a2/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md?ref=b269213b35f102a22b5a9645de48814fa255f7a2", "patch": "@@ -1,34 +1,64 @@\n-Trait objects like `Box<Trait>` can only be constructed when certain\n-requirements are satisfied by the trait in question.\n-\n-Trait objects are a form of dynamic dispatch and use a dynamically sized type\n-for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n-type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n-pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n-(among other things) for dynamic dispatch. This design mandates some\n-restrictions on the types of traits that are allowed to be used in trait\n-objects, which are collectively termed as 'object safety' rules.\n-\n-Attempting to create a trait object for a non object-safe trait will trigger\n-this error.\n-\n-There are various rules:\n-\n-### The trait cannot require `Self: Sized`\n-\n-When `Trait` is treated as a type, the type does not implement the special\n-`Sized` trait, because the type does not have a known size at compile time and\n-can only be accessed behind a pointer. Thus, if we have a trait like the\n-following:\n+For any given trait `Trait` there may be a related _type_ called the _trait\n+object type_ which is typically written as `dyn Trait`. In earlier editions of\n+Rust, trait object types were written as plain `Trait` (just the name of the\n+trait, written in type positions) but this was a bit too confusing, so we now\n+write `dyn Trait`.\n+\n+Some traits are not allowed to be used as trait object types. The traits that\n+are allowed to be used as trait object types are called \"object-safe\" traits.\n+Attempting to use a trait object type for a trait that is not object-safe will\n+trigger error E0038.\n+\n+Two general aspects of trait object types give rise to the restrictions:\n+\n+  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n+     these types can only be accessed through pointers, such as `&dyn Trait` or\n+     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n+     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n+     with it, and different tait objects with the same trait object type may\n+     have different sizes.\n+\n+  2. The pointer used to access a trait object is paired with an extra pointer\n+     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n+     dispatch to the object's implementations of the trait's methods. There is a\n+     single such vtable for each trait implementation, but different trait\n+     objects with the same trait object type may point to vtables from different\n+     implementations.\n+\n+The specific conditions that violate object-safety follow, most of which relate\n+to missing size information and vtable polymorphism arising from these aspects.\n+\n+### The trait requires `Self: Sized`\n+\n+Traits that are declared as `Trait: Sized` or which otherwise inherit a\n+constraint of `Self:Sized` are not object-safe.\n+\n+The reasoning behind this is somewhat subtle. It derives from the fact that Rust\n+requires (and defines) that every trait object type `dyn Trait` automatically\n+implements `Trait`. Rust does this to simplify error reporting and ease\n+interoperation between static and dynamic polymorphism. For example, this code\n+works:\n \n ```\n-trait Foo where Self: Sized {\n+trait Trait {\n+}\n+\n+fn static_foo<T:Trait + ?Sized>(b: &T) {\n+}\n \n+fn dynamic_bar(a: &dyn Trait) {\n+    static_foo(a)\n }\n ```\n \n-We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n-`Self` would not be `Sized`.\n+This code works because `dyn Trait`, if it exists, always implements `Trait`.\n+\n+However as we know, any `dyn Trait` is also unsized, and so it can never\n+implement a sized trait like `Trait:Sized`. So, rather than allow an exception\n+to the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\n+such a `dyn Trait` from existing at all.\n+\n+Only unsized traits are considered object-safe.\n \n Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n@@ -67,7 +97,7 @@ trait Trait {\n     fn foo(&self) -> Self;\n }\n \n-fn call_foo(x: Box<Trait>) {\n+fn call_foo(x: Box<dyn Trait>) {\n     let y = x.foo(); // What type is y?\n     // ...\n }\n@@ -76,7 +106,8 @@ fn call_foo(x: Box<Trait>) {\n If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n on them to mark them as explicitly unavailable to trait objects. The\n functionality will still be available to all other implementers, including\n-`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\n+Trait>`).\n \n ```\n trait Trait {\n@@ -115,7 +146,9 @@ impl Trait for u8 {\n ```\n \n At compile time each implementation of `Trait` will produce a table containing\n-the various methods (and other items) related to the implementation.\n+the various methods (and other items) related to the implementation, which will\n+be used as the virtual method table for a `dyn Trait` object derived from that\n+implementation.\n \n This works fine, but when the method gains generic parameters, we can have a\n problem.\n@@ -174,7 +207,7 @@ Now, if we have the following code:\n # impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n # impl Trait for bool { fn foo<T>(&self, on: T) {} }\n # // etc.\n-fn call_foo(thing: Box<Trait>) {\n+fn call_foo(thing: Box<dyn Trait>) {\n     thing.foo(true); // this could be any one of the 8 types above\n     thing.foo(1);\n     thing.foo(\"hello\");\n@@ -200,7 +233,7 @@ trait Trait {\n ```\n \n If this is not an option, consider replacing the type parameter with another\n-trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\n number of types you intend to feed to this method is limited, consider manually\n listing out the methods of different types.\n \n@@ -226,7 +259,7 @@ trait Foo {\n }\n ```\n \n-### The trait cannot contain associated constants\n+### Trait contains associated constants\n \n Just like static functions, associated constants aren't stored on the method\n table. If the trait or any subtrait contain an associated constant, they cannot\n@@ -248,7 +281,7 @@ trait Foo {\n }\n ```\n \n-### The trait cannot use `Self` as a type parameter in the supertrait listing\n+### Trait uses `Self` as a type parameter in the supertrait listing\n \n This is similar to the second sub-error, but subtler. It happens in situations\n like the following:"}]}