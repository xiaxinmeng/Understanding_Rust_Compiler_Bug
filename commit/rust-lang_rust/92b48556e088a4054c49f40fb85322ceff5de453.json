{"sha": "92b48556e088a4054c49f40fb85322ceff5de453", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjQ4NTU2ZTA4OGE0MDU0YzQ5ZjQwZmI4NTMyMmNlZmY1ZGU0NTM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-01-14T05:12:39Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-01-14T05:12:39Z"}, "message": "syntax: Don't import the pp.rs enum variants into the namespace", "tree": {"sha": "44fcae76cb23a9fb27a7e42b0ef05e1a4ae5bc90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44fcae76cb23a9fb27a7e42b0ef05e1a4ae5bc90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b48556e088a4054c49f40fb85322ceff5de453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b48556e088a4054c49f40fb85322ceff5de453", "html_url": "https://github.com/rust-lang/rust/commit/92b48556e088a4054c49f40fb85322ceff5de453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b48556e088a4054c49f40fb85322ceff5de453/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "170c4399e614fe599c3d41306b3429ca8b3b68c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/170c4399e614fe599c3d41306b3429ca8b3b68c6", "html_url": "https://github.com/rust-lang/rust/commit/170c4399e614fe599c3d41306b3429ca8b3b68c6"}], "stats": {"total": 152, "additions": 82, "deletions": 70}, "files": [{"sha": "116158c2372c5543549e7526faa257d092679198", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 68, "deletions": 63, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/92b48556e088a4054c49f40fb85322ceff5de453/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b48556e088a4054c49f40fb85322ceff5de453/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=92b48556e088a4054c49f40fb85322ceff5de453", "patch": "@@ -59,10 +59,6 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n-pub use self::PrintStackBreak::*;\n-pub use self::Breaks::*;\n-pub use self::Token::*;\n-\n use std::io;\n use std::string;\n use std::iter::repeat;\n@@ -87,7 +83,7 @@ pub struct BeginToken {\n \n #[derive(Clone)]\n pub enum Token {\n-    String(string::String, int),\n+    String(String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -96,12 +92,15 @@ pub enum Token {\n \n impl Token {\n     pub fn is_eof(&self) -> bool {\n-        match *self { Eof => true, _ => false }\n+        match *self {\n+            Token::Eof => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_hardbreak_tok(&self) -> bool {\n         match *self {\n-            Break(BreakToken {\n+            Token::Break(BreakToken {\n                 offset: 0,\n                 blank_space: bs\n             }) if bs == SIZE_INFINITY =>\n@@ -112,22 +111,22 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> string::String {\n-    match t {\n-        String(s, len) => return format!(\"STR({},{})\", s, len),\n-        Break(_) => return \"BREAK\".to_string(),\n-        Begin(_) => return \"BEGIN\".to_string(),\n-        End => return \"END\".to_string(),\n-        Eof => return \"EOF\".to_string()\n+pub fn tok_str(token: &Token) -> String {\n+    match *token {\n+        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n+        Token::Break(_) => \"BREAK\".to_string(),\n+        Token::Begin(_) => \"BEGIN\".to_string(),\n+        Token::End => \"END\".to_string(),\n+        Token::Eof => \"EOF\".to_string()\n     }\n }\n \n-pub fn buf_str(toks: Vec<Token>,\n-               szs: Vec<int>,\n+pub fn buf_str(toks: &[Token],\n+               szs: &[int],\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> string::String {\n+               -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n@@ -140,7 +139,7 @@ pub fn buf_str(toks: Vec<Token>,\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone()))[]);\n+                           tok_str(&toks[i]))[]);\n         i += 1u;\n         i %= n;\n     }\n@@ -167,7 +166,7 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let token: Vec<Token> = repeat(Token::Eof).take(n).collect();\n     let size: Vec<int> = repeat(0i).take(n).collect();\n     let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n@@ -312,10 +311,10 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n+    pub fn pretty_print(&mut self, token: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n-        match t {\n-          Eof => {\n+        match token {\n+          Token::Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 let left = self.token[self.left].clone();\n@@ -325,7 +324,7 @@ impl Printer {\n             self.indent(0);\n             Ok(())\n           }\n-          Begin(b) => {\n+          Token::Begin(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -334,27 +333,27 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             if self.scan_stack_empty {\n                 debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n-                self.print(t, 0)\n+                self.print(token, 0)\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t;\n+                self.token[self.right] = token;\n                 self.size[self.right] = -1;\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n             }\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -366,21 +365,21 @@ impl Printer {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n-          String(ref s, len) => {\n+          Token::String(ref s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n                        *s, self.left, self.right);\n-                self.print(t.clone(), len)\n+                self.print(token.clone(), len)\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t.clone();\n+                self.token[self.right] = token.clone();\n                 self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream()\n@@ -456,8 +455,8 @@ impl Printer {\n         if l >= 0 {\n             let ret = self.print(x.clone(), l);\n             match x {\n-              Break(b) => self.left_total += b.blank_space,\n-              String(_, len) => {\n+              Token::Break(b) => self.left_total += b.blank_space,\n+              Token::String(_, len) => {\n                 assert_eq!(len, l); self.left_total += len;\n               }\n               _ => ()\n@@ -478,14 +477,14 @@ impl Printer {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             match self.token[x] {\n-                Begin(_) => {\n+                Token::Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n                         self.size[popped] = self.size[x] + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n-                End => {\n+                Token::End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n                     self.size[popped] = 1;\n@@ -520,7 +519,7 @@ impl Printer {\n         } else {\n             PrintStackElem {\n                 offset: 0,\n-                pbreak: Broken(Inconsistent)\n+                pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n         }\n     }\n@@ -531,56 +530,56 @@ impl Printer {\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, l: int) -> io::IoResult<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), l,\n+    pub fn print(&mut self, token: Token, l: int) -> io::IoResult<()> {\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n-        debug!(\"{}\", buf_str(self.token.clone(),\n-                             self.size.clone(),\n+        debug!(\"{}\", buf_str(&self.token[],\n+                             &self.size[],\n                              self.left,\n                              self.right,\n                              6));\n-        match x {\n-          Begin(b) => {\n+        match token {\n+          Token::Begin(b) => {\n             if l > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!(\"print Begin -> push broken block at col {}\", col);\n                 self.print_stack.push(PrintStackElem {\n                     offset: col,\n-                    pbreak: Broken(b.breaks)\n+                    pbreak: PrintStackBreak::Broken(b.breaks)\n                 });\n             } else {\n                 debug!(\"print Begin -> push fitting block\");\n                 self.print_stack.push(PrintStackElem {\n                     offset: 0,\n-                    pbreak: Fits\n+                    pbreak: PrintStackBreak::Fits\n                 });\n             }\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             let top = self.get_top();\n             match top.pbreak {\n-              Fits => {\n+              PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n                 Ok(())\n               }\n-              Broken(Consistent) => {\n+              PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n                 ret\n               }\n-              Broken(Inconsistent) => {\n+              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n@@ -597,14 +596,14 @@ impl Printer {\n               }\n             }\n           }\n-          String(s, len) => {\n+          Token::String(s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n             self.print_str(&s[])\n           }\n-          Eof => {\n+          Token::Eof => {\n             // Eof should never get here.\n             panic!();\n           }\n@@ -616,41 +615,45 @@ impl Printer {\n //\n // \"raw box\"\n pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n-    p.pretty_print(Begin(BeginToken {\n+    p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n     }))\n }\n \n pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Inconsistent)\n+    rbox(p, indent, Breaks::Inconsistent)\n }\n \n pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Consistent)\n+    rbox(p, indent, Breaks::Consistent)\n }\n \n pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n-    p.pretty_print(Break(BreakToken {\n+    p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n     }))\n }\n \n-pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n+pub fn end(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::End)\n+}\n \n-pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n+pub fn eof(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::Eof)\n+}\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), wrd.len() as int))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as int))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n@@ -670,7 +673,9 @@ pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n }\n \n pub fn hardbreak_tok_offset(off: int) -> Token {\n-    Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n }\n \n-pub fn hardbreak_tok() -> Token { return hardbreak_tok_offset(0); }\n+pub fn hardbreak_tok() -> Token {\n+    hardbreak_tok_offset(0)\n+}"}, {"sha": "cbf7e2069870429966c3953897a3d0fb0e8d3141", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92b48556e088a4054c49f40fb85322ceff5de453/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b48556e088a4054c49f40fb85322ceff5de453/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=92b48556e088a4054c49f40fb85322ceff5de453", "patch": "@@ -25,7 +25,8 @@ use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n-use print::pp::{Breaks, Consistent, Inconsistent, eof};\n+use print::pp::{Breaks, eof};\n+use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n \n use std::{ascii, mem};\n@@ -459,7 +460,7 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n \n impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Inconsistent);\n+        self.boxes.push(pp::Breaks::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n \n@@ -469,7 +470,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn cbox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Consistent);\n+        self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n@@ -531,11 +532,17 @@ impl<'a> State<'a> {\n     }\n \n     pub fn is_begin(&mut self) -> bool {\n-        match self.s.last_token() { pp::Begin(_) => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::Begin(_) => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_end(&mut self) -> bool {\n-        match self.s.last_token() { pp::End => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::End => true,\n+            _ => false,\n+        }\n     }\n \n     // is this the beginning of a line?\n@@ -545,7 +552,7 @@ impl<'a> State<'a> {\n \n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n-            Some(&last_box) => last_box == pp::Consistent,\n+            Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n@@ -2881,7 +2888,7 @@ impl<'a> State<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let is_semi = match self.s.last_token() {\n-                    pp::String(s, _) => \";\" == s,\n+                    pp::Token::String(s, _) => \";\" == s,\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {"}]}