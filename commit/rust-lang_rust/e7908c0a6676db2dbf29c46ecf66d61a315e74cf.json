{"sha": "e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OTA4YzBhNjY3NmRiMmRiZjI5YzQ2ZWNmNjZkNjFhMzE1ZTc0Y2Y=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-06T12:56:52Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-08T01:13:27Z"}, "message": "extra::json: remove the use of `unsafe` char transmutes.\n\nAvoid using -1 as a char sentinel, when Option<char> is the perfect\nthing.", "tree": {"sha": "5db7b34430620ef729e7459f4f3e9661d98e9b1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5db7b34430620ef729e7459f4f3e9661d98e9b1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "html_url": "https://github.com/rust-lang/rust/commit/e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7908c0a6676db2dbf29c46ecf66d61a315e74cf/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "html_url": "https://github.com/rust-lang/rust/commit/1fd2d7786013f98c59f099a2a0413b61a6e82d9d"}], "stats": {"total": 278, "additions": 139, "deletions": 139}, "files": [{"sha": "3938f1a89942b6593492bb653d3543592ebd45c8", "filename": "src/libextra/json.rs", "status": "modified", "additions": 139, "deletions": 139, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/e7908c0a6676db2dbf29c46ecf66d61a315e74cf/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7908c0a6676db2dbf29c46ecf66d61a315e74cf/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "patch": "@@ -229,7 +229,6 @@ fn main() {\n */\n \n use std::char;\n-use std::cast::transmute;\n use std::f64;\n use std::hashmap::HashMap;\n use std::io;\n@@ -718,7 +717,7 @@ impl Json {\n \n pub struct Parser<T> {\n     priv rdr: T,\n-    priv ch: char,\n+    priv ch: Option<char>,\n     priv line: uint,\n     priv col: uint,\n }\n@@ -728,7 +727,7 @@ impl<T: Iterator<char>> Parser<T> {\n     pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n             rdr: rdr,\n-            ch: '\\x00',\n+            ch: Some('\\x00'),\n             line: 1,\n             col: 0,\n         };\n@@ -756,27 +755,26 @@ impl<T: Iterator<char>> Parser<T> {\n }\n \n impl<T : Iterator<char>> Parser<T> {\n-    // FIXME: #8971: unsound\n-    fn eof(&self) -> bool { self.ch == unsafe { transmute(-1u32) } }\n-\n+    fn eof(&self) -> bool { self.ch.is_none() }\n+    fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }\n     fn bump(&mut self) {\n-        match self.rdr.next() {\n-            Some(ch) => self.ch = ch,\n-            None() => self.ch = unsafe { transmute(-1u32) }, // FIXME: #8971: unsound\n-        }\n+        self.ch = self.rdr.next();\n \n-        if self.ch == '\\n' {\n+        if self.ch_is('\\n') {\n             self.line += 1u;\n             self.col = 1u;\n         } else {\n             self.col += 1u;\n         }\n     }\n \n-    fn next_char(&mut self) -> char {\n+    fn next_char(&mut self) -> Option<char> {\n         self.bump();\n         self.ch\n     }\n+    fn ch_is(&self, c: char) -> bool {\n+        self.ch == Some(c)\n+    }\n \n     fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n         Err(Error { line: self.line, col: self.col, msg: msg })\n@@ -787,31 +785,32 @@ impl<T : Iterator<char>> Parser<T> {\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n-        match self.ch {\n-          'n' => self.parse_ident(\"ull\", Null),\n-          't' => self.parse_ident(\"rue\", Boolean(true)),\n-          'f' => self.parse_ident(\"alse\", Boolean(false)),\n-          '0' .. '9' | '-' => self.parse_number(),\n-          '\"' =>\n-            match self.parse_str() {\n-              Ok(s) => Ok(String(s)),\n-              Err(e) => Err(e),\n+        match self.ch_or_null() {\n+            'n' => self.parse_ident(\"ull\", Null),\n+            't' => self.parse_ident(\"rue\", Boolean(true)),\n+            'f' => self.parse_ident(\"alse\", Boolean(false)),\n+            '0' .. '9' | '-' => self.parse_number(),\n+            '\"' => {\n+                match self.parse_str() {\n+                    Ok(s) => Ok(String(s)),\n+                    Err(e) => Err(e),\n+                }\n             },\n-          '[' => self.parse_list(),\n-          '{' => self.parse_object(),\n-          _ => self.error(~\"invalid syntax\")\n+            '[' => self.parse_list(),\n+            '{' => self.parse_object(),\n+            _ => self.error(~\"invalid syntax\"),\n         }\n     }\n \n     fn parse_whitespace(&mut self) {\n-        while self.ch == ' ' ||\n-              self.ch == '\\n' ||\n-              self.ch == '\\t' ||\n-              self.ch == '\\r' { self.bump(); }\n+        while self.ch_is(' ') ||\n+              self.ch_is('\\n') ||\n+              self.ch_is('\\t') ||\n+              self.ch_is('\\r') { self.bump(); }\n     }\n \n     fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if ident.chars().all(|c| c == self.next_char()) {\n+        if ident.chars().all(|c| Some(c) == self.next_char()) {\n             self.bump();\n             Ok(value)\n         } else {\n@@ -822,7 +821,7 @@ impl<T : Iterator<char>> Parser<T> {\n     fn parse_number(&mut self) -> Result<Json, Error> {\n         let mut neg = 1.0;\n \n-        if self.ch == '-' {\n+        if self.ch_is('-') {\n             self.bump();\n             neg = -1.0;\n         }\n@@ -832,14 +831,14 @@ impl<T : Iterator<char>> Parser<T> {\n           Err(e) => return Err(e)\n         };\n \n-        if self.ch == '.' {\n+        if self.ch_is('.') {\n             match self.parse_decimal(res) {\n               Ok(r) => res = r,\n               Err(e) => return Err(e)\n             }\n         }\n \n-        if self.ch == 'e' || self.ch == 'E' {\n+        if self.ch_is('e') || self.ch_is('E') {\n             match self.parse_exponent(res) {\n               Ok(r) => res = r,\n               Err(e) => return Err(e)\n@@ -852,55 +851,54 @@ impl<T : Iterator<char>> Parser<T> {\n     fn parse_integer(&mut self) -> Result<f64, Error> {\n         let mut res = 0.0;\n \n-        match self.ch {\n-          '0' => {\n-            self.bump();\n-\n-            // There can be only one leading '0'.\n-            match self.ch {\n-              '0' .. '9' => return self.error(~\"invalid number\"),\n-              _ => ()\n-            }\n-          }\n-          '1' .. '9' => {\n-            while !self.eof() {\n-                match self.ch {\n-                  '0' .. '9' => {\n-                    res *= 10.0;\n-                    res += ((self.ch as int) - ('0' as int)) as f64;\n+        match self.ch_or_null() {\n+            '0' => {\n+                self.bump();\n \n-                    self.bump();\n-                  }\n-                  _ => break\n+                // There can be only one leading '0'.\n+                match self.ch_or_null() {\n+                    '0' .. '9' => return self.error(~\"invalid number\"),\n+                    _ => ()\n+                }\n+            },\n+            '1' .. '9' => {\n+                while !self.eof() {\n+                    match self.ch_or_null() {\n+                        c @ '0' .. '9' => {\n+                            res *= 10.0;\n+                            res += ((c as int) - ('0' as int)) as f64;\n+\n+                            self.bump();\n+                        }\n+                        _ => break,\n+                    }\n                 }\n             }\n-          }\n-          _ => return self.error(~\"invalid number\")\n+            _ => return self.error(~\"invalid number\"),\n         }\n-\n         Ok(res)\n     }\n \n     fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n-        match self.ch {\n-          '0' .. '9' => (),\n-          _ => return self.error(~\"invalid number\")\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+             _ => return self.error(~\"invalid number\")\n         }\n \n         let mut res = res;\n         let mut dec = 1.0;\n         while !self.eof() {\n-            match self.ch {\n-              '0' .. '9' => {\n-                dec /= 10.0;\n-                res += (((self.ch as int) - ('0' as int)) as f64) * dec;\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    dec /= 10.0;\n+                    res += (((c as int) - ('0' as int)) as f64) * dec;\n \n-                self.bump();\n-              }\n-              _ => break\n+                    self.bump();\n+                }\n+                _ => break,\n             }\n         }\n \n@@ -913,27 +911,27 @@ impl<T : Iterator<char>> Parser<T> {\n         let mut exp = 0u;\n         let mut neg_exp = false;\n \n-        match self.ch {\n-          '+' => self.bump(),\n-          '-' => { self.bump(); neg_exp = true; }\n-          _ => ()\n+        if self.ch_is('+') {\n+            self.bump();\n+        } else if self.ch_is('-') {\n+            self.bump();\n+            neg_exp = true;\n         }\n \n         // Make sure a digit follows the exponent place.\n-        match self.ch {\n-          '0' .. '9' => (),\n-          _ => return self.error(~\"invalid number\")\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+            _ => return self.error(~\"invalid number\")\n         }\n-\n         while !self.eof() {\n-            match self.ch {\n-              '0' .. '9' => {\n-                exp *= 10u;\n-                exp += (self.ch as uint) - ('0' as uint);\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    exp *= 10;\n+                    exp += (c as uint) - ('0' as uint);\n \n-                self.bump();\n-              }\n-              _ => break\n+                    self.bump();\n+                }\n+                _ => break\n             }\n         }\n \n@@ -958,56 +956,55 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n \n             if escape {\n-                match self.ch {\n-                  '\"' => res.push_char('\"'),\n-                  '\\\\' => res.push_char('\\\\'),\n-                  '/' => res.push_char('/'),\n-                  'b' => res.push_char('\\x08'),\n-                  'f' => res.push_char('\\x0c'),\n-                  'n' => res.push_char('\\n'),\n-                  'r' => res.push_char('\\r'),\n-                  't' => res.push_char('\\t'),\n-                  'u' => {\n-                      // Parse \\u1234.\n-                      let mut i = 0u;\n-                      let mut n = 0u;\n-                      while i < 4u {\n-                          match self.next_char() {\n-                            '0' .. '9' => {\n-                              n = n * 16u + (self.ch as uint)\n-                                          - ('0'     as uint);\n-                            },\n-                            'a' | 'A' => n = n * 16u + 10u,\n-                            'b' | 'B' => n = n * 16u + 11u,\n-                            'c' | 'C' => n = n * 16u + 12u,\n-                            'd' | 'D' => n = n * 16u + 13u,\n-                            'e' | 'E' => n = n * 16u + 14u,\n-                            'f' | 'F' => n = n * 16u + 15u,\n-                            _ => return self.error(\n-                                   ~\"invalid \\\\u escape (unrecognized hex)\")\n-                          }\n-                          i += 1u;\n-                      }\n-\n-                      // Error out if we didn't parse 4 digits.\n-                      if i != 4u {\n-                          return self.error(\n-                            ~\"invalid \\\\u escape (not four digits)\");\n-                      }\n-\n-                      res.push_char(char::from_u32(n as u32).unwrap());\n-                  }\n-                  _ => return self.error(~\"invalid escape\")\n+                match self.ch_or_null() {\n+                    '\"' => res.push_char('\"'),\n+                    '\\\\' => res.push_char('\\\\'),\n+                    '/' => res.push_char('/'),\n+                    'b' => res.push_char('\\x08'),\n+                    'f' => res.push_char('\\x0c'),\n+                    'n' => res.push_char('\\n'),\n+                    'r' => res.push_char('\\r'),\n+                    't' => res.push_char('\\t'),\n+                    'u' => {\n+                        // Parse \\u1234.\n+                        let mut i = 0u;\n+                        let mut n = 0u;\n+                        while i < 4u && !self.eof() {\n+                            self.bump();\n+                            n = match self.ch_or_null() {\n+                                c @ '0' .. '9' => n * 16u + (c as uint) - ('0' as uint),\n+                                'a' | 'A' => n * 16u + 10u,\n+                                'b' | 'B' => n * 16u + 11u,\n+                                'c' | 'C' => n * 16u + 12u,\n+                                'd' | 'D' => n * 16u + 13u,\n+                                'e' | 'E' => n * 16u + 14u,\n+                                'f' | 'F' => n * 16u + 15u,\n+                                _ => return self.error(\n+                                    ~\"invalid \\\\u escape (unrecognized hex)\")\n+                            };\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Error out if we didn't parse 4 digits.\n+                        if i != 4u {\n+                            return self.error(\n+                                ~\"invalid \\\\u escape (not four digits)\");\n+                        }\n+\n+                        res.push_char(char::from_u32(n as u32).unwrap());\n+                    }\n+                    _ => return self.error(~\"invalid escape\"),\n                 }\n                 escape = false;\n-            } else if self.ch == '\\\\' {\n+            } else if self.ch_is('\\\\') {\n                 escape = true;\n             } else {\n-                if self.ch == '\"' {\n-                    self.bump();\n-                    return Ok(res);\n+                match self.ch {\n+                    Some('\"') => { self.bump(); return Ok(res); },\n+                    Some(c) => res.push_char(c),\n+                    None => unreachable!()\n                 }\n-                res.push_char(self.ch);\n             }\n         }\n     }\n@@ -1018,7 +1015,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n         let mut values = ~[];\n \n-        if self.ch == ']' {\n+        if self.ch_is(']') {\n             self.bump();\n             return Ok(List(values));\n         }\n@@ -1034,10 +1031,13 @@ impl<T : Iterator<char>> Parser<T> {\n                 return self.error(~\"EOF while parsing list\");\n             }\n \n-            match self.ch {\n-              ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(values)); }\n-              _ => return self.error(~\"expected `,` or `]`\")\n+            if self.ch_is(',') {\n+                self.bump();\n+            } else if self.ch_is(']') {\n+                self.bump();\n+                return Ok(List(values));\n+            } else {\n+                return self.error(~\"expected `,` or `]`\")\n             }\n         };\n     }\n@@ -1048,15 +1048,15 @@ impl<T : Iterator<char>> Parser<T> {\n \n         let mut values = ~TreeMap::new();\n \n-        if self.ch == '}' {\n+        if self.ch_is('}') {\n           self.bump();\n           return Ok(Object(values));\n         }\n \n         while !self.eof() {\n             self.parse_whitespace();\n \n-            if self.ch != '\"' {\n+            if !self.ch_is('\"') {\n                 return self.error(~\"key must be a string\");\n             }\n \n@@ -1067,7 +1067,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n             self.parse_whitespace();\n \n-            if self.ch != ':' {\n+            if !self.ch_is(':') {\n                 if self.eof() { break; }\n                 return self.error(~\"expected `:`\");\n             }\n@@ -1079,13 +1079,13 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n             self.parse_whitespace();\n \n-            match self.ch {\n-              ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(values)); }\n-              _ => {\n-                  if self.eof() { break; }\n-                  return self.error(~\"expected `,` or `}`\");\n-              }\n+            match self.ch_or_null() {\n+                ',' => self.bump(),\n+                '}' => { self.bump(); return Ok(Object(values)); },\n+                _ => {\n+                    if self.eof() { break; }\n+                    return self.error(~\"expected `,` or `}`\");\n+                }\n             }\n         }\n "}]}