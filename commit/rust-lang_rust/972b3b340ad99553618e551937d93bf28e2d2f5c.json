{"sha": "972b3b340ad99553618e551937d93bf28e2d2f5c", "node_id": "C_kwDOAAsO6NoAKDk3MmIzYjM0MGFkOTk1NTM2MThlNTUxOTM3ZDkzYmYyOGUyZDJmNWM", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-05-11T23:13:00Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-05-12T00:07:44Z"}, "message": "Cleanup/Refactoring from review\n\n* Pass a ThreadInfo down to grant/access to get the current span lazily\n* Rename add_* to log_* for clarity\n* Hoist borrow_mut calls out of loops by tweaking the for_each signature\n* Explain the parameters of check_protector a bit more", "tree": {"sha": "89d7d1b4860242c26b799cb21b3e590648b29861", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89d7d1b4860242c26b799cb21b3e590648b29861"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972b3b340ad99553618e551937d93bf28e2d2f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972b3b340ad99553618e551937d93bf28e2d2f5c", "html_url": "https://github.com/rust-lang/rust/commit/972b3b340ad99553618e551937d93bf28e2d2f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972b3b340ad99553618e551937d93bf28e2d2f5c/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ab457aa04090d52b7b1a91058957afd56ecc52", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ab457aa04090d52b7b1a91058957afd56ecc52", "html_url": "https://github.com/rust-lang/rust/commit/68ab457aa04090d52b7b1a91058957afd56ecc52"}], "stats": {"total": 215, "additions": 117, "deletions": 98}, "files": [{"sha": "f8d23cb8279cde8ea0736eff82e75bfc628aa048", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=972b3b340ad99553618e551937d93bf28e2d2f5c", "patch": "@@ -15,7 +15,6 @@ use rustc_target::spec::abi::Abi;\n \n use rustc_session::config::EntryFnType;\n \n-use rustc_span::DUMMY_SP;\n use std::collections::HashSet;\n \n use crate::*;\n@@ -311,9 +310,6 @@ pub fn eval_entry<'tcx>(\n             let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n-                    if let Some(sb) = ecx.machine.stacked_borrows.as_mut() {\n-                        sb.get_mut().current_span = DUMMY_SP;\n-                    }\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {"}, {"sha": "7cb08066a6c3b3c77388ca90b7435834c3053eb6", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=972b3b340ad99553618e551937d93bf28e2d2f5c", "patch": "@@ -25,7 +25,6 @@ use rustc_middle::{\n };\n use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n@@ -308,6 +307,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n                 config.tracked_pointer_tags.clone(),\n                 config.tracked_call_ids.clone(),\n                 config.tag_raw,\n+                local_crates.clone(),\n             )))\n         } else {\n             None\n@@ -562,15 +562,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>> {\n-        set_current_span(&ecx.machine);\n         if ecx.machine.tracked_alloc_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(id));\n         }\n \n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n         let stacks = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            Some(Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))\n+            Some(Stacks::new_allocation(\n+                id,\n+                alloc.size(),\n+                stacked_borrows,\n+                kind,\n+                &ecx.machine.threads,\n+            ))\n         } else {\n             None\n         };\n@@ -591,7 +596,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<Tag> {\n-        set_current_span(&ecx.machine);\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n@@ -627,7 +631,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        set_current_span(&machine);\n         if let Some(data_race) = &alloc_extra.data_race {\n             data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n         }\n@@ -637,6 +640,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 tag,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -651,7 +655,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        set_current_span(&machine);\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n@@ -661,6 +664,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 tag,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -675,7 +679,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        set_current_span(&machine);\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n@@ -700,12 +703,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() {\n-            set_current_span(&ecx.machine);\n-            ecx.retag(kind, place)\n-        } else {\n-            Ok(())\n-        }\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n     }\n \n     #[inline(always)]\n@@ -751,12 +749,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() {\n-            set_current_span(&ecx.machine);\n-            ecx.retag_return_place()\n-        } else {\n-            Ok(())\n-        }\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n     #[inline(always)]\n@@ -773,30 +766,3 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         res\n     }\n }\n-\n-// This is potentially a performance hazard.\n-// Factoring it into its own function lets us keep an eye on how much it shows up in a profile.\n-///\n-fn set_current_span<'mir, 'tcx: 'mir>(machine: &Evaluator<'mir, 'tcx>) {\n-    if let Some(sb) = machine.stacked_borrows.as_ref() {\n-        if sb.borrow().current_span != DUMMY_SP {\n-            return;\n-        }\n-        let current_span = machine\n-            .threads\n-            .active_thread_stack()\n-            .into_iter()\n-            .rev()\n-            .find(|frame| {\n-                let info = FrameInfo {\n-                    instance: frame.instance,\n-                    span: frame.current_span(),\n-                    lint_root: None,\n-                };\n-                machine.is_local(&info)\n-            })\n-            .map(|frame| frame.current_span())\n-            .unwrap_or(rustc_span::DUMMY_SP);\n-        sb.borrow_mut().current_span = current_span;\n-    }\n-}"}, {"sha": "1aec3c0e5eab91bfff4960d76bc33a45d9c4741e", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=972b3b340ad99553618e551937d93bf28e2d2f5c", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n };\n-use rustc_span::Span;\n+use rustc_span::def_id::CrateNum;\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n use std::collections::HashSet;\n@@ -118,10 +118,10 @@ pub struct GlobalStateInner {\n     tracked_call_ids: HashSet<CallId>,\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n+    /// Crates which are considered local for the purposes of error reporting.\n+    local_crates: Vec<CrateNum>,\n     /// Extra per-allocation information\n     extras: HashMap<AllocId, AllocHistory>,\n-    /// Current span\n-    pub(crate) current_span: Span,\n }\n \n /// We need interior mutable access to the global state.\n@@ -174,6 +174,7 @@ impl GlobalStateInner {\n         tracked_pointer_tags: HashSet<PtrId>,\n         tracked_call_ids: HashSet<CallId>,\n         tag_raw: bool,\n+        local_crates: Vec<CrateNum>,\n     ) -> Self {\n         GlobalStateInner {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n@@ -183,8 +184,8 @@ impl GlobalStateInner {\n             tracked_pointer_tags,\n             tracked_call_ids,\n             tag_raw,\n+            local_crates,\n             extras: HashMap::new(),\n-            current_span: DUMMY_SP,\n         }\n     }\n \n@@ -325,6 +326,9 @@ impl<'tcx> Stack {\n     /// The `provoking_access` argument is only used to produce diagnostics.\n     /// It is `Some` when we are granting the contained access for said tag, and it is\n     /// `None` during a deallocation.\n+    /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n+    /// the `Size` refers to the specific location in the `AllocRange` that we are\n+    /// currently checking.\n     fn check_protector(\n         item: &Item,\n         provoking_access: Option<(SbTag, AllocId, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n@@ -378,6 +382,7 @@ impl<'tcx> Stack {\n         tag: SbTag,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -399,7 +404,7 @@ impl<'tcx> Stack {\n                     Some((tag, alloc_id, alloc_range, offset, access)),\n                     global,\n                 )?;\n-                global.add_invalidation(item.tag, alloc_id, alloc_range);\n+                global.log_invalidation(item.tag, alloc_id, alloc_range, threads);\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -420,7 +425,7 @@ impl<'tcx> Stack {\n                         global,\n                     )?;\n                     item.perm = Permission::Disabled;\n-                    global.add_invalidation(item.tag, alloc_id, alloc_range);\n+                    global.log_invalidation(item.tag, alloc_id, alloc_range, threads);\n                 }\n             }\n         }\n@@ -468,6 +473,7 @@ impl<'tcx> Stack {\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n@@ -495,7 +501,7 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, (alloc_id, alloc_range, offset), global)?;\n+            self.access(access, derived_from, (alloc_id, alloc_range, offset), global, threads)?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -532,7 +538,7 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &self,\n         range: AllocRange,\n-        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n@@ -545,7 +551,7 @@ impl<'tcx> Stacks {\n     fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n-        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n@@ -562,6 +568,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n+        threads: &ThreadManager<'_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -595,7 +602,7 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        extra.add_creation(None, base_tag, id, alloc_range(Size::ZERO, size));\n+        extra.log_creation(None, base_tag, id, alloc_range(Size::ZERO, size), threads);\n         Stacks::new(size, perm, base_tag)\n     }\n \n@@ -606,16 +613,17 @@ impl Stacks {\n         tag: SbTag,\n         range: AllocRange,\n         state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        self.for_each(range, move |offset, stack| {\n-            let mut state = state.borrow_mut();\n-            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), &mut state)\n+        let mut state = state.borrow_mut();\n+        self.for_each(range, |offset, stack| {\n+            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), &mut state, threads)\n         })\n     }\n \n@@ -626,16 +634,17 @@ impl Stacks {\n         tag: SbTag,\n         range: AllocRange,\n         state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        self.for_each_mut(range, move |offset, stack| {\n-            let mut state = state.borrow_mut();\n-            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), &mut state)\n+        let mut state = state.borrow_mut();\n+        self.for_each_mut(range, |offset, stack| {\n+            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), &mut state, threads)\n         })\n     }\n \n@@ -648,11 +657,11 @@ impl Stacks {\n         state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        self.for_each_mut(range, move |offset, stack| {\n-            let mut state = state.borrow_mut();\n+        let mut state = state.borrow_mut();\n+        self.for_each_mut(range, |offset, stack| {\n             stack.dealloc(tag, (alloc_id, range, offset), &mut state)\n         })?;\n-        state.borrow_mut().extras.remove(&alloc_id);\n+        state.extras.remove(&alloc_id);\n         Ok(())\n     }\n }\n@@ -684,14 +693,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n \n         let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-        mem_extra.add_creation(\n+        mem_extra.log_creation(\n             Some(orig_tag),\n             new_tag,\n             alloc_id,\n             alloc_range(base_offset, base_offset + size),\n+            &this.machine.threads,\n         );\n         if protect {\n-            mem_extra.add_protector(orig_tag, new_tag, alloc_id);\n+            mem_extra.log_protector(orig_tag, new_tag, alloc_id, &this.machine.threads);\n         }\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n@@ -752,10 +762,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n+                    let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n                     stacked_borrows.for_each(range, |offset, stack| {\n-                        let mut global =\n-                            this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-                        stack.grant(orig_tag, item, (alloc_id, range, offset), &mut *global)\n+                        stack.grant(\n+                            orig_tag,\n+                            item,\n+                            (alloc_id, range, offset),\n+                            &mut *global,\n+                            &this.machine.threads,\n+                        )\n                     })\n                 })?;\n                 return Ok(());\n@@ -764,15 +779,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let (alloc_extra, memory_extra) = this.get_alloc_extra_mut(alloc_id)?;\n+        let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows =\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n+        let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         stacked_borrows.for_each_mut(range, |offset, stack| {\n-            let mut global = memory_extra.stacked_borrows.as_ref().unwrap().borrow_mut();\n-            stack.grant(orig_tag, item, (alloc_id, range, offset), &mut *global)\n+            stack.grant(orig_tag, item, (alloc_id, range, offset), &mut global, &machine.threads)\n         })?;\n+\n         Ok(())\n     }\n \n@@ -797,12 +813,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Compute new borrow.\n-        let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-        let new_tag = match kind {\n-            // Give up tracking for raw pointers.\n-            RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n-            // All other pointers are properly tracked.\n-            _ => SbTag::Tagged(mem_extra.new_ptr()),\n+        let new_tag = {\n+            let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n+            match kind {\n+                // Give up tracking for raw pointers.\n+                RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n+                // All other pointers are properly tracked.\n+                _ => SbTag::Tagged(mem_extra.new_ptr()),\n+            }\n         };\n \n         // Reborrow."}, {"sha": "f657a926c0a54751efe4ac06ab2a209410786d59", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972b3b340ad99553618e551937d93bf28e2d2f5c/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=972b3b340ad99553618e551937d93bf28e2d2f5c", "patch": "@@ -7,6 +7,7 @@ use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission\n use crate::Item;\n use crate::SbTag;\n use crate::Stack;\n+use crate::ThreadManager;\n \n use rustc_middle::mir::interpret::InterpError;\n \n@@ -52,17 +53,32 @@ pub enum TagHistory {\n }\n \n pub trait GlobalStateExt {\n-    fn add_creation(\n+    fn current_span(&self, threads: &ThreadManager<'_, '_>) -> Span;\n+\n+    fn log_creation(\n         &mut self,\n         parent: Option<SbTag>,\n         tag: SbTag,\n         alloc: AllocId,\n         range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n     );\n \n-    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange);\n+    fn log_invalidation(\n+        &mut self,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n+    );\n \n-    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId);\n+    fn log_protector(\n+        &mut self,\n+        orig_tag: SbTag,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        threads: &ThreadManager<'_, '_>,\n+    );\n \n     fn get_stack_history(\n         &self,\n@@ -75,39 +91,62 @@ pub trait GlobalStateExt {\n }\n \n impl GlobalStateExt for GlobalStateInner {\n-    fn add_creation(\n+    fn current_span(&self, threads: &ThreadManager<'_, '_>) -> Span {\n+        threads\n+            .active_thread_stack()\n+            .into_iter()\n+            .rev()\n+            .find(|frame| {\n+                let def_id = frame.instance.def_id();\n+                def_id.is_local() || self.local_crates.contains(&def_id.krate)\n+            })\n+            .map(|frame| frame.current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP)\n+    }\n+\n+    fn log_creation(\n         &mut self,\n         parent: Option<SbTag>,\n         tag: SbTag,\n         alloc: AllocId,\n         range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n     ) {\n+        let span = self.current_span(threads);\n         let extras = self.extras.entry(alloc).or_default();\n-        extras.creations.push(Event {\n-            parent,\n-            tag,\n-            range,\n-            span: self.current_span,\n-            time: extras.current_time,\n-        });\n+        extras.creations.push(Event { parent, tag, range, span, time: extras.current_time });\n         extras.current_time += 1;\n     }\n \n-    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange) {\n+    fn log_invalidation(\n+        &mut self,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n+    ) {\n+        let span = self.current_span(threads);\n         let extras = self.extras.entry(alloc).or_default();\n         extras.invalidations.push(Event {\n             parent: None,\n             tag,\n             range,\n-            span: self.current_span,\n+            span,\n             time: extras.current_time,\n         });\n         extras.current_time += 1;\n     }\n \n-    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId) {\n+    fn log_protector(\n+        &mut self,\n+        orig_tag: SbTag,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        threads: &ThreadManager<'_, '_>,\n+    ) {\n+        let span = self.current_span(threads);\n         let extras = self.extras.entry(alloc).or_default();\n-        extras.protectors.push(Protection { orig_tag, tag, span: self.current_span });\n+        extras.protectors.push(Protection { orig_tag, tag, span });\n         extras.current_time += 1;\n     }\n "}]}