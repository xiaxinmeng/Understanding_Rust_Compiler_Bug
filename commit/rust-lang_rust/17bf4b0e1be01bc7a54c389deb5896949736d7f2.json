{"sha": "17bf4b0e1be01bc7a54c389deb5896949736d7f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YmY0YjBlMWJlMDFiYzdhNTRjMzg5ZGViNTg5Njk0OTczNmQ3ZjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-18T01:28:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-18T03:41:05Z"}, "message": "libcore: Move core tests into libcore", "tree": {"sha": "925c4038e60299b3b518afb580b0127786d974d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/925c4038e60299b3b518afb580b0127786d974d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17bf4b0e1be01bc7a54c389deb5896949736d7f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17bf4b0e1be01bc7a54c389deb5896949736d7f2", "html_url": "https://github.com/rust-lang/rust/commit/17bf4b0e1be01bc7a54c389deb5896949736d7f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17bf4b0e1be01bc7a54c389deb5896949736d7f2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de4053f47384a71d6339b71a20102143df1e3144", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4053f47384a71d6339b71a20102143df1e3144", "html_url": "https://github.com/rust-lang/rust/commit/de4053f47384a71d6339b71a20102143df1e3144"}], "stats": {"total": 4058, "additions": 1990, "deletions": 2068}, "files": [{"sha": "3b35801142242b3cbd81fe3ecc28648c506ff0d6", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -85,6 +85,26 @@ fn all_values(blk: block(v: t)) {\n )]\n pure fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n \n+#[test]\n+fn test_bool_from_str() {\n+    all_values { |v|\n+        assert v == from_str(bool::to_str(v))\n+    }\n+}\n+\n+#[test]\n+fn test_bool_to_str() {\n+    assert to_str(false) == \"false\";\n+    assert to_str(true) == \"true\";\n+}\n+\n+#[test]\n+fn test_bool_to_bit() {\n+    all_values { |v|\n+        assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "114c495d64d9464421e949cdb1f56addbdba2dfe", "filename": "src/libcore/box.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -11,3 +11,13 @@ pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n         ret a_ptr == b_ptr;\n     }\n }\n+\n+#[test]\n+fn test() {\n+    let x = @3;\n+    let y = @3;\n+    assert (ptr_eq::<int>(x, x));\n+    assert (ptr_eq::<int>(y, y));\n+    assert (!ptr_eq::<int>(x, y));\n+    assert (!ptr_eq::<int>(y, x));\n+}"}, {"sha": "1903ac8dbd85acdf3fa028ed43ba79b0df05a13f", "filename": "src/libcore/char.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -147,3 +147,77 @@ pure fn cmp(a: char, b: char) -> int {\n     else if b < a { 1 }\n     else { 0 }\n }\n+\n+#[test]\n+fn test_is_lowercase() {\n+    assert is_lowercase('a');\n+    assert is_lowercase('\u00f6');\n+    assert is_lowercase('\u00df');\n+    assert !is_lowercase('\u00dc');\n+    assert !is_lowercase('P');\n+}\n+\n+#[test]\n+fn test_is_uppercase() {\n+    assert !is_uppercase('h');\n+    assert !is_uppercase('\u00e4');\n+    assert !is_uppercase('\u00df');\n+    assert is_uppercase('\u00d6');\n+    assert is_uppercase('T');\n+}\n+\n+#[test]\n+fn test_is_whitespace() {\n+    assert is_whitespace(' ');\n+    assert is_whitespace('\\u2007');\n+    assert is_whitespace('\\t');\n+    assert is_whitespace('\\n');\n+\n+    assert !is_whitespace('a');\n+    assert !is_whitespace('_');\n+    assert !is_whitespace('\\u0000');\n+}\n+\n+#[test]\n+fn test_to_digit() {\n+    assert (to_digit('0') == 0u8);\n+    assert (to_digit('1') == 1u8);\n+    assert (to_digit('2') == 2u8);\n+    assert (to_digit('9') == 9u8);\n+    assert (to_digit('a') == 10u8);\n+    assert (to_digit('A') == 10u8);\n+    assert (to_digit('b') == 11u8);\n+    assert (to_digit('B') == 11u8);\n+    assert (to_digit('z') == 35u8);\n+    assert (to_digit('Z') == 35u8);\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_to_digit_fail_1() {\n+    to_digit(' ');\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_to_digit_fail_2() {\n+    to_digit('$');\n+}\n+\n+#[test]\n+fn test_to_lower() {\n+    assert (to_lower('H') == 'h');\n+    assert (to_lower('e') == 'e');\n+    //assert (to_lower('\u00d6') == '\u00f6');\n+    assert (to_lower('\u00df') == '\u00df');\n+}\n+\n+#[test]\n+fn test_to_upper() {\n+    assert (to_upper('l') == 'L');\n+    assert (to_upper('Q') == 'Q');\n+    //assert (to_upper('\u00fc') == '\u00dc');\n+    assert (to_upper('\u00df') == '\u00df');\n+}"}, {"sha": "353c14fe5a826a1a24054641c76e56ee4246253d", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -156,3 +156,46 @@ fn recv_<T: send>(p: *rustrt::rust_port) -> T {\n fn chan<T: send>(p: port<T>) -> chan<T> {\n     chan_t(task::get_task(), rustrt::get_port_id(***p))\n }\n+\n+#[test]\n+fn create_port_and_chan() { let p = port::<int>(); chan(p); }\n+\n+#[test]\n+fn send_int() {\n+    let p = port::<int>();\n+    let c = chan(p);\n+    send(c, 22);\n+}\n+\n+#[test]\n+fn send_recv_fn() {\n+    let p = port::<int>();\n+    let c = chan::<int>(p);\n+    send(c, 42);\n+    assert (recv(p) == 42);\n+}\n+\n+#[test]\n+fn send_recv_fn_infer() {\n+    let p = port();\n+    let c = chan(p);\n+    send(c, 42);\n+    assert (recv(p) == 42);\n+}\n+\n+#[test]\n+fn chan_chan_infer() {\n+    let p = port(), p2 = port::<int>();\n+    let c = chan(p);\n+    send(c, chan(p2));\n+    recv(p);\n+}\n+\n+#[test]\n+fn chan_chan() {\n+    let p = port::<chan<int>>(), p2 = port::<int>();\n+    let c = chan(p);\n+    send(c, chan(p2));\n+    recv(p);\n+}\n+"}, {"sha": "47878ae9bf48b9596356108ff8d16c60afca8be3", "filename": "src/libcore/either.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -130,3 +130,96 @@ pure fn is_right<T, U>(eith: t<T, U>) -> bool {\n // buffer-file-coding-system: utf-8-unix\n // End:\n //\n+\n+#[test]\n+fn test_either_left() {\n+    let val = left(10);\n+    fn f_left(&&x: int) -> bool { x == 10 }\n+    fn f_right(&&_x: uint) -> bool { false }\n+    assert (either(f_left, f_right, val));\n+}\n+\n+#[test]\n+fn test_either_right() {\n+    let val = right(10u);\n+    fn f_left(&&_x: int) -> bool { false }\n+    fn f_right(&&x: uint) -> bool { x == 10u }\n+    assert (either(f_left, f_right, val));\n+}\n+\n+#[test]\n+fn test_lefts() {\n+    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let result = lefts(input);\n+    assert (result == [10, 12, 14]);\n+}\n+\n+#[test]\n+fn test_lefts_none() {\n+    let input: [t<int, int>] = [right(10), right(10)];\n+    let result = lefts(input);\n+    assert (vec::len(result) == 0u);\n+}\n+\n+#[test]\n+fn test_lefts_empty() {\n+    let input: [t<int, int>] = [];\n+    let result = lefts(input);\n+    assert (vec::len(result) == 0u);\n+}\n+\n+#[test]\n+fn test_rights() {\n+    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let result = rights(input);\n+    assert (result == [11, 13]);\n+}\n+\n+#[test]\n+fn test_rights_none() {\n+    let input: [t<int, int>] = [left(10), left(10)];\n+    let result = rights(input);\n+    assert (vec::len(result) == 0u);\n+}\n+\n+#[test]\n+fn test_rights_empty() {\n+    let input: [t<int, int>] = [];\n+    let result = rights(input);\n+    assert (vec::len(result) == 0u);\n+}\n+\n+#[test]\n+fn test_partition() {\n+    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let result = partition(input);\n+    assert (result.lefts[0] == 10);\n+    assert (result.lefts[1] == 12);\n+    assert (result.lefts[2] == 14);\n+    assert (result.rights[0] == 11);\n+    assert (result.rights[1] == 13);\n+}\n+\n+#[test]\n+fn test_partition_no_lefts() {\n+    let input: [t<int, int>] = [right(10), right(11)];\n+    let result = partition(input);\n+    assert (vec::len(result.lefts) == 0u);\n+    assert (vec::len(result.rights) == 2u);\n+}\n+\n+#[test]\n+fn test_partition_no_rights() {\n+    let input: [t<int, int>] = [left(10), left(11)];\n+    let result = partition(input);\n+    assert (vec::len(result.lefts) == 2u);\n+    assert (vec::len(result.rights) == 0u);\n+}\n+\n+#[test]\n+fn test_partition_empty() {\n+    let input: [t<int, int>] = [];\n+    let result = partition(input);\n+    assert (vec::len(result.lefts) == 0u);\n+    assert (vec::len(result.rights) == 0u);\n+}"}, {"sha": "4023c65b118d9028d53a12e39a31b2931666867a", "filename": "src/libcore/float.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -281,6 +281,87 @@ fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n }\n \n \n+#[test]\n+fn test_from_str() {\n+   assert ( from_str(\"3\") == 3. );\n+   assert ( from_str(\"  3  \") == 3. );\n+   assert ( from_str(\"3.14\") == 3.14 );\n+   assert ( from_str(\"+3.14\") == 3.14 );\n+   assert ( from_str(\"-3.14\") == -3.14 );\n+   assert ( from_str(\"2.5E10\") == 25000000000. );\n+   assert ( from_str(\"2.5e10\") == 25000000000. );\n+   assert ( from_str(\"25000000000.E-10\") == 2.5 );\n+   assert ( from_str(\"\") == 0. );\n+   assert ( from_str(\".\") == 0. );\n+   assert ( from_str(\".e1\") == 0. );\n+   assert ( from_str(\".e-1\") == 0. );\n+   assert ( from_str(\"5.\") == 5. );\n+   assert ( from_str(\".5\") == 0.5 );\n+   assert ( from_str(\"0.5\") == 0.5 );\n+   assert ( from_str(\"0.5 \") == 0.5 );\n+   assert ( from_str(\" 0.5 \") == 0.5 );\n+   assert ( from_str(\" -.5 \") == -0.5 );\n+   assert ( from_str(\" -.5 \") == -0.5 );\n+   assert ( from_str(\" -5 \") == -5. );\n+\n+   assert ( is_NaN(from_str(\"x\")) );\n+   assert ( from_str(\" \") == 0. );\n+   assert ( from_str(\"   \") == 0. );\n+   assert ( from_str(\" 0.5\") == 0.5 );\n+   assert ( from_str(\" 0.5 \") == 0.5 );\n+   assert ( from_str(\" .1 \") == 0.1 );\n+   assert ( is_NaN(from_str(\"e\")) );\n+   assert ( is_NaN(from_str(\"E\")) );\n+   assert ( is_NaN(from_str(\"E1\")) );\n+   assert ( is_NaN(from_str(\"1e1e1\")) );\n+   assert ( is_NaN(from_str(\"1e1.1\")) );\n+   assert ( is_NaN(from_str(\"1e1-1\")) );\n+}\n+\n+#[test]\n+fn test_positive() {\n+  assert(is_positive(infinity));\n+  assert(is_positive(1.));\n+  assert(is_positive(0.));\n+  assert(!is_positive(-1.));\n+  assert(!is_positive(neg_infinity));\n+  assert(!is_positive(1./neg_infinity));\n+  assert(!is_positive(NaN));\n+}\n+\n+#[test]\n+fn test_negative() {\n+  assert(!is_negative(infinity));\n+  assert(!is_negative(1.));\n+  assert(!is_negative(0.));\n+  assert(is_negative(-1.));\n+  assert(is_negative(neg_infinity));\n+  assert(is_negative(1./neg_infinity));\n+  assert(!is_negative(NaN));\n+}\n+\n+#[test]\n+fn test_nonpositive() {\n+  assert(!is_nonpositive(infinity));\n+  assert(!is_nonpositive(1.));\n+  assert(!is_nonpositive(0.));\n+  assert(is_nonpositive(-1.));\n+  assert(is_nonpositive(neg_infinity));\n+  assert(is_nonpositive(1./neg_infinity));\n+  assert(!is_nonpositive(NaN));\n+}\n+\n+#[test]\n+fn test_nonnegative() {\n+  assert(is_nonnegative(infinity));\n+  assert(is_nonnegative(1.));\n+  assert(is_nonnegative(0.));\n+  assert(!is_nonnegative(-1.));\n+  assert(!is_nonnegative(neg_infinity));\n+  assert(!is_nonnegative(1./neg_infinity));\n+  assert(!is_nonnegative(NaN));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "ca48e83011c4f57b637e738a31b74b27b557084c", "filename": "src/libcore/int.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -180,6 +180,101 @@ fn pow(base: int, exponent: uint) -> int {\n     }\n     ret acc;\n }\n+\n+#[test]\n+fn test_from_str() {\n+    assert(from_str(\"0\") == 0);\n+    assert(from_str(\"3\") == 3);\n+    assert(from_str(\"10\") == 10);\n+    assert(from_str(\"123456789\") == 123456789);\n+    assert(from_str(\"00100\") == 100);\n+\n+    assert(from_str(\"-1\") == -1);\n+    assert(from_str(\"-3\") == -3);\n+    assert(from_str(\"-10\") == -10);\n+    assert(from_str(\"-123456789\") == -123456789);\n+    assert(from_str(\"-00100\") == -100);\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_from_str_fail_1() {\n+    from_str(\" \");\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_from_str_fail_2() {\n+    from_str(\"x\");\n+}\n+\n+#[test]\n+fn test_parse_buf() {\n+    import str::bytes;\n+    assert (parse_buf(bytes(\"123\"), 10u) == 123);\n+    assert (parse_buf(bytes(\"1001\"), 2u) == 9);\n+    assert (parse_buf(bytes(\"123\"), 8u) == 83);\n+    assert (parse_buf(bytes(\"123\"), 16u) == 291);\n+    assert (parse_buf(bytes(\"ffff\"), 16u) == 65535);\n+    assert (parse_buf(bytes(\"FFFF\"), 16u) == 65535);\n+    assert (parse_buf(bytes(\"z\"), 36u) == 35);\n+    assert (parse_buf(bytes(\"Z\"), 36u) == 35);\n+\n+    assert (parse_buf(bytes(\"-123\"), 10u) == -123);\n+    assert (parse_buf(bytes(\"-1001\"), 2u) == -9);\n+    assert (parse_buf(bytes(\"-123\"), 8u) == -83);\n+    assert (parse_buf(bytes(\"-123\"), 16u) == -291);\n+    assert (parse_buf(bytes(\"-ffff\"), 16u) == -65535);\n+    assert (parse_buf(bytes(\"-FFFF\"), 16u) == -65535);\n+    assert (parse_buf(bytes(\"-z\"), 36u) == -35);\n+    assert (parse_buf(bytes(\"-Z\"), 36u) == -35);\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_parse_buf_fail_1() {\n+    parse_buf(str::bytes(\"Z\"), 35u);\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(target_os = \"win32\"))]\n+fn test_parse_buf_fail_2() {\n+    parse_buf(str::bytes(\"-9\"), 2u);\n+}\n+\n+#[test]\n+fn test_to_str() {\n+    import str::eq;\n+    assert (eq(to_str(0, 10u), \"0\"));\n+    assert (eq(to_str(1, 10u), \"1\"));\n+    assert (eq(to_str(-1, 10u), \"-1\"));\n+    assert (eq(to_str(255, 16u), \"ff\"));\n+    assert (eq(to_str(100, 10u), \"100\"));\n+}\n+\n+#[test]\n+fn test_pow() {\n+    assert (pow(0, 0u) == 1);\n+    assert (pow(0, 1u) == 0);\n+    assert (pow(0, 2u) == 0);\n+    assert (pow(-1, 0u) == 1);\n+    assert (pow(1, 0u) == 1);\n+    assert (pow(-3, 2u) == 9);\n+    assert (pow(-3, 3u) == -27);\n+    assert (pow(4, 9u) == 262144);\n+}\n+\n+#[test]\n+fn test_overflows() {\n+   assert (max_value > 0);\n+   assert (min_value <= 0);\n+   assert (min_value + max_value + 1 == 0);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "c2982cf918a807b00084eab9925ec94812174b65", "filename": "src/libcore/math.rs", "status": "modified", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmath.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -16,3 +16,298 @@ Returns the maximum of two values\n */\n pure fn max<T: copy>(x: T, y: T) -> T { x < y ? y : x }\n \n+#[test]\n+fn test_max_min() {\n+    assert max(0, 1) == 1;\n+    assert min(0, 1) == 0;\n+    assert max(0, -1) == 0;\n+    assert min(0, -1) == -1;\n+    assert max(0.0, 1.0) == 1.0;\n+    assert min(0.0, 1.0) == 0.0;\n+}\n+\n+// FIXME use macros to execute the tests below for all float types\n+\n+/*\n+#[test]\n+fn test_trig() {\n+    assert sin(0.0) == 0.0;\n+    assert sin(-0.0) == 0.0;\n+\n+    assert float::isNaN(sin(float::infinity));\n+    assert float::isNaN(sin(float::neg_infinity));\n+\n+    assert cos(0.0) == 1.0;\n+    assert cos(-0.0) == 1.0;\n+    assert float::isNaN(cos(float::infinity));\n+    assert float::isNaN(cos(float::neg_infinity));\n+\n+    assert tan(0.0) == 0.0;\n+    assert tan(-0.0) == 0.0;;\n+    assert float::isNaN(tan(float::infinity));\n+    assert float::isNaN(tan(float::neg_infinity));\n+}\n+\n+#[test]\n+fn test_inv_trig() {\n+    assert asin(0.0) == 0.0;\n+    assert asin(-0.0) == -0.0;\n+    assert float::isNaN(asin(1.1));\n+    assert float::isNaN(asin(-1.1));\n+\n+    assert acos(1.0) == 0.0;\n+    assert float::isNaN(acos(1.1));\n+    assert float::isNaN(acos(-1.1));\n+\n+    assert atan(0.0) == 0.0;\n+    assert atan(-0.0) == 0.0;\n+    assert atan(float::infinity) == consts::frac_pi_2;\n+    assert atan(float::neg_infinity) == - consts::frac_pi_2;\n+\n+    assert atan2(0.0, -0.0) == consts::pi;\n+    assert atan2(-0.0, -0.0) == -consts::pi;\n+\n+    assert atan2(0.0, 0.0) == 0.0;\n+    assert atan2(-0.0, 0.0) == -0.0;\n+\n+    assert atan2(0.0, -1.0) == consts::pi;\n+    assert atan2(-0.0, -1.0) == -consts::pi;\n+\n+    assert atan2(0.0, 1.0) == 0.0;\n+    assert atan2(-0.0, 1.0) == -0.0;\n+\n+    assert atan2(1.0, 0.0) == consts::frac_pi_2;\n+    assert atan2(1.0, -0.0) == consts::frac_pi_2;\n+}\n+\n+// FIXME (1222): The commented-out tests give different results on windows\n+#[test]\n+fn test_pow() {\n+    assert pow(2.0, 4.0) == 16.0;\n+\n+    assert pow(0.0, -3.0) == float::infinity;\n+    assert pow(-0.0, -3.0) == float::neg_infinity;\n+\n+    assert pow(0.0, -4.0) == float::infinity;\n+    assert pow(-0.0, -4.0) == float::infinity;\n+\n+    assert pow(0.0, 3.0) == 0.0;\n+    assert pow(-0.0, 3.0) == -0.0;\n+    assert pow(0.0, 4.0) == 0.0;\n+    assert pow(-0.0, 4.0) == 0.0;\n+\n+    assert pow(-1.0, float::infinity) == 1.0;\n+    //assert pow(-1.0, float::neg_infinity) == 1.0;\n+\n+    assert pow(1.0, 4.0) == 1.0;\n+    assert pow(1.0, 0.0) == 1.0;\n+    assert pow(1.0, -0.0) == 1.0;\n+    //assert pow(1.0, float::NaN) == 1.0;\n+    assert pow(1.0, float::infinity) == 1.0;\n+    //assert pow(1.0, float::neg_infinity) == 1.0;\n+    assert pow(1.0, -3.0) == 1.0;\n+    assert pow(1.0, -4.0) == 1.0;\n+\n+    assert pow(4.0, 0.0) == 1.0;\n+    assert pow(0.0, 0.0) == 1.0;\n+    assert pow(-0.0, 0.0) == 1.0;\n+    //assert pow(float::NaN, 0.0) == 1.0;\n+    assert pow(float::infinity, 0.0) == 1.0;\n+    assert pow(float::neg_infinity, 0.0) == 1.0;\n+    assert pow(-3.0, 0.0) == 1.0;\n+    assert pow(-4.0, 0.0) == 1.0;\n+\n+    assert pow(4.0, -0.0) == 1.0;\n+    assert pow(0.0, -0.0) == 1.0;\n+    assert pow(-0.0, -0.0) == 1.0;\n+    //assert pow(float::NaN, -0.0) == 1.0;\n+    assert pow(float::infinity, -0.0) == 1.0;\n+    assert pow(float::neg_infinity, -0.0) == 1.0;\n+    assert pow(-3.0, -0.0) == 1.0;\n+    assert pow(-4.0, -0.0) == 1.0;\n+\n+    assert float::isNaN(pow(-1.0, -1.5));\n+    assert float::isNaN(pow(-1.0, 1.5));\n+\n+    assert float::isNaN(pow(-1.2, -1.5));\n+    assert float::isNaN(pow(-1.2, 1.5));\n+\n+    assert pow(0.5, float::neg_infinity) == float::infinity;\n+    assert pow(-0.5, float::neg_infinity) == float::infinity;\n+\n+    assert pow(1.5, float::neg_infinity) == 0.0;\n+    assert pow(-1.5, float::neg_infinity) == 0.0;\n+\n+    assert pow(0.5, float::infinity) == 0.0;\n+    assert pow(-0.5, float::infinity) == 0.0;\n+\n+    assert pow(-1.5, float::infinity) == float::infinity;\n+    assert pow(1.5, float::infinity) == float::infinity;\n+\n+    assert pow(float::neg_infinity, -3.0) == -0.0;\n+    assert pow(float::neg_infinity, -4.0) == 0.0;\n+\n+    assert pow(float::neg_infinity, 3.0) == float::neg_infinity;\n+    assert pow(float::neg_infinity, 4.0) == float::infinity;\n+\n+    assert pow(float::infinity, -16.0) == 0.0;\n+    assert pow(float::infinity, 16.0) == float::infinity;\n+}\n+\n+// FIXME (1222): The commented-out tests give different results on windows\n+#[test]\n+fn test_exp_and_mod() {\n+    assert exp(0.0) == 1.0;\n+    assert exp(-0.0) == 1.0;\n+    assert exp(float::neg_infinity) == 0.0;\n+    assert exp(float::infinity) == float::infinity;\n+\n+    let d1: c_int = 1 as c_int;\n+    assert frexp(0.0, d1) == 0.0;\n+    assert frexp(-0.0, d1) == 0.0;\n+    //assert frexp(float::infinity, d1) == float::infinity;\n+    //assert frexp(float::neg_infinity, d1) == float::neg_infinity;\n+    assert float::isNaN(frexp(float::NaN, d1));\n+\n+    let d2: float = 1.0;\n+    assert modf(float::infinity, d2) == 0.0;\n+    assert d2 == float::infinity;\n+    assert modf(float::neg_infinity, d2) == -0.0;\n+    assert d2 == float::neg_infinity;\n+    assert float::isNaN(modf(float::NaN, d2));\n+    assert float::isNaN(d2);\n+}\n+\n+#[test]\n+fn test_round_and_abs() {\n+    assert abs(0.0) == 0.0;\n+    assert abs(-0.0) == 0.0;\n+    assert abs(float::infinity) == float::infinity;\n+    assert abs(float::neg_infinity) == float::infinity;\n+\n+    assert abs(-2.5) == 2.5;\n+    assert abs(2.5) == 2.5;\n+\n+    assert ceil(0.0) == 0.0;\n+    assert ceil(-0.0) == -0.0;\n+    assert ceil(float::infinity) == float::infinity;\n+    assert ceil(float::neg_infinity) == float::neg_infinity;\n+\n+    assert ceil(1.9) == 2.0;\n+    assert ceil(-1.9) == -1.0;\n+\n+    assert floor(0.0) == 0.0;\n+    assert floor(-0.0) == -0.0;\n+    assert floor(float::infinity) == float::infinity;\n+    assert floor(float::neg_infinity) == float::neg_infinity;\n+\n+    assert floor(1.9) == 1.0;\n+    assert floor(-1.9) == -2.0;\n+\n+    assert trunc(0.0) == 0.0;\n+    assert trunc(-0.0) == -0.0;\n+    assert trunc(float::infinity) == float::infinity;\n+    assert trunc(float::neg_infinity) == float::neg_infinity;\n+\n+    assert trunc(1.5) == 1.0;\n+    assert trunc(1.2) == 1.0;\n+    assert trunc(1.0) == 1.0;\n+    assert trunc(1.9) == 1.0;\n+    assert trunc(-1.5) == -1.0;\n+    assert trunc(-1.2) == -1.0;\n+    assert trunc(-1.0) == -1.0;\n+    assert trunc(-1.9) == -1.0;\n+\n+    assert round(0.0) == 0.0;\n+    assert round(-0.0) == -0.0;\n+    assert round(float::infinity) == float::infinity;\n+    assert round(float::neg_infinity) == float::neg_infinity;\n+\n+    assert rint(0.0) == 0.0;\n+    assert rint(-0.0) == -0.0;\n+    assert rint(float::infinity) == float::infinity;\n+    assert rint(float::neg_infinity) == float::neg_infinity;\n+}\n+\n+#[test]\n+fn test_hyp_trig() {\n+    assert sinh(0.0) == 0.0;\n+    assert sinh(-0.0) == 0.0;\n+    assert sinh(float::infinity) == float::infinity;\n+    assert sinh(float::neg_infinity) == float::neg_infinity;\n+\n+    assert cosh(0.0) == 1.0;\n+    assert cosh(-0.0) == 1.0;\n+    assert cosh(float::infinity) == float::infinity;\n+    assert cosh(float::neg_infinity) == float::infinity;\n+\n+    assert tanh(0.0) == 0.0;\n+    assert tanh(-0.0) == 0.0;\n+    assert tanh(float::infinity) == 1.0;\n+    assert tanh(float::neg_infinity) == -1.0;\n+}\n+\n+#[test]\n+fn test_sqrt() {\n+    assert sqrt(9.0) == 3.0;\n+    assert sqrt(4.0) == 2.0;\n+    assert sqrt(1.0) == 1.0;\n+    assert sqrt(0.0) == 0.0;\n+}\n+\n+\n+#[test]\n+fn test_angle() {\n+    fn angle(vec: (float, float)) -> float {\n+        alt vec {\n+          (0f, y) if y < 0f { 1.5 * consts::pi }\n+          (0f, y) { 0.5 * consts::pi }\n+          (x, y) { float::atan(y / x) }\n+        }\n+    }\n+    assert angle((1f, 0f)) == 0f;\n+    assert angle((1f, 1f)) == 0.25 * consts::pi;\n+    assert angle((0f, 1f)) == 0.5 * consts::pi;\n+}\n+\n+\n+#[test]\n+fn test_log_functions() {\n+    assert ln(1.0) == 0.0;\n+    assert log2(1.0) == 0.0;\n+    assert log10(1.0) == 0.0;\n+\n+    // FIXME remove round-up due to valgrind weirdness\n+    assert ceil(ln(consts::e)) == 1.0; /* ln(e) == 0.999.. under valgrind */\n+    assert log2(2.0) == 1.0;\n+    assert log10(10.0) == 1.0;\n+\n+    // FIXME remove round-up due to valgrind weirdness\n+    assert ceil(ln(consts::e*consts::e*consts::e*consts::e)) == 4.0;\n+    assert log2(256.0) == 8.0;\n+    assert log10(1000.0) == 3.0;\n+\n+    assert ln(0.0) == float::neg_infinity;\n+    assert log2(0.0) == float::neg_infinity;\n+    assert log10(0.0) == float::neg_infinity;\n+\n+    assert ln(-0.0) == float::neg_infinity;\n+    assert log2(-0.0) == float::neg_infinity;\n+    assert log10(-0.0) == float::neg_infinity;\n+\n+    assert float::isNaN(ln(-1.0));\n+    assert float::isNaN(log2(-1.0));\n+    assert float::isNaN(log10(-1.0));\n+\n+    assert ln(float::infinity) == float::infinity;\n+    assert log2(float::infinity) == float::infinity;\n+    assert log10(float::infinity) == float::infinity;\n+\n+    assert ln1p(0.0) == 0.0;\n+    assert ln1p(-0.0) == 0.0;\n+    assert ln1p(-1.0) == float::neg_infinity;\n+    assert float::isNaN(ln1p(-2.0f));\n+    assert ln1p(float::infinity) == float::infinity;\n+}\n+\n+*/\n\\ No newline at end of file"}, {"sha": "1dcfed5bc3688149b5ecc7d8ef30444b3a3c8112", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -84,6 +84,9 @@ fn may<T>(opt: t<T>, f: block(T)) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n \n+#[test]\n+fn test() { let _x = some::<int>(10); }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "8ce0730df4f7051dce3b73c33d98cf0f300b23a2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -50,3 +50,20 @@ Function: null\n Create an unsafe null pointer\n */\n fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }\n+\n+#[test]\n+fn test() unsafe {\n+    type pair = {mutable fst: int, mutable snd: int};\n+    let p = {mutable fst: 10, mutable snd: 20};\n+    let pptr: *mutable pair = mut_addr_of(p);\n+    let iptr: *mutable int = unsafe::reinterpret_cast(pptr);\n+    assert (*iptr == 10);;\n+    *iptr = 30;\n+    assert (*iptr == 30);\n+    assert (p.fst == 30);;\n+\n+    *pptr = {mutable fst: 50, mutable snd: 60};\n+    assert (*iptr == 50);\n+    assert (p.fst == 50);\n+    assert (p.snd == 60);\n+}\n\\ No newline at end of file"}, {"sha": "7cb24a7d3d31e37ee9a5d5b58be2d34dcacad503", "filename": "src/libcore/result.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -117,3 +117,22 @@ fn chain<T, U: copy, V: copy>(res: t<T, V>, op: block(T) -> t<U, V>)\n       err(e) { err(e) }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    fn op1() -> result::t<int, str> { result::ok(666) }\n+\n+    fn op2(&&i: int) -> result::t<uint, str> { result::ok(i as uint + 1u) }\n+\n+    fn op3() -> result::t<int, str> { result::err(\"sadface\") }\n+\n+    #[test]\n+    fn chain_success() {\n+        assert get(chain(op1(), op2)) == 667u;\n+    }\n+\n+    #[test]\n+    fn chain_failure() {\n+        assert get_err(chain(op3(), op2)) == \"sadface\";\n+    }\n+}"}, {"sha": "b24c2158d4118315d0bde7a1d3bc3bc9fd14f1e5", "filename": "src/libcore/str.rs", "status": "modified", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1112,3 +1112,464 @@ fn escape(s: str) -> str {\n     loop_chars(s, { |c| r += escape_char(c); true });\n     r\n }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_eq() {\n+        assert (eq(\"\", \"\"));\n+        assert (eq(\"foo\", \"foo\"));\n+        assert (!eq(\"foo\", \"bar\"));\n+    }\n+\n+    #[test]\n+    fn test_lteq() {\n+        assert (lteq(\"\", \"\"));\n+        assert (lteq(\"\", \"foo\"));\n+        assert (lteq(\"foo\", \"foo\"));\n+        assert (!eq(\"foo\", \"bar\"));\n+    }\n+\n+    #[test]\n+    fn test_bytes_len() {\n+        assert (byte_len(\"\") == 0u);\n+        assert (byte_len(\"hello world\") == 11u);\n+        assert (byte_len(\"\\x63\") == 1u);\n+        assert (byte_len(\"\\xa2\") == 2u);\n+        assert (byte_len(\"\\u03c0\") == 2u);\n+        assert (byte_len(\"\\u2620\") == 3u);\n+        assert (byte_len(\"\\U0001d11e\") == 4u);\n+    }\n+\n+    #[test]\n+    fn test_index_and_rindex() {\n+        assert (index(\"hello\", 'e' as u8) == 1);\n+        assert (index(\"hello\", 'o' as u8) == 4);\n+        assert (index(\"hello\", 'z' as u8) == -1);\n+        assert (rindex(\"hello\", 'l' as u8) == 3);\n+        assert (rindex(\"hello\", 'h' as u8) == 0);\n+        assert (rindex(\"hello\", 'z' as u8) == -1);\n+    }\n+\n+    #[test]\n+    fn test_split() {\n+        fn t(s: str, c: char, u: [str]) {\n+            log(debug, \"split: \" + s);\n+            let v = split(s, c as u8);\n+            #debug(\"split to: \");\n+            log(debug, v);\n+            assert (vec::all2(v, u, { |a,b| a == b }));\n+        }\n+        t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n+        t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n+        t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+    }\n+\n+    #[test]\n+    fn test_splitn() {\n+        fn t(s: str, c: char, n: uint, u: [str]) {\n+            log(debug, \"splitn: \" + s);\n+            let v = splitn(s, c as u8, n);\n+            #debug(\"split to: \");\n+            log(debug, v);\n+            #debug(\"comparing vs. \");\n+            log(debug, u);\n+            assert (vec::all2(v, u, { |a,b| a == b }));\n+        }\n+        t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]);\n+        t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]);\n+        t(\"abc.hello.there\", '.', 2u, [\"abc\", \"hello\", \"there\"]);\n+        t(\"abc.hello.there\", '.', 3u, [\"abc\", \"hello\", \"there\"]);\n+        t(\".hello.there\", '.', 0u, [\".hello.there\"]);\n+        t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]);\n+        t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n+        t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+    }\n+\n+    #[test]\n+    fn test_split_str() {\n+        fn t(s: str, sep: str, i: int, k: str) {\n+            let v = split_str(s, sep);\n+            assert eq(v[i], k);\n+        }\n+\n+        //FIXME: should behave like split and split_char:\n+        //assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n+\n+        t(\"abc::hello::there\", \"::\", 0, \"abc\");\n+        t(\"abc::hello::there\", \"::\", 1, \"hello\");\n+        t(\"abc::hello::there\", \"::\", 2, \"there\");\n+        t(\"::hello::there\", \"::\", 0, \"hello\");\n+        t(\"hello::there::\", \"::\", 2, \"\");\n+        t(\"::hello::there::\", \"::\", 2, \"\");\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 0, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\");\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 1, \"Vi\u1ec7t Nam\");\n+    }\n+\n+    #[test]\n+    fn test_split_func () {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+            == split_func (data, {|cc| cc == '\u534e'});\n+\n+        assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n+            == split_func(\"zzXXXzYYYz\", char::is_lowercase);\n+\n+        assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n+            == split_func(\"zzXXXzYYYz\", char::is_uppercase);\n+\n+        assert [\"\",\"\"] == split_func(\"z\", {|cc| cc == 'z'});\n+        assert [\"\"] == split_func(\"\", {|cc| cc == 'z'});\n+        assert [\"ok\"] == split_func(\"ok\", {|cc| cc == 'z'});\n+    }\n+\n+    #[test]\n+    fn test_split_char () {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+            == split_char(data, '\u534e');\n+\n+        assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n+            == split_char(\"zzXXXzYYYz\", 'z');\n+        assert [\"\",\"\"] == split_char(\"z\", 'z');\n+        assert [\"\"] == split_char(\"\", 'z');\n+        assert [\"ok\"] == split_char(\"ok\", 'z');\n+    }\n+\n+    #[test]\n+    fn test_lines () {\n+        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n+\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+            == lines(lf);\n+\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+            == lines_any(lf);\n+\n+        assert [\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]\n+            == lines(crlf);\n+\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+            == lines_any(crlf);\n+\n+        assert [\"\"] == lines    (\"\");\n+        assert [\"\"] == lines_any(\"\");\n+        assert [\"\",\"\"] == lines    (\"\\n\");\n+        assert [\"\",\"\"] == lines_any(\"\\n\");\n+        assert [\"banana\"] == lines    (\"banana\");\n+        assert [\"banana\"] == lines_any(\"banana\");\n+    }\n+\n+    #[test]\n+    fn test_words () {\n+        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        assert [\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]\n+            == words(data);\n+\n+        assert [\"ok\"] == words(\"ok\");\n+        assert [] == words(\"\");\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        fn t(haystack: str, needle: str, i: int) {\n+            let j: int = find(haystack, needle);\n+            log(debug, \"searched for \" + needle);\n+            log(debug, j);\n+            assert (i == j);\n+        }\n+        t(\"this is a simple\", \"is a\", 5);\n+        t(\"this is a simple\", \"is z\", -1);\n+        t(\"this is a simple\", \"\", 0);\n+        t(\"this is a simple\", \"simple\", 10);\n+        t(\"this\", \"simple\", -1);\n+    }\n+\n+    #[test]\n+    fn test_substr() {\n+        fn t(a: str, b: str, start: int) {\n+            assert (eq(substr(a, start as uint, byte_len(b)), b));\n+        }\n+        t(\"hello\", \"llo\", 2);\n+        t(\"hello\", \"el\", 1);\n+        t(\"substr should not be a challenge\", \"not\", 14);\n+    }\n+\n+    #[test]\n+    fn test_concat() {\n+        fn t(v: [str], s: str) { assert (eq(concat(v), s)); }\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n+        let v: [str] = [];\n+        t(v, \"\");\n+        t([\"hi\"], \"hi\");\n+    }\n+\n+    #[test]\n+    fn test_connect() {\n+        fn t(v: [str], sep: str, s: str) {\n+            assert (eq(connect(v, sep), s));\n+        }\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n+        let v: [str] = [];\n+        t(v, \" \", \"\");\n+        t([\"hi\"], \" \", \"hi\");\n+    }\n+\n+    #[test]\n+    fn test_to_upper() {\n+        // to_upper doesn't understand unicode yet,\n+        // but we need to at least preserve it\n+\n+        let unicode = \"\\u65e5\\u672c\";\n+        let input = \"abcDEF\" + unicode + \"xyz:.;\";\n+        let expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n+        let actual = to_upper(input);\n+        assert (eq(expected, actual));\n+    }\n+\n+    #[test]\n+    fn test_slice() {\n+        assert (eq(\"ab\", slice(\"abc\", 0u, 2u)));\n+        assert (eq(\"bc\", slice(\"abc\", 1u, 3u)));\n+        assert (eq(\"\", slice(\"abc\", 1u, 1u)));\n+        fn a_million_letter_a() -> str {\n+            let i = 0;\n+            let rs = \"\";\n+            while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n+            ret rs;\n+        }\n+        fn half_a_million_letter_a() -> str {\n+            let i = 0;\n+            let rs = \"\";\n+            while i < 100000 { rs += \"aaaaa\"; i += 1; }\n+            ret rs;\n+        }\n+        assert (eq(half_a_million_letter_a(),\n+                        slice(a_million_letter_a(), 0u, 500000u)));\n+    }\n+\n+    #[test]\n+    fn test_starts_with() {\n+        assert (starts_with(\"\", \"\"));\n+        assert (starts_with(\"abc\", \"\"));\n+        assert (starts_with(\"abc\", \"a\"));\n+        assert (!starts_with(\"a\", \"abc\"));\n+        assert (!starts_with(\"\", \"abc\"));\n+    }\n+\n+    #[test]\n+    fn test_ends_with() {\n+        assert (ends_with(\"\", \"\"));\n+        assert (ends_with(\"abc\", \"\"));\n+        assert (ends_with(\"abc\", \"c\"));\n+        assert (!ends_with(\"a\", \"abc\"));\n+        assert (!ends_with(\"\", \"abc\"));\n+    }\n+\n+    #[test]\n+    fn test_is_empty() {\n+        assert (is_empty(\"\"));\n+        assert (!is_empty(\"a\"));\n+    }\n+\n+    #[test]\n+    fn test_is_not_empty() {\n+        assert (is_not_empty(\"a\"));\n+        assert (!is_not_empty(\"\"));\n+    }\n+\n+    #[test]\n+    fn test_replace() {\n+        let a = \"a\";\n+        check (is_not_empty(a));\n+        assert (replace(\"\", a, \"b\") == \"\");\n+        assert (replace(\"a\", a, \"b\") == \"b\");\n+        assert (replace(\"ab\", a, \"b\") == \"bb\");\n+        let test = \"test\";\n+        check (is_not_empty(test));\n+        assert (replace(\" test test \", test, \"toast\") == \" toast toast \");\n+        assert (replace(\" test test \", test, \"\") == \"   \");\n+    }\n+\n+    #[test]\n+    fn test_char_slice() {\n+        assert (eq(\"ab\", char_slice(\"abc\", 0u, 2u)));\n+        assert (eq(\"bc\", char_slice(\"abc\", 1u, 3u)));\n+        assert (eq(\"\", char_slice(\"abc\", 1u, 1u)));\n+        assert (eq(\"\\u65e5\", char_slice(\"\\u65e5\\u672c\", 0u, 1u)));\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert (eq(\"\u0e1b\", char_slice(data, 0u, 1u)));\n+        assert (eq(\"\u0e23\", char_slice(data, 1u, 2u)));\n+        assert (eq(\"\u534e\", char_slice(data, 10u, 11u)));\n+        assert (eq(\"\", char_slice(data, 1u, 1u)));\n+\n+        fn a_million_letter_X() -> str {\n+            let i = 0;\n+            let rs = \"\";\n+            while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n+            ret rs;\n+        }\n+        fn half_a_million_letter_X() -> str {\n+            let i = 0;\n+            let rs = \"\";\n+            while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n+            ret rs;\n+        }\n+        assert (eq(half_a_million_letter_X(),\n+                        char_slice(a_million_letter_X(), 0u, 500000u)));\n+    }\n+\n+    #[test]\n+    fn test_trim_left() {\n+        assert (trim_left(\"\") == \"\");\n+        assert (trim_left(\"a\") == \"a\");\n+        assert (trim_left(\"    \") == \"\");\n+        assert (trim_left(\"     blah\") == \"blah\");\n+        assert (trim_left(\"   \\u3000  wut\") == \"wut\");\n+        assert (trim_left(\"hey \") == \"hey \");\n+    }\n+\n+    #[test]\n+    fn test_trim_right() {\n+        assert (trim_right(\"\") == \"\");\n+        assert (trim_right(\"a\") == \"a\");\n+        assert (trim_right(\"    \") == \"\");\n+        assert (trim_right(\"blah     \") == \"blah\");\n+        assert (trim_right(\"wut   \\u3000  \") == \"wut\");\n+        assert (trim_right(\" hey\") == \" hey\");\n+    }\n+\n+    #[test]\n+    fn test_trim() {\n+        assert (trim(\"\") == \"\");\n+        assert (trim(\"a\") == \"a\");\n+        assert (trim(\"    \") == \"\");\n+        assert (trim(\"    blah     \") == \"blah\");\n+        assert (trim(\"\\nwut   \\u3000  \") == \"wut\");\n+        assert (trim(\" hey dude \") == \"hey dude\");\n+    }\n+\n+    #[test]\n+    fn test_is_whitespace() {\n+        assert (is_whitespace(\"\"));\n+        assert (is_whitespace(\" \"));\n+        assert (is_whitespace(\"\\u2009\")); // Thin space\n+        assert (is_whitespace(\"  \\n\\t   \"));\n+        assert (!is_whitespace(\"   _   \"));\n+    }\n+\n+    #[test]\n+    fn test_is_ascii() {\n+        assert (is_ascii(\"\"));\n+        assert (is_ascii(\"a\"));\n+        assert (!is_ascii(\"\\u2009\"));\n+    }\n+\n+    #[test]\n+    fn test_shift_byte() {\n+        let s = \"ABC\";\n+        let b = shift_byte(s);\n+        assert (s == \"BC\");\n+        assert (b == 65u8);\n+    }\n+\n+    #[test]\n+    fn test_pop_byte() {\n+        let s = \"ABC\";\n+        let b = pop_byte(s);\n+        assert (s == \"AB\");\n+        assert (b == 67u8);\n+    }\n+\n+    #[test]\n+    fn test_unsafe_from_bytes() {\n+        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n+        let b = unsafe_from_bytes(a);\n+        assert (b == \"AAAAAAA\");\n+    }\n+\n+    #[test]\n+    fn test_from_cstr() unsafe {\n+        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+        let b = vec::to_ptr(a);\n+        let c = from_cstr(b);\n+        assert (c == \"AAAAAAA\");\n+    }\n+\n+    #[test]\n+    fn test_as_buf() unsafe {\n+        let a = \"Abcdefg\";\n+        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        assert (b == 100);\n+    }\n+\n+    #[test]\n+    fn test_as_buf_small() unsafe {\n+        let a = \"A\";\n+        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        assert (b == 100);\n+    }\n+\n+    #[test]\n+    fn test_as_buf2() unsafe {\n+        let s = \"hello\";\n+        let sb = as_buf(s, {|b| b });\n+        let s_cstr = from_cstr(sb);\n+        assert (eq(s_cstr, s));\n+    }\n+\n+    #[test]\n+    fn vec_str_conversions() {\n+        let s1: str = \"All mimsy were the borogoves\";\n+\n+        let v: [u8] = bytes(s1);\n+        let s2: str = unsafe_from_bytes(v);\n+        let i: uint = 0u;\n+        let n1: uint = byte_len(s1);\n+        let n2: uint = vec::len::<u8>(v);\n+        assert (n1 == n2);\n+        while i < n1 {\n+            let a: u8 = s1[i];\n+            let b: u8 = s2[i];\n+            log(debug, a);\n+            log(debug, b);\n+            assert (a == b);\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_contains() {\n+        assert contains(\"abcde\", \"bcd\");\n+        assert contains(\"abcde\", \"abcd\");\n+        assert contains(\"abcde\", \"bcde\");\n+        assert contains(\"abcde\", \"\");\n+        assert contains(\"\", \"\");\n+        assert !contains(\"abcde\", \"def\");\n+        assert !contains(\"\", \"a\");\n+    }\n+\n+    #[test]\n+    fn test_iter_chars() {\n+        let i = 0;\n+        iter_chars(\"x\\u03c0y\") {|ch|\n+            alt i {\n+              0 { assert ch == 'x'; }\n+              1 { assert ch == '\\u03c0'; }\n+              2 { assert ch == 'y'; }\n+            }\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_escape() {\n+        assert(escape(\"abcdef\") == \"abcdef\");\n+        assert(escape(\"abc\\\\def\") == \"abc\\\\\\\\def\");\n+        assert(escape(\"abc\\ndef\") == \"abc\\\\ndef\");\n+        assert(escape(\"abc\\\"def\") == \"abc\\\\\\\"def\");\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "7360ca3521a8ccd141cefda3864932539ae8f55d", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -122,6 +122,60 @@ fn set_min_stack(size: uint) {\n     rustrt::set_min_stack(size);\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn last_os_error() {\n+        log(debug, last_os_error());\n+    }\n+\n+    #[test]\n+    fn size_of_basic() {\n+        assert size_of::<u8>() == 1u;\n+        assert size_of::<u16>() == 2u;\n+        assert size_of::<u32>() == 4u;\n+        assert size_of::<u64>() == 8u;\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    fn size_of_32() {\n+        assert size_of::<uint>() == 4u;\n+        assert size_of::<*uint>() == 4u;\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn size_of_64() {\n+        assert size_of::<uint>() == 8u;\n+        assert size_of::<*uint>() == 8u;\n+    }\n+\n+    #[test]\n+    fn align_of_basic() {\n+        assert align_of::<u8>() == 1u;\n+        assert align_of::<u16>() == 2u;\n+        assert align_of::<u32>() == 4u;\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    fn align_of_32() {\n+        assert align_of::<uint>() == 4u;\n+        assert align_of::<*uint>() == 4u;\n+    }\n+\n+    #[test]\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn align_of_64() {\n+        assert align_of::<uint>() == 8u;\n+        assert align_of::<*uint>() == 8u;\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "6f3e7b0f0654fba4a6257949476e927517f1d4d4", "filename": "src/libcore/task.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -374,6 +374,85 @@ fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_sleep() { sleep(1000000u); }\n+\n+    // FIXME: Leaks on windows\n+    #[test]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_unsupervise() {\n+        fn f() { unsupervise(); fail; }\n+        spawn {|| f();};\n+    }\n+\n+    #[test]\n+    fn test_lib_spawn() {\n+        fn foo() { #error(\"Hello, World!\"); }\n+        spawn {|| foo();};\n+    }\n+\n+    #[test]\n+    fn test_lib_spawn2() {\n+        fn foo(x: int) { assert (x == 42); }\n+        spawn {|| foo(42);};\n+    }\n+\n+    #[test]\n+    fn test_join_chan() {\n+        fn winner() { }\n+\n+        let t = spawn_joinable {|| winner();};\n+        alt join(t) {\n+          tr_success. {/* yay! */ }\n+          _ { fail \"invalid task status received\" }\n+        }\n+    }\n+\n+    // FIXME: Leaks on windows\n+    #[test]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_join_chan_fail() {\n+        fn failer() { unsupervise(); fail }\n+\n+        let t = spawn_joinable {|| failer();};\n+        alt join(t) {\n+          tr_failure. {/* yay! */ }\n+          _ { fail \"invalid task status received\" }\n+        }\n+    }\n+\n+    #[test]\n+    fn spawn_polymorphic() {\n+        fn foo<T:send>(x: T) { log(error, x); }\n+        spawn {|| foo(true);};\n+        spawn {|| foo(42);};\n+    }\n+\n+    #[test]\n+    fn try_success() {\n+        alt try {||\n+            \"Success!\"\n+        } {\n+            result::ok(\"Success!\") { }\n+            _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn try_fail() {\n+        alt try {||\n+            fail\n+        } {\n+            result::err(()) { }\n+            _ { fail; }\n+        }\n+    }\n+}\n+\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "598c6baffe4f0c1d7c7c0b5331d48d8a62f44bd0", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -252,6 +252,116 @@ Convert to a string\n */\n fn str(i: uint) -> str { ret to_str(i, 10u); }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert (uint::from_str(\"0\") == 0u);\n+        assert (uint::from_str(\"3\") == 3u);\n+        assert (uint::from_str(\"10\") == 10u);\n+        assert (uint::from_str(\"123456789\") == 123456789u);\n+        assert (uint::from_str(\"00100\") == 100u);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_from_str_fail_1() {\n+        uint::from_str(\" \");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_from_str_fail_2() {\n+        uint::from_str(\"x\");\n+    }\n+\n+    #[test]\n+    fn test_parse_buf() {\n+        import str::bytes;\n+        assert (uint::parse_buf(bytes(\"123\"), 10u) == 123u);\n+        assert (uint::parse_buf(bytes(\"1001\"), 2u) == 9u);\n+        assert (uint::parse_buf(bytes(\"123\"), 8u) == 83u);\n+        assert (uint::parse_buf(bytes(\"123\"), 16u) == 291u);\n+        assert (uint::parse_buf(bytes(\"ffff\"), 16u) == 65535u);\n+        assert (uint::parse_buf(bytes(\"z\"), 36u) == 35u);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_parse_buf_fail_1() {\n+        uint::parse_buf(str::bytes(\"Z\"), 10u);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_parse_buf_fail_2() {\n+        uint::parse_buf(str::bytes(\"_\"), 2u);\n+    }\n+\n+    #[test]\n+    fn test_next_power_of_two() {\n+        assert (uint::next_power_of_two(0u) == 0u);\n+        assert (uint::next_power_of_two(1u) == 1u);\n+        assert (uint::next_power_of_two(2u) == 2u);\n+        assert (uint::next_power_of_two(3u) == 4u);\n+        assert (uint::next_power_of_two(4u) == 4u);\n+        assert (uint::next_power_of_two(5u) == 8u);\n+        assert (uint::next_power_of_two(6u) == 8u);\n+        assert (uint::next_power_of_two(7u) == 8u);\n+        assert (uint::next_power_of_two(8u) == 8u);\n+        assert (uint::next_power_of_two(9u) == 16u);\n+        assert (uint::next_power_of_two(10u) == 16u);\n+        assert (uint::next_power_of_two(11u) == 16u);\n+        assert (uint::next_power_of_two(12u) == 16u);\n+        assert (uint::next_power_of_two(13u) == 16u);\n+        assert (uint::next_power_of_two(14u) == 16u);\n+        assert (uint::next_power_of_two(15u) == 16u);\n+        assert (uint::next_power_of_two(16u) == 16u);\n+        assert (uint::next_power_of_two(17u) == 32u);\n+        assert (uint::next_power_of_two(18u) == 32u);\n+        assert (uint::next_power_of_two(19u) == 32u);\n+        assert (uint::next_power_of_two(20u) == 32u);\n+        assert (uint::next_power_of_two(21u) == 32u);\n+        assert (uint::next_power_of_two(22u) == 32u);\n+        assert (uint::next_power_of_two(23u) == 32u);\n+        assert (uint::next_power_of_two(24u) == 32u);\n+        assert (uint::next_power_of_two(25u) == 32u);\n+        assert (uint::next_power_of_two(26u) == 32u);\n+        assert (uint::next_power_of_two(27u) == 32u);\n+        assert (uint::next_power_of_two(28u) == 32u);\n+        assert (uint::next_power_of_two(29u) == 32u);\n+        assert (uint::next_power_of_two(30u) == 32u);\n+        assert (uint::next_power_of_two(31u) == 32u);\n+        assert (uint::next_power_of_two(32u) == 32u);\n+        assert (uint::next_power_of_two(33u) == 64u);\n+        assert (uint::next_power_of_two(34u) == 64u);\n+        assert (uint::next_power_of_two(35u) == 64u);\n+        assert (uint::next_power_of_two(36u) == 64u);\n+        assert (uint::next_power_of_two(37u) == 64u);\n+        assert (uint::next_power_of_two(38u) == 64u);\n+        assert (uint::next_power_of_two(39u) == 64u);\n+    }\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert (uint::max_value > 0u);\n+        assert (uint::min_value <= 0u);\n+        assert (uint::min_value + uint::max_value + 1u == 0u);\n+    }\n+\n+    #[test]\n+    fn test_div() {\n+        assert(uint::div_floor(3u, 4u) == 0u);\n+        assert(uint::div_ceil(3u, 4u)  == 1u);\n+        assert(uint::div_round(3u, 4u) == 1u);\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "b069c62d41e90fa3fbab345bd71016e411bd5151", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -4,6 +4,8 @@ Module: unsafe\n Unsafe operations\n */\n \n+export reinterpret_cast, leak;\n+\n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn cast<T, U>(src: T) -> U;\n@@ -39,3 +41,19 @@ can be used for various acts of magick, particularly when using\n reinterpret_cast on managed pointer types.\n */\n unsafe fn leak<T>(-thing: T) { rustrt::leak(thing); }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_reinterpret_cast() unsafe {\n+        assert reinterpret_cast(1) == 1u;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_reinterpret_cast_wrong_size() unsafe {\n+        let _i: uint = reinterpret_cast(0u8);\n+    }\n+}"}, {"sha": "c4ddde19e9442cb6b443602070755f312cc09a9a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -981,6 +981,524 @@ mod u8 {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    fn square(n: uint) -> uint { ret n * n; }\n+\n+    fn square_ref(&&n: uint) -> uint { ret n * n; }\n+\n+    pure fn is_three(&&n: uint) -> bool { ret n == 3u; }\n+\n+    pure fn is_odd(&&n: uint) -> bool { ret n % 2u == 1u; }\n+\n+    pure fn is_equal(&&x: uint, &&y:uint) -> bool { ret x == y; }\n+\n+    fn square_if_odd(&&n: uint) -> option::t<uint> {\n+        ret if n % 2u == 1u { some(n * n) } else { none };\n+    }\n+\n+    fn add(&&x: uint, &&y: uint) -> uint { ret x + y; }\n+\n+    #[test]\n+    fn test_unsafe_ptrs() unsafe {\n+        // Test on-stack copy-from-buf.\n+        let a = [1, 2, 3];\n+        let ptr = to_ptr(a);\n+        let b = unsafe::from_buf(ptr, 3u);\n+        assert (len(b) == 3u);\n+        assert (b[0] == 1);\n+        assert (b[1] == 2);\n+        assert (b[2] == 3);\n+\n+        // Test on-heap copy-from-buf.\n+        let c = [1, 2, 3, 4, 5];\n+        ptr = to_ptr(c);\n+        let d = unsafe::from_buf(ptr, 5u);\n+        assert (len(d) == 5u);\n+        assert (d[0] == 1);\n+        assert (d[1] == 2);\n+        assert (d[2] == 3);\n+        assert (d[3] == 4);\n+        assert (d[4] == 5);\n+    }\n+\n+    #[test]\n+    fn test_init_fn() {\n+        // Test on-stack init_fn.\n+        let v = init_fn(square, 3u);\n+        assert (len(v) == 3u);\n+        assert (v[0] == 0u);\n+        assert (v[1] == 1u);\n+        assert (v[2] == 4u);\n+\n+        // Test on-heap init_fn.\n+        v = init_fn(square, 5u);\n+        assert (len(v) == 5u);\n+        assert (v[0] == 0u);\n+        assert (v[1] == 1u);\n+        assert (v[2] == 4u);\n+        assert (v[3] == 9u);\n+        assert (v[4] == 16u);\n+    }\n+\n+    #[test]\n+    fn test_init_elt() {\n+        // Test on-stack init_elt.\n+        let v = init_elt(10u, 2u);\n+        assert (len(v) == 2u);\n+        assert (v[0] == 10u);\n+        assert (v[1] == 10u);\n+\n+        // Test on-heap init_elt.\n+        v = init_elt(20u, 6u);\n+        assert (v[0] == 20u);\n+        assert (v[1] == 20u);\n+        assert (v[2] == 20u);\n+        assert (v[3] == 20u);\n+        assert (v[4] == 20u);\n+        assert (v[5] == 20u);\n+    }\n+\n+    #[test]\n+    fn test_is_empty() {\n+        assert (is_empty::<int>([]));\n+        assert (!is_empty([0]));\n+    }\n+\n+    #[test]\n+    fn test_is_not_empty() {\n+        assert (is_not_empty([0]));\n+        assert (!is_not_empty::<int>([]));\n+    }\n+\n+    #[test]\n+    fn test_head() {\n+        let a = [11, 12];\n+        check (is_not_empty(a));\n+        assert (head(a) == 11);\n+    }\n+\n+    #[test]\n+    fn test_tail() {\n+        let a = [11];\n+        check (is_not_empty(a));\n+        assert (tail(a) == []);\n+\n+        a = [11, 12];\n+        check (is_not_empty(a));\n+        assert (tail(a) == [12]);\n+    }\n+\n+    #[test]\n+    fn test_last() {\n+        let n = last([]);\n+        assert (n == none);\n+        n = last([1, 2, 3]);\n+        assert (n == some(3));\n+        n = last([1, 2, 3, 4, 5]);\n+        assert (n == some(5));\n+    }\n+\n+    #[test]\n+    fn test_slice() {\n+        // Test on-stack -> on-stack slice.\n+        let v = slice([1, 2, 3], 1u, 3u);\n+        assert (len(v) == 2u);\n+        assert (v[0] == 2);\n+        assert (v[1] == 3);\n+\n+        // Test on-heap -> on-stack slice.\n+        v = slice([1, 2, 3, 4, 5], 0u, 3u);\n+        assert (len(v) == 3u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 2);\n+        assert (v[2] == 3);\n+\n+        // Test on-heap -> on-heap slice.\n+        v = slice([1, 2, 3, 4, 5, 6], 1u, 6u);\n+        assert (len(v) == 5u);\n+        assert (v[0] == 2);\n+        assert (v[1] == 3);\n+        assert (v[2] == 4);\n+        assert (v[3] == 5);\n+        assert (v[4] == 6);\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        // Test on-stack pop.\n+        let v = [1, 2, 3];\n+        let e = pop(v);\n+        assert (len(v) == 2u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 2);\n+        assert (e == 3);\n+\n+        // Test on-heap pop.\n+        v = [1, 2, 3, 4, 5];\n+        e = pop(v);\n+        assert (len(v) == 4u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 2);\n+        assert (v[2] == 3);\n+        assert (v[3] == 4);\n+        assert (e == 5);\n+    }\n+\n+    #[test]\n+    fn test_push() {\n+        // Test on-stack push().\n+        let v = [];\n+        push(v, 1);\n+        assert (len(v) == 1u);\n+        assert (v[0] == 1);\n+\n+        // Test on-heap push().\n+        push(v, 2);\n+        assert (len(v) == 2u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 2);\n+    }\n+\n+    #[test]\n+    fn test_grow() {\n+        // Test on-stack grow().\n+        let v = [];\n+        grow(v, 2u, 1);\n+        assert (len(v) == 2u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 1);\n+\n+        // Test on-heap grow().\n+        grow(v, 3u, 2);\n+        assert (len(v) == 5u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 1);\n+        assert (v[2] == 2);\n+        assert (v[3] == 2);\n+        assert (v[4] == 2);\n+    }\n+\n+    #[test]\n+    fn test_grow_fn() {\n+        let v = [];\n+        grow_fn(v, 3u, square);\n+        assert (len(v) == 3u);\n+        assert (v[0] == 0u);\n+        assert (v[1] == 1u);\n+        assert (v[2] == 4u);\n+    }\n+\n+    #[test]\n+    fn test_grow_set() {\n+        let v = [mutable 1, 2, 3];\n+        grow_set(v, 4u, 4, 5);\n+        assert (len(v) == 5u);\n+        assert (v[0] == 1);\n+        assert (v[1] == 2);\n+        assert (v[2] == 3);\n+        assert (v[3] == 4);\n+        assert (v[4] == 5);\n+    }\n+\n+    #[test]\n+    fn test_map() {\n+        // Test on-stack map.\n+        let v = [1u, 2u, 3u];\n+        let w = map(v, square_ref);\n+        assert (len(w) == 3u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 4u);\n+        assert (w[2] == 9u);\n+\n+        // Test on-heap map.\n+        v = [1u, 2u, 3u, 4u, 5u];\n+        w = map(v, square_ref);\n+        assert (len(w) == 5u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 4u);\n+        assert (w[2] == 9u);\n+        assert (w[3] == 16u);\n+        assert (w[4] == 25u);\n+    }\n+\n+    #[test]\n+    fn test_map2() {\n+        fn times(&&x: int, &&y: int) -> int { ret x * y; }\n+        let f = times;\n+        let v0 = [1, 2, 3, 4, 5];\n+        let v1 = [5, 4, 3, 2, 1];\n+        let u = map2::<int, int, int>(v0, v1, f);\n+        let i = 0;\n+        while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n+    }\n+\n+    #[test]\n+    fn test_filter_map() {\n+        // Test on-stack filter-map.\n+        let v = [1u, 2u, 3u];\n+        let w = filter_map(v, square_if_odd);\n+        assert (len(w) == 2u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+\n+        // Test on-heap filter-map.\n+        v = [1u, 2u, 3u, 4u, 5u];\n+        w = filter_map(v, square_if_odd);\n+        assert (len(w) == 3u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+        assert (w[2] == 25u);\n+\n+        fn halve(&&i: int) -> option::t<int> {\n+            if i % 2 == 0 {\n+                ret option::some::<int>(i / 2);\n+            } else { ret option::none::<int>; }\n+        }\n+        fn halve_for_sure(&&i: int) -> int { ret i / 2; }\n+        let all_even: [int] = [0, 2, 8, 6];\n+        let all_odd1: [int] = [1, 7, 3];\n+        let all_odd2: [int] = [];\n+        let mix: [int] = [9, 2, 6, 7, 1, 0, 0, 3];\n+        let mix_dest: [int] = [1, 3, 0, 0];\n+        assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n+        assert (filter_map(all_odd1, halve) == []);\n+        assert (filter_map(all_odd2, halve) == []);\n+        assert (filter_map(mix, halve) == mix_dest);\n+    }\n+\n+    #[test]\n+    fn test_filter() {\n+        assert filter([1u, 2u, 3u], is_odd) == [1u, 3u];\n+        assert filter([1u, 2u, 4u, 8u, 16u], is_three) == [];\n+    }\n+\n+    #[test]\n+    fn test_foldl() {\n+        // Test on-stack fold.\n+        let v = [1u, 2u, 3u];\n+        let sum = foldl(0u, v, add);\n+        assert (sum == 6u);\n+\n+        // Test on-heap fold.\n+        v = [1u, 2u, 3u, 4u, 5u];\n+        sum = foldl(0u, v, add);\n+        assert (sum == 15u);\n+    }\n+\n+    #[test]\n+    fn test_foldl2() {\n+        fn sub(&&a: int, &&b: int) -> int {\n+            a - b\n+        }\n+        let v = [1, 2, 3, 4];\n+        let sum = foldl(0, v, sub);\n+        assert sum == -10;\n+    }\n+\n+    #[test]\n+    fn test_foldr() {\n+        fn sub(&&a: int, &&b: int) -> int {\n+            a - b\n+        }\n+        let v = [1, 2, 3, 4];\n+        let sum = foldr(v, 0, sub);\n+        assert sum == -2;\n+    }\n+\n+    #[test]\n+    fn test_iter_empty() {\n+        let i = 0;\n+        iter::<int>([], { |_v| i += 1 });\n+        assert i == 0;\n+    }\n+\n+    #[test]\n+    fn test_iter_nonempty() {\n+        let i = 0;\n+        iter([1, 2, 3], { |v| i += v });\n+        assert i == 6;\n+    }\n+\n+    #[test]\n+    fn test_iteri() {\n+        let i = 0;\n+        iteri([1, 2, 3], { |j, v|\n+            if i == 0 { assert v == 1; }\n+            assert j + 1u == v as uint;\n+            i += v;\n+        });\n+        assert i == 6;\n+    }\n+\n+    #[test]\n+    fn test_riter_empty() {\n+        let i = 0;\n+        riter::<int>([], { |_v| i += 1 });\n+        assert i == 0;\n+    }\n+\n+    #[test]\n+    fn test_riter_nonempty() {\n+        let i = 0;\n+        riter([1, 2, 3], { |v|\n+            if i == 0 { assert v == 3; }\n+            i += v\n+        });\n+        assert i == 6;\n+    }\n+\n+    #[test]\n+    fn test_riteri() {\n+        let i = 0;\n+        riteri([0, 1, 2], { |j, v|\n+            if i == 0 { assert v == 2; }\n+            assert j == v as uint;\n+            i += v;\n+        });\n+        assert i == 3;\n+    }\n+\n+    #[test]\n+    fn test_permute() {\n+        let results: [[int]];\n+\n+        results = [];\n+        permute([]) {|v| results += [v]; }\n+        assert results == [[]];\n+\n+        results = [];\n+        permute([7]) {|v| results += [v]; }\n+        assert results == [[7]];\n+\n+        results = [];\n+        permute([1,1]) {|v| results += [v]; }\n+        assert results == [[1,1],[1,1]];\n+\n+        results = [];\n+        permute([5,2,0]) {|v| results += [v]; }\n+        assert results == [[5,2,0],[5,0,2],[2,5,0],[2,0,5],[0,5,2],[0,2,5]];\n+    }\n+\n+    #[test]\n+    fn test_any_and_all() {\n+        assert (any([1u, 2u, 3u], is_three));\n+        assert (!any([0u, 1u, 2u], is_three));\n+        assert (any([1u, 2u, 3u, 4u, 5u], is_three));\n+        assert (!any([1u, 2u, 4u, 5u, 6u], is_three));\n+\n+        assert (all([3u, 3u, 3u], is_three));\n+        assert (!all([3u, 3u, 2u], is_three));\n+        assert (all([3u, 3u, 3u, 3u, 3u], is_three));\n+        assert (!all([3u, 3u, 0u, 1u, 2u], is_three));\n+    }\n+\n+    #[test]\n+    fn test_any2_and_all2() {\n+\n+        assert (any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+        assert (any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+        assert (!any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+        assert (any2([2u, 4u, 6u], [2u, 4u], is_equal));\n+\n+        assert (all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n+        assert (!all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n+        assert (!all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n+        assert (!all2([2u, 4u, 6u], [2u, 4u], is_equal));\n+    }\n+\n+    #[test]\n+    fn test_zip_unzip() {\n+        let v1 = [1, 2, 3];\n+        let v2 = [4, 5, 6];\n+\n+        check (same_length(v1, v2)); // Silly, but what else can we do?\n+        let z1 = zip(v1, v2);\n+\n+        assert ((1, 4) == z1[0]);\n+        assert ((2, 5) == z1[1]);\n+        assert ((3, 6) == z1[2]);\n+\n+        let (left, right) = unzip(z1);\n+\n+        assert ((1, 4) == (left[0], right[0]));\n+        assert ((2, 5) == (left[1], right[1]));\n+        assert ((3, 6) == (left[2], right[2]));\n+    }\n+\n+    #[test]\n+    fn test_position() {\n+        let v1: [int] = [1, 2, 3, 3, 2, 5];\n+        assert (position(1, v1) == option::some::<uint>(0u));\n+        assert (position(2, v1) == option::some::<uint>(1u));\n+        assert (position(5, v1) == option::some::<uint>(5u));\n+        assert (position(4, v1) == option::none::<uint>);\n+    }\n+\n+    #[test]\n+    fn test_position_pred() {\n+        fn less_than_three(&&i: int) -> bool { ret i < 3; }\n+        fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n+        let v1: [int] = [5, 4, 3, 2, 1];\n+        assert position_pred(v1, less_than_three) == option::some::<uint>(3u);\n+        assert position_pred(v1, is_eighteen) == option::none::<uint>;\n+    }\n+\n+    #[test]\n+    fn reverse_and_reversed() {\n+        let v: [mutable int] = [mutable 10, 20];\n+        assert (v[0] == 10);\n+        assert (v[1] == 20);\n+        reverse(v);\n+        assert (v[0] == 20);\n+        assert (v[1] == 10);\n+        let v2 = reversed::<int>([10, 20]);\n+        assert (v2[0] == 20);\n+        assert (v2[1] == 10);\n+        v[0] = 30;\n+        assert (v2[0] == 20);\n+        // Make sure they work with 0-length vectors too.\n+\n+        let v4 = reversed::<int>([]);\n+        assert (v4 == []);\n+        let v3: [mutable int] = [mutable];\n+        reverse::<int>(v3);\n+    }\n+\n+    #[test]\n+    fn reversed_mut() {\n+        let v2 = reversed::<int>([mutable 10, 20]);\n+        assert (v2[0] == 20);\n+        assert (v2[1] == 10);\n+    }\n+\n+    #[test]\n+    fn test_init() {\n+        let v = init([1, 2, 3]);\n+        assert v == [1, 2];\n+    }\n+\n+    #[test]\n+    // FIXME: Windows can't undwind\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_init_empty() {\n+\n+        let r = task::join(\n+            task::spawn_joinable {||\n+                task::unsupervise();\n+                init::<int>([]);\n+            });\n+        assert r == task::tr_failure\n+    }\n+\n+    #[test]\n+    fn test_concat() {\n+        assert concat([[1], [2,3]]) == [1, 2, 3];\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "528e8e42681acf8fa83a3bd378a134a1ec6d82ed", "filename": "src/test/stdtest/bool.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbool.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,25 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import bool;\n-\n-#[test]\n-fn test_bool_from_str() {\n-    bool::all_values { |v|\n-        assert v == bool::from_str(bool::to_str(v))\n-    }\n-}\n-\n-#[test]\n-fn test_bool_to_str() {\n-    assert bool::to_str(false) == \"false\";\n-    assert bool::to_str(true) == \"true\";\n-}\n-\n-#[test]\n-fn test_bool_to_bit() {\n-    bool::all_values { |v|\n-        assert bool::to_bit(v) == if bool::is_true(v) { 1u8 } else { 0u8 };\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "abe80eec99799d9289fcf432a13e0507acfa2ccf", "filename": "src/test/stdtest/box.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbox.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,14 +0,0 @@\n-import core::*;\n-\n-use std;\n-import box;\n-\n-#[test]\n-fn test() {\n-    let x = @3;\n-    let y = @3;\n-    assert (box::ptr_eq::<int>(x, x));\n-    assert (box::ptr_eq::<int>(y, y));\n-    assert (!box::ptr_eq::<int>(x, y));\n-    assert (!box::ptr_eq::<int>(y, x));\n-}"}, {"sha": "7da2443d6c2c1c425de057afc8e26247f68c3cd8", "filename": "src/test/stdtest/char.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fchar.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,78 +0,0 @@\n-import core::*;\n-\n-use std;\n-import char;\n-\n-#[test]\n-fn test_is_lowercase() {\n-    assert char::is_lowercase('a');\n-    assert char::is_lowercase('\u00f6');\n-    assert char::is_lowercase('\u00df');\n-    assert !char::is_lowercase('\u00dc');\n-    assert !char::is_lowercase('P');\n-}\n-\n-#[test]\n-fn test_is_uppercase() {\n-    assert !char::is_uppercase('h');\n-    assert !char::is_uppercase('\u00e4');\n-    assert !char::is_uppercase('\u00df');\n-    assert char::is_uppercase('\u00d6');\n-    assert char::is_uppercase('T');\n-}\n-\n-#[test]\n-fn test_is_whitespace() {\n-    assert char::is_whitespace(' ');\n-    assert char::is_whitespace('\\u2007');\n-    assert char::is_whitespace('\\t');\n-    assert char::is_whitespace('\\n');\n-\n-    assert !char::is_whitespace('a');\n-    assert !char::is_whitespace('_');\n-    assert !char::is_whitespace('\\u0000');\n-}\n-\n-#[test]\n-fn test_to_digit() {\n-    assert (char::to_digit('0') == 0u8);\n-    assert (char::to_digit('1') == 1u8);\n-    assert (char::to_digit('2') == 2u8);\n-    assert (char::to_digit('9') == 9u8);\n-    assert (char::to_digit('a') == 10u8);\n-    assert (char::to_digit('A') == 10u8);\n-    assert (char::to_digit('b') == 11u8);\n-    assert (char::to_digit('B') == 11u8);\n-    assert (char::to_digit('z') == 35u8);\n-    assert (char::to_digit('Z') == 35u8);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_to_digit_fail_1() {\n-    char::to_digit(' ');\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_to_digit_fail_2() {\n-    char::to_digit('$');\n-}\n-\n-#[test]\n-fn test_to_lower() {\n-    assert (char::to_lower('H') == 'h');\n-    assert (char::to_lower('e') == 'e');\n-    //assert (char::to_lower('\u00d6') == '\u00f6');\n-    assert (char::to_lower('\u00df') == '\u00df');\n-}\n-\n-#[test]\n-fn test_to_upper() {\n-    assert (char::to_upper('l') == 'L');\n-    assert (char::to_upper('Q') == 'Q');\n-    //assert (char::to_upper('\u00fc') == '\u00dc');\n-    assert (char::to_upper('\u00df') == '\u00df');\n-}"}, {"sha": "fbb0cec73c914efcadc023fbb1706c9d73f0c3fa", "filename": "src/test/stdtest/comm.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fcomm.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,46 +0,0 @@\n-import core::*;\n-\n-use std;\n-import comm;\n-\n-#[test]\n-fn create_port_and_chan() { let p = comm::port::<int>(); comm::chan(p); }\n-\n-#[test]\n-fn send_int() {\n-    let p = comm::port::<int>();\n-    let c = comm::chan(p);\n-    comm::send(c, 22);\n-}\n-\n-#[test]\n-fn send_recv_fn() {\n-    let p = comm::port::<int>();\n-    let c = comm::chan::<int>(p);\n-    comm::send(c, 42);\n-    assert (comm::recv(p) == 42);\n-}\n-\n-#[test]\n-fn send_recv_fn_infer() {\n-    let p = comm::port();\n-    let c = comm::chan(p);\n-    comm::send(c, 42);\n-    assert (comm::recv(p) == 42);\n-}\n-\n-#[test]\n-fn chan_chan_infer() {\n-    let p = comm::port(), p2 = comm::port::<int>();\n-    let c = comm::chan(p);\n-    comm::send(c, comm::chan(p2));\n-    comm::recv(p);\n-}\n-\n-#[test]\n-fn chan_chan() {\n-    let p = comm::port::<comm::chan<int>>(), p2 = comm::port::<int>();\n-    let c = comm::chan(p);\n-    comm::send(c, comm::chan(p2));\n-    comm::recv(p);\n-}"}, {"sha": "de5849f029f696d06fa6eca1bdad7a48ba69dbd1", "filename": "src/test/stdtest/either.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,99 +0,0 @@\n-import core::*;\n-\n-use std;\n-import vec;\n-import core::either::*;\n-import vec::len;\n-\n-#[test]\n-fn test_either_left() {\n-    let val = left(10);\n-    fn f_left(&&x: int) -> bool { x == 10 }\n-    fn f_right(&&_x: uint) -> bool { false }\n-    assert (either(f_left, f_right, val));\n-}\n-\n-#[test]\n-fn test_either_right() {\n-    let val = right(10u);\n-    fn f_left(&&_x: int) -> bool { false }\n-    fn f_right(&&x: uint) -> bool { x == 10u }\n-    assert (either(f_left, f_right, val));\n-}\n-\n-#[test]\n-fn test_lefts() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n-    let result = lefts(input);\n-    assert (result == [10, 12, 14]);\n-}\n-\n-#[test]\n-fn test_lefts_none() {\n-    let input: [t<int, int>] = [right(10), right(10)];\n-    let result = lefts(input);\n-    assert (len(result) == 0u);\n-}\n-\n-#[test]\n-fn test_lefts_empty() {\n-    let input: [t<int, int>] = [];\n-    let result = lefts(input);\n-    assert (len(result) == 0u);\n-}\n-\n-#[test]\n-fn test_rights() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n-    let result = rights(input);\n-    assert (result == [11, 13]);\n-}\n-\n-#[test]\n-fn test_rights_none() {\n-    let input: [t<int, int>] = [left(10), left(10)];\n-    let result = rights(input);\n-    assert (len(result) == 0u);\n-}\n-\n-#[test]\n-fn test_rights_empty() {\n-    let input: [t<int, int>] = [];\n-    let result = rights(input);\n-    assert (len(result) == 0u);\n-}\n-\n-#[test]\n-fn test_partition() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n-    let result = partition(input);\n-    assert (result.lefts[0] == 10);\n-    assert (result.lefts[1] == 12);\n-    assert (result.lefts[2] == 14);\n-    assert (result.rights[0] == 11);\n-    assert (result.rights[1] == 13);\n-}\n-\n-#[test]\n-fn test_partition_no_lefts() {\n-    let input: [t<int, int>] = [right(10), right(11)];\n-    let result = partition(input);\n-    assert (len(result.lefts) == 0u);\n-    assert (len(result.rights) == 2u);\n-}\n-\n-#[test]\n-fn test_partition_no_rights() {\n-    let input: [t<int, int>] = [left(10), left(11)];\n-    let result = partition(input);\n-    assert (len(result.lefts) == 2u);\n-    assert (len(result.rights) == 0u);\n-}\n-\n-#[test]\n-fn test_partition_empty() {\n-    let input: [t<int, int>] = [];\n-    let result = partition(input);\n-    assert (len(result.lefts) == 0u);\n-    assert (len(result.rights) == 0u);\n-}"}, {"sha": "3ac3d67b8346eaee1647f4aa2cd16a0596c4f4bc", "filename": "src/test/stdtest/float.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffloat.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,85 +0,0 @@\n-import core::*;\n-\n-use std;\n-import float;\n-\n-#[test]\n-fn test_from_str() {\n-   assert ( float::from_str(\"3\") == 3. );\n-   assert ( float::from_str(\"  3  \") == 3. );\n-   assert ( float::from_str(\"3.14\") == 3.14 );\n-   assert ( float::from_str(\"+3.14\") == 3.14 );\n-   assert ( float::from_str(\"-3.14\") == -3.14 );\n-   assert ( float::from_str(\"2.5E10\") == 25000000000. );\n-   assert ( float::from_str(\"2.5e10\") == 25000000000. );\n-   assert ( float::from_str(\"25000000000.E-10\") == 2.5 );\n-   assert ( float::from_str(\"\") == 0. );\n-   assert ( float::from_str(\".\") == 0. );\n-   assert ( float::from_str(\".e1\") == 0. );\n-   assert ( float::from_str(\".e-1\") == 0. );\n-   assert ( float::from_str(\"5.\") == 5. );\n-   assert ( float::from_str(\".5\") == 0.5 );\n-   assert ( float::from_str(\"0.5\") == 0.5 );\n-   assert ( float::from_str(\"0.5 \") == 0.5 );\n-   assert ( float::from_str(\" 0.5 \") == 0.5 );\n-   assert ( float::from_str(\" -.5 \") == -0.5 );\n-   assert ( float::from_str(\" -.5 \") == -0.5 );\n-   assert ( float::from_str(\" -5 \") == -5. );\n-\n-   assert ( float::is_NaN(float::from_str(\"x\")) );\n-   assert ( float::from_str(\" \") == 0. );\n-   assert ( float::from_str(\"   \") == 0. );\n-   assert ( float::from_str(\" 0.5\") == 0.5 );\n-   assert ( float::from_str(\" 0.5 \") == 0.5 );\n-   assert ( float::from_str(\" .1 \") == 0.1 );\n-   assert ( float::is_NaN(float::from_str(\"e\")) );\n-   assert ( float::is_NaN(float::from_str(\"E\")) );\n-   assert ( float::is_NaN(float::from_str(\"E1\")) );\n-   assert ( float::is_NaN(float::from_str(\"1e1e1\")) );\n-   assert ( float::is_NaN(float::from_str(\"1e1.1\")) );\n-   assert ( float::is_NaN(float::from_str(\"1e1-1\")) );\n-}\n-\n-#[test]\n-fn test_positive() {\n-  assert(float::is_positive(float::infinity));\n-  assert(float::is_positive(1.));\n-  assert(float::is_positive(0.));\n-  assert(!float::is_positive(-1.));\n-  assert(!float::is_positive(float::neg_infinity));\n-  assert(!float::is_positive(1./float::neg_infinity));\n-  assert(!float::is_positive(float::NaN));\n-}\n-\n-#[test]\n-fn test_negative() {\n-  assert(!float::is_negative(float::infinity));\n-  assert(!float::is_negative(1.));\n-  assert(!float::is_negative(0.));\n-  assert(float::is_negative(-1.));\n-  assert(float::is_negative(float::neg_infinity));\n-  assert(float::is_negative(1./float::neg_infinity));\n-  assert(!float::is_negative(float::NaN));\n-}\n-\n-#[test]\n-fn test_nonpositive() {\n-  assert(!float::is_nonpositive(float::infinity));\n-  assert(!float::is_nonpositive(1.));\n-  assert(!float::is_nonpositive(0.));\n-  assert(float::is_nonpositive(-1.));\n-  assert(float::is_nonpositive(float::neg_infinity));\n-  assert(float::is_nonpositive(1./float::neg_infinity));\n-  assert(!float::is_nonpositive(float::NaN));\n-}\n-\n-#[test]\n-fn test_nonnegative() {\n-  assert(float::is_nonnegative(float::infinity));\n-  assert(float::is_nonnegative(1.));\n-  assert(float::is_nonnegative(0.));\n-  assert(!float::is_nonnegative(-1.));\n-  assert(!float::is_nonnegative(float::neg_infinity));\n-  assert(!float::is_nonnegative(1./float::neg_infinity));\n-  assert(!float::is_nonnegative(float::NaN));\n-}"}, {"sha": "c8ec806189fb5f3692ddbcad65c1492a942c62e4", "filename": "src/test/stdtest/int.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fint.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,99 +0,0 @@\n-import core::*;\n-\n-use std;\n-import str;\n-import int;\n-import str::eq;\n-import str::bytes;\n-\n-#[test]\n-fn test_from_str() {\n-    assert(int::from_str(\"0\") == 0);\n-    assert(int::from_str(\"3\") == 3);\n-    assert(int::from_str(\"10\") == 10);\n-    assert(int::from_str(\"123456789\") == 123456789);\n-    assert(int::from_str(\"00100\") == 100);\n-\n-    assert(int::from_str(\"-1\") == -1);\n-    assert(int::from_str(\"-3\") == -3);\n-    assert(int::from_str(\"-10\") == -10);\n-    assert(int::from_str(\"-123456789\") == -123456789);\n-    assert(int::from_str(\"-00100\") == -100);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_1() {\n-    int::from_str(\" \");\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_2() {\n-    int::from_str(\"x\");\n-}\n-\n-#[test]\n-fn test_parse_buf() {\n-    assert (int::parse_buf(bytes(\"123\"), 10u) == 123);\n-    assert (int::parse_buf(bytes(\"1001\"), 2u) == 9);\n-    assert (int::parse_buf(bytes(\"123\"), 8u) == 83);\n-    assert (int::parse_buf(bytes(\"123\"), 16u) == 291);\n-    assert (int::parse_buf(bytes(\"ffff\"), 16u) == 65535);\n-    assert (int::parse_buf(bytes(\"FFFF\"), 16u) == 65535);\n-    assert (int::parse_buf(bytes(\"z\"), 36u) == 35);\n-    assert (int::parse_buf(bytes(\"Z\"), 36u) == 35);\n-\n-    assert (int::parse_buf(bytes(\"-123\"), 10u) == -123);\n-    assert (int::parse_buf(bytes(\"-1001\"), 2u) == -9);\n-    assert (int::parse_buf(bytes(\"-123\"), 8u) == -83);\n-    assert (int::parse_buf(bytes(\"-123\"), 16u) == -291);\n-    assert (int::parse_buf(bytes(\"-ffff\"), 16u) == -65535);\n-    assert (int::parse_buf(bytes(\"-FFFF\"), 16u) == -65535);\n-    assert (int::parse_buf(bytes(\"-z\"), 36u) == -35);\n-    assert (int::parse_buf(bytes(\"-Z\"), 36u) == -35);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_1() {\n-    int::parse_buf(bytes(\"Z\"), 35u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_2() {\n-    int::parse_buf(bytes(\"-9\"), 2u);\n-}\n-\n-#[test]\n-fn test_to_str() {\n-    assert (eq(int::to_str(0, 10u), \"0\"));\n-    assert (eq(int::to_str(1, 10u), \"1\"));\n-    assert (eq(int::to_str(-1, 10u), \"-1\"));\n-    assert (eq(int::to_str(255, 16u), \"ff\"));\n-    assert (eq(int::to_str(100, 10u), \"100\"));\n-}\n-\n-#[test]\n-fn test_pow() {\n-    assert (int::pow(0, 0u) == 1);\n-    assert (int::pow(0, 1u) == 0);\n-    assert (int::pow(0, 2u) == 0);\n-    assert (int::pow(-1, 0u) == 1);\n-    assert (int::pow(1, 0u) == 1);\n-    assert (int::pow(-3, 2u) == 9);\n-    assert (int::pow(-3, 3u) == -27);\n-    assert (int::pow(4, 9u) == 262144);\n-}\n-\n-#[test]\n-fn test_overflows() {\n-   assert (int::max_value > 0);\n-   assert (int::min_value <= 0);\n-   assert (int::min_value + int::max_value + 1 == 0);\n-}"}, {"sha": "adb68e4198c267d5e5be2d07a8b50bb5da568fbe", "filename": "src/test/stdtest/math.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmath.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,304 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import math::{min, max};\n-import float::*;\n-import float;\n-import c_int = ctypes::c_int;\n-\n-#[test]\n-fn test_max_min() {\n-    assert max(0, 1) == 1;\n-    assert min(0, 1) == 0;\n-    assert max(0, -1) == 0;\n-    assert min(0, -1) == -1;\n-    assert max(0.0, 1.0) == 1.0;\n-    assert min(0.0, 1.0) == 0.0;\n-}\n-\n-// FIXME use macros to execute the tests below for all float types\n-\n-/*\n-#[test]\n-fn test_trig() {\n-    assert sin(0.0) == 0.0;\n-    assert sin(-0.0) == 0.0;\n-\n-    assert float::isNaN(sin(float::infinity));\n-    assert float::isNaN(sin(float::neg_infinity));\n-\n-    assert cos(0.0) == 1.0;\n-    assert cos(-0.0) == 1.0;\n-    assert float::isNaN(cos(float::infinity));\n-    assert float::isNaN(cos(float::neg_infinity));\n-\n-    assert tan(0.0) == 0.0;\n-    assert tan(-0.0) == 0.0;;\n-    assert float::isNaN(tan(float::infinity));\n-    assert float::isNaN(tan(float::neg_infinity));\n-}\n-\n-#[test]\n-fn test_inv_trig() {\n-    assert asin(0.0) == 0.0;\n-    assert asin(-0.0) == -0.0;\n-    assert float::isNaN(asin(1.1));\n-    assert float::isNaN(asin(-1.1));\n-\n-    assert acos(1.0) == 0.0;\n-    assert float::isNaN(acos(1.1));\n-    assert float::isNaN(acos(-1.1));\n-\n-    assert atan(0.0) == 0.0;\n-    assert atan(-0.0) == 0.0;\n-    assert atan(float::infinity) == consts::frac_pi_2;\n-    assert atan(float::neg_infinity) == - consts::frac_pi_2;\n-\n-    assert atan2(0.0, -0.0) == consts::pi;\n-    assert atan2(-0.0, -0.0) == -consts::pi;\n-\n-    assert atan2(0.0, 0.0) == 0.0;\n-    assert atan2(-0.0, 0.0) == -0.0;\n-\n-    assert atan2(0.0, -1.0) == consts::pi;\n-    assert atan2(-0.0, -1.0) == -consts::pi;\n-\n-    assert atan2(0.0, 1.0) == 0.0;\n-    assert atan2(-0.0, 1.0) == -0.0;\n-\n-    assert atan2(1.0, 0.0) == consts::frac_pi_2;\n-    assert atan2(1.0, -0.0) == consts::frac_pi_2;\n-}\n-\n-// FIXME (1222): The commented-out tests give different results on windows\n-#[test]\n-fn test_pow() {\n-    assert pow(2.0, 4.0) == 16.0;\n-\n-    assert pow(0.0, -3.0) == float::infinity;\n-    assert pow(-0.0, -3.0) == float::neg_infinity;\n-\n-    assert pow(0.0, -4.0) == float::infinity;\n-    assert pow(-0.0, -4.0) == float::infinity;\n-\n-    assert pow(0.0, 3.0) == 0.0;\n-    assert pow(-0.0, 3.0) == -0.0;\n-    assert pow(0.0, 4.0) == 0.0;\n-    assert pow(-0.0, 4.0) == 0.0;\n-\n-    assert pow(-1.0, float::infinity) == 1.0;\n-    //assert pow(-1.0, float::neg_infinity) == 1.0;\n-\n-    assert pow(1.0, 4.0) == 1.0;\n-    assert pow(1.0, 0.0) == 1.0;\n-    assert pow(1.0, -0.0) == 1.0;\n-    //assert pow(1.0, float::NaN) == 1.0;\n-    assert pow(1.0, float::infinity) == 1.0;\n-    //assert pow(1.0, float::neg_infinity) == 1.0;\n-    assert pow(1.0, -3.0) == 1.0;\n-    assert pow(1.0, -4.0) == 1.0;\n-\n-    assert pow(4.0, 0.0) == 1.0;\n-    assert pow(0.0, 0.0) == 1.0;\n-    assert pow(-0.0, 0.0) == 1.0;\n-    //assert pow(float::NaN, 0.0) == 1.0;\n-    assert pow(float::infinity, 0.0) == 1.0;\n-    assert pow(float::neg_infinity, 0.0) == 1.0;\n-    assert pow(-3.0, 0.0) == 1.0;\n-    assert pow(-4.0, 0.0) == 1.0;\n-\n-    assert pow(4.0, -0.0) == 1.0;\n-    assert pow(0.0, -0.0) == 1.0;\n-    assert pow(-0.0, -0.0) == 1.0;\n-    //assert pow(float::NaN, -0.0) == 1.0;\n-    assert pow(float::infinity, -0.0) == 1.0;\n-    assert pow(float::neg_infinity, -0.0) == 1.0;\n-    assert pow(-3.0, -0.0) == 1.0;\n-    assert pow(-4.0, -0.0) == 1.0;\n-\n-    assert float::isNaN(pow(-1.0, -1.5));\n-    assert float::isNaN(pow(-1.0, 1.5));\n-\n-    assert float::isNaN(pow(-1.2, -1.5));\n-    assert float::isNaN(pow(-1.2, 1.5));\n-\n-    assert pow(0.5, float::neg_infinity) == float::infinity;\n-    assert pow(-0.5, float::neg_infinity) == float::infinity;\n-\n-    assert pow(1.5, float::neg_infinity) == 0.0;\n-    assert pow(-1.5, float::neg_infinity) == 0.0;\n-\n-    assert pow(0.5, float::infinity) == 0.0;\n-    assert pow(-0.5, float::infinity) == 0.0;\n-\n-    assert pow(-1.5, float::infinity) == float::infinity;\n-    assert pow(1.5, float::infinity) == float::infinity;\n-\n-    assert pow(float::neg_infinity, -3.0) == -0.0;\n-    assert pow(float::neg_infinity, -4.0) == 0.0;\n-\n-    assert pow(float::neg_infinity, 3.0) == float::neg_infinity;\n-    assert pow(float::neg_infinity, 4.0) == float::infinity;\n-\n-    assert pow(float::infinity, -16.0) == 0.0;\n-    assert pow(float::infinity, 16.0) == float::infinity;\n-}\n-\n-// FIXME (1222): The commented-out tests give different results on windows\n-#[test]\n-fn test_exp_and_mod() {\n-    assert exp(0.0) == 1.0;\n-    assert exp(-0.0) == 1.0;\n-    assert exp(float::neg_infinity) == 0.0;\n-    assert exp(float::infinity) == float::infinity;\n-\n-    let d1: c_int = 1 as c_int;\n-    assert frexp(0.0, d1) == 0.0;\n-    assert frexp(-0.0, d1) == 0.0;\n-    //assert frexp(float::infinity, d1) == float::infinity;\n-    //assert frexp(float::neg_infinity, d1) == float::neg_infinity;\n-    assert float::isNaN(frexp(float::NaN, d1));\n-\n-    let d2: float = 1.0;\n-    assert modf(float::infinity, d2) == 0.0;\n-    assert d2 == float::infinity;\n-    assert modf(float::neg_infinity, d2) == -0.0;\n-    assert d2 == float::neg_infinity;\n-    assert float::isNaN(modf(float::NaN, d2));\n-    assert float::isNaN(d2);\n-}\n-\n-#[test]\n-fn test_round_and_abs() {\n-    assert abs(0.0) == 0.0;\n-    assert abs(-0.0) == 0.0;\n-    assert abs(float::infinity) == float::infinity;\n-    assert abs(float::neg_infinity) == float::infinity;\n-\n-    assert abs(-2.5) == 2.5;\n-    assert abs(2.5) == 2.5;\n-\n-    assert ceil(0.0) == 0.0;\n-    assert ceil(-0.0) == -0.0;\n-    assert ceil(float::infinity) == float::infinity;\n-    assert ceil(float::neg_infinity) == float::neg_infinity;\n-\n-    assert ceil(1.9) == 2.0;\n-    assert ceil(-1.9) == -1.0;\n-\n-    assert floor(0.0) == 0.0;\n-    assert floor(-0.0) == -0.0;\n-    assert floor(float::infinity) == float::infinity;\n-    assert floor(float::neg_infinity) == float::neg_infinity;\n-\n-    assert floor(1.9) == 1.0;\n-    assert floor(-1.9) == -2.0;\n-\n-    assert trunc(0.0) == 0.0;\n-    assert trunc(-0.0) == -0.0;\n-    assert trunc(float::infinity) == float::infinity;\n-    assert trunc(float::neg_infinity) == float::neg_infinity;\n-\n-    assert trunc(1.5) == 1.0;\n-    assert trunc(1.2) == 1.0;\n-    assert trunc(1.0) == 1.0;\n-    assert trunc(1.9) == 1.0;\n-    assert trunc(-1.5) == -1.0;\n-    assert trunc(-1.2) == -1.0;\n-    assert trunc(-1.0) == -1.0;\n-    assert trunc(-1.9) == -1.0;\n-\n-    assert round(0.0) == 0.0;\n-    assert round(-0.0) == -0.0;\n-    assert round(float::infinity) == float::infinity;\n-    assert round(float::neg_infinity) == float::neg_infinity;\n-\n-    assert rint(0.0) == 0.0;\n-    assert rint(-0.0) == -0.0;\n-    assert rint(float::infinity) == float::infinity;\n-    assert rint(float::neg_infinity) == float::neg_infinity;\n-}\n-\n-#[test]\n-fn test_hyp_trig() {\n-    assert sinh(0.0) == 0.0;\n-    assert sinh(-0.0) == 0.0;\n-    assert sinh(float::infinity) == float::infinity;\n-    assert sinh(float::neg_infinity) == float::neg_infinity;\n-\n-    assert cosh(0.0) == 1.0;\n-    assert cosh(-0.0) == 1.0;\n-    assert cosh(float::infinity) == float::infinity;\n-    assert cosh(float::neg_infinity) == float::infinity;\n-\n-    assert tanh(0.0) == 0.0;\n-    assert tanh(-0.0) == 0.0;\n-    assert tanh(float::infinity) == 1.0;\n-    assert tanh(float::neg_infinity) == -1.0;\n-}\n-\n-#[test]\n-fn test_sqrt() {\n-    assert sqrt(9.0) == 3.0;\n-    assert sqrt(4.0) == 2.0;\n-    assert sqrt(1.0) == 1.0;\n-    assert sqrt(0.0) == 0.0;\n-}\n-\n-\n-#[test]\n-fn test_angle() {\n-    fn angle(vec: (float, float)) -> float {\n-        alt vec {\n-          (0f, y) if y < 0f { 1.5 * consts::pi }\n-          (0f, y) { 0.5 * consts::pi }\n-          (x, y) { float::atan(y / x) }\n-        }\n-    }\n-    assert angle((1f, 0f)) == 0f;\n-    assert angle((1f, 1f)) == 0.25 * consts::pi;\n-    assert angle((0f, 1f)) == 0.5 * consts::pi;\n-}\n-\n-\n-#[test]\n-fn test_log_functions() {\n-    assert ln(1.0) == 0.0;\n-    assert log2(1.0) == 0.0;\n-    assert log10(1.0) == 0.0;\n-\n-    // FIXME remove round-up due to valgrind weirdness\n-    assert ceil(ln(consts::e)) == 1.0; /* ln(e) == 0.999.. under valgrind */\n-    assert log2(2.0) == 1.0;\n-    assert log10(10.0) == 1.0;\n-\n-    // FIXME remove round-up due to valgrind weirdness\n-    assert ceil(ln(consts::e*consts::e*consts::e*consts::e)) == 4.0;\n-    assert log2(256.0) == 8.0;\n-    assert log10(1000.0) == 3.0;\n-\n-    assert ln(0.0) == float::neg_infinity;\n-    assert log2(0.0) == float::neg_infinity;\n-    assert log10(0.0) == float::neg_infinity;\n-\n-    assert ln(-0.0) == float::neg_infinity;\n-    assert log2(-0.0) == float::neg_infinity;\n-    assert log10(-0.0) == float::neg_infinity;\n-\n-    assert float::isNaN(ln(-1.0));\n-    assert float::isNaN(log2(-1.0));\n-    assert float::isNaN(log10(-1.0));\n-\n-    assert ln(float::infinity) == float::infinity;\n-    assert log2(float::infinity) == float::infinity;\n-    assert log10(float::infinity) == float::infinity;\n-\n-    assert ln1p(0.0) == 0.0;\n-    assert ln1p(-0.0) == 0.0;\n-    assert ln1p(-1.0) == float::neg_infinity;\n-    assert float::isNaN(ln1p(-2.0f));\n-    assert ln1p(float::infinity) == float::infinity;\n-}\n-\n-*/\n\\ No newline at end of file"}, {"sha": "a04751da101cd97cad98e7b0ecbd9dec199061c9", "filename": "src/test/stdtest/option.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Foption.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,6 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-#[test]\n-fn test() { let _x = option::some::<int>(10); }"}, {"sha": "a2242b1a06d73ea42b027ecf31d6a7bc4242f35e", "filename": "src/test/stdtest/ptr.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fptr.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,24 +0,0 @@\n-import core::*;\n-\n-use std;\n-import ptr;\n-import unsafe;\n-\n-type pair = {mutable fst: int, mutable snd: int};\n-\n-#[test]\n-fn test() unsafe {\n-    let p = {mutable fst: 10, mutable snd: 20};\n-    let pptr: *mutable pair = ptr::mut_addr_of(p);\n-    let iptr: *mutable int = unsafe::reinterpret_cast(pptr);\n-    assert (*iptr == 10);;\n-    *iptr = 30;\n-    assert (*iptr == 30);\n-    assert (p.fst == 30);;\n-\n-    *pptr = {mutable fst: 50, mutable snd: 60};\n-    assert (*iptr == 50);\n-    assert (p.fst == 50);\n-    assert (p.snd == 60);\n-}\n-"}, {"sha": "ed041349176f84f053fb7e9c5162d2de78b01340", "filename": "src/test/stdtest/result.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fresult.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,19 +0,0 @@\n-import core::*;\n-\n-import result;\n-\n-fn op1() -> result::t<int, str> { result::ok(666) }\n-\n-fn op2(&&i: int) -> result::t<uint, str> { result::ok(i as uint + 1u) }\n-\n-fn op3() -> result::t<int, str> { result::err(\"sadface\") }\n-\n-#[test]\n-fn chain_success() {\n-    assert result::get(result::chain(op1(), op2)) == 667u;\n-}\n-\n-#[test]\n-fn chain_failure() {\n-    assert result::get_err(result::chain(op3(), op2)) == \"sadface\";\n-}\n\\ No newline at end of file"}, {"sha": "4fd390c5c3e3fb2a5ca8383cc294e0ec0ee8705a", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,51 +1,34 @@\n use std;\n \n mod bitv;\n-mod bool;\n-mod box;\n mod c_vec;\n-mod char;\n-mod comm;\n mod deque;\n-mod either;\n-mod float;\n mod four;\n mod fs;\n mod getopts;\n-mod int;\n mod io;\n mod json;\n mod list;\n mod map;\n-mod math;\n mod net;\n-mod option;\n mod os;\n mod path;\n-mod ptr;\n mod qsort3;\n mod qsort;\n mod rand;\n-mod result;\n mod rope;\n mod run;\n mod sha1;\n mod sort;\n-mod str;\n-mod sys;\n-mod task;\n mod tempfile;\n mod test;\n mod tri;\n mod treemap;\n-mod uint;\n \n #[cfg(unicode)]\n mod unicode;\n \n-mod unsafe;\n mod uv;\n-mod vec;\n \n // Local Variables:\n // mode: rust"}, {"sha": "26b5c2e9df76150e8754a1613a61466918ce6326", "filename": "src/test/stdtest/str.rs", "status": "removed", "additions": 0, "deletions": 461, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,461 +0,0 @@\n-import core::*;\n-\n-import str;\n-import vec;\n-\n-#[test]\n-fn test_eq() {\n-    assert (str::eq(\"\", \"\"));\n-    assert (str::eq(\"foo\", \"foo\"));\n-    assert (!str::eq(\"foo\", \"bar\"));\n-}\n-\n-#[test]\n-fn test_lteq() {\n-    assert (str::lteq(\"\", \"\"));\n-    assert (str::lteq(\"\", \"foo\"));\n-    assert (str::lteq(\"foo\", \"foo\"));\n-    assert (!str::eq(\"foo\", \"bar\"));\n-}\n-\n-#[test]\n-fn test_bytes_len() {\n-    assert (str::byte_len(\"\") == 0u);\n-    assert (str::byte_len(\"hello world\") == 11u);\n-    assert (str::byte_len(\"\\x63\") == 1u);\n-    assert (str::byte_len(\"\\xa2\") == 2u);\n-    assert (str::byte_len(\"\\u03c0\") == 2u);\n-    assert (str::byte_len(\"\\u2620\") == 3u);\n-    assert (str::byte_len(\"\\U0001d11e\") == 4u);\n-}\n-\n-#[test]\n-fn test_index_and_rindex() {\n-    assert (str::index(\"hello\", 'e' as u8) == 1);\n-    assert (str::index(\"hello\", 'o' as u8) == 4);\n-    assert (str::index(\"hello\", 'z' as u8) == -1);\n-    assert (str::rindex(\"hello\", 'l' as u8) == 3);\n-    assert (str::rindex(\"hello\", 'h' as u8) == 0);\n-    assert (str::rindex(\"hello\", 'z' as u8) == -1);\n-}\n-\n-#[test]\n-fn test_split() {\n-    fn t(s: str, c: char, u: [str]) {\n-        log(debug, \"split: \" + s);\n-        let v = str::split(s, c as u8);\n-        #debug(\"split to: \");\n-        log(debug, v);\n-        assert (vec::all2(v, u, { |a,b| a == b }));\n-    }\n-    t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n-    t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n-    t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n-}\n-\n-#[test]\n-fn test_splitn() {\n-    fn t(s: str, c: char, n: uint, u: [str]) {\n-        log(debug, \"splitn: \" + s);\n-        let v = str::splitn(s, c as u8, n);\n-        #debug(\"split to: \");\n-        log(debug, v);\n-        #debug(\"comparing vs. \");\n-        log(debug, u);\n-        assert (vec::all2(v, u, { |a,b| a == b }));\n-    }\n-    t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]);\n-    t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]);\n-    t(\"abc.hello.there\", '.', 2u, [\"abc\", \"hello\", \"there\"]);\n-    t(\"abc.hello.there\", '.', 3u, [\"abc\", \"hello\", \"there\"]);\n-    t(\".hello.there\", '.', 0u, [\".hello.there\"]);\n-    t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]);\n-    t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n-    t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n-}\n-\n-#[test]\n-fn test_split_str() {\n-    fn t(s: str, sep: str, i: int, k: str) {\n-        let v = str::split_str(s, sep);\n-        assert str::eq(v[i], k);\n-    }\n-\n-    //FIXME: should behave like split and split_char:\n-    //assert [\"\", \"XXX\", \"YYY\", \"\"] == str::split_str(\".XXX.YYY.\", \".\");\n-\n-    t(\"abc::hello::there\", \"::\", 0, \"abc\");\n-    t(\"abc::hello::there\", \"::\", 1, \"hello\");\n-    t(\"abc::hello::there\", \"::\", 2, \"there\");\n-    t(\"::hello::there\", \"::\", 0, \"hello\");\n-    t(\"hello::there::\", \"::\", 2, \"\");\n-    t(\"::hello::there::\", \"::\", 2, \"\");\n-    t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 0, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\");\n-    t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 1, \"Vi\u1ec7t Nam\");\n-}\n-\n-#[test]\n-fn test_split_func () {\n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-        == str::split_func (data, {|cc| cc == '\u534e'});\n-\n-    assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n-         == str::split_func(\"zzXXXzYYYz\", char::is_lowercase);\n-\n-    assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n-         == str::split_func(\"zzXXXzYYYz\", char::is_uppercase);\n-\n-    assert [\"\",\"\"] == str::split_func(\"z\", {|cc| cc == 'z'});\n-    assert [\"\"] == str::split_func(\"\", {|cc| cc == 'z'});\n-    assert [\"ok\"] == str::split_func(\"ok\", {|cc| cc == 'z'});\n-}\n-\n-#[test]\n-fn test_split_char () {\n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-        == str::split_char(data, '\u534e');\n-\n-    assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n-         == str::split_char(\"zzXXXzYYYz\", 'z');\n-    assert [\"\",\"\"] == str::split_char(\"z\", 'z');\n-    assert [\"\"] == str::split_char(\"\", 'z');\n-    assert [\"ok\"] == str::split_char(\"ok\", 'z');\n-}\n-\n-#[test]\n-fn test_lines () {\n-    let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-    let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n-\n-    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n-      == str::lines(lf);\n-\n-    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n-      == str::lines_any(lf);\n-\n-    assert [\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]\n-      == str::lines(crlf);\n-\n-    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n-      == str::lines_any(crlf);\n-\n-    assert [\"\"] == str::lines    (\"\");\n-    assert [\"\"] == str::lines_any(\"\");\n-    assert [\"\",\"\"] == str::lines    (\"\\n\");\n-    assert [\"\",\"\"] == str::lines_any(\"\\n\");\n-    assert [\"banana\"] == str::lines    (\"banana\");\n-    assert [\"banana\"] == str::lines_any(\"banana\");\n-}\n-\n-#[test]\n-fn test_words () {\n-    let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-    assert [\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]\n-        == str::words(data);\n-\n-    assert [\"ok\"] == str::words(\"ok\");\n-    assert [] == str::words(\"\");\n-}\n-\n-#[test]\n-fn test_find() {\n-    fn t(haystack: str, needle: str, i: int) {\n-        let j: int = str::find(haystack, needle);\n-        log(debug, \"searched for \" + needle);\n-        log(debug, j);\n-        assert (i == j);\n-    }\n-    t(\"this is a simple\", \"is a\", 5);\n-    t(\"this is a simple\", \"is z\", -1);\n-    t(\"this is a simple\", \"\", 0);\n-    t(\"this is a simple\", \"simple\", 10);\n-    t(\"this\", \"simple\", -1);\n-}\n-\n-#[test]\n-fn test_substr() {\n-    fn t(a: str, b: str, start: int) {\n-        assert (str::eq(str::substr(a, start as uint, str::byte_len(b)), b));\n-    }\n-    t(\"hello\", \"llo\", 2);\n-    t(\"hello\", \"el\", 1);\n-    t(\"substr should not be a challenge\", \"not\", 14);\n-}\n-\n-#[test]\n-fn test_concat() {\n-    fn t(v: [str], s: str) { assert (str::eq(str::concat(v), s)); }\n-    t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-    let v: [str] = [];\n-    t(v, \"\");\n-    t([\"hi\"], \"hi\");\n-}\n-\n-#[test]\n-fn test_connect() {\n-    fn t(v: [str], sep: str, s: str) {\n-        assert (str::eq(str::connect(v, sep), s));\n-    }\n-    t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n-    let v: [str] = [];\n-    t(v, \" \", \"\");\n-    t([\"hi\"], \" \", \"hi\");\n-}\n-\n-#[test]\n-fn test_to_upper() {\n-    // to_upper doesn't understand unicode yet,\n-    // but we need to at least preserve it\n-\n-    let unicode = \"\\u65e5\\u672c\";\n-    let input = \"abcDEF\" + unicode + \"xyz:.;\";\n-    let expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n-    let actual = str::to_upper(input);\n-    assert (str::eq(expected, actual));\n-}\n-\n-#[test]\n-fn test_slice() {\n-    assert (str::eq(\"ab\", str::slice(\"abc\", 0u, 2u)));\n-    assert (str::eq(\"bc\", str::slice(\"abc\", 1u, 3u)));\n-    assert (str::eq(\"\", str::slice(\"abc\", 1u, 1u)));\n-    fn a_million_letter_a() -> str {\n-        let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    fn half_a_million_letter_a() -> str {\n-        let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"aaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    assert (str::eq(half_a_million_letter_a(),\n-                    str::slice(a_million_letter_a(), 0u, 500000u)));\n-}\n-\n-#[test]\n-fn test_starts_with() {\n-    assert (str::starts_with(\"\", \"\"));\n-    assert (str::starts_with(\"abc\", \"\"));\n-    assert (str::starts_with(\"abc\", \"a\"));\n-    assert (!str::starts_with(\"a\", \"abc\"));\n-    assert (!str::starts_with(\"\", \"abc\"));\n-}\n-\n-#[test]\n-fn test_ends_with() {\n-    assert (str::ends_with(\"\", \"\"));\n-    assert (str::ends_with(\"abc\", \"\"));\n-    assert (str::ends_with(\"abc\", \"c\"));\n-    assert (!str::ends_with(\"a\", \"abc\"));\n-    assert (!str::ends_with(\"\", \"abc\"));\n-}\n-\n-#[test]\n-fn test_is_empty() {\n-    assert (str::is_empty(\"\"));\n-    assert (!str::is_empty(\"a\"));\n-}\n-\n-#[test]\n-fn test_is_not_empty() {\n-    assert (str::is_not_empty(\"a\"));\n-    assert (!str::is_not_empty(\"\"));\n-}\n-\n-#[test]\n-fn test_replace() {\n-    let a = \"a\";\n-    check (str::is_not_empty(a));\n-    assert (str::replace(\"\", a, \"b\") == \"\");\n-    assert (str::replace(\"a\", a, \"b\") == \"b\");\n-    assert (str::replace(\"ab\", a, \"b\") == \"bb\");\n-    let test = \"test\";\n-    check (str::is_not_empty(test));\n-    assert (str::replace(\" test test \", test, \"toast\") == \" toast toast \");\n-    assert (str::replace(\" test test \", test, \"\") == \"   \");\n-}\n-\n-#[test]\n-fn test_char_slice() {\n-    assert (str::eq(\"ab\", str::char_slice(\"abc\", 0u, 2u)));\n-    assert (str::eq(\"bc\", str::char_slice(\"abc\", 1u, 3u)));\n-    assert (str::eq(\"\", str::char_slice(\"abc\", 1u, 1u)));\n-    assert (str::eq(\"\\u65e5\", str::char_slice(\"\\u65e5\\u672c\", 0u, 1u)));\n-\n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert (str::eq(\"\u0e1b\", str::char_slice(data, 0u, 1u)));\n-    assert (str::eq(\"\u0e23\", str::char_slice(data, 1u, 2u)));\n-    assert (str::eq(\"\u534e\", str::char_slice(data, 10u, 11u)));\n-    assert (str::eq(\"\", str::char_slice(data, 1u, 1u)));\n-\n-    fn a_million_letter_X() -> str {\n-        let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n-        ret rs;\n-    }\n-    fn half_a_million_letter_X() -> str {\n-        let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n-        ret rs;\n-    }\n-    assert (str::eq(half_a_million_letter_X(),\n-                    str::char_slice(a_million_letter_X(), 0u, 500000u)));\n-}\n-\n-#[test]\n-fn trim_left() {\n-    assert (str::trim_left(\"\") == \"\");\n-    assert (str::trim_left(\"a\") == \"a\");\n-    assert (str::trim_left(\"    \") == \"\");\n-    assert (str::trim_left(\"     blah\") == \"blah\");\n-    assert (str::trim_left(\"   \\u3000  wut\") == \"wut\");\n-    assert (str::trim_left(\"hey \") == \"hey \");\n-}\n-\n-#[test]\n-fn trim_right() {\n-    assert (str::trim_right(\"\") == \"\");\n-    assert (str::trim_right(\"a\") == \"a\");\n-    assert (str::trim_right(\"    \") == \"\");\n-    assert (str::trim_right(\"blah     \") == \"blah\");\n-    assert (str::trim_right(\"wut   \\u3000  \") == \"wut\");\n-    assert (str::trim_right(\" hey\") == \" hey\");\n-}\n-\n-#[test]\n-fn trim() {\n-    assert (str::trim(\"\") == \"\");\n-    assert (str::trim(\"a\") == \"a\");\n-    assert (str::trim(\"    \") == \"\");\n-    assert (str::trim(\"    blah     \") == \"blah\");\n-    assert (str::trim(\"\\nwut   \\u3000  \") == \"wut\");\n-    assert (str::trim(\" hey dude \") == \"hey dude\");\n-}\n-\n-#[test]\n-fn is_whitespace() {\n-    assert (str::is_whitespace(\"\"));\n-    assert (str::is_whitespace(\" \"));\n-    assert (str::is_whitespace(\"\\u2009\")); // Thin space\n-    assert (str::is_whitespace(\"  \\n\\t   \"));\n-    assert (!str::is_whitespace(\"   _   \"));\n-}\n-\n-#[test]\n-fn is_ascii() {\n-    assert (str::is_ascii(\"\"));\n-    assert (str::is_ascii(\"a\"));\n-    assert (!str::is_ascii(\"\\u2009\"));\n-}\n-\n-#[test]\n-fn shift_byte() {\n-    let s = \"ABC\";\n-    let b = str::shift_byte(s);\n-    assert (s == \"BC\");\n-    assert (b == 65u8);\n-}\n-\n-#[test]\n-fn pop_byte() {\n-    let s = \"ABC\";\n-    let b = str::pop_byte(s);\n-    assert (s == \"AB\");\n-    assert (b == 67u8);\n-}\n-\n-#[test]\n-fn unsafe_from_bytes() {\n-    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-    let b = str::unsafe_from_bytes(a);\n-    assert (b == \"AAAAAAA\");\n-}\n-\n-#[test]\n-fn from_cstr() unsafe {\n-    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-    let b = vec::to_ptr(a);\n-    let c = str::from_cstr(b);\n-    assert (c == \"AAAAAAA\");\n-}\n-\n-#[test]\n-fn as_buf() unsafe {\n-    let a = \"Abcdefg\";\n-    let b = str::as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n-    assert (b == 100);\n-}\n-\n-#[test]\n-fn as_buf_small() unsafe {\n-    let a = \"A\";\n-    let b = str::as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n-    assert (b == 100);\n-}\n-\n-#[test]\n-fn as_buf2() unsafe {\n-    let s = \"hello\";\n-    let sb = str::as_buf(s, {|b| b });\n-    let s_cstr = str::from_cstr(sb);\n-    assert (str::eq(s_cstr, s));\n-}\n-\n-#[test]\n-fn vec_str_conversions() {\n-    let s1: str = \"All mimsy were the borogoves\";\n-\n-    let v: [u8] = str::bytes(s1);\n-    let s2: str = str::unsafe_from_bytes(v);\n-    let i: uint = 0u;\n-    let n1: uint = str::byte_len(s1);\n-    let n2: uint = vec::len::<u8>(v);\n-    assert (n1 == n2);\n-    while i < n1 {\n-        let a: u8 = s1[i];\n-        let b: u8 = s2[i];\n-        log(debug, a);\n-        log(debug, b);\n-        assert (a == b);\n-        i += 1u;\n-    }\n-}\n-\n-#[test]\n-fn contains() {\n-    assert str::contains(\"abcde\", \"bcd\");\n-    assert str::contains(\"abcde\", \"abcd\");\n-    assert str::contains(\"abcde\", \"bcde\");\n-    assert str::contains(\"abcde\", \"\");\n-    assert str::contains(\"\", \"\");\n-    assert !str::contains(\"abcde\", \"def\");\n-    assert !str::contains(\"\", \"a\");\n-}\n-\n-#[test]\n-fn iter_chars() {\n-    let i = 0;\n-    str::iter_chars(\"x\\u03c0y\") {|ch|\n-        alt i {\n-          0 { assert ch == 'x'; }\n-          1 { assert ch == '\\u03c0'; }\n-          2 { assert ch == 'y'; }\n-        }\n-        i += 1;\n-    }\n-}\n-\n-#[test]\n-fn escape() {\n-    assert(str::escape(\"abcdef\") == \"abcdef\");\n-    assert(str::escape(\"abc\\\\def\") == \"abc\\\\\\\\def\");\n-    assert(str::escape(\"abc\\ndef\") == \"abc\\\\ndef\");\n-    assert(str::escape(\"abc\\\"def\") == \"abc\\\\\\\"def\");\n-}"}, {"sha": "632f42c0f6be1abb03240bcd2155d3737561b33d", "filename": "src/test/stdtest/sys.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsys.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,53 +0,0 @@\n-import core::*;\n-\n-import sys;\n-\n-#[test]\n-fn last_os_error() {\n-    log(debug, sys::last_os_error());\n-}\n-\n-#[test]\n-fn size_of_basic() {\n-    assert sys::size_of::<u8>() == 1u;\n-    assert sys::size_of::<u16>() == 2u;\n-    assert sys::size_of::<u32>() == 4u;\n-    assert sys::size_of::<u64>() == 8u;\n-}\n-\n-#[test]\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(target_arch = \"arm\")]\n-fn size_of_32() {\n-    assert sys::size_of::<uint>() == 4u;\n-    assert sys::size_of::<*uint>() == 4u;\n-}\n-\n-#[test]\n-#[cfg(target_arch = \"x86_64\")]\n-fn size_of_64() {\n-    assert sys::size_of::<uint>() == 8u;\n-    assert sys::size_of::<*uint>() == 8u;\n-}\n-\n-#[test]\n-fn align_of_basic() {\n-    assert sys::align_of::<u8>() == 1u;\n-    assert sys::align_of::<u16>() == 2u;\n-    assert sys::align_of::<u32>() == 4u;\n-}\n-\n-#[test]\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(target_arch = \"arm\")]\n-fn align_of_32() {\n-    assert sys::align_of::<uint>() == 4u;\n-    assert sys::align_of::<*uint>() == 4u;\n-}\n-\n-#[test]\n-#[cfg(target_arch = \"x86_64\")]\n-fn align_of_64() {\n-    assert sys::align_of::<uint>() == 8u;\n-    assert sys::align_of::<*uint>() == 8u;\n-}\n\\ No newline at end of file"}, {"sha": "021a56a5dff481306d45fdc089b20533bcc454f8", "filename": "src/test/stdtest/task.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,80 +0,0 @@\n-import core::*;\n-\n-use std;\n-import task;\n-import comm;\n-\n-#[test]\n-fn test_sleep() { task::sleep(1000000u); }\n-\n-// FIXME: Leaks on windows\n-#[test]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_unsupervise() {\n-    fn f() { task::unsupervise(); fail; }\n-    task::spawn {|| f();};\n-}\n-\n-#[test]\n-fn test_lib_spawn() {\n-    fn foo() { #error(\"Hello, World!\"); }\n-    task::spawn {|| foo();};\n-}\n-\n-#[test]\n-fn test_lib_spawn2() {\n-    fn foo(x: int) { assert (x == 42); }\n-    task::spawn {|| foo(42);};\n-}\n-\n-#[test]\n-fn test_join_chan() {\n-    fn winner() { }\n-\n-    let t = task::spawn_joinable {|| winner();};\n-    alt task::join(t) {\n-      task::tr_success. {/* yay! */ }\n-      _ { fail \"invalid task status received\" }\n-    }\n-}\n-\n-// FIXME: Leaks on windows\n-#[test]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_join_chan_fail() {\n-    fn failer() { task::unsupervise(); fail }\n-\n-    let t = task::spawn_joinable {|| failer();};\n-    alt task::join(t) {\n-      task::tr_failure. {/* yay! */ }\n-      _ { fail \"invalid task status received\" }\n-    }\n-}\n-\n-#[test]\n-fn spawn_polymorphic() {\n-    fn foo<T:send>(x: T) { log(error, x); }\n-    task::spawn {|| foo(true);};\n-    task::spawn {|| foo(42);};\n-}\n-\n-#[test]\n-fn try_success() {\n-    alt task::try {||\n-        \"Success!\"\n-    } {\n-        result::ok(\"Success!\") { }\n-        _ { fail; }\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn try_fail() {\n-    alt task::try {||\n-        fail\n-    } {\n-        result::err(()) { }\n-        _ { fail; }\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "4318799482946b8de32ca59c611c8206249697c6", "filename": "src/test/stdtest/uint.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fuint.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,112 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import str;\n-import uint;\n-import str::bytes;\n-\n-#[test]\n-fn test_from_str() {\n-    assert (uint::from_str(\"0\") == 0u);\n-    assert (uint::from_str(\"3\") == 3u);\n-    assert (uint::from_str(\"10\") == 10u);\n-    assert (uint::from_str(\"123456789\") == 123456789u);\n-    assert (uint::from_str(\"00100\") == 100u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_1() {\n-    uint::from_str(\" \");\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_from_str_fail_2() {\n-    uint::from_str(\"x\");\n-}\n-\n-#[test]\n-fn test_parse_buf() {\n-    assert (uint::parse_buf(bytes(\"123\"), 10u) == 123u);\n-    assert (uint::parse_buf(bytes(\"1001\"), 2u) == 9u);\n-    assert (uint::parse_buf(bytes(\"123\"), 8u) == 83u);\n-    assert (uint::parse_buf(bytes(\"123\"), 16u) == 291u);\n-    assert (uint::parse_buf(bytes(\"ffff\"), 16u) == 65535u);\n-    assert (uint::parse_buf(bytes(\"z\"), 36u) == 35u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_1() {\n-    uint::parse_buf(bytes(\"Z\"), 10u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_parse_buf_fail_2() {\n-    uint::parse_buf(bytes(\"_\"), 2u);\n-}\n-\n-#[test]\n-fn test_next_power_of_two() {\n-    assert (uint::next_power_of_two(0u) == 0u);\n-    assert (uint::next_power_of_two(1u) == 1u);\n-    assert (uint::next_power_of_two(2u) == 2u);\n-    assert (uint::next_power_of_two(3u) == 4u);\n-    assert (uint::next_power_of_two(4u) == 4u);\n-    assert (uint::next_power_of_two(5u) == 8u);\n-    assert (uint::next_power_of_two(6u) == 8u);\n-    assert (uint::next_power_of_two(7u) == 8u);\n-    assert (uint::next_power_of_two(8u) == 8u);\n-    assert (uint::next_power_of_two(9u) == 16u);\n-    assert (uint::next_power_of_two(10u) == 16u);\n-    assert (uint::next_power_of_two(11u) == 16u);\n-    assert (uint::next_power_of_two(12u) == 16u);\n-    assert (uint::next_power_of_two(13u) == 16u);\n-    assert (uint::next_power_of_two(14u) == 16u);\n-    assert (uint::next_power_of_two(15u) == 16u);\n-    assert (uint::next_power_of_two(16u) == 16u);\n-    assert (uint::next_power_of_two(17u) == 32u);\n-    assert (uint::next_power_of_two(18u) == 32u);\n-    assert (uint::next_power_of_two(19u) == 32u);\n-    assert (uint::next_power_of_two(20u) == 32u);\n-    assert (uint::next_power_of_two(21u) == 32u);\n-    assert (uint::next_power_of_two(22u) == 32u);\n-    assert (uint::next_power_of_two(23u) == 32u);\n-    assert (uint::next_power_of_two(24u) == 32u);\n-    assert (uint::next_power_of_two(25u) == 32u);\n-    assert (uint::next_power_of_two(26u) == 32u);\n-    assert (uint::next_power_of_two(27u) == 32u);\n-    assert (uint::next_power_of_two(28u) == 32u);\n-    assert (uint::next_power_of_two(29u) == 32u);\n-    assert (uint::next_power_of_two(30u) == 32u);\n-    assert (uint::next_power_of_two(31u) == 32u);\n-    assert (uint::next_power_of_two(32u) == 32u);\n-    assert (uint::next_power_of_two(33u) == 64u);\n-    assert (uint::next_power_of_two(34u) == 64u);\n-    assert (uint::next_power_of_two(35u) == 64u);\n-    assert (uint::next_power_of_two(36u) == 64u);\n-    assert (uint::next_power_of_two(37u) == 64u);\n-    assert (uint::next_power_of_two(38u) == 64u);\n-    assert (uint::next_power_of_two(39u) == 64u);\n-}\n-\n-#[test]\n-fn test_overflows() {\n-   assert (uint::max_value > 0u);\n-   assert (uint::min_value <= 0u);\n-   assert (uint::min_value + uint::max_value + 1u == 0u);\n-}\n-\n-#[test]\n-fn test_div() {\n-    assert(uint::div_floor(3u, 4u) == 0u);\n-    assert(uint::div_ceil(3u, 4u)  == 1u);\n-    assert(uint::div_round(3u, 4u) == 1u);\n-}\n\\ No newline at end of file"}, {"sha": "b8197cf4c238c11c937a7f65e2933a09a1727035", "filename": "src/test/stdtest/unsafe.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Funsafe.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,15 +0,0 @@\n-import core::*;\n-\n-import unsafe;\n-\n-#[test]\n-fn reinterpret_cast() unsafe {\n-    assert unsafe::reinterpret_cast(1) == 1u;\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn reinterpret_cast_wrong_size() unsafe {\n-    let _i: uint = unsafe::reinterpret_cast(0u8);\n-}\n\\ No newline at end of file"}, {"sha": "3bbea1db6be233bc4588a9f6c826efda8f692f03", "filename": "src/test/stdtest/vec.rs", "status": "removed", "additions": 0, "deletions": 531, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4053f47384a71d6339b71a20102143df1e3144/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=de4053f47384a71d6339b71a20102143df1e3144", "patch": "@@ -1,531 +0,0 @@\n-import core::*;\n-\n-import vec;\n-import vec::*;\n-import option;\n-import option::none;\n-import option::some;\n-import task;\n-\n-\n-fn square(n: uint) -> uint { ret n * n; }\n-\n-fn square_ref(&&n: uint) -> uint { ret n * n; }\n-\n-pure fn is_three(&&n: uint) -> bool { ret n == 3u; }\n-\n-pure fn is_odd(&&n: uint) -> bool { ret n % 2u == 1u; }\n-\n-pure fn is_equal(&&x: uint, &&y:uint) -> bool { ret x == y; }\n-\n-fn square_if_odd(&&n: uint) -> option::t<uint> {\n-    ret if n % 2u == 1u { some(n * n) } else { none };\n-}\n-\n-fn add(&&x: uint, &&y: uint) -> uint { ret x + y; }\n-\n-#[test]\n-fn test_unsafe_ptrs() unsafe {\n-    // Test on-stack copy-from-buf.\n-    let a = [1, 2, 3];\n-    let ptr = vec::to_ptr(a);\n-    let b = vec::unsafe::from_buf(ptr, 3u);\n-    assert (vec::len(b) == 3u);\n-    assert (b[0] == 1);\n-    assert (b[1] == 2);\n-    assert (b[2] == 3);\n-\n-    // Test on-heap copy-from-buf.\n-    let c = [1, 2, 3, 4, 5];\n-    ptr = vec::to_ptr(c);\n-    let d = vec::unsafe::from_buf(ptr, 5u);\n-    assert (vec::len(d) == 5u);\n-    assert (d[0] == 1);\n-    assert (d[1] == 2);\n-    assert (d[2] == 3);\n-    assert (d[3] == 4);\n-    assert (d[4] == 5);\n-}\n-\n-#[test]\n-fn test_init_fn() {\n-    // Test on-stack init_fn.\n-    let v = vec::init_fn(square, 3u);\n-    assert (vec::len(v) == 3u);\n-    assert (v[0] == 0u);\n-    assert (v[1] == 1u);\n-    assert (v[2] == 4u);\n-\n-    // Test on-heap init_fn.\n-    v = vec::init_fn(square, 5u);\n-    assert (vec::len(v) == 5u);\n-    assert (v[0] == 0u);\n-    assert (v[1] == 1u);\n-    assert (v[2] == 4u);\n-    assert (v[3] == 9u);\n-    assert (v[4] == 16u);\n-}\n-\n-#[test]\n-fn test_init_elt() {\n-    // Test on-stack init_elt.\n-    let v = vec::init_elt(10u, 2u);\n-    assert (vec::len(v) == 2u);\n-    assert (v[0] == 10u);\n-    assert (v[1] == 10u);\n-\n-    // Test on-heap init_elt.\n-    v = vec::init_elt(20u, 6u);\n-    assert (v[0] == 20u);\n-    assert (v[1] == 20u);\n-    assert (v[2] == 20u);\n-    assert (v[3] == 20u);\n-    assert (v[4] == 20u);\n-    assert (v[5] == 20u);\n-}\n-\n-#[test]\n-fn test_is_empty() {\n-    assert (vec::is_empty::<int>([]));\n-    assert (!vec::is_empty([0]));\n-}\n-\n-#[test]\n-fn test_is_not_empty() {\n-    assert (vec::is_not_empty([0]));\n-    assert (!vec::is_not_empty::<int>([]));\n-}\n-\n-#[test]\n-fn test_head() {\n-    let a = [11, 12];\n-    check (vec::is_not_empty(a));\n-    assert (vec::head(a) == 11);\n-}\n-\n-#[test]\n-fn test_tail() {\n-    let a = [11];\n-    check (vec::is_not_empty(a));\n-    assert (vec::tail(a) == []);\n-\n-    a = [11, 12];\n-    check (vec::is_not_empty(a));\n-    assert (vec::tail(a) == [12]);\n-}\n-\n-#[test]\n-fn test_last() {\n-    let n = vec::last([]);\n-    assert (n == none);\n-    n = vec::last([1, 2, 3]);\n-    assert (n == some(3));\n-    n = vec::last([1, 2, 3, 4, 5]);\n-    assert (n == some(5));\n-}\n-\n-#[test]\n-fn test_slice() {\n-    // Test on-stack -> on-stack slice.\n-    let v = vec::slice([1, 2, 3], 1u, 3u);\n-    assert (vec::len(v) == 2u);\n-    assert (v[0] == 2);\n-    assert (v[1] == 3);\n-\n-    // Test on-heap -> on-stack slice.\n-    v = vec::slice([1, 2, 3, 4, 5], 0u, 3u);\n-    assert (vec::len(v) == 3u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 2);\n-    assert (v[2] == 3);\n-\n-    // Test on-heap -> on-heap slice.\n-    v = vec::slice([1, 2, 3, 4, 5, 6], 1u, 6u);\n-    assert (vec::len(v) == 5u);\n-    assert (v[0] == 2);\n-    assert (v[1] == 3);\n-    assert (v[2] == 4);\n-    assert (v[3] == 5);\n-    assert (v[4] == 6);\n-}\n-\n-#[test]\n-fn test_pop() {\n-    // Test on-stack pop.\n-    let v = [1, 2, 3];\n-    let e = vec::pop(v);\n-    assert (vec::len(v) == 2u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 2);\n-    assert (e == 3);\n-\n-    // Test on-heap pop.\n-    v = [1, 2, 3, 4, 5];\n-    e = vec::pop(v);\n-    assert (vec::len(v) == 4u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 2);\n-    assert (v[2] == 3);\n-    assert (v[3] == 4);\n-    assert (e == 5);\n-}\n-\n-#[test]\n-fn test_push() {\n-    // Test on-stack push().\n-    let v = [];\n-    vec::push(v, 1);\n-    assert (vec::len(v) == 1u);\n-    assert (v[0] == 1);\n-\n-    // Test on-heap push().\n-    vec::push(v, 2);\n-    assert (vec::len(v) == 2u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 2);\n-}\n-\n-#[test]\n-fn test_grow() {\n-    // Test on-stack grow().\n-    let v = [];\n-    vec::grow(v, 2u, 1);\n-    assert (vec::len(v) == 2u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 1);\n-\n-    // Test on-heap grow().\n-    vec::grow(v, 3u, 2);\n-    assert (vec::len(v) == 5u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 1);\n-    assert (v[2] == 2);\n-    assert (v[3] == 2);\n-    assert (v[4] == 2);\n-}\n-\n-#[test]\n-fn test_grow_fn() {\n-    let v = [];\n-    vec::grow_fn(v, 3u, square);\n-    assert (vec::len(v) == 3u);\n-    assert (v[0] == 0u);\n-    assert (v[1] == 1u);\n-    assert (v[2] == 4u);\n-}\n-\n-#[test]\n-fn test_grow_set() {\n-    let v = [mutable 1, 2, 3];\n-    vec::grow_set(v, 4u, 4, 5);\n-    assert (vec::len(v) == 5u);\n-    assert (v[0] == 1);\n-    assert (v[1] == 2);\n-    assert (v[2] == 3);\n-    assert (v[3] == 4);\n-    assert (v[4] == 5);\n-}\n-\n-#[test]\n-fn test_map() {\n-    // Test on-stack map.\n-    let v = [1u, 2u, 3u];\n-    let w = vec::map(v, square_ref);\n-    assert (vec::len(w) == 3u);\n-    assert (w[0] == 1u);\n-    assert (w[1] == 4u);\n-    assert (w[2] == 9u);\n-\n-    // Test on-heap map.\n-    v = [1u, 2u, 3u, 4u, 5u];\n-    w = vec::map(v, square_ref);\n-    assert (vec::len(w) == 5u);\n-    assert (w[0] == 1u);\n-    assert (w[1] == 4u);\n-    assert (w[2] == 9u);\n-    assert (w[3] == 16u);\n-    assert (w[4] == 25u);\n-}\n-\n-#[test]\n-fn test_map2() {\n-    fn times(&&x: int, &&y: int) -> int { ret x * y; }\n-    let f = times;\n-    let v0 = [1, 2, 3, 4, 5];\n-    let v1 = [5, 4, 3, 2, 1];\n-    let u = vec::map2::<int, int, int>(v0, v1, f);\n-    let i = 0;\n-    while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n-}\n-\n-#[test]\n-fn test_filter_map() {\n-    // Test on-stack filter-map.\n-    let v = [1u, 2u, 3u];\n-    let w = vec::filter_map(v, square_if_odd);\n-    assert (vec::len(w) == 2u);\n-    assert (w[0] == 1u);\n-    assert (w[1] == 9u);\n-\n-    // Test on-heap filter-map.\n-    v = [1u, 2u, 3u, 4u, 5u];\n-    w = vec::filter_map(v, square_if_odd);\n-    assert (vec::len(w) == 3u);\n-    assert (w[0] == 1u);\n-    assert (w[1] == 9u);\n-    assert (w[2] == 25u);\n-\n-    fn halve(&&i: int) -> option::t<int> {\n-        if i % 2 == 0 {\n-            ret option::some::<int>(i / 2);\n-        } else { ret option::none::<int>; }\n-    }\n-    fn halve_for_sure(&&i: int) -> int { ret i / 2; }\n-    let all_even: [int] = [0, 2, 8, 6];\n-    let all_odd1: [int] = [1, 7, 3];\n-    let all_odd2: [int] = [];\n-    let mix: [int] = [9, 2, 6, 7, 1, 0, 0, 3];\n-    let mix_dest: [int] = [1, 3, 0, 0];\n-    assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n-    assert (filter_map(all_odd1, halve) == []);\n-    assert (filter_map(all_odd2, halve) == []);\n-    assert (filter_map(mix, halve) == mix_dest);\n-}\n-\n-#[test]\n-fn test_filter() {\n-    assert filter([1u, 2u, 3u], is_odd) == [1u, 3u];\n-    assert filter([1u, 2u, 4u, 8u, 16u], is_three) == [];\n-}\n-\n-#[test]\n-fn test_foldl() {\n-    // Test on-stack fold.\n-    let v = [1u, 2u, 3u];\n-    let sum = vec::foldl(0u, v, add);\n-    assert (sum == 6u);\n-\n-    // Test on-heap fold.\n-    v = [1u, 2u, 3u, 4u, 5u];\n-    sum = vec::foldl(0u, v, add);\n-    assert (sum == 15u);\n-}\n-\n-#[test]\n-fn test_foldl2() {\n-    fn sub(&&a: int, &&b: int) -> int {\n-        a - b\n-    }\n-    let v = [1, 2, 3, 4];\n-    let sum = vec::foldl(0, v, sub);\n-    assert sum == -10;\n-}\n-\n-#[test]\n-fn test_foldr() {\n-    fn sub(&&a: int, &&b: int) -> int {\n-        a - b\n-    }\n-    let v = [1, 2, 3, 4];\n-    let sum = vec::foldr(v, 0, sub);\n-    assert sum == -2;\n-}\n-\n-#[test]\n-fn iter_empty() {\n-    let i = 0;\n-    vec::iter::<int>([], { |_v| i += 1 });\n-    assert i == 0;\n-}\n-\n-#[test]\n-fn iter_nonempty() {\n-    let i = 0;\n-    vec::iter([1, 2, 3], { |v| i += v });\n-    assert i == 6;\n-}\n-\n-#[test]\n-fn iteri() {\n-    let i = 0;\n-    vec::iteri([1, 2, 3], { |j, v|\n-        if i == 0 { assert v == 1; }\n-        assert j + 1u == v as uint;\n-        i += v;\n-                          });\n-    assert i == 6;\n-}\n-\n-#[test]\n-fn riter_empty() {\n-    let i = 0;\n-    vec::riter::<int>([], { |_v| i += 1 });\n-    assert i == 0;\n-}\n-\n-#[test]\n-fn riter_nonempty() {\n-    let i = 0;\n-    vec::riter([1, 2, 3], { |v|\n-        if i == 0 { assert v == 3; }\n-        i += v\n-                         });\n-    assert i == 6;\n-}\n-\n-#[test]\n-fn riteri() {\n-    let i = 0;\n-    vec::riteri([0, 1, 2], { |j, v|\n-        if i == 0 { assert v == 2; }\n-        assert j == v as uint;\n-        i += v;\n-                          });\n-    assert i == 3;\n-}\n-\n-#[test]\n-fn test_permute() {\n-  let results: [[int]];\n-\n-  results = [];\n-  permute([]) {|v| results += [v]; }\n-  assert results == [[]];\n-\n-  results = [];\n-  permute([7]) {|v| results += [v]; }\n-  assert results == [[7]];\n-\n-  results = [];\n-  permute([1,1]) {|v| results += [v]; }\n-  assert results == [[1,1],[1,1]];\n-\n-  results = [];\n-  permute([5,2,0]) {|v| results += [v]; }\n-  assert results == [[5,2,0],[5,0,2],[2,5,0],[2,0,5],[0,5,2],[0,2,5]];\n-}\n-\n-#[test]\n-fn test_any_and_all() {\n-    assert (vec::any([1u, 2u, 3u], is_three));\n-    assert (!vec::any([0u, 1u, 2u], is_three));\n-    assert (vec::any([1u, 2u, 3u, 4u, 5u], is_three));\n-    assert (!vec::any([1u, 2u, 4u, 5u, 6u], is_three));\n-\n-    assert (vec::all([3u, 3u, 3u], is_three));\n-    assert (!vec::all([3u, 3u, 2u], is_three));\n-    assert (vec::all([3u, 3u, 3u, 3u, 3u], is_three));\n-    assert (!vec::all([3u, 3u, 0u, 1u, 2u], is_three));\n-}\n-\n-#[test]\n-fn test_any2_and_all2() {\n-\n-    assert (vec::any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-    assert (vec::any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-    assert (!vec::any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-    assert (vec::any2([2u, 4u, 6u], [2u, 4u], is_equal));\n-\n-    assert (vec::all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-    assert (!vec::all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-    assert (!vec::all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-    assert (!vec::all2([2u, 4u, 6u], [2u, 4u], is_equal));\n-}\n-\n-#[test]\n-fn test_zip_unzip() {\n-    let v1 = [1, 2, 3];\n-    let v2 = [4, 5, 6];\n-\n-    check (same_length(v1, v2)); // Silly, but what else can we do?\n-    let z1 = vec::zip(v1, v2);\n-\n-    assert ((1, 4) == z1[0]);\n-    assert ((2, 5) == z1[1]);\n-    assert ((3, 6) == z1[2]);\n-\n-    let (left, right) = vec::unzip(z1);\n-\n-    assert ((1, 4) == (left[0], right[0]));\n-    assert ((2, 5) == (left[1], right[1]));\n-    assert ((3, 6) == (left[2], right[2]));\n-}\n-\n-#[test]\n-fn test_position() {\n-    let v1: [int] = [1, 2, 3, 3, 2, 5];\n-    assert (position(1, v1) == option::some::<uint>(0u));\n-    assert (position(2, v1) == option::some::<uint>(1u));\n-    assert (position(5, v1) == option::some::<uint>(5u));\n-    assert (position(4, v1) == option::none::<uint>);\n-}\n-\n-#[test]\n-fn test_position_pred() {\n-    fn less_than_three(&&i: int) -> bool { ret i < 3; }\n-    fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n-    let v1: [int] = [5, 4, 3, 2, 1];\n-    assert (position_pred(v1, less_than_three) == option::some::<uint>(3u));\n-    assert (position_pred(v1, is_eighteen) == option::none::<uint>);\n-}\n-\n-#[test]\n-fn reverse_and_reversed() {\n-    let v: [mutable int] = [mutable 10, 20];\n-    assert (v[0] == 10);\n-    assert (v[1] == 20);\n-    vec::reverse(v);\n-    assert (v[0] == 20);\n-    assert (v[1] == 10);\n-    let v2 = vec::reversed::<int>([10, 20]);\n-    assert (v2[0] == 20);\n-    assert (v2[1] == 10);\n-    v[0] = 30;\n-    assert (v2[0] == 20);\n-    // Make sure they work with 0-length vectors too.\n-\n-    let v4 = vec::reversed::<int>([]);\n-    assert (v4 == []);\n-    let v3: [mutable int] = [mutable];\n-    vec::reverse::<int>(v3);\n-}\n-\n-#[test]\n-fn reversed_mut() {\n-    let v2 = vec::reversed::<int>([mutable 10, 20]);\n-    assert (v2[0] == 20);\n-    assert (v2[1] == 10);\n-}\n-\n-#[test]\n-fn init() {\n-    let v = vec::init([1, 2, 3]);\n-    assert v == [1, 2];\n-}\n-\n-#[test]\n-// FIXME: Windows can't undwind\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn init_empty() {\n-\n-    let r = task::join(\n-        task::spawn_joinable {||\n-            task::unsupervise();\n-            vec::init::<int>([]);\n-        });\n-    assert r == task::tr_failure\n-}\n-\n-#[test]\n-fn concat() {\n-    assert vec::concat([[1], [2,3]]) == [1, 2, 3];\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-"}]}