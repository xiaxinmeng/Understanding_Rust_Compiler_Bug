{"sha": "6937d5581af14b71e23af0db81241a3fea11c70a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MzdkNTU4MWFmMTRiNzFlMjNhZjBkYjgxMjQxYTNmZWExMWM3MGE=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-03-12T06:13:44Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-03-12T06:13:44Z"}, "message": "Merge branch 'master' into fix-3739", "tree": {"sha": "1d8324d8d46d7f64c7143a47d3a69054065abd8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d8324d8d46d7f64c7143a47d3a69054065abd8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6937d5581af14b71e23af0db81241a3fea11c70a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6937d5581af14b71e23af0db81241a3fea11c70a", "html_url": "https://github.com/rust-lang/rust/commit/6937d5581af14b71e23af0db81241a3fea11c70a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6937d5581af14b71e23af0db81241a3fea11c70a/comments", "author": null, "committer": null, "parents": [{"sha": "5332cdb7dc3f7c0a680397eb6b696b25759ba1a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5332cdb7dc3f7c0a680397eb6b696b25759ba1a4", "html_url": "https://github.com/rust-lang/rust/commit/5332cdb7dc3f7c0a680397eb6b696b25759ba1a4"}, {"sha": "1cdac4a9c798f8e22a4db220020713175eb9159b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cdac4a9c798f8e22a4db220020713175eb9159b", "html_url": "https://github.com/rust-lang/rust/commit/1cdac4a9c798f8e22a4db220020713175eb9159b"}], "stats": {"total": 15543, "additions": 8356, "deletions": 7187}, "files": [{"sha": "b05fa25fb1b42563cdaa9538fad58a9ae93a1789", "filename": "CHANGELOG.md", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,7 +4,38 @@ All notable changes to this project will be documented in this file.\n \n ## Unreleased / In Rust Beta or Nightly\n \n-[b2601be...master](https://github.com/rust-lang/rust-clippy/compare/b2601be...master)\n+[1b89724...master](https://github.com/rust-lang/rust-clippy/compare/1b89724...master)\n+\n+## Rust 1.33 (2019-02-26)\n+\n+[b2601be...1b89724](https://github.com/rust-lang/rust-clippy/compare/b2601be...1b89724)\n+\n+* New lints: [`implicit_return`], [`vec_box`], [`cast_ref_to_mut`]\n+* The `rust-clippy` repository is now part of the `rust-lang` org.\n+* Rename `stutter` to `module_name_repetitions`\n+* Merge `new_without_default_derive` into `new_without_default` lint\n+* Move `large_digit_groups` from `style` group to `pedantic`\n+* Expand `bool_comparison` to check for `<`, `<=`, `>`, `>=`, and `!=`\n+  comparisons against booleans\n+* Expand `no_effect` to detect writes to constants such as `A_CONST.field = 2`\n+* Expand `redundant_clone` to work on struct fields\n+* Expand `suspicious_else_formatting` to detect `if .. {..} {..}`\n+* Expand `use_self` to work on tuple structs and also in local macros\n+* Fix ICE in `result_map_unit_fn` and `option_map_unit_fn`\n+* Fix false positives in `implicit_return`\n+* Fix false positives in `use_self`\n+* Fix false negative in `clone_on_copy`\n+* Fix false positive in `doc_markdown`\n+* Fix false positive in `empty_loop`\n+* Fix false positive in `if_same_then_else`\n+* Fix false positive in `infinite_iter`\n+* Fix false positive in `question_mark`\n+* Fix false positive in `useless_asref`\n+* Fix false positive in `wildcard_dependencies`\n+* Fix false positive in `write_with_newline`\n+* Add suggestion to `explicit_write`\n+* Improve suggestions for `question_mark` lint\n+* Fix incorrect suggestion for `get_unwrap`\n \n ## Rust 1.32 (2019-01-17)\n \n@@ -767,11 +798,11 @@ All notable changes to this project will be documented in this file.\n [`cmp_nan`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_nan\n [`cmp_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_null\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n+[`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n [`const_static_lifetime`]: https://rust-lang.github.io/rust-clippy/master/index.html#const_static_lifetime\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n [`crosspointer_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#crosspointer_transmute\n-[`cyclomatic_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cyclomatic_complexity\n [`dbg_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#dbg_macro\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const"}, {"sha": "3eff20cead74f36cf8acf5498f64db9553becad3", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 114, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -14,11 +14,6 @@ All contributors are expected to follow the [Rust Code of Conduct](http://www.ru\n * [Getting started](#getting-started)\n   * [Finding something to fix/improve](#finding-something-to-fiximprove)\n * [Writing code](#writing-code)\n-  * [Author lint](#author-lint)\n-  * [Documentation](#documentation)\n-  * [Running test suite](#running-test-suite)\n-  * [Running rustfmt](#running-rustfmt)\n-  * [Testing manually](#testing-manually)\n * [How Clippy works](#how-clippy-works)\n * [Fixing nightly build failures](#fixing-build-failures-caused-by-rust)\n * [Issue and PR Triage](#issue-and-pr-triage)\n@@ -73,121 +68,15 @@ an AST expression). `match_def_path()` in Clippy's `utils` module can also be us\n \n ## Writing code\n \n-Clippy depends on the current git master version of rustc, which can change rapidly. Make sure you're\n-working near rust-clippy's master, and use the `setup-toolchain.sh` script to configure the appropriate\n-toolchain for this directory.\n-\n-[Llogiq's blog post on lints](https://llogiq.github.io/2015/06/04/workflows.html) is a nice primer\n-to lint-writing, though it does get into advanced stuff. Most lints consist of an implementation of\n-`LintPass` with one or more of its default methods overridden. See the existing lints for examples\n-of this.\n+Have a look at the [docs for writing lints](doc/adding_lints.md) for more details. [Llogiq's blog post on lints](https://llogiq.github.io/2015/06/04/workflows.html) is also a nice primer\n+to lint-writing, though it does get into advanced stuff and may be a bit\n+outdated.\n \n If you want to add a new lint or change existing ones apart from bugfixing, it's\n also a good idea to give the [stability guarantees][rfc_stability] and\n [lint categories][rfc_lint_cats] sections of the [Clippy 1.0 RFC][clippy_rfc] a\n quick read.\n \n-### Author lint\n-\n-There is also the internal `author` lint to generate Clippy code that detects the offending pattern. It does not work for all of the Rust syntax, but can give a good starting point.\n-\n-First, create a new UI test file in the `tests/ui/` directory with the pattern you want to match:\n-\n-```rust\n-// ./tests/ui/my_lint.rs\n-fn main() {\n-    #[clippy::author]\n-    let arr: [i32; 1] = [7]; // Replace line with the code you want to match\n-}\n-```\n-\n-Now you run `TESTNAME=ui/my_lint cargo uitest` to produce\n-a `.stdout` file with the generated code:\n-\n-```rust\n-// ./tests/ui/my_lint.stdout\n-\n-if_chain! {\n-    if let ExprKind::Array(ref elements) = stmt.node;\n-    if elements.len() == 1;\n-    if let ExprKind::Lit(ref lit) = elements[0].node;\n-    if let LitKind::Int(7, _) = lit.node;\n-    then {\n-        // report your lint here\n-    }\n-}\n-```\n-\n-If the command was executed successfully, you can copy the code over to where you are implementing your lint.\n-\n-### Documentation\n-\n-Please document your lint with a doc comment akin to the following:\n-\n-```rust\n-/// **What it does:** Checks for ... (describe what the lint matches).\n-///\n-/// **Why is this bad?** Supply the reason for linting the code.\n-///\n-/// **Known problems:** None. (Or describe where it could go wrong.)\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// // Bad\n-/// Insert a short example of code that triggers the lint\n-///\n-/// // Good\n-/// Insert a short example of improved code that doesn't trigger the lint\n-/// ```\n-```\n-\n-Once your lint is merged it will show up in the [lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n-\n-### Running test suite\n-\n-Use `cargo test` to run the whole testsuite.\n-\n-If you don't want to wait for all tests to finish, you can also execute a single test file by using `TESTNAME` to specify the test to run:\n-\n-```bash\n-TESTNAME=ui/empty_line_after_outer_attr cargo uitest\n-```\n-\n-Clippy uses UI tests. UI tests check that the output of the compiler is exactly as expected.\n-Of course there's little sense in writing the output yourself or copying it around.\n-Therefore you should use `tests/ui/update-all-references.sh` (after running\n-`cargo test`) and check whether the output looks as you expect with `git diff`. Commit all\n-`*.stderr` files, too.\n-\n-If the lint you are working on is making use of structured suggestions, the\n-test file should include a `// run-rustfix` comment at the top. This will\n-additionally run [rustfix](https://github.com/rust-lang-nursery/rustfix) for\n-that test. Rustfix will apply the suggestions from the lint to the code of the\n-test file and compare that to the contents of a `.fixed` file.\n-\n-Use `tests/ui/update-all-references.sh` to automatically generate the\n-`.fixed` file after running `cargo test`.\n-\n-### Running rustfmt\n-\n-[Rustfmt](https://github.com/rust-lang/rustfmt) is a tool for formatting Rust code according\n-to style guidelines. The code has to be formatted by `rustfmt` before a PR will be merged.\n-\n-It can be installed via `rustup`:\n-```bash\n-rustup component add rustfmt\n-```\n-\n-Use `cargo fmt --all` to format the whole codebase.\n-\n-### Testing manually\n-\n-Manually testing against an example file is useful if you have added some\n-`println!`s and test suite output becomes unreadable.  To try Clippy with your\n-local modifications, run `env CLIPPY_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs`\n-from the working copy root.\n-\n ## How Clippy works\n \n Clippy is a [rustc compiler plugin][compiler_plugin]. The main entry point is at [`src/lib.rs`][main_entry]. In there, the lint registration is delegated to the [`clippy_lints`][lint_crate] crate."}, {"sha": "024b8ff28ad45e796bec77e928249c83876b4804", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -47,7 +47,7 @@ rustc_tools_util = { version = \"0.1.1\", path = \"rustc_tools_util\"}\n [dev-dependencies]\n clippy_dev = { version = \"0.0.1\", path = \"clippy_dev\" }\n cargo_metadata = \"0.7.1\"\n-compiletest_rs = \"0.3.18\"\n+compiletest_rs = \"0.3.19\"\n lazy_static = \"1.0\"\n serde_derive = \"1.0\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }"}, {"sha": "0fd7c557dd61019f5950a3d56c854de7568da867", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -11,14 +11,14 @@ A collection of lints to catch common mistakes and improve your [Rust](https://g\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n \n-* `clippy::all` (everything that has no false positives)\n-* `clippy::pedantic` (everything)\n-* `clippy::nursery` (new lints that aren't quite ready yet)\n+* `clippy::all` (everything that is on by default: all the categories below except for `nursery`, `pedantic`, and `cargo`)\n+* **`clippy::correctness`** (code that is just outright wrong or very very useless, causes hard errors by default)\n * `clippy::style` (code that should be written in a more idiomatic way)\n * `clippy::complexity` (code that does something simple but in a complex way)\n * `clippy::perf` (code that can be written in a faster way)\n-* `clippy::cargo` (checks against the cargo manifest)\n-* **`clippy::correctness`** (code that is just outright wrong or very very useless)\n+* `clippy::pedantic` (lints which are rather strict, off by default)\n+* `clippy::nursery` (new lints that aren't quite ready yet, off by default)\n+* `clippy::cargo` (checks against the cargo manifest, off by default)\n \n More to come, please [file an issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n \n@@ -31,6 +31,8 @@ Only the following of those categories are enabled by default:\n \n Other categories need to be enabled in order for their lints to be executed.\n \n+The [lint list](https://rust-lang.github.io/rust-clippy/master/index.html) also contains \"restriction lints\", which are for things which are usually not considered \"bad\", but may be useful to turn on in specific cases. These should be used very selectively, if at all.\n+\n Table of contents:\n \n *   [Usage instructions](#usage)\n@@ -105,13 +107,13 @@ script:\n   - cargo clippy\n   # if you want the build job to fail when encountering warnings, use\n   - cargo clippy -- -D warnings\n-  # in order to also check tests and none-default crate features, use\n+  # in order to also check tests and non-default crate features, use\n   - cargo clippy --all-targets --all-features -- -D warnings\n   - cargo test\n   # etc.\n ```\n \n-It might happen that Clippy is not available for a certain nightly release.\n+If you are on nightly, It might happen that Clippy is not available for a certain nightly release.\n In this case you can try to conditionally install Clippy from the git repo.\n \n ```yaml\n@@ -129,7 +131,7 @@ Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml\n \n ```toml\n blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n-cyclomatic-complexity-threshold = 30\n+cognitive-complexity-threshold = 30\n ```\n \n See the [list of lints](https://rust-lang.github.io/rust-clippy/master/index.html) for more information about which lints can be configured and the"}, {"sha": "fbb5d1cba48dd4b59611d2be587f4e88cd50419e", "filename": "ci/base-tests.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,7 +4,7 @@ echo \"Running clippy base tests\"\n \n PATH=$PATH:./node_modules/.bin\n if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then\n-  remark -f *.md > /dev/null\n+  remark -f *.md -f doc/*.md > /dev/null\n fi\n # build clippy in debug mode and run tests\n cargo build --features debugging\n@@ -59,7 +59,7 @@ rustup override set nightly\n # avoid loop spam and allow cmds with exit status != 0\n set +ex\n \n-for file in `find tests -not -path \"tests/ui/methods.rs\" -not -path \"tests/ui/format.rs\" -not -path \"tests/ui/formatting.rs\" -not -path \"tests/ui/empty_line_after_outer_attribute.rs\" -not -path \"tests/ui/double_parens.rs\" -not -path \"tests/ui/doc.rs\" -not -path \"tests/ui/unused_unit.rs\" | grep \"\\.rs$\"` ; do\n+for file in `find tests | grep \"\\.rs$\"` ; do\n   rustfmt ${file} --check\n   if [ $? -ne 0 ]; then\n     echo \"${file} needs reformatting!\""}, {"sha": "31b0a98c1ab74f2998e1e20cd058700ff1701f0c", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -12,8 +12,9 @@ use walkdir::WalkDir;\n lazy_static! {\n     static ref DEC_CLIPPY_LINT_RE: Regex = Regex::new(\n         r#\"(?x)\n-        declare_clippy_lint!\\s*[\\{(]\\s*\n-        pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        declare_clippy_lint!\\s*[\\{(]\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n         (?P<cat>[a-z_]+)\\s*,\\s*\n         \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n     \"#\n@@ -22,7 +23,8 @@ lazy_static! {\n     static ref DEC_DEPRECATED_LINT_RE: Regex = Regex::new(\n         r#\"(?x)\n         declare_deprecated_lint!\\s*[{(]\\s*\n-        pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n         \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n     \"#\n     )\n@@ -189,7 +191,7 @@ pub struct FileChange {\n     pub new_lines: String,\n }\n \n-/// Replace a region in a file delimited by two lines matching regexes.\n+/// Replaces a region in a file delimited by two lines matching regexes.\n ///\n /// `path` is the relative path to the file on which you want to perform the replacement.\n ///\n@@ -223,7 +225,7 @@ where\n     file_change\n }\n \n-/// Replace a region in a text delimited by two lines matching regexes.\n+/// Replaces a region in a text delimited by two lines matching regexes.\n ///\n /// * `text` is the input text on which you want to perform the replacement\n /// * `start` is a `&str` that describes the delimiter line before the region you want to replace."}, {"sha": "3f21b9dee11face627b7099be13162f17b85882f", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -2,7 +2,7 @@ extern crate clap;\n extern crate clippy_dev;\n extern crate regex;\n \n-use clap::{App, Arg, SubCommand};\n+use clap::{App, AppSettings, Arg, SubCommand};\n use clippy_dev::*;\n \n #[derive(PartialEq)]\n@@ -13,9 +13,11 @@ enum UpdateMode {\n \n fn main() {\n     let matches = App::new(\"Clippy developer tooling\")\n+        .setting(AppSettings::SubcommandRequiredElseHelp)\n         .subcommand(\n             SubCommand::with_name(\"update_lints\")\n-                .about(\n+                .about(\"Updates lint registration and information from the source code\")\n+                .long_about(\n                     \"Makes sure that:\\n \\\n                      * the lint count in README.md is correct\\n \\\n                      * the changelog contains markdown link references at the bottom\\n \\"}, {"sha": "fa586ad45c23c6bebde7edf3ac7dc062c4e59a93", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,28 +6,28 @@ use std::f64::consts as f64;\n use syntax::ast::{FloatTy, Lit, LitKind};\n use syntax::symbol;\n \n-/// **What it does:** Checks for floating point literals that approximate\n-/// constants which are defined in\n-/// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n-/// or\n-/// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n-/// respectively, suggesting to use the predefined constant.\n-///\n-/// **Why is this bad?** Usually, the definition in the standard library is more\n-/// precise than what people come up with. If you find that your definition is\n-/// actually more precise, please [file a Rust\n-/// issue](https://github.com/rust-lang/rust/issues).\n-///\n-/// **Known problems:** If you happen to have a value that is within 1/8192 of a\n-/// known constant, but is not *and should not* be the same, this lint will\n-/// report your value anyway. We have not yet noticed any false positives in\n-/// code we tested clippy with (this includes servo), but YMMV.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = 3.14;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for floating point literals that approximate\n+    /// constants which are defined in\n+    /// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+    /// or\n+    /// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+    /// respectively, suggesting to use the predefined constant.\n+    ///\n+    /// **Why is this bad?** Usually, the definition in the standard library is more\n+    /// precise than what people come up with. If you find that your definition is\n+    /// actually more precise, please [file a Rust\n+    /// issue](https://github.com/rust-lang/rust/issues).\n+    ///\n+    /// **Known problems:** If you happen to have a value that is within 1/8192 of a\n+    /// known constant, but is not *and should not* be the same, this lint will\n+    /// report your value anyway. We have not yet noticed any false positives in\n+    /// code we tested clippy with (this includes servo), but YMMV.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 3.14;\n+    /// ```\n     pub APPROX_CONSTANT,\n     correctness,\n     \"the approximate of a known float constant (in `std::fXX::consts`)\"\n@@ -104,7 +104,7 @@ fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, mod\n     }\n }\n \n-/// Returns false if the number of significant figures in `value` are\n+/// Returns `false` if the number of significant figures in `value` are\n /// less than `min_digits`; otherwise, returns true if `value` is equal\n /// to `constant`, rounded to the number of digits present in `value`.\n fn is_approx_const(constant: f64, value: &str, min_digits: usize) -> bool {"}, {"sha": "416ec656e12a44bb5d1729f15e2c413c46ddb176", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,36 +5,36 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for plain integer arithmetic.\n-///\n-/// **Why is this bad?** This is only checked against overflow in debug builds.\n-/// In some applications one wants explicitly checked, wrapping or saturating\n-/// arithmetic.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for plain integer arithmetic.\n+    ///\n+    /// **Why is this bad?** This is only checked against overflow in debug builds.\n+    /// In some applications one wants explicitly checked, wrapping or saturating\n+    /// arithmetic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + 1\n+    /// ```\n     pub INTEGER_ARITHMETIC,\n     restriction,\n     \"any integer arithmetic statement\"\n }\n \n-/// **What it does:** Checks for float arithmetic.\n-///\n-/// **Why is this bad?** For some embedded systems or kernel development, it\n-/// can be useful to rule out floating-point numbers.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + 1.0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for float arithmetic.\n+    ///\n+    /// **Why is this bad?** For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + 1.0\n+    /// ```\n     pub FLOAT_ARITHMETIC,\n     restriction,\n     \"any floating-point arithmetic statement\""}, {"sha": "9e2a8c451ee1e24fa95c8e10975b02bfe33d6dd9", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,31 +1,32 @@\n+use if_chain::if_chain;\n+use rustc::hir::{Expr, ExprKind};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_tool_lint, lint_array};\n+\n use crate::consts::{constant, Constant};\n-use crate::rustc::hir::{Expr, ExprKind};\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::LitKind;\n use crate::utils::{in_macro, is_direct_expn_of, span_help_and_lint};\n-use if_chain::if_chain;\n \n-/// **What it does:** Check to call assert!(true/false)\n-///\n-/// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n-/// panic!() or unreachable!()\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// assert!(false)\n-/// // or\n-/// assert!(true)\n-/// // or\n-/// const B: bool = false;\n-/// assert!(B)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `assert!(true)` and `assert!(false)` calls.\n+    ///\n+    /// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n+    /// panic!() or unreachable!()\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// assert!(false)\n+    /// // or\n+    /// assert!(true)\n+    /// // or\n+    /// const B: bool = false;\n+    /// assert!(B)\n+    /// ```\n     pub ASSERTIONS_ON_CONSTANTS,\n     style,\n-    \"assert!(true/false) will be optimized out by the compiler/should probably be replaced by a panic!() or unreachable!()\"\n+    \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\"\n }\n \n pub struct AssertionsOnConstants;"}, {"sha": "a39685f85ff8d9e0f4a2953bb03f05dd7fd98d3f", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 91, "deletions": 87, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,50 +1,53 @@\n-use crate::utils::{get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, SpanlessEq};\n-use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast;\n \n-/// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n-/// patterns.\n-///\n-/// **Why is this bad?** These can be written as the shorter `a op= b`.\n-///\n-/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n-/// implementations that differ from the regular `Op` impl.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut a = 5;\n-/// ...\n-/// a = a + b;\n-/// ```\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+};\n+use crate::utils::{higher, sugg};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// **Why is this bad?** These can be written as the shorter `a op= b`.\n+    ///\n+    /// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    /// a = a + b;\n+    /// ```\n     pub ASSIGN_OP_PATTERN,\n     style,\n     \"assigning the result of an operation on a variable to that same variable\"\n }\n \n-/// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n-///\n-/// **Why is this bad?** Most likely these are bugs where one meant to write `a\n-/// op= b`.\n-///\n-/// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n-/// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n-/// If `a op= a op b` is really the correct behaviour it should be\n-/// written as `a = a op a op b` as it's less confusing.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut a = 5;\n-/// ...\n-/// a += a + b;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// **Why is this bad?** Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+    /// If `a op= a op b` is really the correct behaviour it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// ...\n+    /// a += a + b;\n+    /// ```\n     pub MISREFACTORED_ASSIGN_OP,\n     complexity,\n     \"having a variable on both sides of an assign op\"\n@@ -69,58 +72,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n         match &expr.node {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n-                    if op.node == binop.node {\n-                        let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n-                            span_lint_and_then(\n-                                cx,\n-                                MISREFACTORED_ASSIGN_OP,\n-                                expr.span,\n-                                \"variable appears on both sides of an assignment operation\",\n-                                |db| {\n-                                    if let (Some(snip_a), Some(snip_r)) =\n-                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span))\n-                                    {\n-                                        let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                                        let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                                        let long =\n-                                            format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            &format!(\n-                                                \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n-                                                snip_a,\n-                                                snip_a,\n-                                                op.node.as_str(),\n-                                                snip_r,\n-                                                long\n-                                            ),\n-                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            \"or\",\n-                                            long,\n-                                            Applicability::MachineApplicable, // snippet\n-                                        );\n-                                    }\n-                                },\n-                            );\n-                        };\n-                        // lhs op= l op r\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n-                            lint(lhs, r);\n-                        }\n-                        // lhs op= l commutative_op r\n-                        if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n-                            lint(lhs, l);\n-                        }\n+                    if op.node != binop.node {\n+                        return;\n+                    }\n+                    // lhs op= l op r\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n+                    }\n+                    // lhs op= l commutative_op r\n+                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n             },\n             hir::ExprKind::Assign(assignee, e) => {\n                 if let hir::ExprKind::Binary(op, l, r) = &e.node {\n-                    #[allow(clippy::cyclomatic_complexity)]\n+                    #[allow(clippy::cognitive_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n                         let rty = cx.tables.expr_ty(rhs);\n@@ -140,14 +107,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             return; // useless if the trait doesn't exist\n                                         };\n                                         // check that we are not inside an `impl AssignOp` of this exact operation\n-                                        let parent_fn = cx.tcx.hir().get_parent(e.id);\n-                                        let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n-                                        // the crate node is the only one that is not in the map\n+                                        let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n                                         if_chain! {\n-                                            if parent_impl != ast::CRATE_NODE_ID;\n-                                            if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-                                            if let hir::ItemKind::Impl(_, _, _, _, Some(trait_ref), _, _) =\n-                                                &item.node;\n+                                            if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n                                         }\n@@ -235,6 +197,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    op: hir::BinOp,\n+    rhs: &hir::Expr,\n+    assignee: &hir::Expr,\n+    rhs_other: &hir::Expr,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |db| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n+                db.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.node.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                    Applicability::MachineApplicable,\n+                );\n+                db.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n fn is_commutative(op: hir::BinOpKind) -> bool {\n     use rustc::hir::BinOpKind::*;\n     match op {"}, {"sha": "ab3b7e471ac04cb0cfd5ff7f345c677e6aa2edb1", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -2,8 +2,8 @@\n \n use crate::reexport::*;\n use crate::utils::{\n-    in_macro, last_line_of_span, match_def_path, opt_def_id, paths, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, without_block_comments,\n+    in_macro, last_line_of_span, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    without_block_comments,\n };\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -17,170 +17,170 @@ use semver::Version;\n use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for items annotated with `#[inline(always)]`,\n-/// unless the annotated function is empty or simply panics.\n-///\n-/// **Why is this bad?** While there are valid uses of this annotation (and once\n-/// you know when to use it, by all means `allow` this lint), it's a common\n-/// newbie-mistake to pepper one's code with it.\n-///\n-/// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n-/// measure if that additional function call really affects your runtime profile\n-/// sufficiently to make up for the increase in compile time.\n-///\n-/// **Known problems:** False positives, big time. This lint is meant to be\n-/// deactivated by everyone doing serious performance work. This means having\n-/// done the measurement.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[inline(always)]\n-/// fn not_quite_hot_code(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n+    /// unless the annotated function is empty or simply panics.\n+    ///\n+    /// **Why is this bad?** While there are valid uses of this annotation (and once\n+    /// you know when to use it, by all means `allow` this lint), it's a common\n+    /// newbie-mistake to pepper one's code with it.\n+    ///\n+    /// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+    /// measure if that additional function call really affects your runtime profile\n+    /// sufficiently to make up for the increase in compile time.\n+    ///\n+    /// **Known problems:** False positives, big time. This lint is meant to be\n+    /// deactivated by everyone doing serious performance work. This means having\n+    /// done the measurement.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// #[inline(always)]\n+    /// fn not_quite_hot_code(..) { ... }\n+    /// ```\n     pub INLINE_ALWAYS,\n     pedantic,\n     \"use of `#[inline(always)]`\"\n }\n \n-/// **What it does:** Checks for `extern crate` and `use` items annotated with\n-/// lint attributes.\n-///\n-/// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n-/// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n-/// `#[macro_use]` attribute.\n-///\n-/// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n-/// likely a `!` was forgotten.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// #[deny(dead_code)]\n-/// extern crate foo;\n-/// #[forbid(dead_code)]\n-/// use foo::bar;\n-///\n-/// // Ok\n-/// #[allow(unused_imports)]\n-/// use foo::baz;\n-/// #[allow(unused_imports)]\n-/// #[macro_use]\n-/// extern crate baz;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `extern crate` and `use` items annotated with\n+    /// lint attributes.\n+    ///\n+    /// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n+    /// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n+    /// `#[macro_use]` attribute.\n+    ///\n+    /// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n+    /// likely a `!` was forgotten.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // Bad\n+    /// #[deny(dead_code)]\n+    /// extern crate foo;\n+    /// #[forbid(dead_code)]\n+    /// use foo::bar;\n+    ///\n+    /// // Ok\n+    /// #[allow(unused_imports)]\n+    /// use foo::baz;\n+    /// #[allow(unused_imports)]\n+    /// #[macro_use]\n+    /// extern crate baz;\n+    /// ```\n     pub USELESS_ATTRIBUTE,\n     correctness,\n     \"use of lint attributes on `extern crate` items\"\n }\n \n-/// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n-/// field that is not a valid semantic version.\n-///\n-/// **Why is this bad?** For checking the version of the deprecation, it must be\n-/// a valid semver. Failing that, the contained information is useless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[deprecated(since = \"forever\")]\n-/// fn something_else(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n+    /// field that is not a valid semantic version.\n+    ///\n+    /// **Why is this bad?** For checking the version of the deprecation, it must be\n+    /// a valid semver. Failing that, the contained information is useless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[deprecated(since = \"forever\")]\n+    /// fn something_else() { /* ... */ }\n+    /// ```\n     pub DEPRECATED_SEMVER,\n     correctness,\n     \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n }\n \n-/// **What it does:** Checks for empty lines after outer attributes\n-///\n-/// **Why is this bad?**\n-/// Most likely the attribute was meant to be an inner attribute using a '!'.\n-/// If it was meant to be an outer attribute, then the following item\n-/// should not be separated by empty lines.\n-///\n-/// **Known problems:** Can cause false positives.\n-///\n-/// From the clippy side it's difficult to detect empty lines between an attributes and the\n-/// following item because empty lines and comments are not part of the AST. The parsing\n-/// currently works for basic cases but is not perfect.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// #[inline(always)]\n-///\n-/// fn not_quite_good_code(..) { ... }\n-///\n-/// // Good (as inner attribute)\n-/// #![inline(always)]\n-///\n-/// fn this_is_fine(..) { ... }\n-///\n-/// // Good (as outer attribute)\n-/// #[inline(always)]\n-/// fn this_is_fine_too(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for empty lines after outer attributes\n+    ///\n+    /// **Why is this bad?**\n+    /// Most likely the attribute was meant to be an inner attribute using a '!'.\n+    /// If it was meant to be an outer attribute, then the following item\n+    /// should not be separated by empty lines.\n+    ///\n+    /// **Known problems:** Can cause false positives.\n+    ///\n+    /// From the clippy side it's difficult to detect empty lines between an attributes and the\n+    /// following item because empty lines and comments are not part of the AST. The parsing\n+    /// currently works for basic cases but is not perfect.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// #[inline(always)]\n+    ///\n+    /// fn not_quite_good_code(..) { ... }\n+    ///\n+    /// // Good (as inner attribute)\n+    /// #![inline(always)]\n+    ///\n+    /// fn this_is_fine(..) { ... }\n+    ///\n+    /// // Good (as outer attribute)\n+    /// #[inline(always)]\n+    /// fn this_is_fine_too(..) { ... }\n+    /// ```\n     pub EMPTY_LINE_AFTER_OUTER_ATTR,\n     nursery,\n     \"empty line after outer attribute\"\n }\n \n-/// **What it does:** Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\n-/// lints and if those lints exist in clippy. If there is a uppercase letter in the lint name\n-/// (not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\n-/// the lint name.\n-///\n-/// **Why is this bad?** A lint attribute with a mistyped lint name won't have an effect.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// Bad:\n-/// ```rust\n-/// #![warn(if_not_els)]\n-/// #![deny(clippy::All)]\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// #![warn(if_not_else)]\n-/// #![deny(clippy::all)]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\n+    /// lints and if those lints exist in clippy. If there is a uppercase letter in the lint name\n+    /// (not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\n+    /// the lint name.\n+    ///\n+    /// **Why is this bad?** A lint attribute with a mistyped lint name won't have an effect.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// #![warn(if_not_els)]\n+    /// #![deny(clippy::All)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![warn(if_not_else)]\n+    /// #![deny(clippy::all)]\n+    /// ```\n     pub UNKNOWN_CLIPPY_LINTS,\n     style,\n     \"unknown_lints for scoped Clippy lints\"\n }\n \n-/// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n-/// with `#[rustfmt::skip]`.\n-///\n-/// **Why is this bad?** Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n-/// are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n-///\n-/// **Known problems:** This lint doesn't detect crate level inner attributes, because they get\n-/// processed before the PreExpansionPass lints get executed. See\n-/// [#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n-///\n-/// **Example:**\n-///\n-/// Bad:\n-/// ```rust\n-/// #[cfg_attr(rustfmt, rustfmt_skip)]\n-/// fn main() { }\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// #[rustfmt::skip]\n-/// fn main() { }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n+    /// with `#[rustfmt::skip]`.\n+    ///\n+    /// **Why is this bad?** Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n+    /// are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n+    ///\n+    /// **Known problems:** This lint doesn't detect crate level inner attributes, because they get\n+    /// processed before the PreExpansionPass lints get executed. See\n+    /// [#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust\n+    /// #[cfg_attr(rustfmt, rustfmt_skip)]\n+    /// fn main() { }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #[rustfmt::skip]\n+    /// fn main() { }\n+    /// ```\n     pub DEPRECATED_CFG_ATTR,\n     complexity,\n     \"usage of `cfg_attr(rustfmt)` instead of `tool_attributes`\"\n@@ -396,7 +396,7 @@ fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.node {\n-                if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n+                if let Some(fun_id) = tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n                     !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n                 } else {\n                     true"}, {"sha": "c57b1c5366c4d203ec589bf8e06c52bb11826897", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,83 +9,83 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for incompatible bit masks in comparisons.\n-///\n-/// The formula for detecting if an expression of the type `_ <bit_op> m\n-/// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n-/// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n-/// table:\n-///\n-/// |Comparison  |Bit Op|Example     |is always|Formula               |\n-/// |------------|------|------------|---------|----------------------|\n-/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n-/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n-///\n-/// **Why is this bad?** If the bits that the comparison cares about are always\n-/// set to zero or one by the bit mask, the comparison is constant `true` or\n-/// `false` (depending on mask, compared value, and operators).\n-///\n-/// So the code is actively misleading, and the only reason someone would write\n-/// this intentionally is to win an underhanded Rust contest or create a\n-/// test-case for this lint.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if (x & 1 == 2) { \u2026 }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for incompatible bit masks in comparisons.\n+    ///\n+    /// The formula for detecting if an expression of the type `_ <bit_op> m\n+    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+    /// table:\n+    ///\n+    /// |Comparison  |Bit Op|Example     |is always|Formula               |\n+    /// |------------|------|------------|---------|----------------------|\n+    /// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+    /// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+    /// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+    /// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+    /// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+    /// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+    ///\n+    /// **Why is this bad?** If the bits that the comparison cares about are always\n+    /// set to zero or one by the bit mask, the comparison is constant `true` or\n+    /// `false` (depending on mask, compared value, and operators).\n+    ///\n+    /// So the code is actively misleading, and the only reason someone would write\n+    /// this intentionally is to win an underhanded Rust contest or create a\n+    /// test-case for this lint.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if (x & 1 == 2) { \u2026 }\n+    /// ```\n     pub BAD_BIT_MASK,\n     correctness,\n     \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n }\n \n-/// **What it does:** Checks for bit masks in comparisons which can be removed\n-/// without changing the outcome. The basic structure can be seen in the\n-/// following table:\n-///\n-/// |Comparison| Bit Op  |Example    |equals |\n-/// |----------|---------|-----------|-------|\n-/// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n-/// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n-///\n-/// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n-/// but still a bit misleading, because the bit mask is ineffective.\n-///\n-/// **Known problems:** False negatives: This lint will only match instances\n-/// where we have figured out the math (which is for a power-of-two compared\n-/// value). This means things like `x | 1 >= 7` (which would be better written\n-/// as `x >= 6`) will not be reported (but bit masks like this are fairly\n-/// uncommon).\n-///\n-/// **Example:**\n-/// ```rust\n-/// if (x | 1 > 3) { \u2026 }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks in comparisons which can be removed\n+    /// without changing the outcome. The basic structure can be seen in the\n+    /// following table:\n+    ///\n+    /// |Comparison| Bit Op  |Example    |equals |\n+    /// |----------|---------|-----------|-------|\n+    /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n+    /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n+    ///\n+    /// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+    /// but still a bit misleading, because the bit mask is ineffective.\n+    ///\n+    /// **Known problems:** False negatives: This lint will only match instances\n+    /// where we have figured out the math (which is for a power-of-two compared\n+    /// value). This means things like `x | 1 >= 7` (which would be better written\n+    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+    /// uncommon).\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if (x | 1 > 3) { \u2026 }\n+    /// ```\n     pub INEFFECTIVE_BIT_MASK,\n     correctness,\n-    \"expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\"\n+    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n }\n \n-/// **What it does:** Checks for bit masks that can be replaced by a call\n-/// to `trailing_zeros`\n-///\n-/// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n-/// == 0`\n-///\n-/// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n-///\n-/// **Example:**\n-/// ```rust\n-/// x & 0x1111 == 0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks that can be replaced by a call\n+    /// to `trailing_zeros`\n+    ///\n+    /// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n+    /// == 0`\n+    ///\n+    /// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x & 0x1111 == 0\n+    /// ```\n     pub VERBOSE_BIT_MASK,\n     style,\n     \"expressions where a bit mask is less readable than the corresponding method call\""}, {"sha": "c1ee4d528854609648067f967a03892e511ab06d", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,19 +4,19 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n \n-/// **What it does:** Checks for usage of blacklisted names for variables, such\n-/// as `foo`.\n-///\n-/// **Why is this bad?** These names are usually placeholder names and should be\n-/// avoided.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let foo = 3.14;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of blacklisted names for variables, such\n+    /// as `foo`.\n+    ///\n+    /// **Why is this bad?** These names are usually placeholder names and should be\n+    /// avoided.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo = 3.14;\n+    /// ```\n     pub BLACKLISTED_NAME,\n     style,\n     \"usage of a blacklisted/placeholder name\""}, {"sha": "f16631a5eff69feb70042308b10c8c3e957c064f", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,41 +5,41 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `if` conditions that use blocks to contain an\n-/// expression.\n-///\n-/// **Why is this bad?** It isn't really Rust style, same as using parentheses\n-/// to contain expressions.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if { true } ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks to contain an\n+    /// expression.\n+    ///\n+    /// **Why is this bad?** It isn't really Rust style, same as using parentheses\n+    /// to contain expressions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if { true } { /* ... */ }\n+    /// ```\n     pub BLOCK_IN_IF_CONDITION_EXPR,\n     style,\n-    \"braces that can be eliminated in conditions, e.g. `if { true } ...`\"\n+    \"braces that can be eliminated in conditions, e.g., `if { true } ...`\"\n }\n \n-/// **What it does:** Checks for `if` conditions that use blocks containing\n-/// statements, or conditions that use closures with blocks.\n-///\n-/// **Why is this bad?** Using blocks in the condition makes it hard to read.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if { let x = somefunc(); x } ..\n-/// // or\n-/// if somefunc(|x| { x == 47 }) ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks containing\n+    /// statements, or conditions that use closures with blocks.\n+    ///\n+    /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if { let x = somefunc(); x } {}\n+    /// // or\n+    /// if somefunc(|x| { x == 47 }) {}\n+    /// ```\n     pub BLOCK_IN_IF_CONDITION_STMT,\n     style,\n-    \"complex blocks in conditions, e.g. `if { let x = true; x } ...`\"\n+    \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "f7e0157746f41c48b2f96967e2f675cb0ce2a944", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,42 +7,42 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Applicability;\n-use syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::LitKind;\n use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n \n-/// **What it does:** Checks for boolean expressions that can be written more\n-/// concisely.\n-///\n-/// **Why is this bad?** Readability of boolean expressions suffers from\n-/// unnecessary duplication.\n-///\n-/// **Known problems:** Ignores short circuiting behavior of `||` and\n-/// `&&`. Ignores `|`, `&` and `^`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a && true  // should be: if a\n-/// if !(a == b)  // should be: if a != b\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that can be written more\n+    /// concisely.\n+    ///\n+    /// **Why is this bad?** Readability of boolean expressions suffers from\n+    /// unnecessary duplication.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior of `||` and\n+    /// `&&`. Ignores `|`, `&` and `^`.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a && true  // should be: if a\n+    /// if !(a == b)  // should be: if a != b\n+    /// ```\n     pub NONMINIMAL_BOOL,\n     complexity,\n     \"boolean expressions that can be written more concisely\"\n }\n \n-/// **What it does:** Checks for boolean expressions that contain terminals that\n-/// can be eliminated.\n-///\n-/// **Why is this bad?** This is most likely a logic bug.\n-///\n-/// **Known problems:** Ignores short circuiting behavior.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a && b || a { ... }\n-/// ```\n-/// The `b` is unnecessary, the expression is equivalent to `if a`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that contain terminals that\n+    /// can be eliminated.\n+    ///\n+    /// **Why is this bad?** This is most likely a logic bug.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a && b || a { ... }\n+    /// ```\n+    /// The `b` is unnecessary, the expression is equivalent to `if a`.\n     pub LOGIC_BUG,\n     correctness,\n     \"boolean expressions that contain terminals which can be eliminated\"\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         NonminimalBoolVisitor { cx }.visit_body(body)\n     }\n@@ -132,7 +132,6 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                     }\n \n                     let mk_expr = |op| Expr {\n-                        id: DUMMY_NODE_ID,\n                         hir_id: DUMMY_HIR_ID,\n                         span: DUMMY_SP,\n                         attrs: ThinVec::new(),"}, {"sha": "9fd82ae5946b7af0dc37f00c9b28cb5ea9e1c4d1", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,22 +10,22 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Name, UintTy};\n \n-/// **What it does:** Checks for naive byte counts\n-///\n-/// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n-/// crate has methods to count your bytes faster, especially for large slices.\n-///\n-/// **Known problems:** If you have predominantly small slices, the\n-/// `bytecount::count(..)` method may actually be slower. However, if you can\n-/// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n-/// faster in those cases.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// &my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for naive byte counts\n+    ///\n+    /// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// **Known problems:** If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// &my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n+    /// ```\n     pub NAIVE_BYTECOUNT,\n     perf,\n     \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\""}, {"sha": "57bdce4cf3a9a2b0624c7c65cbc1b01a5fca05ce", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,28 +7,28 @@ use syntax::{ast::*, source_map::DUMMY_SP};\n \n use cargo_metadata;\n \n-/// **What it does:** Checks to see if all common metadata is defined in\n-/// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n-///\n-/// **Why is this bad?** It will be more difficult for users to discover the\n-/// purpose of the crate, and key information related to it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```toml\n-/// # This `Cargo.toml` is missing an authors field:\n-/// [package]\n-/// name = \"clippy\"\n-/// version = \"0.0.212\"\n-/// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n-/// repository = \"https://github.com/rust-lang/rust-clippy\"\n-/// readme = \"README.md\"\n-/// license = \"MIT/Apache-2.0\"\n-/// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-/// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks to see if all common metadata is defined in\n+    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+    ///\n+    /// **Why is this bad?** It will be more difficult for users to discover the\n+    /// purpose of the crate, and key information related to it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```toml\n+    /// # This `Cargo.toml` is missing an authors field:\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT/Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n     pub CARGO_COMMON_METADATA,\n     cargo,\n     \"common metadata is defined in `Cargo.toml`\""}, {"sha": "d44784843e73955cc0ad4a6b3d698138e3edf445", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "renamed", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,54 +1,54 @@\n-//! calculate cyclomatic complexity and warn about overly complex functions\n+//! calculate cognitive complexity and warn about overly complex functions\n \n use rustc::cfg::CFG;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::{Attribute, NodeId};\n+use syntax::ast::Attribute;\n use syntax::source_map::Span;\n \n use crate::utils::{in_macro, is_allowed, match_type, paths, span_help_and_lint, LimitStack};\n \n-/// **What it does:** Checks for methods with high cyclomatic complexity.\n-///\n-/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly\n-/// readable. Also LLVM will usually optimize small methods better.\n-///\n-/// **Known problems:** Sometimes it's hard to find a way to reduce the\n-/// complexity.\n-///\n-/// **Example:** No. You'll see it when you get the warning.\n declare_clippy_lint! {\n-    pub CYCLOMATIC_COMPLEXITY,\n+    /// **What it does:** Checks for methods with high cognitive complexity.\n+    ///\n+    /// **Why is this bad?** Methods of high cognitive complexity tend to be hard to\n+    /// both read and maintain. Also LLVM will tend to optimize small methods better.\n+    ///\n+    /// **Known problems:** Sometimes it's hard to find a way to reduce the\n+    /// complexity.\n+    ///\n+    /// **Example:** No. You'll see it when you get the warning.\n+    pub COGNITIVE_COMPLEXITY,\n     complexity,\n     \"functions that should be split up into multiple functions\"\n }\n \n-pub struct CyclomaticComplexity {\n+pub struct CognitiveComplexity {\n     limit: LimitStack,\n }\n \n-impl CyclomaticComplexity {\n+impl CognitiveComplexity {\n     pub fn new(limit: u64) -> Self {\n         Self {\n             limit: LimitStack::new(limit),\n         }\n     }\n }\n \n-impl LintPass for CyclomaticComplexity {\n+impl LintPass for CognitiveComplexity {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CYCLOMATIC_COMPLEXITY)\n+        lint_array!(COGNITIVE_COMPLEXITY)\n     }\n \n     fn name(&self) -> &'static str {\n-        \"CyclomaticComplexity\"\n+        \"CognitiveComplexity\"\n     }\n }\n \n-impl CyclomaticComplexity {\n+impl CognitiveComplexity {\n     fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, body: &'tcx Body, span: Span) {\n         if in_macro(span) {\n             return;\n@@ -105,37 +105,37 @@ impl CyclomaticComplexity {\n             if rust_cc > self.limit.limit() {\n                 span_help_and_lint(\n                     cx,\n-                    CYCLOMATIC_COMPLEXITY,\n+                    COGNITIVE_COMPLEXITY,\n                     span,\n-                    &format!(\"the function has a cyclomatic complexity of {}\", rust_cc),\n+                    &format!(\"the function has a cognitive complexity of {}\", rust_cc),\n                     \"you could split it up into multiple smaller functions\",\n                 );\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n         _: intravisit::FnKind<'tcx>,\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        node_id: NodeId,\n+        hir_id: HirId,\n     ) {\n-        let def_id = cx.tcx.hir().local_def_id(node_id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n         if !cx.tcx.has_attr(def_id, \"test\") {\n             self.check(cx, body, span);\n         }\n     }\n \n     fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.push_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n     fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }\n \n@@ -201,7 +201,7 @@ fn report_cc_bug(\n ) {\n     span_bug!(\n         span,\n-        \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n+        \"Clippy encountered a bug calculating cognitive complexity: cc = {}, arms = {}, \\\n          div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n         cc,\n         narms,\n@@ -222,13 +222,12 @@ fn report_cc_bug(\n     span: Span,\n     id: HirId,\n ) {\n-    let node_id = cx.tcx.hir().hir_to_node_id(id);\n-    if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, node_id) {\n+    if !is_allowed(cx, COGNITIVE_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,\n             &format!(\n-                \"Clippy encountered a bug calculating cyclomatic complexity \\\n-                 (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n+                \"Clippy encountered a bug calculating cognitive complexity \\\n+                 (hide this message with `#[allow(cognitive_complexity)]`): \\\n                  cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n                  Please file a bug report.\",\n                 cc, narms, div, shorts, returns", "previous_filename": "clippy_lints/src/cyclomatic_complexity.rs"}, {"sha": "00e0787a927da99b119d55ce60dc3a39d162e73a", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -21,54 +21,54 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for nested `if` statements which can be collapsed\n-/// by `&&`-combining their conditions and for `else { if ... }` expressions\n-/// that\n-/// can be collapsed to `else if ...`.\n-///\n-/// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n-/// makes code look more complex than it really is.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// if x {\n-///     if y {\n-///         \u2026\n-///     }\n-/// }\n-///\n-/// // or\n-///\n-/// if x {\n-///     \u2026\n-/// } else {\n-///     if y {\n-///         \u2026\n-///     }\n-/// }\n-/// ```\n-///\n-/// Should be written:\n-///\n-/// ```rust.ignore\n-/// if x && y {\n-///     \u2026\n-/// }\n-///\n-/// // or\n-///\n-/// if x {\n-///     \u2026\n-/// } else if y {\n-///     \u2026\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for nested `if` statements which can be collapsed\n+    /// by `&&`-combining their conditions and for `else { if ... }` expressions\n+    /// that\n+    /// can be collapsed to `else if ...`.\n+    ///\n+    /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+    /// makes code look more complex than it really is.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if x {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Should be written:\n+    ///\n+    /// ```rust.ignore\n+    /// if x && y {\n+    ///     \u2026\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else if y {\n+    ///     \u2026\n+    /// }\n+    /// ```\n     pub COLLAPSIBLE_IF,\n     style,\n-    \"`if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\"\n+    \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "1e369044d2469a464613e2093ba4d23db79ec2c8", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,23 +4,23 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::*;\n \n-/// **What it does:** Checks for constants with an explicit `'static` lifetime.\n-///\n-/// **Why is this bad?** Adding `'static` to every reference can create very\n-/// complicated types.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// const FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n-/// &[...]\n-/// ```\n-/// This code can be rewritten as\n-/// ```rust\n-///  const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n+    ///\n+    /// **Why is this bad?** Adding `'static` to every reference can create very\n+    /// complicated types.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// const FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n+    /// &[...]\n+    /// ```\n+    /// This code can be rewritten as\n+    /// ```ignore\n+    ///  const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n+    /// ```\n     pub CONST_STATIC_LIFETIME,\n     style,\n     \"Using explicit `'static` lifetime for constants when elision rules would allow omitting them.\""}, {"sha": "8d71eb54277746368cfc568384777b44107f7ad7", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,7 +5,7 @@ use if_chain::if_chain;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::LateContext;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc::{bug, span_bug};\n use rustc_data_structures::sync::Lrc;\n@@ -21,27 +21,27 @@ use syntax_pos::symbol::Symbol;\n /// A `LitKind`-like enum to fold constant `Expr`s into.\n #[derive(Debug, Clone)]\n pub enum Constant {\n-    /// a String \"abc\"\n+    /// A `String` (e.g., \"abc\").\n     Str(String),\n-    /// a Binary String b\"abc\"\n+    /// A binary string (e.g., `b\"abc\"`).\n     Binary(Lrc<Vec<u8>>),\n-    /// a single char 'a'\n+    /// A single `char` (e.g., `'a'`).\n     Char(char),\n-    /// an integer's bit representation\n+    /// An integer's bit representation.\n     Int(u128),\n-    /// an f32\n+    /// An `f32`.\n     F32(f32),\n-    /// an f64\n+    /// An `f64`.\n     F64(f64),\n-    /// true or false\n+    /// `true` or `false`.\n     Bool(bool),\n-    /// an array of constants\n+    /// An array of constants.\n     Vec(Vec<Constant>),\n-    /// also an array, but with only one constant, repeated N times\n+    /// Also an array, but with only one constant, repeated N times.\n     Repeat(Box<Constant>, u64),\n-    /// a tuple of constants\n+    /// A tuple of constants.\n     Tuple(Vec<Constant>),\n-    /// a literal with syntax error\n+    /// A literal with syntax error.\n     Err(Symbol),\n }\n \n@@ -53,23 +53,24 @@ impl PartialEq for Constant {\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => l == r,\n             (&Constant::F64(l), &Constant::F64(r)) => {\n-                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n-                // `Fw32 == Fw64` so don\u2019t compare them\n-                // to_bits is required to catch non-matching 0.0, -0.0, and NaNs\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 l.to_bits() == r.to_bits()\n             },\n             (&Constant::F32(l), &Constant::F32(r)) => {\n-                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n-                // `Fw32 == Fw64` so don\u2019t compare them\n-                // to_bits is required to catch non-matching 0.0, -0.0, and NaNs\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 f64::from(l).to_bits() == f64::from(r).to_bits()\n             },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n                 l == r\n             },\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            _ => false, // TODO: Are there inter-type equalities?\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n         }\n     }\n }\n@@ -142,12 +143,13 @@ impl Constant {\n                     x => x,\n                 }\n             },\n-            _ => None, // TODO: Are there any useful inter-type orderings?\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n         }\n     }\n }\n \n-/// parse a `LitKind` to a `Constant`\n+/// Parses a `LitKind` to a `Constant`.\n pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n \n@@ -209,7 +211,7 @@ pub struct ConstEvalLateContext<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     needed_resolution: bool,\n-    substs: &'tcx Substs<'tcx>,\n+    substs: SubstsRef<'tcx>,\n }\n \n impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {"}, {"sha": "39fc10258078b1ca1f402a56b6d9041199dadc7f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,94 +10,94 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for consecutive `if`s with the same condition.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a == b {\n-///     \u2026\n-/// } else if a == b {\n-///     \u2026\n-/// }\n-/// ```\n-///\n-/// Note that this lint ignores all conditions with a function call as it could\n-/// have side effects:\n-///\n-/// ```rust\n-/// if foo() {\n-///     \u2026\n-/// } else if foo() { // not linted\n-///     \u2026\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for consecutive `if`s with the same condition.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a == b {\n+    ///     \u2026\n+    /// } else if a == b {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that this lint ignores all conditions with a function call as it could\n+    /// have side effects:\n+    ///\n+    /// ```ignore\n+    /// if foo() {\n+    ///     \u2026\n+    /// } else if foo() { // not linted\n+    ///     \u2026\n+    /// }\n+    /// ```\n     pub IFS_SAME_COND,\n     correctness,\n     \"consecutive `ifs` with the same condition\"\n }\n \n-/// **What it does:** Checks for `if/else` with the same body as the *then* part\n-/// and the *else* part.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let foo = if \u2026 {\n-///     42\n-/// } else {\n-///     42\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if/else` with the same body as the *then* part\n+    /// and the *else* part.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let foo = if \u2026 {\n+    ///     42\n+    /// } else {\n+    ///     42\n+    /// };\n+    /// ```\n     pub IF_SAME_THEN_ELSE,\n     correctness,\n     \"if with the same *then* and *else* blocks\"\n }\n \n-/// **What it does:** Checks for `match` with identical arm bodies.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n-/// are the same on purpose, you can factor them\n-/// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-///\n-/// **Known problems:** False positive possible with order dependent `match`\n-/// (see issue\n-/// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar => bar(),\n-///     Quz => quz(),\n-///     Baz => bar(), // <= oops\n-/// }\n-/// ```\n-///\n-/// This should probably be\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar => bar(),\n-///     Quz => quz(),\n-///     Baz => baz(), // <= fixed\n-/// }\n-/// ```\n-///\n-/// or if the original code was not a typo:\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar | Baz => bar(), // <= shows the intent better\n-///     Quz => quz(),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` with identical arm bodies.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// **Known problems:** False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n     pub MATCH_SAME_ARMS,\n     pedantic,\n     \"`match` with identical arm bodies\"\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n                 ..\n             }) = get_parent_expr(cx, expr)\n             {\n-                if else_expr.id == expr.id {\n+                if else_expr.hir_id == expr.hir_id {\n                     return;\n                 }\n             }\n@@ -239,9 +239,9 @@ fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n     }\n }\n \n-/// Return the list of condition expressions and the list of blocks in a\n+/// Returns the list of condition expressions and the list of blocks in a\n /// sequence of `if/else`.\n-/// Eg. would return `([a, b], [c, d, e])` for the expression\n+/// E.g., this returns `([a, b], [c, d, e])` for the expression\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>) {\n     let mut conds = SmallVec::new();\n@@ -272,7 +272,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>)\n     (conds, blocks)\n }\n \n-/// Return the list of bindings in a pattern.\n+/// Returns the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<LocalInternedString, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,"}, {"sha": "5c8d6def210fcdf9e7c7f749d4ae47598924b432", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,27 +3,27 @@ use rustc::hir::{Item, ItemKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for types that implement `Copy` as well as\n-/// `Iterator`.\n-///\n-/// **Why is this bad?** Implicit copies can be confusing when working with\n-/// iterator combinators.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Copy, Clone)]\n-/// struct Countdown(u8);\n-///\n-/// impl Iterator for Countdown {\n-///     // ...\n-/// }\n-///\n-/// let a: Vec<_> = my_iterator.take(1).collect();\n-/// let b: Vec<_> = my_iterator.collect();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types that implement `Copy` as well as\n+    /// `Iterator`.\n+    ///\n+    /// **Why is this bad?** Implicit copies can be confusing when working with\n+    /// iterator combinators.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[derive(Copy, Clone)]\n+    /// struct Countdown(u8);\n+    ///\n+    /// impl Iterator for Countdown {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let a: Vec<_> = my_iterator.take(1).collect();\n+    /// let b: Vec<_> = my_iterator.collect();\n+    /// ```\n     pub COPY_ITERATOR,\n     pedantic,\n     \"implementing `Iterator` on a `Copy` type\"\n@@ -44,7 +44,7 @@ impl LintPass for CopyIterator {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_note_and_lint("}, {"sha": "8b71123ca55b767afee979b644ef503b21ac110f", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,22 +6,22 @@ use syntax::ast;\n use syntax::source_map::Span;\n use syntax::tokenstream::TokenStream;\n \n-/// **What it does:** Checks for usage of dbg!() macro.\n-///\n-/// **Why is this bad?** `dbg!` macro is intended as a debugging tool. It\n-/// should not be in version control.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// // Bad\n-/// dbg!(true)\n-///\n-/// // Good\n-/// true\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of dbg!() macro.\n+    ///\n+    /// **Why is this bad?** `dbg!` macro is intended as a debugging tool. It\n+    /// should not be in version control.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// dbg!(true)\n+    ///\n+    /// // Good\n+    /// true\n+    /// ```\n     pub DBG_MACRO,\n     restriction,\n     \"`dbg!` macro is intended as a debugging tool\""}, {"sha": "247dff7560999113da19591b5586a5caa5803bdc", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,24 +5,24 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n+use crate::utils::{any_parent_is_automatically_derived, match_def_path, paths, span_lint_and_sugg};\n \n-/// **What it does:** Checks for literal calls to `Default::default()`.\n-///\n-/// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n-/// being gotten than the generic `Default`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// let s: String = Default::default();\n-///\n-/// // Good\n-/// let s = String::default();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for literal calls to `Default::default()`.\n+    ///\n+    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+    /// being gotten than the generic `Default`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let s: String = Default::default();\n+    ///\n+    /// // Good\n+    /// let s = String::default();\n+    /// ```\n     pub DEFAULT_TRAIT_ACCESS,\n     pedantic,\n     \"checks for literal calls to Default::default()\"\n@@ -45,9 +45,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ..) = expr.node;\n-            if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.node;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 match qpath {"}, {"sha": "62cef778917b984083d1c69f7bda6ca6db06a770", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -90,7 +90,7 @@ declare_deprecated_lint! {\n /// counterparts, so this lint may suggest a change in behavior or the code may not compile.\n declare_deprecated_lint! {\n     pub ASSIGN_OPS,\n-    \"using compound assignment operators (e.g. `+=`) is harmless\"\n+    \"using compound assignment operators (e.g., `+=`) is harmless\"\n }\n \n /// **What it does:** Nothing. This lint has been deprecated."}, {"sha": "2c77f8d37fac7cc4ea16f73dacae1ccf134f2115", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,56 +7,56 @@ use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n-/// explicitly or vice versa.\n-///\n-/// **Why is this bad?** The implementation of these traits must agree (for\n-/// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n-/// default-generated `Hash` implementation with an explicitly defined\n-/// `PartialEq`. In particular, the following must hold for any type:\n-///\n-/// ```rust\n-/// k1 == k2 \u21d2 hash(k1) == hash(k2)\n-/// ```\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Hash)]\n-/// struct Foo;\n-///\n-/// impl PartialEq for Foo {\n-///     ...\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Hash` implementation with an explicitly defined\n+    /// `PartialEq`. In particular, the following must hold for any type:\n+    ///\n+    /// ```text\n+    /// k1 == k2 \u21d2 hash(k1) == hash(k2)\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// #[derive(Hash)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialEq for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n     pub DERIVE_HASH_XOR_EQ,\n     correctness,\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n-/// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n-/// types.\n-///\n-/// **Why is this bad?** To avoid surprising behaviour, these traits should\n-/// agree and the behaviour of `Copy` cannot be overridden. In almost all\n-/// situations a `Copy` type should have a `Clone` implementation that does\n-/// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n-/// gets you.\n-///\n-/// **Known problems:** Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl Clone for Foo {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n+    /// types.\n+    ///\n+    /// **Why is this bad?** To avoid surprising behaviour, these traits should\n+    /// agree and the behaviour of `Copy` cannot be overridden. In almost all\n+    /// situations a `Copy` type should have a `Clone` implementation that does\n+    /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+    /// gets you.\n+    ///\n+    /// **Known problems:** Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[derive(Copy)]\n+    /// struct Foo;\n+    ///\n+    /// impl Clone for Foo {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPL_IMPL_CLONE_ON_COPY,\n     pedantic,\n     \"implementing `Clone` explicitly on `Copy` types\"\n@@ -77,7 +77,7 @@ impl LintPass for Derive {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "0e8d47384f1a4b6825793c29e2a6dde6365e125b", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,25 +9,25 @@ use syntax::source_map::{BytePos, Span};\n use syntax_pos::Pos;\n use url::Url;\n \n-/// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n-/// outside ticks in documentation.\n-///\n-/// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n-/// camel-case probably indicates some code which should be included between\n-/// ticks. `_` can also be used for emphasis in markdown, this lint tries to\n-/// consider that.\n-///\n-/// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n-/// for is limited, and there are still false positives.\n-///\n-/// **Examples:**\n-/// ```rust\n-/// /// Do something with the foo_bar parameter. See also\n-/// /// that::other::module::foo.\n-/// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n-/// fn doit(foo_bar) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n+    /// outside ticks in documentation.\n+    ///\n+    /// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n+    /// camel-case probably indicates some code which should be included between\n+    /// ticks. `_` can also be used for emphasis in markdown, this lint tries to\n+    /// consider that.\n+    ///\n+    /// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n+    /// for is limited, and there are still false positives.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// /// Do something with the foo_bar parameter. See also\n+    /// /// that::other::module::foo.\n+    /// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n+    /// fn doit(foo_bar) { .. }\n+    /// ```\n     pub DOC_MARKDOWN,\n     pedantic,\n     \"presence of `_`, `::` or camel-case outside backticks in documentation\"\n@@ -257,10 +257,9 @@ fn check_text(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, text: &st\n }\n \n fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n-    /// Checks if a string is camel-case, ie. contains at least two uppercase\n-    /// letter (`Clippy` is\n-    /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded\n-    /// (`IDs` is ok).\n+    /// Checks if a string is camel-case, i.e., contains at least two uppercase\n+    /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n+    /// Plurals are also excluded (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n         if s.starts_with(|c: char| c.is_digit(10)) {\n             return false;"}, {"sha": "be6124e45536fe714127210a23895a8d9834245c", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,24 +8,24 @@ use syntax::source_map::Span;\n \n use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n \n-/// **What it does:** Checks for double comparions that could be simplified to a single expression.\n-///\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == y || x < y\n-/// ```\n-///\n-/// Could be written as:\n-///\n-/// ```rust\n-/// x <= y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for double comparions that could be simplified to a single expression.\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x == y || x < y\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// x <= y\n+    /// ```\n     pub DOUBLE_COMPARISONS,\n     complexity,\n     \"unnecessary double comparisons that can be simplified\""}, {"sha": "5b5639371a188627ceeb6dc34fdc1ac7ef420636", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,20 +3,20 @@ use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::*;\n \n-/// **What it does:** Checks for unnecessary double parentheses.\n-///\n-/// **Why is this bad?** This makes code harder to read and might indicate a\n-/// mistake.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// ((0))\n-/// foo((0))\n-/// ((1, 2))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary double parentheses.\n+    ///\n+    /// **Why is this bad?** This makes code harder to read and might indicate a\n+    /// mistake.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// ((0))\n+    /// foo((0))\n+    /// ((1, 2))\n+    /// ```\n     pub DOUBLE_PARENS,\n     complexity,\n     \"Warn on unnecessary double parentheses\""}, {"sha": "702f7eced717944c2c11bc2cf2bb6b68a11d7818", "filename": "clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,29 +4,29 @@ use rustc::hir::*;\n use rustc::lint::{LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for generics with `std::ops::Drop` as bounds.\n-///\n-/// **Why is this bad?** `Drop` bounds do not really accomplish anything.\n-/// A type may have compiler-generated drop glue without implementing the\n-/// `Drop` trait itself. The `Drop` trait also only has one method,\n-/// `Drop::drop`, and that function is by fiat not callable in user code.\n-/// So there is really no use case for using `Drop` in trait bounds.\n-///\n-/// The most likely use case of a drop bound is to distinguish between types\n-/// that have destructors and types that don't. Combined with specialization,\n-/// a naive coder would write an implementation that assumed a type could be\n-/// trivially dropped, then write a specialization for `T: Drop` that actually\n-/// calls the destructor. Except that doing so is not correct; String, for\n-/// example, doesn't actually implement Drop, but because String contains a\n-/// Vec, assuming it can be trivially dropped will leak memory.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo<T: Drop>() {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for generics with `std::ops::Drop` as bounds.\n+    ///\n+    /// **Why is this bad?** `Drop` bounds do not really accomplish anything.\n+    /// A type may have compiler-generated drop glue without implementing the\n+    /// `Drop` trait itself. The `Drop` trait also only has one method,\n+    /// `Drop::drop`, and that function is by fiat not callable in user code.\n+    /// So there is really no use case for using `Drop` in trait bounds.\n+    ///\n+    /// The most likely use case of a drop bound is to distinguish between types\n+    /// that have destructors and types that don't. Combined with specialization,\n+    /// a naive coder would write an implementation that assumed a type could be\n+    /// trivially dropped, then write a specialization for `T: Drop` that actually\n+    /// calls the destructor. Except that doing so is not correct; String, for\n+    /// example, doesn't actually implement Drop, but because String contains a\n+    /// Vec, assuming it can be trivially dropped will leak memory.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo<T: Drop>() {}\n+    /// ```\n     pub DROP_BOUNDS,\n     correctness,\n     \"Bounds of the form `T: Drop` are useless\""}, {"sha": "b880e28fc647d2a573ebcb7c57f3fbc4c2a5f51b", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,97 +1,97 @@\n-use crate::utils::{is_copy, match_def_path, opt_def_id, paths, span_note_and_lint};\n+use crate::utils::{is_copy, match_def_path, paths, span_note_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for calls to `std::mem::drop` with a reference\n-/// instead of an owned value.\n-///\n-/// **Why is this bad?** Calling `drop` on a reference will only drop the\n-/// reference itself, which is a no-op. It will not call the `drop` method (from\n-/// the `Drop` trait implementation) on the underlying referenced value, which\n-/// is likely what was intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut lock_guard = mutex.lock();\n-/// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n-/// // still locked\n-/// operation_that_requires_mutex_to_be_unlocked();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `drop` on a reference will only drop the\n+    /// reference itself, which is a no-op. It will not call the `drop` method (from\n+    /// the `Drop` trait implementation) on the underlying referenced value, which\n+    /// is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let mut lock_guard = mutex.lock();\n+    /// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+    /// // still locked\n+    /// operation_that_requires_mutex_to_be_unlocked();\n+    /// ```\n     pub DROP_REF,\n     correctness,\n     \"calls to `std::mem::drop` with a reference instead of an owned value\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::forget` with a reference\n-/// instead of an owned value.\n-///\n-/// **Why is this bad?** Calling `forget` on a reference will only forget the\n-/// reference itself, which is a no-op. It will not forget the underlying\n-/// referenced\n-/// value, which is likely what was intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Box::new(1);\n-/// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `forget` on a reference will only forget the\n+    /// reference itself, which is a no-op. It will not forget the underlying\n+    /// referenced\n+    /// value, which is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Box::new(1);\n+    /// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n+    /// ```\n     pub FORGET_REF,\n     correctness,\n     \"calls to `std::mem::forget` with a reference instead of an owned value\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::drop` with a value\n-/// that derives the Copy trait\n-///\n-/// **Why is this bad?** Calling `std::mem::drop` [does nothing for types that\n-/// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n-/// value will be copied and moved into the function on invocation.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: i32 = 42; // i32 implements Copy\n-/// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n-///                   // original unaffected\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a value\n+    /// that derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::drop` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+    ///                   // original unaffected\n+    /// ```\n     pub DROP_COPY,\n     correctness,\n     \"calls to `std::mem::drop` with a value that implements Copy\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::forget` with a value that\n-/// derives the Copy trait\n-///\n-/// **Why is this bad?** Calling `std::mem::forget` [does nothing for types that\n-/// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n-/// value will be copied and moved into the function on invocation.\n-///\n-/// An alternative, but also valid, explanation is that Copy types do not\n-/// implement\n-/// the Drop trait, which means they have no destructors. Without a destructor,\n-/// there\n-/// is nothing for `std::mem::forget` to ignore.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: i32 = 42; // i32 implements Copy\n-/// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n-///                     // original unaffected\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a value that\n+    /// derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::forget` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// An alternative, but also valid, explanation is that Copy types do not\n+    /// implement\n+    /// the Drop trait, which means they have no destructors. Without a destructor,\n+    /// there\n+    /// is nothing for `std::mem::forget` to ignore.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+    ///                     // original unaffected\n+    /// ```\n     pub FORGET_COPY,\n     correctness,\n     \"calls to `std::mem::forget` with a value that implements Copy\"\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprKind::Call(ref path, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 1;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(qpath, path.hir_id).opt_def_id();\n             then {\n                 let lint;\n                 let msg;"}, {"sha": "df0ea31470c60a3721209f26ad7ea23b9e0123f0", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,21 +9,21 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n \n-/// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n-/// from other `Duration` methods.\n-///\n-/// **Why is this bad?** It's more concise to call `Duration::subsec_micros()` or\n-/// `Duration::subsec_millis()` than to calculate them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let dur = Duration::new(5, 0);\n-/// let _micros = dur.subsec_nanos() / 1_000;\n-/// let _millis = dur.subsec_nanos() / 1_000_000;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n+    /// from other `Duration` methods.\n+    ///\n+    /// **Why is this bad?** It's more concise to call `Duration::subsec_micros()` or\n+    /// `Duration::subsec_millis()` than to calculate them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let dur = Duration::new(5, 0);\n+    /// let _micros = dur.subsec_nanos() / 1_000;\n+    /// let _millis = dur.subsec_nanos() / 1_000_000;\n+    /// ```\n     pub DURATION_SUBSEC,\n     complexity,\n     \"checks for calculation of subsecond microseconds or milliseconds\""}, {"sha": "01380fd968078dca4fee0e237adbca2990dc1366", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,39 +1,39 @@\n-//! lint on if expressions with an else if, but without a final else branch\n+//! Lint on if expressions with an else if, but without a final else branch.\n \n use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::*;\n \n use crate::utils::span_help_and_lint;\n \n-/// **What it does:** Checks for usage of if expressions with an `else if` branch,\n-/// but without a final `else` branch.\n-///\n-/// **Why is this bad?** Some coding guidelines require this (e.g. MISRA-C:2004 Rule 14.10).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x.is_positive() {\n-///     a();\n-/// } else if x.is_negative() {\n-///     b();\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if x.is_positive() {\n-///     a();\n-/// } else if x.is_negative() {\n-///     b();\n-/// } else {\n-///     // we don't care about zero\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n+    /// but without a final `else` branch.\n+    ///\n+    /// **Why is this bad?** Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// } else {\n+    ///     // We don't care about zero.\n+    /// }\n+    /// ```\n     pub ELSE_IF_WITHOUT_ELSE,\n     restriction,\n     \"if expression with an `else if`, but without a final `else` branch\""}, {"sha": "9075cdc10c8b1b254efbdcd98fef923e374bdefb", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,19 +5,19 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `enum`s with no variants.\n-///\n-/// **Why is this bad?** Enum's with no variants should be replaced with `!`,\n-/// the uninhabited type,\n-/// or a wrapper around it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Test {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `enum`s with no variants.\n+    ///\n+    /// **Why is this bad?** Enum's with no variants should be replaced with `!`,\n+    /// the uninhabited type,\n+    /// or a wrapper around it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Test {}\n+    /// ```\n     pub EMPTY_ENUM,\n     pedantic,\n     \"enum with no variants\"\n@@ -38,7 +38,7 @@ impl LintPass for EmptyEnum {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "0dc970fcafe261e14e97a2ad481915b4fa0bc3b9", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,30 +8,30 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n-/// or `BTreeMap`.\n-///\n-/// **Why is this bad?** Using `entry` is more efficient.\n-///\n-/// **Known problems:** Some false negatives, eg.:\n-/// ```rust\n-/// let k = &key;\n-/// if !m.contains_key(k) {\n-///     m.insert(k.clone(), v);\n-/// }\n-/// ```\n-///\n-/// **Example:**\n-/// ```rust\n-/// if !m.contains_key(&k) {\n-///     m.insert(k, v)\n-/// }\n-/// ```\n-/// can be rewritten as:\n-/// ```rust\n-/// m.entry(k).or_insert(v);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n+    /// or `BTreeMap`.\n+    ///\n+    /// **Why is this bad?** Using `entry` is more efficient.\n+    ///\n+    /// **Known problems:** Some false negatives, eg.:\n+    /// ```rust\n+    /// let k = &key;\n+    /// if !m.contains_key(k) {\n+    ///     m.insert(k.clone(), v);\n+    /// }\n+    /// ```\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if !m.contains_key(&k) {\n+    ///     m.insert(k, v)\n+    /// }\n+    /// ```\n+    /// can be rewritten as:\n+    /// ```rust\n+    /// m.entry(k).or_insert(v);\n+    /// ```\n     pub MAP_ENTRY,\n     perf,\n     \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\""}, {"sha": "8e844f9c3988199e322a87f90114dffb7f2d03f1", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,28 +7,28 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::mir::interpret::GlobalId;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::InternalSubsts;\n use rustc::ty::util::IntTypeExt;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::{IntTy, UintTy};\n \n-/// **What it does:** Checks for C-like enumerations that are\n-/// `repr(isize/usize)` and have values that don't fit into an `i32`.\n-///\n-/// **Why is this bad?** This will truncate the variant value on 32 bit\n-/// architectures, but works fine on 64 bit.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[repr(usize)]\n-/// enum NonPortable {\n-///     X = 0x1_0000_0000,\n-///     Y = 0,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for C-like enumerations that are\n+    /// `repr(isize/usize)` and have values that don't fit into an `i32`.\n+    ///\n+    /// **Why is this bad?** This will truncate the variant value on 32 bit\n+    /// architectures, but works fine on 64 bit.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[repr(usize)]\n+    /// enum NonPortable {\n+    ///     X = 0x1_0000_0000,\n+    ///     Y = 0,\n+    /// }\n+    /// ```\n     pub ENUM_CLIKE_UNPORTABLE_VARIANT,\n     correctness,\n     \"C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\"\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 if let Some(ref anon_const) = variant.disr_expr {\n                     let param_env = ty::ParamEnv::empty();\n                     let def_id = cx.tcx.hir().body_owner_def_id(anon_const.body);\n-                    let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n+                    let substs = InternalSubsts::identity_for_item(cx.tcx.global_tcx(), def_id);\n                     let instance = ty::Instance::new(def_id, substs);\n                     let c_id = GlobalId {\n                         instance,"}, {"sha": "37575f10f19574d926d0452332feeadc2d3115c3", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,22 +5,21 @@ use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for `use Enum::*`.\n-///\n-/// **Why is this bad?** It is usually better style to use the prefixed name of\n-/// an enumeration variant, rather than importing variants.\n-///\n-/// **Known problems:** Old-style enumerations that prefix the variants are\n-/// still around.\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::cmp::Ordering::*;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `use Enum::*`.\n+    ///\n+    /// **Why is this bad?** It is usually better style to use the prefixed name of\n+    /// an enumeration variant, rather than importing variants.\n+    ///\n+    /// **Known problems:** Old-style enumerations that prefix the variants are\n+    /// still around.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::cmp::Ordering::*;\n+    /// ```\n     pub ENUM_GLOB_USE,\n     pedantic,\n     \"use items that import all variants of an enum\"\n@@ -39,7 +38,7 @@ impl LintPass for EnumGlobUse {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n-    fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n+    fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: HirId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n             self.lint_item(cx, cx.tcx.hir().expect_item(item.id));"}, {"sha": "707fe93bd0c3c43d81b9ca9b1595f7edcc6fa578", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,94 +8,94 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::symbol::{InternedString, LocalInternedString};\n \n-/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n-/// by the same characters.\n-///\n-/// **Why is this bad?** Enumeration variant names should specify their variant,\n-/// not repeat the enumeration name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Cake {\n-///     BlackForestCake,\n-///     HummingbirdCake,\n-///     BattenbergCake,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n     pub ENUM_VARIANT_NAMES,\n     style,\n     \"enums where all variants share a prefix/postfix\"\n }\n \n-/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n-/// by the same characters.\n-///\n-/// **Why is this bad?** Enumeration variant names should specify their variant,\n-/// not repeat the enumeration name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Cake {\n-///     BlackForestCake,\n-///     HummingbirdCake,\n-///     BattenbergCake,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n     pub PUB_ENUM_VARIANT_NAMES,\n     pedantic,\n     \"enums where all variants share a prefix/postfix\"\n }\n \n-/// **What it does:** Detects type names that are prefixed or suffixed by the\n-/// containing module's name.\n-///\n-/// **Why is this bad?** It requires the user to type the module name twice.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mod cake {\n-///     struct BlackForestCake;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects type names that are prefixed or suffixed by the\n+    /// containing module's name.\n+    ///\n+    /// **Why is this bad?** It requires the user to type the module name twice.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mod cake {\n+    ///     struct BlackForestCake;\n+    /// }\n+    /// ```\n     pub MODULE_NAME_REPETITIONS,\n     pedantic,\n     \"type names prefixed/postfixed with their containing module's name\"\n }\n \n-/// **What it does:** Checks for modules that have the same name as their\n-/// parent module\n-///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n-/// again `mod foo { ..\n-/// }` in `foo.rs`.\n-/// The expectation is that items inside the inner `mod foo { .. }` are then\n-/// available\n-/// through `foo::x`, but they are only available through\n-/// `foo::foo::x`.\n-/// If this is done on purpose, it would be better to choose a more\n-/// representative module name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // lib.rs\n-/// mod foo;\n-/// // foo.rs\n-/// mod foo {\n-///     ...\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for modules that have the same name as their\n+    /// parent module\n+    ///\n+    /// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n+    /// again `mod foo { ..\n+    /// }` in `foo.rs`.\n+    /// The expectation is that items inside the inner `mod foo { .. }` are then\n+    /// available\n+    /// through `foo::x`, but they are only available through\n+    /// `foo::foo::x`.\n+    /// If this is done on purpose, it would be better to choose a more\n+    /// representative module name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // lib.rs\n+    /// mod foo;\n+    /// // foo.rs\n+    /// mod foo {\n+    ///     ...\n+    /// }\n+    /// ```\n     pub MODULE_INCEPTION,\n     style,\n     \"modules that have the same name as their parent module\""}, {"sha": "903700f1aacb2cb56cbae66e53d61a3f17f7bd22", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,40 +6,40 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for equal operands to comparison, logical and\n-/// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-/// `||`, `&`, `|`, `^`, `-` and `/`).\n-///\n-/// **Why is this bad?** This is usually just a typo or a copy and paste error.\n-///\n-/// **Known problems:** False negatives: We had some false positives regarding\n-/// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-/// of `x.pop() && x.pop()`), so we removed matching any function or method\n-/// calls. We may introduce a whitelist of known pure functions in the future.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x + 1 == x + 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// **Why is this bad?** This is usually just a typo or a copy and paste error.\n+    ///\n+    /// **Known problems:** False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a whitelist of known pure functions in the future.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x + 1 == x + 1\n+    /// ```\n     pub EQ_OP,\n     correctness,\n-    \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n }\n \n-/// **What it does:** Checks for arguments to `==` which have their address\n-/// taken to satisfy a bound\n-/// and suggests to dereference the other argument instead\n-///\n-/// **Why is this bad?** It is more idiomatic to dereference the other argument.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// &x == y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// **Why is this bad?** It is more idiomatic to dereference the other argument.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// &x == y\n+    /// ```\n     pub OP_REF,\n     style,\n     \"taking a reference to satisfy the type constraints on `==`\""}, {"sha": "07909ef587fee27bd0675563a688bb6828520bfe", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,28 +1,30 @@\n-use crate::consts::{constant_simple, Constant};\n-use crate::utils::{in_macro, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for erasing operations, e.g. `x * 0`.\n-///\n-/// **Why is this bad?** The whole expression can be replaced by zero.\n-/// This is most likely not the intended outcome and should probably be\n-/// corrected\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0 / x;\n-/// 0 * x;\n-/// x & 0\n-/// ```\n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::{in_macro, span_lint};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for erasing operations, e.g., `x * 0`.\n+    ///\n+    /// **Why is this bad?** The whole expression can be replaced by zero.\n+    /// This is most likely not the intended outcome and should probably be\n+    /// corrected\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1;\n+    /// 0 / x;\n+    /// 0 * x;\n+    /// x & 0;\n+    /// ```\n     pub ERASING_OP,\n     correctness,\n-    \"using erasing operations, e.g. `x * 0` or `y & 0`\"\n+    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "d15a619ef9f04aa7fa026fc4f796a06f8623e0a8", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,38 +1,38 @@\n-use crate::utils::span_lint;\n use rustc::hir::intravisit as visit;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::HirIdSet;\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n+use crate::utils::span_lint;\n+\n pub struct Pass {\n     pub too_large_for_stack: u64,\n }\n \n-/// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n-/// work fine.\n-///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for\n-/// performance. It is only necessary to allocate if you wish to move the box\n-/// into something.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn main() {\n-///     let x = Box::new(1);\n-///     foo(*x);\n-///     println!(\"{}\", *x);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n+    /// work fine.\n+    ///\n+    /// **Why is this bad?** This is an unnecessary allocation, and bad for\n+    /// performance. It is only necessary to allocate if you wish to move the box\n+    /// into something.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = Box::new(1);\n+    ///     foo(*x);\n+    ///     println!(\"{}\", *x);\n+    /// }\n+    /// ```\n     pub BOXED_LOCAL,\n     perf,\n     \"using `Box<T>` where unnecessary\"\n@@ -44,7 +44,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    set: NodeSet,\n+    set: HirIdSet,\n     too_large_for_stack: u64,\n }\n \n@@ -66,11 +66,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        node_id: NodeId,\n+        hir_id: HirId,\n     ) {\n-        // If the method is an impl for a trait, don't warn\n-        let parent_id = cx.tcx.hir().get_parent(node_id);\n-        let parent_node = cx.tcx.hir().find(parent_id);\n+        // If the method is an impl for a trait, don't warn.\n+        let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n+        let parent_node = cx.tcx.hir().find_by_hir_id(parent_id);\n \n         if let Some(Node::Item(item)) = parent_node {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n@@ -80,27 +80,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         let mut v = EscapeDelegate {\n             cx,\n-            set: NodeSet::default(),\n+            set: HirIdSet::default(),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n         let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n         ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).consume_body(body);\n \n         for node in v.set {\n             span_lint(\n                 cx,\n                 BOXED_LOCAL,\n-                cx.tcx.hir().span(node),\n+                cx.tcx.hir().span_by_hir_id(node),\n                 \"local variable doesn't need to be boxed here\",\n             );\n         }\n     }\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n+    fn consume(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if let Move(DirectRefMove) | Move(CaptureMove) = mode {\n                 // moved out or in. clearly can't be localized\n@@ -111,13 +111,13 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n         let map = &self.cx.tcx.hir();\n-        if map.is_argument(consume_pat.id) {\n+        if map.is_argument(map.hir_to_node_id(consume_pat.hir_id)) {\n             // Skip closure arguments\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n+            if let Some(Node::Expr(..)) = map.find_by_hir_id(map.get_parent_node_by_hir_id(consume_pat.hir_id)) {\n                 return;\n             }\n             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n             }\n             return;\n         }\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                         if let ExprKind::Box(..) = ex.node {\n                             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                 // let x = box (...)\n-                                self.set.insert(consume_pat.id);\n+                                self.set.insert(consume_pat.hir_id);\n                             }\n                             // TODO Box::new\n                             // TODO vec![]\n@@ -143,14 +143,14 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             if self.set.contains(&lid) {\n                 // let y = x where x is known\n                 // remove x, insert y\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n                 self.set.remove(&lid);\n             }\n         }\n     }\n     fn borrow(\n         &mut self,\n-        _: NodeId,\n+        _: HirId,\n         _: Span,\n         cmt: &cmt_<'tcx>,\n         _: ty::Region<'_>,\n@@ -159,32 +159,31 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     ) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n-                // x.foo()\n-                // Used without autodereffing (i.e. x.clone())\n+                // `x.foo()`\n+                // Used without autoderef-ing (i.e., `x.clone()`).\n                 LoanCause::AutoRef |\n \n-                // &x\n-                // foo(&x) where no extra autoreffing is happening\n+                // `&x`\n+                // `foo(&x)` where no extra autoref-ing is happening.\n                 LoanCause::AddrOf |\n \n-                // `match x` can move\n+                // `match x` can move.\n                 LoanCause::MatchDiscriminant => {\n                     self.set.remove(&lid);\n                 }\n \n-                // do nothing for matches, etc. These can't escape\n+                // Do nothing for matches, etc. These can't escape.\n                 _ => {}\n             }\n         }\n     }\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-    fn mutate(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n+    fn mutate(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n     fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n-        // Large types need to be boxed to avoid stack\n-        // overflows.\n+        // Large types need to be boxed to avoid stack overflows.\n         if ty.is_box() {\n             self.cx.layout_of(ty.boxed_ty()).ok().map_or(0, |l| l.size.bytes()) > self.too_large_for_stack\n         } else {"}, {"sha": "1329e945b370bc76c26a0a0e7666439ac75b2d33", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,36 +1,36 @@\n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n use if_chain::if_chain;\n use rustc::hir::*;\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n+use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n+\n pub struct EtaPass;\n \n-/// **What it does:** Checks for closures which just call another function where\n-/// the function can be called directly. `unsafe` functions or calls where types\n-/// get adjusted are ignored.\n-///\n-/// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n-/// and gives the optimizer more work.\n-///\n-/// **Known problems:** If creating the closure inside the closure has a side-\n-/// effect then moving the closure creation out will change when that side-\n-/// effect runs.\n-/// See https://github.com/rust-lang/rust-clippy/issues/1439 for more\n-/// details.\n-///\n-/// **Example:**\n-/// ```rust\n-/// xs.map(|x| foo(x))\n-/// ```\n-/// where `foo(_)` is a plain function that takes the exact argument type of\n-/// `x`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for closures which just call another function where\n+    /// the function can be called directly. `unsafe` functions or calls where types\n+    /// get adjusted are ignored.\n+    ///\n+    /// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n+    /// and gives the optimizer more work.\n+    ///\n+    /// **Known problems:** If creating the closure inside the closure has a side-\n+    /// effect then moving the closure creation out will change when that side-\n+    /// effect runs.\n+    /// See rust-lang/rust-clippy#1439 for more details.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// xs.map(|x| foo(x))\n+    /// ```\n+    /// where `foo(_)` is a plain function that takes the exact argument type of\n+    /// `x`.\n     pub REDUNDANT_CLOSURE,\n     style,\n-    \"redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\"\n+    \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\"\n }\n \n impl LintPass for EtaPass {\n@@ -45,6 +45,10 @@ impl LintPass for EtaPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n         match expr.node {\n             ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n@@ -129,25 +133,30 @@ fn get_ufcs_type_name(\n     let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id).sty;\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        //if the method expectes &self, ufcs requires explicit borrowing so closure can't be removed\n-        return match (expected_type_of_self, actual_type_of_self) {\n-            (ty::Ref(_, _, _), ty::Ref(_, _, _)) => Some(cx.tcx.item_path_str(trait_id)),\n-            (l, r) => match (l, r) {\n-                (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => None,\n-                (_, _) => Some(cx.tcx.item_path_str(trait_id)),\n-            },\n-        };\n+        if match_borrow_depth(expected_type_of_self, actual_type_of_self) {\n+            return Some(cx.tcx.item_path_str(trait_id));\n+        }\n     }\n \n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n-        //a type may implicitly implement other types methods (e.g. Deref)\n+        //a type may implicitly implement other type's methods (e.g. Deref)\n         if match_types(expected_type_of_self, actual_type_of_self) {\n             return Some(get_type_name(cx, &actual_type_of_self));\n         }\n         None\n     })\n }\n \n+fn match_borrow_depth(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n+    match (lhs, rhs) {\n+        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1.sty, &t2.sty),\n+        (l, r) => match (l, r) {\n+            (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n+            (_, _) => true,\n+        },\n+    }\n+}\n+\n fn match_types(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n     match (lhs, rhs) {\n         (ty::Bool, ty::Bool)\n@@ -173,7 +182,7 @@ fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n \n fn compare_inputs(closure_inputs: &mut dyn Iterator<Item = &Arg>, call_args: &mut dyn Iterator<Item = &Expr>) -> bool {\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, _, ident, _) = closure_input.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.node {\n             // XXXManishearth Should I be checking the binding mode here?\n             if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.node {\n                 if p.segments.len() != 1 {"}, {"sha": "90e6102dd844e0cb5dd02f2989616ed91ae0c3d2", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,48 +7,48 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n \n-/// **What it does:** Checks for a read and a write to the same variable where\n-/// whether the read occurs before or after the write depends on the evaluation\n-/// order of sub-expressions.\n-///\n-/// **Why is this bad?** It is often confusing to read. In addition, the\n-/// sub-expression evaluation order for Rust is not well documented.\n-///\n-/// **Known problems:** Code which intentionally depends on the evaluation\n-/// order, or which is correct for any evaluation order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut x = 0;\n-/// let a = {\n-///     x = 1;\n-///     1\n-/// } + x;\n-/// // Unclear whether a is 1 or 2.\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for a read and a write to the same variable where\n+    /// whether the read occurs before or after the write depends on the evaluation\n+    /// order of sub-expressions.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Code which intentionally depends on the evaluation\n+    /// order, or which is correct for any evaluation order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 0;\n+    /// let a = {\n+    ///     x = 1;\n+    ///     1\n+    /// } + x;\n+    /// // Unclear whether a is 1 or 2.\n+    /// ```\n     pub EVAL_ORDER_DEPENDENCE,\n     complexity,\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n }\n \n-/// **What it does:** Checks for diverging calls that are not match arms or\n-/// statements.\n-///\n-/// **Why is this bad?** It is often confusing to read. In addition, the\n-/// sub-expression evaluation order for Rust is not well documented.\n-///\n-/// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n-/// shorthand.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let a = b() || panic!() || c();\n-/// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n-/// let x = (a, b, c, panic!());\n-/// // can simply be replaced by `panic!()`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for diverging calls that are not match arms or\n+    /// statements.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n+    /// shorthand.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let a = b() || panic!() || c();\n+    /// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+    /// let x = (a, b, c, panic!());\n+    /// // can simply be replaced by `panic!()`\n+    /// ```\n     pub DIVERGING_SUB_EXPRESSION,\n     complexity,\n     \"whether an expression contains a diverging sub expression\"\n@@ -186,13 +186,13 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n /// When such a read is found, the lint is triggered.\n fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n     let map = &vis.cx.tcx.hir();\n-    let mut cur_id = vis.write_expr.id;\n+    let mut cur_id = vis.write_expr.hir_id;\n     loop {\n-        let parent_id = map.get_parent_node(cur_id);\n+        let parent_id = map.get_parent_node_by_hir_id(cur_id);\n         if parent_id == cur_id {\n             break;\n         }\n-        let parent_node = match map.find(parent_id) {\n+        let parent_node = match map.find_by_hir_id(parent_id) {\n             Some(parent) => parent,\n             None => break,\n         };\n@@ -224,7 +224,7 @@ enum StopEarly {\n }\n \n fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n-    if expr.id == vis.last_expr.id {\n+    if expr.hir_id == vis.last_expr.hir_id {\n         return StopEarly::KeepGoing;\n     }\n \n@@ -286,7 +286,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> St\n /// A visitor that looks for reads from a variable.\n struct ReadVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    /// The id of the variable we're looking for.\n+    /// The ID of the variable we're looking for.\n     var: ast::NodeId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n@@ -298,7 +298,7 @@ struct ReadVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if expr.id == self.last_expr.id {\n+        if expr.hir_id == self.last_expr.hir_id {\n             return;\n         }\n \n@@ -351,11 +351,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n+/// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, _) = parent.node {\n-            return lhs.id == expr.id;\n+            return lhs.hir_id == expr.hir_id;\n         }\n     }\n     false"}, {"sha": "ff28866e3a7bff70f56fb55dd12f6d01bafcbad7", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -11,25 +11,25 @@ use std::fmt;\n use syntax::ast::*;\n use syntax_pos::symbol::Symbol;\n \n-/// **What it does:** Checks for float literals with a precision greater\n-/// than that supported by the underlying type\n-///\n-/// **Why is this bad?** Rust will truncate the literal silently.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// // Bad\n-/// let v: f32 = 0.123_456_789_9;\n-/// println!(\"{}\", v); //  0.123_456_789\n-///\n-/// // Good\n-/// let v: f64 = 0.123_456_789_9;\n-/// println!(\"{}\", v); //  0.123_456_789_9\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for float literals with a precision greater\n+    /// than that supported by the underlying type\n+    ///\n+    /// **Why is this bad?** Rust will truncate the literal silently.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let v: f32 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789\n+    ///\n+    /// // Good\n+    /// let v: f64 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789_9\n+    /// ```\n     pub EXCESSIVE_PRECISION,\n     style,\n     \"excessive precision for float literal\""}, {"sha": "64ba3efedc5e2543b4abb6eec9cd7c11a6433055", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,24 +1,24 @@\n-use crate::utils::{is_expn_of, match_def_path, opt_def_id, resolve_node, span_lint, span_lint_and_sugg};\n+use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n \n-/// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n-/// replaced with `(e)print!()` / `(e)println!()`\n-///\n-/// **Why is this bad?** Using `(e)println! is clearer and more concise\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n-/// writeln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n+    /// replaced with `(e)print!()` / `(e)println!()`\n+    ///\n+    /// **Why is this bad?** Using `(e)println! is clearer and more concise\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n+    /// writeln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n+    /// ```\n     pub EXPLICIT_WRITE,\n     complexity,\n     \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\"\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n             if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) =\n-                opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id));\n+                resolve_node(cx, qpath, dest_fun.hir_id).opt_def_id();\n             if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {\n                 Some(\"stdout\")\n             } else if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stderr\"]) {"}, {"sha": "c59a5fc20a678f3ed3287ec5f26ca058c35868c7", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,28 +1,28 @@\n use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n-use crate::utils::{is_expn_of, match_def_path, method_chain_args, opt_def_id, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n-///\n-/// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo(i32);\n-/// impl From<String> for Foo {\n-///     fn from(s: String) -> Self {\n-///         Foo(s.parse().unwrap())\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo(i32);\n+    /// impl From<String> for Foo {\n+    ///     fn from(s: String) -> Self {\n+    ///         Foo(s.parse().unwrap())\n+    ///     }\n+    /// }\n+    /// ```\n     pub FALLIBLE_IMPL_FROM,\n     nursery,\n     \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\"\n@@ -43,7 +43,7 @@ impl LintPass for FallibleImplFrom {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+        let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n@@ -71,7 +71,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             if_chain! {\n                 if let ExprKind::Call(ref func_expr, _) = expr.node;\n                 if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n-                if let Some(path_def_id) = opt_def_id(path.def);\n+                if let Some(path_def_id) = path.def.opt_def_id();\n                 if match_def_path(self.tcx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(self.tcx, path_def_id, &BEGIN_PANIC_FMT);\n                 if is_expn_of(expr.span, \"unreachable\").is_none();\n@@ -105,7 +105,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n                 let body = cx.tcx.hir().body(body_id);\n-                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.node_id);\n+                let impl_item_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     tcx: cx.tcx,\n                     tables: cx.tcx.typeck_tables_of(impl_item_def_id),"}, {"sha": "02a47d65421091c43a854bdbcf52a2e14c7a9f53", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,33 +1,34 @@\n use crate::utils::paths;\n use crate::utils::{\n-    in_macro, is_expn_of, last_path_segment, match_def_path, match_type, opt_def_id, resolve_node, snippet,\n-    span_lint_and_then, walk_ptrs_ty,\n+    in_macro, is_expn_of, last_path_segment, match_def_path, match_type, resolve_node, snippet, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::hir::*;\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n+use syntax::source_map::Span;\n \n-/// **What it does:** Checks for the use of `format!(\"string literal with no\n-/// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n-///\n-/// **Why is this bad?** There is no point of doing that. `format!(\"foo\")` can\n-/// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n-/// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n-/// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n-/// if `foo: &str`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Examples:**\n-/// ```rust\n-/// format!(\"foo\")\n-/// format!(\"{}\", foo)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `format!(\"string literal with no\n+    /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n+    ///\n+    /// **Why is this bad?** There is no point of doing that. `format!(\"foo\")` can\n+    /// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n+    /// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n+    /// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n+    /// if `foo: &str`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// format!(\"foo\")\n+    /// format!(\"{}\", foo)\n+    /// ```\n     pub USELESS_FORMAT,\n     complexity,\n     \"useless use of `format!`\"\n@@ -57,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 ExprKind::Call(ref fun, ref args) => {\n                     if_chain! {\n                         if let ExprKind::Path(ref qpath) = fun.node;\n-                        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+                        if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n                         let new_v1 = match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n                         let new_v1_fmt = match_def_path(\n                             cx.tcx,\n@@ -82,14 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 }\n                             };\n \n-                            span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n-                                db.span_suggestion(\n-                                    expr.span,\n-                                    message,\n-                                    sugg,\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            });\n+                            span_useless_format(cx, span, message, sugg);\n                         }\n                     }\n                 },\n@@ -98,14 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if let ExprKind::Tup(ref tup) = matchee.node {\n                         if tup.is_empty() {\n                             let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n-                            span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n-                                db.span_suggestion(\n-                                    span,\n-                                    \"consider using .to_string()\",\n-                                    sugg,\n-                                    Applicability::MachineApplicable, // snippet\n-                                );\n-                            });\n+                            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n                         }\n                     }\n                 },\n@@ -115,6 +102,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n+fn span_useless_format<'a, 'tcx: 'a, T: LintContext<'tcx>>(cx: &'a T, span: Span, help: &str, mut sugg: String) {\n+    let to_replace = span.source_callsite();\n+\n+    // The callsite span contains the statement semicolon for some reason.\n+    let snippet = snippet(cx, to_replace, \"..\");\n+    if snippet.ends_with(';') {\n+        sugg.push(';');\n+    }\n+\n+    span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n+        db.span_suggestion(\n+            to_replace,\n+            help,\n+            sugg,\n+            Applicability::MachineApplicable, // snippet\n+        );\n+    });\n+}\n+\n /// Checks if the expressions matches `&[\"\"]`\n fn check_single_piece(expr: &Expr) -> bool {\n     if_chain! {\n@@ -153,7 +159,7 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n         if let ExprKind::Call(_, ref args) = exprs[0].node;\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].node;\n-        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id));\n+        if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));"}, {"sha": "4788f57d070a486b8d68a9df07e837099a55ce86", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,75 +4,75 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n use syntax::ptr::P;\n \n-/// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n-/// operators.\n-///\n-/// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n-/// confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n+    /// operators.\n+    ///\n+    /// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n+    /// confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n+    /// ```\n     pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     style,\n     \"suspicious formatting of `*=`, `-=` or `!=`\"\n }\n \n-/// **What it does:** Checks for formatting of `else`. It lints if the `else`\n-/// is followed immediately by a newline or the `else` seems to be missing.\n-///\n-/// **Why is this bad?** This is probably some refactoring remnant, even if the\n-/// code is correct, it might look confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// if foo {\n-/// } { // looks like an `else` is missing here\n-/// }\n-///\n-/// if foo {\n-/// } if bar { // looks like an `else` is missing here\n-/// }\n-///\n-/// if foo {\n-/// } else\n-///\n-/// { // this is the `else` block of the previous `if`, but should it be?\n-/// }\n-///\n-/// if foo {\n-/// } else\n-///\n-/// if bar { // this is the `else` block of the previous `if`, but should it be?\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for formatting of `else`. It lints if the `else`\n+    /// is followed immediately by a newline or the `else` seems to be missing.\n+    ///\n+    /// **Why is this bad?** This is probably some refactoring remnant, even if the\n+    /// code is correct, it might look confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if foo {\n+    /// } { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } if bar { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// if bar { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_ELSE_FORMATTING,\n     style,\n     \"suspicious formatting of `else`\"\n }\n \n-/// **What it does:** Checks for possible missing comma in an array. It lints if\n-/// an array element is a binary operator expression and it lies on two lines.\n-///\n-/// **Why is this bad?** This could lead to unexpected results.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let a = &[\n-///     -1, -2, -3 // <= no comma here\n-///     -4, -5, -6\n-/// ];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for possible missing comma in an array. It lints if\n+    /// an array element is a binary operator expression and it lies on two lines.\n+    ///\n+    /// **Why is this bad?** This could lead to unexpected results.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let a = &[\n+    ///     -1, -2, -3 // <= no comma here\n+    ///     -4, -5, -6\n+    /// ];\n+    /// ```\n     pub POSSIBLE_MISSING_COMMA,\n     correctness,\n     \"possible missing comma in array\""}, {"sha": "5378f7d455f7e651bda51b4f470137961f888ece", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,75 +8,74 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for functions with too many parameters.\n-///\n-/// **Why is this bad?** Functions with lots of parameters are considered bad\n-/// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n-/// grouping some parameters into a new type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with too many parameters.\n+    ///\n+    /// **Why is this bad?** Functions with lots of parameters are considered bad\n+    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+    /// grouping some parameters into a new type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub TOO_MANY_ARGUMENTS,\n     complexity,\n     \"functions with too many arguments\"\n }\n \n-/// **What it does:** Checks for functions with a large amount of lines.\n-///\n-/// **Why is this bad?** Functions with a lot of lines are harder to understand\n-/// due to having to look at a larger amount of code to understand what the\n-/// function is doing. Consider splitting the body of the function into\n-/// multiple functions.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ``` rust\n-/// fn im_too_long() {\n-/// println!(\"\");\n-/// // ... 100 more LoC\n-/// println!(\"\");\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with a large amount of lines.\n+    ///\n+    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n+    /// due to having to look at a larger amount of code to understand what the\n+    /// function is doing. Consider splitting the body of the function into\n+    /// multiple functions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ``` rust\n+    /// fn im_too_long() {\n+    /// println!(\"\");\n+    /// // ... 100 more LoC\n+    /// println!(\"\");\n+    /// }\n+    /// ```\n     pub TOO_MANY_LINES,\n     pedantic,\n     \"functions with too many lines\"\n }\n \n-/// **What it does:** Checks for public functions that dereferences raw pointer\n-/// arguments but are not marked unsafe.\n-///\n-/// **Why is this bad?** The function should probably be marked `unsafe`, since\n-/// for an arbitrary raw pointer, there is no way of telling for sure if it is\n-/// valid.\n-///\n-/// **Known problems:**\n-///\n-/// * It does not check functions recursively so if the pointer is passed to a\n-/// private non-`unsafe` function which does the dereferencing, the lint won't\n-/// trigger.\n-/// * It only checks for arguments whose type are raw pointers, not raw pointers\n-/// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n-/// `some_argument.get_raw_ptr()`).\n-///\n-/// **Example:**\n-/// ```rust\n-/// pub fn foo(x: *const u8) {\n-///     println!(\"{}\", unsafe { *x });\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that dereferences raw pointer\n+    /// arguments but are not marked unsafe.\n+    ///\n+    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n+    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+    /// valid.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * It does not check functions recursively so if the pointer is passed to a\n+    /// private non-`unsafe` function which does the dereferencing, the lint won't\n+    /// trigger.\n+    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n+    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+    /// `some_argument.get_raw_ptr()`).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    /// ```\n     pub NOT_UNSAFE_PTR_ARG_DEREF,\n     correctness,\n     \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n@@ -112,9 +111,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n         span: Span,\n-        nodeid: ast::NodeId,\n+        hir_id: hir::HirId,\n     ) {\n-        let is_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(nodeid)) {\n+        let is_impl = if let Some(hir::Node::Item(item)) = cx\n+            .tcx\n+            .hir()\n+            .find_by_hir_id(cx.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             matches!(item.node, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n         } else {\n             false\n@@ -146,8 +149,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, body, nodeid);\n-        self.check_line_number(cx, span);\n+        self.check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+        self.check_line_number(cx, span, body);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n@@ -159,7 +162,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n \n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n-                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.id);\n+                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n             }\n         }\n     }\n@@ -178,12 +181,12 @@ impl<'a, 'tcx> Functions {\n         }\n     }\n \n-    fn check_line_number(self, cx: &LateContext<'_, '_>, span: Span) {\n+    fn check_line_number(self, cx: &LateContext<'_, '_>, span: Span, body: &'tcx hir::Body) {\n         if in_external_macro(cx.sess(), span) {\n             return;\n         }\n \n-        let code_snippet = snippet(cx, span, \"..\");\n+        let code_snippet = snippet(cx, body.value.span, \"..\");\n         let mut line_count: u64 = 0;\n         let mut in_comment = false;\n         let mut code_in_line;\n@@ -250,10 +253,11 @@ impl<'a, 'tcx> Functions {\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n-        nodeid: ast::NodeId,\n+        hir_id: hir::HirId,\n     ) {\n         let expr = &body.value;\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(hir_id);\n+        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(node_id) {\n             let raw_ptrs = iter_input_pats(decl, body)\n                 .zip(decl.inputs.iter())\n                 .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n@@ -273,8 +277,8 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n+fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n         Some(id)\n     } else {\n         None\n@@ -283,7 +287,7 @@ fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n \n struct DerefVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ptrs: FxHashSet<ast::NodeId>,\n+    ptrs: FxHashSet<hir::HirId>,\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -324,7 +328,7 @@ impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n         if let hir::ExprKind::Path(ref qpath) = ptr.node {\n             if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n-                if self.ptrs.contains(&id) {\n+                if self.ptrs.contains(&self.cx.tcx.hir().node_to_hir_id(id)) {\n                     span_lint(\n                         self.cx,\n                         NOT_UNSAFE_PTR_ARG_DEREF,"}, {"sha": "7391f0a5208eba617164a51bac329353315d7a25", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,33 +1,32 @@\n use crate::utils::{\n     in_macro, match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then,\n };\n-use crate::utils::{opt_def_id, paths, resolve_node};\n+use crate::utils::{paths, resolve_node};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::NodeId;\n \n-/// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n-///\n-/// **Why is this bad?** Redundant code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // format!() returns a `String`\n-/// let s: String = format!(\"hello\").into();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n+    ///\n+    /// **Why is this bad?** Redundant code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // format!() returns a `String`\n+    /// let s: String = format!(\"hello\").into();\n+    /// ```\n     pub IDENTITY_CONVERSION,\n     complexity,\n     \"using always-identical `Into`/`From`/`IntoIter` conversions\"\n }\n \n #[derive(Default)]\n pub struct IdentityConversion {\n-    try_desugar_arm: Vec<NodeId>,\n+    try_desugar_arm: Vec<HirId>,\n }\n \n impl LintPass for IdentityConversion {\n@@ -46,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             return;\n         }\n \n-        if Some(&e.id) == self.try_desugar_arm.last() {\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             return;\n         }\n \n@@ -57,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                     _ => return,\n                 };\n                 if let ExprKind::Call(_, ref args) = e.node {\n-                    self.try_desugar_arm.push(args[0].id);\n+                    self.try_desugar_arm.push(args[0].hir_id);\n                 } else {\n                     return;\n                 }\n@@ -99,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n \n             ExprKind::Call(ref path, ref args) => {\n                 if let ExprKind::Path(ref qpath) = path.node {\n-                    if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n+                    if let Some(def_id) = resolve_node(cx, qpath, path.hir_id).opt_def_id() {\n                         if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n                             let a = cx.tables.expr_ty(e);\n                             let b = cx.tables.expr_ty(&args[0]);\n@@ -126,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n     }\n \n     fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if Some(&e.id) == self.try_desugar_arm.last() {\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             self.try_desugar_arm.pop();\n         }\n     }"}, {"sha": "6d15e37454c46be34482118f640165bfa72502aa", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,26 +1,27 @@\n-use crate::consts::{constant_simple, Constant};\n-use crate::utils::{clip, in_macro, snippet, span_lint, unsext};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for identity operations, e.g. `x + 0`.\n-///\n-/// **Why is this bad?** This code can be removed without changing the\n-/// meaning. So it just obscures what's going on. Delete it mercilessly.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x / 1 + 0 * 1 - 0 | 0\n-/// ```\n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::{clip, in_macro, snippet, span_lint, unsext};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for identity operations, e.g., `x + 0`.\n+    ///\n+    /// **Why is this bad?** This code can be removed without changing the\n+    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x / 1 + 0 * 1 - 0 | 0\n+    /// ```\n     pub IDENTITY_OP,\n     complexity,\n-    \"using identity operations, e.g. `x + 0` or `y / 1`\"\n+    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "5ce29597cab77c5c978a507782f314a43c87aa94", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,32 +7,32 @@ use syntax::ast::*;\n \n use crate::utils::span_help_and_lint;\n \n-/// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n-/// else branch.\n-///\n-/// **Why is this bad?** Negations reduce the readability of statements.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if !v.is_empty() {\n-///     a()\n-/// } else {\n-///     b()\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if v.is_empty() {\n-///     b()\n-/// } else {\n-///     a()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n+    /// else branch.\n+    ///\n+    /// **Why is this bad?** Negations reduce the readability of statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if !v.is_empty() {\n+    ///     a()\n+    /// } else {\n+    ///     b()\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if v.is_empty() {\n+    ///     b()\n+    /// } else {\n+    ///     a()\n+    /// }\n+    /// ```\n     pub IF_NOT_ELSE,\n     pedantic,\n     \"`if` branches that could be swapped so no negation operation is necessary on the condition\""}, {"sha": "a82a57fe6ff316d0cf28acda865d1ed1fe504532", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,33 +1,33 @@\n use crate::utils::{in_macro, is_expn_of, snippet_opt, span_lint_and_then};\n-use rustc::hir::{intravisit::FnKind, Body, ExprKind, FnDecl, MatchSource};\n+use rustc::hir::{intravisit::FnKind, Body, ExprKind, FnDecl, HirId, MatchSource};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::{ast::NodeId, source_map::Span};\n+use syntax::source_map::Span;\n \n-/// **What it does:** Checks for missing return statements at the end of a block.\n-///\n-/// **Why is this bad?** Actually omitting the return keyword is idiomatic Rust code. Programmers\n-/// coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n-/// the last returning statement because the only difference is a missing `;`. Especially in bigger\n-/// code with multiple return paths having a `return` keyword makes it easier to find the\n-/// corresponding statements.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     x\n-/// }\n-/// ```\n-/// add return\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     return x;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for missing return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Actually omitting the return keyword is idiomatic Rust code. Programmers\n+    /// coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n+    /// the last returning statement because the only difference is a missing `;`. Especially in bigger\n+    /// code with multiple return paths having a `return` keyword makes it easier to find the\n+    /// corresponding statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     x\n+    /// }\n+    /// ```\n+    /// add return\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     return x;\n+    /// }\n+    /// ```\n     pub IMPLICIT_RETURN,\n     restriction,\n     \"use a return statement like `return expr` instead of an expression\"\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);"}, {"sha": "07fcec85863705f480ef3bd7f1c0df867ffe16b1", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,75 +10,76 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::RangeLimits;\n \n-/// **What it does:** Checks for out of bounds array indexing with a constant\n-/// index.\n-///\n-/// **Why is this bad?** This will always panic at runtime.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = [1, 2, 3, 4];\n-///\n-/// // Bad\n-/// x[9];\n-/// &x[2..9];\n-///\n-/// // Good\n-/// x[0];\n-/// x[3];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for out of bounds array indexing with a constant\n+    /// index.\n+    ///\n+    /// **Why is this bad?** This will always panic at runtime.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// # #![allow(const_err)]\n+    /// let x = [1, 2, 3, 4];\n+    ///\n+    /// // Bad\n+    /// x[9];\n+    /// &x[2..9];\n+    ///\n+    /// // Good\n+    /// x[0];\n+    /// x[3];\n+    /// ```\n     pub OUT_OF_BOUNDS_INDEXING,\n     correctness,\n     \"out of bounds constant indexing\"\n }\n \n-/// **What it does:** Checks for usage of indexing or slicing. Arrays are special cased, this lint\n-/// does report on arrays if we can tell that slicing operations are in bounds and does not\n-/// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n-///\n-/// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n-/// safe alternatives.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Vector\n-/// let x = vec![0; 5];\n-///\n-/// // Bad\n-/// x[2];\n-/// &x[2..100];\n-/// &x[2..];\n-/// &x[..100];\n-///\n-/// // Good\n-/// x.get(2);\n-/// x.get(2..100);\n-/// x.get(2..);\n-/// x.get(..100);\n-///\n-/// // Array\n-/// let y = [0, 1, 2, 3];\n-///\n-/// // Bad\n-/// &y[10..100];\n-/// &y[10..];\n-/// &y[..100];\n-///\n-/// // Good\n-/// &y[2..];\n-/// &y[..2];\n-/// &y[0..3];\n-/// y.get(10);\n-/// y.get(10..100);\n-/// y.get(10..);\n-/// y.get(..100);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of indexing or slicing. Arrays are special cased, this lint\n+    /// does report on arrays if we can tell that slicing operations are in bounds and does not\n+    /// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+    ///\n+    /// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n+    /// safe alternatives.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Vector\n+    /// let x = vec![0; 5];\n+    ///\n+    /// // Bad\n+    /// x[2];\n+    /// &x[2..100];\n+    /// &x[2..];\n+    /// &x[..100];\n+    ///\n+    /// // Good\n+    /// x.get(2);\n+    /// x.get(2..100);\n+    /// x.get(2..);\n+    /// x.get(..100);\n+    ///\n+    /// // Array\n+    /// let y = [0, 1, 2, 3];\n+    ///\n+    /// // Bad\n+    /// &y[10..100];\n+    /// &y[10..];\n+    /// &y[..100];\n+    ///\n+    /// // Good\n+    /// &y[2..];\n+    /// &y[..2];\n+    /// &y[0..3];\n+    /// y.get(10);\n+    /// y.get(10..100);\n+    /// y.get(10..);\n+    /// y.get(..100);\n+    /// ```\n     pub INDEXING_SLICING,\n     restriction,\n     \"indexing/slicing usage\"\n@@ -102,7 +103,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n         if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n-                // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n+                // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.sty {\n                     let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n \n@@ -148,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n \n                 utils::span_help_and_lint(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", help_msg);\n             } else {\n-                // Catchall non-range index, i.e. [n] or [n << m]\n+                // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.sty {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.tables, index) {"}, {"sha": "762d3b17c926665b3ee4690aaaf726b7f50e11b7", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,36 +5,36 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for matches being used to destructure a single-variant enum\n-/// or tuple struct where a `let` will suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Wrapper {\n-///     Data(i32),\n-/// }\n-///\n-/// let wrapper = Wrapper::Data(42);\n-///\n-/// let data = match wrapper {\n-///     Wrapper::Data(i) => i,\n-/// };\n-/// ```\n-///\n-/// The correct use would be:\n-/// ```rust\n-/// enum Wrapper {\n-///     Data(i32),\n-/// }\n-///\n-/// let wrapper = Wrapper::Data(42);\n-/// let Wrapper::Data(data) = wrapper;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n     pub INFALLIBLE_DESTRUCTURING_MATCH,\n     style,\n     \"a match statement with a single infallible arm instead of a `let`\""}, {"sha": "689cd8fd3b05eefd2783af72428cc6523b392e02", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,38 +1,41 @@\n-use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for iteration that is guaranteed to be infinite.\n-///\n-/// **Why is this bad?** While there may be places where this is acceptable\n-/// (e.g. in event streams), in most cases this is simply an error.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// repeat(1_u8).iter().collect::<Vec<_>>()\n-/// ```\n+use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g., in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// use std::iter;\n+    ///\n+    /// iter::repeat(1_u8).collect::<Vec<_>>();\n+    /// ```\n     pub INFINITE_ITER,\n     correctness,\n     \"infinite iteration\"\n }\n \n-/// **What it does:** Checks for iteration that may be infinite.\n-///\n-/// **Why is this bad?** While there may be places where this is acceptable\n-/// (e.g. in event streams), in most cases this is simply an error.\n-///\n-/// **Known problems:** The code may have a condition to stop iteration, but\n-/// this lint is not clever enough to analyze it.\n-///\n-/// **Example:**\n-/// ```rust\n-/// [0..].iter().zip(infinite_iter.take_while(|x| x > 5))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that may be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g., in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** The code may have a condition to stop iteration, but\n+    /// this lint is not clever enough to analyze it.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// [0..].iter().zip(infinite_iter.take_while(|x| x > 5))\n+    /// ```\n     pub MAYBE_INFINITE_ITER,\n     pedantic,\n     \"possible infinite iteration\"\n@@ -120,8 +123,8 @@ use self::Heuristic::{All, Always, Any, First};\n /// a slice of (method name, number of args, heuristic, bounds) tuples\n /// that will be used to determine whether the method in question\n /// returns an infinite or possibly infinite iterator. The finiteness\n-/// is an upper bound, e.g. some methods can return a possibly\n-/// infinite iterator at worst, e.g. `take_while`.\n+/// is an upper bound, e.g., some methods can return a possibly\n+/// infinite iterator at worst, e.g., `take_while`.\n static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"zip\", 2, All, Infinite),\n     (\"chain\", 2, Any, Infinite),"}, {"sha": "51d6c310cf628f0ec87c5971f0d7dd7874241e70", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,33 +8,33 @@ use rustc_data_structures::fx::FxHashMap;\n use std::default::Default;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for multiple inherent implementations of a struct\n-///\n-/// **Why is this bad?** Splitting the implementation of a type makes the code harder to navigate.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn one() {}\n-/// }\n-/// impl X {\n-///     fn other() {}\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn one() {}\n-///     fn other() {}\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for multiple inherent implementations of a struct\n+    ///\n+    /// **Why is this bad?** Splitting the implementation of a type makes the code harder to navigate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    /// }\n+    /// impl X {\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n     pub MULTIPLE_INHERENT_IMPL,\n     restriction,\n     \"Multiple inherent impl that could be grouped\""}, {"sha": "cced334f43a8c517c2279adaf8508d62ece4aeed", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,21 +8,21 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Attribute, Name};\n \n-/// **What it does:** Checks for `#[inline]` on trait methods without bodies\n-///\n-/// **Why is this bad?** Only implementations of trait methods may be inlined.\n-/// The inline attribute is ignored for trait methods without bodies.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// trait Animal {\n-///     #[inline]\n-///     fn name(&self) -> &'static str;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n+    ///\n+    /// **Why is this bad?** Only implementations of trait methods may be inlined.\n+    /// The inline attribute is ignored for trait methods without bodies.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// trait Animal {\n+    ///     #[inline]\n+    ///     fn name(&self) -> &'static str;\n+    /// }\n+    /// ```\n     pub INLINE_FN_WITHOUT_BODY,\n     correctness,\n     \"use of `#[inline]` on trait methods without bodies\""}, {"sha": "bab7374916dab9991708a46a8410491b91d21365", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,24 +7,24 @@ use syntax::ast::*;\n \n use crate::utils::{snippet_opt, span_lint_and_then};\n \n-/// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n-///\n-///\n-/// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x >= y + 1\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// x > y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x >= y + 1\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// x > y\n+    /// ```\n     pub INT_PLUS_ONE,\n     complexity,\n     \"instead of using x >= y + 1, use x > y\""}, {"sha": "721db396fff6314fced0a0992f2835167aa0b1f5", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,21 +1,21 @@\n-use crate::utils::{match_def_path, opt_def_id, paths, span_help_and_lint};\n+use crate::utils::{match_def_path, paths, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n-///\n-/// **Why is this bad?** Creation of null references is undefined behavior.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bad_ref: &usize = std::mem::zeroed();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n+    ///\n+    /// **Why is this bad?** Creation of null references is undefined behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// let bad_ref: &usize = unsafe { std::mem::zeroed() };\n+    /// ```\n     pub INVALID_REF,\n     correctness,\n     \"creation of invalid reference\"\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n             if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 0;\n             if let ty::Ref(..) = cx.tables.expr_ty(expr).sty;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(qpath, path.hir_id).opt_def_id();\n             then {\n                 let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) |\n                              match_def_path(cx.tcx, def_id, &paths::INIT)"}, {"sha": "f93f515d0239d7d9dc80624aac0c4d6d1fecfd1f", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,29 +6,29 @@ use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::*;\n \n-/// **What it does:** Checks for items declared after some statement in a block.\n-///\n-/// **Why is this bad?** Items live for the entire scope they are declared\n-/// in. But statements are processed in order. This might cause confusion as\n-/// it's hard to figure out which item is meant in a statement.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo() {\n-///     println!(\"cake\");\n-/// }\n-///\n-/// fn main() {\n-///     foo(); // prints \"foo\"\n-///     fn foo() {\n-///         println!(\"foo\");\n-///     }\n-///     foo(); // prints \"foo\"\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items declared after some statement in a block.\n+    ///\n+    /// **Why is this bad?** Items live for the entire scope they are declared\n+    /// in. But statements are processed in order. This might cause confusion as\n+    /// it's hard to figure out which item is meant in a statement.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() {\n+    ///     println!(\"cake\");\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     foo(); // prints \"foo\"\n+    ///     fn foo() {\n+    ///         println!(\"foo\");\n+    ///     }\n+    ///     foo(); // prints \"foo\"\n+    /// }\n+    /// ```\n     pub ITEMS_AFTER_STATEMENTS,\n     pedantic,\n     \"blocks where an item comes after a statement\""}, {"sha": "2e38fcf03672bc4cdc976de7db2a928aa852eab7", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,23 +7,23 @@ use rustc::ty::layout::LayoutOf;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for large size differences between variants on\n-/// `enum`s.\n-///\n-/// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n-/// large variant\n-/// can penalize the memory layout of that enum.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Test {\n-///     A(i32),\n-///     B([i32; 8000]),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for large size differences between variants on\n+    /// `enum`s.\n+    ///\n+    /// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n+    /// large variant\n+    /// can penalize the memory layout of that enum.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Test {\n+    ///     A(i32),\n+    ///     B([i32; 8000]),\n+    /// }\n+    /// ```\n     pub LARGE_ENUM_VARIANT,\n     perf,\n     \"large size difference between variants on an enum\"\n@@ -54,7 +54,7 @@ impl LintPass for LargeEnumVariant {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "4762ce760c9b3a3b77618001f563c95c83d030e4", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,62 +9,61 @@ use rustc_errors::Applicability;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::source_map::{Span, Spanned};\n \n-/// **What it does:** Checks for getting the length of something via `.len()`\n-/// just to compare to zero, and suggests using `.is_empty()` where applicable.\n-///\n-/// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n-/// than calculating their length. Notably, for slices, getting the length\n-/// requires a subtraction whereas `.is_empty()` is just a comparison. So it is\n-/// good to get into the habit of using `.is_empty()`, and having it is cheap.\n-/// Besides, it makes the intent clearer than a manual comparison.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x.len() == 0 {\n-///     ..\n-/// }\n-/// if y.len() != 0 {\n-///     ..\n-/// }\n-/// ```\n-/// instead use\n-/// ```rust\n-/// if x.is_empty() {\n-///     ..\n-/// }\n-/// if !y.is_empty() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n-pub LEN_ZERO,\n-style,\n-\"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n- could be used instead\"\n+    /// **What it does:** Checks for getting the length of something via `.len()`\n+    /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n+    ///\n+    /// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+    /// than calculating their length. Notably, for slices, getting the length\n+    /// requires a subtraction whereas `.is_empty()` is just a comparison. So it is\n+    /// good to get into the habit of using `.is_empty()`, and having it is cheap.\n+    /// Besides, it makes the intent clearer than a manual comparison.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if x.len() == 0 {\n+    ///     ..\n+    /// }\n+    /// if y.len() != 0 {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// instead use\n+    /// ```ignore\n+    /// if x.is_empty() {\n+    ///     ..\n+    /// }\n+    /// if !y.is_empty() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub LEN_ZERO,\n+    style,\n+    \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\"\n }\n \n-/// **What it does:** Checks for items that implement `.len()` but not\n-/// `.is_empty()`.\n-///\n-/// **Why is this bad?** It is good custom to have both methods, because for\n-/// some data structures, asking about the length will be a costly operation,\n-/// whereas `.is_empty()` can usually answer in constant time. Also it used to\n-/// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n-/// lint will ignore such entities.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     pub fn len(&self) -> usize {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items that implement `.len()` but not\n+    /// `.is_empty()`.\n+    ///\n+    /// **Why is this bad?** It is good custom to have both methods, because for\n+    /// some data structures, asking about the length will be a costly operation,\n+    /// whereas `.is_empty()` can usually answer in constant time. Also it used to\n+    /// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+    /// lint will ignore such entities.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl X {\n+    ///     pub fn len(&self) -> usize {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub LEN_WITHOUT_IS_EMPTY,\n     style,\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n@@ -132,7 +131,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -149,9 +148,11 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    let trait_node_id = cx.tcx.hir().hir_to_node_id(visited_trait.hir_id);\n+\n+    if cx.access_levels.is_exported(trait_node_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.id);\n+        let visited_trait_def_id = cx.tcx.hir().local_def_id_from_hir_id(visited_trait.hir_id);\n         fill_trait_set(visited_trait_def_id, &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -183,7 +184,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -192,7 +193,10 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.node_id) {\n+        if cx\n+            .access_levels\n+            .is_exported(cx.tcx.hir().hir_to_node_id(is_empty.id.hir_id))\n+        {\n             return;\n         } else {\n             \"a private\"\n@@ -202,8 +206,8 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     };\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.node_id) {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+        if cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(i.id.hir_id)) {\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let ty = cx.tcx.type_of(def_id);\n \n             span_lint(\n@@ -270,9 +274,9 @@ fn check_len(\n     }\n }\n \n-/// Check if this type has an `is_empty` method.\n+/// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n+    /// Gets an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if item.ident.name == \"is_empty\" {\n@@ -287,7 +291,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n         }\n     }\n \n-    /// Check the inherent impl's items for an `is_empty(self)` method.\n+    /// Checks the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n         cx.tcx\n             .inherent_impls(id)"}, {"sha": "5ef3d8dd4abf101602edf3a7442f01f9f931e875", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,48 +6,47 @@ use rustc::hir::BindingAnnotation;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast;\n-\n-/// **What it does:** Checks for variable declarations immediately followed by a\n-/// conditional affectation.\n-///\n-/// **Why is this bad?** This is not idiomatic Rust.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let foo;\n-///\n-/// if bar() {\n-///     foo = 42;\n-/// } else {\n-///     foo = 0;\n-/// }\n-///\n-/// let mut baz = None;\n-///\n-/// if bar() {\n-///     baz = Some(42);\n-/// }\n-/// ```\n-///\n-/// should be written\n-///\n-/// ```rust,ignore\n-/// let foo = if bar() {\n-///     42\n-/// } else {\n-///     0\n-/// };\n-///\n-/// let baz = if bar() {\n-///     Some(42)\n-/// } else {\n-///     None\n-/// };\n-/// ```\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for variable declarations immediately followed by a\n+    /// conditional affectation.\n+    ///\n+    /// **Why is this bad?** This is not idiomatic Rust.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let foo;\n+    ///\n+    /// if bar() {\n+    ///     foo = 42;\n+    /// } else {\n+    ///     foo = 0;\n+    /// }\n+    ///\n+    /// let mut baz = None;\n+    ///\n+    /// if bar() {\n+    ///     baz = Some(42);\n+    /// }\n+    /// ```\n+    ///\n+    /// should be written\n+    ///\n+    /// ```rust,ignore\n+    /// let foo = if bar() {\n+    ///     42\n+    /// } else {\n+    ///     0\n+    /// };\n+    ///\n+    /// let baz = if bar() {\n+    ///     Some(42)\n+    /// } else {\n+    ///     None\n+    /// };\n+    /// ```\n     pub USELESS_LET_IF_SEQ,\n     style,\n     \"unidiomatic `let mut` declaration followed by initialization in `if`\"\n@@ -73,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n                 if let hir::StmtKind::Local(ref local) = stmt.node;\n-                if let hir::PatKind::Binding(mode, canonical_id, _, ident, None) = local.pat.node;\n+                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.node;\n                 if let hir::StmtKind::Expr(ref if_) = expr.node;\n                 if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n@@ -142,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n \n struct UsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     used: bool,\n }\n \n@@ -151,7 +150,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n         if_chain! {\n             if let hir::ExprKind::Path(ref qpath) = expr.node;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n-            if self.id == local_id;\n+            if self.id == self.cx.tcx.hir().node_to_hir_id(local_id);\n             then {\n                 self.used = true;\n                 return;\n@@ -166,7 +165,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n \n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    decl: ast::NodeId,\n+    decl: hir::HirId,\n     block: &'tcx hir::Block,\n ) -> Option<&'tcx hir::Expr> {\n     if_chain! {\n@@ -176,7 +175,7 @@ fn check_assign<'a, 'tcx>(\n         if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n         if let hir::ExprKind::Path(ref qpath) = var.node;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n-        if decl == local_id;\n+        if decl == cx.tcx.hir().node_to_hir_id(local_id);\n         then {\n             let mut v = UsedVisitor {\n                 cx,\n@@ -199,7 +198,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: ast::NodeId, expr: &'tcx hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr) -> bool {\n     let mut v = UsedVisitor { cx, id, used: false };\n     hir::intravisit::walk_expr(&mut v, expr);\n     v.used"}, {"sha": "4a7f23bc8587fae5187c8917da3bef2718f018bf", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,10 +9,9 @@\n #![recursion_limit = \"256\"]\n #![warn(rust_2018_idioms, trivial_casts, trivial_numeric_casts)]\n #![feature(crate_visibility_modifier)]\n-#![feature(try_from)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate fmt_macros;\n #[allow(unused_extern_crates)]\n@@ -40,7 +39,7 @@ use toml;\n ///\n /// Every lint declaration consists of 4 parts:\n ///\n-/// 1. The documentation above the lint, which is used for the website\n+/// 1. The documentation, which is used for the website\n /// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n /// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n ///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n@@ -61,22 +60,22 @@ use toml;\n /// # use clippy_lints::declare_clippy_lint;\n /// use rustc::declare_tool_lint;\n ///\n-/// /// **What it does:** Checks for ... (describe what the lint matches).\n-/// ///\n-/// /// **Why is this bad?** Supply the reason for linting the code.\n-/// ///\n-/// /// **Known problems:** None. (Or describe where it could go wrong.)\n-/// ///\n-/// /// **Example:**\n-/// ///\n-/// /// ```rust\n-/// /// // Bad\n-/// /// Insert a short example of code that triggers the lint\n-/// ///\n-/// /// // Good\n-/// /// Insert a short example of improved code that doesn't trigger the lint\n-/// /// ```\n /// declare_clippy_lint! {\n+///     /// **What it does:** Checks for ... (describe what the lint matches).\n+///     ///\n+///     /// **Why is this bad?** Supply the reason for linting the code.\n+///     ///\n+///     /// **Known problems:** None. (Or describe where it could go wrong.)\n+///     ///\n+///     /// **Example:**\n+///     ///\n+///     /// ```rust\n+///     /// // Bad\n+///     /// Insert a short example of code that triggers the lint\n+///     ///\n+///     /// // Good\n+///     /// Insert a short example of improved code that doesn't trigger the lint\n+///     /// ```\n ///     pub LINT_NAME,\n ///     pedantic,\n ///     \"description\"\n@@ -85,35 +84,55 @@ use toml;\n /// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n #[macro_export]\n macro_rules! declare_clippy_lint {\n-    { pub $name:tt, style, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, style, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, correctness, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Deny, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, correctness, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, complexity, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, perf, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, perf, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, pedantic, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, pedantic, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, restriction, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, restriction, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, cargo, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, cargo, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, nursery, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, nursery, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, internal, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, internal, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, internal_warn, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, internal_warn, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n }\n \n@@ -133,11 +152,11 @@ pub mod block_in_if_condition;\n pub mod booleans;\n pub mod bytecount;\n pub mod cargo_common_metadata;\n+pub mod cognitive_complexity;\n pub mod collapsible_if;\n pub mod const_static_lifetime;\n pub mod copies;\n pub mod copy_iterator;\n-pub mod cyclomatic_complexity;\n pub mod dbg_macro;\n pub mod default_trait_access;\n pub mod derive;\n@@ -253,7 +272,7 @@ pub mod zero_div_zero;\n pub use crate::utils::conf::Conf;\n \n mod reexport {\n-    crate use syntax::ast::{Name, NodeId};\n+    crate use syntax::ast::Name;\n }\n \n /// Register all pre expansion lints\n@@ -388,7 +407,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     );\n     store.register_removed(\n         \"assign_ops\",\n-        \"using compound assignment operators (e.g. `+=`) is harmless\",\n+        \"using compound assignment operators (e.g., `+=`) is harmless\",\n     );\n     store.register_removed(\n         \"if_let_redundant_pattern_matching\",\n@@ -459,7 +478,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(\n-        box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold)\n+        box cognitive_complexity::CognitiveComplexity::new(conf.cognitive_complexity_threshold)\n     );\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n@@ -564,6 +583,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         matches::WILDCARD_ENUM_MATCH_ARM,\n         mem_forget::MEM_FORGET,\n         methods::CLONE_ON_REF_PTR,\n+        methods::GET_UNWRAP,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n@@ -647,11 +667,11 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         booleans::LOGIC_BUG,\n         booleans::NONMINIMAL_BOOL,\n         bytecount::NAIVE_BYTECOUNT,\n+        cognitive_complexity::COGNITIVE_COMPLEXITY,\n         collapsible_if::COLLAPSIBLE_IF,\n         const_static_lifetime::CONST_STATIC_LIFETIME,\n         copies::IFS_SAME_COND,\n         copies::IF_SAME_THEN_ELSE,\n-        cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         derive::DERIVE_HASH_XOR_EQ,\n         double_comparison::DOUBLE_COMPARISONS,\n         double_parens::DOUBLE_PARENS,\n@@ -730,7 +750,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::CLONE_ON_COPY,\n         methods::EXPECT_FUN_CALL,\n         methods::FILTER_NEXT,\n-        methods::GET_UNWRAP,\n         methods::INTO_ITER_ON_ARRAY,\n         methods::INTO_ITER_ON_REF,\n         methods::ITER_CLONED_COLLECT,\n@@ -889,7 +908,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         matches::SINGLE_MATCH,\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         methods::CHARS_LAST_CMP,\n-        methods::GET_UNWRAP,\n         methods::INTO_ITER_ON_REF,\n         methods::ITER_CLONED_COLLECT,\n         methods::ITER_SKIP_NEXT,\n@@ -943,7 +961,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         assign_ops::MISREFACTORED_ASSIGN_OP,\n         attrs::DEPRECATED_CFG_ATTR,\n         booleans::NONMINIMAL_BOOL,\n-        cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n+        cognitive_complexity::COGNITIVE_COMPLEXITY,\n         double_comparison::DOUBLE_COMPARISONS,\n         double_parens::DOUBLE_PARENS,\n         duration_subsec::DURATION_SUBSEC,\n@@ -1112,6 +1130,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n pub fn register_renamed(ls: &mut rustc::lint::LintStore) {\n     ls.register_renamed(\"clippy::stutter\", \"clippy::module_name_repetitions\");\n     ls.register_renamed(\"clippy::new_without_default_derive\", \"clippy::new_without_default\");\n+    ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "4b2ba60090f9d3583db40eff0ce25b71eedc170c", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,5 +1,3 @@\n-use crate::reexport::*;\n-use crate::utils::{last_path_segment, span_lint};\n use matches::matches;\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::*;\n@@ -10,45 +8,48 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use syntax::source_map::Span;\n use syntax::symbol::keywords;\n \n-/// **What it does:** Checks for lifetime annotations which can be removed by\n-/// relying on lifetime elision.\n-///\n-/// **Why is this bad?** The additional lifetimes make the code look more\n-/// complicated, while there is nothing out of the ordinary going on. Removing\n-/// them leads to more readable code.\n-///\n-/// **Known problems:** Potential false negatives: we bail out if the function\n-/// has a `where` clause where lifetimes are mentioned.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n-///     x\n-/// }\n-/// ```\n+use crate::reexport::*;\n+use crate::utils::{last_path_segment, span_lint};\n+\n declare_clippy_lint! {\n-pub NEEDLESS_LIFETIMES,\n-complexity,\n-\"using explicit lifetimes for references in function arguments when elision rules \\\n- would allow omitting them\"\n+    /// **What it does:** Checks for lifetime annotations which can be removed by\n+    /// relying on lifetime elision.\n+    ///\n+    /// **Why is this bad?** The additional lifetimes make the code look more\n+    /// complicated, while there is nothing out of the ordinary going on. Removing\n+    /// them leads to more readable code.\n+    ///\n+    /// **Known problems:** Potential false negatives: we bail out if the function\n+    /// has a `where` clause where lifetimes are mentioned.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_LIFETIMES,\n+    complexity,\n+    \"using explicit lifetimes for references in function arguments when elision rules \\\n+     would allow omitting them\"\n }\n \n-/// **What it does:** Checks for lifetimes in generics that are never used\n-/// anywhere else.\n-///\n-/// **Why is this bad?** The additional lifetimes make the code look more\n-/// complicated, while there is nothing out of the ordinary going on. Removing\n-/// them leads to more readable code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn unused_lifetime<'a>(x: u8) {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for lifetimes in generics that are never used\n+    /// anywhere else.\n+    ///\n+    /// **Why is this bad?** The additional lifetimes make the code look more\n+    /// complicated, while there is nothing out of the ordinary going on. Removing\n+    /// them leads to more readable code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn unused_lifetime<'a>(x: u8) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXTRA_UNUSED_LIFETIMES,\n     complexity,\n     \"unused lifetimes in function definitions\"\n@@ -319,7 +320,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                     _ => false,\n                 })\n             {\n-                let hir_id = self.cx.tcx.hir().node_to_hir_id(ty.id);\n+                let hir_id = ty.hir_id;\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n                         let generics = self.cx.tcx.generics_of(def_id);\n@@ -384,7 +385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n+/// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {"}, {"sha": "5c2ca4b1c9358115db095347bf34f3e2747e6625", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,95 +9,95 @@ use rustc_errors::Applicability;\n use syntax::ast::*;\n use syntax_pos;\n \n-/// **What it does:** Warns if a long integral or floating-point constant does\n-/// not contain underscores.\n-///\n-/// **Why is this bad?** Reading long numbers is difficult without separators.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 61864918973511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if a long integral or floating-point constant does\n+    /// not contain underscores.\n+    ///\n+    /// **Why is this bad?** Reading long numbers is difficult without separators.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: u64 = 61864918973511;\n+    /// ```\n     pub UNREADABLE_LITERAL,\n     style,\n     \"long integer literal without underscores\"\n }\n \n-/// **What it does:** Warns for mistyped suffix in literals\n-///\n-/// **Why is this bad?** This is most probably a typo\n-///\n-/// **Known problems:**\n-/// \t\t- Recommends a signed suffix, even though the number might be too big and an unsigned\n-///\t\tsuffix is required\n-/// \t\t- Does not match on `_128` since that is a valid grouping for decimal and octal numbers\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 2_32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns for mistyped suffix in literals\n+    ///\n+    /// **Why is this bad?** This is most probably a typo\n+    ///\n+    /// **Known problems:**\n+    /// \t\t- Recommends a signed suffix, even though the number might be too big and an unsigned\n+    ///\t\tsuffix is required\n+    /// \t\t- Does not match on `_128` since that is a valid grouping for decimal and octal numbers\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 2_32;\n+    /// ```\n     pub MISTYPED_LITERAL_SUFFIXES,\n     correctness,\n     \"mistyped literal suffix\"\n }\n \n-/// **What it does:** Warns if an integral or floating-point constant is\n-/// grouped inconsistently with underscores.\n-///\n-/// **Why is this bad?** Readers may incorrectly interpret inconsistently\n-/// grouped digits.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 618_64_9189_73_511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral or floating-point constant is\n+    /// grouped inconsistently with underscores.\n+    ///\n+    /// **Why is this bad?** Readers may incorrectly interpret inconsistently\n+    /// grouped digits.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: u64 = 618_64_9189_73_511;\n+    /// ```\n     pub INCONSISTENT_DIGIT_GROUPING,\n     style,\n     \"integer literals with digits grouped inconsistently\"\n }\n \n-/// **What it does:** Warns if the digits of an integral or floating-point\n-/// constant are grouped into groups that\n-/// are too large.\n-///\n-/// **Why is this bad?** Negatively impacts readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 6186491_8973511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if the digits of an integral or floating-point\n+    /// constant are grouped into groups that\n+    /// are too large.\n+    ///\n+    /// **Why is this bad?** Negatively impacts readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: u64 = 6186491_8973511;\n+    /// ```\n     pub LARGE_DIGIT_GROUPS,\n     pedantic,\n     \"grouping digits into groups that are too large\"\n }\n \n-/// **What it does:** Warns if there is a better representation for a numeric literal.\n-///\n-/// **Why is this bad?** Especially for big powers of 2 a hexadecimal representation is more\n-/// readable than a decimal representation.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// `255` => `0xFF`\n-/// `65_535` => `0xFFFF`\n-/// `4_042_322_160` => `0xF0F0_F0F0`\n declare_clippy_lint! {\n+    /// **What it does:** Warns if there is a better representation for a numeric literal.\n+    ///\n+    /// **Why is this bad?** Especially for big powers of 2 a hexadecimal representation is more\n+    /// readable than a decimal representation.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// `255` => `0xFF`\n+    /// `65_535` => `0xFFFF`\n+    /// `4_042_322_160` => `0xF0F0_F0F0`\n     pub DECIMAL_LITERAL_REPRESENTATION,\n     restriction,\n     \"using decimal representation when hexadecimal would be better\"\n@@ -112,7 +112,7 @@ pub(super) enum Radix {\n }\n \n impl Radix {\n-    /// Return a reasonable digit group size for this radix.\n+    /// Returns a reasonable digit group size for this radix.\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n             Radix::Binary | Radix::Hexadecimal => 4,"}, {"sha": "0016625631c70b29007151aeff683ad983353be6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 383, "deletions": 375, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -27,413 +27,413 @@ use syntax_pos::BytePos;\n \n use crate::utils::paths;\n use crate::utils::{\n-    get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable, last_path_segment,\n+    get_enclosing_block, get_parent_expr, has_iter_method, higher, is_integer_literal, is_refutable, last_path_segment,\n     match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt, snippet_with_applicability,\n     span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n };\n \n-/// **What it does:** Checks for for-loops that manually copy items between\n-/// slices that could be optimized by having a memcpy.\n-///\n-/// **Why is this bad?** It is not as fast as a memcpy.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..src.len() {\n-///     dst[i + 64] = src[i];\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for for-loops that manually copy items between\n+    /// slices that could be optimized by having a memcpy.\n+    ///\n+    /// **Why is this bad?** It is not as fast as a memcpy.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for i in 0..src.len() {\n+    ///     dst[i + 64] = src[i];\n+    /// }\n+    /// ```\n     pub MANUAL_MEMCPY,\n     perf,\n     \"manually copying items between slices\"\n }\n \n-/// **What it does:** Checks for looping over the range of `0..len` of some\n-/// collection just to get the values by index.\n-///\n-/// **Why is this bad?** Just iterating the collection itself makes the intent\n-/// more clear and is probably faster.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..vec.len() {\n-///     println!(\"{}\", vec[i]);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for looping over the range of `0..len` of some\n+    /// collection just to get the values by index.\n+    ///\n+    /// **Why is this bad?** Just iterating the collection itself makes the intent\n+    /// more clear and is probably faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for i in 0..vec.len() {\n+    ///     println!(\"{}\", vec[i]);\n+    /// }\n+    /// ```\n     pub NEEDLESS_RANGE_LOOP,\n     style,\n     \"for-looping over a range of indices where an iterator over items would do\"\n }\n \n-/// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n-/// suggests the latter.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** False negatives. We currently only warn on some known\n-/// types.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // with `y` a `Vec` or slice:\n-/// for x in y.iter() {\n-///     ..\n-/// }\n-/// ```\n-/// can be rewritten to\n-/// ```rust\n-/// for x in &y {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False negatives. We currently only warn on some known\n+    /// types.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// for x in &y {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPLICIT_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n }\n \n-/// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n-/// suggests the latter.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// // with `y` a `Vec` or slice:\n-/// for x in y.into_iter() {\n-///     ..\n-/// }\n-/// ```\n-/// can be rewritten to\n-/// ```rust\n-/// for x in y {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.into_iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```ignore\n+    /// for x in y {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPLICIT_INTO_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.into_iter()` when `_` would do\"\n }\n \n-/// **What it does:** Checks for loops on `x.next()`.\n-///\n-/// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n-/// value, or `None` otherwise. The insidious thing is that `Option<_>`\n-/// implements `IntoIterator`, so that possibly one value will be iterated,\n-/// leading to some hard to find bugs. No one will want to write such code\n-/// [except to win an Underhanded Rust\n-/// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in y.next() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.next()`.\n+    ///\n+    /// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n+    /// value, or `None` otherwise. The insidious thing is that `Option<_>`\n+    /// implements `IntoIterator`, so that possibly one value will be iterated,\n+    /// leading to some hard to find bugs. No one will want to write such code\n+    /// [except to win an Underhanded Rust\n+    /// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in y.next() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub ITER_NEXT_LOOP,\n     correctness,\n     \"for-looping over `_.next()` which is probably not intended\"\n }\n \n-/// **What it does:** Checks for `for` loops over `Option` values.\n-///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n-/// let`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in option {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// This should be\n-/// ```rust\n-/// if let Some(x) = option {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Option` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in option {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// This should be\n+    /// ```ignore\n+    /// if let Some(x) = option {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_LOOP_OVER_OPTION,\n     correctness,\n     \"for-looping over an `Option`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** Checks for `for` loops over `Result` values.\n-///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n-/// let`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in result {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// This should be\n-/// ```rust\n-/// if let Ok(x) = result {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Result` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in result {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// This should be\n+    /// ```ignore\n+    /// if let Ok(x) = result {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_LOOP_OVER_RESULT,\n     correctness,\n     \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** Detects `loop + match` combinations that are easier\n-/// written as a `while let` loop.\n-///\n-/// **Why is this bad?** The `while let` loop is usually shorter and more\n-/// readable.\n-///\n-/// **Known problems:** Sometimes the wrong binding is displayed (#383).\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {\n-///     let x = match y {\n-///         Some(x) => x,\n-///         None => break,\n-///     }\n-///     // .. do something with x\n-/// }\n-/// // is easier written as\n-/// while let Some(x) = y {\n-///     // .. do something with x\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects `loop + match` combinations that are easier\n+    /// written as a `while let` loop.\n+    ///\n+    /// **Why is this bad?** The `while let` loop is usually shorter and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** Sometimes the wrong binding is displayed (#383).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     let x = match y {\n+    ///         Some(x) => x,\n+    ///         None => break,\n+    ///     }\n+    ///     // .. do something with x\n+    /// }\n+    /// // is easier written as\n+    /// while let Some(x) = y {\n+    ///     // .. do something with x\n+    /// }\n+    /// ```\n     pub WHILE_LET_LOOP,\n     complexity,\n     \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n }\n \n-/// **What it does:** Checks for using `collect()` on an iterator without using\n-/// the result.\n-///\n-/// **Why is this bad?** It is more idiomatic to use a `for` loop over the\n-/// iterator instead.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for using `collect()` on an iterator without using\n+    /// the result.\n+    ///\n+    /// **Why is this bad?** It is more idiomatic to use a `for` loop over the\n+    /// iterator instead.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n+    /// ```\n     pub UNUSED_COLLECT,\n     perf,\n     \"`collect()`ing an iterator without using the result; this is usually better written as a for loop\"\n }\n \n-/// **What it does:** Checks for functions collecting an iterator when collect\n-/// is not needed.\n-///\n-/// **Why is this bad?** `collect` causes the allocation of a new data structure,\n-/// when this allocation may not be needed.\n-///\n-/// **Known problems:**\n-/// None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let len = iterator.collect::<Vec<_>>().len();\n-/// // should be\n-/// let len = iterator.count();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions collecting an iterator when collect\n+    /// is not needed.\n+    ///\n+    /// **Why is this bad?** `collect` causes the allocation of a new data structure,\n+    /// when this allocation may not be needed.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let len = iterator.collect::<Vec<_>>().len();\n+    /// // should be\n+    /// let len = iterator.count();\n+    /// ```\n     pub NEEDLESS_COLLECT,\n     perf,\n     \"collecting an iterator when collect is not needed\"\n }\n \n-/// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n-/// are constant and `x` is greater or equal to `y`, unless the range is\n-/// reversed or has a negative `.step_by(_)`.\n-///\n-/// **Why is it bad?** Such loops will either be skipped or loop until\n-/// wrap-around (in debug code, this may `panic!()`). Both options are probably\n-/// not intended.\n-///\n-/// **Known problems:** The lint cannot catch loops over dynamically defined\n-/// ranges. Doing this would require simulating all possible inputs and code\n-/// paths through the program, which would be complex and error-prone.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in 5..10 - 5 {\n-///     ..\n-/// } // oops, stray `-`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n+    /// are constant and `x` is greater or equal to `y`, unless the range is\n+    /// reversed or has a negative `.step_by(_)`.\n+    ///\n+    /// **Why is it bad?** Such loops will either be skipped or loop until\n+    /// wrap-around (in debug code, this may `panic!()`). Both options are probably\n+    /// not intended.\n+    ///\n+    /// **Known problems:** The lint cannot catch loops over dynamically defined\n+    /// ranges. Doing this would require simulating all possible inputs and code\n+    /// paths through the program, which would be complex and error-prone.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in 5..10 - 5 {\n+    ///     ..\n+    /// } // oops, stray `-`\n+    /// ```\n     pub REVERSE_RANGE_LOOP,\n     correctness,\n     \"iteration over an empty range, such as `10..0` or `5..5`\"\n }\n \n-/// **What it does:** Checks `for` loops over slices with an explicit counter\n-/// and suggests the use of `.enumerate()`.\n-///\n-/// **Why is it bad?** Not only is the version using `.enumerate()` more\n-/// readable, the compiler is able to remove bounds checks which can lead to\n-/// faster code in some instances.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..v.len() { foo(v[i]);\n-/// for i in 0..v.len() { bar(i, v[i]); }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks `for` loops over slices with an explicit counter\n+    /// and suggests the use of `.enumerate()`.\n+    ///\n+    /// **Why is it bad?** Not only is the version using `.enumerate()` more\n+    /// readable, the compiler is able to remove bounds checks which can lead to\n+    /// faster code in some instances.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for i in 0..v.len() { foo(v[i]);\n+    /// for i in 0..v.len() { bar(i, v[i]); }\n+    /// ```\n     pub EXPLICIT_COUNTER_LOOP,\n     complexity,\n     \"for-looping with an explicit counter when `_.enumerate()` would do\"\n }\n \n-/// **What it does:** Checks for empty `loop` expressions.\n-///\n-/// **Why is this bad?** Those busy loops burn CPU cycles without doing\n-/// anything. Think of the environment and either block on something or at least\n-/// make the thread sleep for some microseconds.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for empty `loop` expressions.\n+    ///\n+    /// **Why is this bad?** Those busy loops burn CPU cycles without doing\n+    /// anything. Think of the environment and either block on something or at least\n+    /// make the thread sleep for some microseconds.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// loop {}\n+    /// ```\n     pub EMPTY_LOOP,\n     style,\n     \"empty `loop {}`, which should block or sleep\"\n }\n \n-/// **What it does:** Checks for `while let` expressions on iterators.\n-///\n-/// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n-/// the intent better.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// while let Some(val) = iter() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `while let` expressions on iterators.\n+    ///\n+    /// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n+    /// the intent better.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// while let Some(val) = iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub WHILE_LET_ON_ITERATOR,\n     style,\n     \"using a while-let loop instead of a for loop on an iterator\"\n }\n \n-/// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n-/// ignoring either the keys or values.\n-///\n-/// **Why is this bad?** Readability. There are `keys` and `values` methods that\n-/// can be used to express that don't need the values or keys.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for (k, _) in &map {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// could be replaced by\n-///\n-/// ```rust\n-/// for k in map.keys() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+    /// ignoring either the keys or values.\n+    ///\n+    /// **Why is this bad?** Readability. There are `keys` and `values` methods that\n+    /// can be used to express that don't need the values or keys.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for (k, _) in &map {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// could be replaced by\n+    ///\n+    /// ```ignore\n+    /// for k in map.keys() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_KV_MAP,\n     style,\n     \"looping on a map using `iter` when `keys` or `values` would do\"\n }\n \n-/// **What it does:** Checks for loops that will always `break`, `return` or\n-/// `continue` an outer loop.\n-///\n-/// **Why is this bad?** This loop never loops, all it does is obfuscating the\n-/// code.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {\n-///     ..;\n-///     break;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops that will always `break`, `return` or\n+    /// `continue` an outer loop.\n+    ///\n+    /// **Why is this bad?** This loop never loops, all it does is obfuscating the\n+    /// code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     ..;\n+    ///     break;\n+    /// }\n+    /// ```\n     pub NEVER_LOOP,\n     correctness,\n     \"any loop that will always `break` or `return`\"\n }\n \n-/// **What it does:** Checks for loops which have a range bound that is a mutable variable\n-///\n-/// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut foo = 42;\n-/// for i in 0..foo {\n-///     foo -= 1;\n-///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops which have a range bound that is a mutable variable\n+    ///\n+    /// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut foo = 42;\n+    /// for i in 0..foo {\n+    ///     foo -= 1;\n+    ///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n+    /// }\n+    /// ```\n     pub MUT_RANGE_BOUND,\n     complexity,\n     \"for loop over a range where one of the bounds is a mutable variable\"\n }\n \n-/// **What it does:** Checks whether variables used within while loop condition\n-/// can be (and are) mutated in the body.\n-///\n-/// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n-/// will lead to an infinite loop.\n-///\n-/// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n-/// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n-/// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let i = 0;\n-/// while i > 10 {\n-///     println!(\"let me loop forever!\");\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks whether variables used within while loop condition\n+    /// can be (and are) mutated in the body.\n+    ///\n+    /// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n+    /// will lead to an infinite loop.\n+    ///\n+    /// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n+    /// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n+    /// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 0;\n+    /// while i > 10 {\n+    ///     println!(\"let me loop forever!\");\n+    /// }\n+    /// ```\n     pub WHILE_IMMUTABLE_CONDITION,\n     correctness,\n     \"variables used within while expression are not mutated in the body\"\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for never_loop\n         match expr.node {\n             ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n-                match never_loop_block(block, expr.id) {\n+                match never_loop_block(block, expr.hir_id) {\n                     NeverLoopResult::AlwaysBreak => {\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\")\n                     },\n@@ -663,7 +663,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_block(block: &Block, main_loop_id: HirId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n@@ -678,7 +678,7 @@ fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.node {\n         ExprKind::Box(ref e)\n         | ExprKind::Unary(_, ref e)\n@@ -727,7 +727,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n-                .expect(\"target id can only be missing in the presence of compilation errors\");\n+                .expect(\"target ID can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n                 NeverLoopResult::MayContinueMainLoop\n             } else {\n@@ -752,17 +752,17 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n@@ -783,14 +783,14 @@ fn check_for_loop<'a, 'tcx>(\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n-fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n         // our variable!\n-        if local_id == var;\n+        if cx.tcx.hir().node_to_hir_id(local_id) == var;\n         then {\n             return true;\n         }\n@@ -832,8 +832,8 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n-    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: HirId) -> Option<String> {\n         match e.node {\n             ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n@@ -888,7 +888,7 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &Expr,\n-    var: ast::NodeId,\n+    var: HirId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n@@ -906,12 +906,12 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n fn get_indexed_assignments<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     body: &Expr,\n-    var: ast::NodeId,\n+    var: HirId,\n ) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n     fn get_assignment<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n         e: &Expr,\n-        var: ast::NodeId,\n+        var: HirId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n         if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n             match (\n@@ -953,7 +953,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n     }\n }\n \n-/// Check for for loops that sequentially copy items from one slice-like\n+/// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n@@ -969,7 +969,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, _, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n@@ -1065,7 +1065,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }\n }\n \n-/// Check for looping over a range and then indexing a sequence with it.\n+/// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n #[allow(clippy::too_many_lines)]\n fn check_for_loop_range<'a, 'tcx>(\n@@ -1086,7 +1086,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, ident, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx,\n                 var: canonical_id,\n@@ -1109,15 +1109,21 @@ fn check_for_loop_range<'a, 'tcx>(\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n-                    let parent_id = cx.tcx.hir().get_parent(expr.id);\n-                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id_from_hir_id(parent_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n                     }\n                 }\n \n+                // don't lint if the container that is indexed does not have .iter() method\n+                let has_iter = has_iter_method(cx, indexed_ty);\n+                if has_iter.is_none() {\n+                    return;\n+                }\n+\n                 // don't lint if the container that is indexed into is also used without\n                 // indexing\n                 if visitor.referenced.contains(&indexed) {\n@@ -1407,7 +1413,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n     }\n }\n \n-/// Check for `for` loops over `Option`s and `Results`\n+/// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n@@ -1463,8 +1469,9 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir();\n+    let expr_node_id = map.hir_to_node_id(expr.hir_id);\n     let parent_scope = map\n-        .get_enclosing_scope(expr.id)\n+        .get_enclosing_scope(expr_node_id)\n         .and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let Node::Block(block) = map.get(parent_id) {\n@@ -1500,7 +1507,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     }\n }\n \n-/// Check for the `FOR_KV_MAP` lint.\n+/// Checks for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     pat: &'tcx Pat,\n@@ -1554,44 +1561,44 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n }\n \n struct MutatePairDelegate {\n-    node_id_low: Option<NodeId>,\n-    node_id_high: Option<NodeId>,\n+    hir_id_low: Option<HirId>,\n+    hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n-                if Some(id) == self.node_id_low {\n+                if Some(id) == self.hir_id_low {\n                     self.span_low = Some(sp)\n                 }\n-                if Some(id) == self.node_id_high {\n+                if Some(id) == self.hir_id_high {\n                     self.span_high = Some(sp)\n                 }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         if let Categorization::Local(id) = cmt.cat {\n-            if Some(id) == self.node_id_low {\n+            if Some(id) == self.hir_id_low {\n                 self.span_low = Some(sp)\n             }\n-            if Some(id) == self.node_id_high {\n+            if Some(id) == self.hir_id_high {\n                 self.span_high = Some(sp)\n             }\n         }\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n impl<'tcx> MutatePairDelegate {\n@@ -1627,7 +1634,7 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1640,7 +1647,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n                     if let PatKind::Binding(bind_ann, ..) = pat.node;\n                     if let BindingAnnotation::Mutable = bind_ann;\n                     then {\n-                        return Some(node_id);\n+                        return Some(cx.tcx.hir().node_to_hir_id(node_id));\n                     }\n                 }\n             }\n@@ -1652,11 +1659,11 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n fn check_for_mutation(\n     cx: &LateContext<'_, '_>,\n     body: &Expr,\n-    bound_ids: &[Option<NodeId>],\n+    bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n-        node_id_low: bound_ids[0],\n-        node_id_high: bound_ids[1],\n+        hir_id_low: bound_ids[0],\n+        hir_id_high: bound_ids[1],\n         span_low: None,\n         span_high: None,\n     };\n@@ -1666,7 +1673,7 @@ fn check_for_mutation(\n     delegate.mutation_span()\n }\n \n-/// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n@@ -1703,7 +1710,7 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n \n struct LocalUsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    local: ast::NodeId,\n+    local: HirId,\n     used: bool,\n }\n \n@@ -1725,7 +1732,7 @@ struct VarVisitor<'a, 'tcx: 'a> {\n     /// context reference\n     cx: &'a LateContext<'a, 'tcx>,\n     /// var name to look for as index\n-    var: ast::NodeId,\n+    var: HirId,\n     /// indexed variables that are used mutably\n     indexed_mut: FxHashSet<Name>,\n     /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n@@ -1772,8 +1779,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                         Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n                             let hir_id = self.cx.tcx.hir().node_to_hir_id(node_id);\n \n-                            let parent_id = self.cx.tcx.hir().get_parent(expr.id);\n-                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id_from_hir_id(parent_id);\n                             let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n                             if indexed_indirectly {\n                                 self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n@@ -1833,15 +1840,15 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             then {\n                 match self.cx.tables.qpath_def(qpath, expr.hir_id) {\n                     Def::Upvar(local_id, ..) => {\n-                        if local_id == self.var {\n+                        if self.cx.tcx.hir().node_to_hir_id(local_id) == self.var {\n                             // we are not indexing anything, record that\n                             self.nonindex = true;\n                         }\n                     }\n                     Def::Local(local_id) =>\n                     {\n \n-                        if local_id == self.var {\n+                        if self.cx.tcx.hir().node_to_hir_id(local_id) == self.var {\n                             self.nonindex = true;\n                         } else {\n                             // not the correct variable, but still a variable\n@@ -1926,7 +1933,7 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n     let mut visitor = VarUsedAfterLoopVisitor {\n         cx,\n         def_id,\n-        iter_expr_id: iter_expr.id,\n+        iter_expr_id: iter_expr.hir_id,\n         past_while_let: false,\n         var_used_after_while_let: false,\n     };\n@@ -1938,8 +1945,8 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n \n struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    def_id: NodeId,\n-    iter_expr_id: NodeId,\n+    def_id: HirId,\n+    iter_expr_id: HirId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n@@ -1950,7 +1957,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n             }\n-        } else if self.iter_expr_id == expr.id {\n+        } else if self.iter_expr_id == expr.hir_id {\n             self.past_while_let = true;\n         }\n         walk_expr(self, expr);\n@@ -1960,7 +1967,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Return true if the type of expr is one that provides `IntoIterator` impls\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[rustfmt::skip]\n fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n@@ -2015,7 +2022,7 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     }\n }\n \n-/// Return true if expr contains a single break expr without destination label\n+/// Returns `true` if expr contains a single break expr without destination label\n /// and\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n@@ -2043,9 +2050,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,       // context reference\n-    states: FxHashMap<NodeId, VarState>, // incremented variables\n-    depth: u32,                          // depth of conditional expressions\n+    cx: &'a LateContext<'a, 'tcx>,      // context reference\n+    states: FxHashMap<HirId, VarState>, // incremented variables\n+    depth: u32,                         // depth of conditional expressions\n     done: bool,\n }\n \n@@ -2062,7 +2069,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n \n                 match parent.node {\n                     ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                        if lhs.id == expr.id {\n+                        if lhs.hir_id == expr.hir_id {\n                             if op.node == BinOpKind::Add && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n@@ -2074,7 +2081,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             }\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _) if lhs.hir_id == expr.hir_id => *state = VarState::DontWarn,\n                     ExprKind::AddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n                 }\n@@ -2095,11 +2102,11 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Check whether a variable is initialized to zero at the start of a loop.\n+/// Checks whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n     end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n-    var_id: NodeId,\n+    var_id: HirId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n@@ -2110,7 +2117,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         // Look for declarations of the variable\n         if let StmtKind::Local(ref local) = stmt.node {\n-            if local.pat.id == self.var_id {\n+            if local.pat.hir_id == self.var_id {\n                 if let PatKind::Binding(.., ident, _) = local.pat.node {\n                     self.name = Some(ident.name);\n \n@@ -2147,10 +2154,10 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.node {\n-                    ExprKind::AssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = VarState::DontWarn;\n                     },\n-                    ExprKind::Assign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                    ExprKind::Assign(ref lhs, ref rhs) if lhs.hir_id == expr.hir_id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n@@ -2182,11 +2189,11 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n-            return Some(node_id);\n+            return Some(cx.tcx.hir().node_to_hir_id(node_id));\n         }\n     }\n     None\n@@ -2208,8 +2215,9 @@ fn is_conditional(expr: &Expr) -> bool {\n \n fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n-        if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(loop_block.id));\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n+        let parent_node = cx.tcx.hir().get_parent_node_by_hir_id(loop_block.hir_id);\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find_by_hir_id(parent_node);\n         then {\n             return is_loop_nested(cx, loop_expr, iter_expr)\n         }\n@@ -2218,18 +2226,18 @@ fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> b\n }\n \n fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n-    let mut id = loop_expr.id;\n+    let mut id = loop_expr.hir_id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name\n     } else {\n         return true;\n     };\n     loop {\n-        let parent = cx.tcx.hir().get_parent_node(id);\n+        let parent = cx.tcx.hir().get_parent_node_by_hir_id(id);\n         if parent == id {\n             return false;\n         }\n-        match cx.tcx.hir().find(parent) {\n+        match cx.tcx.hir().find_by_hir_id(parent) {\n             Some(Node::Expr(expr)) => match expr.node {\n                 ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;\n@@ -2238,7 +2246,7 @@ fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr)\n             },\n             Some(Node::Block(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n-                    id,\n+                    hir_id: id,\n                     iterator: iter_name,\n                     nesting: Unknown,\n                 };\n@@ -2266,14 +2274,14 @@ enum Nesting {\n use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n-    id: NodeId,\n+    hir_id: HirId,\n     iterator: Name,\n     nesting: Nesting,\n }\n \n impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n-        if stmt.id == self.id {\n+        if stmt.hir_id == self.hir_id {\n             self.nesting = LookFurther;\n         } else if self.nesting == Unknown {\n             walk_stmt(self, stmt);\n@@ -2284,7 +2292,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         if self.nesting != Unknown {\n             return;\n         }\n-        if expr.id == self.id {\n+        if expr.hir_id == self.hir_id {\n             self.nesting = LookFurther;\n             return;\n         }\n@@ -2328,7 +2336,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n \n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n     if constant(cx, cx.tables, cond).is_some() {\n-        // A pure constant condition (e.g. while false) is not linted.\n+        // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n \n@@ -2366,7 +2374,7 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, e\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: FxHashSet<NodeId>,\n+    ids: FxHashSet<HirId>,\n     def_ids: FxHashMap<def_id::DefId, bool>,\n     skip: bool,\n }\n@@ -2380,7 +2388,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n             then {\n                 match def {\n                     Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        self.ids.insert(node_id);\n+                        self.ids.insert(self.cx.tcx.hir().node_to_hir_id(node_id));\n                     },\n                     Def::Static(def_id, mutable) => {\n                         self.def_ids.insert(def_id, mutable);"}, {"sha": "4a3092640962fc7de8e788af62a856dfa212bf12", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -14,29 +14,29 @@ use syntax::source_map::Span;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n-/// `iterator.cloned()` instead\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x = vec![42, 43];\n-/// let y = x.iter();\n-/// let z = y.map(|i| *i);\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x = vec![42, 43];\n-/// let y = x.iter();\n-/// let z = y.cloned();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n+    /// `iterator.cloned()` instead\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.map(|i| *i);\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.cloned();\n+    /// ```\n     pub MAP_CLONE,\n     style,\n     \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\""}, {"sha": "f96418201da751d5fc5a2e9e5975d32f232b2476", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -11,67 +11,67 @@ use syntax::source_map::Span;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for usage of `option.map(f)` where f is a function\n-/// or closure that returns the unit type.\n-///\n-/// **Why is this bad?** Readability, this can be written more clearly with\n-/// an if let statement\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x: Option<&str> = do_stuff();\n-/// x.map(log_err_msg);\n-/// x.map(|msg| log_err_msg(format_msg(msg)))\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x: Option<&str> = do_stuff();\n-/// if let Some(msg) = x {\n-///     log_err_msg(msg)\n-/// }\n-/// if let Some(msg) = x {\n-///     log_err_msg(format_msg(msg))\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `option.map(f)` where f is a function\n+    /// or closure that returns the unit type.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more clearly with\n+    /// an if let statement\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: Option<&str> = do_stuff();\n+    /// x.map(log_err_msg);\n+    /// x.map(|msg| log_err_msg(format_msg(msg)))\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x: Option<&str> = do_stuff();\n+    /// if let Some(msg) = x {\n+    ///     log_err_msg(msg)\n+    /// }\n+    /// if let Some(msg) = x {\n+    ///     log_err_msg(format_msg(msg))\n+    /// }\n+    /// ```\n     pub OPTION_MAP_UNIT_FN,\n     complexity,\n     \"using `option.map(f)`, where f is a function or closure that returns ()\"\n }\n \n-/// **What it does:** Checks for usage of `result.map(f)` where f is a function\n-/// or closure that returns the unit type.\n-///\n-/// **Why is this bad?** Readability, this can be written more clearly with\n-/// an if let statement\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x: Result<&str, &str> = do_stuff();\n-/// x.map(log_err_msg);\n-/// x.map(|msg| log_err_msg(format_msg(msg)))\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x: Result<&str, &str> = do_stuff();\n-/// if let Ok(msg) = x {\n-///     log_err_msg(msg)\n-/// }\n-/// if let Ok(msg) = x {\n-///     log_err_msg(format_msg(msg))\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `result.map(f)` where f is a function\n+    /// or closure that returns the unit type.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more clearly with\n+    /// an if let statement\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: Result<&str, &str> = do_stuff();\n+    /// x.map(log_err_msg);\n+    /// x.map(|msg| log_err_msg(format_msg(msg)))\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x: Result<&str, &str> = do_stuff();\n+    /// if let Ok(msg) = x {\n+    ///     log_err_msg(msg)\n+    /// }\n+    /// if let Ok(msg) = x {\n+    ///     log_err_msg(format_msg(msg))\n+    /// }\n+    /// ```\n     pub RESULT_MAP_UNIT_FN,\n     complexity,\n     \"using `result.map(f)`, where f is a function or closure that returns ()\""}, {"sha": "e7e1df5cffff201855942b4892326f4a9a289401", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 155, "deletions": 153, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -18,192 +18,192 @@ use std::ops::Deref;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for matches with a single arm where an `if let`\n-/// will usually suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     Some(ref foo) => bar(foo),\n-///     _ => (),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches with a single arm where an `if let`\n+    /// will usually suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n     pub SINGLE_MATCH,\n     style,\n-    \"a match statement with a single nontrivial arm (i.e. where the other arm is `_ => {}`) instead of `if let`\"\n+    \"a match statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n }\n \n-/// **What it does:** Checks for matches with a two arms where an `if let else` will\n-/// usually suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n-///\n-/// **Known problems:** Personal style preferences may differ.\n-///\n-/// **Example:**\n-///\n-/// Using `match`:\n-///\n-/// ```rust\n-/// match x {\n-///     Some(ref foo) => bar(foo),\n-///     _ => bar(other_ref),\n-/// }\n-/// ```\n-///\n-/// Using `if let` with `else`:\n-///\n-/// ```rust\n-/// if let Some(ref foo) = x {\n-///     bar(foo);\n-/// } else {\n-///     bar(other_ref);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches with a two arms where an `if let else` will\n+    /// usually suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// **Known problems:** Personal style preferences may differ.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Using `match`:\n+    ///\n+    /// ```rust\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => bar(other_ref),\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `if let` with `else`:\n+    ///\n+    /// ```ignore\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// } else {\n+    ///     bar(other_ref);\n+    /// }\n+    /// ```\n     pub SINGLE_MATCH_ELSE,\n     pedantic,\n     \"a match statement with a two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n }\n \n-/// **What it does:** Checks for matches where all arms match a reference,\n-/// suggesting to remove the reference and deref the matched expression\n-/// instead. It also checks for `if let &foo = bar` blocks.\n-///\n-/// **Why is this bad?** It just makes the code less readable. That reference\n-/// destructuring adds nothing to the code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     &A(ref y) => foo(y),\n-///     &B => bar(),\n-///     _ => frob(&x),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches where all arms match a reference,\n+    /// suggesting to remove the reference and deref the matched expression\n+    /// instead. It also checks for `if let &foo = bar` blocks.\n+    ///\n+    /// **Why is this bad?** It just makes the code less readable. That reference\n+    /// destructuring adds nothing to the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// match x {\n+    ///     &A(ref y) => foo(y),\n+    ///     &B => bar(),\n+    ///     _ => frob(&x),\n+    /// }\n+    /// ```\n     pub MATCH_REF_PATS,\n     style,\n     \"a match or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n }\n \n-/// **What it does:** Checks for matches where match expression is a `bool`. It\n-/// suggests to replace the expression with an `if...else` block.\n-///\n-/// **Why is this bad?** It makes the code less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let condition: bool = true;\n-/// match condition {\n-///     true => foo(),\n-///     false => bar(),\n-/// }\n-/// ```\n-/// Use if/else instead:\n-/// ```rust\n-/// let condition: bool = true;\n-/// if condition {\n-///     foo();\n-/// } else {\n-///     bar();\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches where match expression is a `bool`. It\n+    /// suggests to replace the expression with an `if...else` block.\n+    ///\n+    /// **Why is this bad?** It makes the code less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let condition: bool = true;\n+    /// match condition {\n+    ///     true => foo(),\n+    ///     false => bar(),\n+    /// }\n+    /// ```\n+    /// Use if/else instead:\n+    /// ```ignore\n+    /// let condition: bool = true;\n+    /// if condition {\n+    ///     foo();\n+    /// } else {\n+    ///     bar();\n+    /// }\n+    /// ```\n     pub MATCH_BOOL,\n     style,\n     \"a match on a boolean expression instead of an `if..else` block\"\n }\n \n-/// **What it does:** Checks for overlapping match arms.\n-///\n-/// **Why is this bad?** It is likely to be an error and if not, makes the code\n-/// less obvious.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = 5;\n-/// match x {\n-///     1...10 => println!(\"1 ... 10\"),\n-///     5...15 => println!(\"5 ... 15\"),\n-///     _ => (),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for overlapping match arms.\n+    ///\n+    /// **Why is this bad?** It is likely to be an error and if not, makes the code\n+    /// less obvious.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     1...10 => println!(\"1 ... 10\"),\n+    ///     5...15 => println!(\"5 ... 15\"),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n     pub MATCH_OVERLAPPING_ARM,\n     style,\n     \"a match with overlapping arms\"\n }\n \n-/// **What it does:** Checks for arm which matches all errors with `Err(_)`\n-/// and take drastic actions like `panic!`.\n-///\n-/// **Why is this bad?** It is generally a bad practice, just like\n-/// catching all exceptions in java with `catch(Exception)`\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: Result(i32, &str) = Ok(3);\n-/// match x {\n-///     Ok(_) => println!(\"ok\"),\n-///     Err(_) => panic!(\"err\"),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for arm which matches all errors with `Err(_)`\n+    /// and take drastic actions like `panic!`.\n+    ///\n+    /// **Why is this bad?** It is generally a bad practice, just like\n+    /// catching all exceptions in java with `catch(Exception)`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: Result<i32, &str> = Ok(3);\n+    /// match x {\n+    ///     Ok(_) => println!(\"ok\"),\n+    ///     Err(_) => panic!(\"err\"),\n+    /// }\n+    /// ```\n     pub MATCH_WILD_ERR_ARM,\n     style,\n     \"a match with `Err(_)` arm and take drastic actions\"\n }\n \n-/// **What it does:** Checks for match which is used to add a reference to an\n-/// `Option` value.\n-///\n-/// **Why is this bad?** Using `as_ref()` or `as_mut()` instead is shorter.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: Option<()> = None;\n-/// let r: Option<&()> = match x {\n-///     None => None,\n-///     Some(ref v) => Some(v),\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for match which is used to add a reference to an\n+    /// `Option` value.\n+    ///\n+    /// **Why is this bad?** Using `as_ref()` or `as_mut()` instead is shorter.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: Option<()> = None;\n+    /// let r: Option<&()> = match x {\n+    ///     None => None,\n+    ///     Some(ref v) => Some(v),\n+    /// };\n+    /// ```\n     pub MATCH_AS_REF,\n     complexity,\n     \"a match on an Option value instead of using `as_ref()` or `as_mut`\"\n }\n \n-/// **What it does:** Checks for wildcard enum matches using `_`.\n-///\n-/// **Why is this bad?** New enum variants added by library updates can be missed.\n-///\n-/// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n-/// variants, and also may not use correct path to enum if it's not present in the current scope.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     A => {},\n-///     _ => {},\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard enum matches using `_`.\n+    ///\n+    /// **Why is this bad?** New enum variants added by library updates can be missed.\n+    ///\n+    /// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n+    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// match x {\n+    ///     A => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n     pub WILDCARD_ENUM_MATCH_ARM,\n     restriction,\n     \"a wildcard enum match arm using `_`\"\n@@ -266,7 +266,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             return;\n         };\n         let ty = cx.tables.expr_ty(ex);\n-        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.id) {\n+        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n@@ -322,7 +322,7 @@ fn check_single_match_opt_like(\n     ty: Ty<'_>,\n     els: Option<&Expr>,\n ) {\n-    // list of candidate Enums we know will never get any more members\n+    // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n         (&paths::COW, \"Cow::Borrowed\"),\n@@ -335,7 +335,7 @@ fn check_single_match_opt_like(\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n-            // contains any non wildcard patterns? e.g. Err(err)\n+            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n                 return;\n             }\n@@ -354,7 +354,7 @@ fn check_single_match_opt_like(\n }\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    // type of expression == bool\n+    // Type of expression is `bool`.\n     if cx.tables.expr_ty(ex).sty == ty::Bool {\n         span_lint_and_then(\n             cx,\n@@ -482,7 +482,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n         for pat in &arm.pats {\n             if let PatKind::Wild = pat.node {\n                 wildcard_span = Some(pat.span);\n-            } else if let PatKind::Binding(_, _, _, ident, None) = pat.node {\n+            } else if let PatKind::Binding(_, _, ident, None) = pat.node {\n                 wildcard_span = Some(pat.span);\n                 wildcard_ident = Some(ident);\n             }\n@@ -570,13 +570,15 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n         let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-            suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n+            let span = ex.span.source_callsite();\n+            suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n             (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n                 \"try\",\n             )\n         } else {\n-            suggs.push((ex.span, Sugg::hir(cx, ex, \"..\").deref().to_string()));\n+            let span = ex.span.source_callsite();\n+            suggs.push((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n             (\n                 \"you don't need to add `&` to all patterns\",\n                 \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n@@ -637,7 +639,7 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n     }\n }\n \n-/// Get all arms that are unbounded `PatRange`s.\n+/// Gets all arms that are unbounded `PatRange`s.\n fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n@@ -685,7 +687,7 @@ pub struct SpannedRange<T> {\n \n type TypedRanges = Vec<SpannedRange<u128>>;\n \n-/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n+/// Gets all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n /// and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {"}, {"sha": "0eb42dbaaf99757d8ce6ad4e1dfc73e6893add06", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, opt_def_id, paths, snippet, span_lint_and_then, walk_ptrs_ty_depth};\n+use crate::utils::{match_def_path, paths, snippet, span_lint_and_then, walk_ptrs_ty_depth};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -7,19 +7,21 @@ use rustc_errors::Applicability;\n \n use std::iter;\n \n-/// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n-///\n-/// **Why is this bad?** The value of `mem::discriminant()` on non-enum types\n-/// is unspecified.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mem::discriminant(&\"hello\");\n-/// mem::discriminant(&&Some(2));\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n+    ///\n+    /// **Why is this bad?** The value of `mem::discriminant()` on non-enum types\n+    /// is unspecified.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::mem;\n+    ///\n+    /// mem::discriminant(&\"hello\");\n+    /// mem::discriminant(&&Some(2));\n+    /// ```\n     pub MEM_DISCRIMINANT_NON_ENUM,\n     correctness,\n     \"calling mem::descriminant on non-enum type\"\n@@ -43,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n             if let ExprKind::Call(ref func, ref func_args) = expr.node;\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.node;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(func_qpath, func.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx.tcx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n             let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);"}, {"sha": "82070063b0460877761ab7d5c40c2b0cdac017f7", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,21 +1,21 @@\n-use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n+use crate::utils::{match_def_path, paths, span_lint};\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n-/// `Drop`.\n-///\n-/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n-/// destructor, possibly causing leaks.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mem::forget(Rc::new(55))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n+    /// `Drop`.\n+    ///\n+    /// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n+    /// destructor, possibly causing leaks.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mem::forget(Rc::new(55))\n+    /// ```\n     pub MEM_FORGET,\n     restriction,\n     \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\"\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n+                if let Some(def_id) = cx.tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);\n "}, {"sha": "57b05ab108cb780e04888adf23f2895a08797e7b", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,30 +1,32 @@\n-use crate::utils::{match_def_path, match_qpath, opt_def_id, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{match_def_path, match_qpath, paths, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for `mem::replace()` on an `Option` with\n-/// `None`.\n-///\n-/// **Why is this bad?** `Option` already has the method `take()` for\n-/// taking its current value (Some(..) or None) and replacing it with\n-/// `None`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut an_option = Some(0);\n-/// let replaced = mem::replace(&mut an_option, None);\n-/// ```\n-/// Is better expressed with:\n-/// ```rust\n-/// let mut an_option = Some(0);\n-/// let taken = an_option.take();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `mem::replace()` on an `Option` with\n+    /// `None`.\n+    ///\n+    /// **Why is this bad?** `Option` already has the method `take()` for\n+    /// taking its current value (Some(..) or None) and replacing it with\n+    /// `None`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::mem;\n+    ///\n+    /// let mut an_option = Some(0);\n+    /// let replaced = mem::replace(&mut an_option, None);\n+    /// ```\n+    /// Is better expressed with:\n+    /// ```rust\n+    /// let mut an_option = Some(0);\n+    /// let taken = an_option.take();\n+    /// ```\n     pub MEM_REPLACE_OPTION_WITH_NONE,\n     style,\n     \"replacing an `Option` with `None` instead of `take()`\"\n@@ -49,7 +51,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             if let ExprKind::Call(ref func, ref func_args) = expr.node;\n             if func_args.len() == 2;\n             if let ExprKind::Path(ref func_qpath) = func.node;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(func_qpath, func.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx.tcx, def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`"}, {"sha": "d7ab3505765573ec3c7149b5ff36b9e2b36ce9bd", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 599, "deletions": 662, "changes": 1261, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,12 +1,10 @@\n-use crate::utils::paths;\n-use crate::utils::sugg;\n-use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self,\n-    is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n-    match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path,\n-    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n-};\n+mod option_map_unwrap_or;\n+mod unnecessary_filter_map;\n+\n+use std::borrow::Cow;\n+use std::fmt;\n+use std::iter;\n+\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n@@ -15,761 +13,765 @@ use rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray,\n use rustc::ty::{self, Predicate, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use std::borrow::Cow;\n-use std::fmt;\n-use std::iter;\n use syntax::ast;\n use syntax::source_map::{BytePos, Span};\n use syntax::symbol::LocalInternedString;\n \n-mod unnecessary_filter_map;\n+use crate::utils::paths;\n+use crate::utils::sugg;\n+use crate::utils::{\n+    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy, is_expn_of,\n+    is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath,\n+    match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+};\n \n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n-///\n-/// **Why is this bad?** Usually it is better to handle the `None` case, or to\n-/// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n-/// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n-/// `Allow` by default.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.unwrap()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n+    ///\n+    /// **Why is this bad?** Usually it is better to handle the `None` case, or to\n+    /// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n+    /// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.unwrap()\n+    /// ```\n     pub OPTION_UNWRAP_USED,\n     restriction,\n     \"using `Option.unwrap()`, which should at least get a better message using `expect()`\"\n }\n \n-/// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n-///\n-/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n-/// values. Normally, you want to implement more sophisticated error handling,\n-/// and propagate errors upwards with `try!`.\n-///\n-/// Even if you want to panic on errors, not all `Error`s implement good\n-/// messages on display.  Therefore it may be beneficial to look at the places\n-/// where they may get displayed. Activate this lint to do just that.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.unwrap()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n+    ///\n+    /// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n+    /// values. Normally, you want to implement more sophisticated error handling,\n+    /// and propagate errors upwards with `try!`.\n+    ///\n+    /// Even if you want to panic on errors, not all `Error`s implement good\n+    /// messages on display. Therefore, it may be beneficial to look at the places\n+    /// where they may get displayed. Activate this lint to do just that.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.unwrap()\n+    /// ```\n     pub RESULT_UNWRAP_USED,\n     restriction,\n     \"using `Result.unwrap()`, which might be better handled\"\n }\n \n-/// **What it does:** Checks for methods that should live in a trait\n-/// implementation of a `std` trait (see [llogiq's blog\n-/// post](http://llogiq.github.io/2015/07/30/traits.html) for further\n-/// information) instead of an inherent implementation.\n-///\n-/// **Why is this bad?** Implementing the traits improve ergonomics for users of\n-/// the code, often with very little cost. Also people seeing a `mul(...)`\n-/// method\n-/// may expect `*` to work equally, so you should have good reason to disappoint\n-/// them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn add(&self, other: &X) -> X {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for methods that should live in a trait\n+    /// implementation of a `std` trait (see [llogiq's blog\n+    /// post](http://llogiq.github.io/2015/07/30/traits.html) for further\n+    /// information) instead of an inherent implementation.\n+    ///\n+    /// **Why is this bad?** Implementing the traits improve ergonomics for users of\n+    /// the code, often with very little cost. Also people seeing a `mul(...)`\n+    /// method\n+    /// may expect `*` to work equally, so you should have good reason to disappoint\n+    /// them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// struct X;\n+    /// impl X {\n+    ///     fn add(&self, other: &X) -> X {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub SHOULD_IMPLEMENT_TRAIT,\n     style,\n     \"defining a method that should be implementing a std trait\"\n }\n \n-/// **What it does:** Checks for methods with certain name prefixes and which\n-/// doesn't match how self is taken. The actual rules are:\n-///\n-/// |Prefix |`self` taken          |\n-/// |-------|----------------------|\n-/// |`as_`  |`&self` or `&mut self`|\n-/// |`from_`| none                 |\n-/// |`into_`|`self`                |\n-/// |`is_`  |`&self` or none       |\n-/// |`to_`  |`&self`               |\n-///\n-/// **Why is this bad?** Consistency breeds readability. If you follow the\n-/// conventions, your users won't be surprised that they, e.g., need to supply a\n-/// mutable reference to a `as_..` function.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     fn as_str(self) -> &str {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for methods with certain name prefixes and which\n+    /// doesn't match how self is taken. The actual rules are:\n+    ///\n+    /// |Prefix |`self` taken          |\n+    /// |-------|----------------------|\n+    /// |`as_`  |`&self` or `&mut self`|\n+    /// |`from_`| none                 |\n+    /// |`into_`|`self`                |\n+    /// |`is_`  |`&self` or none       |\n+    /// |`to_`  |`&self`               |\n+    ///\n+    /// **Why is this bad?** Consistency breeds readability. If you follow the\n+    /// conventions, your users won't be surprised that they, e.g., need to supply a\n+    /// mutable reference to a `as_..` function.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl X {\n+    ///     fn as_str(self) -> &str {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub WRONG_SELF_CONVENTION,\n     style,\n     \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n }\n \n-/// **What it does:** This is the same as\n-/// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n-///\n-/// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n-///\n-/// **Known problems:** Actually *renaming* the function may break clients if\n-/// the function is part of the public interface. In that case, be mindful of\n-/// the stability guarantees you've given your users.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     pub fn as_str(self) -> &str {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This is the same as\n+    /// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n+    ///\n+    /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n+    ///\n+    /// **Known problems:** Actually *renaming* the function may break clients if\n+    /// the function is part of the public interface. In that case, be mindful of\n+    /// the stability guarantees you've given your users.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl X {\n+    ///     pub fn as_str(self) -> &str {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub WRONG_PUB_SELF_CONVENTION,\n     restriction,\n     \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n }\n \n-/// **What it does:** Checks for usage of `ok().expect(..)`.\n-///\n-/// **Why is this bad?** Because you usually call `expect()` on the `Result`\n-/// directly to get a better error message.\n-///\n-/// **Known problems:** The error type needs to implement `Debug`\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.ok().expect(\"why did I do this again?\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `ok().expect(..)`.\n+    ///\n+    /// **Why is this bad?** Because you usually call `expect()` on the `Result`\n+    /// directly to get a better error message.\n+    ///\n+    /// **Known problems:** The error type needs to implement `Debug`\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x.ok().expect(\"why did I do this again?\")\n+    /// ```\n     pub OK_EXPECT,\n     style,\n     \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\"\n }\n \n-/// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.map_or(_, _)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or(0)\n-/// ```\n declare_clippy_lint! {\n-pub OPTION_MAP_UNWRAP_OR,\n-pedantic,\n-\"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n- `map_or(a, f)`\"\n-}\n-\n-/// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.map_or_else(_, _)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or_else(some_function)\n-/// ```\n+    /// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.map_or(_, _)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or(0)\n+    /// ```\n+    pub OPTION_MAP_UNWRAP_OR,\n+    pedantic,\n+    \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\"\n+}\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.map_or_else(_, _)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or_else(some_function)\n+    /// ```\n     pub OPTION_MAP_UNWRAP_OR_ELSE,\n     pedantic,\n     \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\"\n }\n \n-/// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `result.ok().map_or_else(_, _)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or_else(some_function)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `result.ok().map_or_else(_, _)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or_else(some_function)\n+    /// ```\n     pub RESULT_MAP_UNWRAP_OR_ELSE,\n     pedantic,\n     \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `.ok().map_or_else(g, f)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.map_or(None, _)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.and_then(_)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// opt.map_or(None, |a| a + 1)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map_or(None, _)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.and_then(_)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// opt.map_or(None, |a| a + 1)\n+    /// ```\n     pub OPTION_MAP_OR_NONE,\n     style,\n     \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.filter(_).next()`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.find(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.filter(|x| x == 0).next()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.filter(_).next()`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.find(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.filter(|x| x == 0).next()\n+    /// ```\n     pub FILTER_NEXT,\n     complexity,\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.map(_).flatten(_)`,\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as a\n-/// single method call.\n-///\n-/// **Known problems:**\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.map(|x| x.iter()).flatten()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map(_).flatten(_)`,\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as a\n+    /// single method call.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.map(|x| x.iter()).flatten()\n+    /// ```\n     pub MAP_FLATTEN,\n     pedantic,\n     \"using combinations of `flatten` and `map` which can usually be written as a single method call\"\n }\n \n-/// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n-/// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as a\n-/// single method call.\n-///\n-/// **Known problems:** Often requires a condition + Option/Iterator creation\n-/// inside the closure.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.filter(|x| x == 0).map(|x| x * 2)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n+    /// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as a\n+    /// single method call.\n+    ///\n+    /// **Known problems:** Often requires a condition + Option/Iterator creation\n+    /// inside the closure.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.filter(|x| x == 0).map(|x| x * 2)\n+    /// ```\n     pub FILTER_MAP,\n     pedantic,\n     \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\"\n }\n \n-/// **What it does:** Checks for an iterator search (such as `find()`,\n-/// `position()`, or `rposition()`) followed by a call to `is_some()`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.any(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.find(|x| x == 0).is_some()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for an iterator search (such as `find()`,\n+    /// `position()`, or `rposition()`) followed by a call to `is_some()`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.any(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.find(|x| x == 0).is_some()\n+    /// ```\n     pub SEARCH_IS_SOME,\n     complexity,\n     \"using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\"\n }\n \n-/// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n-/// if it starts with a given char.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.starts_with(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// name.chars().next() == Some('_')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n+    /// if it starts with a given char.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.starts_with(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// name.chars().next() == Some('_')\n+    /// ```\n     pub CHARS_NEXT_CMP,\n     complexity,\n     \"using `.chars().next()` to check if a string starts with a char\"\n }\n \n-/// **What it does:** Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n-/// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n-/// `unwrap_or_default` instead.\n-///\n-/// **Why is this bad?** The function will always be called and potentially\n-/// allocate an object acting as the default.\n-///\n-/// **Known problems:** If the function has side-effects, not calling it will\n-/// change the semantic of the program, but you shouldn't rely on that anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo.unwrap_or(String::new())\n-/// ```\n-/// this can instead be written:\n-/// ```rust\n-/// foo.unwrap_or_else(String::new)\n-/// ```\n-/// or\n-/// ```rust\n-/// foo.unwrap_or_default()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n+    /// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n+    /// `unwrap_or_default` instead.\n+    ///\n+    /// **Why is this bad?** The function will always be called and potentially\n+    /// allocate an object acting as the default.\n+    ///\n+    /// **Known problems:** If the function has side-effects, not calling it will\n+    /// change the semantic of the program, but you shouldn't rely on that anyway.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo.unwrap_or(String::new())\n+    /// ```\n+    /// this can instead be written:\n+    /// ```rust\n+    /// foo.unwrap_or_else(String::new)\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// foo.unwrap_or_default()\n+    /// ```\n     pub OR_FUN_CALL,\n     perf,\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n-/// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n-/// etc., and suggests to use `unwrap_or_else` instead\n-///\n-/// **Why is this bad?** The function will always be called.\n-///\n-/// **Known problems:** If the function has side-effects, not calling it will\n-/// change the semantic of the program, but you shouldn't rely on that anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo.expect(&format!(\"Err {}: {}\", err_code, err_msg))\n-/// ```\n-/// or\n-/// ```rust\n-/// foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str())\n-/// ```\n-/// this can instead be written:\n-/// ```rust\n-/// foo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+    /// etc., and suggests to use `unwrap_or_else` instead\n+    ///\n+    /// **Why is this bad?** The function will always be called.\n+    ///\n+    /// **Known problems:** If the function has side-effects, not calling it will\n+    /// change the semantic of the program, but you shouldn't rely on that anyway.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo.expect(&format!(\"Err {}: {}\", err_code, err_msg))\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str())\n+    /// ```\n+    /// this can instead be written:\n+    /// ```rust\n+    /// foo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n+    /// ```\n     pub EXPECT_FUN_CALL,\n     perf,\n     \"using any `expect` method with a function call\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n-///\n-/// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n-/// generics, not for using the `clone` method on a concrete type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 42u64.clone()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n+    ///\n+    /// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n+    /// generics, not for using the `clone` method on a concrete type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 42u64.clone()\n+    /// ```\n     pub CLONE_ON_COPY,\n     complexity,\n     \"using `clone` on a `Copy` type\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on a ref-counted pointer,\n-/// (`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n-/// function syntax instead (e.g. `Rc::clone(foo)`).\n-///\n-/// **Why is this bad?** Calling '.clone()' on an Rc, Arc, or Weak\n-/// can obscure the fact that only the pointer is being cloned, not the underlying\n-/// data.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.clone()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on a ref-counted pointer,\n+    /// (`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n+    /// function syntax instead (e.g., `Rc::clone(foo)`).\n+    ///\n+    /// **Why is this bad?** Calling '.clone()' on an Rc, Arc, or Weak\n+    /// can obscure the fact that only the pointer is being cloned, not the underlying\n+    /// data.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.clone()\n+    /// ```\n     pub CLONE_ON_REF_PTR,\n     restriction,\n     \"using 'clone' on a ref-counted pointer\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on an `&&T`.\n-///\n-/// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of\n-/// cloning the underlying `T`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn main() {\n-///     let x = vec![1];\n-///     let y = &&x;\n-///     let z = y.clone();\n-///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on an `&&T`.\n+    ///\n+    /// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of\n+    /// cloning the underlying `T`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = vec![1];\n+    ///     let y = &&x;\n+    ///     let z = y.clone();\n+    ///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n+    /// }\n+    /// ```\n     pub CLONE_DOUBLE_REF,\n     correctness,\n     \"using `clone` on `&&T`\"\n }\n \n-/// **What it does:** Checks for `new` not returning `Self`.\n-///\n-/// **Why is this bad?** As a convention, `new` methods are used to make a new\n-/// instance of a type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl Foo {\n-///     fn new(..) -> NotAFoo {\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `new` not returning `Self`.\n+    ///\n+    /// **Why is this bad?** As a convention, `new` methods are used to make a new\n+    /// instance of a type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl Foo {\n+    ///     fn new(..) -> NotAFoo {\n+    ///     }\n+    /// }\n+    /// ```\n     pub NEW_RET_NO_SELF,\n     style,\n     \"not returning `Self` in a `new` method\"\n }\n \n-/// **What it does:** Checks for string methods that receive a single-character\n-/// `str` as an argument, e.g. `_.split(\"x\")`.\n-///\n-/// **Why is this bad?** Performing these methods using a `char` is faster than\n-/// using a `str`.\n-///\n-/// **Known problems:** Does not catch multi-byte unicode characters.\n-///\n-/// **Example:**\n-/// `_.split(\"x\")` could be `_.split('x')`\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string methods that receive a single-character\n+    /// `str` as an argument, e.g., `_.split(\"x\")`.\n+    ///\n+    /// **Why is this bad?** Performing these methods using a `char` is faster than\n+    /// using a `str`.\n+    ///\n+    /// **Known problems:** Does not catch multi-byte unicode characters.\n+    ///\n+    /// **Example:**\n+    /// `_.split(\"x\")` could be `_.split('x')`\n     pub SINGLE_CHAR_PATTERN,\n     perf,\n-    \"using a single-character str where a char could be used, e.g. `_.split(\\\"x\\\")`\"\n-}\n-\n-/// **What it does:** Checks for getting the inner pointer of a temporary\n-/// `CString`.\n-///\n-/// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n-/// as the `CString` is alive.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let c_str = CString::new(\"foo\").unwrap().as_ptr();\n-/// unsafe {\n-///     call_some_ffi_func(c_str);\n-/// }\n-/// ```\n-/// Here `c_str` point to a freed address. The correct use would be:\n-/// ```rust,ignore\n-/// let c_str = CString::new(\"foo\").unwrap();\n-/// unsafe {\n-///     call_some_ffi_func(c_str.as_ptr());\n-/// }\n-/// ```\n+    \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\"\n+}\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for getting the inner pointer of a temporary\n+    /// `CString`.\n+    ///\n+    /// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n+    /// as the `CString` is alive.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let c_str = CString::new(\"foo\").unwrap().as_ptr();\n+    /// unsafe {\n+    ///     call_some_ffi_func(c_str);\n+    /// }\n+    /// ```\n+    /// Here `c_str` point to a freed address. The correct use would be:\n+    /// ```rust,ignore\n+    /// let c_str = CString::new(\"foo\").unwrap();\n+    /// unsafe {\n+    ///     call_some_ffi_func(c_str.as_ptr());\n+    /// }\n+    /// ```\n     pub TEMPORARY_CSTRING_AS_PTR,\n     correctness,\n     \"getting the inner pointer of a temporary `CString`\"\n }\n \n-/// **What it does:** Checks for use of `.iter().nth()` (and the related\n-/// `.iter_mut().nth()`) on standard library types with O(1) element access.\n-///\n-/// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more\n-/// readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().nth(3);\n-/// let bad_slice = &some_vec[..].iter().nth(3);\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.get(3);\n-/// let bad_slice = &some_vec[..].get(3);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.iter().nth()` (and the related\n+    /// `.iter_mut().nth()`) on standard library types with O(1) element access.\n+    ///\n+    /// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().nth(3);\n+    /// let bad_slice = &some_vec[..].iter().nth(3);\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.get(3);\n+    /// let bad_slice = &some_vec[..].get(3);\n+    /// ```\n     pub ITER_NTH,\n     perf,\n     \"using `.iter().nth()` on a standard library type with O(1) element access\"\n }\n \n-/// **What it does:** Checks for use of `.skip(x).next()` on iterators.\n-///\n-/// **Why is this bad?** `.nth(x)` is cleaner\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().skip(3).next();\n-/// let bad_slice = &some_vec[..].iter().skip(3).next();\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().nth(3);\n-/// let bad_slice = &some_vec[..].iter().nth(3);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.skip(x).next()` on iterators.\n+    ///\n+    /// **Why is this bad?** `.nth(x)` is cleaner\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().skip(3).next();\n+    /// let bad_slice = &some_vec[..].iter().skip(3).next();\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().nth(3);\n+    /// let bad_slice = &some_vec[..].iter().nth(3);\n+    /// ```\n     pub ITER_SKIP_NEXT,\n     style,\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n-/// **What it does:** Checks for use of `.get().unwrap()` (or\n-/// `.get_mut().unwrap`) on a standard library type which implements `Index`\n-///\n-/// **Why is this bad?** Using the Index trait (`[]`) is more clear and more\n-/// concise.\n-///\n-/// **Known problems:** Not a replacement for error handling: Using either\n-/// `.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n-/// if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n-/// temporary placeholder for dealing with the `Option` type, then this does\n-/// not mitigate the need for error handling. If there is a chance that `.get()`\n-/// will be `None` in your program, then it is advisable that the `None` case\n-/// is handled in a future refactor instead of using `.unwrap()` or the Index\n-/// trait.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let last = some_vec.get(3).unwrap();\n-/// *some_vec.get_mut(0).unwrap() = 1;\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let last = some_vec[3];\n-/// some_vec[0] = 1;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.get().unwrap()` (or\n+    /// `.get_mut().unwrap`) on a standard library type which implements `Index`\n+    ///\n+    /// **Why is this bad?** Using the Index trait (`[]`) is more clear and more\n+    /// concise.\n+    ///\n+    /// **Known problems:** Not a replacement for error handling: Using either\n+    /// `.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n+    /// if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n+    /// temporary placeholder for dealing with the `Option` type, then this does\n+    /// not mitigate the need for error handling. If there is a chance that `.get()`\n+    /// will be `None` in your program, then it is advisable that the `None` case\n+    /// is handled in a future refactor instead of using `.unwrap()` or the Index\n+    /// trait.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut some_vec = vec![0, 1, 2, 3];\n+    /// let last = some_vec.get(3).unwrap();\n+    /// *some_vec.get_mut(0).unwrap() = 1;\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let mut some_vec = vec![0, 1, 2, 3];\n+    /// let last = some_vec[3];\n+    /// some_vec[0] = 1;\n+    /// ```\n     pub GET_UNWRAP,\n-    style,\n+    restriction,\n     \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\"\n }\n \n-/// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n-/// `&str` or `String`.\n-///\n-/// **Why is this bad?** `.push_str(s)` is clearer\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let abc = \"abc\";\n-/// let def = String::from(\"def\");\n-/// let mut s = String::new();\n-/// s.extend(abc.chars());\n-/// s.extend(def.chars());\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let abc = \"abc\";\n-/// let def = String::from(\"def\");\n-/// let mut s = String::new();\n-/// s.push_str(abc);\n-/// s.push_str(&def));\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n+    /// `&str` or `String`.\n+    ///\n+    /// **Why is this bad?** `.push_str(s)` is clearer\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let abc = \"abc\";\n+    /// let def = String::from(\"def\");\n+    /// let mut s = String::new();\n+    /// s.extend(abc.chars());\n+    /// s.extend(def.chars());\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let abc = \"abc\";\n+    /// let def = String::from(\"def\");\n+    /// let mut s = String::new();\n+    /// s.push_str(abc);\n+    /// s.push_str(&def);\n+    /// ```\n     pub STRING_EXTEND_CHARS,\n     style,\n     \"using `x.extend(s.chars())` where s is a `&str` or `String`\"\n }\n \n-/// **What it does:** Checks for the use of `.cloned().collect()` on slice to\n-/// create a `Vec`.\n-///\n-/// **Why is this bad?** `.to_vec()` is clearer\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let s = [1, 2, 3, 4, 5];\n-/// let s2: Vec<isize> = s[..].iter().cloned().collect();\n-/// ```\n-/// The better use would be:\n-/// ```rust\n-/// let s = [1, 2, 3, 4, 5];\n-/// let s2: Vec<isize> = s.to_vec();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `.cloned().collect()` on slice to\n+    /// create a `Vec`.\n+    ///\n+    /// **Why is this bad?** `.to_vec()` is clearer\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let s = [1, 2, 3, 4, 5];\n+    /// let s2: Vec<isize> = s[..].iter().cloned().collect();\n+    /// ```\n+    /// The better use would be:\n+    /// ```rust\n+    /// let s = [1, 2, 3, 4, 5];\n+    /// let s2: Vec<isize> = s.to_vec();\n+    /// ```\n     pub ITER_CLONED_COLLECT,\n     style,\n     \"using `.cloned().collect()` on slice to create a `Vec`\"\n }\n \n-/// **What it does:** Checks for usage of `.chars().last()` or\n-/// `.chars().next_back()` on a `str` to check if it ends with a given char.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.ends_with(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.chars().last()` or\n+    /// `.chars().next_back()` on a `str` to check if it ends with a given char.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.ends_with(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n+    /// ```\n     pub CHARS_LAST_CMP,\n     style,\n     \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\"\n }\n \n-/// **What it does:** Checks for usage of `.as_ref()` or `.as_mut()` where the\n-/// types before and after the call are the same.\n-///\n-/// **Why is this bad?** The call is unnecessary.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: &[i32] = &[1, 2, 3, 4, 5];\n-/// do_stuff(x.as_ref());\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let x: &[i32] = &[1, 2, 3, 4, 5];\n-/// do_stuff(x);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.as_ref()` or `.as_mut()` where the\n+    /// types before and after the call are the same.\n+    ///\n+    /// **Why is this bad?** The call is unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: &[i32] = &[1, 2, 3, 4, 5];\n+    /// do_stuff(x.as_ref());\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let x: &[i32] = &[1, 2, 3, 4, 5];\n+    /// do_stuff(x);\n+    /// ```\n     pub USELESS_ASREF,\n     complexity,\n     \"using `as_ref` where the types before and after the call are the same\"\n }\n \n-/// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n-/// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n-/// `sum` or `product`.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** False positive in pattern guards. Will be resolved once\n-/// non-lexical lifetimes are stable.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n-/// ```\n-/// This could be written as:\n-/// ```rust\n-/// let _ = (0..3).any(|x| x > 2);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n+    /// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n+    /// `sum` or `product`.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False positive in pattern guards. Will be resolved once\n+    /// non-lexical lifetimes are stable.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+    /// ```\n+    /// This could be written as:\n+    /// ```rust\n+    /// let _ = (0..3).any(|x| x > 2);\n+    /// ```\n     pub UNNECESSARY_FOLD,\n     style,\n     \"using `fold` when a more succinct alternative exists\"\n }\n \n-/// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n-/// More specifically it checks if the closure provided is only performing one of the\n-/// filter or map operations and suggests the appropriate option.\n-///\n-/// **Why is this bad?** Complexity. The intent is also clearer if only a single\n-/// operation is being performed.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n-/// ```\n-/// As there is no transformation of the argument this could be written as:\n-/// ```rust\n-/// let _ = (0..3).filter(|&x| x > 2);\n-/// ```\n-///\n-/// ```rust\n-/// let _ = (0..4).filter_map(i32::checked_abs);\n-/// ```\n-/// As there is no conditional check on the argument this could be written as:\n-/// ```rust\n-/// let _ = (0..4).map(i32::checked_abs);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n+    /// More specifically it checks if the closure provided is only performing one of the\n+    /// filter or map operations and suggests the appropriate option.\n+    ///\n+    /// **Why is this bad?** Complexity. The intent is also clearer if only a single\n+    /// operation is being performed.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n+    /// ```\n+    /// As there is no transformation of the argument this could be written as:\n+    /// ```rust\n+    /// let _ = (0..3).filter(|&x| x > 2);\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// let _ = (0..4).filter_map(i32::checked_abs);\n+    /// ```\n+    /// As there is no conditional check on the argument this could be written as:\n+    /// ```rust\n+    /// let _ = (0..4).map(i32::checked_abs);\n+    /// ```\n     pub UNNECESSARY_FILTER_MAP,\n     complexity,\n     \"using `filter_map` when a more succinct alternative exists\"\n }\n \n-/// **What it does:** Checks for `into_iter` calls on types which should be replaced by `iter` or\n-/// `iter_mut`.\n-///\n-/// **Why is this bad?** Arrays and `PathBuf` do not yet have an `into_iter` method which move out\n-/// their content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\n-/// instead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\n-/// like calling `iter` would. Furthermore, when the standard library actually\n-/// [implements the `into_iter` method][25725] which moves the content out of the array, the\n-/// original use of `into_iter` got inferred with the wrong type and the code will be broken.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n-/// ```\n-///\n-/// [25725]: https://github.com/rust-lang/rust/issues/25725\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `into_iter` calls on types which should be replaced by `iter` or\n+    /// `iter_mut`.\n+    ///\n+    /// **Why is this bad?** Arrays and `PathBuf` do not yet have an `into_iter` method which move out\n+    /// their content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\n+    /// instead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\n+    /// like calling `iter` would. Furthermore, when the standard library actually\n+    /// [implements the `into_iter` method][25725] which moves the content out of the array, the\n+    /// original use of `into_iter` got inferred with the wrong type and the code will be broken.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n+    /// ```\n+    ///\n+    /// [25725]: https://github.com/rust-lang/rust/issues/25725\n     pub INTO_ITER_ON_ARRAY,\n     correctness,\n     \"using `.into_iter()` on an array\"\n }\n \n-/// **What it does:** Checks for `into_iter` calls on references which should be replaced by `iter`\n-/// or `iter_mut`.\n-///\n-/// **Why is this bad?** Readability. Calling `into_iter` on a reference will not move out its\n-/// content into the resulting iterator, which is confusing. It is better just call `iter` or\n-/// `iter_mut` directly.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let _ = (&vec![3, 4, 5]).into_iter();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `into_iter` calls on references which should be replaced by `iter`\n+    /// or `iter_mut`.\n+    ///\n+    /// **Why is this bad?** Readability. Calling `into_iter` on a reference will not move out its\n+    /// content into the resulting iterator, which is confusing. It is better just call `iter` or\n+    /// `iter_mut` directly.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = (&vec![3, 4, 5]).into_iter();\n+    /// ```\n     pub INTO_ITER_ON_REF,\n     style,\n     \"using `.into_iter()` on a reference\"\n@@ -821,7 +823,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    #[allow(clippy::cyclomatic_complexity)]\n+    #[allow(clippy::cognitive_complexity)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if in_macro(expr.span) {\n             return;\n@@ -836,7 +838,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             [\"unwrap\", \"get_mut\"] => lint_get_unwrap(cx, expr, arg_lists[1], true),\n             [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n-            [\"unwrap_or\", \"map\"] => lint_map_unwrap_or(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -906,17 +908,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let name = implitem.ident.name;\n-        let parent = cx.tcx.hir().get_parent(implitem.id);\n-        let item = cx.tcx.hir().expect_item(parent);\n-        let def_id = cx.tcx.hir().local_def_id(item.id);\n+        let parent = cx.tcx.hir().get_parent_item(implitem.hir_id);\n+        let item = cx.tcx.hir().expect_item_by_hir_id(parent);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n-                if cx.access_levels.is_exported(implitem.id) {\n+                let node_id = cx.tcx.hir().hir_to_node_id(implitem.hir_id);\n+                if cx.access_levels.is_exported(node_id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n@@ -963,7 +966,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         if let hir::ImplItemKind::Method(_, _) = implitem.node {\n-            let ret_ty = return_ty(cx, implitem.id);\n+            let ret_ty = return_ty(cx, implitem.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n             for inner_type in ret_ty.walk() {\n@@ -1007,7 +1010,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n-    /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_, '_>,\n         name: &str,\n@@ -1056,7 +1059,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         false\n     }\n \n-    /// Check for `*or(foo())`.\n+    /// Checks for `*or(foo())`.\n     #[allow(clippy::too_many_arguments)]\n     fn check_general_case(\n         cx: &LateContext<'_, '_>,\n@@ -1082,7 +1085,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         }\n \n         // don't lint for constant values\n-        let owner_def = cx.tcx.hir().get_parent_did(arg.id);\n+        let owner_def = cx.tcx.hir().get_parent_did_by_hir_id(arg.hir_id);\n         let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n         if promotable {\n             return;\n@@ -1341,8 +1344,8 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n             if cx.tables.expr_ty(arg) == ty {\n                 snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             } else {\n-                let parent = cx.tcx.hir().get_parent_node(expr.id);\n-                match cx.tcx.hir().get(parent) {\n+                let parent = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+                match cx.tcx.hir().get_by_hir_id(parent) {\n                     hir::Node::Expr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n                         hir::ExprKind::AddrOf(..) |\n@@ -1545,7 +1548,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                     cx,\n                     UNNECESSARY_FOLD,\n                     fold_span,\n-                    // TODO #2371 don't suggest e.g. .any(|x| f(x)) if we can suggest .any(f)\n+                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n                     \"this `.fold` can be written more succinctly using another method\",\n                     \"try\",\n                     sugg,\n@@ -1769,48 +1772,6 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Ex\n     }\n }\n \n-/// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n-    // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n-        // get snippets for args to map() and unwrap_or()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n-        // lint message\n-        // comparing the snippet from source to raw text (\"None\") below is safe\n-        // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" {\n-            \"and_then(f)\"\n-        } else {\n-            \"map_or(a, f)\"\n-        };\n-        let msg = &format!(\n-            \"called `map(f).unwrap_or({})` on an Option value. \\\n-             This can be done more directly by calling `{}` instead\",\n-            arg, suggest\n-        );\n-        // lint, with note if neither arg is > 1 line and both map() and\n-        // unwrap_or() have the same span\n-        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n-        if same_span && !multiline {\n-            let suggest = if unwrap_snippet == \"None\" {\n-                format!(\"and_then({})\", map_snippet)\n-            } else {\n-                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n-            };\n-            let note = format!(\n-                \"replace `map({}).unwrap_or({})` with `{}`\",\n-                map_snippet, unwrap_snippet, suggest\n-            );\n-            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n-        } else if same_span && multiline {\n-            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-        };\n-    }\n-}\n-\n /// lint use of `map().flatten()` for `Iterators`\n fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n@@ -2237,47 +2198,23 @@ fn ty_has_iter_method(\n     cx: &LateContext<'_, '_>,\n     self_ref_ty: ty::Ty<'_>,\n ) -> Option<(&'static Lint, &'static str, &'static str)> {\n-    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n-    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n-    // so we can't use its `lookup_method` method.\n-    static INTO_ITER_COLLECTIONS: [(&Lint, &[&str]); 13] = [\n-        (INTO_ITER_ON_REF, &paths::VEC),\n-        (INTO_ITER_ON_REF, &paths::OPTION),\n-        (INTO_ITER_ON_REF, &paths::RESULT),\n-        (INTO_ITER_ON_REF, &paths::BTREESET),\n-        (INTO_ITER_ON_REF, &paths::BTREEMAP),\n-        (INTO_ITER_ON_REF, &paths::VEC_DEQUE),\n-        (INTO_ITER_ON_REF, &paths::LINKED_LIST),\n-        (INTO_ITER_ON_REF, &paths::BINARY_HEAP),\n-        (INTO_ITER_ON_REF, &paths::HASHSET),\n-        (INTO_ITER_ON_REF, &paths::HASHMAP),\n-        (INTO_ITER_ON_ARRAY, &[\"std\", \"path\", \"PathBuf\"]),\n-        (INTO_ITER_ON_REF, &[\"std\", \"path\", \"Path\"]),\n-        (INTO_ITER_ON_REF, &[\"std\", \"sync\", \"mpsc\", \"Receiver\"]),\n-    ];\n-\n-    let (self_ty, mutbl) = match self_ref_ty.sty {\n-        ty::Ref(_, self_ty, mutbl) => (self_ty, mutbl),\n-        _ => unreachable!(),\n-    };\n-    let method_name = match mutbl {\n-        hir::MutImmutable => \"iter\",\n-        hir::MutMutable => \"iter_mut\",\n-    };\n-\n-    let def_id = match self_ty.sty {\n-        ty::Array(..) => return Some((INTO_ITER_ON_ARRAY, \"array\", method_name)),\n-        ty::Slice(..) => return Some((INTO_ITER_ON_REF, \"slice\", method_name)),\n-        ty::Adt(adt, _) => adt.did,\n-        _ => return None,\n-    };\n-\n-    for (lint, path) in &INTO_ITER_COLLECTIONS {\n-        if match_def_path(cx.tcx, def_id, path) {\n-            return Some((lint, path.last().unwrap(), method_name));\n-        }\n+    if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n+        let lint = match ty_name {\n+            \"array\" | \"PathBuf\" => INTO_ITER_ON_ARRAY,\n+            _ => INTO_ITER_ON_REF,\n+        };\n+        let mutbl = match self_ref_ty.sty {\n+            ty::Ref(_, _, mutbl) => mutbl,\n+            _ => unreachable!(),\n+        };\n+        let method_name = match mutbl {\n+            hir::MutImmutable => \"iter\",\n+            hir::MutMutable => \"iter_mut\",\n+        };\n+        Some((lint, ty_name, method_name))\n+    } else {\n+        None\n     }\n-    None\n }\n \n fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::Ty<'_>, method_span: Span) {\n@@ -2413,7 +2350,7 @@ impl SelfKind {\n         // Self types in the HIR are desugared to explicit self types. So it will\n         // always be `self:\n         // SomeType`,\n-        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if\n+        // where SomeType can be `Self` or an explicit impl self type (e.g., `Foo` if\n         // the impl is on `Foo`)\n         // Thus, we only need to test equality against the impl self type or if it is\n         // an explicit"}, {"sha": "9a8880a7960a7778a5a42a180bdc24630a04be99", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::paths;\n+use crate::utils::{is_copy, match_type, snippet, span_lint, span_note_and_lint};\n+use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, *};\n+use rustc::lint::LateContext;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::symbol::Symbol;\n+\n+use super::OPTION_MAP_UNWRAP_OR;\n+\n+/// lint use of `map().unwrap_or()` for `Option`s\n+pub(super) fn lint<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr,\n+    map_args: &'tcx [hir::Expr],\n+    unwrap_args: &'tcx [hir::Expr],\n+) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n+        if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n+            // Do not lint if the `map` argument uses identifiers in the `map`\n+            // argument that are also used in the `unwrap_or` argument\n+\n+            let mut unwrap_visitor = UnwrapVisitor {\n+                cx,\n+                identifiers: FxHashSet::default(),\n+            };\n+            unwrap_visitor.visit_expr(&unwrap_args[1]);\n+\n+            let mut map_expr_visitor = MapExprVisitor {\n+                cx,\n+                identifiers: unwrap_visitor.identifiers,\n+                found_identifier: false,\n+            };\n+            map_expr_visitor.visit_expr(&map_args[1]);\n+\n+            if map_expr_visitor.found_identifier {\n+                return;\n+            }\n+        }\n+\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint message\n+        // comparing the snippet from source to raw text (\"None\") below is safe\n+        // because we already have checked the type.\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let suggest = if unwrap_snippet == \"None\" {\n+            \"and_then(f)\"\n+        } else {\n+            \"map_or(a, f)\"\n+        };\n+        let msg = &format!(\n+            \"called `map(f).unwrap_or({})` on an Option value. \\\n+             This can be done more directly by calling `{}` instead\",\n+            arg, suggest\n+        );\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let suggest = if unwrap_snippet == \"None\" {\n+                format!(\"and_then({})\", map_snippet)\n+            } else {\n+                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n+            };\n+            let note = format!(\n+                \"replace `map({}).unwrap_or({})` with `{}`\",\n+                map_snippet, unwrap_snippet, suggest\n+            );\n+            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n+        } else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}\n+\n+struct UnwrapVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    identifiers: FxHashSet<Symbol>,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrapVisitor<'a, 'tcx> {\n+    fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        self.identifiers.insert(ident(path));\n+        walk_path(self, path);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n+    }\n+}\n+\n+struct MapExprVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    identifiers: FxHashSet<Symbol>,\n+    found_identifier: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for MapExprVisitor<'a, 'tcx> {\n+    fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        if self.identifiers.contains(&ident(path)) {\n+            self.found_identifier = true;\n+            return;\n+        }\n+        walk_path(self, path);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n+    }\n+}\n+\n+fn ident(path: &Path) -> Symbol {\n+    path.segments\n+        .last()\n+        .expect(\"segments should be composed of at least 1 element\")\n+        .ident\n+        .name\n+}"}, {"sha": "c081384db4b82a320f7392b6cb3b143f6524df13", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,7 +5,6 @@ use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::LateContext;\n-use syntax::ast;\n \n use if_chain::if_chain;\n \n@@ -18,7 +17,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n \n     if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n         let body = cx.tcx.hir().body(body_id);\n-        let arg_id = body.arguments[0].pat.id;\n+        let arg_id = body.arguments[0].pat.hir_id;\n         let mutates_arg = match mutated_variables(&body.value, cx) {\n             Some(used_mutably) => used_mutably.contains(&arg_id),\n             None => true,\n@@ -56,7 +55,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n // returns (found_mapping, found_filtering)\n fn check_expression<'a, 'tcx: 'a>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     expr: &'tcx hir::Expr,\n ) -> (bool, bool) {\n     match &expr.node {\n@@ -69,7 +68,7 @@ fn check_expression<'a, 'tcx: 'a>(\n                             if let hir::ExprKind::Path(path) = &args[0].node;\n                             if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n                             then {\n-                                if arg_id == *local {\n+                                if arg_id == cx.tcx.hir().node_to_hir_id(*local) {\n                                     return (false, false)\n                                 }\n                             }\n@@ -113,15 +112,15 @@ fn check_expression<'a, 'tcx: 'a>(\n \n struct ReturnVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     // Found a non-None return that isn't Some(input)\n     found_mapping: bool,\n     // Found a return that isn't Some\n     found_filtering: bool,\n }\n \n impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n         ReturnVisitor {\n             cx,\n             arg_id,"}, {"sha": "8633458626a17e7517cfa08343859f522a7ccbb2", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,25 +1,25 @@\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n+use crate::utils::{match_def_path, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use std::cmp::Ordering;\n \n-/// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n-/// used to clamp values, but switched so that the result is constant.\n-///\n-/// **Why is this bad?** This is in all probability not the intended outcome. At\n-/// the least it hurts readability of the code.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// min(0, max(100, x))\n-/// ```\n-/// It will always be equal to `0`. Probably the author meant to clamp the value\n-/// between 0 and 100, but has erroneously swapped `min` and `max`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n+    /// used to clamp values, but switched so that the result is constant.\n+    ///\n+    /// **Why is this bad?** This is in all probability not the intended outcome. At\n+    /// the least it hurts readability of the code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// min(0, max(100, x))\n+    /// ```\n+    /// It will always be equal to `0`. Probably the author meant to clamp the value\n+    /// between 0 and 100, but has erroneously swapped `min` and `max`.\n     pub MIN_MAX,\n     correctness,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\"\n@@ -72,7 +72,7 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprKind::Call(ref path, ref args) = expr.node {\n         if let ExprKind::Path(ref qpath) = path.node {\n-            opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n+            cx.tables.qpath_def(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n                 if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)\n                 } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {"}, {"sha": "77aee50c6f872d2bb76200d3a3e85a441032010b", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 163, "deletions": 164, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,11 +1,3 @@\n-use crate::consts::{constant, Constant};\n-use crate::reexport::*;\n-use crate::utils::sugg::Sugg;\n-use crate::utils::{\n-    get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal, iter_input_pats,\n-    last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n-};\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir::intravisit::FnKind;\n@@ -17,208 +9,216 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::{ExpnFormat, Span};\n \n-/// **What it does:** Checks for function arguments and let bindings denoted as\n-/// `ref`.\n-///\n-/// **Why is this bad?** The `ref` declaration makes the function take an owned\n-/// value, but turns the argument into a reference (which means that the value\n-/// is destroyed when exiting the function). This adds not much value: either\n-/// take a reference type, or take an owned value and create references in the\n-/// body.\n-///\n-/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\n-/// type of `x` is more obvious with the former.\n-///\n-/// **Known problems:** If the argument is dereferenced within the function,\n-/// removing the `ref` will lead to errors. This can be fixed by removing the\n-/// dereferences, e.g. changing `*x` to `x` within the function.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(ref x: u8) -> bool {\n-///     ..\n-/// }\n-/// ```\n+use crate::consts::{constant, Constant};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal, iter_input_pats,\n+    last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n+    SpanlessEq,\n+};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments and let bindings denoted as\n+    /// `ref`.\n+    ///\n+    /// **Why is this bad?** The `ref` declaration makes the function take an owned\n+    /// value, but turns the argument into a reference (which means that the value\n+    /// is destroyed when exiting the function). This adds not much value: either\n+    /// take a reference type, or take an owned value and create references in the\n+    /// body.\n+    ///\n+    /// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\n+    /// type of `x` is more obvious with the former.\n+    ///\n+    /// **Known problems:** If the argument is dereferenced within the function,\n+    /// removing the `ref` will lead to errors. This can be fixed by removing the\n+    /// dereferences, e.g., changing `*x` to `x` within the function.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(ref x: u8) -> bool {\n+    ///     true\n+    /// }\n+    /// ```\n     pub TOPLEVEL_REF_ARG,\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n \n-/// **What it does:** Checks for comparisons to NaN.\n-///\n-/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n-/// even itself \u2013 so those comparisons are simply wrong.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == NAN\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons to NaN.\n+    ///\n+    /// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n+    /// even itself \u2013 so those comparisons are simply wrong.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x == NAN\n+    /// ```\n     pub CMP_NAN,\n     correctness,\n     \"comparisons to NAN, which will always return false, probably not intended\"\n }\n \n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// values (apart from zero), except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// y == 1.23f64\n-/// y != x  // where both are floats\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for (in-)equality comparisons on floating-point\n+    /// values (apart from zero), except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// **Why is this bad?** Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// y == 1.23f64\n+    /// y != x  // where both are floats\n+    /// ```\n     pub FLOAT_CMP,\n     correctness,\n     \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n }\n \n-/// **What it does:** Checks for conversions to owned values just for the sake\n-/// of a comparison.\n-///\n-/// **Why is this bad?** The comparison can operate on a reference, so creating\n-/// an owned value effectively throws it away directly afterwards, which is\n-/// needlessly consuming code and heap space.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.to_owned() == y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for conversions to owned values just for the sake\n+    /// of a comparison.\n+    ///\n+    /// **Why is this bad?** The comparison can operate on a reference, so creating\n+    /// an owned value effectively throws it away directly afterwards, which is\n+    /// needlessly consuming code and heap space.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.to_owned() == y\n+    /// ```\n     pub CMP_OWNED,\n     perf,\n-    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n+    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n }\n \n-/// **What it does:** Checks for getting the remainder of a division by one.\n-///\n-/// **Why is this bad?** The result can only ever be zero. No one will write\n-/// such code deliberately, unless trying to win an Underhanded Rust\n-/// Contest. Even for that contest, it's probably a bad idea. Use something more\n-/// underhanded.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x % 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for getting the remainder of a division by one.\n+    ///\n+    /// **Why is this bad?** The result can only ever be zero. No one will write\n+    /// such code deliberately, unless trying to win an Underhanded Rust\n+    /// Contest. Even for that contest, it's probably a bad idea. Use something more\n+    /// underhanded.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x % 1\n+    /// ```\n     pub MODULO_ONE,\n     correctness,\n     \"taking a number modulo 1, which always returns 0\"\n }\n \n-/// **What it does:** Checks for patterns in the form `name @ _`.\n-///\n-/// **Why is this bad?** It's almost always more readable to just use direct\n-/// bindings.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match v {\n-///     Some(x) => (),\n-///     y @ _ => (), // easier written as `y`,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns in the form `name @ _`.\n+    ///\n+    /// **Why is this bad?** It's almost always more readable to just use direct\n+    /// bindings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y @ _ => (), // easier written as `y`,\n+    /// }\n+    /// ```\n     pub REDUNDANT_PATTERN,\n     style,\n     \"using `name @ _` in a pattern\"\n }\n \n-/// **What it does:** Checks for the use of bindings with a single leading\n-/// underscore.\n-///\n-/// **Why is this bad?** A single leading underscore is usually used to indicate\n-/// that a binding will not be used. Using such a binding breaks this\n-/// expectation.\n-///\n-/// **Known problems:** The lint does not work properly with desugaring and\n-/// macro, it has been allowed in the mean time.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _x = 0;\n-/// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n-///                 // underscore. We should rename `_x` to `x`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of bindings with a single leading\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** A single leading underscore is usually used to indicate\n+    /// that a binding will not be used. Using such a binding breaks this\n+    /// expectation.\n+    ///\n+    /// **Known problems:** The lint does not work properly with desugaring and\n+    /// macro, it has been allowed in the mean time.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _x = 0;\n+    /// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n+    ///                 // underscore. We should rename `_x` to `x`\n+    /// ```\n     pub USED_UNDERSCORE_BINDING,\n     pedantic,\n     \"using a binding which is prefixed with an underscore\"\n }\n \n-/// **What it does:** Checks for the use of short circuit boolean conditions as\n-/// a\n-/// statement.\n-///\n-/// **Why is this bad?** Using a short circuit boolean condition as a statement\n-/// may hide the fact that the second part is executed or not depending on the\n-/// outcome of the first part.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// f() && g(); // We should write `if f() { g(); }`.\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of short circuit boolean conditions as\n+    /// a\n+    /// statement.\n+    ///\n+    /// **Why is this bad?** Using a short circuit boolean condition as a statement\n+    /// may hide the fact that the second part is executed or not depending on the\n+    /// outcome of the first part.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// f() && g(); // We should write `if f() { g(); }`.\n+    /// ```\n     pub SHORT_CIRCUIT_STATEMENT,\n     complexity,\n     \"using a short circuit boolean condition as a statement\"\n }\n \n-/// **What it does:** Catch casts from `0` to some pointer type\n-///\n-/// **Why is this bad?** This generally means `null` and is better expressed as\n-/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 0 as *const u32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Catch casts from `0` to some pointer type\n+    ///\n+    /// **Why is this bad?** This generally means `null` and is better expressed as\n+    /// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// 0 as *const u32\n+    /// ```\n     pub ZERO_PTR,\n     style,\n     \"using 0 as *{const, mut} T\"\n }\n \n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// value and constant, except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// const ONE = 1.00f64;\n-/// x == ONE  // where both are floats\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for (in-)equality comparisons on floating-point\n+    /// value and constant, except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// **Why is this bad?** Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// const ONE = 1.00f64;\n+    /// x == ONE  // where both are floats\n+    /// ```\n     pub FLOAT_CMP_CONST,\n     restriction,\n     \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n-    if !in_constant(cx, expr.id) {\n+    if !in_constant(cx, expr.hir_id) {\n         if let Some(seg) = path.segments.last() {\n             if seg.ident.name == \"NAN\" {\n                 span_lint(\n@@ -553,7 +553,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n         lint_span,\n         \"this creates an owned instance just for comparison\",\n         |db| {\n-            // this also catches PartialEq implementations that call to_owned\n+            // This also catches `PartialEq` implementations that call `to_owned`.\n             if other_gets_derefed {\n                 db.span_label(lint_span, \"try implementing the comparison without allocating\");\n                 return;\n@@ -591,9 +591,8 @@ fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     }\n }\n \n-/// Test whether an expression is in a macro expansion (e.g. something\n-/// generated by\n-/// `#[derive(...)`] or the like).\n+/// Tests whether an expression is in a macro expansion (e.g., something\n+/// generated by `#[derive(...)]` or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n     expr.span\n         .ctxt()\n@@ -602,7 +601,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n         .map_or(false, |info| matches!(info.format, ExpnFormat::MacroAttribute(_)))\n }\n \n-/// Test whether `def` is a variable defined outside a macro.\n+/// Tests whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir().span(id)),\n@@ -616,7 +615,7 @@ fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n         if let ExprKind::Lit(ref lit) = e.node;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n-        if !in_constant(cx, e.id);\n+        if !in_constant(cx, e.hir_id);\n         then {\n             let msg = match mutbl {\n                 Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\","}, {"sha": "3d41195f34969c624d03f3967964ea9c3293d867", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 116, "deletions": 115, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,163 +9,164 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::visit::{walk_expr, FnKind, Visitor};\n \n-/// **What it does:** Checks for structure field patterns bound to wildcards.\n-///\n-/// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n-/// the fields that are actually bound.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let { a: _, b: ref b, c: _ } = ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for structure field patterns bound to wildcards.\n+    ///\n+    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n+    /// the fields that are actually bound.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let { a: _, b: ref b, c: _ } = ..\n+    /// ```\n     pub UNNEEDED_FIELD_PATTERN,\n     style,\n     \"struct fields bound to a wildcard instead of using `..`\"\n }\n \n-/// **What it does:** Checks for function arguments having the similar names\n-/// differing by an underscore.\n-///\n-/// **Why is this bad?** It affects code readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(a: i32, _a: i32) {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments having the similar names\n+    /// differing by an underscore.\n+    ///\n+    /// **Why is this bad?** It affects code readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(a: i32, _a: i32) {}\n+    /// ```\n     pub DUPLICATE_UNDERSCORE_ARGUMENT,\n     style,\n     \"function arguments having names which only differ by an underscore\"\n }\n \n-/// **What it does:** Detects closures called in the same expression where they\n-/// are defined.\n-///\n-/// **Why is this bad?** It is unnecessarily adding to the expression's\n-/// complexity.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// (|| 42)()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects closures called in the same expression where they\n+    /// are defined.\n+    ///\n+    /// **Why is this bad?** It is unnecessarily adding to the expression's\n+    /// complexity.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// (|| 42)()\n+    /// ```\n     pub REDUNDANT_CLOSURE_CALL,\n     complexity,\n     \"throwaway closures called in the expression they are defined\"\n }\n \n-/// **What it does:** Detects expressions of the form `--x`.\n-///\n-/// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n-/// decremented.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// --x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects expressions of the form `--x`.\n+    ///\n+    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n+    /// decremented.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 3;\n+    /// --x;\n+    /// ```\n     pub DOUBLE_NEG,\n     style,\n     \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n }\n \n-/// **What it does:** Warns on hexadecimal literals with mixed-case letter\n-/// digits.\n-///\n-/// **Why is this bad?** It looks confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y = 0x1a9BAcD;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n+    /// digits.\n+    ///\n+    /// **Why is this bad?** It looks confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y = 0x1a9BAcD;\n+    /// ```\n     pub MIXED_CASE_HEX_LITERALS,\n     style,\n     \"hex literals whose letter digits are not consistently upper- or lowercased\"\n }\n \n-/// **What it does:** Warns if literal suffixes are not separated by an\n-/// underscore.\n-///\n-/// **Why is this bad?** It is much less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y = 123832i32;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if literal suffixes are not separated by an\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** It is much less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y = 123832i32;\n+    /// ```\n     pub UNSEPARATED_LITERAL_SUFFIX,\n     pedantic,\n     \"literals whose suffix is not separated by an underscore\"\n }\n \n-/// **What it does:** Warns if an integral constant literal starts with `0`.\n-///\n-/// **Why is this bad?** In some languages (including the infamous C language\n-/// and most of its\n-/// family), this marks an octal constant. In Rust however, this is a decimal\n-/// constant. This could\n-/// be confusing for both the writer and a reader of the constant.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// In Rust:\n-/// ```rust\n-/// fn main() {\n-///     let a = 0123;\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// prints `123`, while in C:\n-///\n-/// ```c\n-/// #include <stdio.h>\n-///\n-/// int main() {\n-///     int a = 0123;\n-///     printf(\"%d\\n\", a);\n-/// }\n-/// ```\n-///\n-/// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral constant literal starts with `0`.\n+    ///\n+    /// **Why is this bad?** In some languages (including the infamous C language\n+    /// and most of its\n+    /// family), this marks an octal constant. In Rust however, this is a decimal\n+    /// constant. This could\n+    /// be confusing for both the writer and a reader of the constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// In Rust:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let a = 0123;\n+    ///     println!(\"{}\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `123`, while in C:\n+    ///\n+    /// ```c\n+    /// #include <stdio.h>\n+    ///\n+    /// int main() {\n+    ///     int a = 0123;\n+    ///     printf(\"%d\\n\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n     pub ZERO_PREFIXED_LITERAL,\n     complexity,\n     \"integer literals starting with `0`\"\n }\n \n-/// **What it does:** Warns if a generic shadows a built-in type.\n-///\n-/// **Why is this bad?** This gives surprising type errors.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// impl<u32> Foo<u32> {\n-///     fn impl_func(&self) -> u32 {\n-///         42\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if a generic shadows a built-in type.\n+    ///\n+    /// **Why is this bad?** This gives surprising type errors.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// impl<u32> Foo<u32> {\n+    ///     fn impl_func(&self) -> u32 {\n+    ///         42\n+    ///     }\n+    /// }\n+    /// ```\n     pub BUILTIN_TYPE_SHADOW,\n     style,\n     \"shadowing a builtin type\"\n@@ -193,7 +194,7 @@ impl LintPass for MiscEarly {\n     }\n }\n \n-// Used to find `return` statements or equivalents e.g. `?`\n+// Used to find `return` statements or equivalents e.g., `?`\n struct ReturnVisitor {\n     found_return: bool,\n }"}, {"sha": "5bc949a6688adff8625961945e514363f92608ab", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,58 +1,57 @@\n-use crate::utils::{is_entrypoint_fn, span_lint};\n+use crate::utils::{is_entrypoint_fn, span_lint, trait_ref_of_method};\n use rustc::hir;\n use rustc::hir::intravisit::FnKind;\n-use rustc::hir::{Body, Constness, FnDecl};\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::hir::{Body, Constness, FnDecl, HirId};\n+use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_mir::transform::qualify_min_const_fn::is_min_const_fn;\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n \n-/// **What it does:**\n-///\n-/// Suggests the use of `const` in functions and methods where possible.\n-///\n-/// **Why is this bad?**\n-///\n-/// Not having the function const prevents callers of the function from being const as well.\n-///\n-/// **Known problems:**\n-///\n-/// Const functions are currently still being worked on, with some features only being available\n-/// on nightly. This lint does not consider all edge cases currently and the suggestions may be\n-/// incorrect if you are using this lint on stable.\n-///\n-/// Also, the lint only runs one pass over the code. Consider these two non-const functions:\n-///\n-/// ```rust\n-/// fn a() -> i32 {\n-///     0\n-/// }\n-/// fn b() -> i32 {\n-///     a()\n-/// }\n-/// ```\n-///\n-/// When running Clippy, the lint will only suggest to make `a` const, because `b` at this time\n-/// can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n-/// will suggest to make `b` const, too.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// fn new() -> Self {\n-///     Self { random_number: 42 }\n-/// }\n-/// ```\n-///\n-/// Could be a const fn:\n-///\n-/// ```rust\n-/// const fn new() -> Self {\n-///     Self { random_number: 42 }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:**\n+    ///\n+    /// Suggests the use of `const` in functions and methods where possible.\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// Not having the function const prevents callers of the function from being const as well.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// Const functions are currently still being worked on, with some features only being available\n+    /// on nightly. This lint does not consider all edge cases currently and the suggestions may be\n+    /// incorrect if you are using this lint on stable.\n+    ///\n+    /// Also, the lint only runs one pass over the code. Consider these two non-const functions:\n+    ///\n+    /// ```rust\n+    /// fn a() -> i32 {\n+    ///     0\n+    /// }\n+    /// fn b() -> i32 {\n+    ///     a()\n+    /// }\n+    /// ```\n+    ///\n+    /// When running Clippy, the lint will only suggest to make `a` const, because `b` at this time\n+    /// can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n+    /// will suggest to make `b` const, too.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn new() -> Self {\n+    ///     Self { random_number: 42 }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be a const fn:\n+    ///\n+    /// ```rust\n+    /// const fn new() -> Self {\n+    ///     Self { random_number: 42 }\n+    /// }\n+    /// ```\n     pub MISSING_CONST_FOR_FN,\n     nursery,\n     \"Lint functions definitions that could be made `const fn`\"\n@@ -79,11 +78,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n         _: &FnDecl,\n         _: &Body,\n         span: Span,\n-        node_id: NodeId,\n+        hir_id: HirId,\n     ) {\n-        let def_id = cx.tcx.hir().local_def_id(node_id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n \n-        if is_entrypoint_fn(cx, def_id) {\n+        if in_external_macro(cx.tcx.sess, span) || is_entrypoint_fn(cx, def_id) {\n             return;\n         }\n \n@@ -96,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n                 }\n             },\n             FnKind::Method(_, sig, ..) => {\n-                if already_const(sig.header) {\n+                if trait_ref_of_method(cx, hir_id).is_some() || already_const(sig.header) {\n                     return;\n                 }\n             },"}, {"sha": "d7e4dd221232600ccb0611b67bdb604a4eb6eab6", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -14,16 +14,16 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Span;\n \n-/// **What it does:** Warns if there is missing doc for any documentable item\n-/// (public or private).\n-///\n-/// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS`\n-/// allowed-by-default lint for\n-/// public members, but has no way to enforce documentation of private items.\n-/// This lint fixes that.\n-///\n-/// **Known problems:** None.\n declare_clippy_lint! {\n+    /// **What it does:** Warns if there is missing doc for any documentable item\n+    /// (public or private).\n+    ///\n+    /// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS`\n+    /// allowed-by-default lint for\n+    /// public members, but has no way to enforce documentation of private items.\n+    /// This lint fixes that.\n+    ///\n+    /// **Known problems:** None.\n     pub MISSING_DOCS_IN_PRIVATE_ITEMS,\n     restriction,\n     \"detects missing documentation for public and private members\"\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == \"main\" {\n-                    let def_id = cx.tcx.hir().local_def_id(it.id);\n+                    let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {"}, {"sha": "87bf3b5485fb49952d2c08554e2e55fb1001c82d", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,52 +5,52 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n use syntax::source_map::Span;\n \n-/// **What it does:** it lints if an exported function, method, trait method with default impl,\n-/// or trait method impl is not `#[inline]`.\n-///\n-/// **Why is this bad?** In general, it is not. Functions can be inlined across\n-/// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n-/// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n-/// might intend for most of the methods in their public API to be able to be inlined across\n-/// crates even when LTO is disabled. For these types of crates, enabling this lint might make\n-/// sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n-/// then opt out for specific methods where this might not make sense.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// pub fn foo() {} // missing #[inline]\n-/// fn ok() {} // ok\n-/// #[inline] pub fn bar() {} // ok\n-/// #[inline(always)] pub fn baz() {} // ok\n-///\n-/// pub trait Bar {\n-///   fn bar(); // ok\n-///   fn def_bar() {} // missing #[inline]\n-/// }\n-///\n-/// struct Baz;\n-/// impl Baz {\n-///    fn priv() {} // ok\n-/// }\n-///\n-/// impl Bar for Baz {\n-///   fn bar() {} // ok - Baz is not exported\n-/// }\n-///\n-/// pub struct PubBaz;\n-/// impl PubBaz {\n-///    fn priv() {} // ok\n-///    pub not_ptriv() {} // missing #[inline]\n-/// }\n-///\n-/// impl Bar for PubBaz {\n-///    fn bar() {} // missing #[inline]\n-///    fn def_bar() {} // missing #[inline]\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** it lints if an exported function, method, trait method with default impl,\n+    /// or trait method impl is not `#[inline]`.\n+    ///\n+    /// **Why is this bad?** In general, it is not. Functions can be inlined across\n+    /// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n+    /// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n+    /// might intend for most of the methods in their public API to be able to be inlined across\n+    /// crates even when LTO is disabled. For these types of crates, enabling this lint might make\n+    /// sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n+    /// then opt out for specific methods where this might not make sense.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo() {} // missing #[inline]\n+    /// fn ok() {} // ok\n+    /// #[inline] pub fn bar() {} // ok\n+    /// #[inline(always)] pub fn baz() {} // ok\n+    ///\n+    /// pub trait Bar {\n+    ///   fn bar(); // ok\n+    ///   fn def_bar() {} // missing #[inline]\n+    /// }\n+    ///\n+    /// struct Baz;\n+    /// impl Baz {\n+    ///    fn priv() {} // ok\n+    /// }\n+    ///\n+    /// impl Bar for Baz {\n+    ///   fn bar() {} // ok - Baz is not exported\n+    /// }\n+    ///\n+    /// pub struct PubBaz;\n+    /// impl PubBaz {\n+    ///    fn priv() {} // ok\n+    ///    pub not_ptriv() {} // missing #[inline]\n+    /// }\n+    ///\n+    /// impl Bar for PubBaz {\n+    ///    fn bar() {} // missing #[inline]\n+    ///    fn def_bar() {} // missing #[inline]\n+    /// }\n+    /// ```\n     pub MISSING_INLINE_IN_PUBLIC_ITEMS,\n     restriction,\n     \"detects missing #[inline] attribute for public callables (functions, trait methods, methods...)\"\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(it.hir_id)) {\n             return;\n         }\n         match it.node {\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir().expect_trait_item(tit.id.node_id);\n+                                let item = cx.tcx.hir().expect_trait_item(tit.id.hir_id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },\n@@ -146,7 +146,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.id) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(impl_item.hir_id);\n+        if !cx.access_levels.is_exported(node_id) {\n             return;\n         }\n \n@@ -155,7 +156,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) | hir::ImplItemKind::Existential(_) => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         let trait_def_id = match cx.tcx.associated_item(def_id).container {\n             TraitContainer(cid) => Some(cid),\n             ImplContainer(cid) => cx.tcx.impl_trait_ref(cid).map(|t| t.def_id),"}, {"sha": "68293f58cadd5bd451af95188e830a0e64382722", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,24 +8,24 @@ use syntax::{ast::*, source_map::DUMMY_SP};\n use cargo_metadata;\n use itertools::Itertools;\n \n-/// **What it does:** Checks to see if multiple versions of a crate are being\n-/// used.\n-///\n-/// **Why is this bad?** This bloats the size of targets, and can lead to\n-/// confusing error messages when structs or traits are used interchangeably\n-/// between different versions of a crate.\n-///\n-/// **Known problems:** Because this can be caused purely by the dependencies\n-/// themselves, it's not always possible to fix this issue.\n-///\n-/// **Example:**\n-/// ```toml\n-/// # This will pull in both winapi v0.3.4 and v0.2.8, triggering a warning.\n-/// [dependencies]\n-/// ctrlc = \"3.1.0\"\n-/// ansi_term = \"0.11.0\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks to see if multiple versions of a crate are being\n+    /// used.\n+    ///\n+    /// **Why is this bad?** This bloats the size of targets, and can lead to\n+    /// confusing error messages when structs or traits are used interchangeably\n+    /// between different versions of a crate.\n+    ///\n+    /// **Known problems:** Because this can be caused purely by the dependencies\n+    /// themselves, it's not always possible to fix this issue.\n+    ///\n+    /// **Example:**\n+    /// ```toml\n+    /// # This will pull in both winapi v0.3.4 and v0.2.8, triggering a warning.\n+    /// [dependencies]\n+    /// ctrlc = \"3.1.0\"\n+    /// ansi_term = \"0.11.0\"\n+    /// ```\n     pub MULTIPLE_CRATE_VERSIONS,\n     cargo,\n     \"multiple versions of the same crate being used\""}, {"sha": "f37f72135033737746c049de7c21436e68fb7d85", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,22 +5,22 @@ use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintC\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for instances of `mut mut` references.\n-///\n-/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the\n-/// source. This is either a copy'n'paste error, or it shows a fundamental\n-/// misunderstanding of references.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = &mut &mut y;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `mut mut` references.\n+    ///\n+    /// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the\n+    /// source. This is either a copy'n'paste error, or it shows a fundamental\n+    /// misunderstanding of references.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = &mut &mut y;\n+    /// ```\n     pub MUT_MUT,\n     pedantic,\n-    \"usage of double-mut refs, e.g. `&mut &mut ...`\"\n+    \"usage of double-mut refs, e.g., `&mut &mut ...`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "136fb8b55728f7d4e8bbe4af99749cd3d0d63a7b", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,19 +5,19 @@ use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Detects giving a mutable reference to a function that only\n-/// requires an immutable reference.\n-///\n-/// **Why is this bad?** The immutable reference rules out all other references\n-/// to the value. Also the code misleads about the intent of the call site.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// my_vec.push(&mut value)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects giving a mutable reference to a function that only\n+    /// requires an immutable reference.\n+    ///\n+    /// **Why is this bad?** The immutable reference rules out all other references\n+    /// to the value. Also the code misleads about the intent of the call site.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// my_vec.push(&mut value)\n+    /// ```\n     pub UNNECESSARY_MUT_PASSED,\n     style,\n     \"an argument passed as a mutable reference although the callee only demands an immutable reference\""}, {"sha": "6800e4295f5702b9449e50ab20aa97dd79454129", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,41 +9,41 @@ use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n \n-/// **What it does:** Checks for usages of `Mutex<X>` where an atomic will do.\n-///\n-/// **Why is this bad?** Using a mutex just to make access to a plain bool or\n-/// reference sequential is shooting flies with cannons.\n-/// `std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\n-/// faster.\n-///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used\n-/// for waiting before a critical section.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Mutex::new(&y);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `Mutex<X>` where an atomic will do.\n+    ///\n+    /// **Why is this bad?** Using a mutex just to make access to a plain bool or\n+    /// reference sequential is shooting flies with cannons.\n+    /// `std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\n+    /// faster.\n+    ///\n+    /// **Known problems:** This lint cannot detect if the mutex is actually used\n+    /// for waiting before a critical section.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Mutex::new(&y);\n+    /// ```\n     pub MUTEX_ATOMIC,\n     perf,\n     \"using a mutex where an atomic value could be used instead\"\n }\n \n-/// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral\n-/// type.\n-///\n-/// **Why is this bad?** Using a mutex just to make access to a plain integer\n-/// sequential is\n-/// shooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n-///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used\n-/// for waiting before a critical section.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Mutex::new(0usize);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral\n+    /// type.\n+    ///\n+    /// **Why is this bad?** Using a mutex just to make access to a plain integer\n+    /// sequential is\n+    /// shooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n+    ///\n+    /// **Known problems:** This lint cannot detect if the mutex is actually used\n+    /// for waiting before a critical section.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Mutex::new(0usize);\n+    /// ```\n     pub MUTEX_INTEGER,\n     nursery,\n     \"using a mutex for an integer type\""}, {"sha": "6e81ecac05fb4b33b4c668f168868af83648f62c", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -11,47 +11,47 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for expressions of the form `if c { true } else {\n-/// false }`\n-/// (or vice versa) and suggest using the condition directly.\n-///\n-/// **Why is this bad?** Redundant code.\n-///\n-/// **Known problems:** Maybe false positives: Sometimes, the two branches are\n-/// painstakingly documented (which we of course do not detect), so they *may*\n-/// have some value. Even then, the documentation can be rewritten to match the\n-/// shorter code.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x {\n-///     false\n-/// } else {\n-///     true\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions of the form `if c { true } else {\n+    /// false }`\n+    /// (or vice versa) and suggest using the condition directly.\n+    ///\n+    /// **Why is this bad?** Redundant code.\n+    ///\n+    /// **Known problems:** Maybe false positives: Sometimes, the two branches are\n+    /// painstakingly documented (which we of course do not detect), so they *may*\n+    /// have some value. Even then, the documentation can be rewritten to match the\n+    /// shorter code.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x {\n+    ///     false\n+    /// } else {\n+    ///     true\n+    /// }\n+    /// ```\n     pub NEEDLESS_BOOL,\n     complexity,\n-    \"if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\"\n+    \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\"\n }\n \n-/// **What it does:** Checks for expressions of the form `x == true`,\n-/// `x != true` and order comparisons such as `x < true` (or vice versa) and\n-/// suggest using the variable directly.\n-///\n-/// **Why is this bad?** Unnecessary code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x == true {} // could be `if x { }`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions of the form `x == true`,\n+    /// `x != true` and order comparisons such as `x < true` (or vice versa) and\n+    /// suggest using the variable directly.\n+    ///\n+    /// **Why is this bad?** Unnecessary code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x == true {} // could be `if x { }`\n+    /// ```\n     pub BOOL_COMPARISON,\n     complexity,\n-    \"comparing a variable to a boolean, e.g. `if x == true` or `if x != true`\"\n+    \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\"\n }\n \n #[derive(Copy, Clone)]\n@@ -126,8 +126,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n }\n \n fn parent_node_is_if_expr<'a, 'b>(expr: &Expr, cx: &LateContext<'a, 'b>) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_node(expr.id);\n-    let parent_node = cx.tcx.hir().get(parent_id);\n+    let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+    let parent_node = cx.tcx.hir().get_by_hir_id(parent_id);\n \n     if let rustc::hir::Node::Expr(e) = parent_node {\n         if let ExprKind::If(_, _, _) = e.node {\n@@ -225,23 +225,23 @@ fn check_comparison<'a, 'tcx>(\n     use self::Expression::*;\n \n     if let ExprKind::Binary(_, ref left_side, ref right_side) = e.node {\n-        let mut applicability = Applicability::MachineApplicable;\n-        match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-            (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n-            }),\n-            (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n-            }),\n-            (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n-            }),\n-            (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n-            }),\n-            (Other, Other) => no_literal.map_or((), |(h, m)| {\n-                let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n-                if l_ty.is_bool() && r_ty.is_bool() {\n+        let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n+        if l_ty.is_bool() && r_ty.is_bool() {\n+            let mut applicability = Applicability::MachineApplicable;\n+            match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n+                (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                }),\n+                (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                }),\n+                (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                }),\n+                (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                }),\n+                (Other, Other) => no_literal.map_or((), |(h, m)| {\n                     let left_side = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     let right_side = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n@@ -253,9 +253,9 @@ fn check_comparison<'a, 'tcx>(\n                         h(left_side, right_side).to_string(),\n                         applicability,\n                     )\n-                }\n-            }),\n-            _ => (),\n+                }),\n+                _ => (),\n+            }\n         }\n     }\n }"}, {"sha": "59b4095f61ec5b59d5a186c50d0a87a449ade654", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,35 +4,34 @@\n \n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n-use rustc::hir::{BindingAnnotation, Expr, ExprKind, Item, MutImmutable, Pat, PatKind};\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, HirId, Item, MutImmutable, Pat, PatKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::NodeId;\n \n-/// **What it does:** Checks for address of operations (`&`) that are going to\n-/// be dereferenced immediately by the compiler.\n-///\n-/// **Why is this bad?** Suggests that the receiver of the expression borrows\n-/// the expression.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: &i32 = &&&&&&5;\n-/// ```\n-///\n-/// **Known problems:** None.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for address of operations (`&`) that are going to\n+    /// be dereferenced immediately by the compiler.\n+    ///\n+    /// **Why is this bad?** Suggests that the receiver of the expression borrows\n+    /// the expression.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: &i32 = &&&&&&5;\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n     pub NEEDLESS_BORROW,\n     nursery,\n     \"taking a reference that is going to be automatically dereferenced\"\n }\n \n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<NodeId>,\n+    derived_item: Option<HirId>,\n }\n \n impl LintPass for NeedlessBorrow {\n@@ -119,13 +118,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if item.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n             debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.id);\n+            self.derived_item = Some(item.hir_id);\n         }\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let Some(id) = self.derived_item {\n-            if item.id == id {\n+            if item.hir_id == id {\n                 self.derived_item = None;\n             }\n         }"}, {"sha": "2c1f87c53e35596d44f3440dab069fe278ca83fe", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -9,43 +9,43 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for useless borrowed references.\n-///\n-/// **Why is this bad?** It is mostly useless and make the code look more\n-/// complex than it\n-/// actually is.\n-///\n-/// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n-/// For instance in the following snippet:\n-/// ```rust\n-/// enum Animal {\n-///     Cat(u64),\n-///     Dog(u64),\n-/// }\n-///\n-/// fn foo(a: &Animal, b: &Animal) {\n-///     match (a, b) {\n-/// (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\n-/// mismatch error\n-///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n-///     }\n-/// }\n-/// ```\n-/// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n-/// lifetime).\n-/// This can be fixed by using the `&ref` pattern.\n-/// However, the code can also be fixed by much cleaner ways\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut v = Vec::<String>::new();\n-/// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-/// ```\n-/// This closure takes a reference on something that has been matched as a\n-/// reference and\n-/// de-referenced.\n-/// As such, it could just be |a| a.is_empty()\n declare_clippy_lint! {\n+    /// **What it does:** Checks for useless borrowed references.\n+    ///\n+    /// **Why is this bad?** It is mostly useless and make the code look more\n+    /// complex than it\n+    /// actually is.\n+    ///\n+    /// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n+    /// For instance in the following snippet:\n+    /// ```rust\n+    /// enum Animal {\n+    ///     Cat(u64),\n+    ///     Dog(u64),\n+    /// }\n+    ///\n+    /// fn foo(a: &Animal, b: &Animal) {\n+    ///     match (a, b) {\n+    /// (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\n+    /// mismatch error\n+    ///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n+    ///     }\n+    /// }\n+    /// ```\n+    /// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n+    /// lifetime).\n+    /// This can be fixed by using the `&ref` pattern.\n+    /// However, the code can also be fixed by much cleaner ways\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut v = Vec::<String>::new();\n+    /// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n+    /// ```\n+    /// This closure takes a reference on something that has been matched as a\n+    /// reference and\n+    /// de-referenced.\n+    /// As such, it could just be |a| a.is_empty()\n     pub NEEDLESS_BORROWED_REFERENCE,\n     complexity,\n     \"taking a needless borrowed reference\""}, {"sha": "00394a9e1e2ba1e271704582e0ed79b702c36506", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -35,66 +35,66 @@ use syntax::source_map::{original_sp, DUMMY_SP};\n \n use crate::utils::{in_macro, snippet, snippet_block, span_help_and_lint, trim_multiline};\n \n-/// **What it does:** The lint checks for `if`-statements appearing in loops\n-/// that contain a `continue` statement in either their main blocks or their\n-/// `else`-blocks, when omitting the `else`-block possibly with some\n-/// rearrangement of code can make the code easier to understand.\n-///\n-/// **Why is this bad?** Having explicit `else` blocks for `if` statements\n-/// containing `continue` in their THEN branch adds unnecessary branching and\n-/// nesting to the code. Having an else block containing just `continue` can\n-/// also be better written by grouping the statements following the whole `if`\n-/// statement within the THEN block and omitting the else block completely.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// while condition() {\n-///     update_condition();\n-///     if x {\n-///         // ...\n-///     } else {\n-///         continue;\n-///     }\n-///     println!(\"Hello, world\");\n-/// }\n-/// ```\n-///\n-/// Could be rewritten as\n-///\n-/// ```rust\n-/// while condition() {\n-///     update_condition();\n-///     if x {\n-///         // ...\n-///         println!(\"Hello, world\");\n-///     }\n-/// }\n-/// ```\n-///\n-/// As another example, the following code\n-///\n-/// ```rust\n-/// loop {\n-///     if waiting() {\n-///         continue;\n-///     } else {\n-///         // Do something useful\n-///     }\n-/// }\n-/// ```\n-/// Could be rewritten as\n-///\n-/// ```rust\n-/// loop {\n-///     if waiting() {\n-///         continue;\n-///     }\n-///     // Do something useful\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** The lint checks for `if`-statements appearing in loops\n+    /// that contain a `continue` statement in either their main blocks or their\n+    /// `else`-blocks, when omitting the `else`-block possibly with some\n+    /// rearrangement of code can make the code easier to understand.\n+    ///\n+    /// **Why is this bad?** Having explicit `else` blocks for `if` statements\n+    /// containing `continue` in their THEN branch adds unnecessary branching and\n+    /// nesting to the code. Having an else block containing just `continue` can\n+    /// also be better written by grouping the statements following the whole `if`\n+    /// statement within the THEN block and omitting the else block completely.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// while condition() {\n+    ///     update_condition();\n+    ///     if x {\n+    ///         // ...\n+    ///     } else {\n+    ///         continue;\n+    ///     }\n+    ///     println!(\"Hello, world\");\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be rewritten as\n+    ///\n+    /// ```rust\n+    /// while condition() {\n+    ///     update_condition();\n+    ///     if x {\n+    ///         // ...\n+    ///         println!(\"Hello, world\");\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// As another example, the following code\n+    ///\n+    /// ```rust\n+    /// loop {\n+    ///     if waiting() {\n+    ///         continue;\n+    ///     } else {\n+    ///         // Do something useful\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Could be rewritten as\n+    ///\n+    /// ```rust\n+    /// loop {\n+    ///     if waiting() {\n+    ///         continue;\n+    ///     }\n+    ///     // Do something useful\n+    /// }\n+    /// ```\n     pub NEEDLESS_CONTINUE,\n     pedantic,\n     \"`continue` statements that can be replaced by a rearrangement of code\""}, {"sha": "15d378bdd7f9e2096609baf9213a329a0bbb1f23", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -17,34 +17,33 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use std::borrow::Cow;\n-use syntax::ast::NodeId;\n use syntax::errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for functions taking arguments by value, but not\n-/// consuming them in its\n-/// body.\n-///\n-/// **Why is this bad?** Taking arguments by reference is more flexible and can\n-/// sometimes avoid\n-/// unnecessary allocations.\n-///\n-/// **Known problems:**\n-/// * This lint suggests taking an argument by reference,\n-/// however sometimes it is better to let users decide the argument type\n-/// (by using `Borrow` trait, for example), depending on how the function is used.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(v: Vec<i32>) {\n-///     assert_eq!(v.len(), 42);\n-/// }\n-/// // should be\n-/// fn foo(v: &[i32]) {\n-///     assert_eq!(v.len(), 42);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by value, but not\n+    /// consuming them in its\n+    /// body.\n+    ///\n+    /// **Why is this bad?** Taking arguments by reference is more flexible and can\n+    /// sometimes avoid\n+    /// unnecessary allocations.\n+    ///\n+    /// **Known problems:**\n+    /// * This lint suggests taking an argument by reference,\n+    /// however sometimes it is better to let users decide the argument type\n+    /// (by using `Borrow` trait, for example), depending on how the function is used.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(v: Vec<i32>) {\n+    ///     assert_eq!(v.len(), 42);\n+    /// }\n+    /// // should be\n+    /// fn foo(v: &[i32]) {\n+    ///     assert_eq!(v.len(), 42);\n+    /// }\n+    /// ```\n     pub NEEDLESS_PASS_BY_VALUE,\n     pedantic,\n     \"functions taking arguments by value, but not consuming them in its body\"\n@@ -81,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        node_id: NodeId,\n+        hir_id: HirId,\n     ) {\n         if in_macro(span) {\n             return;\n@@ -103,7 +102,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(node_id)) {\n+        if let Some(Node::Item(item)) = cx\n+            .tcx\n+            .hir()\n+            .find_by_hir_id(cx.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n@@ -122,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n-        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n             .filter(|p| !p.is_global())\n@@ -173,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n             //\n             // * Exclude a type that is specifically bounded by `Borrow`.\n-            // * Exclude a type whose reference also fulfills its bound. (e.g. `std::convert::AsRef`,\n+            // * Exclude a type whose reference also fulfills its bound. (e.g., `std::convert::AsRef`,\n             //   `serde::Serialize`)\n             let (implements_borrow_trait, all_borrowable_trait) = {\n                 let preds = preds\n@@ -322,10 +325,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    moved_vars: FxHashSet<NodeId>,\n+    moved_vars: FxHashSet<HirId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional reference.\n-    spans_need_deref: FxHashMap<NodeId, FxHashSet<Span>>,\n+    spans_need_deref: FxHashMap<HirId, FxHashSet<Span>>,\n }\n \n impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n@@ -337,7 +340,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: &mc::cmt_<'tcx>) {\n+    fn move_common(&mut self, _consume_id: HirId, _span: Span, cmt: &mc::cmt_<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n@@ -349,16 +352,16 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n-            let mut id = matched_pat.id;\n+            let mut id = matched_pat.hir_id;\n             loop {\n-                let parent = self.cx.tcx.hir().get_parent_node(id);\n+                let parent = self.cx.tcx.hir().get_parent_node_by_hir_id(id);\n                 if id == parent {\n                     // no parent\n                     return;\n                 }\n                 id = parent;\n \n-                if let Some(node) = self.cx.tcx.hir().find(id) {\n+                if let Some(node) = self.cx.tcx.hir().find_by_hir_id(id) {\n                     match node {\n                         Node::Expr(e) => {\n                             // `match` and `if let`\n@@ -395,29 +398,29 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n-    fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, consume_id: HirId, consume_span: Span, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);\n         }\n     }\n \n     fn matched_pat(&mut self, matched_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::MatchMode) {\n         if let euv::MatchMode::MovingMatch = mode {\n-            self.move_common(matched_pat.id, matched_pat.span, cmt);\n+            self.move_common(matched_pat.hir_id, matched_pat.span, cmt);\n         } else {\n             self.non_moving_pat(matched_pat, cmt);\n         }\n     }\n \n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n-            self.move_common(consume_pat.id, consume_pat.span, cmt);\n+            self.move_common(consume_pat.hir_id, consume_pat.span, cmt);\n         }\n     }\n \n     fn borrow(\n         &mut self,\n-        _: NodeId,\n+        _: HirId,\n         _: Span,\n         _: &mc::cmt_<'tcx>,\n         _: ty::Region<'_>,\n@@ -426,9 +429,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n     ) {\n     }\n \n-    fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n+    fn mutate(&mut self, _: HirId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {"}, {"sha": "2ce9bf78aa6c40248a3774afcf5bfdbc6e76ed6d", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,23 +4,23 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for needlessly including a base struct on update\n-/// when all fields are changed anyway.\n-///\n-/// **Why is this bad?** This will cost resources (because the base has to be\n-/// somewhere), and make the code less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Point {\n-///     x: 1,\n-///     y: 0,\n-///     ..zero_point\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for needlessly including a base struct on update\n+    /// when all fields are changed anyway.\n+    ///\n+    /// **Why is this bad?** This will cost resources (because the base has to be\n+    /// somewhere), and make the code less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// Point {\n+    ///     x: 1,\n+    ///     y: 0,\n+    ///     ..zero_point\n+    /// }\n+    /// ```\n     pub NEEDLESS_UPDATE,\n     complexity,\n     \"using `Foo { ..base }` when there are no missing fields\""}, {"sha": "7b074f438f4bdd573d62b018b11ade14d6670cb7", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,38 +5,38 @@ use rustc::{declare_tool_lint, lint_array};\n \n use crate::utils::{self, paths, span_lint};\n \n-/// **What it does:**\n-/// Checks for the usage of negated comparison operators on types which only implement\n-/// `PartialOrd` (e.g. `f64`).\n-///\n-/// **Why is this bad?**\n-/// These operators make it easy to forget that the underlying types actually allow not only three\n-/// potential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\n-/// especially easy to miss if the operator based comparison result is negated.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// use std::cmp::Ordering;\n-///\n-/// // Bad\n-/// let a = 1.0;\n-/// let b = std::f64::NAN;\n-///\n-/// let _not_less_or_equal = !(a <= b);\n-///\n-/// // Good\n-/// let a = 1.0;\n-/// let b = std::f64::NAN;\n-///\n-/// let _not_less_or_equal = match a.partial_cmp(&b) {\n-///     None | Some(Ordering::Greater) => true,\n-///     _ => false,\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for the usage of negated comparison operators on types which only implement\n+    /// `PartialOrd` (e.g., `f64`).\n+    ///\n+    /// **Why is this bad?**\n+    /// These operators make it easy to forget that the underlying types actually allow not only three\n+    /// potential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\n+    /// especially easy to miss if the operator based comparison result is negated.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// // Bad\n+    /// let a = 1.0;\n+    /// let b = std::f64::NAN;\n+    ///\n+    /// let _not_less_or_equal = !(a <= b);\n+    ///\n+    /// // Good\n+    /// let a = 1.0;\n+    /// let b = std::f64::NAN;\n+    ///\n+    /// let _not_less_or_equal = match a.partial_cmp(&b) {\n+    ///     None | Some(Ordering::Greater) => true,\n+    ///     _ => false,\n+    /// };\n+    /// ```\n     pub NEG_CMP_OP_ON_PARTIAL_ORD,\n     complexity,\n     \"The use of negated comparison operators on partially ordered types may produce confusing code.\""}, {"sha": "757a3cb6cd5b6c6924a804b137048692c9680c0b", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,17 +7,17 @@ use syntax::source_map::{Span, Spanned};\n use crate::consts::{self, Constant};\n use crate::utils::span_lint;\n \n-/// **What it does:** Checks for multiplication by -1 as a form of negation.\n-///\n-/// **Why is this bad?** It's more readable to just negate.\n-///\n-/// **Known problems:** This only catches integers (for now).\n-///\n-/// **Example:**\n-/// ```rust\n-/// x * -1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for multiplication by -1 as a form of negation.\n+    ///\n+    /// **Why is this bad?** It's more readable to just negate.\n+    ///\n+    /// **Known problems:** This only catches integers (for now).\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// x * -1\n+    /// ```\n     pub NEG_MULTIPLY,\n     style,\n     \"multiplying integers with -1\""}, {"sha": "701cfe20590431ecdfd8a8b598b40b572b5c9d72", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -11,74 +11,74 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for types with a `fn new() -> Self` method and no\n-/// implementation of\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n-///\n-/// It detects both the case when a manual\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// implementation is required and also when it can be created with\n-/// `#[derive(Default)]`\n-///\n-/// **Why is this bad?** The user might expect to be able to use\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n-/// type can be constructed without arguments.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// struct Foo(Bar);\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo(Bar::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead, use:\n-///\n-/// ```rust\n-/// struct Foo(Bar);\n-///\n-/// impl Default for Foo {\n-///     fn default() -> Self {\n-///         Foo(Bar::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// Or, if\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// can be derived by `#[derive(Default)]`:\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead, use:\n-///\n-/// ```rust\n-/// #[derive(Default)]\n-/// struct Foo;\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo\n-///     }\n-/// }\n-/// ```\n-///\n-/// You can also have `new()` call `Default::default()`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n+    /// implementation of\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n+    ///\n+    /// It detects both the case when a manual\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+    /// implementation is required and also when it can be created with\n+    /// `#[derive(Default)]`\n+    ///\n+    /// **Why is this bad?** The user might expect to be able to use\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n+    /// type can be constructed without arguments.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// struct Foo(Bar);\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo(Bar::new())\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead, use:\n+    ///\n+    /// ```ignore\n+    /// struct Foo(Bar);\n+    ///\n+    /// impl Default for Foo {\n+    ///     fn default() -> Self {\n+    ///         Foo(Bar::new())\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Or, if\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+    /// can be derived by `#[derive(Default)]`:\n+    ///\n+    /// ```rust\n+    /// struct Foo;\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead, use:\n+    ///\n+    /// ```rust\n+    /// #[derive(Default)]\n+    /// struct Foo;\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// You can also have `new()` call `Default::default()`.\n     pub NEW_WITHOUT_DEFAULT,\n     style,\n     \"`fn new() -> Self` method without `Default` implementation\"\n@@ -110,7 +110,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                     }\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         let name = impl_item.ident.name;\n-                        let id = impl_item.id;\n+                        let id = impl_item.hir_id;\n+                        let node_id = cx.tcx.hir().hir_to_node_id(id);\n                         if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;\n@@ -128,8 +129,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n-                            let self_did = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent(id));\n+                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(node_id) {\n+                            let self_did = cx.tcx.hir().local_def_id_from_hir_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));"}, {"sha": "dae59bc84b9525e38fbba9f8bd8094fa754ddca3", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,37 +6,37 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::ops::Deref;\n \n-/// **What it does:** Checks for statements which have no effect.\n-///\n-/// **Why is this bad?** Similar to dead code, these statements are actually\n-/// executed. However, as they have no effect, all they do is make the code less\n-/// readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for statements which have no effect.\n+    ///\n+    /// **Why is this bad?** Similar to dead code, these statements are actually\n+    /// executed. However, as they have no effect, all they do is make the code less\n+    /// readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 0;\n+    /// ```\n     pub NO_EFFECT,\n     complexity,\n     \"statements with no effect\"\n }\n \n-/// **What it does:** Checks for expression statements that can be reduced to a\n-/// sub-expression.\n-///\n-/// **Why is this bad?** Expressions by themselves often have no side-effects.\n-/// Having such expressions reduces readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// compute_array()[0];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expression statements that can be reduced to a\n+    /// sub-expression.\n+    ///\n+    /// **Why is this bad?** Expressions by themselves often have no side-effects.\n+    /// Having such expressions reduces readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// compute_array()[0];\n+    /// ```\n     pub UNNECESSARY_OPERATION,\n     complexity,\n     \"outer expressions with no effect\""}, {"sha": "9c184e8c54b28edb7e11334dfdef4535ae0abcfb", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,8 +1,9 @@\n-//! Checks for uses of const which the type is not Freeze (Cell-free).\n+//! Checks for uses of const which the type is not `Freeze` (`Cell`-free).\n //!\n //! This lint is **deny** by default.\n \n-use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+use std::ptr;\n+\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n@@ -11,72 +12,73 @@ use rustc::ty::{self, TypeFlags};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;\n-use std::ptr;\n use syntax_pos::{Span, DUMMY_SP};\n \n-/// **What it does:** Checks for declaration of `const` items which is interior\n-/// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n-///\n-/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n-/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-/// these types in the first place.\n-///\n-/// The `const` should better be replaced by a `static` item if a global\n-/// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n-///\n-/// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n-/// initialized value to downstream `static` items (e.g. the\n-/// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n-/// and this lint should be suppressed.\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-///\n-/// // Bad.\n-/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-///\n-/// // Good.\n-/// static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n-/// STATIC_ATOM.store(9, SeqCst);\n-/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-/// ```\n+use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for declaration of `const` items which is interior\n+    /// mutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n+    ///\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.,\n+    /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+    /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+    /// these types in the first place.\n+    ///\n+    /// The `const` should better be replaced by a `static` item if a global\n+    /// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n+    ///\n+    /// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n+    /// initialized value to downstream `static` items (e.g., the\n+    /// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n+    /// and this lint should be suppressed.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    ///\n+    /// // Bad.\n+    /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+    /// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+    /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+    ///\n+    /// // Good.\n+    /// static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n+    /// STATIC_ATOM.store(9, SeqCst);\n+    /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+    /// ```\n     pub DECLARE_INTERIOR_MUTABLE_CONST,\n     correctness,\n     \"declaring const with interior mutability\"\n }\n \n-/// **What it does:** Checks if `const` items which is interior mutable (e.g.\n-/// contains a `Cell`, `Mutex`, `AtomicXxxx` etc) has been borrowed directly.\n-///\n-/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n-/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-/// these types in the first place.\n-///\n-/// The `const` value should be stored inside a `static` item.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-///\n-/// // Bad.\n-/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-///\n-/// // Good.\n-/// static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n-/// STATIC_ATOM.store(9, SeqCst);\n-/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks if `const` items which is interior mutable (e.g.,\n+    /// contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n+    ///\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.,\n+    /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+    /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+    /// these types in the first place.\n+    ///\n+    /// The `const` value should be stored inside a `static` item.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+    ///\n+    /// // Bad.\n+    /// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+    /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+    ///\n+    /// // Good.\n+    /// static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n+    /// STATIC_ATOM.store(9, SeqCst);\n+    /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+    /// ```\n     pub BORROW_INTERIOR_MUTABLE_CONST,\n     correctness,\n     \"referencing const with interior mutability\"\n@@ -108,8 +110,8 @@ impl Source {\n \n fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n-        // an UnsafeCell is !Copy, and an UnsafeCell is also the only type which\n-        // is !Freeze, thus if our type is Copy we can be sure it must be Freeze\n+        // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n+        // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n         // as well.\n         return;\n     }\n@@ -177,9 +179,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n-            let item_node_id = cx.tcx.hir().get_parent_node(impl_item.id);\n-            let item = cx.tcx.hir().expect_item(item_node_id);\n-            // ensure the impl is an inherent impl.\n+            let item_hir_id = cx.tcx.hir().get_parent_node_by_hir_id(impl_item.hir_id);\n+            let item = cx.tcx.hir().expect_item_by_hir_id(item_hir_id);\n+            // Ensure the impl is an inherent impl.\n             if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                 verify_ty_bound(\n@@ -197,29 +199,29 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Path(qpath) = &expr.node {\n             // Only lint if we use the const item inside a function.\n-            if in_constant(cx, expr.id) {\n+            if in_constant(cx, expr.hir_id) {\n                 return;\n             }\n \n-            // make sure it is a const item.\n+            // Make sure it is a const item.\n             match cx.tables.qpath_def(qpath, expr.hir_id) {\n                 Def::Const(_) | Def::AssociatedConst(_) => {},\n                 _ => return,\n             };\n \n-            // climb up to resolve any field access and explicit referencing.\n+            // Climb up to resolve any field access and explicit referencing.\n             let mut cur_expr = expr;\n             let mut dereferenced_expr = expr;\n             let mut needs_check_adjustment = true;\n             loop {\n-                let parent_id = cx.tcx.hir().get_parent_node(cur_expr.id);\n-                if parent_id == cur_expr.id {\n+                let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(cur_expr.hir_id);\n+                if parent_id == cur_expr.hir_id {\n                     break;\n                 }\n-                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find(parent_id) {\n+                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find_by_hir_id(parent_id) {\n                     match &parent_expr.node {\n                         ExprKind::AddrOf(..) => {\n-                            // `&e` => `e` must be referenced\n+                            // `&e` => `e` must be referenced.\n                             needs_check_adjustment = false;\n                         },\n                         ExprKind::Field(..) => {\n@@ -260,7 +262,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                         adjustments[i - 1].target\n                     }\n                 } else {\n-                    // No borrow adjustments = the entire const is moved.\n+                    // No borrow adjustments means the entire const is moved.\n                     return;\n                 }\n             } else {"}, {"sha": "7bdeec0a56f0ee0fc53951b92267d12fa9ab9023", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,57 +7,57 @@ use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n use syntax::visit::{walk_block, walk_expr, walk_pat, Visitor};\n \n-/// **What it does:** Checks for names that are very similar and thus confusing.\n-///\n-/// **Why is this bad?** It's hard to distinguish between names that differ only\n-/// by a single character.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let checked_exp = something;\n-/// let checked_expr = something_else;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for names that are very similar and thus confusing.\n+    ///\n+    /// **Why is this bad?** It's hard to distinguish between names that differ only\n+    /// by a single character.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let checked_exp = something;\n+    /// let checked_expr = something_else;\n+    /// ```\n     pub SIMILAR_NAMES,\n     pedantic,\n     \"similarly named items and bindings\"\n }\n \n-/// **What it does:** Checks for too many variables whose name consists of a\n-/// single character.\n-///\n-/// **Why is this bad?** It's hard to memorize what a variable means without a\n-/// descriptive name.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let (a, b, c, d, e, f, g) = (...);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for too many variables whose name consists of a\n+    /// single character.\n+    ///\n+    /// **Why is this bad?** It's hard to memorize what a variable means without a\n+    /// descriptive name.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let (a, b, c, d, e, f, g) = (...);\n+    /// ```\n     pub MANY_SINGLE_CHAR_NAMES,\n     style,\n     \"too many single character bindings\"\n }\n \n-/// **What it does:** Checks if you have variables whose name consists of just\n-/// underscores and digits.\n-///\n-/// **Why is this bad?** It's hard to memorize what a variable means without a\n-/// descriptive name.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _1 = 1;\n-/// let ___1 = 1;\n-/// let __1___2 = 11;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks if you have variables whose name consists of just\n+    /// underscores and digits.\n+    ///\n+    /// **Why is this bad?** It's hard to memorize what a variable means without a\n+    /// descriptive name.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _1 = 1;\n+    /// let ___1 = 1;\n+    /// let __1___2 = 11;\n+    /// ```\n     pub JUST_UNDERSCORES_AND_DIGITS,\n     style,\n     \"unclear name\""}, {"sha": "11c392b581ad5975537fc4a40a689896a4a7b514", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,31 +4,31 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:*** Checks for unnecessary `ok()` in if let.\n-///\n-/// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n-/// on `Ok(pat)`\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for result in iter {\n-///     if let Some(bench) = try!(result).parse().ok() {\n-///         vec.push(bench)\n-///     }\n-/// }\n-/// ```\n-/// Could be written:\n-///\n-/// ```rust\n-/// for result in iter {\n-///     if let Ok(bench) = try!(result).parse() {\n-///         vec.push(bench)\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:*** Checks for unnecessary `ok()` in if let.\n+    ///\n+    /// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n+    /// on `Ok(pat)`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for result in iter {\n+    ///     if let Some(bench) = try!(result).parse().ok() {\n+    ///         vec.push(bench)\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```ignore\n+    /// for result in iter {\n+    ///     if let Ok(bench) = try!(result).parse() {\n+    ///         vec.push(bench)\n+    ///     }\n+    /// }\n+    /// ```\n     pub IF_LET_SOME_RESULT,\n     style,\n     \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\""}, {"sha": "43c7f3884d3a220fcc4ce67148aa2e2a9c44aa00", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,19 +5,21 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::LitKind;\n use syntax::source_map::{Span, Spanned};\n \n-/// **What it does:** Checks for duplicate open options as well as combinations\n-/// that make no sense.\n-///\n-/// **Why is this bad?** In the best case, the code will be harder to read than\n-/// necessary. I don't know the worst case.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// OpenOptions::new().read(true).truncate(true)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for duplicate open options as well as combinations\n+    /// that make no sense.\n+    ///\n+    /// **Why is this bad?** In the best case, the code will be harder to read than\n+    /// necessary. I don't know the worst case.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// OpenOptions::new().read(true).truncate(true);\n+    /// ```\n     pub NONSENSICAL_OPEN_OPTIONS,\n     correctness,\n     \"nonsensical combination of options for opening a file\""}, {"sha": "c041f3a959a021a6d8a5f479c2b3b323e767d193", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,18 +4,18 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Detects classic underflow/overflow checks.\n-///\n-/// **Why is this bad?** Most classic C underflow/overflow checks will fail in\n-/// Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + b < a\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects classic underflow/overflow checks.\n+    ///\n+    /// **Why is this bad?** Most classic C underflow/overflow checks will fail in\n+    /// Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + b < a\n+    /// ```\n     pub OVERFLOW_CHECK_CONDITIONAL,\n     complexity,\n     \"overflow checks inspired by C which are likely to panic\""}, {"sha": "66624a066751bc735b5a1e630f7f544b224a3256", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, opt_def_id, paths, resolve_node, span_lint};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, paths, resolve_node, span_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -7,36 +7,36 @@ use syntax::ast::LitKind;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for missing parameters in `panic!`.\n-///\n-/// **Why is this bad?** Contrary to the `format!` family of macros, there are\n-/// two forms of `panic!`: if there are no parameters given, the first argument\n-/// is not a format string and used literally. So while `format!(\"{}\")` will\n-/// fail to compile, `panic!(\"{}\")` will not.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for missing parameters in `panic!`.\n+    ///\n+    /// **Why is this bad?** Contrary to the `format!` family of macros, there are\n+    /// two forms of `panic!`: if there are no parameters given, the first argument\n+    /// is not a format string and used literally. So while `format!(\"{}\")` will\n+    /// fail to compile, `panic!(\"{}\")` will not.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n+    /// ```\n     pub PANIC_PARAMS,\n     style,\n     \"missing parameters in `panic!` calls\"\n }\n \n-/// **What it does:** Checks for usage of `unimplemented!`.\n-///\n-/// **Why is this bad?** This macro should not be present in production code\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// unimplemented!();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `unimplemented!`.\n+    ///\n+    /// **Why is this bad?** This macro should not be present in production code\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// unimplemented!();\n+    /// ```\n     pub UNIMPLEMENTED,\n     restriction,\n     \"`unimplemented!` should not be present in production code\"\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let Some(ref ex) = block.expr;\n             if let ExprKind::Call(ref fun, ref params) = ex.node;\n             if let ExprKind::Path(ref qpath) = fun.node;\n-            if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+            if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n             if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n             then {"}, {"sha": "47495fde24a3d657e568c0a422222c2061cb6ff6", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,25 +4,25 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n-///\n-/// **Why is this bad?** `PartialEq::ne` is required to always return the\n-/// negated result of `PartialEq::eq`, which is exactly what the default\n-/// implementation does. Therefore, there should never be any need to\n-/// re-implement it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl PartialEq for Foo {\n-///    fn eq(&self, other: &Foo) -> bool { ... }\n-///    fn ne(&self, other: &Foo) -> bool { !(self == other) }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n+    ///\n+    /// **Why is this bad?** `PartialEq::ne` is required to always return the\n+    /// negated result of `PartialEq::eq`, which is exactly what the default\n+    /// implementation does. Therefore, there should never be any need to\n+    /// re-implement it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo;\n+    ///\n+    /// impl PartialEq for Foo {\n+    ///    fn eq(&self, other: &Foo) -> bool { ... }\n+    ///    fn ne(&self, other: &Foo) -> bool { !(self == other) }\n+    /// }\n+    /// ```\n     pub PARTIALEQ_NE_IMPL,\n     complexity,\n     \"re-implementing `PartialEq::ne`\"\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         span_lint_node(\n                             cx,\n                             PARTIALEQ_NE_IMPL,\n-                            impl_item.id.node_id,\n+                            impl_item.id.hir_id,\n                             impl_item.span,\n                             \"re-implementing `PartialEq::ne` is unnecessary\",\n                         );"}, {"sha": "6819ac74474434e7b899677f38f07d2bcd113944", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,24 +5,24 @@ use rustc_errors::Applicability;\n use syntax::ast::*;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for operations where precedence may be unclear\n-/// and suggests to add parentheses. Currently it catches the following:\n-/// * mixed usage of arithmetic and bit shifting/combining operators without\n-/// parentheses\n-/// * a \"negative\" numeric literal (which is really a unary `-` followed by a\n-/// numeric literal)\n-///   followed by a method call\n-///\n-/// **Why is this bad?** Not everyone knows the precedence of those operators by\n-/// heart, so expressions like these may trip others trying to reason about the\n-/// code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n-/// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n declare_clippy_lint! {\n+    /// **What it does:** Checks for operations where precedence may be unclear\n+    /// and suggests to add parentheses. Currently it catches the following:\n+    /// * mixed usage of arithmetic and bit shifting/combining operators without\n+    /// parentheses\n+    /// * a \"negative\" numeric literal (which is really a unary `-` followed by a\n+    /// numeric literal)\n+    ///   followed by a method call\n+    ///\n+    /// **Why is this bad?** Not everyone knows the precedence of those operators by\n+    /// heart, so expressions like these may trip others trying to reason about the\n+    /// code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n+    /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n     pub PRECEDENCE,\n     complexity,\n     \"operations where precedence may be unclear\""}, {"sha": "331f4216d26ff6ba6f74c94cfa3fbf9af8023ba6", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,86 +10,85 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::borrow::Cow;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n use syntax_pos::MultiSpan;\n \n-/// **What it does:** This lint checks for function arguments of type `&String`\n-/// or `&Vec` unless the references are mutable. It will also suggest you\n-/// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n-/// calls.\n-///\n-/// **Why is this bad?** Requiring the argument to be of the specific size\n-/// makes the function less useful for no benefit; slices in the form of `&[T]`\n-/// or `&str` usually suffice and can be obtained from other types, too.\n-///\n-/// **Known problems:** The lint does not follow data. So if you have an\n-/// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n-/// changing that `.clone()` to `.to_owned()`.\n-///\n-/// Other functions called from this function taking a `&String` or `&Vec`\n-/// argument may also fail to compile if you change the argument. Applying\n-/// this lint on them will fix the problem, but they may be in other crates.\n-///\n-/// Also there may be `fn(&Vec)`-typed references pointing to your function.\n-/// If you have them, you will get a compiler error after applying this lint's\n-/// suggestions. You then have the choice to undo your changes or change the\n-/// type of the reference.\n-///\n-/// Note that if the function is part of your public interface, there may be\n-/// other crates referencing it you may not be aware. Carefully deprecate the\n-/// function before applying the lint suggestions in this case.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(&Vec<u32>) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for function arguments of type `&String`\n+    /// or `&Vec` unless the references are mutable. It will also suggest you\n+    /// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n+    /// calls.\n+    ///\n+    /// **Why is this bad?** Requiring the argument to be of the specific size\n+    /// makes the function less useful for no benefit; slices in the form of `&[T]`\n+    /// or `&str` usually suffice and can be obtained from other types, too.\n+    ///\n+    /// **Known problems:** The lint does not follow data. So if you have an\n+    /// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n+    /// changing that `.clone()` to `.to_owned()`.\n+    ///\n+    /// Other functions called from this function taking a `&String` or `&Vec`\n+    /// argument may also fail to compile if you change the argument. Applying\n+    /// this lint on them will fix the problem, but they may be in other crates.\n+    ///\n+    /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n+    /// If you have them, you will get a compiler error after applying this lint's\n+    /// suggestions. You then have the choice to undo your changes or change the\n+    /// type of the reference.\n+    ///\n+    /// Note that if the function is part of your public interface, there may be\n+    /// other crates referencing it you may not be aware. Carefully deprecate the\n+    /// function before applying the lint suggestions in this case.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// fn foo(&Vec<u32>) { .. }\n+    /// ```\n     pub PTR_ARG,\n     style,\n     \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\"\n }\n \n-/// **What it does:** This lint checks for equality comparisons with `ptr::null`\n-///\n-/// **Why is this bad?** It's easier and more readable to use the inherent\n-/// `.is_null()`\n-/// method instead\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x == ptr::null {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for equality comparisons with `ptr::null`\n+    ///\n+    /// **Why is this bad?** It's easier and more readable to use the inherent\n+    /// `.is_null()`\n+    /// method instead\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if x == ptr::null {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub CMP_NULL,\n     style,\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n }\n \n-/// **What it does:** This lint checks for functions that take immutable\n-/// references and return\n-/// mutable ones.\n-///\n-/// **Why is this bad?** This is trivially unsound, as one can create two\n-/// mutable references\n-/// from the same (immutable!) source. This\n-/// [error](https://github.com/rust-lang/rust/issues/39465)\n-/// actually lead to an interim Rust release 1.15.1.\n-///\n-/// **Known problems:** To be on the conservative side, if there's at least one\n-/// mutable reference\n-/// with the output lifetime, this lint will not trigger. In practice, this\n-/// case is unlikely anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(&Foo) -> &mut Bar { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for functions that take immutable\n+    /// references and return\n+    /// mutable ones.\n+    ///\n+    /// **Why is this bad?** This is trivially unsound, as one can create two\n+    /// mutable references\n+    /// from the same (immutable!) source. This\n+    /// [error](https://github.com/rust-lang/rust/issues/39465)\n+    /// actually lead to an interim Rust release 1.15.1.\n+    ///\n+    /// **Known problems:** To be on the conservative side, if there's at least one\n+    /// mutable reference\n+    /// with the output lifetime, this lint will not trigger. In practice, this\n+    /// case is unlikely anyway.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// fn foo(&Foo) -> &mut Bar { .. }\n+    /// ```\n     pub MUT_FROM_REF,\n     correctness,\n     \"fns that create mutable refs from immutable ref args\"\n@@ -111,18 +110,19 @@ impl LintPass for PointerPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Fn(ref decl, _, _, body_id) = item.node {\n-            check_fn(cx, decl, item.id, Some(body_id));\n+            check_fn(cx, decl, item.hir_id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, body_id) = item.node {\n-            if let Some(Node::Item(it)) = cx.tcx.hir().find(cx.tcx.hir().get_parent(item.id)) {\n+            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n+            if let Some(Node::Item(it)) = cx.tcx.hir().find_by_hir_id(parent_item) {\n                 if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.id, Some(body_id));\n+            check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n         }\n     }\n \n@@ -133,7 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n             } else {\n                 None\n             };\n-            check_fn(cx, &sig.decl, item.id, body_id);\n+            check_fn(cx, &sig.decl, item.hir_id, body_id);\n         }\n     }\n \n@@ -152,8 +152,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n }\n \n #[allow(clippy::too_many_lines)]\n-fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_id);\n+fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id: Option<BodyId>) {\n+    let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n "}, {"sha": "21c7e721338292b0684a92081edf175b608f1810", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,37 +3,37 @@ use rustc::{declare_tool_lint, hir, lint, lint_array};\n use rustc_errors::Applicability;\n use std::fmt;\n \n-/// **What it does:** Checks for usage of the `offset` pointer method with a `usize` casted to an\n-/// `isize`.\n-///\n-/// **Why is this bad?** If we\u2019re always increasing the pointer address, we can avoid the numeric\n-/// cast by using the `add` method instead.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let vec = vec![b'a', b'b', b'c'];\n-/// let ptr = vec.as_ptr();\n-/// let offset = 1_usize;\n-///\n-/// unsafe {\n-///     ptr.offset(offset as isize);\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// let vec = vec![b'a', b'b', b'c'];\n-/// let ptr = vec.as_ptr();\n-/// let offset = 1_usize;\n-///\n-/// unsafe {\n-///     ptr.add(offset);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of the `offset` pointer method with a `usize` casted to an\n+    /// `isize`.\n+    ///\n+    /// **Why is this bad?** If we\u2019re always increasing the pointer address, we can avoid the numeric\n+    /// cast by using the `add` method instead.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let vec = vec![b'a', b'b', b'c'];\n+    /// let ptr = vec.as_ptr();\n+    /// let offset = 1_usize;\n+    ///\n+    /// unsafe {\n+    ///     ptr.offset(offset as isize);\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// let vec = vec![b'a', b'b', b'c'];\n+    /// let ptr = vec.as_ptr();\n+    /// let offset = 1_usize;\n+    ///\n+    /// unsafe {\n+    ///     ptr.add(offset);\n+    /// }\n+    /// ```\n     pub PTR_OFFSET_WITH_CAST,\n     complexity,\n     \"unneeded pointer offset cast\""}, {"sha": "7821ad56ccc8e8f75f6d836da17b1560a0e79861", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,34 +1,34 @@\n-use crate::utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n+use rustc_errors::Applicability;\n use syntax::ptr::P;\n \n use crate::utils::paths::*;\n+use crate::utils::sugg::Sugg;\n use crate::utils::{match_def_path, match_type, span_lint_and_then, SpanlessEq};\n-use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for expressions that could be replaced by the question mark operator\n-///\n-/// **Why is this bad?** Question mark usage is more idiomatic\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_none() {\n-///     return None;\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// option?;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions that could be replaced by the question mark operator.\n+    ///\n+    /// **Why is this bad?** Question mark usage is more idiomatic.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if option.is_none() {\n+    ///     return None;\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```ignore\n+    /// option?;\n+    /// ```\n     pub QUESTION_MARK,\n     style,\n     \"checks for expressions that could be replaced by the question mark operator\"\n@@ -48,7 +48,7 @@ impl LintPass for Pass {\n }\n \n impl Pass {\n-    /// Check if the given expression on the given context matches the following structure:\n+    /// Checks if the given expression on the given context matches the following structure:\n     ///\n     /// ```ignore\n     /// if option.is_none() {"}, {"sha": "18dfb963230bd79f54fb0c4f1679d852ca9c5375", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,6 +1,3 @@\n-use crate::utils::sugg::Sugg;\n-use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n-use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -9,77 +6,81 @@ use rustc_errors::Applicability;\n use syntax::ast::RangeLimits;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for calling `.step_by(0)` on iterators,\n-/// which never terminates.\n-///\n-/// **Why is this bad?** This very much looks like an oversight, since with\n-/// `loop { .. }` there is an obvious better way to endlessly loop.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in (5..5).step_by(0) {\n-///     ..\n-/// }\n-/// ```\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n+use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n+    /// which never terminates.\n+    ///\n+    /// **Why is this bad?** This very much looks like an oversight, since with\n+    /// `loop { .. }` there is an obvious better way to endlessly loop.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in (5..5).step_by(0) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub ITERATOR_STEP_BY_ZERO,\n     correctness,\n     \"using `Iterator::step_by(0)`, which produces an infinite iterator\"\n }\n \n-/// **What it does:** Checks for zipping a collection with the range of\n-/// `0.._.len()`.\n-///\n-/// **Why is this bad?** The code is better expressed with `.enumerate()`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.iter().zip(0..x.len())\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for zipping a collection with the range of\n+    /// `0.._.len()`.\n+    ///\n+    /// **Why is this bad?** The code is better expressed with `.enumerate()`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.iter().zip(0..x.len())\n+    /// ```\n     pub RANGE_ZIP_WITH_LEN,\n     complexity,\n     \"zipping iterator with a range when `enumerate()` would do\"\n }\n \n-/// **What it does:** Checks for exclusive ranges where 1 is added to the\n-/// upper bound, e.g. `x..(y+1)`.\n-///\n-/// **Why is this bad?** The code is more readable with an inclusive range\n-/// like `x..=y`.\n-///\n-/// **Known problems:** Will add unnecessary pair of parentheses when the\n-/// expression is not wrapped in a pair but starts with a opening parenthesis\n-/// and ends with a closing one.\n-/// I.e: `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x..(y+1) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for exclusive ranges where 1 is added to the\n+    /// upper bound, e.g., `x..(y+1)`.\n+    ///\n+    /// **Why is this bad?** The code is more readable with an inclusive range\n+    /// like `x..=y`.\n+    ///\n+    /// **Known problems:** Will add unnecessary pair of parentheses when the\n+    /// expression is not wrapped in a pair but starts with a opening parenthesis\n+    /// and ends with a closing one.\n+    /// I.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x..(y+1) { .. }\n+    /// ```\n     pub RANGE_PLUS_ONE,\n     complexity,\n     \"`x..(y+1)` reads better as `x..=y`\"\n }\n \n-/// **What it does:** Checks for inclusive ranges where 1 is subtracted from\n-/// the upper bound, e.g. `x..=(y-1)`.\n-///\n-/// **Why is this bad?** The code is more readable with an exclusive range\n-/// like `x..y`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x..=(y-1) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for inclusive ranges where 1 is subtracted from\n+    /// the upper bound, e.g., `x..=(y-1)`.\n+    ///\n+    /// **Why is this bad?** The code is more readable with an exclusive range\n+    /// like `x..y`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x..=(y-1) { .. }\n+    /// ```\n     pub RANGE_MINUS_ONE,\n     complexity,\n     \"`x..=(y-1)` reads better as `x..y`\"\n@@ -123,16 +124,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n                 if_chain! {\n-                    // .iter() call\n+                    // `.iter()` call\n                     if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n                     if iter_path.ident.name == \"iter\";\n-                    // range expression in .zip() call: 0..x.len()\n+                    // range expression in `.zip()` call: `0..x.len()`\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n-                    // .len() call\n+                    // `.len()` call\n                     if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n                     if len_path.ident.name == \"len\" && len_args.len() == 1;\n-                    // .iter() and .len() called on same Path\n+                    // `.iter()` and `.len()` called on same `Path`\n                     if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n                     if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n                     if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n@@ -147,7 +148,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         }\n \n-        // exclusive range plus one: x..(y+1)\n+        // exclusive range plus one: `x..(y+1)`\n         if_chain! {\n             if let Some(higher::Range {\n                 start,\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         }\n \n-        // inclusive range minus one: x..=(y-1)\n+        // inclusive range minus one: `x..=(y-1)`\n         if_chain! {\n             if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n             if let Some(y) = y_minus_one(end);\n@@ -213,7 +214,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    // No need for walk_ptrs_ty here because step_by moves self, so it\n+    // No need for `walk_ptrs_ty` here because `step_by` moves `self`, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);\n "}, {"sha": "3b74de5159f7ca0ffc93fd168de5646bc76eabd2", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,7 +5,7 @@ use crate::utils::{\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir::intravisit::FnKind;\n-use rustc::hir::{def_id, Body, FnDecl};\n+use rustc::hir::{def_id, Body, FnDecl, HirId};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::mir::{\n     self, traversal,\n@@ -16,10 +16,7 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::convert::TryFrom;\n-use syntax::{\n-    ast::NodeId,\n-    source_map::{BytePos, Span},\n-};\n+use syntax::source_map::{BytePos, Span};\n \n macro_rules! unwrap_or_continue {\n     ($x:expr) => {\n@@ -30,38 +27,38 @@ macro_rules! unwrap_or_continue {\n     };\n }\n \n-/// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n-/// value that is going to be dropped without further use.\n-///\n-/// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n-/// allocations and deallocations generated by redundant `clone()`s.\n-///\n-/// **Known problems:**\n-///\n-/// * Suggestions made by this lint could require NLL to be enabled.\n-/// * False-positive if there is a borrow preventing the value from moving out.\n-///\n-/// ```rust\n-/// let x = String::new();\n-///\n-/// let y = &x;\n-///\n-/// foo(x.clone()); // This lint suggests to remove this `clone()`\n-/// ```\n-///\n-/// **Example:**\n-/// ```rust\n-/// {\n-///     let x = Foo::new();\n-///     call(x.clone());\n-///     call(x.clone()); // this can just pass `x`\n-/// }\n-///\n-/// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n-///\n-/// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n+    /// value that is going to be dropped without further use.\n+    ///\n+    /// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n+    /// allocations and deallocations generated by redundant `clone()`s.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * Suggestions made by this lint could require NLL to be enabled.\n+    /// * False-positive if there is a borrow preventing the value from moving out.\n+    ///\n+    /// ```rust\n+    /// let x = String::new();\n+    ///\n+    /// let y = &x;\n+    ///\n+    /// foo(x.clone()); // This lint suggests to remove this `clone()`\n+    /// ```\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// {\n+    ///     let x = Foo::new();\n+    ///     call(x.clone());\n+    ///     call(x.clone()); // this can just pass `x`\n+    /// }\n+    ///\n+    /// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n+    ///\n+    /// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n+    /// ```\n     pub REDUNDANT_CLONE,\n     nursery,\n     \"`clone()` of an owned value that is going to be dropped immediately\"\n@@ -88,7 +85,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n@@ -146,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                 let pred_arg = if_chain! {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n-                    if *res == mir::Place::Local(cloned);\n+                    if *res == mir::Place::Base(mir::PlaceBase::Local(cloned));\n                     if match_def_path(cx.tcx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n                     if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n                         || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n@@ -232,7 +229,7 @@ fn is_call_with_ref_arg<'tcx>(\n     if_chain! {\n         if let TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n-        if let mir::Operand::Move(mir::Place::Local(local)) = &args[0];\n+        if let mir::Operand::Move(mir::Place::Base(mir::PlaceBase::Local(local))) = &args[0];\n         if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n         if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n         if !is_copy(cx, inner_ty);\n@@ -258,7 +255,7 @@ fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n     stmts\n         .rev()\n         .find_map(|stmt| {\n-            if let mir::StatementKind::Assign(mir::Place::Local(local), v) = &stmt.kind {\n+            if let mir::StatementKind::Assign(mir::Place::Base(mir::PlaceBase::Local(local)), v) = &stmt.kind {\n                 if *local == to {\n                     return Some(v);\n                 }\n@@ -288,6 +285,7 @@ fn base_local_and_movability<'tcx>(\n     mut place: &mir::Place<'tcx>,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n     use rustc::mir::Place::*;\n+    use rustc::mir::PlaceBase;\n \n     // Dereference. You cannot move things out from a borrowed value.\n     let mut deref = false;\n@@ -296,7 +294,7 @@ fn base_local_and_movability<'tcx>(\n \n     loop {\n         match place {\n-            Local(local) => return Some((*local, deref || field)),\n+            Base(PlaceBase::Local(local)) => return Some((*local, deref || field)),\n             Projection(proj) => {\n                 place = &proj.base;\n                 deref = deref || matches!(proj.elem, mir::ProjectionElem::Deref);"}, {"sha": "7e53035d9dce6c518be83cb90a7cea96ae979d19", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,29 +4,29 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::*;\n \n-/// **What it does:** Checks for fields in struct literals where shorthands\n-/// could be used.\n-///\n-/// **Why is this bad?** If the field and variable names are the same,\n-/// the field name is redundant.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bar: u8 = 123;\n-///\n-/// struct Foo {\n-///     bar: u8,\n-/// }\n-///\n-/// let foo = Foo{ bar: bar }\n-/// ```\n-/// the last line can be simplified to\n-/// ```rust\n-/// let foo = Foo{ bar }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for fields in struct literals where shorthands\n+    /// could be used.\n+    ///\n+    /// **Why is this bad?** If the field and variable names are the same,\n+    /// the field name is redundant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let bar: u8 = 123;\n+    ///\n+    /// struct Foo {\n+    ///     bar: u8,\n+    /// }\n+    ///\n+    /// let foo = Foo { bar: bar };\n+    /// ```\n+    /// the last line can be simplified to\n+    /// ```ignore\n+    /// let foo = Foo { bar };\n+    /// ```\n     pub REDUNDANT_FIELD_NAMES,\n     style,\n     \"checks for fields in struct literals where shorthands could be used\""}, {"sha": "ebc5e240a954e5bfd85e5f0d87dc2b7398b76701", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,37 +6,37 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::ptr::P;\n \n-/// **What it does:** Lint for redundant pattern matching over `Result` or\n-/// `Option`\n-///\n-/// **Why is this bad?** It's more concise and clear to just use the proper\n-/// utility function\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// if let Ok(_) = Ok::<i32, i32>(42) {}\n-/// if let Err(_) = Err::<i32, i32>(42) {}\n-/// if let None = None::<()> {}\n-/// if let Some(_) = Some(42) {}\n-/// match Ok::<i32, i32>(42) {\n-///     Ok(_) => true,\n-///     Err(_) => false,\n-/// };\n-/// ```\n-///\n-/// The more idiomatic use would be:\n-///\n-/// ```rust\n-/// if Ok::<i32, i32>(42).is_ok() {}\n-/// if Err::<i32, i32>(42).is_err() {}\n-/// if None::<()>.is_none() {}\n-/// if Some(42).is_some() {}\n-/// Ok::<i32, i32>(42).is_ok();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n     pub REDUNDANT_PATTERN_MATCHING,\n     style,\n     \"use the proper utility function avoiding an `if let`\""}, {"sha": "d5447027acbabed71fc4190b23c5bc2698277e4d", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,20 +5,20 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Expr, ExprKind, UnOp};\n \n-/// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n-///\n-/// **Why is this bad?** Immediately dereferencing a reference is no-op and\n-/// makes the code less clear.\n-///\n-/// **Known problems:** Multiple dereference/addrof pairs are not handled so\n-/// the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let a = f(*&mut b);\n-/// let c = *&d;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n+    ///\n+    /// **Why is this bad?** Immediately dereferencing a reference is no-op and\n+    /// makes the code less clear.\n+    ///\n+    /// **Known problems:** Multiple dereference/addrof pairs are not handled so\n+    /// the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let a = f(*&mut b);\n+    /// let c = *&d;\n+    /// ```\n     pub DEREF_ADDROF,\n     complexity,\n     \"use of `*&` or `*&mut` in an expression\"\n@@ -64,19 +64,19 @@ impl EarlyLintPass for Pass {\n     }\n }\n \n-/// **What it does:** Checks for references in expressions that use\n-/// auto dereference.\n-///\n-/// **Why is this bad?** The reference is a no-op and is automatically\n-/// dereferenced by the compiler and makes the code less clear.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Point(u32, u32);\n-/// let point = Foo(30, 20);\n-/// let x = (&point).x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for references in expressions that use\n+    /// auto dereference.\n+    ///\n+    /// **Why is this bad?** The reference is a no-op and is automatically\n+    /// dereferenced by the compiler and makes the code less clear.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Point(u32, u32);\n+    /// let point = Foo(30, 20);\n+    /// let x = (&point).x;\n+    /// ```\n     pub REF_IN_DEREF,\n     complexity,\n     \"Use of reference in auto dereference expression.\""}, {"sha": "094b6124076c9e266affe4b03c1b0653b719e2f1", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,66 +1,66 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::{is_expn_of, match_def_path, match_type, opt_def_id, paths, span_help_and_lint, span_lint};\n+use crate::utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint};\n use if_chain::if_chain;\n use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n use std::convert::TryFrom;\n-use syntax::ast::{LitKind, NodeId, StrStyle};\n+use syntax::ast::{LitKind, StrStyle};\n use syntax::source_map::{BytePos, Span};\n \n-/// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n-/// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n-/// regex syntax.\n-///\n-/// **Why is this bad?** This will lead to a runtime panic.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Regex::new(\"|\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n+    /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n+    /// regex syntax.\n+    ///\n+    /// **Why is this bad?** This will lead to a runtime panic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// Regex::new(\"|\")\n+    /// ```\n     pub INVALID_REGEX,\n     correctness,\n     \"invalid regular expressions\"\n }\n \n-/// **What it does:** Checks for trivial [regex](https://crates.io/crates/regex)\n-/// creation (with `Regex::new`, `RegexBuilder::new` or `RegexSet::new`).\n-///\n-/// **Why is this bad?** Matching the regex can likely be replaced by `==` or\n-/// `str::starts_with`, `str::ends_with` or `std::contains` or other `str`\n-/// methods.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Regex::new(\"^foobar\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for trivial [regex](https://crates.io/crates/regex)\n+    /// creation (with `Regex::new`, `RegexBuilder::new` or `RegexSet::new`).\n+    ///\n+    /// **Why is this bad?** Matching the regex can likely be replaced by `==` or\n+    /// `str::starts_with`, `str::ends_with` or `std::contains` or other `str`\n+    /// methods.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// Regex::new(\"^foobar\")\n+    /// ```\n     pub TRIVIAL_REGEX,\n     style,\n     \"trivial regular expressions\"\n }\n \n-/// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n-/// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n-/// idea anyway).\n-///\n-/// **Why is this bad?** Performance, at least for now. The macro version is\n-/// likely to catch up long-term, but for now the dynamic version is faster.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// regex!(\"foo|bar\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n+    /// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n+    /// idea anyway).\n+    ///\n+    /// **Why is this bad?** Performance, at least for now. The macro version is\n+    /// likely to catch up long-term, but for now the dynamic version is faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// regex!(\"foo|bar\")\n+    /// ```\n     pub REGEX_MACRO,\n     style,\n     \"use of `regex!(_)` instead of `Regex::new(_)`\"\n@@ -69,7 +69,7 @@ declare_clippy_lint! {\n #[derive(Clone, Default)]\n pub struct Pass {\n     spans: FxHashSet<Span>,\n-    last: Option<NodeId>,\n+    last: Option<HirId>,\n }\n \n impl LintPass for Pass {\n@@ -102,13 +102,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                               Please use `Regex::new(_)`, which is faster for now.\");\n                     self.spans.insert(span);\n                 }\n-                self.last = Some(block.id);\n+                self.last = Some(block.hir_id);\n             }\n         }\n     }\n \n     fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n-        if self.last.map_or(false, |id| block.id == id) {\n+        if self.last.map_or(false, |id| block.hir_id == id) {\n             self.last = None;\n         }\n     }\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprKind::Call(ref fun, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath) = fun.node;\n             if args.len() == 1;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id));\n+            if let Some(def_id) = cx.tables.qpath_def(qpath, fun.hir_id).opt_def_id();\n             then {\n                 if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n                    match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {"}, {"sha": "10e339eeb023cd8cbcb0396103147bedfab8d776", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,24 +6,24 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n-/// `uX/iX::MIN/MAX`.\n-///\n-/// **Why is this bad?** `const fn`s exist\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// static FOO: AtomicIsize = AtomicIsize::new(0);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n+    /// `uX/iX::MIN/MAX`.\n+    ///\n+    /// **Why is this bad?** `const fn`s exist\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// static FOO: AtomicIsize = AtomicIsize::new(0);\n+    /// ```\n     pub REPLACE_CONSTS,\n     pedantic,\n     \"Lint usages of standard library `const`s that could be replaced by `const fn`s\""}, {"sha": "5458fa51c7c07e0611d89997f38bf1429f6ccb38", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n use if_chain::if_chain;\n use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -8,75 +7,77 @@ use syntax::source_map::Span;\n use syntax::visit::FnKind;\n use syntax_pos::BytePos;\n \n-/// **What it does:** Checks for return statements at the end of a block.\n-///\n-/// **Why is this bad?** Removing the `return` and semicolon will make the code\n-/// more rusty.\n-///\n-/// **Known problems:** If the computation returning the value borrows a local\n-/// variable, removing the `return` may run afoul of the borrow checker.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     return x;\n-/// }\n-/// ```\n-/// simplify to\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     x\n-/// }\n-/// ```\n+use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** If the computation returning the value borrows a local\n+    /// variable, removing the `return` may run afoul of the borrow checker.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n+    /// }\n+    /// ```\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n     pub NEEDLESS_RETURN,\n     style,\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-/// **What it does:** Checks for `let`-bindings, which are subsequently\n-/// returned.\n-///\n-/// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-/// more rusty.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo() -> String {\n-///     let x = String::new();\n-///     x\n-/// }\n-/// ```\n-/// instead, use\n-/// ```\n-/// fn foo() -> String {\n-///     String::new()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n+    ///\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n+    /// }\n+    /// ```\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n+    /// }\n+    /// ```\n     pub LET_AND_RETURN,\n     style,\n     \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n-/// **What it does:** Checks for unit (`()`) expressions that can be removed.\n-///\n-/// **Why is this bad?** Such expressions add no value, but can make the code\n-/// less readable. Depending on formatting they can make a `break` or `return`\n-/// statement look like a function call.\n-///\n-/// **Known problems:** The lint currently misses unit return types in types,\n-/// e.g. the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn return_unit() -> () {\n-///     ()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** The lint currently misses unit return types in types,\n+    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n     pub UNUSED_UNIT,\n     style,\n     \"needless unit expression\""}, {"sha": "e9479af541909a31d3c24aaae1f314fba72931fd", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,16 +3,16 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for mis-uses of the serde API.\n-///\n-/// **Why is this bad?** Serde is very finnicky about how its API should be\n-/// used, but the type system can't be used to enforce it (yet?).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** Implementing `Visitor::visit_string` but not\n-/// `Visitor::visit_str`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for mis-uses of the serde API.\n+    ///\n+    /// **Why is this bad?** Serde is very finnicky about how its API should be\n+    /// used, but the type system can't be used to enforce it (yet?).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** Implementing `Visitor::visit_string` but not\n+    /// `Visitor::visit_str`.\n     pub SERDE_API_MISUSE,\n     correctness,\n     \"various things that will negatively affect your serde experience\""}, {"sha": "99580affef6783cc8e563c87951d5868c1fc4755", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,69 +7,69 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, while just changing reference level or mutability.\n-///\n-/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust\n-/// code. Still, some may opt to avoid it in their code base, they can set this\n-/// lint to `Warn`.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = &x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, while just changing reference level or mutability.\n+    ///\n+    /// **Why is this bad?** Not much, in fact it's a very common pattern in Rust\n+    /// code. Still, some may opt to avoid it in their code base, they can set this\n+    /// lint to `Warn`.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = &x;\n+    /// ```\n     pub SHADOW_SAME,\n     restriction,\n-    \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n+    \"rebinding a name to itself, e.g., `let mut x = &mut x`\"\n }\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, while reusing the original value.\n-///\n-/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust\n-/// code. Still, some argue that name shadowing like this hurts readability,\n-/// because a value may be bound to different things depending on position in\n-/// the code.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = x + 1;\n-/// ```\n-/// use different variable name:\n-/// ```rust\n-/// let y = x + 1;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, while reusing the original value.\n+    ///\n+    /// **Why is this bad?** Not too much, in fact it's a common pattern in Rust\n+    /// code. Still, some argue that name shadowing like this hurts readability,\n+    /// because a value may be bound to different things depending on position in\n+    /// the code.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = x + 1;\n+    /// ```\n+    /// use different variable name:\n+    /// ```rust\n+    /// let y = x + 1;\n+    /// ```\n     pub SHADOW_REUSE,\n     restriction,\n-    \"rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\"\n+    \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\"\n }\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, either without a initialization or with one that does not even use\n-/// the original value.\n-///\n-/// **Why is this bad?** Name shadowing can hurt readability, especially in\n-/// large code bases, because it is easy to lose track of the active binding at\n-/// any place in the code. This can be alleviated by either giving more specific\n-/// names to bindings or introducing more scopes to contain the bindings.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = y;\n-/// let x = z; // shadows the earlier binding\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, either without a initialization or with one that does not even use\n+    /// the original value.\n+    ///\n+    /// **Why is this bad?** Name shadowing can hurt readability, especially in\n+    /// large code bases, because it is easy to lose track of the active binding at\n+    /// any place in the code. This can be alleviated by either giving more specific\n+    /// names to bindings or introducing more scopes to contain the bindings.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = y;\n+    /// let x = z; // shadows the earlier binding\n+    /// ```\n     pub SHADOW_UNRELATED,\n     pedantic,\n     \"rebinding a name without even using the original value\"\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         if in_external_macro(cx.sess(), body.value.span) {\n             return;"}, {"sha": "888405983fd5129a853ccd80f13d5bb1d9f5e520", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -6,25 +6,25 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::{LitKind, NodeId};\n+use syntax::ast::LitKind;\n use syntax_pos::symbol::Symbol;\n \n-/// **What it does:** Checks slow zero-filled vector initialization\n-///\n-/// **Why is this bad?** These structures are non-idiomatic and less efficient than simply using\n-/// `vec![0; len]`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut vec1 = Vec::with_capacity(len);\n-/// vec1.resize(len, 0);\n-///\n-/// let mut vec2 = Vec::with_capacity(len);\n-/// vec2.extend(repeat(0).take(len))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks slow zero-filled vector initialization\n+    ///\n+    /// **Why is this bad?** These structures are non-idiomatic and less efficient than simply using\n+    /// `vec![0; len]`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut vec1 = Vec::with_capacity(len);\n+    /// vec1.resize(len, 0);\n+    ///\n+    /// let mut vec2 = Vec::with_capacity(len);\n+    /// vec2.extend(repeat(0).take(len))\n+    /// ```\n     pub SLOW_VECTOR_INITIALIZATION,\n     perf,\n     \"slow vector initialization\"\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     len_expr: len_arg,\n                 };\n \n-                Self::search_initialization(cx, vi, expr.id);\n+                Self::search_initialization(cx, vi, expr.hir_id);\n             }\n         }\n     }\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     len_expr: len_arg,\n                 };\n \n-                Self::search_initialization(cx, vi, stmt.id);\n+                Self::search_initialization(cx, vi, stmt.hir_id);\n             }\n         }\n     }\n@@ -132,7 +132,7 @@ impl Pass {\n     }\n \n     /// Search initialization for the given vector\n-    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: NodeId) {\n+    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: HirId) {\n         let enclosing_body = get_enclosing_block(cx, parent_node);\n \n         if enclosing_body.is_none() {\n@@ -194,13 +194,13 @@ impl Pass {\n struct VectorInitializationVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n \n-    /// Contains the information\n+    /// Contains the information.\n     vec_alloc: VecAllocation<'tcx>,\n \n-    /// Contains, if found, the slow initialization expression\n+    /// Contains the slow initialization expression, if one was found.\n     slow_expression: Option<InitializationType<'tcx>>,\n \n-    /// true if the initialization of the vector has been found on the visited block\n+    /// `true` if the initialization of the vector has been found on the visited block.\n     initialization_found: bool,\n }\n \n@@ -317,7 +317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         // Skip all the expressions previous to the vector initialization\n-        if self.vec_alloc.allocation_expr.id == expr.id {\n+        if self.vec_alloc.allocation_expr.hir_id == expr.hir_id {\n             self.initialization_found = true;\n         }\n "}, {"sha": "cd23722bef4f9a8e0d9e6892d4dd8e977456981c", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,72 +1,73 @@\n-use crate::utils::SpanlessEq;\n-use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for string appends of the form `x = x + y` (without\n-/// `let`!).\n-///\n-/// **Why is this bad?** It's not really bad, but some people think that the\n-/// `.push_str(_)` method is more readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let mut x = \"Hello\".to_owned();\n-/// x = x + \", World\";\n-/// ```\n+use crate::utils::SpanlessEq;\n+use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string appends of the form `x = x + y` (without\n+    /// `let`!).\n+    ///\n+    /// **Why is this bad?** It's not really bad, but some people think that the\n+    /// `.push_str(_)` method is more readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut x = \"Hello\".to_owned();\n+    /// x = x + \", World\";\n+    /// ```\n     pub STRING_ADD_ASSIGN,\n     pedantic,\n     \"using `x = x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** Checks for all instances of `x + _` where `x` is of type\n-/// `String`, but only if [`string_add_assign`](#string_add_assign) does *not*\n-/// match.\n-///\n-/// **Why is this bad?** It's not bad in and of itself. However, this particular\n-/// `Add` implementation is asymmetric (the other operand need not be `String`,\n-/// but `x` does), while addition as mathematically defined is symmetric, also\n-/// the `String::push_str(_)` function is a perfectly good replacement.\n-/// Therefore some dislike it and wish not to have it in their code.\n-///\n-/// That said, other people think that string addition, having a long tradition\n-/// in other languages is actually fine, which is why we decided to make this\n-/// particular lint `allow` by default.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x = \"Hello\".to_owned();\n-/// x + \", World\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for all instances of `x + _` where `x` is of type\n+    /// `String`, but only if [`string_add_assign`](#string_add_assign) does *not*\n+    /// match.\n+    ///\n+    /// **Why is this bad?** It's not bad in and of itself. However, this particular\n+    /// `Add` implementation is asymmetric (the other operand need not be `String`,\n+    /// but `x` does), while addition as mathematically defined is symmetric, also\n+    /// the `String::push_str(_)` function is a perfectly good replacement.\n+    /// Therefore, some dislike it and wish not to have it in their code.\n+    ///\n+    /// That said, other people think that string addition, having a long tradition\n+    /// in other languages is actually fine, which is why we decided to make this\n+    /// particular lint `allow` by default.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = \"Hello\".to_owned();\n+    /// x + \", World\"\n+    /// ```\n     pub STRING_ADD,\n     restriction,\n     \"using `x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** Checks for the `as_bytes` method called on string literals\n-/// that contain only ASCII characters.\n-///\n-/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used\n-/// instead. They are shorter but less discoverable than `as_bytes()`.\n-///\n-/// **Known Problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bs = \"a byte string\".as_bytes();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the `as_bytes` method called on string literals\n+    /// that contain only ASCII characters.\n+    ///\n+    /// **Why is this bad?** Byte string literals (e.g., `b\"foo\"`) can be used\n+    /// instead. They are shorter but less discoverable than `as_bytes()`.\n+    ///\n+    /// **Known Problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let bs = \"a byte string\".as_bytes();\n+    /// ```\n     pub STRING_LIT_AS_BYTES,\n     style,\n     \"calling `as_bytes` on a string literal instead of using a byte string literal\"\n@@ -96,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n         ) = e.node\n         {\n             if is_string(cx, left) {\n-                if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n+                if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n                         if let ExprKind::Assign(ref target, _) = p.node {"}, {"sha": "76ca1dc284827f8db4ecec3527637e976f942c29", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,50 +1,49 @@\n-use crate::utils::{get_trait_def_id, span_lint};\n+use crate::utils::{get_trait_def_id, span_lint, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast;\n-\n-/// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n-/// subtracting elements in an Add impl.\n-///\n-/// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl Add for Foo {\n-///     type Output = Foo;\n-///\n-///     fn add(self, other: Foo) -> Foo {\n-///         Foo(self.0 - other.0)\n-///     }\n-/// }\n-/// ```\n+\n declare_clippy_lint! {\n+    /// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n+    /// subtracting elements in an Add impl.\n+    ///\n+    /// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl Add for Foo {\n+    ///     type Output = Foo;\n+    ///\n+    ///     fn add(self, other: Foo) -> Foo {\n+    ///         Foo(self.0 - other.0)\n+    ///     }\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_ARITHMETIC_IMPL,\n     correctness,\n     \"suspicious use of operators in impl of arithmetic trait\"\n }\n \n-/// **What it does:** Lints for suspicious operations in impls of OpAssign, e.g.\n-/// subtracting elements in an AddAssign impl.\n-///\n-/// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl AddAssign for Foo {\n-///     fn add_assign(&mut self, other: Foo) {\n-///         *self = *self - other;\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Lints for suspicious operations in impls of OpAssign, e.g.\n+    /// subtracting elements in an AddAssign impl.\n+    ///\n+    /// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl AddAssign for Foo {\n+    ///     fn add_assign(&mut self, other: Foo) {\n+    ///         *self = *self - other;\n+    ///     }\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_OP_ASSIGN_IMPL,\n     correctness,\n     \"suspicious use of operators in impl of OpAssign trait\"\n@@ -77,17 +76,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             }\n             // Check if the binary expression is part of another bi/unary expression\n             // as a child node\n-            let mut parent_expr = cx.tcx.hir().get_parent_node(expr.id);\n-            while parent_expr != ast::CRATE_NODE_ID {\n-                if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n+            let mut parent_expr = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+            while parent_expr != hir::CRATE_HIR_ID {\n+                if let hir::Node::Expr(e) = cx.tcx.hir().get_by_hir_id(parent_expr) {\n                     match e.node {\n                         hir::ExprKind::Binary(..)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n-                parent_expr = cx.tcx.hir().get_parent_node(parent_expr);\n+                parent_expr = cx.tcx.hir().get_parent_node_by_hir_id(parent_expr);\n             }\n             // as a parent node\n             let mut visitor = BinaryExprVisitor { in_binary_expr: false };\n@@ -177,13 +176,10 @@ fn check_binop<'a>(\n     }\n \n     // Get the actually implemented trait\n-    let parent_fn = cx.tcx.hir().get_parent(expr.id);\n-    let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n+    let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n \n     if_chain! {\n-        if parent_impl != ast::CRATE_NODE_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-        if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+        if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];\n         then{"}, {"sha": "c7003cfb9f032c6fd0152de3ada29dcaf81ee110", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,41 +10,41 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for manual swapping.\n-///\n-/// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n-/// without deinitializing or copying either variable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let t = b;\n-/// b = a;\n-/// a = t;\n-/// ```\n-/// Use std::mem::swap():\n-/// ```rust\n-/// std::mem::swap(&mut a, &mut b);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for manual swapping.\n+    ///\n+    /// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n+    /// without deinitializing or copying either variable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let t = b;\n+    /// b = a;\n+    /// a = t;\n+    /// ```\n+    /// Use std::mem::swap():\n+    /// ```rust\n+    /// std::mem::swap(&mut a, &mut b);\n+    /// ```\n     pub MANUAL_SWAP,\n     complexity,\n     \"manual swap of two variables\"\n }\n \n-/// **What it does:** Checks for `foo = bar; bar = foo` sequences.\n-///\n-/// **Why is this bad?** This looks like a failed attempt to swap.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// a = b;\n-/// b = a;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `foo = bar; bar = foo` sequences.\n+    ///\n+    /// **Why is this bad?** This looks like a failed attempt to swap.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// a = b;\n+    /// b = a;\n+    /// ```\n     pub ALMOST_SWAPPED,\n     correctness,\n     \"`foo = bar; bar = foo` sequence\""}, {"sha": "a6126f37282872afc0af76a808751e49131dda80", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,19 +5,19 @@ use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for construction of a structure or tuple just to\n-/// assign a value in it.\n-///\n-/// **Why is this bad?** Readability. If the structure is only created to be\n-/// updated, why not write the structure you want in the first place?\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// (0, 0).0 = 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for construction of a structure or tuple just to\n+    /// assign a value in it.\n+    ///\n+    /// **Why is this bad?** Readability. If the structure is only created to be\n+    /// updated, why not write the structure you want in the first place?\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// (0, 0).0 = 1\n+    /// ```\n     pub TEMPORARY_ASSIGNMENT,\n     complexity,\n     \"assignments to temporaries\""}, {"sha": "2c4bfe7358d602ea131a46a65d09adba5bf4f1b0", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 144, "deletions": 145, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then};\n-use crate::utils::{opt_def_id, sugg};\n+use crate::utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then, sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -9,196 +8,196 @@ use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast;\n \n-/// **What it does:** Checks for transmutes that can't ever be correct on any\n-/// architecture.\n-///\n-/// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n-///\n-/// **Known problems:** When accessing C, users might want to store pointer\n-/// sized objects in `extradata` arguments to save an allocation.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let ptr: *const T = core::intrinsics::transmute('x')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes that can't ever be correct on any\n+    /// architecture.\n+    ///\n+    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n+    ///\n+    /// **Known problems:** When accessing C, users might want to store pointer\n+    /// sized objects in `extradata` arguments to save an allocation.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let ptr: *const T = core::intrinsics::transmute('x')\n+    /// ```\n     pub WRONG_TRANSMUTE,\n     correctness,\n     \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n }\n \n-/// **What it does:** Checks for transmutes to the original type of the object\n-/// and transmutes that could be a cast.\n-///\n-/// **Why is this bad?** Readability. The code tricks people into thinking that\n-/// something complex is going on.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// core::intrinsics::transmute(t) // where the result type is the same as `t`'s\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes to the original type of the object\n+    /// and transmutes that could be a cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// core::intrinsics::transmute(t) // where the result type is the same as `t`'s\n+    /// ```\n     pub USELESS_TRANSMUTE,\n     complexity,\n     \"transmutes that have the same to and from types or could be a cast/coercion\"\n }\n \n-/// **What it does:** Checks for transmutes between a type `T` and `*T`.\n-///\n-/// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n-/// pointer to that type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// core::intrinsics::transmute(t) // where the result type is the same as\n-///                                // `*t` or `&t`'s\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n+    ///\n+    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n+    /// pointer to that type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// core::intrinsics::transmute(t) // where the result type is the same as\n+    ///                                // `*t` or `&t`'s\n+    /// ```\n     pub CROSSPOINTER_TRANSMUTE,\n     complexity,\n     \"transmutes that have to or from types that are a pointer to the other\"\n }\n \n-/// **What it does:** Checks for transmutes from a pointer to a reference.\n-///\n-/// **Why is this bad?** This can always be rewritten with `&` and `*`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: &T = std::mem::transmute(p); // where p: *const T\n-///\n-/// // can be written:\n-/// let _: &T = &*p;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a reference.\n+    ///\n+    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: &T = std::mem::transmute(p); // where p: *const T\n+    ///\n+    /// // can be written:\n+    /// let _: &T = &*p;\n+    /// ```\n     pub TRANSMUTE_PTR_TO_REF,\n     complexity,\n     \"transmutes from a pointer to a reference type\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a `char`.\n-///\n-/// **Why is this bad?** Not every integer is a Unicode scalar value.\n-///\n-/// **Known problems:**\n-/// - [`from_u32`] which this lint suggests using is slower than `transmute`\n-/// as it needs to validate the input.\n-/// If you are certain that the input is always a valid Unicode scalar value,\n-/// use [`from_u32_unchecked`] which is as fast as `transmute`\n-/// but has a semantically meaningful name.\n-/// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n-///\n-/// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n-/// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: char = std::mem::transmute(x); // where x: u32\n-///\n-/// // should be:\n-/// let _ = std::char::from_u32(x).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `char`.\n+    ///\n+    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid Unicode scalar value,\n+    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n+    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: char = std::mem::transmute(x); // where x: u32\n+    ///\n+    /// // should be:\n+    /// let _ = std::char::from_u32(x).unwrap();\n+    /// ```\n     pub TRANSMUTE_INT_TO_CHAR,\n     complexity,\n     \"transmutes from an integer to a `char`\"\n }\n \n-/// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n-///\n-/// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n-///\n-/// **Known problems:**\n-/// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n-/// as it needs to validate the input.\n-/// If you are certain that the input is always a valid UTF-8,\n-/// use [`from_utf8_unchecked`] which is as fast as `transmute`\n-/// but has a semantically meaningful name.\n-/// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n-///\n-/// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n-/// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: &str = std::mem::transmute(b); // where b: &[u8]\n-///\n-/// // should be:\n-/// let _ = std::str::from_utf8(b).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n+    ///\n+    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid UTF-8,\n+    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n+    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: &str = std::mem::transmute(b); // where b: &[u8]\n+    ///\n+    /// // should be:\n+    /// let _ = std::str::from_utf8(b).unwrap();\n+    /// ```\n     pub TRANSMUTE_BYTES_TO_STR,\n     complexity,\n     \"transmutes from a `&[u8]` to a `&str`\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a `bool`.\n-///\n-/// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: bool = std::mem::transmute(x); // where x: u8\n-///\n-/// // should be:\n-/// let _: bool = x != 0;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n+    ///\n+    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: bool = std::mem::transmute(x); // where x: u8\n+    ///\n+    /// // should be:\n+    /// let _: bool = x != 0;\n+    /// ```\n     pub TRANSMUTE_INT_TO_BOOL,\n     complexity,\n     \"transmutes from an integer to a `bool`\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a float.\n-///\n-/// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n-/// and safe.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: f32 = std::mem::transmute(x); // where x: u32\n-///\n-/// // should be:\n-/// let _: f32 = f32::from_bits(x);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a float.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: f32 = std::mem::transmute(x); // where x: u32\n+    ///\n+    /// // should be:\n+    /// let _: f32 = f32::from_bits(x);\n+    /// ```\n     pub TRANSMUTE_INT_TO_FLOAT,\n     complexity,\n     \"transmutes from an integer to a float\"\n }\n \n-/// **What it does:** Checks for transmutes from a pointer to a pointer, or\n-/// from a reference to a reference.\n-///\n-/// **Why is this bad?** Transmutes are dangerous, and these can instead be\n-/// written as casts.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let ptr = &1u32 as *const u32;\n-/// unsafe {\n-///     // pointer-to-pointer transmute\n-///     let _: *const f32 = std::mem::transmute(ptr);\n-///     // ref-ref transmute\n-///     let _: &f32 = std::mem::transmute(&1u32);\n-/// }\n-/// // These can be respectively written:\n-/// let _ = ptr as *const f32\n-/// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n+    /// from a reference to a reference.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n+    /// written as casts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let ptr = &1u32 as *const u32;\n+    /// unsafe {\n+    ///     // pointer-to-pointer transmute\n+    ///     let _: *const f32 = std::mem::transmute(ptr);\n+    ///     // ref-ref transmute\n+    ///     let _: &f32 = std::mem::transmute(&1u32);\n+    /// }\n+    /// // These can be respectively written:\n+    /// let _ = ptr as *const f32\n+    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n+    /// ```\n     pub TRANSMUTE_PTR_TO_PTR,\n     complexity,\n     \"transmutes from a pointer to a pointer / a reference to a reference\"\n@@ -231,7 +230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n+                if let Some(def_id) = cx.tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n                         let to_ty = cx.tables.expr_ty(e);\n@@ -486,7 +485,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     }\n }\n \n-/// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n /// not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`"}, {"sha": "d246a7911662299494c8b3c152f5e604cd7b5557", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -13,42 +13,41 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for functions taking arguments by reference, where\n-/// the argument type is `Copy` and small enough to be more efficient to always\n-/// pass by value.\n-///\n-/// **Why is this bad?** In many calling conventions instances of structs will\n-/// be passed through registers if they fit into two or less general purpose\n-/// registers.\n-///\n-/// **Known problems:** This lint is target register size dependent, it is\n-/// limited to 32-bit to try and reduce portability problems between 32 and\n-/// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n-/// will be different.\n-///\n-/// The configuration option `trivial_copy_size_limit` can be set to override\n-/// this limit for a project.\n-///\n-/// This lint attempts to allow passing arguments by reference if a reference\n-/// to that argument is returned. This is implemented by comparing the lifetime\n-/// of the argument and return value for equality. However, this can cause\n-/// false positives in cases involving multiple lifetimes that are bounded by\n-/// each other.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(v: &u32) {\n-///     assert_eq!(v, 42);\n-/// }\n-/// // should be\n-/// fn foo(v: u32) {\n-///     assert_eq!(v, 42);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by reference, where\n+    /// the argument type is `Copy` and small enough to be more efficient to always\n+    /// pass by value.\n+    ///\n+    /// **Why is this bad?** In many calling conventions instances of structs will\n+    /// be passed through registers if they fit into two or less general purpose\n+    /// registers.\n+    ///\n+    /// **Known problems:** This lint is target register size dependent, it is\n+    /// limited to 32-bit to try and reduce portability problems between 32 and\n+    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+    /// will be different.\n+    ///\n+    /// The configuration option `trivial_copy_size_limit` can be set to override\n+    /// this limit for a project.\n+    ///\n+    /// This lint attempts to allow passing arguments by reference if a reference\n+    /// to that argument is returned. This is implemented by comparing the lifetime\n+    /// of the argument and return value for equality. However, this can cause\n+    /// false positives in cases involving multiple lifetimes that are bounded by\n+    /// each other.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(v: &u32) {\n+    ///     assert_eq!(v, 42);\n+    /// }\n+    /// // should be\n+    /// fn foo(v: u32) {\n+    ///     assert_eq!(v, 42);\n+    /// }\n+    /// ```\n     pub TRIVIALLY_COPY_PASS_BY_REF,\n     perf,\n     \"functions taking small copyable arguments by reference\"\n@@ -73,11 +72,11 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n     }\n \n     fn check_trait_method(&mut self, cx: &LateContext<'_, 'tcx>, item: &TraitItemRef) {\n-        let method_def_id = cx.tcx.hir().local_def_id(item.id.node_id);\n+        let method_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n         let method_sig = cx.tcx.fn_sig(method_def_id);\n         let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n \n-        let decl = match cx.tcx.hir().fn_decl(item.id.node_id) {\n+        let decl = match cx.tcx.hir().fn_decl_by_hir_id(item.id.hir_id) {\n             Some(b) => b,\n             None => return,\n         };\n@@ -165,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         decl: &'tcx FnDecl,\n         _body: &'tcx Body,\n         span: Span,\n-        node_id: NodeId,\n+        hir_id: HirId,\n     ) {\n         if in_macro(span) {\n             return;\n@@ -187,15 +186,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         }\n \n         // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(node_id)) {\n+        if let Some(Node::Item(item)) = cx\n+            .tcx\n+            .hir()\n+            .find_by_hir_id(cx.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n                 return;\n             }\n         }\n \n-        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n \n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);"}, {"sha": "5ad999f7095974e5aef77cd3e6796870126362b4", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 466, "deletions": 465, "changes": 931, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,14 +1,9 @@\n #![allow(clippy::default_hash_types)]\n \n-use crate::consts::{constant, Constant};\n-use crate::reexport::*;\n-use crate::utils::paths;\n-use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n-    match_def_path, match_path, multispan_sugg, opt_def_id, same_tys, sext, snippet, snippet_opt,\n-    snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n-    AbsolutePathBuffer,\n-};\n+use std::borrow::Cow;\n+use std::cmp::Ordering;\n+use std::collections::BTreeMap;\n+\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n@@ -20,145 +15,151 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n-use std::borrow::Cow;\n-use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::errors::DiagnosticBuilder;\n use syntax::source_map::Span;\n \n+use crate::consts::{constant, Constant};\n+use crate::utils::paths;\n+use crate::utils::{\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n+    match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathBuffer,\n+};\n+\n /// Handles all the linting of funky types\n pub struct TypePass;\n \n-/// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n-///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n-/// the heap. So if you `Box` it, you just add another level of indirection\n-/// without any benefit whatsoever.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X {\n-///     values: Box<Vec<Foo>>,\n-/// }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// struct X {\n-///     values: Vec<Foo>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n+    /// the heap. So if you `Box` it, you just add another level of indirection\n+    /// without any benefit whatsoever.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// struct X {\n+    ///     values: Box<Vec<Foo>>,\n+    /// }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust,ignore\n+    /// struct X {\n+    ///     values: Vec<Foo>,\n+    /// }\n+    /// ```\n     pub BOX_VEC,\n     perf,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n \n-/// **What it does:** Checks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.\n-///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n-/// the heap. So if you `Box` its contents, you just add another level of indirection.\n-///\n-/// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n-/// 1st comment).\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X {\n-///     values: Vec<Box<i32>>,\n-/// }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// struct X {\n-///     values: Vec<i32>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.\n+    ///\n+    /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n+    /// the heap. So if you `Box` its contents, you just add another level of indirection.\n+    ///\n+    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n+    /// 1st comment).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Vec<Box<i32>>,\n+    /// }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Vec<i32>,\n+    /// }\n+    /// ```\n     pub VEC_BOX,\n     complexity,\n     \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\"\n }\n \n-/// **What it does:** Checks for use of `Option<Option<_>>` in function signatures and type\n-/// definitions\n-///\n-/// **Why is this bad?** `Option<_>` represents an optional value. `Option<Option<_>>`\n-/// represents an optional optional value which is logically the same thing as an optional\n-/// value but has an unneeded extra level of wrapping.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example**\n-/// ```rust\n-/// fn x() -> Option<Option<u32>> {\n-///     None\n-/// }\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Option<Option<_>>` in function signatures and type\n+    /// definitions\n+    ///\n+    /// **Why is this bad?** `Option<_>` represents an optional value. `Option<Option<_>>`\n+    /// represents an optional optional value which is logically the same thing as an optional\n+    /// value but has an unneeded extra level of wrapping.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example**\n+    /// ```rust\n+    /// fn x() -> Option<Option<u32>> {\n+    ///     None\n+    /// }\n+    /// ```\n     pub OPTION_OPTION,\n     complexity,\n     \"usage of `Option<Option<T>>`\"\n }\n \n-/// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n-/// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n-///\n-/// **Why is this bad?** Gankro says:\n-///\n-/// > The TL;DR of `LinkedList` is that it's built on a massive amount of\n-/// pointers and indirection.\n-/// > It wastes memory, it has terrible cache locality, and is all-around slow.\n-/// `RingBuf`, while\n-/// > \"only\" amortized for push/pop, should be faster in the general case for\n-/// almost every possible\n-/// > workload, and isn't even amortized at all if you can predict the capacity\n-/// you need.\n-/// >\n-/// > `LinkedList`s are only really good if you're doing a lot of merging or\n-/// splitting of lists.\n-/// > This is because they can just mangle some pointers instead of actually\n-/// copying the data. Even\n-/// > if you're doing a lot of insertion in the middle of the list, `RingBuf`\n-/// can still be better\n-/// > because of how expensive it is to seek to the middle of a `LinkedList`.\n-///\n-/// **Known problems:** False positives \u2013 the instances where using a\n-/// `LinkedList` makes sense are few and far between, but they can still happen.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = LinkedList::new();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n+    /// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n+    ///\n+    /// **Why is this bad?** Gankro says:\n+    ///\n+    /// > The TL;DR of `LinkedList` is that it's built on a massive amount of\n+    /// pointers and indirection.\n+    /// > It wastes memory, it has terrible cache locality, and is all-around slow.\n+    /// `RingBuf`, while\n+    /// > \"only\" amortized for push/pop, should be faster in the general case for\n+    /// almost every possible\n+    /// > workload, and isn't even amortized at all if you can predict the capacity\n+    /// you need.\n+    /// >\n+    /// > `LinkedList`s are only really good if you're doing a lot of merging or\n+    /// splitting of lists.\n+    /// > This is because they can just mangle some pointers instead of actually\n+    /// copying the data. Even\n+    /// > if you're doing a lot of insertion in the middle of the list, `RingBuf`\n+    /// can still be better\n+    /// > because of how expensive it is to seek to the middle of a `LinkedList`.\n+    ///\n+    /// **Known problems:** False positives \u2013 the instances where using a\n+    /// `LinkedList` makes sense are few and far between, but they can still happen.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = LinkedList::new();\n+    /// ```\n     pub LINKEDLIST,\n     pedantic,\n     \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\"\n }\n \n-/// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n-///\n-/// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more\n-/// general.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(bar: &Box<T>) { ... }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// fn foo(bar: &T) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more\n+    /// general.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// fn foo(bar: &Box<T>) { ... }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust,ignore\n+    /// fn foo(bar: &T) { ... }\n+    /// ```\n     pub BORROWED_BOX,\n     complexity,\n     \"a borrow of a boxed type\"\n@@ -175,9 +176,9 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n-        // skip trait implementations, see #605\n-        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent(id)) {\n+    fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: HirId) {\n+        // Skip trait implementations; see issue #605.\n+        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find_by_hir_id(cx.tcx.hir().get_parent_item(id)) {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n                 return;\n             }\n@@ -215,7 +216,7 @@ fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n     }\n }\n \n-/// Check if `qpath` has last segment with type parameter matching `path`\n+/// Checks if `qpath` has last segment with type parameter matching `path`\n fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n@@ -226,7 +227,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n             _ => None,\n         });\n         if let TyKind::Path(ref qpath) = ty.node;\n-        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir().node_to_hir_id(ty.id)));\n+        if let Some(did) = cx.tables.qpath_def(qpath, ty.hir_id).opt_def_id();\n         if match_def_path(cx.tcx, did, path);\n         then {\n             return true;\n@@ -247,9 +248,9 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n     }\n     match hir_ty.node {\n         TyKind::Path(ref qpath) if !is_local => {\n-            let hir_id = cx.tcx.hir().node_to_hir_id(hir_ty.id);\n+            let hir_id = hir_ty.hir_id;\n             let def = cx.tables.qpath_def(qpath, hir_id);\n-            if let Some(def_id) = opt_def_id(def) {\n+            if let Some(def_id) = def.opt_def_id() {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                     if match_type_parameter(cx, qpath, &paths::VEC) {\n                         span_help_and_lint(\n@@ -272,7 +273,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         // ty is now _ at this point\n                         if let TyKind::Path(ref ty_qpath) = ty.node;\n                         let def = cx.tables.qpath_def(ty_qpath, ty.hir_id);\n-                        if let Some(def_id) = opt_def_id(def);\n+                        if let Some(def_id) = def.opt_def_id();\n                         if Some(def_id) == cx.tcx.lang_items().owned_box();\n                         // At this point, we know ty is Box<T>, now get T\n                         if let Some(ref last) = last_path_segment(ty_qpath).args;\n@@ -376,10 +377,10 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n-            let hir_id = cx.tcx.hir().node_to_hir_id(mut_ty.ty.id);\n+            let hir_id = mut_ty.ty.hir_id;\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if_chain! {\n-                if let Some(def_id) = opt_def_id(def);\n+                if let Some(def_id) = def.opt_def_id();\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n                 if let QPath::Resolved(None, ref path) = *qpath;\n                 if let [ref bx] = *path.segments;\n@@ -391,7 +392,7 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt:\n                 });\n                 then {\n                     if is_any_trait(inner) {\n-                        // Ignore `Box<Any>` types, see #1884 for details.\n+                        // Ignore `Box<Any>` types; see issue #1884 for details.\n                         return;\n                     }\n \n@@ -447,20 +448,20 @@ fn is_any_trait(t: &hir::Ty) -> bool {\n \n pub struct LetPass;\n \n-/// **What it does:** Checks for binding a unit value.\n-///\n-/// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n-/// binding one is kind of pointless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = {\n-///     1;\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for binding a unit value.\n+    ///\n+    /// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n+    /// binding one is kind of pointless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = {\n+    ///     1;\n+    /// };\n+    /// ```\n     pub LET_UNIT_VALUE,\n     style,\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n@@ -500,33 +501,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetPass {\n     }\n }\n \n-/// **What it does:** Checks for comparisons to unit.\n-///\n-/// **Why is this bad?** Unit is always equal to itself, and thus is just a\n-/// clumsily written constant. Mostly this happens when someone accidentally\n-/// adds semicolons at the end of the operands.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if {\n-///     foo();\n-/// } == {\n-///     bar();\n-/// } {\n-///     baz();\n-/// }\n-/// ```\n-/// is equal to\n-/// ```rust\n-/// {\n-///     foo();\n-///     bar();\n-///     baz();\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons to unit.\n+    ///\n+    /// **Why is this bad?** Unit is always equal to itself, and thus is just a\n+    /// clumsily written constant. Mostly this happens when someone accidentally\n+    /// adds semicolons at the end of the operands.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if {\n+    ///     foo();\n+    /// } == {\n+    ///     bar();\n+    /// } {\n+    ///     baz();\n+    /// }\n+    /// ```\n+    /// is equal to\n+    /// ```ignore\n+    /// {\n+    ///     foo();\n+    ///     bar();\n+    ///     baz();\n+    /// }\n+    /// ```\n     pub UNIT_CMP,\n     correctness,\n     \"comparing unit values\"\n@@ -571,21 +572,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n     }\n }\n \n-/// **What it does:** Checks for passing a unit value as an argument to a function without using a\n-/// unit literal (`()`).\n-///\n-/// **Why is this bad?** This is likely the result of an accidental semicolon.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo({\n-///     let a = bar();\n-///     baz(a);\n-/// })\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for passing a unit value as an argument to a function without using a\n+    /// unit literal (`()`).\n+    ///\n+    /// **Why is this bad?** This is likely the result of an accidental semicolon.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo({\n+    ///     let a = bar();\n+    ///     baz(a);\n+    /// })\n+    /// ```\n     pub UNIT_ARG,\n     complexity,\n     \"passing unit to a function\"\n@@ -618,7 +619,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n         }\n         if_chain! {\n             let map = &cx.tcx.hir();\n-            let opt_parent_node = map.find(map.get_parent_node(expr.id));\n+            let opt_parent_node = map.find_by_hir_id(map.get_parent_node_by_hir_id(expr.hir_id));\n             if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n             if is_questionmark_desugar_marked_call(parent_expr);\n             then {\n@@ -678,216 +679,216 @@ fn is_unit_literal(expr: &Expr) -> bool {\n \n pub struct CastPass;\n \n-/// **What it does:** Checks for casts from any numerical to a float type where\n-/// the receiving type cannot store all values from the original type without\n-/// rounding errors. This possible rounding is to be expected, so this lint is\n-/// `Allow` by default.\n-///\n-/// Basically, this warns on casting any integer with 32 or more bits to `f32`\n-/// or any 64-bit integer to `f64`.\n-///\n-/// **Why is this bad?** It's not bad at all. But in some applications it can be\n-/// helpful to know where precision loss can take place. This lint can help find\n-/// those places in the code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = u64::MAX;\n-/// x as f64\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from any numerical to a float type where\n+    /// the receiving type cannot store all values from the original type without\n+    /// rounding errors. This possible rounding is to be expected, so this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n+    /// or any 64-bit integer to `f64`.\n+    ///\n+    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n+    /// helpful to know where precision loss can take place. This lint can help find\n+    /// those places in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = u64::MAX;\n+    /// x as f64\n+    /// ```\n     pub CAST_PRECISION_LOSS,\n     pedantic,\n-    \"casts that cause loss of precision, e.g. `x as f32` where `x: u64`\"\n+    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n }\n \n-/// **What it does:** Checks for casts from a signed to an unsigned numerical\n-/// type. In this case, negative values wrap around to large positive values,\n-/// which can be quite surprising in practice. However, as the cast works as\n-/// defined, this lint is `Allow` by default.\n-///\n-/// **Why is this bad?** Possibly surprising results. You can activate this lint\n-/// as a one-time check to see where numerical wrapping can arise.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y: i8 = -1;\n-/// y as u128 // will return 18446744073709551615\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n+    /// type. In this case, negative values wrap around to large positive values,\n+    /// which can be quite surprising in practice. However, as the cast works as\n+    /// defined, this lint is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n+    /// as a one-time check to see where numerical wrapping can arise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y: i8 = -1;\n+    /// y as u128 // will return 18446744073709551615\n+    /// ```\n     pub CAST_SIGN_LOSS,\n     pedantic,\n-    \"casts from signed types to unsigned types, e.g. `x as u32` where `x: i32`\"\n+    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n }\n \n-/// **What it does:** Checks for on casts between numerical types that may\n-/// truncate large values. This is expected behavior, so the cast is `Allow` by\n-/// default.\n-///\n-/// **Why is this bad?** In some problem domains, it is good practice to avoid\n-/// truncation. This lint can be activated to help assess where additional\n-/// checks could be beneficial.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn as_u8(x: u64) -> u8 {\n-///     x as u8\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for on casts between numerical types that may\n+    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n+    /// default.\n+    ///\n+    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n+    /// truncation. This lint can be activated to help assess where additional\n+    /// checks could be beneficial.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u8(x: u64) -> u8 {\n+    ///     x as u8\n+    /// }\n+    /// ```\n     pub CAST_POSSIBLE_TRUNCATION,\n     pedantic,\n-    \"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n }\n \n-/// **What it does:** Checks for casts from an unsigned type to a signed type of\n-/// the same size. Performing such a cast is a 'no-op' for the compiler,\n-/// i.e. nothing is changed at the bit level, and the binary representation of\n-/// the value is reinterpreted. This can cause wrapping if the value is too big\n-/// for the target signed type. However, the cast works as defined, so this lint\n-/// is `Allow` by default.\n-///\n-/// **Why is this bad?** While such a cast is not bad in itself, the results can\n-/// be surprising when this is not the intended behavior, as demonstrated by the\n-/// example below.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// u32::MAX as i32 // will yield a value of `-1`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n+    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n+    /// i.e., nothing is changed at the bit level, and the binary representation of\n+    /// the value is reinterpreted. This can cause wrapping if the value is too big\n+    /// for the target signed type. However, the cast works as defined, so this lint\n+    /// is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n+    /// be surprising when this is not the intended behavior, as demonstrated by the\n+    /// example below.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// u32::MAX as i32 // will yield a value of `-1`\n+    /// ```\n     pub CAST_POSSIBLE_WRAP,\n     pedantic,\n-    \"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` and `x > i32::MAX`\"\n+    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n }\n \n-/// **What it does:** Checks for on casts between numerical types that may\n-/// be replaced by safe conversion functions.\n-///\n-/// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n-/// conversions, including silently lossy conversions. Conversion functions such\n-/// as `i32::from` will only perform lossless conversions. Using the conversion\n-/// functions prevents conversions from turning into silent lossy conversions if\n-/// the types of the input expressions ever change, and make it easier for\n-/// people reading the code to know that the conversion is lossless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn as_u64(x: u8) -> u64 {\n-///     x as u64\n-/// }\n-/// ```\n-///\n-/// Using `::from` would look like this:\n-///\n-/// ```rust\n-/// fn as_u64(x: u8) -> u64 {\n-///     u64::from(x)\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for on casts between numerical types that may\n+    /// be replaced by safe conversion functions.\n+    ///\n+    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n+    /// conversions, including silently lossy conversions. Conversion functions such\n+    /// as `i32::from` will only perform lossless conversions. Using the conversion\n+    /// functions prevents conversions from turning into silent lossy conversions if\n+    /// the types of the input expressions ever change, and make it easier for\n+    /// people reading the code to know that the conversion is lossless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     x as u64\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `::from` would look like this:\n+    ///\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     u64::from(x)\n+    /// }\n+    /// ```\n     pub CAST_LOSSLESS,\n     complexity,\n-    \"casts using `as` that are known to be lossless, e.g. `x as u64` where `x: u8`\"\n+    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n }\n \n-/// **What it does:** Checks for casts to the same type.\n-///\n-/// **Why is this bad?** It's just unnecessary.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = 2i32 as i32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts to the same type.\n+    ///\n+    /// **Why is this bad?** It's just unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = 2i32 as i32\n+    /// ```\n     pub UNNECESSARY_CAST,\n     complexity,\n-    \"cast to the same type, e.g. `x as i32` where `x: i32`\"\n+    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n }\n \n-/// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n-/// more-strictly-aligned pointer\n-///\n-/// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n-/// behavior.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (&1u8 as *const u8) as *const u16;\n-/// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n+    /// more-strictly-aligned pointer\n+    ///\n+    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n+    /// behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (&1u8 as *const u8) as *const u16;\n+    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    /// ```\n     pub CAST_PTR_ALIGNMENT,\n     correctness,\n     \"cast from a pointer to a more-strictly-aligned pointer\"\n }\n \n-/// **What it does:** Checks for casts of function pointers to something other than usize\n-///\n-/// **Why is this bad?**\n-/// Casting a function pointer to anything other than usize/isize is not portable across\n-/// architectures, because you end up losing bits if the target type is too small or end up with a\n-/// bunch of extra bits that waste space and add more instructions to the final binary than\n-/// strictly necessary for the problem\n-///\n-/// Casting to isize also doesn't make sense since there are no signed addresses.\n-///\n-/// **Example**\n-///\n-/// ```rust\n-/// // Bad\n-/// fn fun() -> i32 {}\n-/// let a = fun as i64;\n-///\n-/// // Good\n-/// fn fun2() -> i32 {}\n-/// let a = fun2 as usize;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of function pointers to something other than usize\n+    ///\n+    /// **Why is this bad?**\n+    /// Casting a function pointer to anything other than usize/isize is not portable across\n+    /// architectures, because you end up losing bits if the target type is too small or end up with a\n+    /// bunch of extra bits that waste space and add more instructions to the final binary than\n+    /// strictly necessary for the problem\n+    ///\n+    /// Casting to isize also doesn't make sense since there are no signed addresses.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```ignore\n+    /// // Bad\n+    /// fn fun() -> i32 {}\n+    /// let a = fun as i64;\n+    ///\n+    /// // Good\n+    /// fn fun2() -> i32 {}\n+    /// let a = fun2 as usize;\n+    /// ```\n     pub FN_TO_NUMERIC_CAST,\n     style,\n     \"casting a function pointer to a numeric type other than usize\"\n }\n \n-/// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n-/// store address.\n-///\n-/// **Why is this bad?**\n-/// Such a cast discards some bits of the function's address. If this is intended, it would be more\n-/// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n-/// a comment) to perform the truncation.\n-///\n-/// **Example**\n-///\n-/// ```rust\n-/// // Bad\n-/// fn fn1() -> i16 {\n-///     1\n-/// };\n-/// let _ = fn1 as i32;\n-///\n-/// // Better: Cast to usize first, then comment with the reason for the truncation\n-/// fn fn2() -> i16 {\n-///     1\n-/// };\n-/// let fn_ptr = fn2 as usize;\n-/// let fn_ptr_truncated = fn_ptr as i32;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n+    /// store address.\n+    ///\n+    /// **Why is this bad?**\n+    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n+    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+    /// a comment) to perform the truncation.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fn1() -> i16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn1 as i32;\n+    ///\n+    /// // Better: Cast to usize first, then comment with the reason for the truncation\n+    /// fn fn2() -> i16 {\n+    ///     1\n+    /// };\n+    /// let fn_ptr = fn2 as usize;\n+    /// let fn_ptr_truncated = fn_ptr as i32;\n+    /// ```\n     pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     style,\n     \"casting a function pointer to a numeric type not wide enough to store the address\"\n@@ -962,7 +963,7 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n \n fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n-    if in_constant(cx, expr.id) {\n+    if in_constant(cx, expr.hir_id) {\n         return;\n     }\n     // The suggestion is to use a function call, so if the original expression\n@@ -1288,21 +1289,21 @@ fn lint_fn_to_numeric_cast(\n     }\n }\n \n-/// **What it does:** Checks for types used in structs, parameters and `let`\n-/// declarations above a certain complexity threshold.\n-///\n-/// **Why is this bad?** Too complex types make the code less readable. Consider\n-/// using a `type` definition to simplify them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo {\n-///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types used in structs, parameters and `let`\n+    /// declarations above a certain complexity threshold.\n+    ///\n+    /// **Why is this bad?** Too complex types make the code less readable. Consider\n+    /// using a `type` definition to simplify them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo {\n+    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+    /// }\n+    /// ```\n     pub TYPE_COMPLEXITY,\n     complexity,\n     \"usage of very complex types that might be better factored into `type` definitions\"\n@@ -1336,7 +1337,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         decl: &'tcx FnDecl,\n         _: &'tcx Body,\n         _: Span,\n-        _: NodeId,\n+        _: HirId,\n     ) {\n         self.check_fndecl(cx, decl);\n     }\n@@ -1457,28 +1458,28 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-/// **What it does:** Checks for expressions where a character literal is cast\n-/// to `u8` and suggests using a byte literal instead.\n-///\n-/// **Why is this bad?** In general, casting values to smaller types is\n-/// error-prone and should be avoided where possible. In the particular case of\n-/// converting a character literal to u8, it is easy to avoid by just using a\n-/// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n-/// than `'a' as u8`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 'x' as u8\n-/// ```\n-///\n-/// A better version, using the byte literal:\n-///\n-/// ```rust\n-/// b'x'\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where a character literal is cast\n+    /// to `u8` and suggests using a byte literal instead.\n+    ///\n+    /// **Why is this bad?** In general, casting values to smaller types is\n+    /// error-prone and should be avoided where possible. In the particular case of\n+    /// converting a character literal to u8, it is easy to avoid by just using a\n+    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+    /// than `'a' as u8`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 'x' as u8\n+    /// ```\n+    ///\n+    /// A better version, using the byte literal:\n+    ///\n+    /// ```rust\n+    /// b'x'\n+    /// ```\n     pub CHAR_LIT_AS_U8,\n     complexity,\n     \"casting a character literal to u8\"\n@@ -1519,28 +1520,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     }\n }\n \n-/// **What it does:** Checks for comparisons where one side of the relation is\n-/// either the minimum or maximum value for its type and warns if it involves a\n-/// case that is always true or always false. Only integer and boolean types are\n-/// checked.\n-///\n-/// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n-/// that is is possible for `x` to be less than the minimum. Expressions like\n-/// `max < x` are probably mistakes.\n-///\n-/// **Known problems:** For `usize` the size of the current compile target will\n-/// be assumed (e.g. 64 bits on 64 bit systems). This means code that uses such\n-/// a comparison to detect target pointer width will trigger this lint. One can\n-/// use `mem::sizeof` and compare its value or conditional compilation\n-/// attributes\n-/// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-///\n-/// **Example:**\n-/// ```rust\n-/// vec.len() <= 0\n-/// 100 > std::i32::MAX\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+    /// that is is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// **Known problems:** For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// vec.len() <= 0\n+    /// 100 > std::i32::MAX\n+    /// ```\n     pub ABSURD_EXTREME_COMPARISONS,\n     correctness,\n     \"a comparison with a maximum or minimum value that is always true or false\"\n@@ -1704,22 +1705,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n     }\n }\n \n-/// **What it does:** Checks for comparisons where the relation is always either\n-/// true or false, but where one side has been upcast so that the comparison is\n-/// necessary. Only integer types are checked.\n-///\n-/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n-/// will mistakenly imply that it is possible for `x` to be outside the range of\n-/// `u8`.\n-///\n-/// **Known problems:**\n-/// https://github.com/rust-lang/rust-clippy/issues/886\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x : u8 = ...; (x as u32) > 300\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where the relation is always either\n+    /// true or false, but where one side has been upcast so that the comparison is\n+    /// necessary. Only integer types are checked.\n+    ///\n+    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+    /// will mistakenly imply that it is possible for `x` to be outside the range of\n+    /// `u8`.\n+    ///\n+    /// **Known problems:**\n+    /// https://github.com/rust-lang/rust-clippy/issues/886\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x : u8 = ...; (x as u32) > 300\n+    /// ```\n     pub INVALID_UPCAST_COMPARISONS,\n     pedantic,\n     \"a comparison involving an upcast which is always true or false\"\n@@ -1949,24 +1950,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     }\n }\n \n-/// **What it does:** Checks for public `impl` or `fn` missing generalization\n-/// over different hashers and implicitly defaulting to the default hashing\n-/// algorithm (SipHash).\n-///\n-/// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n-/// used with them.\n-///\n-/// **Known problems:** Suggestions for replacing constructors can contain\n-/// false-positives. Also applying suggestions can require modification of other\n-/// pieces of code, possibly including external crates.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n-///\n-/// pub foo(map: &mut HashMap<i32, i32>) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n+    /// over different hashers and implicitly defaulting to the default hashing\n+    /// algorithm (SipHash).\n+    ///\n+    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+    /// used with them.\n+    ///\n+    /// **Known problems:** Suggestions for replacing constructors can contain\n+    /// false-positives. Also applying suggestions can require modification of other\n+    /// pieces of code, possibly including external crates.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n+    ///\n+    /// pub foo(map: &mut HashMap<i32, i32>) { .. }\n+    /// ```\n     pub IMPLICIT_HASHER,\n     style,\n     \"missing generalization over different hashers\"\n@@ -2035,7 +2036,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(item.hir_id)) {\n             return;\n         }\n \n@@ -2293,33 +2294,33 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n     }\n }\n \n-/// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n-///\n-/// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n-/// `UnsafeCell` is the only way to obtain aliasable data that is considered\n-/// mutable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn x(r: &i32) {\n-///     unsafe {\n-///         *(r as *const _ as *mut _) += 1;\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead consider using interior mutability types.\n-///\n-/// ```rust\n-/// fn x(r: &UnsafeCell<i32>) {\n-///     unsafe {\n-///         *r.get() += 1;\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n+    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n+    /// mutable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// fn x(r: &i32) {\n+    ///     unsafe {\n+    ///         *(r as *const _ as *mut _) += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead consider using interior mutability types.\n+    ///\n+    /// ```ignore\n+    /// fn x(r: &UnsafeCell<i32>) {\n+    ///     unsafe {\n+    ///         *r.get() += 1;\n+    ///     }\n+    /// }\n+    /// ```\n     pub CAST_REF_TO_MUT,\n     correctness,\n     \"a cast of reference to a mutable pointer\""}, {"sha": "4d9e2f18650ea3ca5dc9a8276cbe4a8b5d9b4101", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -2,57 +2,57 @@ use crate::utils::{is_allowed, snippet, span_help_and_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::{LitKind, NodeId};\n+use syntax::ast::LitKind;\n use syntax::source_map::Span;\n use unicode_normalization::UnicodeNormalization;\n \n-/// **What it does:** Checks for the Unicode zero-width space in the code.\n-///\n-/// **Why is this bad?** Having an invisible character in the code makes for all\n-/// sorts of April fools, but otherwise is very much frowned upon.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** You don't see it, but there may be a zero-width space\n-/// somewhere in this text.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the Unicode zero-width space in the code.\n+    ///\n+    /// **Why is this bad?** Having an invisible character in the code makes for all\n+    /// sorts of April fools, but otherwise is very much frowned upon.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** You don't see it, but there may be a zero-width space\n+    /// somewhere in this text.\n     pub ZERO_WIDTH_SPACE,\n     correctness,\n     \"using a zero-width space in a string literal, which is confusing\"\n }\n \n-/// **What it does:** Checks for non-ASCII characters in string literals.\n-///\n-/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset\n-/// back. Even so, there still are editors and other programs out there that\n-/// don't work well with Unicode. So if the code is meant to be used\n-/// internationally, on multiple operating systems, or has other portability\n-/// requirements, activating this lint could be useful.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = \"H\u00e4?\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for non-ASCII characters in string literals.\n+    ///\n+    /// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset\n+    /// back. Even so, there still are editors and other programs out there that\n+    /// don't work well with Unicode. So if the code is meant to be used\n+    /// internationally, on multiple operating systems, or has other portability\n+    /// requirements, activating this lint could be useful.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = \"H\u00e4?\"\n+    /// ```\n     pub NON_ASCII_LITERAL,\n     pedantic,\n     \"using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape\"\n }\n \n-/// **What it does:** Checks for string literals that contain Unicode in a form\n-/// that is not equal to its\n-/// [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n-///\n-/// **Why is this bad?** If such a string is compared to another, the results\n-/// may be surprising.\n-///\n-/// **Known problems** None.\n-///\n-/// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n-/// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string literals that contain Unicode in a form\n+    /// that is not equal to its\n+    /// [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n+    ///\n+    /// **Why is this bad?** If such a string is compared to another, the results\n+    /// may be surprising.\n+    ///\n+    /// **Known problems** None.\n+    ///\n+    /// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n+    /// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n     pub UNICODE_NOT_NFC,\n     pedantic,\n     \"using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\"\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Lit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n-                check_str(cx, lit.span, expr.id)\n+                check_str(cx, lit.span, expr.hir_id)\n             }\n         }\n     }\n@@ -95,7 +95,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n+fn check_str(cx: &LateContext<'_, '_>, span: Span, id: HirId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint("}, {"sha": "68ceaaac8a31432416cb38c6540494c13357221b", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,22 +5,22 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n-/// name.\n-///\n-/// **Why is this bad?** Renaming makes it less clear which traits and\n-/// structures are unsafe.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// use std::cell::{UnsafeCell as TotallySafeCell};\n-///\n-/// extern crate crossbeam;\n-/// use crossbeam::{spawn_unsafe as spawn};\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n+    /// name.\n+    ///\n+    /// **Why is this bad?** Renaming makes it less clear which traits and\n+    /// structures are unsafe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// use std::cell::{UnsafeCell as TotallySafeCell};\n+    ///\n+    /// extern crate crossbeam;\n+    /// use crossbeam::{spawn_unsafe as spawn};\n+    /// ```\n     pub UNSAFE_REMOVED_FROM_NAME,\n     style,\n     \"`unsafe` removed from API names on import\""}, {"sha": "bf31b774bba24fd66c9f50c5de431805a3253f65", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,28 +3,28 @@ use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for unused written/read amount.\n-///\n-/// **Why is this bad?** `io::Write::write` and `io::Read::read` are not\n-/// guaranteed to\n-/// process the entire buffer. They return how many bytes were processed, which\n-/// might be smaller\n-/// than a given buffer's length. If you don't need to deal with\n-/// partial-write/read, use\n-/// `write_all`/`read_exact` instead.\n-///\n-/// **Known problems:** Detects only common patterns.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// use std::io;\n-/// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n-///     // must be `w.write_all(b\"foo\")?;`\n-///     w.write(b\"foo\")?;\n-///     Ok(())\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unused written/read amount.\n+    ///\n+    /// **Why is this bad?** `io::Write::write` and `io::Read::read` are not\n+    /// guaranteed to\n+    /// process the entire buffer. They return how many bytes were processed, which\n+    /// might be smaller\n+    /// than a given buffer's length. If you don't need to deal with\n+    /// partial-write/read, use\n+    /// `write_all`/`read_exact` instead.\n+    ///\n+    /// **Known problems:** Detects only common patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// use std::io;\n+    /// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n+    ///     // must be `w.write_all(b\"foo\")?;`\n+    ///     w.write(b\"foo\")?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n     pub UNUSED_IO_AMOUNT,\n     correctness,\n     \"unused written/read amount\"\n@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n         };\n \n         match expr.node {\n-            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n+            hir::ExprKind::Match(ref res, _, _) if is_try(cx, expr).is_some() => {\n                 if let hir::ExprKind::Call(ref func, ref args) = res.node {\n                     if let hir::ExprKind::Path(ref path) = func.node {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {"}, {"sha": "d92511d999fb392b9171a11f36e3fefc8f8f9a3b", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -4,25 +4,24 @@ use rustc::hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visit\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for unused labels.\n-///\n-/// **Why is this bad?** Maybe the label should be used in which case there is\n-/// an error in the code or it should be removed.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// fn unused_label() {\n-///     'label: for i in 1..2 {\n-///         if i > 4 { continue }\n-///     }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unused labels.\n+    ///\n+    /// **Why is this bad?** Maybe the label should be used in which case there is\n+    /// an error in the code or it should be removed.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// fn unused_label() {\n+    ///     'label: for i in 1..2 {\n+    ///         if i > 4 { continue }\n+    ///     }\n+    /// ```\n     pub UNUSED_LABEL,\n     complexity,\n     \"unused labels\"\n@@ -53,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n         span: Span,\n-        fn_id: ast::NodeId,\n+        fn_id: hir::HirId,\n     ) {\n         if in_macro(span) {\n             return;"}, {"sha": "6b77e0f16faa0981a99bb3312c8693179451cbef", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,51 +5,50 @@ use rustc::{declare_tool_lint, lint_array};\n use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n use rustc::hir::intravisit::*;\n use rustc::hir::*;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n-///\n-/// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n-///\n-/// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_some() {\n-///     do_something_with(option.unwrap())\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if let Some(value) = option {\n-///     do_something_with(value)\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n+    ///\n+    /// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n+    ///\n+    /// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if option.is_some() {\n+    ///     do_something_with(option.unwrap())\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if let Some(value) = option {\n+    ///     do_something_with(value)\n+    /// }\n+    /// ```\n     pub UNNECESSARY_UNWRAP,\n     nursery,\n     \"checks for calls of unwrap[_err]() that cannot fail\"\n }\n \n-/// **What it does:** Checks for calls of `unwrap[_err]()` that will always fail.\n-///\n-/// **Why is this bad?** If panicking is desired, an explicit `panic!()` should be used.\n-///\n-/// **Known problems:** This lint only checks `if` conditions not assignments.\n-/// So something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_none() {\n-///     do_something_with(option.unwrap())\n-/// }\n-/// ```\n-///\n-/// This code will always panic. The if condition should probably be inverted.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `unwrap[_err]()` that will always fail.\n+    ///\n+    /// **Why is this bad?** If panicking is desired, an explicit `panic!()` should be used.\n+    ///\n+    /// **Known problems:** This lint only checks `if` conditions not assignments.\n+    /// So something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if option.is_none() {\n+    ///     do_something_with(option.unwrap())\n+    /// }\n+    /// ```\n+    ///\n+    /// This code will always panic. The if condition should probably be inverted.\n     pub PANICKING_UNWRAP,\n     nursery,\n     \"checks for calls of unwrap[_err]() that will always fail\"\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        fn_id: NodeId,\n+        fn_id: HirId,\n     ) {\n         if in_macro(span) {\n             return;"}, {"sha": "a2fc8bcc4a6e37629813cf028fbc2dc6c873fd23", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::span_lint_and_sugg;\n use if_chain::if_chain;\n use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Visitor};\n@@ -9,36 +8,38 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax_pos::symbol::keywords::SelfUpper;\n \n-/// **What it does:** Checks for unnecessary repetition of structure name when a\n-/// replacement with `Self` is applicable.\n-///\n-/// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct\n-/// name\n-/// feels inconsistent.\n-///\n-/// **Known problems:**\n-/// - False positive when using associated types (#2843)\n-/// - False positives in some situations when using generics (#3410)\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo {}\n-/// impl Foo {\n-///     fn new() -> Foo {\n-///         Foo {}\n-///     }\n-/// }\n-/// ```\n-/// could be\n-/// ```rust\n-/// struct Foo {}\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Self {}\n-///     }\n-/// }\n-/// ```\n+use crate::utils::span_lint_and_sugg;\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary repetition of structure name when a\n+    /// replacement with `Self` is applicable.\n+    ///\n+    /// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct\n+    /// name\n+    /// feels inconsistent.\n+    ///\n+    /// **Known problems:**\n+    /// - False positive when using associated types (#2843)\n+    /// - False positives in some situations when using generics (#3410)\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo {}\n+    /// impl Foo {\n+    ///     fn new() -> Foo {\n+    ///         Foo {}\n+    ///     }\n+    /// }\n+    /// ```\n+    /// could be\n+    /// ```rust\n+    /// struct Foo {}\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Self {}\n+    ///     }\n+    /// }\n+    /// ```\n     pub USE_SELF,\n     pedantic,\n     \"Unnecessary structure name repetition whereas `Self` is applicable\"\n@@ -60,9 +61,9 @@ impl LintPass for UseSelf {\n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n-    // path segments only include actual path, no methods or fields\n+    // Path segments only include actual path, no methods or fields.\n     let last_path_span = path.segments.last().expect(SEGMENTS_MSG).ident.span;\n-    // only take path up to the end of last_path_span\n+    // Only take path up to the end of last_path_span.\n     let span = path.span.with_hi(last_path_span.hi());\n \n     span_lint_and_sugg(\n@@ -137,7 +138,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n     let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n     let trait_method_sig = cx.tcx.erase_late_bound_regions(&trait_method_sig);\n \n-    let impl_method_def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+    let impl_method_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n     let impl_method_sig = cx.tcx.fn_sig(impl_method_def_id);\n     let impl_method_sig = cx.tcx.erase_late_bound_regions(&impl_method_sig);\n \n@@ -149,7 +150,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n \n     // `impl_decl_ty` (of type `hir::Ty`) represents the type declared in the signature.\n     // `impl_ty` (of type `ty:TyS`) is the concrete type that the compiler has determined for\n-    // that declaration.  We use `impl_decl_ty` to see if the type was declared as `Self`\n+    // that declaration. We use `impl_decl_ty` to see if the type was declared as `Self`\n     // and use `impl_ty` to check its concrete type.\n     for (impl_decl_ty, (impl_ty, trait_ty)) in impl_decl.inputs.iter().chain(output_ty).zip(\n         impl_method_sig\n@@ -192,7 +193,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+                    let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                     let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {"}, {"sha": "fbd36ba71dec43d1ffcab2ac057f2fc14cd0cf31", "filename": "clippy_lints/src/utils/attrs.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,109 @@\n+use rustc::session::Session;\n+use rustc_errors::Applicability;\n+use std::str::FromStr;\n+use syntax::ast;\n+\n+/// Deprecation status of attributes known by Clippy.\n+#[allow(dead_code)]\n+pub enum DeprecationStatus {\n+    /// Attribute is deprecated\n+    Deprecated,\n+    /// Attribute is deprecated and was replaced by the named attribute\n+    Replaced(&'static str),\n+    None,\n+}\n+\n+pub const BUILTIN_ATTRIBUTES: &[(&str, DeprecationStatus)] = &[\n+    (\"author\", DeprecationStatus::None),\n+    (\"cognitive_complexity\", DeprecationStatus::None),\n+    (\n+        \"cyclomatic_complexity\",\n+        DeprecationStatus::Replaced(\"cognitive_complexity\"),\n+    ),\n+    (\"dump\", DeprecationStatus::None),\n+];\n+\n+pub struct LimitStack {\n+    stack: Vec<u64>,\n+}\n+\n+impl Drop for LimitStack {\n+    fn drop(&mut self) {\n+        assert_eq!(self.stack.len(), 1);\n+    }\n+}\n+\n+impl LimitStack {\n+    pub fn new(limit: u64) -> Self {\n+        Self { stack: vec![limit] }\n+    }\n+    pub fn limit(&self) -> u64 {\n+        *self.stack.last().expect(\"there should always be a value in the stack\")\n+    }\n+    pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(sess, attrs, name, |val| stack.push(val));\n+    }\n+    pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(sess, attrs, name, |val| assert_eq!(stack.pop(), Some(val)));\n+    }\n+}\n+\n+pub fn get_attr<'a>(\n+    sess: &'a Session,\n+    attrs: &'a [ast::Attribute],\n+    name: &'static str,\n+) -> impl Iterator<Item = &'a ast::Attribute> {\n+    attrs.iter().filter(move |attr| {\n+        let attr_segments = &attr.path.segments;\n+        if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n+            if let Some(deprecation_status) = BUILTIN_ATTRIBUTES\n+                .iter()\n+                .find(|(builtin_name, _)| *builtin_name == attr_segments[1].ident.to_string())\n+                .map(|(_, deprecation_status)| deprecation_status)\n+            {\n+                let mut db = sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                match deprecation_status {\n+                    DeprecationStatus::Deprecated => {\n+                        db.emit();\n+                        false\n+                    },\n+                    DeprecationStatus::Replaced(new_name) => {\n+                        db.span_suggestion(\n+                            attr_segments[1].ident.span,\n+                            \"consider using\",\n+                            new_name.to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        db.emit();\n+                        false\n+                    },\n+                    DeprecationStatus::None => {\n+                        db.cancel();\n+                        attr_segments[1].ident.to_string() == name\n+                    },\n+                }\n+            } else {\n+                sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n+    for attr in get_attr(sess, attrs, name) {\n+        if let Some(ref value) = attr.value_str() {\n+            if let Ok(value) = FromStr::from_str(&value.as_str()) {\n+                f(value)\n+            } else {\n+                sess.span_err(attr.span, \"not a number\");\n+            }\n+        } else {\n+            sess.span_err(attr.span, \"bad clippy attribute\");\n+        }\n+    }\n+}"}, {"sha": "d0b7dd7e8089a66213c68608c160f94793fd6ae5", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,43 +5,44 @@ use crate::utils::get_attr;\n use rustc::hir;\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::{BindingAnnotation, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::session::Session;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast::{Attribute, LitKind, DUMMY_NODE_ID};\n+use syntax::ast::{Attribute, LitKind};\n \n-/// **What it does:** Generates clippy code that detects the offending pattern\n-///\n-/// **Example:**\n-/// ```rust\n-/// // ./tests/ui/my_lint.rs\n-/// fn foo() {\n-///     // detect the following pattern\n-///     #[clippy::author]\n-///     if x == 42 {\n-///         // but ignore everything from here on\n-///         #![clippy::author = \"ignore\"]\n-///     }\n-/// }\n-/// ```\n-///\n-/// Running `TESTNAME=ui/my_lint cargo uitest` will produce\n-/// a `./tests/ui/new_lint.stdout` file with the generated code:\n-///\n-/// ```rust\n-/// // ./tests/ui/new_lint.stdout\n-/// if_chain! {\n-///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n-///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     if let ExprKind::Path(ref path) = left.node,\n-///     if let ExprKind::Lit(ref lit) = right.node,\n-///     if let LitKind::Int(42, _) = lit.node,\n-///     then {\n-///         // report your lint here\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Generates clippy code that detects the offending pattern\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // ./tests/ui/my_lint.rs\n+    /// fn foo() {\n+    ///     // detect the following pattern\n+    ///     #[clippy::author]\n+    ///     if x == 42 {\n+    ///         // but ignore everything from here on\n+    ///         #![clippy::author = \"ignore\"]\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Running `TESTNAME=ui/my_lint cargo uitest` will produce\n+    /// a `./tests/ui/new_lint.stdout` file with the generated code:\n+    ///\n+    /// ```rust\n+    /// // ./tests/ui/new_lint.stdout\n+    /// if_chain! {\n+    ///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n+    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n+    ///     if let ExprKind::Path(ref path) = left.node,\n+    ///     if let ExprKind::Lit(ref lit) = right.node,\n+    ///     if let LitKind::Int(42, _) = lit.node,\n+    ///     then {\n+    ///         // report your lint here\n+    ///     }\n+    /// }\n+    /// ```\n     pub LINT_AUTHOR,\n     internal_warn,\n     \"helper for writing lints\"\n@@ -71,80 +72,80 @@ fn done() {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if !has_attr(&item.attrs) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_item(item);\n         done();\n     }\n \n-    fn check_impl_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_impl_item(item);\n         done();\n     }\n \n-    fn check_trait_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_trait_item(item);\n         done();\n     }\n \n-    fn check_variant(&mut self, _cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, generics: &hir::Generics) {\n-        if !has_attr(&var.node.attrs) {\n+    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, generics: &hir::Generics) {\n+        if !has_attr(cx.sess(), &var.node.attrs) {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"var\").visit_variant(var, generics, DUMMY_NODE_ID);\n+        PrintVisitor::new(\"var\").visit_variant(var, generics, hir::DUMMY_HIR_ID);\n         done();\n     }\n \n-    fn check_struct_field(&mut self, _cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n-        if !has_attr(&field.attrs) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n+        if !has_attr(cx.sess(), &field.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"field\").visit_struct_field(field);\n         done();\n     }\n \n-    fn check_expr(&mut self, _cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if !has_attr(&expr.attrs) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+        if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"expr\").visit_expr(expr);\n         done();\n     }\n \n-    fn check_arm(&mut self, _cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-        if !has_attr(&arm.attrs) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+        if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"arm\").visit_arm(arm);\n         done();\n     }\n \n-    fn check_stmt(&mut self, _cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(stmt.node.attrs()) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+        if !has_attr(cx.sess(), stmt.node.attrs()) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"stmt\").visit_stmt(stmt);\n         done();\n     }\n \n-    fn check_foreign_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n@@ -638,7 +639,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"Local(ref {}) = {};\", local_pat, current);\n                 if let Some(ref init) = local.init {\n                     let init_pat = self.next(\"init\");\n-                    println!(\"    if let Some(ref {}) = {}.init\", init_pat, local_pat);\n+                    println!(\"    if let Some(ref {}) = {}.init;\", init_pat, local_pat);\n                     self.current = init_pat;\n                     self.visit_expr(init);\n                 }\n@@ -673,8 +674,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n }\n \n-fn has_attr(attrs: &[Attribute]) -> bool {\n-    get_attr(attrs, \"author\").count() > 0\n+fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n+    get_attr(sess, attrs, \"author\").count() > 0\n }\n \n fn desugaring_name(des: hir::MatchSource) -> String {"}, {"sha": "5b124dd96bf2e46a742efe082a6481efd563a404", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,5 +1,4 @@\n-/// Return the index of the character after the first camel-case component of\n-/// `s`.\n+/// Returns the index of the character after the first camel-case component of `s`.\n pub fn until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n@@ -32,7 +31,7 @@ pub fn until(s: &str) -> usize {\n     }\n }\n \n-/// Return index of the last camel-case component of `s`.\n+/// Returns index of the last camel-case component of `s`.\n pub fn from(s: &str) -> usize {\n     let mut iter = s.char_indices().rev();\n     if let Some((_, first)) = iter.next() {"}, {"sha": "64243203b7ff95922f03bba317b7f67a35e93830", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -10,7 +10,7 @@ use std::{env, fmt, fs, io, path};\n use syntax::{ast, source_map};\n use toml;\n \n-/// Get the configuration file from arguments.\n+/// Gets the configuration file from arguments.\n pub fn file_from_args(\n     args: &[source_map::Spanned<ast::NestedMetaItemKind>],\n ) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n@@ -110,8 +110,10 @@ macro_rules! define_Conf {\n define_Conf! {\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about\n     (blacklisted_names, \"blacklisted_names\", [\"foo\", \"bar\", \"baz\", \"quux\"] => Vec<String>),\n-    /// Lint: CYCLOMATIC_COMPLEXITY. The maximum cyclomatic complexity a function can have\n-    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\", 25 => u64),\n+    /// Lint: COGNITIVE_COMPLEXITY. The maximum cognitive complexity a function can have\n+    (cognitive_complexity_threshold, \"cognitive_complexity_threshold\", 25 => u64),\n+    /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY. Use the Cognitive Complexity lint instead.\n+    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\", None => Option<u64>),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n     (doc_valid_idents, \"doc_valid_idents\", [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n@@ -227,13 +229,24 @@ pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n \n     assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n     match toml::from_str(&file) {\n-        Ok(toml) => (\n-            toml,\n-            ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0),\n-        ),\n+        Ok(toml) => {\n+            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n+\n+            let toml_ref: &Conf = &toml;\n+\n+            let cyc_field: Option<u64> = toml_ref.cyclomatic_complexity_threshold;\n+\n+            if cyc_field.is_some() {\n+                let cyc_err = \"found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\".to_string();\n+                errors.push(Error::Toml(cyc_err));\n+            }\n+\n+            (toml, errors)\n+        },\n         Err(e) => {\n             let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n             errors.push(Error::Toml(e.to_string()));\n+\n             default(errors)\n         },\n     }"}, {"sha": "6d04ce70bc434abbcb1936bb04af3c6fdc9e5ddb", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,205 @@\n+//! Clippy wrappers around rustc's diagnostic functions.\n+\n+use rustc::hir::HirId;\n+use rustc::lint::{LateContext, Lint, LintContext};\n+use rustc_errors::{Applicability, CodeSuggestion, Substitution, SubstitutionPart, SuggestionStyle};\n+use std::env;\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::source_map::Span;\n+\n+/// Wrapper around `DiagnosticBuilder` that adds a link to Clippy documentation for the emitted lint\n+struct DiagnosticWrapper<'a>(DiagnosticBuilder<'a>);\n+\n+impl<'a> Drop for DiagnosticWrapper<'a> {\n+    fn drop(&mut self) {\n+        self.0.emit();\n+    }\n+}\n+\n+impl<'a> DiagnosticWrapper<'a> {\n+    fn docs_link(&mut self, lint: &'static Lint) {\n+        if env::var(\"CLIPPY_DISABLE_DOCS_LINKS\").is_err() {\n+            self.0.help(&format!(\n+                \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n+                &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n+                    // extract just major + minor version and ignore patch versions\n+                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n+                }),\n+                lint.name_lower().replacen(\"clippy::\", \"\", 1)\n+            ));\n+        }\n+    }\n+}\n+\n+/// Emit a basic lint message with a `msg` and a `span`.\n+///\n+/// This is the most primitive of our lint emission methods and can\n+/// be a good way to get a new lint started.\n+///\n+/// Usually it's nicer to provide more context for lint messages.\n+/// Be sure the output is understandable when you use this method.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// error: usage of mem::forget on Drop type\n+///   --> $DIR/mem_forget.rs:17:5\n+///    |\n+/// 17 |     std::mem::forget(seven);\n+///    |     ^^^^^^^^^^^^^^^^^^^^^^^\n+/// ```\n+pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+    DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg)).docs_link(lint);\n+}\n+\n+/// Same as `span_lint` but with an extra `help` message.\n+///\n+/// Use this if you want to provide some general help but\n+/// can't provide a specific machine applicable suggestion.\n+///\n+/// The `help` message is not attached to any `Span`.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// error: constant division of 0.0 with 0.0 will always result in NaN\n+///   --> $DIR/zero_div_zero.rs:6:25\n+///    |\n+/// 6  |     let other_f64_nan = 0.0f64 / 0.0;\n+///    |                         ^^^^^^^^^^^^\n+///    |\n+///    = help: Consider using `std::f64::NAN` if you would like a constant representing NaN\n+/// ```\n+pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    help: &str,\n+) {\n+    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n+    db.0.help(help);\n+    db.docs_link(lint);\n+}\n+\n+/// Like `span_lint` but with a `note` section instead of a `help` message.\n+///\n+/// The `note` message is presented separately from the main lint message\n+/// and is attached to a specific span:\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+///   --> $DIR/drop_forget_ref.rs:10:5\n+///    |\n+/// 10 |     forget(&SomeStruct);\n+///    |     ^^^^^^^^^^^^^^^^^^^\n+///    |\n+///    = note: `-D clippy::forget-ref` implied by `-D warnings`\n+/// note: argument has type &SomeStruct\n+///   --> $DIR/drop_forget_ref.rs:10:12\n+///    |\n+/// 10 |     forget(&SomeStruct);\n+///    |            ^^^^^^^^^^^\n+/// ```\n+pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    note_span: Span,\n+    note: &str,\n+) {\n+    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n+    if note_span == span {\n+        db.0.note(note);\n+    } else {\n+        db.0.span_note(note_span, note);\n+    }\n+    db.docs_link(lint);\n+}\n+\n+pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    sp: Span,\n+    msg: &str,\n+    f: F,\n+) where\n+    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n+{\n+    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n+    f(&mut db.0);\n+    db.docs_link(lint);\n+}\n+\n+pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: HirId, sp: Span, msg: &str) {\n+    DiagnosticWrapper(cx.tcx.struct_span_lint_hir(lint, node, sp, msg)).docs_link(lint);\n+}\n+\n+pub fn span_lint_node_and_then(\n+    cx: &LateContext<'_, '_>,\n+    lint: &'static Lint,\n+    node: HirId,\n+    sp: Span,\n+    msg: &str,\n+    f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n+) {\n+    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_hir(lint, node, sp, msg));\n+    f(&mut db.0);\n+    db.docs_link(lint);\n+}\n+\n+/// Add a span lint with a suggestion on how to fix it.\n+///\n+/// These suggestions can be parsed by rustfix to allow it to automatically fix your code.\n+/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n+/// 2)\"`.\n+///\n+/// ```ignore\n+/// error: This `.fold` can be more succinctly expressed as `.any`\n+/// --> $DIR/methods.rs:390:13\n+///     |\n+/// 390 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+///     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n+///     |\n+///     = note: `-D fold-any` implied by `-D warnings`\n+/// ```\n+pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    sp: Span,\n+    msg: &str,\n+    help: &str,\n+    sugg: String,\n+    applicability: Applicability,\n+) {\n+    span_lint_and_then(cx, lint, sp, msg, |db| {\n+        db.span_suggestion(sp, help, sugg, applicability);\n+    });\n+}\n+\n+/// Create a suggestion made from several `span \u2192 replacement`.\n+///\n+/// Note: in the JSON format (used by `compiletest_rs`), the help message will\n+/// appear once per\n+/// replacement. In human-readable format though, it only appears once before\n+/// the whole suggestion.\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n+where\n+    I: IntoIterator<Item = (Span, String)>,\n+{\n+    let sugg = CodeSuggestion {\n+        substitutions: vec![Substitution {\n+            parts: sugg\n+                .into_iter()\n+                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                .collect(),\n+        }],\n+        msg: help_msg,\n+        style: SuggestionStyle::ShowCode,\n+        applicability: Applicability::Unspecified,\n+    };\n+    db.suggestions.push(sugg);\n+}"}, {"sha": "bb4c18ea2bb6a1bfc22a3010f6d2a983df393e81", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,13 +3,13 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, resolve_node};\n+use crate::utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n use if_chain::if_chain;\n use rustc::lint::LateContext;\n use rustc::{hir, ty};\n use syntax::ast;\n \n-/// Convert a hir binary operator to the corresponding `ast` type.\n+/// Converts a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     match op {\n         hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n@@ -46,7 +46,7 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> Option<Range<'b>> {\n-    /// Find the field named `name` in the field. Always return `Some` for\n+    /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter().find(|field| field.ident.name == name)?.expr;\n@@ -214,7 +214,7 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<Ve\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n         if let hir::ExprKind::Path(ref path) = fun.node;\n         if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id));\n+        if let Some(fun_def_id) = resolve_node(cx, path, fun.hir_id).opt_def_id();\n         then {\n             return if match_def_path(cx.tcx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case"}, {"sha": "e084ed8224c6484db06696b2b66f81c7ea72742b", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    /// Check whether two statements are the same.\n+    /// Checks whether two statements are the same.\n     pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n@@ -55,7 +55,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    /// Check whether two blocks are the same.\n+    /// Checks whether two blocks are the same.\n     pub fn eq_block(&mut self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n@@ -186,7 +186,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n-    /// Check whether two patterns are the same.\n+    /// Checks whether two patterns are the same.\n     pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n@@ -328,7 +328,7 @@ fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Bin\n     }\n }\n \n-/// Check if the two `Option`s are both `None` or some equal values as per\n+/// Checks if the two `Option`s are both `None` or some equal values as per\n /// `eq_fn`.\n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n where\n@@ -338,7 +338,7 @@ where\n         .map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n-/// Check if two slices are equal as per `eq_fn`.\n+/// Checks if two slices are equal as per `eq_fn`.\n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n where\n     F: FnMut(&X, &X) -> bool,"}, {"sha": "2195039227013535c8b3dfd08de2aaa79692ded2", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -3,27 +3,28 @@\n use crate::utils::get_attr;\n use rustc::hir;\n use rustc::hir::print;\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::session::Session;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::Attribute;\n \n-/// **What it does:** Dumps every ast/hir node which has the `#[clippy::dump]`\n-/// attribute\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[clippy::dump]\n-/// extern crate foo;\n-/// ```\n-///\n-/// prints\n-///\n-/// ```\n-/// item `foo`\n-/// visibility inherited from outer item\n-/// extern crate dylib source: \"/path/to/foo.so\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Dumps every ast/hir node which has the `#[clippy::dump]`\n+    /// attribute\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[clippy::dump]\n+    /// extern crate foo;\n+    /// ```\n+    ///\n+    /// prints\n+    ///\n+    /// ```\n+    /// item `foo`\n+    /// visibility inherited from outer item\n+    /// extern crate dylib source: \"/path/to/foo.so\"\n+    /// ```\n     pub DEEP_CODE_INSPECTION,\n     internal_warn,\n     \"helper to dump info about code\"\n@@ -43,14 +44,14 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if !has_attr(&item.attrs) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n-        if !has_attr(&item.attrs) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         println!(\"impl item `{}`\", item.ident.name);\n@@ -100,14 +101,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     //\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if !has_attr(&expr.attrs) {\n+        if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n     fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-        if !has_attr(&arm.attrs) {\n+        if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n         for pat in &arm.pats {\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(stmt.node.attrs()) {\n+        if !has_attr(cx.sess(), stmt.node.attrs()) {\n             return;\n         }\n         match stmt.node {\n@@ -148,8 +149,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     //\n }\n \n-fn has_attr(attrs: &[Attribute]) -> bool {\n-    get_attr(attrs, \"dump\").count() > 0\n+fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n+    get_attr(sess, attrs, \"dump\").count() > 0\n }\n \n #[allow(clippy::similar_names)]\n@@ -343,7 +344,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n }\n \n fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n-    let did = cx.tcx.hir().local_def_id(item.id);\n+    let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -356,7 +357,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     }\n     match item.node {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {"}, {"sha": "343098ceeeea4d8bbf471f35f808ffa26d2682e7", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -14,78 +14,78 @@ use syntax::ast::{Crate as AstCrate, Ident, ItemKind, Name};\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for various things we like to keep tidy in clippy.\n-///\n-/// **Why is this bad?** We like to pretend we're an example of tidy code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** Wrong ordering of the util::paths constants.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for various things we like to keep tidy in clippy.\n+    ///\n+    /// **Why is this bad?** We like to pretend we're an example of tidy code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** Wrong ordering of the util::paths constants.\n     pub CLIPPY_LINTS_INTERNAL,\n     internal,\n     \"various things that will negatively affect your clippy experience\"\n }\n \n-/// **What it does:** Ensures every lint is associated to a `LintPass`.\n-///\n-/// **Why is this bad?** The compiler only knows lints via a `LintPass`. Without\n-/// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n-/// know the name of the lint.\n-///\n-/// **Known problems:** Only checks for lints associated using the `lint_array!`\n-/// macro.\n-///\n-/// **Example:**\n-/// ```rust\n-/// declare_lint! { pub LINT_1, ... }\n-/// declare_lint! { pub LINT_2, ... }\n-/// declare_lint! { pub FORGOTTEN_LINT, ... }\n-/// // ...\n-/// pub struct Pass;\n-/// impl LintPass for Pass {\n-///     fn get_lints(&self) -> LintArray {\n-///         lint_array![LINT_1, LINT_2]\n-///         // missing FORGOTTEN_LINT\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Ensures every lint is associated to a `LintPass`.\n+    ///\n+    /// **Why is this bad?** The compiler only knows lints via a `LintPass`. Without\n+    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+    /// know the name of the lint.\n+    ///\n+    /// **Known problems:** Only checks for lints associated using the `lint_array!`\n+    /// macro.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// declare_lint! { pub LINT_1, ... }\n+    /// declare_lint! { pub LINT_2, ... }\n+    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n+    /// // ...\n+    /// pub struct Pass;\n+    /// impl LintPass for Pass {\n+    ///     fn get_lints(&self) -> LintArray {\n+    ///         lint_array![LINT_1, LINT_2]\n+    ///         // missing FORGOTTEN_LINT\n+    ///     }\n+    /// }\n+    /// ```\n     pub LINT_WITHOUT_LINT_PASS,\n     internal,\n     \"declaring a lint without associating it in a LintPass\"\n }\n \n-/// **What it does:** Checks for the presence of the default hash types \"HashMap\" or \"HashSet\"\n-/// and recommends the FxHash* variants.\n-///\n-/// **Why is this bad?** The FxHash variants have better performance\n-/// and we don't need any collision prevention in clippy.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the presence of the default hash types \"HashMap\" or \"HashSet\"\n+    /// and recommends the FxHash* variants.\n+    ///\n+    /// **Why is this bad?** The FxHash variants have better performance\n+    /// and we don't need any collision prevention in clippy.\n     pub DEFAULT_HASH_TYPES,\n     internal,\n     \"forbid HashMap and HashSet and suggest the FxHash* variants\"\n }\n \n-/// **What it does:** Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n-/// variant of the function.\n-///\n-/// **Why is this bad?** The `utils::*` variants also add a link to the Clippy documentation to the\n-/// warning/error messages.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// Bad:\n-/// ```rust\n-/// cx.span_lint(LINT_NAME, \"message\");\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// utils::span_lint(cx, LINT_NAME, \"message\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n+    /// variant of the function.\n+    ///\n+    /// **Why is this bad?** The `utils::*` variants also add a link to the Clippy documentation to the\n+    /// warning/error messages.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// cx.span_lint(LINT_NAME, \"message\");\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// utils::span_lint(cx, LINT_NAME, \"message\");\n+    /// ```\n     pub COMPILER_LINT_FUNCTIONS,\n     internal,\n     \"usage of the lint functions of the compiler instead of the utils::* variant\"\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n                         output: &mut self.registered_lints,\n                         cx,\n                     };\n-                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.node_id);\n+                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.hir_id);\n                     collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n                 }\n             }"}, {"sha": "bf94c8a086811f184040be1199b3a19e27d1807a", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 178, "deletions": 283, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,25 @@\n-use crate::reexport::*;\n+pub mod attrs;\n+pub mod author;\n+pub mod camel_case;\n+pub mod comparisons;\n+pub mod conf;\n+pub mod constants;\n+mod diagnostics;\n+pub mod higher;\n+mod hir_utils;\n+pub mod inspector;\n+pub mod internal_lints;\n+pub mod paths;\n+pub mod ptr;\n+pub mod sugg;\n+pub mod usage;\n+pub use self::attrs::*;\n+pub use self::diagnostics::*;\n+pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n+\n+use std::borrow::Cow;\n+use std::mem;\n+\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n@@ -8,7 +29,6 @@ use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::Node;\n use rustc::hir::*;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n-use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{\n     self,\n@@ -17,38 +37,17 @@ use rustc::ty::{\n     Binder, Ty, TyCtxt,\n };\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, CodeSuggestion, Substitution, SubstitutionPart, SuggestionStyle};\n-use std::borrow::Cow;\n-use std::env;\n-use std::mem;\n-use std::str::FromStr;\n+use rustc_errors::Applicability;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n-use syntax::errors::DiagnosticBuilder;\n use syntax::source_map::{Span, DUMMY_SP};\n use syntax::symbol;\n use syntax::symbol::{keywords, Symbol};\n \n-pub mod camel_case;\n-\n-pub mod author;\n-pub mod comparisons;\n-pub mod conf;\n-pub mod constants;\n-mod hir_utils;\n-pub mod inspector;\n-pub mod internal_lints;\n-pub mod paths;\n-pub mod ptr;\n-pub mod sugg;\n-pub mod usage;\n-pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n-\n-pub mod higher;\n+use crate::reexport::*;\n \n-/// Returns true if the two spans come from differing expansions (i.e. one is\n-/// from a macro and one\n-/// isn't).\n+/// Returns `true` if the two spans come from differing expansions (i.e., one is\n+/// from a macro and one isn't).\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n@@ -62,9 +61,9 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n ///     // Do something\n /// }\n /// ```\n-pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent(id);\n-    match cx.tcx.hir().get(parent_id) {\n+pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(id);\n+    match cx.tcx.hir().get_by_hir_id(parent_id) {\n         Node::Item(&Item {\n             node: ItemKind::Const(..),\n             ..\n@@ -90,7 +89,7 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n     }\n }\n \n-/// Returns true if this `expn_info` was expanded by any macro.\n+/// Returns `true` if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().is_some()\n }\n@@ -114,7 +113,7 @@ impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n     }\n }\n \n-/// Check if a `DefId`'s path matches the given absolute type path usage.\n+/// Checks if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -130,7 +129,7 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n     apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n-/// Get the absolute path of `def_id` as a vector of `&str`.\n+/// Gets the absolute path of `def_id` as a vector of `&str`.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -148,15 +147,15 @@ pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str>\n         .collect()\n }\n \n-/// Check if type is struct, enum or union type with given def path.\n+/// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n-/// Check if the method call given in `expr` belongs to given trait.\n+/// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n@@ -167,7 +166,7 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str])\n     }\n }\n \n-/// Check if an expression references a variable of the given name.\n+/// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n@@ -192,7 +191,10 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n     }\n }\n \n-/// Match a `Path` against a slice of segment string literals.\n+/// Matches a `QPath` against a slice of segment string literals.\n+///\n+/// There is also `match_path` if you are dealing with a `rustc::hir::Path` instead of a\n+/// `rustc::hir::QPath`.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -212,6 +214,22 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     }\n }\n \n+/// Matches a `Path` against a slice of segment string literals.\n+///\n+/// There is also `match_qpath` if you are dealing with a `rustc::hir::QPath` instead of a\n+/// `rustc::hir::Path`.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// if match_path(&trait_ref.path, &paths::HASH) {\n+///     // This is the `std::hash::Hash` trait.\n+/// }\n+///\n+/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n+///     // This is a `rustc::lint::Lint`.\n+/// }\n+/// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments\n         .iter()\n@@ -220,7 +238,7 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name == *b)\n }\n \n-/// Match a `Path` against a slice of segment string literals, e.g.\n+/// Matches a `Path` against a slice of segment string literals, e.g.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -234,7 +252,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name == *b)\n }\n \n-/// Get the definition associated to a path.\n+/// Gets the definition associated to a path.\n pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n     let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n@@ -281,7 +299,7 @@ pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId\n     }\n }\n \n-/// Check whether a type implements a trait.\n+/// Checks whether a type implements a trait.\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n@@ -303,20 +321,47 @@ pub fn implements_trait<'a, 'tcx>(\n         .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n }\n \n-/// Check whether this type implements Drop.\n+/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n+///\n+/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n+///\n+/// ```rust\n+/// struct Point(isize, isize);\n+///\n+/// impl std::ops::Add for Point {\n+///     type Output = Self;\n+///\n+///     fn add(self, other: Self) -> Self {\n+///         Point(0, 0)\n+///     }\n+/// }\n+/// ```\n+pub fn trait_ref_of_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> Option<TraitRef> {\n+    // Get the implemented trait for the current function\n+    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n+    if_chain! {\n+        if parent_impl != hir::CRATE_HIR_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n+        if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.node;\n+        then { return trait_ref.clone(); }\n+    }\n+    None\n+}\n+\n+/// Checks whether this type implements `Drop`.\n pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n         _ => false,\n     }\n }\n \n-/// Resolve the definition of a node from its `HirId`.\n+/// Resolves the definition of a node from its `HirId`.\n pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::Def {\n     cx.tables.qpath_def(qpath, id)\n }\n \n-/// Return the method names and argument list of nested method call expressions that make up\n+/// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`.\n pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&'a [Expr]>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n@@ -339,7 +384,7 @@ pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&\n     (method_names, arg_lists)\n }\n \n-/// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n+/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n /// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n@@ -364,22 +409,23 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n             return None;\n         }\n     }\n-    matched.reverse(); // reverse `matched`, so that it is in the same order as `methods`\n+    // Reverse `matched` so that it is in the same order as `methods`.\n+    matched.reverse();\n     Some(matched)\n }\n \n-/// Returns true if the provided `def_id` is an entrypoint to a program\n+/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n pub fn is_entrypoint_fn(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n     if let Some((entry_fn_def_id, _)) = cx.tcx.entry_fn(LOCAL_CRATE) {\n         return def_id == entry_fn_def_id;\n     }\n     false\n }\n \n-/// Get the name of the item the expression is in, if available.\n+/// Gets the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n-    let parent_id = cx.tcx.hir().get_parent(expr.id);\n-    match cx.tcx.hir().find(parent_id) {\n+    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    match cx.tcx.hir().find_by_hir_id(parent_id) {\n         Some(Node::Item(&Item { ref ident, .. })) => Some(ident.name),\n         Some(Node::TraitItem(&TraitItem { ident, .. })) | Some(Node::ImplItem(&ImplItem { ident, .. })) => {\n             Some(ident.name)\n@@ -388,7 +434,7 @@ pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// Get the name of a `Pat`, if any\n+/// Gets the name of a `Pat`, if any.\n pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n@@ -414,14 +460,14 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n     }\n }\n \n-/// check if an `Expr` contains a certain name\n+/// Checks if an `Expr` contains a certain name.\n pub fn contains_name(name: Name, expr: &Expr) -> bool {\n     let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n }\n \n-/// Convert a span to a code snippet if available, otherwise use default.\n+/// Converts a span to a code snippet if available, otherwise use default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n /// to convert a given `Span` to a `str`.\n@@ -466,12 +512,12 @@ pub fn snippet_with_macro_callsite<'a, 'b, T: LintContext<'b>>(cx: &T, span: Spa\n     snippet(cx, span.source_callsite(), default)\n }\n \n-/// Convert a span to a code snippet. Returns `None` if not available.\n+/// Converts a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().source_map().span_to_snippet(span).ok()\n }\n \n-/// Convert a span (from a block) to a code snippet if available, otherwise use\n+/// Converts a span (from a block) to a code snippet if available, otherwise use\n /// default.\n /// This trims the code of indentation, except for the first line. Use it for\n /// blocks or block-like\n@@ -568,15 +614,15 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n     }\n }\n \n-/// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n+/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir();\n-    let node_id: NodeId = e.id;\n-    let parent_id: NodeId = map.get_parent_node(node_id);\n-    if node_id == parent_id {\n+    let hir_id = e.hir_id;\n+    let parent_id = map.get_parent_node_by_hir_id(hir_id);\n+    if hir_id == parent_id {\n         return None;\n     }\n-    map.find(parent_id).and_then(|node| {\n+    map.find_by_hir_id(parent_id).and_then(|node| {\n         if let Node::Expr(parent) = node {\n             Some(parent)\n         } else {\n@@ -585,10 +631,11 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n     })\n }\n \n-pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n+pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: HirId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir();\n+    let node_id = map.hir_to_node_id(node);\n     let enclosing_node = map\n-        .get_enclosing_scope(node)\n+        .get_enclosing_scope(node_id)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n@@ -611,163 +658,23 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n     }\n }\n \n-pub struct DiagnosticWrapper<'a>(pub DiagnosticBuilder<'a>);\n-\n-impl<'a> Drop for DiagnosticWrapper<'a> {\n-    fn drop(&mut self) {\n-        self.0.emit();\n-    }\n-}\n-\n-impl<'a> DiagnosticWrapper<'a> {\n-    fn docs_link(&mut self, lint: &'static Lint) {\n-        if env::var(\"CLIPPY_DISABLE_DOCS_LINKS\").is_err() {\n-            self.0.help(&format!(\n-                \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n-                &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n-                    // extract just major + minor version and ignore patch versions\n-                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n-                }),\n-                lint.name_lower().replacen(\"clippy::\", \"\", 1)\n-            ));\n-        }\n-    }\n-}\n-\n-pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n-    DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg)).docs_link(lint);\n-}\n-\n-pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    help: &str,\n-) {\n-    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n-    db.0.help(help);\n-    db.docs_link(lint);\n-}\n-\n-pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    note_span: Span,\n-    note: &str,\n-) {\n-    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n-    if note_span == span {\n-        db.0.note(note);\n-    } else {\n-        db.0.span_note(note_span, note);\n-    }\n-    db.docs_link(lint);\n-}\n-\n-pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    f: F,\n-) where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n-{\n-    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n-    f(&mut db.0);\n-    db.docs_link(lint);\n-}\n-\n-pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: NodeId, sp: Span, msg: &str) {\n-    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg)).docs_link(lint);\n-}\n-\n-pub fn span_lint_node_and_then(\n-    cx: &LateContext<'_, '_>,\n-    lint: &'static Lint,\n-    node: NodeId,\n-    sp: Span,\n-    msg: &str,\n-    f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n-) {\n-    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg));\n-    f(&mut db.0);\n-    db.docs_link(lint);\n-}\n-\n-/// Add a span lint with a suggestion on how to fix it.\n-///\n-/// These suggestions can be parsed by rustfix to allow it to automatically fix your code.\n-/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n-/// 2)\"`.\n-///\n-/// ```ignore\n-/// error: This `.fold` can be more succinctly expressed as `.any`\n-/// --> $DIR/methods.rs:390:13\n-///     |\n-/// 390 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n-///     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n-///     |\n-///     = note: `-D fold-any` implied by `-D warnings`\n-/// ```\n-pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    help: &str,\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-    span_lint_and_then(cx, lint, sp, msg, |db| {\n-        db.span_suggestion(sp, help, sugg, applicability);\n-    });\n-}\n-\n-/// Create a suggestion made from several `span \u2192 replacement`.\n-///\n-/// Note: in the JSON format (used by `compiletest_rs`), the help message will\n-/// appear once per\n-/// replacement. In human-readable format though, it only appears once before\n-/// the whole suggestion.\n-pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n-where\n-    I: IntoIterator<Item = (Span, String)>,\n-{\n-    let sugg = CodeSuggestion {\n-        substitutions: vec![Substitution {\n-            parts: sugg\n-                .into_iter()\n-                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                .collect(),\n-        }],\n-        msg: help_msg,\n-        style: SuggestionStyle::ShowCode,\n-        applicability: Applicability::Unspecified,\n-    };\n-    db.suggestions.push(sugg);\n-}\n-\n-/// Return the base type for HIR references and pointers.\n+/// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n     match ty.node {\n         TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n         _ => ty,\n     }\n }\n \n-/// Return the base type for references and raw pointers.\n+/// Returns the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n         ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n }\n \n-/// Return the base type for references and raw pointers, and count reference\n+/// Returns the base type for references and raw pointers, and count reference\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n@@ -779,7 +686,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     inner(ty, 0)\n }\n \n-/// Check whether the given expression is a constant literal of the given value.\n+/// Checks whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n     if let ExprKind::Lit(ref spanned) = expr.node {\n@@ -801,56 +708,7 @@ pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n-pub struct LimitStack {\n-    stack: Vec<u64>,\n-}\n-\n-impl Drop for LimitStack {\n-    fn drop(&mut self) {\n-        assert_eq!(self.stack.len(), 1);\n-    }\n-}\n-\n-impl LimitStack {\n-    pub fn new(limit: u64) -> Self {\n-        Self { stack: vec![limit] }\n-    }\n-    pub fn limit(&self) -> u64 {\n-        *self.stack.last().expect(\"there should always be a value in the stack\")\n-    }\n-    pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n-        let stack = &mut self.stack;\n-        parse_attrs(sess, attrs, name, |val| stack.push(val));\n-    }\n-    pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n-        let stack = &mut self.stack;\n-        parse_attrs(sess, attrs, name, |val| assert_eq!(stack.pop(), Some(val)));\n-    }\n-}\n-\n-pub fn get_attr<'a>(attrs: &'a [ast::Attribute], name: &'static str) -> impl Iterator<Item = &'a ast::Attribute> {\n-    attrs.iter().filter(move |attr| {\n-        attr.path.segments.len() == 2\n-            && attr.path.segments[0].ident.to_string() == \"clippy\"\n-            && attr.path.segments[1].ident.to_string() == name\n-    })\n-}\n-\n-fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n-    for attr in get_attr(attrs, name) {\n-        if let Some(ref value) = attr.value_str() {\n-            if let Ok(value) = FromStr::from_str(&value.as_str()) {\n-                f(value)\n-            } else {\n-                sess.span_err(attr.span, \"not a number\");\n-            }\n-        } else {\n-            sess.span_err(attr.span, \"bad clippy attribute\");\n-        }\n-    }\n-}\n-\n-/// Return the pre-expansion span if is this comes from an expansion of the\n+/// Returns the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n@@ -869,7 +727,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Return the pre-expansion span if is this directly comes from an expansion\n+/// Returns the pre-expansion span if the span directly comes from an expansion\n /// of the macro `name`.\n /// The difference with `is_expn_of` is that in\n /// ```rust,ignore\n@@ -891,19 +749,19 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Convenience function to get the return type of a function\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+/// Convenience function to get the return type of a function.\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n+    let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n-/// Check if two types are the same.\n+/// Checks if two types are the same.\n ///\n /// This discards any lifetime annotations, too.\n-// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for\n-// <'b> Foo<'b>` but\n-// not for type parameters.\n+//\n+// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` ==\n+// `for <'b> Foo<'b>`, but not for type parameters).\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n     let a = cx.tcx.erase_late_bound_regions(&Binder::bind(a));\n     let b = cx.tcx.erase_late_bound_regions(&Binder::bind(b));\n@@ -912,7 +770,7 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n         .enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n }\n \n-/// Return whether the given type is an `unsafe` function.\n+/// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n@@ -924,7 +782,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_copy_modulo_regions(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n-/// Return whether a pattern is refutable.\n+/// Returns `true` if a pattern is refutable.\n pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n@@ -989,10 +847,6 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n     }\n }\n \n-pub fn opt_def_id(def: Def) -> Option<DefId> {\n-    def.opt_def_id()\n-}\n-\n pub fn is_self(slf: &Arg) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.node {\n         name.name == keywords::SelfLower.name()\n@@ -1017,17 +871,17 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n     (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n }\n \n-/// Check if a given expression is a match expression\n-/// expanded from `?` operator or `try` macro.\n-pub fn is_try(expr: &Expr) -> Option<&Expr> {\n-    fn is_ok(arm: &Arm) -> bool {\n+/// Checks if a given expression is a match expression expanded from the `?`\n+/// operator or the `try` macro.\n+pub fn is_try<'a>(cx: &'_ LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n+    fn is_ok(cx: &'_ LateContext<'_, '_>, arm: &Arm) -> bool {\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n-            if let PatKind::Binding(_, defid, _, _, None) = pat[0].node;\n+            if let PatKind::Binding(_, hir_id, _, None) = pat[0].node;\n             if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n             if let Def::Local(lid) = path.def;\n-            if lid == defid;\n+            if cx.tcx.hir().node_to_hir_id(lid) == hir_id;\n             then {\n                 return true;\n             }\n@@ -1053,8 +907,8 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             if arms.len() == 2;\n             if arms[0].pats.len() == 1 && arms[0].guard.is_none();\n             if arms[1].pats.len() == 1 && arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            if (is_ok(cx, &arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(cx, &arms[1]) && is_err(&arms[0]));\n             then {\n                 return Some(expr);\n             }\n@@ -1064,10 +918,10 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     None\n }\n \n-/// Returns true if the lint is allowed in the current context\n+/// Returns `true` if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: NodeId) -> bool {\n+pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1108,7 +962,7 @@ pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n     (u << amt) >> amt\n }\n \n-/// Remove block comments from the given Vec of lines\n+/// Removes block comments from the given `Vec` of lines.\n ///\n /// # Examples\n ///\n@@ -1141,20 +995,61 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n     without\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: HirId) -> bool {\n     let map = &tcx.hir();\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;\n     while Some(enclosing_node) != prev_enclosing_node {\n-        if is_automatically_derived(map.attrs(enclosing_node)) {\n+        if is_automatically_derived(map.attrs_by_hir_id(enclosing_node)) {\n             return true;\n         }\n         prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.get_parent(enclosing_node);\n+        enclosing_node = map.get_parent_item(enclosing_node);\n     }\n     false\n }\n \n+/// Returns true if ty has `iter` or `iter_mut` methods\n+pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: ty::Ty<'_>) -> Option<&'static str> {\n+    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n+    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n+    // so we can't use its `lookup_method` method.\n+    static INTO_ITER_COLLECTIONS: [&[&str]; 13] = [\n+        &paths::VEC,\n+        &paths::OPTION,\n+        &paths::RESULT,\n+        &paths::BTREESET,\n+        &paths::BTREEMAP,\n+        &paths::VEC_DEQUE,\n+        &paths::LINKED_LIST,\n+        &paths::BINARY_HEAP,\n+        &paths::HASHSET,\n+        &paths::HASHMAP,\n+        &paths::PATH_BUF,\n+        &paths::PATH,\n+        &paths::RECEIVER,\n+    ];\n+\n+    let ty_to_check = match probably_ref_ty.sty {\n+        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        _ => probably_ref_ty,\n+    };\n+\n+    let def_id = match ty_to_check.sty {\n+        ty::Array(..) => return Some(\"array\"),\n+        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Adt(adt, _) => adt.did,\n+        _ => return None,\n+    };\n+\n+    for path in &INTO_ITER_COLLECTIONS {\n+        if match_def_path(cx.tcx, def_id, path) {\n+            return Some(path.last().unwrap());\n+        }\n+    }\n+    None\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{trim_multiline, without_block_comments};"}, {"sha": "9ee25aaea5ead2ff86481be069d65e4f7ad3c240", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -62,6 +62,7 @@ pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARTIAL_ORD: [&str; 3] = [\"core\", \"cmp\", \"PartialOrd\"];\n+pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n@@ -80,6 +81,7 @@ pub const RANGE_TO_INCLUSIVE: [&str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n pub const RANGE_TO_INCLUSIVE_STD: [&str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n+pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n pub const REGEX: [&str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];"}, {"sha": "72740cee5006a1812c3407957dbaebf71be4ea3d", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,7 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{higher, in_macro, snippet, snippet_opt};\n+use crate::utils::{higher, in_macro, snippet, snippet_opt, snippet_with_macro_callsite};\n use matches::matches;\n use rustc::hir;\n use rustc::lint::{EarlyContext, LateContext, LintContext};\n@@ -46,38 +46,7 @@ impl<'a> Sugg<'a> {\n     pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n-            match expr.node {\n-                hir::ExprKind::AddrOf(..)\n-                | hir::ExprKind::Box(..)\n-                | hir::ExprKind::Closure(.., _)\n-                | hir::ExprKind::If(..)\n-                | hir::ExprKind::Unary(..)\n-                | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprKind::Continue(..)\n-                | hir::ExprKind::Yield(..)\n-                | hir::ExprKind::Array(..)\n-                | hir::ExprKind::Block(..)\n-                | hir::ExprKind::Break(..)\n-                | hir::ExprKind::Call(..)\n-                | hir::ExprKind::Field(..)\n-                | hir::ExprKind::Index(..)\n-                | hir::ExprKind::InlineAsm(..)\n-                | hir::ExprKind::Lit(..)\n-                | hir::ExprKind::Loop(..)\n-                | hir::ExprKind::MethodCall(..)\n-                | hir::ExprKind::Path(..)\n-                | hir::ExprKind::Repeat(..)\n-                | hir::ExprKind::Ret(..)\n-                | hir::ExprKind::Struct(..)\n-                | hir::ExprKind::Tup(..)\n-                | hir::ExprKind::While(..)\n-                | hir::ExprKind::Err => Sugg::NonParen(snippet),\n-                hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-                hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-                hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n-                hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-                hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n-            }\n+            Self::hir_from_snippet(expr, snippet)\n         })\n     }\n \n@@ -111,6 +80,50 @@ impl<'a> Sugg<'a> {\n         })\n     }\n \n+    /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n+    pub fn hir_with_macro_callsite(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n+        let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n+\n+        Self::hir_from_snippet(expr, snippet)\n+    }\n+\n+    /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n+    /// function variants of `Sugg`, since these use different snippet functions.\n+    fn hir_from_snippet(expr: &hir::Expr, snippet: Cow<'a, str>) -> Self {\n+        match expr.node {\n+            hir::ExprKind::AddrOf(..)\n+            | hir::ExprKind::Box(..)\n+            | hir::ExprKind::Closure(.., _)\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            hir::ExprKind::Continue(..)\n+            | hir::ExprKind::Yield(..)\n+            | hir::ExprKind::Array(..)\n+            | hir::ExprKind::Block(..)\n+            | hir::ExprKind::Break(..)\n+            | hir::ExprKind::Call(..)\n+            | hir::ExprKind::Field(..)\n+            | hir::ExprKind::Index(..)\n+            | hir::ExprKind::InlineAsm(..)\n+            | hir::ExprKind::Lit(..)\n+            | hir::ExprKind::Loop(..)\n+            | hir::ExprKind::MethodCall(..)\n+            | hir::ExprKind::Path(..)\n+            | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::Ret(..)\n+            | hir::ExprKind::Struct(..)\n+            | hir::ExprKind::Tup(..)\n+            | hir::ExprKind::While(..)\n+            | hir::ExprKind::Err => Sugg::NonParen(snippet),\n+            hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+            hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+            hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+            hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+            hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+        }\n+    }\n+\n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use syntax::ast::RangeLimits;\n@@ -227,13 +240,13 @@ impl<'a> Sugg<'a> {\n         }\n     }\n \n-    /// Add parenthesis to any expression that might need them. Suitable to the\n-    /// `self` argument of\n-    /// a method call (eg. to build `bar.foo()` or `(1 + 2).foo()`).\n+    /// Adds parenthesis to any expression that might need them. Suitable to the\n+    /// `self` argument of a method call\n+    /// (e.g., to build `bar.foo()` or `(1 + 2).foo()`).\n     pub fn maybe_par(self) -> Self {\n         match self {\n             Sugg::NonParen(..) => self,\n-            // (x) and (x).y() both don't need additional parens\n+            // `(x)` and `(x).y()` both don't need additional parens.\n             Sugg::MaybeParen(sugg) => {\n                 if sugg.starts_with('(') && sugg.ends_with(')') {\n                     Sugg::MaybeParen(sugg)\n@@ -269,14 +282,14 @@ impl<'a> std::ops::Not for Sugg<'a> {\n \n /// Helper type to display either `foo` or `(foo)`.\n struct ParenHelper<T> {\n-    /// Whether parenthesis are needed.\n+    /// `true` if parentheses are needed.\n     paren: bool,\n     /// The main thing to display.\n     wrapped: T,\n }\n \n impl<T> ParenHelper<T> {\n-    /// Build a `ParenHelper`.\n+    /// Builds a `ParenHelper`.\n     fn new(paren: bool, wrapped: T) -> Self {\n         Self { paren, wrapped }\n     }\n@@ -292,7 +305,7 @@ impl<T: Display> Display for ParenHelper<T> {\n     }\n }\n \n-/// Build the string for `<op><expr>` adding parenthesis when necessary.\n+/// Builds the string for `<op><expr>` adding parenthesis when necessary.\n ///\n /// For convenience, the operator is taken as a string because all unary\n /// operators have the same\n@@ -301,28 +314,28 @@ pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n-/// Build the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n+/// Builds the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n ///\n /// Precedence of shift operator relative to other arithmetic operation is\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n-    /// Whether the operator is a shift operator `<<` or `>>`.\n+    /// Returns `true` if the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n+    /// Returns `true` if the operator is a arithmetic operator\n+    /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n         matches!(\n             *op,\n             AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n         )\n     }\n \n-    /// Whether the operator `op` needs parenthesis with the operator `other`\n-    /// in the direction\n-    /// `dir`.\n+    /// Returns `true` if the operator `op` needs parenthesis with the operator\n+    /// `other` in the direction `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence()\n             || (other.precedence() == op.precedence()\n@@ -400,10 +413,9 @@ enum Associativity {\n     Right,\n }\n \n-/// Return the associativity/fixity of an operator. The difference with\n-/// `AssocOp::fixity` is that\n-/// an operator can be both left and right associative (such as `+`:\n-/// `a + b + c == (a + b) + c == a + (b + c)`.\n+/// Returns the associativity/fixity of an operator. The difference with\n+/// `AssocOp::fixity` is that an operator can be both left and right associative\n+/// (such as `+`: `a + b + c == (a + b) + c == a + (b + c)`.\n ///\n /// Chained `as` and explicit `:` type coercion never need inner parenthesis so\n /// they are considered\n@@ -420,7 +432,7 @@ fn associativity(op: &AssocOp) -> Associativity {\n     }\n }\n \n-/// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n+/// Converts a `hir::BinOp` to the corresponding assigning binary operator.\n fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n     use syntax::parse::token::BinOpToken::*;\n \n@@ -447,7 +459,7 @@ fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n     })\n }\n \n-/// Convert an `ast::BinOp` to the corresponding assigning binary operator.\n+/// Converts an `ast::BinOp` to the corresponding assigning binary operator.\n fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n     use syntax::ast::BinOpKind::*;\n     use syntax::parse::token::BinOpToken;\n@@ -467,13 +479,13 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n     })\n }\n \n-/// Return the indentation before `span` if there are nothing but `[ \\t]`\n+/// Returns the indentation before `span` if there are nothing but `[ \\t]`\n /// before it on its line.\n fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n     if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n-            // we can mix char and byte positions here because we only consider `[ \\t]`\n+            // We can mix char and byte positions here because we only consider `[ \\t]`.\n             if lo.col == CharPos(pos) {\n                 Some(line[..pos].into())\n             } else {"}, {"sha": "521ddbc08656127f9ff13b68403611f2262f828e", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,17 +1,15 @@\n-use rustc::lint::LateContext;\n-\n use rustc::hir::def::Def;\n use rustc::hir::*;\n+use rustc::lint::LateContext;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n-/// Returns a set of mutated local variable ids or None if mutations could not be determined.\n-pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<NodeId>> {\n+/// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n+pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),\n         skip: false,\n@@ -35,11 +33,11 @@ pub fn is_potentially_mutated<'a, 'tcx: 'a>(\n         Def::Local(id) | Def::Upvar(id, ..) => id,\n         _ => return true,\n     };\n-    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&cx.tcx.hir().node_to_hir_id(id)))\n }\n \n struct MutVarsDelegate {\n-    used_mutably: FxHashSet<NodeId>,\n+    used_mutably: FxHashSet<HirId>,\n     skip: bool,\n }\n \n@@ -63,21 +61,21 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }\n     }\n \n-    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         self.update(&cmt.cat)\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }"}, {"sha": "51cedfef0f7102a6aad504521fb0691f87ea5fc3", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -8,18 +8,18 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n-/// be possible.\n-///\n-/// **Why is this bad?** This is less efficient.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// foo(&vec![1, 2])\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n+    /// be possible.\n+    ///\n+    /// **Why is this bad?** This is less efficient.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// foo(&vec![1, 2])\n+    /// ```\n     pub USELESS_VEC,\n     perf,\n     \"useless `vec!`\"\n@@ -106,7 +106,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n     );\n }\n \n-/// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n+/// Returns the item type of the vector (i.e., the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n     if let ty::Adt(_, substs) = ty.sty {\n         substs.type_at(0)"}, {"sha": "30bd2177ca91de9752f77bf2a09f5c7668e8bf3b", "filename": "clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,21 +7,21 @@ use cargo_metadata;\n use if_chain::if_chain;\n use semver;\n \n-/// **What it does:** Checks for wildcard dependencies in the `Cargo.toml`.\n-///\n-/// **Why is this bad?** [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n-/// it is highly unlikely that you work with any possible version of your dependency,\n-/// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```toml\n-/// [dependencies]\n-/// regex = \"*\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard dependencies in the `Cargo.toml`.\n+    ///\n+    /// **Why is this bad?** [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n+    /// it is highly unlikely that you work with any possible version of your dependency,\n+    /// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```toml\n+    /// [dependencies]\n+    /// regex = \"*\"\n+    /// ```\n     pub WILDCARD_DEPENDENCIES,\n     cargo,\n     \"wildcard dependencies being used\""}, {"sha": "236875f0aca8069a56ebe64bc5ee928b107de71b", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -7,153 +7,153 @@ use syntax::ast::*;\n use syntax::parse::{parser, token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n \n-/// **What it does:** This lint warns when you use `println!(\"\")` to\n-/// print a newline.\n-///\n-/// **Why is this bad?** You should use `println!()`, which is simpler.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `println!(\"\")` to\n+    /// print a newline.\n+    ///\n+    /// **Why is this bad?** You should use `println!()`, which is simpler.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"\");\n+    /// ```\n     pub PRINTLN_EMPTY_STRING,\n     style,\n     \"using `println!(\\\"\\\")` with an empty string\"\n }\n \n-/// **What it does:** This lint warns when you use `print!()` with a format\n-/// string that\n-/// ends in a newline.\n-///\n-/// **Why is this bad?** You should use `println!()` instead, which appends the\n-/// newline.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// print!(\"Hello {}!\\n\", name);\n-/// ```\n-/// use println!() instead\n-/// ```rust\n-/// println!(\"Hello {}!\", name);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `print!()` with a format\n+    /// string that\n+    /// ends in a newline.\n+    ///\n+    /// **Why is this bad?** You should use `println!()` instead, which appends the\n+    /// newline.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// print!(\"Hello {}!\\n\", name);\n+    /// ```\n+    /// use println!() instead\n+    /// ```ignore\n+    /// println!(\"Hello {}!\", name);\n+    /// ```\n     pub PRINT_WITH_NEWLINE,\n     style,\n     \"using `print!()` with a format string that ends in a single newline\"\n }\n \n-/// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n-/// is to catch debugging remnants.\n-///\n-/// **Why is this bad?** People often print on *stdout* while debugging an\n-/// application and might forget to remove those prints afterward.\n-///\n-/// **Known problems:** Only catches `print!` and `println!` calls.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"Hello world!\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n+    /// is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** People often print on *stdout* while debugging an\n+    /// application and might forget to remove those prints afterward.\n+    ///\n+    /// **Known problems:** Only catches `print!` and `println!` calls.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"Hello world!\");\n+    /// ```\n     pub PRINT_STDOUT,\n     restriction,\n     \"printing on stdout\"\n }\n \n-/// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n-/// lint is to catch debugging remnants.\n-///\n-/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n-/// debugging Rust code. It should not be used in in user-facing output.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{:?}\", foo);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n+    /// lint is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n+    /// debugging Rust code. It should not be used in in user-facing output.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"{:?}\", foo);\n+    /// ```\n     pub USE_DEBUG,\n     restriction,\n     \"use of `Debug`-based formatting\"\n }\n \n-/// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n-///\n-/// **Why is this bad?** Using literals as `println!` args is inefficient\n-/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n-/// (i.e., just put the literal in the format string)\n-///\n-/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n-/// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{}\", \"foo\");\n-/// ```\n-/// use the literal without formatting:\n-/// ```rust\n-/// println!(\"foo\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n+    ///\n+    /// **Why is this bad?** Using literals as `println!` args is inefficient\n+    /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+    /// (i.e., just put the literal in the format string)\n+    ///\n+    /// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+    /// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"{}\", \"foo\");\n+    /// ```\n+    /// use the literal without formatting:\n+    /// ```rust\n+    /// println!(\"foo\");\n+    /// ```\n     pub PRINT_LITERAL,\n     style,\n     \"printing a literal with a format string\"\n }\n \n-/// **What it does:** This lint warns when you use `writeln!(buf, \"\")` to\n-/// print a newline.\n-///\n-/// **Why is this bad?** You should use `writeln!(buf)`, which is simpler.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// writeln!(\"\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `writeln!(buf, \"\")` to\n+    /// print a newline.\n+    ///\n+    /// **Why is this bad?** You should use `writeln!(buf)`, which is simpler.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// writeln!(buf, \"\");\n+    /// ```\n     pub WRITELN_EMPTY_STRING,\n     style,\n-    \"using `writeln!(\\\"\\\")` with an empty string\"\n+    \"using `writeln!(buf, \\\"\\\")` with an empty string\"\n }\n \n-/// **What it does:** This lint warns when you use `write!()` with a format\n-/// string that\n-/// ends in a newline.\n-///\n-/// **Why is this bad?** You should use `writeln!()` instead, which appends the\n-/// newline.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// write!(buf, \"Hello {}!\\n\", name);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `write!()` with a format\n+    /// string that\n+    /// ends in a newline.\n+    ///\n+    /// **Why is this bad?** You should use `writeln!()` instead, which appends the\n+    /// newline.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// write!(buf, \"Hello {}!\\n\", name);\n+    /// ```\n     pub WRITE_WITH_NEWLINE,\n     style,\n     \"using `write!()` with a format string that ends in a single newline\"\n }\n \n-/// **What it does:** This lint warns about the use of literals as `write!`/`writeln!` args.\n-///\n-/// **Why is this bad?** Using literals as `writeln!` args is inefficient\n-/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n-/// (i.e., just put the literal in the format string)\n-///\n-/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n-/// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// writeln!(buf, \"{}\", \"foo\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns about the use of literals as `write!`/`writeln!` args.\n+    ///\n+    /// **Why is this bad?** Using literals as `writeln!` args is inefficient\n+    /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+    /// (i.e., just put the literal in the format string)\n+    ///\n+    /// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+    /// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// writeln!(buf, \"{}\", \"foo\");\n+    /// ```\n     pub WRITE_LITERAL,\n     style,\n     \"writing a literal with a format string\""}, {"sha": "de13816f66fdc4858d3f364dd232ca733d8a2d25", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,18 +5,18 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `0.0 / 0.0`.\n-///\n-/// **Why is this bad?** It's less readable than `std::f32::NAN` or\n-/// `std::f64::NAN`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0.0f32 / 0.0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `0.0 / 0.0`.\n+    ///\n+    /// **Why is this bad?** It's less readable than `std::f32::NAN` or\n+    /// `std::f64::NAN`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 0.0f32 / 0.0\n+    /// ```\n     pub ZERO_DIVIDED_BY_ZERO,\n     complexity,\n     \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\""}, {"sha": "53e671e17e034f2db5bf2965df39510fa38d156a", "filename": "doc/adding_lints.md", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,449 @@\n+## Adding a new lint\n+\n+You are probably here because you want to add a new lint to Clippy. If this is\n+the first time you're contributing to Clippy, this document guides you through\n+creating an example lint from scratch.\n+\n+To get started, we will create a lint that detects functions called `foo`,\n+because that's clearly a non-descriptive name.\n+\n+* [Setup](#Setup)\n+* [Testing](#Testing)\n+* [Rustfix tests](#Rustfix-tests)\n+* [Lint declaration](#Lint-declaration)\n+* [Lint passes](#Lint-passes)\n+* [Emitting a lint](#Emitting-a-lint)\n+* [Adding the lint logic](#Adding-the-lint-logic)\n+* [Author lint](#Author-lint)\n+* [Documentation](#Documentation)\n+* [Running rustfmt](#Running-rustfmt)\n+* [Debugging](#Debugging)\n+* [PR Checklist](#PR-Checklist)\n+* [Cheatsheet](#Cheatsheet)\n+\n+### Setup\n+\n+When working on Clippy, you will need the current git master version of rustc,\n+which can change rapidly. Make sure you're working near rust-clippy's master,\n+and use the `setup-toolchain.sh` script to configure the appropriate toolchain\n+for the Clippy directory.\n+\n+### Testing\n+\n+Let's write some tests first that we can execute while we iterate on our lint.\n+\n+Clippy uses UI tests for testing. UI tests check that the output of Clippy is\n+exactly as expected. Each test is just a plain Rust file that contains the code\n+we want to check. The output of Clippy is compared against a `.stderr` file.\n+Note that you don't have to create this file yourself, we'll get to\n+generating the `.stderr` files further down.\n+\n+We start by creating the test file at `tests/ui/foo_functions.rs`. It doesn't\n+really matter what the file is called, but it's a good convention to name it\n+after the lint it is testing, so `foo_functions.rs` it is.\n+\n+Inside the file we put some examples to get started:\n+\n+```rust\n+#![warn(clippy::foo_functions)]\n+\n+// Impl methods\n+struct A;\n+impl A {\n+    pub fn fo(&self) {}\n+    pub fn foo(&self) {}\n+    pub fn food(&self) {}\n+}\n+\n+// Default trait methods\n+trait B {\n+    pub fn fo(&self) {}\n+    pub fn foo(&self) {}\n+    pub fn food(&self) {}\n+}\n+\n+// Plain functions\n+fn fo() {}\n+fn foo() {}\n+fn food() {}\n+\n+fn main() {\n+    // We also don't want to lint method calls\n+    foo();\n+    let a = A;\n+    a.foo();\n+}\n+\n+```\n+\n+Now we can run the test with `TESTNAME=ui/foo_functions cargo uitest`.\n+Currently this test will fail. If you go through the output you will see that we\n+are told that `clippy::foo_functions` is an unknown lint, which is expected.\n+\n+While we are working on implementing our lint, we can keep running the UI\n+test. That allows us to check if the output is turning into what we want.\n+\n+Once we are satisfied with the output, we need to run\n+`tests/ui/update-all-references.sh` to update the `.stderr` file for our lint.\n+Running `TESTNAME=ui/foo_functions cargo uitest` should pass then. When we\n+commit our lint, we need to commit the generated `.stderr` files, too.\n+\n+### Rustfix tests\n+\n+If the lint you are working on is making use of structured suggestions, the\n+test file should include a `// run-rustfix` comment at the top. This will\n+additionally run [rustfix](https://github.com/rust-lang-nursery/rustfix) for\n+that test. Rustfix will apply the suggestions from the lint to the code of the\n+test file and compare that to the contents of a `.fixed` file.\n+\n+Use `tests/ui/update-all-references.sh` to automatically generate the\n+`.fixed` file after running the tests.\n+\n+With tests in place, let's have a look at implementing our lint now.\n+\n+### Testing manually\n+\n+Manually testing against an example file can be useful if you have added some\n+`println!`s and the test suite output becomes unreadable. To try Clippy with\n+your local modifications, run `env CLIPPY_TESTS=true cargo run --bin\n+clippy-driver -- -L ./target/debug input.rs` from the working copy root.\n+\n+### Lint declaration\n+\n+We start by creating a new file in the `clippy_lints` crate. That's the crate\n+where all the lint code is. We are going to call the file\n+`clippy_lints/src/foo_functions.rs` and import some initial things we need:\n+\n+```rust\n+use rustc::lint::{LintArray, LintPass};\n+use rustc::{declare_tool_lint, lint_array};\n+```\n+\n+The next step is to provide a lint declaration. Lints are declared using the\n+[`declare_clippy_lint!`][declare_clippy_lint] macro:\n+\n+```rust\n+declare_clippy_lint! {\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+* `FOO_FUNCTIONS` is the name of our lint. Be sure to follow the [lint naming\n+guidelines][lint_naming] here when naming your lint. In short, the name should\n+state the thing that is being checked for and read well when used with\n+`allow`/`warn`/`deny`.\n+* `pedantic` sets the lint level to `Allow`.\n+  The exact mapping can be found [here][category_level_mapping]\n+* The last part should be a text that explains what exactly is wrong with the\n+  code\n+\n+With our lint declaration done, we will now make sure that it is assigned to a\n+lint pass:\n+\n+```rust\n+// clippy_lints/src/foo_functions.rs\n+\n+// .. imports and lint declaration ..\n+\n+#[derive(Copy, Clone)]\n+pub struct FooFunctionsPass;\n+\n+impl LintPass for FooFunctionsPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            FOO_FUNCTIONS,\n+        )\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        \"FooFunctions\"\n+    }\n+}\n+```\n+\n+Don't worry about the `name` method here. As long as it includes the name of the\n+lint pass it should be fine.\n+\n+Next we need to run `util/dev update_lints` to register the lint in various\n+places, mainly in `clippy_lints/src/lib.rs`.\n+\n+While `update_lints` automates some things, it doesn't automate everything. We\n+will have to register our lint pass manually in the `register_plugins` function\n+in `clippy_lints/src/lib.rs`:\n+\n+```rust\n+reg.register_early_lint_pass(box foo_functions::FooFunctionsPass);\n+```\n+\n+This should fix the `unknown clippy lint: clippy::foo_functions` error that we\n+saw when we executed our tests the first time. The next decision we have to make\n+is which lint pass our lint is going to need.\n+\n+### Lint passes\n+\n+Writing a lint that only checks for the name of a function means that we only\n+have to deal with the AST and don't have to deal with the type system at all.\n+This is good, because it makes writing this particular lint less complicated.\n+\n+We have to make this decision with every new Clippy lint. It boils down to using\n+either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n+\n+In short, the `LateLintPass` has access to type information while the\n+`EarlyLintPass` doesn't. If you don't need access to type information, use the\n+`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n+hasn't really been a concern with Clippy so far.\n+\n+Since we don't need type information for checking the function name, we are\n+going to use the `EarlyLintPass`. It has to be imported as well, changing our\n+imports to:\n+\n+```rust\n+use rustc::lint::{LintArray, LintPass, EarlyLintPass, EarlyContext};\n+use rustc::{declare_tool_lint, lint_array};\n+```\n+\n+### Emitting a lint\n+\n+With UI tests and the lint declaration in place, we can start working on the\n+implementation of the lint logic.\n+\n+Let's start by implementing the `EarlyLintPass` for our `FooFunctionsPass`:\n+\n+```rust\n+impl EarlyLintPass for FooFunctionsPass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        // TODO: Emit lint here\n+    }\n+}\n+```\n+\n+We implement the [`check_fn`][check_fn] method from the\n+[`EarlyLintPass`][early_lint_pass] trait. This gives us access to various\n+information about the function that is currently being checked. More on that in\n+the next section. Let's worry about the details later and emit our lint for\n+*every* function definition first.\n+\n+Depending on how complex we want our lint message to be, we can choose from a\n+variety of lint emission functions. They can all be found in\n+[`clippy_lints/src/utils/diagnostics.rs`][diagnostics].\n+\n+`span_help_and_lint` seems most appropriate in this case. It allows us to\n+provide an extra help message and we can't really suggest a better name\n+automatically. This is how it looks:\n+\n+```rust\n+impl EarlyLintPass for Pass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, _: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        span_help_and_lint(\n+            cx,\n+            FOO_FUNCTIONS,\n+            span,\n+            \"function named `foo`\",\n+            \"consider using a more meaningful name\"\n+        );\n+    }\n+}\n+```\n+\n+Running our UI test should now produce output that contains the lint message.\n+\n+### Adding the lint logic\n+\n+Writing the logic for your lint will most likely be different from our example,\n+so this section is kept rather short.\n+\n+Using the [`check_fn`][check_fn] method gives us access to [`FnKind`][fn_kind]\n+that has two relevant variants for us `FnKind::ItemFn` and `FnKind::Method`.\n+Both provide access to the name of the function/method via an [`Ident`][ident].\n+\n+With that we can expand our `check_fn` method to:\n+\n+```rust\n+impl EarlyLintPass for Pass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        if is_foo_fn(fn_kind) {\n+            span_help_and_lint(\n+                cx,\n+                FOO_FUNCTIONS,\n+                span,\n+                \"function named `foo`\",\n+                \"consider using a more meaningful name\"\n+            );\n+        }\n+    }\n+}\n+```\n+\n+We separate the lint conditional from the lint emissions because it makes the\n+code a bit easier to read. In some cases this separation would also allow to\n+write some unit tests (as opposed to only UI tests) for the separate function.\n+\n+In our example, `is_foo_fn` looks like:\n+\n+```rust\n+// use statements, impl EarlyLintPass, check_fn, ..\n+\n+fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) => {\n+            ident.name == \"foo\"\n+        },\n+        FnKind::Closure(..) => false\n+    }\n+}\n+```\n+\n+Now we should also run the full test suite with `cargo test`. At this point\n+running `cargo test` should produce the expected output. Remember to run\n+`tests/ui/update-all-references.sh` to update the `.stderr` file.\n+\n+`cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n+implementation is not violating any Clippy lints itself.\n+\n+If you are still following the example, you will see that `FooFunctionsPass`\n+violates a Clippy lint. So we are going to rename that struct to just `Pass`:\n+\n+```rust\n+#[derive(Copy, Clone)]\n+pub struct Pass;\n+\n+impl LintPass for Pass { /* .. */ }\n+```\n+\n+That should be it for the lint implementation. Running `cargo test` should now\n+pass.\n+\n+### Author lint\n+\n+If you have trouble implementing your lint, there is also the internal `author`\n+lint to generate Clippy code that detects the offending pattern. It does not\n+work for all of the Rust syntax, but can give a good starting point.\n+\n+The quickest way to use it, is the [Rust playground][play].rust-lang.org).\n+Put the code you want to lint into the editor and add the `#[clippy::author]`\n+attribute above the item. Then run Clippy via `Tools -> Clippy` and you should\n+see the generated code in the output below.\n+\n+[Here][author_example] is an example on the playground.\n+\n+If the command was executed successfully, you can copy the code over to where\n+you are implementing your lint.\n+\n+### Documentation\n+\n+The final thing before submitting our PR is to add some documentation to our\n+lint declaration.\n+\n+Please document your lint with a doc comment akin to the following:\n+\n+```rust\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for ... (describe what the lint matches).\n+    ///\n+    /// **Why is this bad?** Supply the reason for linting the code.\n+    ///\n+    /// **Known problems:** None. (Or describe where it could go wrong.)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// Insert a short example of code that triggers the lint\n+    ///\n+    /// // Good\n+    /// Insert a short example of improved code that doesn't trigger the lint\n+    /// ```\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+Once your lint is merged, this documentation will show up in the [lint\n+list][lint_list].\n+\n+### Running rustfmt\n+\n+[Rustfmt](https://github.com/rust-lang/rustfmt) is a tool for formatting Rust code according\n+to style guidelines. Your code has to be formatted by `rustfmt` before a PR can be merged.\n+\n+It can be installed via `rustup`:\n+\n+```bash\n+rustup component add rustfmt\n+```\n+\n+Use `cargo fmt --all` to format the whole codebase.\n+\n+### Debugging\n+\n+If you want to debug parts of your lint implementation, you can use the `dbg!`\n+macro anywhere in your code. Running the tests should then include the debug\n+output in the `stdout` part.\n+\n+### PR Checklist\n+\n+Before submitting your PR make sure you followed all of the basic requirements:\n+\n+- [ ] Followed [lint naming conventions][lint_naming]\n+- [ ] Added passing UI tests (including committed `.stderr` file)\n+- [ ] `cargo test` passes locally\n+- [ ] Executed `util/dev update_lints`\n+- [ ] Added lint documentation\n+\n+### Cheatsheet\n+\n+Here are some pointers to things you are likely going to need for every lint:\n+\n+* [Clippy utils][utils] - Various helper functions. Maybe the function you need\n+  is already in here (`implements_trait`, `match_path`, `snippet`, etc)\n+* [Clippy diagnostics][diagnostics]\n+* [The `if_chain` macro][if_chain]\n+* [`in_macro`][in_macro] and [`in_external_macro`][in_external_macro]\n+* [`Span`][span]\n+* [`Applicability`][applicability]\n+* [The rustc guide][rustc_guide] explains a lot of internal compiler concepts\n+* [The nightly rustc docs][nightly_docs] which has been linked to throughout\n+  this guide\n+\n+For `EarlyLintPass` lints:\n+\n+* [`EarlyLintPass`][early_lint_pass]\n+* [`syntax::ast`][ast]\n+\n+For `LateLintPass` lints:\n+\n+* [`LateLintPass`][late_lint_pass]\n+* [`Ty::TyKind`][ty]\n+\n+\n+While most of Clippy's lint utils are documented, most of rustc's internals lack\n+documentation currently. This is unfortunate, but in most cases you can probably\n+get away with copying things from existing similar lints. If you are stuck,\n+don't hesitate to ask on Discord, IRC or in the issue/PR.\n+\n+[lint_list]: https://rust-lang.github.io/rust-clippy/master/index.html\n+[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/bd23cb89ec0ea63403a17d3fc5e50c88e38dd54f/clippy_lints/src/lib.rs#L43\n+[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/a71acac1da7eaf667ab90a1d65d10e5cc4b80191/clippy_lints/src/lib.rs#L39\n+[compilation_stages]: https://rust-lang.github.io/rustc-guide/high-level-overview.html#the-main-stages-of-compilation\n+[check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_fn\n+[early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html\n+[late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LateLintPass.html\n+[fn_kind]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/visit/enum.FnKind.html\n+[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs\n+[ident]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/symbol/struct.Ident.html\n+[span]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax_pos/struct.Span.html\n+[applicability]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html\n+[if_chain]: https://docs.rs/if_chain/0.1.2/if_chain/\n+[ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/sty/index.html\n+[ast]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/index.html\n+[in_macro]: https://github.com/rust-lang/rust-clippy/blob/d0717d1f9531a03d154aaeb0cad94c243915a146/clippy_lints/src/utils/mod.rs#L94\n+[in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/fn.in_external_macro.html\n+[play]: https://play.rust-lang.org\n+[author_example]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f093b986e80ad62f3b67a1f24f5e66e2\n+[rustc_guide]: https://rust-lang.github.io/rustc-guide/\n+[nightly_docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/"}, {"sha": "82326bf780cfbf726b3835bbba4a014be5e5b938", "filename": "src/driver.rs", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,18 +1,18 @@\n // error-pattern:yummy\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n-#![feature(try_from)]\n #![allow(clippy::missing_docs_in_private_items)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate rustc_driver;\n #[allow(unused_extern_crates)]\n+extern crate rustc_interface;\n+#[allow(unused_extern_crates)]\n extern crate rustc_plugin;\n-use self::rustc_driver::{driver::CompileController, Compilation};\n \n-use std::convert::TryInto;\n+use rustc_interface::interface;\n use std::path::Path;\n use std::process::{exit, Command};\n \n@@ -61,10 +61,62 @@ fn test_arg_value() {\n }\n \n #[allow(clippy::too_many_lines)]\n+\n+struct ClippyCallbacks;\n+\n+impl rustc_driver::Callbacks for ClippyCallbacks {\n+    fn after_parsing(&mut self, compiler: &interface::Compiler) -> bool {\n+        let sess = compiler.session();\n+        let mut registry = rustc_plugin::registry::Registry::new(\n+            sess,\n+            compiler\n+                .parse()\n+                .expect(\n+                    \"at this compilation stage \\\n+                     the crate must be parsed\",\n+                )\n+                .peek()\n+                .span,\n+        );\n+        registry.args_hidden = Some(Vec::new());\n+\n+        let conf = clippy_lints::read_conf(&registry);\n+        clippy_lints::register_plugins(&mut registry, &conf);\n+\n+        let rustc_plugin::registry::Registry {\n+            early_lint_passes,\n+            late_lint_passes,\n+            lint_groups,\n+            llvm_passes,\n+            attributes,\n+            ..\n+        } = registry;\n+        let mut ls = sess.lint_store.borrow_mut();\n+        for pass in early_lint_passes {\n+            ls.register_early_pass(Some(sess), true, false, pass);\n+        }\n+        for pass in late_lint_passes {\n+            ls.register_late_pass(Some(sess), true, pass);\n+        }\n+\n+        for (name, (to, deprecated_name)) in lint_groups {\n+            ls.register_group(Some(sess), true, name, deprecated_name, to);\n+        }\n+        clippy_lints::register_pre_expansion_lints(sess, &mut ls, &conf);\n+        clippy_lints::register_renamed(&mut ls);\n+\n+        sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n+        sess.plugin_attributes.borrow_mut().extend(attributes);\n+\n+        // Continue execution\n+        true\n+    }\n+}\n+\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     exit(\n-        rustc_driver::run(move || {\n+        rustc_driver::report_ices_to_stderr_if_any(move || {\n             use std::env;\n \n             if std::env::args().any(|a| a == \"--version\" || a == \"-V\") {\n@@ -145,58 +197,14 @@ pub fn main() {\n                 }\n             }\n \n-            let mut controller = CompileController::basic();\n-            if clippy_enabled {\n-                controller.after_parse.callback = Box::new(move |state| {\n-                    let mut registry = rustc_plugin::registry::Registry::new(\n-                        state.session,\n-                        state\n-                            .krate\n-                            .as_ref()\n-                            .expect(\n-                                \"at this compilation stage \\\n-                                 the crate must be parsed\",\n-                            )\n-                            .span,\n-                    );\n-                    registry.args_hidden = Some(Vec::new());\n-\n-                    let conf = clippy_lints::read_conf(&registry);\n-                    clippy_lints::register_plugins(&mut registry, &conf);\n-\n-                    let rustc_plugin::registry::Registry {\n-                        early_lint_passes,\n-                        late_lint_passes,\n-                        lint_groups,\n-                        llvm_passes,\n-                        attributes,\n-                        ..\n-                    } = registry;\n-                    let sess = &state.session;\n-                    let mut ls = sess.lint_store.borrow_mut();\n-                    for pass in early_lint_passes {\n-                        ls.register_early_pass(Some(sess), true, false, pass);\n-                    }\n-                    for pass in late_lint_passes {\n-                        ls.register_late_pass(Some(sess), true, pass);\n-                    }\n-\n-                    for (name, (to, deprecated_name)) in lint_groups {\n-                        ls.register_group(Some(sess), true, name, deprecated_name, to);\n-                    }\n-                    clippy_lints::register_pre_expansion_lints(sess, &mut ls, &conf);\n-                    clippy_lints::register_renamed(&mut ls);\n-\n-                    sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n-                    sess.plugin_attributes.borrow_mut().extend(attributes);\n-                });\n-            }\n-            controller.compilation_done.stop = Compilation::Stop;\n-\n+            let mut clippy = ClippyCallbacks;\n+            let mut default = rustc_driver::DefaultCallbacks;\n+            let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n+                if clippy_enabled { &mut clippy } else { &mut default };\n             let args = args;\n-            rustc_driver::run_compiler(&args, Box::new(controller), None, None)\n+            rustc_driver::run_compiler(&args, callbacks, None, None)\n         })\n-        .try_into()\n-        .expect(\"exit code too large\"),\n+        .and_then(|result| result)\n+        .is_err() as i32,\n     )\n }"}, {"sha": "63af1283bcc89a0a8ee9529f769e8b464fc6e9b0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -5,7 +5,7 @@\n #![warn(rust_2018_idioms)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate rustc_driver;\n #[allow(unused_extern_crates)]"}, {"sha": "ac47b195042ebfb3682978d7847888ef49a2f40f", "filename": "tests/ui-toml/conf_deprecated_key/clippy.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,6 @@\n+# that one is an error\n+cyclomatic-complexity-threshold = 42\n+\n+# that one is white-listed\n+[third-party]\n+clippy-feature = \"nightly\""}, {"sha": "2577c1eef92bc5b987edef4cf3aa9d91be3e81f7", "filename": "tests/ui-toml/conf_deprecated_key/conf_deprecated_key.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,4 @@\n+// error-pattern: error reading Clippy's configuration file: found deprecated field\n+// `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\n+\n+fn main() {}"}, {"sha": "34267c0daf7c2cfd50fc647b6cd3f2b891e32856", "filename": "tests/ui-toml/conf_deprecated_key/conf_deprecated_key.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,4 @@\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\n+\n+error: aborting due to previous error\n+"}, {"sha": "a1dd6b2f0819cb67361baacf14d6e51f1fcac992", "filename": "tests/ui-toml/good_toml_no_false_negatives/clippy.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,3 @@\n+# that one is white-listed\n+[third-party]\n+clippy-feature = \"nightly\""}, {"sha": "270b9c5c43c138883d76aa4c7e4733576b6d68c7", "filename": "tests/ui-toml/good_toml_no_false_negatives/conf_no_false_negatives.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern: should give absolutely no error\n+\n+fn main() {}"}, {"sha": "cdb1576b6776969d6780183e81814c71bbe9b51d", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `third-party`\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `third-party`\n \n error: aborting due to previous error\n "}, {"sha": "1d7bf607a14687078e81773111fb51e70373ed26", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,6 +1,6 @@\n if_chain! {\n     if let StmtKind::Local(ref local) = stmt.node;\n-    if let Some(ref init) = local.init\n+    if let Some(ref init) = local.init;\n     if let ExprKind::Cast(ref expr, ref cast_ty) = init.node;\n     if let TyKind::Path(ref qp) = cast_ty.node;\n     if match_qpath(qp, &[\"char\"]);"}, {"sha": "5c8c90c6b4c8f1bcd89b8e64b0b445e653be7ad9", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,6 +1,6 @@\n if_chain! {\n     if let StmtKind::Local(ref local) = stmt.node;\n-    if let Some(ref init) = local.init\n+    if let Some(ref init) = local.init;\n     if let ExprKind::Call(ref func, ref args) = init.node;\n     if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);"}, {"sha": "e223ba1a8302d5e34ddf3bcc6e1db3c3ee805184", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,7 +1,7 @@\n if_chain! {\n     if let ExprKind::Block(ref block) = expr.node;\n     if let StmtKind::Local(ref local) = block.node;\n-    if let Some(ref init) = local.init\n+    if let Some(ref init) = local.init;\n     if let ExprKind::Match(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n     if let ExprKind::Call(ref func, ref args) = expr.node;\n     if let ExprKind::Path(ref path) = func.node;\n@@ -41,15 +41,15 @@ if_chain! {\n     if let PatKind::Path(ref path7) = arms1[1].pats[0].node;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n     if let StmtKind::Local(ref local2) = path7.node;\n-    if let Some(ref init1) = local2.init\n+    if let Some(ref init1) = local2.init;\n     if let ExprKind::Path(ref path8) = init1.node;\n     if match_qpath(path8, &[\"__next\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local2.pat.node;\n     if name1.node.as_str() == \"y\";\n     if let StmtKind::Expr(ref e1, _) = local2.pat.node\n     if let ExprKind::Block(ref block1) = e1.node;\n     if let StmtKind::Local(ref local3) = block1.node;\n-    if let Some(ref init2) = local3.init\n+    if let Some(ref init2) = local3.init;\n     if let ExprKind::Path(ref path9) = init2.node;\n     if match_qpath(path9, &[\"y\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local3.pat.node;"}, {"sha": "689ee695b60104efb9027da1554d6e4d6c5ebe79", "filename": "tests/ui/author/matches.stout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,7 +1,7 @@\n if_chain! {\n     if let StmtKind::Decl(ref decl, _) = stmt.node\n     if let DeclKind::Local(ref local) = decl.node;\n-    if let Some(ref init) = local.init\n+    if let Some(ref init) = local.init;\n     if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.node;\n     if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(42, _) = lit.node;"}, {"sha": "10342ed28b5757e94b2db10eb3a168fd878cd561", "filename": "tests/ui/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -48,9 +48,10 @@ fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n fn pred_test() {\n     let v = 3;\n     let sky = \"blue\";\n-    // this is a sneaky case, where the block isn't directly in the condition, but is actually\n-    // inside a closure that the condition is using.  same principle applies.  add some extra\n-    // expressions to make sure linter isn't confused by them.\n+    // This is a sneaky case, where the block isn't directly in the condition,\n+    // but is actually nside a closure that the condition is using.\n+    // The same principle applies -- add some extra expressions to make sure\n+    // linter isn't confused by them.\n     if v == 3\n         && sky == \"blue\"\n         && predicate("}, {"sha": "0876d5db6964152aa585e57f11f4210f90d47909", "filename": "tests/ui/block_in_if_condition.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fblock_in_if_condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fblock_in_if_condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -31,7 +31,7 @@ LL |     if { true } {\n            } ... \n \n error: in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-  --> $DIR/block_in_if_condition.rs:57:17\n+  --> $DIR/block_in_if_condition.rs:58:17\n    |\n LL |               |x| {\n    |  _________________^\n@@ -41,7 +41,7 @@ LL | |             },\n    | |_____________^\n \n error: in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-  --> $DIR/block_in_if_condition.rs:66:13\n+  --> $DIR/block_in_if_condition.rs:67:13\n    |\n LL |           |x| {\n    |  _____________^\n@@ -51,7 +51,7 @@ LL | |         },\n    | |_________^\n \n error: this boolean expression can be simplified\n-  --> $DIR/block_in_if_condition.rs:76:8\n+  --> $DIR/block_in_if_condition.rs:77:8\n    |\n LL |     if true && x == 3 {\n    |        ^^^^^^^^^^^^^^ help: try: `x == 3`"}, {"sha": "36d31aa043bb9ec700bcd6e0f216fa1816521f33", "filename": "tests/ui/bool_comparison.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fbool_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fbool_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -73,3 +73,39 @@ fn main() {\n         \"no\"\n     };\n }\n+\n+#[allow(dead_code)]\n+fn issue3703() {\n+    struct Foo;\n+    impl PartialEq<bool> for Foo {\n+        fn eq(&self, _: &bool) -> bool {\n+            true\n+        }\n+    }\n+    impl PartialEq<Foo> for bool {\n+        fn eq(&self, _: &Foo) -> bool {\n+            true\n+        }\n+    }\n+    impl PartialOrd<bool> for Foo {\n+        fn partial_cmp(&self, _: &bool) -> Option<std::cmp::Ordering> {\n+            None\n+        }\n+    }\n+    impl PartialOrd<Foo> for bool {\n+        fn partial_cmp(&self, _: &Foo) -> Option<std::cmp::Ordering> {\n+            None\n+        }\n+    }\n+\n+    if Foo == true {}\n+    if true == Foo {}\n+    if Foo != true {}\n+    if true != Foo {}\n+    if Foo == false {}\n+    if false == Foo {}\n+    if Foo != false {}\n+    if false != Foo {}\n+    if Foo < false {}\n+    if false < Foo {}\n+}"}, {"sha": "08450ba117645b67b0f17d4845deded8762e9b55", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     (&1u8 as *const u8) as *const u16;\n     (&mut 1u8 as *mut u8) as *mut u16;\n \n-    /* These should be okay */\n+    /* These should be ok */\n \n     // not a pointer type\n     1u8 as u16;"}, {"sha": "089e5cfabe4b912fb6b819fa334d6476862a8455", "filename": "tests/ui/cast_ref_to_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_ref_to_mut.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -2,8 +2,8 @@\n #![allow(clippy::no_effect)]\n \n extern \"C\" {\n-    // NB. Mutability can be easily incorrect in FFI calls, as\n-    // in C, the default are mutable pointers.\n+    // N.B., mutability can be easily incorrect in FFI calls -- as\n+    // in C, the default is mutable pointers.\n     fn ffi(c: *mut u8);\n     fn int_ffi(c: *mut i32);\n }"}, {"sha": "4e4016e78c2a00685cac06b72f2587b925ccf330", "filename": "tests/ui/cognitive_complexity.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "patch": "@@ -1,5 +1,5 @@\n #![allow(clippy::all)]\n-#![warn(clippy::cyclomatic_complexity)]\n+#![warn(clippy::cognitive_complexity)]\n #![allow(unused)]\n \n #[rustfmt::skip]\n@@ -87,7 +87,7 @@ fn main() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn kaboom() {\n     let n = 0;\n     'a: for i in 0..20 {\n@@ -133,17 +133,17 @@ fn bloo() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn lots_of_short_circuits() -> bool {\n     true && false && true && false && true && false && true\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn lots_of_short_circuits2() -> bool {\n     true || false || true || false || true || false || true\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn baa() {\n     let x = || match 99 {\n         0 => 0,\n@@ -161,7 +161,7 @@ fn baa() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn bar() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -170,8 +170,8 @@ fn bar() {\n }\n \n #[test]\n-#[clippy::cyclomatic_complexity = \"0\"]\n-/// Tests are usually complex but simple at the same time. `clippy::cyclomatic_complexity` used to\n+#[clippy::cognitive_complexity = \"0\"]\n+/// Tests are usually complex but simple at the same time. `clippy::cognitive_complexity` used to\n /// give lots of false-positives in tests.\n fn dont_warn_on_tests() {\n     match 99 {\n@@ -180,7 +180,7 @@ fn dont_warn_on_tests() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -190,7 +190,7 @@ fn barr() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -206,7 +206,7 @@ fn barr2() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barrr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -216,7 +216,7 @@ fn barrr() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barrr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -232,7 +232,7 @@ fn barrr2() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barrrr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -242,7 +242,7 @@ fn barrrr() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn barrrr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -258,7 +258,7 @@ fn barrrr2() {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn cake() {\n     if 4 == 5 {\n         println!(\"yea\");\n@@ -268,7 +268,7 @@ fn cake() {\n     println!(\"whee\");\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n pub fn read_file(input_path: &str) -> String {\n     use std::fs::File;\n     use std::io::{Read, Write};\n@@ -299,28 +299,28 @@ pub fn read_file(input_path: &str) -> String {\n \n enum Void {}\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn void(void: Void) {\n     if true {\n         match void {}\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn mcarton_sees_all() {\n     panic!(\"meh\");\n     panic!(\"m\u00f6h\");\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn try() -> Result<i32, &'static str> {\n     match 5 {\n         5 => Ok(5),\n         _ => return Err(\"bla\"),\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn try_again() -> Result<i32, &'static str> {\n     let _ = try!(Ok(42));\n     let _ = try!(Ok(43));\n@@ -336,7 +336,7 @@ fn try_again() -> Result<i32, &'static str> {\n     }\n }\n \n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn early() -> Result<i32, &'static str> {\n     return Ok(5);\n     return Ok(5);\n@@ -350,7 +350,7 @@ fn early() -> Result<i32, &'static str> {\n }\n \n #[rustfmt::skip]\n-#[clippy::cyclomatic_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"0\"]\n fn early_ret() -> i32 {\n     let a = if true { 42 } else { return 0; };\n     let a = if a < 99 { 42 } else { return 0; };", "previous_filename": "tests/ui/cyclomatic_complexity.rs"}, {"sha": "168653b9711640d8c126e3f9ec826ba5165d4672", "filename": "tests/ui/cognitive_complexity.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "previous_filename": "tests/ui/cyclomatic_complexity.stderr"}, {"sha": "403eff566ed6d34d2a2ac92e58d9d94735782f62", "filename": "tests/ui/cognitive_complexity_attr_used.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity_attr_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity_attr_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity_attr_used.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "previous_filename": "tests/ui/cyclomatic_complexity_attr_used.rs"}, {"sha": "2cf41506f566c7688e750ac9549f3f9d1aafc6d5", "filename": "tests/ui/cognitive_complexity_attr_used.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity_attr_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcognitive_complexity_attr_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity_attr_used.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a", "previous_filename": "tests/ui/cyclomatic_complexity_attr_used.stderr"}, {"sha": "69570c515b6baba796330550d51e10b091b2a938", "filename": "tests/ui/collapsible_if.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcollapsible_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcollapsible_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.fixed?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "5dac42a3dd976aaf500ca991ccbed612a79a4c2e", "filename": "tests/ui/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "f1a229f3f4faf3a706ee0e721ad6c26b973b6135", "filename": "tests/ui/crashes/ice-2760.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-2760.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-2760.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2760.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "d44b0fae82001b3824b2a83c8d44e74eddacb0d8", "filename": "tests/ui/crashes/ice-2774.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-2774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-2774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2774.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "cdf018cbc88d8426193b2951d64734312df50dc2", "filename": "tests/ui/crashes/ice-3747.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-3747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fice-3747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-3747.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "6d2124c12fe98addb011233f1b737aa6077c341c", "filename": "tests/ui/crashes/used_underscore_binding_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "a8fc06af1d9bdb8f3b50d0d8518e0e1d654fc86e", "filename": "tests/ui/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdlist.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "039ce5d9c423edc8fda2c442870111288873ae34", "filename": "tests/ui/doc.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ae9bb394cb9ac726bcca6129a5e7bb1c3349741d", "filename": "tests/ui/doc.stderr", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdoc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdoc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "9c7590c7dd6324bc3afe069cf22bce3def645366", "filename": "tests/ui/double_parens.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_parens.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "0e4c9b5682dfb4748f74c808cdf56321583451ee", "filename": "tests/ui/double_parens.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdouble_parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fdouble_parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_parens.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "5343dff9da1db26078505730abf8edcea2383d2c", "filename": "tests/ui/empty_line_after_outer_attribute.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fempty_line_after_outer_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fempty_line_after_outer_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_line_after_outer_attribute.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "72692310391b126e9a894cef3bb9715233fec0ad", "filename": "tests/ui/empty_line_after_outer_attribute.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_line_after_outer_attribute.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "f777939c67d2f11261f32ebbafa88c6f1f061920", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "e111ee3dfeda50b4723c6d02630f1e7237c0dc68", "filename": "tests/ui/expect_fun_call.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.fixed?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "891ec883120c1f4a5a535629991ef2f9806e415b", "filename": "tests/ui/expect_fun_call.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "bb16fabd973bafc48d7583f92883758a6e48c94e", "filename": "tests/ui/expect_fun_call.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fexpect_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_fun_call.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ce8de0745773c7cf1f6cf4b223f584995233e5c8", "filename": "tests/ui/for_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ab973e07511375f7c2cbf03d528f7577e490a49d", "filename": "tests/ui/format.fixed", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "2ef31f0b9484cf79ba57e7f3ae1ffd7bc22815ce", "filename": "tests/ui/format.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "7ca63e2fea5186a9f7731f8e1524ee0702382271", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "149f1da93966c5d6d9524e41029c0b04e2eba4d7", "filename": "tests/ui/formatting.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformatting.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "29a5c55bc34b7512a1528294a6c5d830e7f9eedf", "filename": "tests/ui/formatting.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformatting.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "97e6b20f471fcf8bef96afdbeb493aa8f3deeee3", "filename": "tests/ui/get_unwrap.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fget_unwrap.fixed?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "1c9a71c09699afda778d8dba35896571a672d997", "filename": "tests/ui/get_unwrap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fget_unwrap.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "b27bef6d1cc9d65bb80d462feb82398c533ec037", "filename": "tests/ui/get_unwrap.stderr", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fget_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fget_unwrap.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "0ec933e87847d2ee6ebee32b216276bea9b6f5cb", "filename": "tests/ui/if_same_then_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "33462b0ea77d254cb7aea3dd95dc2c6b8e397a27", "filename": "tests/ui/issue_3849.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fissue_3849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fissue_3849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissue_3849.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "126c230ac4ccaf09006eac016f695b81c3b47f1e", "filename": "tests/ui/issue_3849.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fissue_3849.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fissue_3849.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissue_3849.stdout?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "db97c2427f372b23cf366b1673094d240030d533", "filename": "tests/ui/len_zero.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "f2ad0bb9e1e479edc9865f3ace57b2447ccd57f6", "filename": "tests/ui/len_zero.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flen_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flen_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "2cb236fa3bc3843d3303d282d70903e25d8c1859", "filename": "tests/ui/lifetimes.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "9eac0407e4d58fd2158af2644a7f86e23a4e3ad3", "filename": "tests/ui/lifetimes.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "8a7588f2e7f73bbc4bca255c75ecf1b3b3383b15", "filename": "tests/ui/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "b711367d123cfaf49c84304dd9d0aaa6fa511a93", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "b4159f7a68d08b28309fdd8e7715e8242b778b7b", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "46a16f75c7bcce4b91a916970a7dec6412ab37f1", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 122, "deletions": 63, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "cfbb0152eebdb9a130b069cb13dd49960c9c7255", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "115cc954dc7860f0287a7419f9a96641a8fa1f01", "filename": "tests/ui/missing_const_for_fn/cant_be_const.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "c76f4de9b07ab444a29aec630b1e81f4c22fe10d", "filename": "tests/ui/needless_borrowed_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "70ad6eac65f6d59dced91a7ad969c50b4d472adc", "filename": "tests/ui/needless_range_loop.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "dd8bd58c015c15e029c9d413c957a8a9d101db51", "filename": "tests/ui/proc_macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc_macro.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ec19cd8fc5fb8179a9404ca0a3703845cb3d05fe", "filename": "tests/ui/proc_macro.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fproc_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fproc_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc_macro.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "b1846a1096cbdb6305197c3b44ebe7946b73bf74", "filename": "tests/ui/rename.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ac850b60d9724f6042f43e90d93a14dbf248ded0", "filename": "tests/ui/rename.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "fdb425363e81729b17e72dc88cf7c466cf2d5f69", "filename": "tests/ui/renamed_builtin_attr.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frenamed_builtin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frenamed_builtin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frenamed_builtin_attr.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "cf6cccd368848d4050d05aad49f24a07c44937e5", "filename": "tests/ui/renamed_builtin_attr.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frenamed_builtin_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Frenamed_builtin_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frenamed_builtin_attr.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "3bc0448234ef63ddd0d8593ab69852408610ad81", "filename": "tests/ui/toplevel_ref_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "27db9594f3b3305c7385ccea3506a22f534740f1", "filename": "tests/ui/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funicode.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "e993e63f8ed86534d2b2af848c51e51c0be10481", "filename": "tests/ui/unknown_attribute.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funknown_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funknown_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funknown_attribute.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "47e37aed2464e4a5567ddb5ec62d16b2f67d8f50", "filename": "tests/ui/unknown_attribute.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funknown_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funknown_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funknown_attribute.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "641245896839daafc5224f8ecb224c69acb72463", "filename": "tests/ui/unused_unit.fixed", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.fixed?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "8e31385b70c9318f92c5dc5990704c617dede45e", "filename": "tests/ui/unused_unit.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "c33a220b98c0867cb6ecf20bc169d0112dbd3e4d", "filename": "tests/ui/unused_unit.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.stderr?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "cd8b3fb33c755049ddb5e31e74cb67729fdc1672", "filename": "tests/ui/update-references.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fupdate-references.sh?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "550e16a4a2045c6912a0b8b20c3eb57de35c1b77", "filename": "tests/ui/used_underscore_binding.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fused_underscore_binding.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "ee7f7306a4bf7978d50275ee3080649f3b27ba5f", "filename": "tests/ui/while_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/tests%2Fui%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_loop.rs?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "e11f2eeba3b32d11e5cd64b72a10b4c44498132c", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "391e22a4743ccdcd739f536304cf6736c63a609d", "filename": "util/gh-pages/versions.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Fgh-pages%2Fversions.html", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Fgh-pages%2Fversions.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Fversions.html?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}, {"sha": "a260e00cde460ad200a08dcd3470ba745e2f0ae4", "filename": "util/lintlib.py", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/6937d5581af14b71e23af0db81241a3fea11c70a/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=6937d5581af14b71e23af0db81241a3fea11c70a"}]}