{"sha": "9ae85e19dfb6172692908c514f4b4613fe8fe792", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZTg1ZTE5ZGZiNjE3MjY5MjkwOGM1MTRmNGI0NjEzZmU4ZmU3OTI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-04-26T12:07:13Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-04-27T16:31:23Z"}, "message": "Unify lints handling in rustdoc", "tree": {"sha": "f84d13f3330bee83d0aead46eb61545b64950e6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f84d13f3330bee83d0aead46eb61545b64950e6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ae85e19dfb6172692908c514f4b4613fe8fe792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae85e19dfb6172692908c514f4b4613fe8fe792", "html_url": "https://github.com/rust-lang/rust/commit/9ae85e19dfb6172692908c514f4b4613fe8fe792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ae85e19dfb6172692908c514f4b4613fe8fe792/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "019ab732ce63a117cbb446db1488916c5c0bd2a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/019ab732ce63a117cbb446db1488916c5c0bd2a7", "html_url": "https://github.com/rust-lang/rust/commit/019ab732ce63a117cbb446db1488916c5c0bd2a7"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "07996587fb532700b7f5aee90c6ac6e56ff82b9f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9ae85e19dfb6172692908c514f4b4613fe8fe792/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae85e19dfb6172692908c514f4b4613fe8fe792/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9ae85e19dfb6172692908c514f4b4613fe8fe792", "patch": "@@ -205,6 +205,56 @@ pub fn new_handler(\n     )\n }\n \n+/// This function is used to setup the lint initialization. By default, in rustdoc, everything\n+/// is \"allowed\". Depending if we run in test mode or not, we want some of them to be at their\n+/// default level. For example, the \"INVALID_CODEBLOCK_ATTRIBUTE\" lint is activated in both\n+/// modes.\n+///\n+/// A little detail easy to forget is that there is a way to set the lint level for all lints\n+/// through the \"WARNINGS\" lint. To prevent this to happen, we set it back to its \"normal\" level\n+/// inside this function.\n+///\n+/// It returns a tuple containing:\n+///  * Vector of tuples of lints' name and their associated \"max\" level\n+///  * HashMap of lint id with their associated \"max\" level\n+pub fn init_lints<F>(\n+    mut whitelisted_lints: Vec<String>,\n+    lint_opts: Vec<(String, lint::Level)>,\n+    filter_call: F,\n+) -> (Vec<(String, lint::Level)>, FxHashMap<lint::LintId, lint::Level>)\n+where\n+    F: Fn(&lint::Lint) -> Option<(String, lint::Level)>,\n+{\n+    let warnings_lint_name = lint::builtin::WARNINGS.name;\n+\n+    whitelisted_lints.push(warnings_lint_name.to_owned());\n+    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n+\n+    let lints = || {\n+        lint::builtin::HardwiredLints::get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints()\n+        .filter_map(|lint| if lint.name == warnings_lint_name { None } else { filter_call(lint) })\n+        .chain(lint_opts.into_iter())\n+        .collect::<Vec<_>>();\n+\n+    let lint_caps = lints()\n+        .filter_map(|lint| {\n+            // We don't want to whitelist *all* lints so let's\n+            // ignore those ones.\n+            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+                None\n+            } else {\n+                Some((lint::LintId::of(lint), lint::Allow))\n+            }\n+        })\n+        .collect();\n+    (lint_opts, lint_caps)\n+}\n+\n pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -248,7 +298,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let input = Input::File(input);\n \n     let intra_link_resolution_failure_name = lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE.name;\n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n@@ -257,8 +306,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints = vec![\n-        warnings_lint_name.to_owned(),\n+    let whitelisted_lints = vec![\n         intra_link_resolution_failure_name.to_owned(),\n         missing_docs.to_owned(),\n         missing_doc_example.to_owned(),\n@@ -267,39 +315,15 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n-    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name\n-                || lint.name == intra_link_resolution_failure_name\n-                || lint.name == invalid_codeblock_attribute_name\n-            {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(lint_opts.into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, lint_opts, |lint| {\n+        if lint.name == intra_link_resolution_failure_name\n+            || lint.name == invalid_codeblock_attribute_name\n+        {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types = if proc_macro_crate {\n         vec![config::CrateType::ProcMacro]"}, {"sha": "1cb249d0f867e9b250f991441693c78f05ef9e12", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9ae85e19dfb6172692908c514f4b4613fe8fe792/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae85e19dfb6172692908c514f4b4613fe8fe792/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9ae85e19dfb6172692908c514f4b4613fe8fe792", "patch": "@@ -26,6 +26,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n+use crate::core::init_lints;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::passes::span_of_attrs;\n \n@@ -43,44 +44,19 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints =\n-        vec![warnings_lint_name.to_owned(), invalid_codeblock_attribute_name.to_owned()];\n+    let whitelisted_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n \n-    whitelisted_lints.extend(options.lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name || lint.name == invalid_codeblock_attribute_name {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(options.lint_opts.clone().into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, options.lint_opts.clone(), |lint| {\n+        if lint.name == invalid_codeblock_attribute_name {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types = if options.proc_macro_crate {\n         vec![config::CrateType::ProcMacro]"}]}