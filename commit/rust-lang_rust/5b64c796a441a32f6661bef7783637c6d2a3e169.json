{"sha": "5b64c796a441a32f6661bef7783637c6d2a3e169", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNjRjNzk2YTQ0MWEzMmY2NjYxYmVmNzc4MzYzN2M2ZDJhM2UxNjk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T04:27:12Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T19:04:54Z"}, "message": "syntax/rustc: Improve error message for misuse of `for` loop\n\nPrint out a clearer error message when a `for` gets\nused with the wrong type of iterator. Also fix spans on `for` loop\nbodies, and suppress some more derived errors.\n\nr=brson\n\nCloses #3651", "tree": {"sha": "a61bbfdf1ce72b0bc2d833f56e1bfd4ca5fe3e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a61bbfdf1ce72b0bc2d833f56e1bfd4ca5fe3e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b64c796a441a32f6661bef7783637c6d2a3e169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b64c796a441a32f6661bef7783637c6d2a3e169", "html_url": "https://github.com/rust-lang/rust/commit/5b64c796a441a32f6661bef7783637c6d2a3e169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b64c796a441a32f6661bef7783637c6d2a3e169/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f4da78e78238d7a24dc452302a4c1f113f0e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f4da78e78238d7a24dc452302a4c1f113f0e2a", "html_url": "https://github.com/rust-lang/rust/commit/e8f4da78e78238d7a24dc452302a4c1f113f0e2a"}], "stats": {"total": 163, "additions": 104, "deletions": 59}, "files": [{"sha": "3634ca24ccb23a7f346d80b16007af89afc782ce", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -1497,7 +1497,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           match ty::get(lhs_resolved_t).sty {\n             ty::ty_fn(_) => {\n               tcx.sess.span_note(\n-                  ex.span, ~\"did you forget the 'do' keyword for the call?\");\n+                  ex.span, ~\"did you forget the `do` keyword for the call?\");\n             }\n             _ => ()\n           }\n@@ -2207,23 +2207,33 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           Some(ty::ty_fn(ref fty)) => {\n             match fcx.mk_subty(false, expr.span,\n                                (*fty).sig.output, ty::mk_bool(tcx)) {\n-              result::Ok(_) => (),\n+              result::Ok(_) =>\n+                  ty::mk_fn(tcx, FnTyBase {\n+                      meta: (*fty).meta,\n+                      sig: FnSig {output: ty::mk_nil(tcx),\n+                                  ../*bad*/copy (*fty).sig}\n+                  }),\n               result::Err(_) => {\n                    fcx.type_error_message(expr.span,\n                       |actual| {\n-                          fmt!(\"a `loop` function's last argument \\\n-                                should return `bool`, not `%s`\", actual)\n+                          fmt!(\"A `for` loop iterator should expect a \\\n+                                closure that returns `bool`. This iterator \\\n+                                expects a closure that returns `%s`. %s\",\n+                               actual, if ty::type_is_nil((*fty).sig.output) {\n+                                   \"\\nDid you mean to use `do` instead of \\\n+                                        `for`?\" } else { \"\" } )\n                       },\n                       (*fty).sig.output, None);\n                 err_happened = true;\n+                // Kind of a hack: create a function type with the result\n+                // replaced with ty_err, to suppress derived errors.\n+                let t = ty::replace_fn_return_type(tcx, ty::mk_fn(tcx,\n+                                                                  copy *fty),\n+                                                   ty::mk_err(tcx));\n                 fcx.write_ty(id, ty::mk_err(tcx));\n+                t\n               }\n             }\n-            ty::mk_fn(tcx, FnTyBase {\n-                meta: (*fty).meta,\n-                sig: FnSig {output: ty::mk_nil(tcx),\n-                            ../*bad*/copy (*fty).sig}\n-            })\n           }\n           _ =>\n               match expected {\n@@ -2245,14 +2255,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n-            check_expr_fn(fcx, b, None,\n-                          decl, *body, ForLoop, Some(inner_ty));\n-            demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-            capture::check_capture_clause(tcx, b.id, cap_clause);\n-          }\n-          // argh\n-          _ => fail ~\"expr_fn_block\"\n+                ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n+                    // If an error occurred, we pretend this isn't a for\n+                    // loop, so as to assign types to all nodes while also\n+                    // propagating ty_err throughout so as to suppress\n+                    // derived errors. If we passed in ForLoop in the\n+                    // error case, we'd potentially emit a spurious error\n+                    // message because of the indirect_ret_ty.\n+                    let fn_kind = if err_happened { Vanilla }\n+                                  else { ForLoop };\n+                    check_expr_fn(fcx, b, None,\n+                                  decl, *body, fn_kind, Some(inner_ty));\n+                    demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n+                    capture::check_capture_clause(tcx, b.id, cap_clause);\n+                }\n+                // argh\n+                _ => fail ~\"expr_fn_block\"\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));"}, {"sha": "7183b623ef4d618530dbf47f8d93729b9e72b942", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -1660,43 +1660,45 @@ impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-          expr_call(f, args, false) => {\n-            let block = self.parse_lambda_block_expr();\n-            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                    ctor(block));\n-            let args = vec::append(args, ~[last_arg]);\n-            @expr {node: expr_call(f, args, true), .. *e}\n-          }\n-          expr_method_call(f, i, tps, args, false) => {\n-            let block = self.parse_lambda_block_expr();\n-            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                    ctor(block));\n-            let args = vec::append(args, ~[last_arg]);\n-            @expr {node: expr_method_call(f, i, tps, args, true), .. *e}\n-          }\n-          expr_field(f, i, tps) => {\n-            let block = self.parse_lambda_block_expr();\n-            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                    ctor(block));\n-            @expr {node: expr_method_call(f, i, tps, ~[last_arg], true),\n-                   .. *e}\n-          }\n-          expr_path(*) | expr_call(*) | expr_method_call(*) |\n-          expr_paren(*) => {\n-            let block = self.parse_lambda_block_expr();\n-            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                    ctor(block));\n-            self.mk_expr(lo.lo, last_arg.span.hi,\n-                         expr_call(e, ~[last_arg], true))\n-          }\n-          _ => {\n-            // There may be other types of expressions that can\n-            // represent the callee in `for` and `do` expressions\n-            // but they aren't represented by tests\n-            debug!(\"sugary call on %?\", e.node);\n-            self.span_fatal(\n-                lo, fmt!(\"`%s` must be followed by a block call\", keyword));\n-          }\n+            expr_call(f, args, false) => {\n+                let block = self.parse_lambda_block_expr();\n+                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                            ctor(block));\n+                let args = vec::append(args, ~[last_arg]);\n+                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, true))\n+            }\n+            expr_method_call(f, i, tps, args, false) => {\n+                let block = self.parse_lambda_block_expr();\n+                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                            ctor(block));\n+                let args = vec::append(args, ~[last_arg]);\n+                self.mk_expr(lo.lo, block.span.hi,\n+                             expr_method_call(f, i, tps, args, true))\n+            }\n+            expr_field(f, i, tps) => {\n+                let block = self.parse_lambda_block_expr();\n+                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                            ctor(block));\n+                self.mk_expr(lo.lo, block.span.hi,\n+                             expr_method_call(f, i, tps, ~[last_arg], true))\n+            }\n+            expr_path(*) | expr_call(*) | expr_method_call(*) |\n+                expr_paren(*) => {\n+                let block = self.parse_lambda_block_expr();\n+                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                            ctor(block));\n+                self.mk_expr(lo.lo, last_arg.span.hi,\n+                             expr_call(e, ~[last_arg], true))\n+            }\n+            _ => {\n+                // There may be other types of expressions that can\n+                // represent the callee in `for` and `do` expressions\n+                // but they aren't represented by tests\n+                debug!(\"sugary call on %?\", e.node);\n+                self.span_fatal(\n+                    lo, fmt!(\"`%s` must be followed by a block call\",\n+                             keyword));\n+            }\n         }\n     }\n "}, {"sha": "bda463031fae93341f07e709ecee7b0d64974b23", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     fn baz(_x: fn(y: int) -> int) {}\n-    for baz |_e| { } //~ ERROR should return `bool`\n+    for baz |_e| { } //~ ERROR A `for` loop iterator should expect a closure that returns `bool`\n }"}, {"sha": "0bbf86c8fc3a3b093362246482ec44a03cc6b328", "filename": "src/test/compile-fail/issue-2817-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -14,13 +14,12 @@ fn main() {\n     for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but\n         false\n     };\n-    for not_bool |_i| { //~ ERROR a `loop` function's last argument should return `bool`\n-        //~^ ERROR A for-loop body must return (), but\n+    for not_bool |_i| { //~ ERROR a `for` loop iterator should expect a closure that returns `bool`\n         ~\"hi\"\n     };\n     for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but\n         ~\"hi\"\n     };\n-    for not_bool() |_i| { //~ ERROR a `loop` function's last argument\n+    for not_bool() |_i| { //~ ERROR a `for` loop iterator should expect a closure that returns `bool`\n     };\n }\n\\ No newline at end of file"}, {"sha": "bb20be701db40b696d4ec6ef20ebb1deb63891d3", "filename": "src/test/compile-fail/issue-3651-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    do 5.times {} //~ ERROR Do-block body must return bool, but returns () here. Perhaps\n+}\n\\ No newline at end of file"}, {"sha": "392c1415d8a7157a7bf5299c4290e47422c662ad", "filename": "src/test/compile-fail/issue-3651.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    for task::spawn { return true; } //~ ERROR A `for` loop iterator should expect a closure that\n+}\n\\ No newline at end of file"}, {"sha": "fc4a4c11e7d2744210b49a04f421fbab6f2f16e8", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64c796a441a32f6661bef7783637c6d2a3e169/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=5b64c796a441a32f6661bef7783637c6d2a3e169", "patch": "@@ -15,5 +15,5 @@ fn foo(f: fn()) { f() }\n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`\n     foo || {}; //~ ERROR binary operation || cannot be applied to type `extern fn(&fn())`\n-    //~^ NOTE did you forget the 'do' keyword for the call?\n+    //~^ NOTE did you forget the `do` keyword for the call?\n }"}]}