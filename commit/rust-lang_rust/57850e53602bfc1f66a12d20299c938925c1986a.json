{"sha": "57850e53602bfc1f66a12d20299c938925c1986a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ODUwZTUzNjAyYmZjMWY2NmExMmQyMDI5OWM5Mzg5MjVjMTk4NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-15T12:46:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-15T12:46:10Z"}, "message": "Auto merge of #47445 - kennytm:rollup, r=kennytm\n\nRollup of 10 pull requests\n\n- Successful merges: #47120, #47126, #47277, #47330, #47368, #47372, #47414, #47417, #47432, #47443\n- Failed merges: #47334", "tree": {"sha": "1c651f8565c0b8fccd04a7229d509c041c03b5bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c651f8565c0b8fccd04a7229d509c041c03b5bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57850e53602bfc1f66a12d20299c938925c1986a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57850e53602bfc1f66a12d20299c938925c1986a", "html_url": "https://github.com/rust-lang/rust/commit/57850e53602bfc1f66a12d20299c938925c1986a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57850e53602bfc1f66a12d20299c938925c1986a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff449d505728276e822ca9a80c1e7b2da8288a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff449d505728276e822ca9a80c1e7b2da8288a2", "html_url": "https://github.com/rust-lang/rust/commit/8ff449d505728276e822ca9a80c1e7b2da8288a2"}, {"sha": "fa008c02f183130435a2d367088c51fdd2c89209", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa008c02f183130435a2d367088c51fdd2c89209", "html_url": "https://github.com/rust-lang/rust/commit/fa008c02f183130435a2d367088c51fdd2c89209"}], "stats": {"total": 872, "additions": 660, "deletions": 212}, "files": [{"sha": "f1656993e87a5f12c159680a43592468b62a56a2", "filename": "src/doc/unstable-book/src/language-features/crate-in-paths.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md?ref=57850e53602bfc1f66a12d20299c938925c1986a", "previous_filename": "src/doc/unstable-book/src/language-features/crate_in_paths.md"}, {"sha": "f45c5053e8dbcd84b7a8a215b2f8439b1c1ba5f5", "filename": "src/doc/unstable-book/src/language-features/extern-absolute-paths.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md?ref=57850e53602bfc1f66a12d20299c938925c1986a", "previous_filename": "src/doc/unstable-book/src/language-features/extern_absolute_paths.md"}, {"sha": "3ae6cc29df0b871537102122fdf06448eea5d132", "filename": "src/doc/unstable-book/src/language-features/extern-in-paths.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md?ref=57850e53602bfc1f66a12d20299c938925c1986a", "previous_filename": "src/doc/unstable-book/src/language-features/extern_in_paths.md"}, {"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match-default-bindings.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md?ref=57850e53602bfc1f66a12d20299c938925c1986a", "previous_filename": "src/doc/unstable-book/src/language-features/match_default_bindings.md"}, {"sha": "d8ce28695ab6f3049a6ea5e0c5ec7fe6fe8b36de", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -124,6 +124,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n+#![feature(exact_chunks)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "861f72bcf88ee42b2e5fcf711a9fc1a1a6c358f4", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -123,6 +123,8 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_ref_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n pub use core::slice::SliceIndex;\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub use core::slice::{ExactChunks, ExactChunksMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -611,6 +613,9 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will\n     /// not have length `chunk_size`.\n     ///\n+    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n@@ -631,11 +636,44 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.exact_chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        core_slice::SliceExt::exact_chunks(self, chunk_size)\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///\n+    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n@@ -660,6 +698,42 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.exact_chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "eee229bc6fdfa7aef1d6a908dcfa319a39cb25c1", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -30,6 +30,7 @@\n #![feature(string_retain)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(exact_chunks)]\n \n extern crate alloc_system;\n extern crate std_unicode;"}, {"sha": "1a9d26fd1a29150b5c18f950d49f0b5deb70aa4b", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -945,6 +945,30 @@ fn test_chunksator_0() {\n     let _it = v.chunks(0);\n }\n \n+#[test]\n+fn test_exact_chunksator() {\n+    let v = &[1, 2, 3, 4, 5];\n+\n+    assert_eq!(v.exact_chunks(2).len(), 2);\n+\n+    let chunks: &[&[_]] = &[&[1, 2], &[3, 4]];\n+    assert_eq!(v.exact_chunks(2).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[1, 2, 3]];\n+    assert_eq!(v.exact_chunks(3).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[];\n+    assert_eq!(v.exact_chunks(6).collect::<Vec<_>>(), chunks);\n+\n+    let chunks: &[&[_]] = &[&[3, 4], &[1, 2]];\n+    assert_eq!(v.exact_chunks(2).rev().collect::<Vec<_>>(), chunks);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_exact_chunksator_0() {\n+    let v = &[1, 2, 3, 4];\n+    let _it = v.exact_chunks(0);\n+}\n+\n #[test]\n fn test_reverse_part() {\n     let mut values = [1, 2, 3, 4, 5];\n@@ -1159,7 +1183,7 @@ fn test_mut_chunks() {\n         }\n     }\n     let result = [0, 0, 0, 1, 1, 1, 2];\n-    assert!(v == result);\n+    assert_eq!(v, result);\n }\n \n #[test]\n@@ -1171,7 +1195,7 @@ fn test_mut_chunks_rev() {\n         }\n     }\n     let result = [2, 2, 2, 1, 1, 1, 0];\n-    assert!(v == result);\n+    assert_eq!(v, result);\n }\n \n #[test]\n@@ -1181,6 +1205,38 @@ fn test_mut_chunks_0() {\n     let _it = v.chunks_mut(0);\n }\n \n+#[test]\n+fn test_mut_exact_chunks() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    assert_eq!(v.exact_chunks_mut(2).len(), 3);\n+    for (i, chunk) in v.exact_chunks_mut(3).enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 0, 0, 1, 1, 1, 6];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+fn test_mut_exact_chunks_rev() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    for (i, chunk) in v.exact_chunks_mut(3).rev().enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [1, 1, 1, 0, 0, 0, 6];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mut_exact_chunks_0() {\n+    let mut v = [1, 2, 3, 4];\n+    let _it = v.exact_chunks_mut(0);\n+}\n+\n #[test]\n fn test_mut_last() {\n     let mut x = [1, 2, 3, 4, 5];"}, {"sha": "48e82666d35151cafa566bf965cddd874cb8b283", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -104,6 +104,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks(&self, size: usize) -> ExactChunks<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<Self>;\n@@ -181,6 +184,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks_mut(&mut self, size: usize) -> ExactChunksMut<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn swap(&mut self, a: usize, b: usize);\n \n@@ -356,6 +362,14 @@ impl<T> SliceExt for [T] {\n         Chunks { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<[T]>\n@@ -539,6 +553,14 @@ impl<T> SliceExt for [T] {\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn swap(&mut self, a: usize, b: usize) {\n         unsafe {\n@@ -2378,6 +2400,209 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n     fn may_have_side_effect() -> bool { false }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time).\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks`] method on [slices].\n+///\n+/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunks<'a, T:'a> {\n+    v: &'a [T],\n+    chunk_size: usize\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Clone for ExactChunks<'a, T> {\n+    fn clone(&self) -> ExactChunks<'a, T> {\n+        ExactChunks {\n+            v: self.v,\n+            chunk_size: self.chunk_size,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (_, snd) = self.v.split_at(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n+        let start = i * self.chunk_size;\n+        from_raw_parts(self.v.as_ptr().offset(start as isize), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time). When the slice len is not evenly divided by the chunk\n+/// size, the last up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n+///\n+/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunksMut<'a, T:'a> {\n+    v: &'a mut [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (_, snd) = tmp.split_at_mut(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n+        let start = i * self.chunk_size;\n+        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n //\n // Free functions\n //"}, {"sha": "2c0009569d75d60dccb391fe2a3a79332f96f929", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -42,6 +42,7 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(unique)]\n+#![feature(exact_chunks)]\n \n extern crate core;\n extern crate test;"}, {"sha": "f7a4a71e5cfda4909700cd455c5b762d6a3965cd", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 112, "deletions": 8, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -117,12 +117,12 @@ fn test_chunks_count() {\n fn test_chunks_nth() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n     let mut c = v.chunks(2);\n-    assert_eq!(c.nth(1).unwrap()[1], 3);\n-    assert_eq!(c.next().unwrap()[0], 4);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n     let mut c2 = v2.chunks(3);\n-    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n     assert_eq!(c2.next(), None);\n }\n \n@@ -168,24 +168,24 @@ fn test_chunks_mut_count() {\n fn test_chunks_mut_nth() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let mut c = v.chunks_mut(2);\n-    assert_eq!(c.nth(1).unwrap()[1], 3);\n-    assert_eq!(c.next().unwrap()[0], 4);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let mut c2 = v2.chunks_mut(3);\n-    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n fn test_chunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let c = v.chunks_mut(2);\n-    assert_eq!(c.last().unwrap()[1], 5);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let c2 = v2.chunks_mut(2);\n-    assert_eq!(c2.last().unwrap()[0], 4);\n+    assert_eq!(c2.last().unwrap(), &[4]);\n }\n \n #[test]\n@@ -202,6 +202,110 @@ fn test_chunks_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 14]);\n }\n \n+#[test]\n+fn test_exact_chunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.exact_chunks(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_exact_chunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.exact_chunks(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.exact_chunks(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_exact_chunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks(2);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks(2);\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1.exact_chunks(2)\n+        .zip(v2.exact_chunks(2))\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![14, 22]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_count() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks_mut(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks_mut(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &mut [i32] = &mut [];\n+    let c3 = v3.exact_chunks_mut(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_nth() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.exact_chunks_mut(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.exact_chunks_mut(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks_mut(2);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks_mut(2);\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_zip() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    for (a, b) in v1.exact_chunks_mut(2).zip(v2.exact_chunks(2)) {\n+        let sum = b.iter().sum::<i32>();\n+        for v in a {\n+            *v += sum;\n+        }\n+    }\n+    assert_eq!(v1, [13, 14, 19, 20, 4]);\n+}\n+\n #[test]\n fn test_windows_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}, {"sha": "33234ffb66388086be1872a5ee9a342a66236905", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -37,7 +37,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n+use rustc_passes::{self, ast_validation, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n use ::DefaultTransCrate;\n@@ -852,10 +852,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    time(time_passes,\n-         \"checking for inline asm in case the target doesn't support it\",\n-         || no_asm::check_crate(sess, &krate));\n-\n     time(time_passes,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));"}, {"sha": "c0ce32cc970683effe0ae338c303e681dcb40a98", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -92,9 +92,19 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n             let cfg = items.iter().find(|k| {\n                 k.check_name(\"cfg\")\n             }).and_then(|a| a.meta_item_list());\n-            let cfg = cfg.map(|list| {\n-                list[0].meta_item().unwrap().clone()\n-            });\n+            let cfg = if let Some(list) = cfg {\n+                if list.is_empty() {\n+                    self.tcx.sess.span_err(m.span(), \"`cfg()` must have an argument\");\n+                    return;\n+                } else if let cfg @ Some(..) = list[0].meta_item() {\n+                    cfg.cloned()\n+                } else {\n+                    self.tcx.sess.span_err(list[0].span(), \"invalid argument for `cfg(..)`\");\n+                    return;\n+                }\n+            } else {\n+                None\n+            };\n             let foreign_items = fm.items.iter()\n                 .map(|it| self.tcx.hir.local_def_id(it.id))\n                 .collect();"}, {"sha": "3f49128d2e82386f8f16f4474468f1a9da912e1b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -149,6 +149,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span);\n             }\n+            ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n+                span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n+            }\n             _ => {}\n         }\n "}, {"sha": "73c71ec0b2f005a79d02a126c1316e145115de68", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -42,7 +42,6 @@ pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n mod mir_stats;\n-pub mod no_asm;\n pub mod static_recursion;\n \n #[cfg(not(stage0))] // remove after the next snapshot"}, {"sha": "4dbf57a99bcbe1395e060ecd59eb48bd863b8078", "filename": "src/librustc_passes/no_asm.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ff449d505728276e822ca9a80c1e7b2da8288a2/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff449d505728276e822ca9a80c1e7b2da8288a2/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=8ff449d505728276e822ca9a80c1e7b2da8288a2", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Run over the whole crate and check for ExprInlineAsm.\n-/// Inline asm isn't allowed on virtual ISA based targets, so we reject it\n-/// here.\n-\n-use rustc::session::Session;\n-\n-use syntax::ast;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n-\n-pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    if sess.target.target.options.allow_asm {\n-        return;\n-    }\n-\n-    visit::walk_crate(&mut CheckNoAsm { sess: sess }, krate);\n-}\n-\n-#[derive(Copy, Clone)]\n-struct CheckNoAsm<'a> {\n-    sess: &'a Session,\n-}\n-\n-impl<'a> Visitor<'a> for CheckNoAsm<'a> {\n-    fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        match e.node {\n-            ast::ExprKind::InlineAsm(_) => {\n-                span_err!(self.sess,\n-                          e.span,\n-                          E0472,\n-                          \"asm! is unsupported on this target\")\n-            }\n-            _ => {}\n-        }\n-        visit::walk_expr(self, e)\n-    }\n-}"}, {"sha": "5e5695f15ac3faa526ebb33d7fe924d8c9f8b6fe", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -472,20 +472,19 @@ impl f32 {\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n+    /// The result may not be correctly rounded owing to implementation details;\n+    /// `self.log2()` can produce more accurate results for base 2, and\n+    /// `self.log10()` can produce more accurate results for base 10.\n+    ///\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let ten = 10.0f32;\n-    /// let two = 2.0f32;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n+    /// let five = 5.0f32;\n     ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n+    /// // log5(5) - 1 == 0\n+    /// let abs_difference = (five.log(5.0) - 1.0).abs();\n     ///\n-    /// assert!(abs_difference_10 <= f32::EPSILON);\n-    /// assert!(abs_difference_2 <= f32::EPSILON);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "e4eea745bb77c17bde809aceb03504427b57eca6", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -432,18 +432,17 @@ impl f64 {\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n-    /// ```\n-    /// let ten = 10.0_f64;\n-    /// let two = 2.0_f64;\n+    /// The result may not be correctly rounded owing to implementation details;\n+    /// `self.log2()` can produce more accurate results for base 2, and\n+    /// `self.log10()` can produce more accurate results for base 10.\n     ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n+    /// ```\n+    /// let five = 5.0_f64;\n     ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n+    /// // log5(5) - 1 == 0\n+    /// let abs_difference = (five.log(5.0) - 1.0).abs();\n     ///\n-    /// assert!(abs_difference_10 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n+    /// assert!(abs_difference < 1e-10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "4e7db5f08261f69c6a2456ecf304c1416a2623c6", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -345,8 +345,8 @@ impl<R: Seek> Seek for BufReader<R> {\n ///\n /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n ///\n-/// for i in 1..10 {\n-///     stream.write(&[i]).unwrap();\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n /// }\n /// ```\n ///\n@@ -361,8 +361,8 @@ impl<R: Seek> Seek for BufReader<R> {\n ///\n /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n ///\n-/// for i in 1..10 {\n-///     stream.write(&[i]).unwrap();\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n /// }\n /// ```\n ///"}, {"sha": "f0b41f30251e09d10209422ea9cd23eb139588ad", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -62,12 +62,18 @@ pub type Result<T> = result::Result<T, Error>;\n /// [`Write`]: ../io/trait.Write.html\n /// [`Seek`]: ../io/trait.Seek.html\n /// [`ErrorKind`]: enum.ErrorKind.html\n-#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Error {\n     repr: Repr,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.repr, f)\n+    }\n+}\n+\n enum Repr {\n     Os(i32),\n     Simple(ErrorKind),\n@@ -511,10 +517,12 @@ impl Error {\n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Repr::Os(ref code) =>\n-                fmt.debug_struct(\"Os\").field(\"code\", code)\n-                   .field(\"message\", &sys::os::error_string(*code)).finish(),\n-            Repr::Custom(ref c) => fmt.debug_tuple(\"Custom\").field(c).finish(),\n+            Repr::Os(code) =>\n+                fmt.debug_struct(\"Os\")\n+                    .field(\"code\", &code)\n+                    .field(\"kind\", &sys::decode_error_kind(code))\n+                    .field(\"message\", &sys::os::error_string(code)).finish(),\n+            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n             Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n         }\n     }\n@@ -559,17 +567,36 @@ fn _assert_error_is_sync_send() {\n \n #[cfg(test)]\n mod test {\n-    use super::{Error, ErrorKind};\n+    use super::{Error, ErrorKind, Repr, Custom};\n     use error;\n     use fmt;\n     use sys::os::error_string;\n+    use sys::decode_error_kind;\n \n     #[test]\n     fn test_debug_error() {\n         let code = 6;\n         let msg = error_string(code);\n-        let err = Error { repr: super::Repr::Os(code) };\n-        let expected = format!(\"Error {{ repr: Os {{ code: {:?}, message: {:?} }} }}\", code, msg);\n+        let kind = decode_error_kind(code);\n+        let err = Error {\n+            repr: Repr::Custom(box Custom {\n+                kind: ErrorKind::InvalidInput,\n+                error: box Error {\n+                    repr: super::Repr::Os(code)\n+                },\n+            })\n+        };\n+        let expected = format!(\n+            \"Custom {{ \\\n+                kind: InvalidInput, \\\n+                error: Os {{ \\\n+                    code: {:?}, \\\n+                    kind: {:?}, \\\n+                    message: {:?} \\\n+                }} \\\n+            }}\",\n+            code, kind, msg\n+        );\n         assert_eq!(format!(\"{:?}\", err), expected);\n     }\n "}, {"sha": "08bc809ed4d4632ac29dc8f5422487ce2dacfa1a", "filename": "src/libstd/rand/reader.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8ff449d505728276e822ca9a80c1e7b2da8288a2/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff449d505728276e822ca9a80c1e7b2da8288a2/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=8ff449d505728276e822ca9a80c1e7b2da8288a2", "patch": "@@ -1,108 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A wrapper around any Read to treat it as an RNG.\n-\n-#![allow(dead_code)]\n-\n-use io::prelude::*;\n-use rand::Rng;\n-\n-/// An RNG that reads random bytes straight from a `Read`. This will\n-/// work best with an infinite reader, but this is not required.\n-///\n-/// # Panics\n-///\n-/// It will panic if it there is insufficient data to fulfill a request.\n-pub struct ReaderRng<R> {\n-    reader: R\n-}\n-\n-impl<R: Read> ReaderRng<R> {\n-    /// Create a new `ReaderRng` from a `Read`.\n-    pub fn new(r: R) -> ReaderRng<R> {\n-        ReaderRng {\n-            reader: r\n-        }\n-    }\n-}\n-\n-impl<R: Read> Rng for ReaderRng<R> {\n-    fn next_u32(&mut self) -> u32 {\n-        // This is designed for speed: reading a LE integer on a LE\n-        // platform just involves blitting the bytes into the memory\n-        // of the u32, similarly for BE on BE; avoiding byteswapping.\n-        let mut bytes = [0; 4];\n-        self.fill_bytes(&mut bytes);\n-        unsafe { *(bytes.as_ptr() as *const u32) }\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        // see above for explanation.\n-        let mut bytes = [0; 8];\n-        self.fill_bytes(&mut bytes);\n-        unsafe { *(bytes.as_ptr() as *const u64) }\n-    }\n-    fn fill_bytes(&mut self, mut v: &mut [u8]) {\n-        while !v.is_empty() {\n-            let t = v;\n-            match self.reader.read(t) {\n-                Ok(0) => panic!(\"ReaderRng.fill_bytes: EOF reached\"),\n-                Ok(n) => v = t.split_at_mut(n).1,\n-                Err(e) => panic!(\"ReaderRng.fill_bytes: {}\", e),\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::ReaderRng;\n-    use rand::Rng;\n-\n-    #[test]\n-    fn test_reader_rng_u64() {\n-        // transmute from the target to avoid endianness concerns.\n-        let v = &[0, 0, 0, 0, 0, 0, 0, 1,\n-                  0, 0, 0, 0, 0, 0, 0, 2,\n-                  0, 0, 0, 0, 0, 0, 0, 3][..];\n-        let mut rng = ReaderRng::new(v);\n-\n-        assert_eq!(rng.next_u64(), 1u64.to_be());\n-        assert_eq!(rng.next_u64(), 2u64.to_be());\n-        assert_eq!(rng.next_u64(), 3u64.to_be());\n-    }\n-    #[test]\n-    fn test_reader_rng_u32() {\n-        let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n-        let mut rng = ReaderRng::new(v);\n-\n-        assert_eq!(rng.next_u32(), 1u32.to_be());\n-        assert_eq!(rng.next_u32(), 2u32.to_be());\n-        assert_eq!(rng.next_u32(), 3u32.to_be());\n-    }\n-    #[test]\n-    fn test_reader_rng_fill_bytes() {\n-        let v = [1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut w = [0; 8];\n-\n-        let mut rng = ReaderRng::new(&v[..]);\n-        rng.fill_bytes(&mut w);\n-\n-        assert!(v == w);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_reader_rng_insufficient_bytes() {\n-        let mut rng = ReaderRng::new(&[][..]);\n-        let mut v = [0; 3];\n-        rng.fill_bytes(&mut v);\n-    }\n-}"}, {"sha": "8ad576472903b0354614f4b4576c9c2fbd04e5e2", "filename": "src/test/compile-fail/issue-43925.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fcompile-fail%2Fissue-43925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fcompile-fail%2Fissue-43925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43925.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+#[link(name=\"foo\", cfg(\"rlib\"))] //~ ERROR invalid argument for `cfg(..)`\n+extern {}\n+\n+fn main() {}"}, {"sha": "5d510b643a349e96c2603addf4835b59ee3095ed", "filename": "src/test/compile-fail/issue-43926.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fcompile-fail%2Fissue-43926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fcompile-fail%2Fissue-43926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43926.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name=\"foo\", cfg())] //~ ERROR `cfg()` must have an argument\n+extern {}\n+\n+fn main() {}"}, {"sha": null, "filename": "src/test/ui-fulldeps/update-references.sh", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh?ref=57850e53602bfc1f66a12d20299c938925c1986a"}, {"sha": "d7c15851418b1d0cc82c57c3649b730f22da1ea2", "filename": "src/test/ui/nll/borrowed-referent-issue-38899.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #38899\n+\n+#![feature(nll)]\n+#![allow(dead_code)]\n+\n+pub struct Block<'a> {\n+    current: &'a u8,\n+    unrelated: &'a u8,\n+}\n+\n+fn bump<'a>(mut block: &mut Block<'a>) {\n+    let x = &mut block;\n+    println!(\"{}\", x.current);\n+    let p: &'a u8 = &*block.current;\n+    //~^ ERROR cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n+    drop(x);\n+    drop(p);\n+}\n+\n+fn main() {}"}, {"sha": "3031fec2d0b2173e34925938b604e292ce22907f", "filename": "src/test/ui/nll/borrowed-referent-issue-38899.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,11 @@\n+error[E0502]: cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowed-referent-issue-38899.rs:24:21\n+   |\n+22 |     let x = &mut block;\n+   |             ---------- mutable borrow occurs here\n+23 |     println!(\"{}\", x.current);\n+24 |     let p: &'a u8 = &*block.current;\n+   |                     ^^^^^^^^^^^^^^^ immutable borrow occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "79150f340cad84f4feb9fef1db883720aca0c6a6", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #46557\n+\n+#![feature(nll)]\n+#![allow(dead_code)]\n+\n+fn gimme_static_mut() -> &'static mut u32 {\n+    let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "763e2bfd8929447f270a2d7bc6b9d9a74d9ad6d0", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/return-ref-mut-issue-46557.rs:17:21\n+   |\n+17 |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   |                     ^^^^^^^ temporary value does not live long enough\n+18 |     x\n+19 | }\n+   |  - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for lifetime '_#2r...\n+\n+error: aborting due to previous error\n+"}, {"sha": "6ffe78eab4108fb58ba1332b77eea55b1e4d1034", "filename": "src/tools/tidy/src/unstable_book.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -49,7 +49,7 @@ pub fn collect_unstable_feature_names(features: &Features) -> BTreeSet<String> {\n     features\n         .iter()\n         .filter(|&(_, ref f)| f.level == Status::Unstable)\n-        .map(|(name, _)| name.to_owned())\n+        .map(|(name, _)| name.replace('_', \"-\"))\n         .collect()\n }\n \n@@ -60,7 +60,7 @@ pub fn collect_unstable_book_section_file_names(dir: &path::Path) -> BTreeSet<St\n         .map(|entry| entry.expect(\"could not read directory entry\"))\n         .filter(dir_entry_is_file)\n         .map(|entry| entry.file_name().into_string().unwrap())\n-        .map(|n| n.trim_right_matches(\".md\").replace('-', \"_\"))\n+        .map(|n| n.trim_right_matches(\".md\").to_owned())\n         .collect()\n }\n "}, {"sha": "f66144fde0199072635a4a9c805439ac2725f335", "filename": "src/tools/unstable-book-gen/src/main.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57850e53602bfc1f66a12d20299c938925c1986a/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs?ref=57850e53602bfc1f66a12d20299c938925c1986a", "patch": "@@ -53,9 +53,9 @@ fn set_to_summary_str(set: &BTreeSet<String>, dir: &str\n     set\n         .iter()\n         .map(|ref n| format!(\"    - [{}]({}/{}.md)\",\n-                                      n,\n+                                      n.replace('-', \"_\"),\n                                       dir,\n-                                      n.replace('_', \"-\")))\n+                                      n))\n         .fold(\"\".to_owned(), |s, a| s + &a + \"\\n\")\n }\n \n@@ -96,14 +96,17 @@ fn generate_unstable_book_files(src :&Path, out: &Path, features :&Features) {\n     let unstable_section_file_names = collect_unstable_book_section_file_names(src);\n     t!(fs::create_dir_all(&out));\n     for feature_name in &unstable_features - &unstable_section_file_names {\n-        let file_name = format!(\"{}.md\", feature_name.replace('_', \"-\"));\n+        let feature_name_underscore = feature_name.replace('-', \"_\");\n+        let file_name = format!(\"{}.md\", feature_name);\n         let out_file_path = out.join(&file_name);\n-        let feature = &features[&feature_name];\n+        let feature = &features[&feature_name_underscore];\n \n         if has_valid_tracking_issue(&feature) {\n-            generate_stub_issue(&out_file_path, &feature_name, feature.tracking_issue.unwrap());\n+            generate_stub_issue(&out_file_path,\n+                                &feature_name_underscore,\n+                                feature.tracking_issue.unwrap());\n         } else {\n-            generate_stub_no_issue(&out_file_path, &feature_name);\n+            generate_stub_no_issue(&out_file_path, &feature_name_underscore);\n         }\n     }\n }"}]}