{"sha": "970b86b1bb61eeff8b32372e2a1d5486945f47d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MGI4NmIxYmI2MWVlZmY4YjMyMzcyZTJhMWQ1NDg2OTQ1ZjQ3ZDE=", "commit": {"author": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-18T14:12:58Z"}, "committer": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-20T10:24:47Z"}, "message": "doc: Fix broken links", "tree": {"sha": "b3898831b88cbbd5988e46010cc6cee9271c2c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3898831b88cbbd5988e46010cc6cee9271c2c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/970b86b1bb61eeff8b32372e2a1d5486945f47d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/970b86b1bb61eeff8b32372e2a1d5486945f47d1", "html_url": "https://github.com/rust-lang/rust/commit/970b86b1bb61eeff8b32372e2a1d5486945f47d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/970b86b1bb61eeff8b32372e2a1d5486945f47d1/comments", "author": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8cfa59be0a6b5200e525ff68390ede34698e909", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8cfa59be0a6b5200e525ff68390ede34698e909", "html_url": "https://github.com/rust-lang/rust/commit/b8cfa59be0a6b5200e525ff68390ede34698e909"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "a404d25bf370353cc5f07202ad531d653ce9b2c9", "filename": "src/doc/style/errors/ergonomics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md?ref=970b86b1bb61eeff8b32372e2a1d5486945f47d1", "patch": "@@ -57,7 +57,7 @@ fn write_info(info: &Info) -> Result<(), IoError> {\n ```\n \n See\n-[the `result` module documentation](https://doc.rust-lang.org/stable/std/result/index.html#the-try!-macro)\n+[the `result` module documentation](https://doc.rust-lang.org/stable/std/result/index.html#the-try-macro)\n for more details.\n \n ### The `Result`-`impl` pattern [FIXME]"}, {"sha": "26ffda50ac53dc1a06b30dae8e7b0fc4e2a82d52", "filename": "src/doc/style/features/traits/generics.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=970b86b1bb61eeff8b32372e2a1d5486945f47d1", "patch": "@@ -27,7 +27,7 @@ explicitly implement to be used by this generic function.\n * _Inference_. Since the type parameters to generic functions can usually be\n   inferred, generic functions can help cut down on verbosity in code where\n   explicit conversions or other method calls would usually be necessary. See the\n-  [overloading/implicits use case](#use-case:-limited-overloading-and/or-implicit-conversions)\n+  [overloading/implicits use case](#use-case-limited-overloading-andor-implicit-conversions)\n   below.\n * _Precise types_. Because generics give a _name_ to the specific type\n   implementing a trait, it is possible to be precise about places where that\n@@ -51,7 +51,7 @@ explicitly implement to be used by this generic function.\n   a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n   vector representation is specialized to lay these out in line). Sometimes\n   heterogeneous collections are useful; see\n-  [trait objects](#use-case:-trait-objects) below.\n+  [trait objects](#use-case-trait-objects) below.\n * _Signature verbosity_. Heavy use of generics can bloat function signatures.\n   **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n "}, {"sha": "47d41a155e4ca4183eb16231464e748754ceb376", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=970b86b1bb61eeff8b32372e2a1d5486945f47d1", "patch": "@@ -24,28 +24,28 @@ systems may want to jump around.\n * [The Basics](#the-basics)\n     * [Unwrapping explained](#unwrapping-explained)\n     * [The `Option` type](#the-option-type)\n-        * [Composing `Option<T>` values](#composing-option<t>-values)\n+        * [Composing `Option<T>` values](#composing-optiont-values)\n     * [The `Result` type](#the-result-type)\n         * [Parsing integers](#parsing-integers)\n         * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n-    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude:-unwrapping-isn't-evil)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isn't-evil)\n * [Working with multiple error types](#working-with-multiple-error-types)\n     * [Composing `Option` and `Result`](#composing-option-and-result)\n     * [The limits of combinators](#the-limits-of-combinators)\n     * [Early returns](#early-returns)\n-    * [The `try!` macro](#the-try!-macro)\n+    * [The `try!` macro](#the-try-macro)\n     * [Defining your own error type](#defining-your-own-error-type)\n * [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling)\n     * [The `Error` trait](#the-error-trait)\n     * [The `From` trait](#the-from-trait)\n-    * [The real `try!` macro](#the-real-try!-macro)\n+    * [The real `try!` macro](#the-real-try-macro)\n     * [Composing custom error types](#composing-custom-error-types)\n     * [Advice for library writers](#advice-for-library-writers)\n-* [Case study: A program to read population data](#case-study:-a-program-to-read-population-data)\n+* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n     * [Initial setup](#initial-setup)\n     * [Argument parsing](#argument-parsing)\n     * [Writing the logic](#writing-the-logic)\n-    * [Error handling with `Box<Error>`](#error-handling-with-box%3Cerror%3E)\n+    * [Error handling with `Box<Error>`](#error-handling-with-boxerror)\n     * [Reading from stdin](#reading-from-stdin)\n     * [Error handling with a custom type](#error-handling-with-a-custom-type)\n     * [Adding functionality](#adding-functionality)\n@@ -87,7 +87,7 @@ thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n Here's another example that is slightly less contrived. A program that accepts\n an integer as an argument, doubles it and prints it.\n \n-<a name=\"code-unwrap-double\"></a>\n+<span id=\"code-unwrap-double\"></span>\n \n ```rust,should_panic\n use std::env;\n@@ -139,7 +139,7 @@ system is an important concept because it will cause the compiler to force the\n programmer to handle that absence. Let's take a look at an example that tries\n to find a character in a string:\n \n-<a name=\"code-option-ex-string-find\"></a>\n+<span id=\"code-option-ex-string-find\"></span>\n \n ```rust\n // Searches `haystack` for the Unicode character `needle`. If one is found, the\n@@ -186,7 +186,7 @@ But wait, what about `unwrap` used in [`unwrap-double`](#code-unwrap-double)?\n There was no case analysis there! Instead, the case analysis was put inside the\n `unwrap` method for you. You could define it yourself if you want:\n \n-<a name=\"code-option-def-unwrap\"></a>\n+<span id=\"code-option-def-unwrap\"></span>\n \n ```rust\n enum Option<T> {\n@@ -253,7 +253,7 @@ option is `None`, in which case, just return `None`.\n Rust has parametric polymorphism, so it is very easy to define a combinator\n that abstracts this pattern:\n \n-<a name=\"code-option-map\"></a>\n+<span id=\"code-option-map\"></span>\n \n ```rust\n fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n@@ -394,7 +394,7 @@ remove choices because they will panic if `Option<T>` is `None`.\n The `Result` type is also\n [defined in the standard library][6]:\n \n-<a name=\"code-result-def-1\"></a>\n+<span id=\"code-result-def\"></span>\n \n ```rust\n enum Result<T, E> {\n@@ -562,7 +562,7 @@ combinators that affect only the error type, such as\n ### The `Result` type alias idiom\n \n In the standard library, you may frequently see types like\n-`Result<i32>`. But wait, [we defined `Result`](#code-result-def-1) to\n+`Result<i32>`. But wait, [we defined `Result`](#code-result-def) to\n have two type parameters. How can we get away with only specifying\n one? The key is to define a `Result` type alias that *fixes* one of\n the type parameters to a particular type. Usually the fixed type is\n@@ -672,7 +672,7 @@ with both an `Option` and a `Result`, the solution is *usually* to convert the\n (from `env::args()`) means the user didn't invoke the program correctly. We\n could just use a `String` to describe the error. Let's try:\n \n-<a name=\"code-error-double-string\"></a>\n+<span id=\"code-error-double-string\"></span>\n \n ```rust\n use std::env;\n@@ -906,7 +906,7 @@ seen above.\n \n Here is a simplified definition of a `try!` macro:\n \n-<a nama name=\"code-try-def-simple\"></a>\n+<span id=\"code-try-def-simple\"></span>\n \n ```rust\n macro_rules! try {\n@@ -1168,7 +1168,7 @@ The `std::convert::From` trait is\n [defined in the standard\n library](../std/convert/trait.From.html):\n \n-<a name=\"code-from-def\"></a>\n+<span id=\"code-from-def\"></span>\n \n ```rust\n trait From<T> {\n@@ -1250,7 +1250,7 @@ macro_rules! try {\n This is not its real definition. Its real definition is\n [in the standard library](../std/macro.try!.html):\n \n-<a name=\"code-try-def\"></a>\n+<span id=\"code-try-def\"></span>\n \n ```rust\n macro_rules! try {\n@@ -1515,7 +1515,7 @@ and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n-chapter](../book/hello-cargo) and [Cargo's documentation][14].\n+chapter](../book/hello-cargo.html) and [Cargo's documentation][14].\n \n To get started from scratch, run `cargo new --bin city-pop` and make sure your\n `Cargo.toml` looks something like this:\n@@ -1573,7 +1573,7 @@ fn main() {\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-    \n+\n     let matches = match opts.parse(&args[1..]) {\n         Ok(m)  => { m }\n \tErr(e) => { panic!(e.to_string()) }\n@@ -1584,7 +1584,7 @@ fn main() {\n     }\n     let data_path = args[1].clone();\n     let city = args[2].clone();\n-\t\n+\n \t// Do stuff with information\n }\n ```\n@@ -1647,27 +1647,27 @@ fn main() {\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-    \n+\n     let matches = match opts.parse(&args[1..]) {\n         Ok(m)  => { m }\n \t\tErr(e) => { panic!(e.to_string()) }\n     };\n-\t\n+\n     if matches.opt_present(\"h\") {\n         print_usage(&program, opts);\n \t\treturn;\n \t}\n-\t\t\n+\n \tlet data_file = args[1].clone();\n \tlet data_path = Path::new(&data_file);\n \tlet city = args[2].clone();\n-\t\n+\n \tlet file = fs::File::open(data_path).unwrap();\n \tlet mut rdr = csv::Reader::from_reader(file);\n-\t\n+\n \tfor row in rdr.decode::<Row>() {\n \t\tlet row = row.unwrap();\n-\t\n+\n \t\tif row.city == city {\n \t\t\tprintln!(\"{}, {}: {:?}\",\n \t\t\t\trow.city, row.country,\n@@ -1773,7 +1773,7 @@ fn main() {\n \t\tprint_usage(&program, opts);\n \t\treturn;\n \t}\n-\t\t\n+\n \tlet data_file = args[1].clone();\n \tlet data_path = Path::new(&data_file);\n \tlet city = args[2].clone();\n@@ -1882,7 +1882,7 @@ opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n ...\n let file = matches.opt_str(\"f\");\n let data_file = file.as_ref().map(Path::new);\n-\t\n+\n let city = if !matches.free.is_empty() {\n \tmatches.free[0].clone()\n } else {"}, {"sha": "c67a4182f54cbb32384b95c3c66b2b71affeb7ac", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970b86b1bb61eeff8b32372e2a1d5486945f47d1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=970b86b1bb61eeff8b32372e2a1d5486945f47d1", "patch": "@@ -18,7 +18,7 @@\n //! language primitives](#primitives), [standard macros](#macros),\n //! [I/O](io/index.html) and [multithreading](thread/index.html), among\n //! [many other\n-//! things](#what-is-in-the-standard-library-documentation?).\n+//! things](#what-is-in-the-standard-library-documentation).\n //!\n //! `std` is available to all Rust crates by default, just as if each\n //! one contained an `extern crate std` import at the [crate"}]}