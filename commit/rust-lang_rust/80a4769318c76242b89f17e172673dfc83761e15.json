{"sha": "80a4769318c76242b89f17e172673dfc83761e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTQ3NjkzMThjNzYyNDJiODlmMTdlMTcyNjczZGZjODM3NjFlMTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-19T00:27:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-19T00:28:40Z"}, "message": "Update tutorial on generics. #4217", "tree": {"sha": "15e43693f259edf2874521fa97411dc1598ccddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e43693f259edf2874521fa97411dc1598ccddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a4769318c76242b89f17e172673dfc83761e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a4769318c76242b89f17e172673dfc83761e15", "html_url": "https://github.com/rust-lang/rust/commit/80a4769318c76242b89f17e172673dfc83761e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a4769318c76242b89f17e172673dfc83761e15/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a59747cd7f49a0fdad742a2ef1219e868fb0f637", "url": "https://api.github.com/repos/rust-lang/rust/commits/a59747cd7f49a0fdad742a2ef1219e868fb0f637", "html_url": "https://github.com/rust-lang/rust/commit/a59747cd7f49a0fdad742a2ef1219e868fb0f637"}], "stats": {"total": 40, "additions": 19, "deletions": 21}, "files": [{"sha": "48d05165597706eeb41bc059b288c62bb9428db2", "filename": "doc/tutorial.md", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80a4769318c76242b89f17e172673dfc83761e15/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/80a4769318c76242b89f17e172673dfc83761e15/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=80a4769318c76242b89f17e172673dfc83761e15", "patch": "@@ -1873,9 +1873,7 @@ is not defined for all Rust types. One reason is user-defined\n destructors: copying a type that has a destructor could result in the\n destructor running multiple times. Therefore, types with user-defined\n destructors cannot be copied, either implicitly or explicitly, and\n-neither can types that own other types containing destructors (see the\n-section on [structs](#structs) for the actual mechanism for defining\n-destructors).\n+neither can types that own other types containing destructors.\n \n This complicates handling of generic functions. If you have a type\n parameter `T`, can you copy values of that type? In Rust, you can't,\n@@ -1924,10 +1922,11 @@ types by the compiler, and may not be overridden:\n > ***Note:*** These three traits were referred to as 'kinds' in earlier\n > iterations of the language, and often still are.\n \n-There is also a special trait known as `Drop`. This trait defines one method\n-called `finalize`, which is automatically called when value of the a type that\n-implements this trait is destroyed, either because the value went out of scope\n-or because the garbage collector reclaimed it.\n+Additionally, the `Drop` trait is used to define destructors. This\n+trait defines one method called `finalize`, which is automatically\n+called when value of the a type that implements this trait is\n+destroyed, either because the value went out of scope or because the\n+garbage collector reclaimed it.\n \n ~~~\n struct TimeBomb {\n@@ -2023,7 +2022,7 @@ trait Eq {\n   fn equals(other: &self) -> bool;\n }\n \n-// In an impl, self refers to the value of the receiver\n+// In an impl, `self` refers to the value of the receiver\n impl int: Eq {\n   fn equals(other: &int) -> bool { *other == self }\n }\n@@ -2077,7 +2076,7 @@ the preferred way to use traits polymorphically.\n \n This usage of traits is similar to Haskell type classes.\n \n-## Casting to a trait type and dynamic method dispatch\n+## Trait objects and dynamic method dispatch\n \n The above allows us to define functions that polymorphically act on\n values of a single unknown type that conforms to a given trait.\n@@ -2099,7 +2098,8 @@ fn draw_all<T: Drawable>(shapes: ~[T]) {\n You can call that on an array of circles, or an array of squares\n (assuming those have suitable `Drawable` traits defined), but not on\n an array containing both circles and squares. When such behavior is\n-needed, a trait name can alternately be used as a type.\n+needed, a trait name can alternately be used as a type, called\n+an _object_.\n \n ~~~~\n # trait Drawable { fn draw(); }\n@@ -2111,7 +2111,7 @@ fn draw_all(shapes: &[@Drawable]) {\n In this example, there is no type parameter. Instead, the `@Drawable`\n type denotes any managed box value that implements the `Drawable`\n trait. To construct such a value, you use the `as` operator to cast a\n-value to a trait type:\n+value to an object:\n \n ~~~~\n # type Circle = int; type Rectangle = bool;\n@@ -2120,9 +2120,9 @@ value to a trait type:\n # fn new_rectangle() -> Rectangle { true }\n # fn draw_all(shapes: &[@Drawable]) {}\n \n-impl @Circle: Drawable { fn draw() { ... } }\n+impl Circle: Drawable { fn draw() { ... } }\n \n-impl @Rectangle: Drawable { fn draw() { ... } }\n+impl Rectangle: Drawable { fn draw() { ... } }\n \n let c: @Circle = @new_circle();\n let r: @Rectangle = @new_rectangle();\n@@ -2131,12 +2131,13 @@ draw_all([c as @Drawable, r as @Drawable]);\n \n We omit the code for `new_circle` and `new_rectangle`; imagine that\n these just return `Circle`s and `Rectangle`s with a default size. Note\n-that, like strings and vectors, trait types have dynamic size and may\n-only be referred to via one of the pointer types. That's why the `impl` is\n-defined for `@Circle` and `@Rectangle` instead of for just `Circle`\n-and `Rectangle`. Other pointer types work as well.\n+that, like strings and vectors, objects have dynamic size and may\n+only be referred to via one of the pointer types.\n+Other pointer types work as well.\n+Casts to traits may only be done with compatible pointers so,\n+for example, an `@Circle` may not be cast to an `~Drawable`.\n \n-~~~{.xfail-test}\n+~~~\n # type Circle = int; type Rectangle = int;\n # trait Drawable { fn draw(); }\n # impl int: Drawable { fn draw() {} }\n@@ -2150,9 +2151,6 @@ let owny: ~Drawable = ~new_circle() as ~Drawable;\n let stacky: &Drawable = &new_circle() as &Drawable;\n ~~~\n \n-> ***Note:*** Other pointer types actually _do not_ work here yet. This is\n-> an evolving corner of the language.\n-\n Method calls to trait types are _dynamically dispatched_. Since the\n compiler doesn't know specifically which functions to call at compile\n time, it uses a lookup table (also known as a vtable or dictionary) to"}]}