{"sha": "b087a991fca51c365ce46ad470d85b99f7c9005a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODdhOTkxZmNhNTFjMzY1Y2U0NmFkNDcwZDg1Yjk5ZjdjOTAwNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-27T23:40:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-27T23:40:16Z"}, "message": "Auto merge of #46312 - kennytm:rollup, r=kennytm\n\nRollup of 10 pull requests\n\n- Successful merges: #45506, #46174, #46231, #46240, #46249, #46258, #46262, #46275, #46282, #46285\n- Failed merges:", "tree": {"sha": "3dd672c525796a0b5b9e2db3c2bc06462056abee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dd672c525796a0b5b9e2db3c2bc06462056abee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b087a991fca51c365ce46ad470d85b99f7c9005a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b087a991fca51c365ce46ad470d85b99f7c9005a", "html_url": "https://github.com/rust-lang/rust/commit/b087a991fca51c365ce46ad470d85b99f7c9005a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b087a991fca51c365ce46ad470d85b99f7c9005a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "560a5da9f1cc7f67d2fc372925aef18c96c82629", "url": "https://api.github.com/repos/rust-lang/rust/commits/560a5da9f1cc7f67d2fc372925aef18c96c82629", "html_url": "https://github.com/rust-lang/rust/commit/560a5da9f1cc7f67d2fc372925aef18c96c82629"}, {"sha": "83a6f38556143f790372a666feed50ce3e72957d", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a6f38556143f790372a666feed50ce3e72957d", "html_url": "https://github.com/rust-lang/rust/commit/83a6f38556143f790372a666feed50ce3e72957d"}], "stats": {"total": 689, "additions": 628, "deletions": 61}, "files": [{"sha": "05e057be4932df41e80dfb9c52a3538e3ba1d8c5", "filename": "src/doc/unstable-book/src/library-features/hint-core-should-pause.md", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/560a5da9f1cc7f67d2fc372925aef18c96c82629/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md", "raw_url": "https://github.com/rust-lang/rust/raw/560a5da9f1cc7f67d2fc372925aef18c96c82629/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fhint-core-should-pause.md?ref=560a5da9f1cc7f67d2fc372925aef18c96c82629", "patch": "@@ -1,41 +0,0 @@\n-# `hint_core_should_pause`\n-\n-The tracking issue for this feature is: [#41196]\n-\n-[#41196]: https://github.com/rust-lang/rust/issues/41196\n-\n-------------------------\n-\n-Many programs have spin loops like the following:\n-\n-```rust,no_run\n-use std::sync::atomic::{AtomicBool,Ordering};\n-\n-fn spin_loop(value: &AtomicBool) {\n-    loop {\n-        if value.load(Ordering::Acquire) {\n-             break;\n-        }\n-    }\n-}\n-```\n-\n-These programs can be improved in performance like so:\n-\n-```rust,no_run\n-#![feature(hint_core_should_pause)]\n-use std::sync::atomic;\n-use std::sync::atomic::{AtomicBool,Ordering};\n-\n-fn spin_loop(value: &AtomicBool) {\n-    loop {\n-        if value.load(Ordering::Acquire) {\n-             break;\n-        }\n-        atomic::hint_core_should_pause();\n-    }\n-}\n-```\n-\n-Further improvements could combine `hint_core_should_pause` with\n-exponential backoff or `std::thread::yield_now`."}, {"sha": "0fe3c9724224d5b8df520e47895b677e050a90e3", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -220,6 +220,28 @@ impl<T> LinkedList<T> {\n             node\n         })\n     }\n+\n+    /// Unlinks the specified node from the current list.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the current list.\n+    #[inline]\n+    unsafe fn unlink_node(&mut self, mut node: Shared<Node<T>>) {\n+        let node = node.as_mut();\n+\n+        match node.prev {\n+            Some(mut prev) => prev.as_mut().next = node.next.clone(),\n+            // this node is the head node\n+            None => self.head = node.next.clone(),\n+        };\n+\n+        match node.next {\n+            Some(mut next) => next.as_mut().prev = node.prev.clone(),\n+            // this node is the tail node\n+            None => self.tail = node.prev.clone(),\n+        };\n+\n+        self.len -= 1;\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -722,6 +744,49 @@ impl<T> LinkedList<T> {\n         second_part\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a list into evens and odds, reusing the original list:\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut numbers: LinkedList<u32> = LinkedList::new();\n+    /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n+    /// ```\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool\n+    {\n+        // avoid borrow issues.\n+        let it = self.head;\n+        let old_len = self.len;\n+\n+        DrainFilter {\n+            list: self,\n+            it: it,\n+            pred: filter,\n+            idx: 0,\n+            old_len: old_len,\n+        }\n+    }\n+\n     /// Returns a place for insertion at the front of the list.\n     ///\n     /// Using this method with placement syntax is equivalent to\n@@ -967,6 +1032,56 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on LinkedList.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub struct DrainFilter<'a, T: 'a, F: 'a>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    list: &'a mut LinkedList<T>,\n+    it: Option<Shared<Node<T>>>,\n+    pred: F,\n+    idx: usize,\n+    old_len: usize,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        while let Some(mut node) = self.it {\n+            unsafe {\n+                self.it = node.as_ref().next;\n+                self.idx += 1;\n+\n+                if (self.pred)(&mut node.as_mut().element) {\n+                    self.list.unlink_node(node);\n+                    return Some(Box::from_raw(node.as_ptr()).element);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\")\n+         .field(&self.list)\n+         .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n@@ -1509,4 +1624,28 @@ mod tests {\n         }\n         assert_eq!(i, v.len());\n     }\n+\n+    #[test]\n+    fn drain_filter_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+    }\n+\n+    #[test]\n+    fn drain_to_empty_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    }\n }"}, {"sha": "4e3e855105eb8523f970e3019c508a0e4fdf8c22", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -366,3 +366,191 @@ fn test_contains() {\n \n     assert!(!l.contains(&3));\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = vec![(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            1,\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {   // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}"}, {"sha": "551aa929ce457d44f195e8215da80820a6dddbdd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -624,6 +624,9 @@ pub trait Display {\n ///\n /// The `Octal` trait should format its output as a number in base-8.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0o` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -639,6 +642,8 @@ pub trait Display {\n ///\n /// assert_eq!(format!(\"{:o}\", x), \"52\");\n /// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n+///\n+/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n /// ```\n ///\n /// Implementing `Octal` on a type:\n@@ -671,6 +676,9 @@ pub trait Octal {\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0b` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -686,6 +694,8 @@ pub trait Octal {\n ///\n /// assert_eq!(format!(\"{:b}\", x), \"101010\");\n /// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n+///\n+/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n /// ```\n ///\n /// Implementing `Binary` on a type:\n@@ -719,6 +729,9 @@ pub trait Binary {\n /// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n /// in lower case.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -734,6 +747,8 @@ pub trait Binary {\n ///\n /// assert_eq!(format!(\"{:x}\", x), \"2a\");\n /// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n+///\n+/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n /// ```\n ///\n /// Implementing `LowerHex` on a type:\n@@ -767,6 +782,9 @@ pub trait LowerHex {\n /// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n /// in upper case.\n ///\n+/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// negative values are formatted as the two\u2019s complement representation.\n+///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n@@ -782,6 +800,8 @@ pub trait LowerHex {\n ///\n /// assert_eq!(format!(\"{:X}\", x), \"2A\");\n /// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n+///\n+/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n /// ```\n ///\n /// Implementing `UpperHex` on a type:"}, {"sha": "19e91a65964aeeab208fa9f3fb6c64f516da024b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -132,7 +132,14 @@ macro_rules! int_impl {\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n+        /// The string is expected to be an optional `+` or `-` sign\n+        /// followed by digits.\n         /// Leading and trailing whitespace represent an error.\n+        /// Digits are a subset of these characters, depending on `radix`:\n+        ///\n+        /// * `0-9`\n+        /// * `a-z`\n+        /// * `A-Z`\n         ///\n         /// # Panics\n         ///\n@@ -1301,7 +1308,18 @@ macro_rules! uint_impl {\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n+        /// The string is expected to be an optional `+` sign\n+        /// followed by digits.\n         /// Leading and trailing whitespace represent an error.\n+        /// Digits are a subset of these characters, depending on `radix`:\n+        ///\n+        /// * `0-9`\n+        /// * `a-z`\n+        /// * `A-Z`\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function panics if `radix` is not in the range from 2 to 36.\n         ///\n         /// # Examples\n         ///"}, {"sha": "8a261b8f07737840dcb3eb7961dd868359dddf34", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -103,9 +103,8 @@ use fmt;\n ///\n /// On some platforms this function may not do anything at all.\n #[inline]\n-#[unstable(feature = \"hint_core_should_pause\", issue = \"41196\")]\n-pub fn hint_core_should_pause()\n-{\n+#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n+pub fn spin_loop_hint() {\n     #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n     unsafe {\n         asm!(\"pause\" ::: \"memory\" : \"volatile\");"}, {"sha": "5703c5c870e88efd5813a0072f4c1754533086ac", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -581,6 +581,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                      trait_ref.self_ty()));\n                         }\n \n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+\n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n                             self.predicate_can_apply(obligation.param_env, trait_ref) {\n@@ -821,6 +823,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n+    /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n+    /// suggestion to borrow the initializer in order to use have a slice instead.\n+    fn suggest_borrow_on_unsized_slice(&self,\n+                                       code: &ObligationCauseCode<'tcx>,\n+                                       err: &mut DiagnosticBuilder<'tcx>) {\n+        if let &ObligationCauseCode::VariableType(node_id) = code {\n+            let parent_node = self.tcx.hir.get_parent_node(node_id);\n+            if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n+                if let Some(ref expr) = local.init {\n+                    if let hir::ExprIndex(_, _) = expr.node {\n+                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                            err.span_suggestion(expr.span,\n+                                                \"consider borrowing here\",\n+                                                format!(\"&{}\", snippet));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,"}, {"sha": "75df4dc524afa73416cad70b669bf67eb1911b40", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -81,17 +81,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // (And cycle errors around impls tend to occur during the\n         // collect/coherence phases anyhow.)\n         item_path::with_forced_impl_filename_line(|| {\n+            let span = self.sess.codemap().def_span(span);\n             let mut err =\n                 struct_span_err!(self.sess, span, E0391,\n                                  \"unsupported cyclic reference between types/traits detected\");\n             err.span_label(span, \"cyclic reference\");\n \n-            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n-                                               stack[0].1.describe(self)));\n+            err.span_note(self.sess.codemap().def_span(stack[0].0),\n+                          &format!(\"the cycle begins when {}...\", stack[0].1.describe(self)));\n \n             for &(span, ref query) in &stack[1..] {\n-                err.span_note(span, &format!(\"...which then requires {}...\",\n-                                             query.describe(self)));\n+                err.span_note(self.sess.codemap().def_span(span),\n+                              &format!(\"...which then requires {}...\", query.describe(self)));\n             }\n \n             err.note(&format!(\"...which then again requires {}, completing the cycle.\","}, {"sha": "9a05bbea48704fe0d9063358e1191cdbedd9242b", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -484,6 +484,34 @@ enum WriteKind {\n     Move,\n }\n \n+#[derive(Copy, Clone)]\n+enum InitializationRequiringAction {\n+    Update,\n+    Borrow,\n+    Use,\n+    Assignment,\n+}\n+\n+impl InitializationRequiringAction {\n+    fn as_noun(self) -> &'static str {\n+        match self {\n+            InitializationRequiringAction::Update     => \"update\",\n+            InitializationRequiringAction::Borrow     => \"borrow\",\n+            InitializationRequiringAction::Use        => \"use\",\n+            InitializationRequiringAction::Assignment => \"assign\"\n+        }\n+    }\n+\n+    fn as_verb_in_past_tense(self) -> &'static str {\n+        match self {\n+            InitializationRequiringAction::Update     => \"updated\",\n+            InitializationRequiringAction::Borrow     => \"borrowed\",\n+            InitializationRequiringAction::Use        => \"used\",\n+            InitializationRequiringAction::Assignment => \"assigned\"\n+        }\n+    }\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Checks an access to the given lvalue to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n@@ -574,7 +602,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, \"update\", lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Update,\n+                                            lvalue_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n                 self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n@@ -600,7 +629,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n                 };\n                 self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n-                self.check_if_path_is_moved(context, \"borrow\", (lvalue, span), flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Borrow,\n+                                            (lvalue, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -619,7 +649,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n                 self.access_lvalue(\n                     context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n-                self.check_if_path_is_moved(context, \"use\", (lvalue, span), flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                            (lvalue, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -720,7 +751,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // skip this check in that case).\n             }\n             ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, \"use\", lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                            lvalue_span, flow_state);\n             }\n         }\n     }\n@@ -772,7 +804,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n-                              desired_action: &str,\n+                              desired_action: InitializationRequiringAction,\n                               lvalue_span: (&Lvalue<'tcx>, Span),\n                               flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n@@ -943,7 +975,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // `base` to its base_path.\n \n                                     self.check_if_path_is_moved(\n-                                        context, \"assignment\", (base, span), flow_state);\n+                                        context, InitializationRequiringAction::Assignment,\n+                                        (base, span), flow_state);\n \n                                     // (base initialized; no need to\n                                     // recur further)\n@@ -1347,7 +1380,7 @@ mod prefixes {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n-                           desired_action: &str,\n+                           desired_action: InitializationRequiringAction,\n                            (lvalue, span): (&Lvalue<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n@@ -1357,7 +1390,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if mois.is_empty() {\n             self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                          desired_action,\n+                                                          desired_action.as_noun(),\n                                                           &self.describe_lvalue(lvalue),\n                                                           Origin::Mir)\n                     .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n@@ -1367,11 +1400,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n             let mut err = self.tcx.cannot_act_on_moved_value(span,\n-                                                             desired_action,\n+                                                             desired_action.as_noun(),\n                                                              msg,\n                                                              &self.describe_lvalue(lvalue),\n                                                              Origin::Mir);\n-            err.span_label(span, format!(\"value {} here after move\", desired_action));\n+\n+            err.span_label(span, format!(\"value {} here after move\",\n+                                         desired_action.as_verb_in_past_tense()));\n             for moi in mois {\n                 let move_msg = \"\"; //FIXME: add \" (into closure)\"\n                 let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;"}, {"sha": "8d7f60f9d2c03e5c78c0229505817f41f17880cc", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -1625,6 +1625,15 @@ impl<T: Send> error::Error for TrySendError<T> {\n     }\n }\n \n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+impl<T> From<SendError<T>> for TrySendError<T> {\n+    fn from(err: SendError<T>) -> TrySendError<T> {\n+        match err {\n+            SendError(t) => TrySendError::Disconnected(t),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for RecvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1677,6 +1686,15 @@ impl error::Error for TryRecvError {\n     }\n }\n \n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+impl From<RecvError> for TryRecvError {\n+    fn from(err: RecvError) -> TryRecvError {\n+        match err {\n+            RecvError => TryRecvError::Disconnected,\n+        }\n+    }\n+}\n+\n #[stable(feature = \"mpsc_recv_timeout_error\", since = \"1.15.0\")]\n impl fmt::Display for RecvTimeoutError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1709,6 +1727,15 @@ impl error::Error for RecvTimeoutError {\n     }\n }\n \n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+impl From<RecvError> for RecvTimeoutError {\n+    fn from(err: RecvError) -> RecvTimeoutError {\n+        match err {\n+            RecvError => RecvTimeoutError::Disconnected,\n+        }\n+    }\n+}\n+\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use env;"}, {"sha": "0f32d588b372fd835c17c724c7facacfc5a61d0a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -5486,7 +5486,12 @@ impl<'a> Parser<'a> {\n \n         if !self.eat(term) {\n             let token_str = self.this_token_to_string();\n-            return Err(self.fatal(&format!(\"expected item, found `{}`\", token_str)));\n+            let mut err = self.fatal(&format!(\"expected item, found `{}`\", token_str));\n+            let msg = \"consider removing this semicolon\";\n+            if token_str == \";\" {\n+                err.span_suggestion_short(self.span, msg, \"\".to_string());\n+            }\n+            return Err(err);\n         }\n \n         let hi = if self.span == syntax_pos::DUMMY_SP {"}, {"sha": "9f08bd198223e248d4364c3a74088e20312ade95", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -14,7 +14,7 @@ error[E0382]: use of moved value: `x` (Mir)\n 17 |     drop(x);\n    |          - value moved here\n 18 |     let _ = (1,x); //~ ERROR use of moved value: `x` (Ast)\n-   |                ^ value use here after move\n+   |                ^ value used here after move\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8a5033e76478ba90e0347ff01578f9d25889a381", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "previous_filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs"}, {"sha": "1c03e9d8526450e46a79d94816a8fd1b0a2a5d28", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -0,0 +1,52 @@\n+error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n+  --> $DIR/auto-trait-leak.rs:27:5\n+   |\n+27 |     send(before());\n+   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n+   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak.rs:21:5: 21:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n+   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+   = note: required by `send`\n+\n+error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n+  --> $DIR/auto-trait-leak.rs:34:5\n+   |\n+34 |     send(after());\n+   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n+   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak.rs:46:5: 46:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n+   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+   = note: required by `send`\n+\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  --> $DIR/auto-trait-leak.rs:52:1\n+   |\n+52 | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic reference\n+   |\n+note: the cycle begins when processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:52:1\n+   |\n+52 | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which then requires processing `cycle2::{{impl-Trait}}`...\n+  --> $DIR/auto-trait-leak.rs:63:16\n+   |\n+63 | fn cycle2() -> impl Clone {\n+   |                ^^^^^^^^^^\n+note: ...which then requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:63:1\n+   |\n+63 | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which then requires processing `cycle1::{{impl-Trait}}`...\n+  --> $DIR/auto-trait-leak.rs:52:16\n+   |\n+52 | fn cycle1() -> impl Clone {\n+   |                ^^^^^^^^^^\n+   = note: ...which then again requires processing `cycle1`, completing the cycle.\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "1440b9e8cdc5f68f5128ab931f9157c3f23a650b", "filename": "src/test/ui/issue-46186.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fissue-46186.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fissue-46186.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46186.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Struct {\n+    a: usize,\n+}; //~ ERROR expected item, found `;`\n+\n+fn main() {}"}, {"sha": "3cc9531bb5b86a0ef2817d692ee8f5c64dc577b4", "filename": "src/test/ui/issue-46186.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fissue-46186.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fissue-46186.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46186.stderr?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -0,0 +1,8 @@\n+error: expected item, found `;`\n+  --> $DIR/issue-46186.rs:13:2\n+   |\n+13 | }; //~ ERROR expected item, found `;`\n+   |  ^ help: consider removing this semicolon\n+\n+error: aborting due to previous error\n+"}, {"sha": "5bba9fc41e276f359a9ba2e7316c85739d10c1ce", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -8,7 +8,7 @@ note: the cycle begins when processing `<impl at $DIR/issue-23305.rs:15:1: 15:20\n   --> $DIR/issue-23305.rs:15:1\n    |\n 15 | impl ToNbt<Self> {}\n-   | ^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^\n    = note: ...which then again requires processing `<impl at $DIR/issue-23305.rs:15:1: 15:20>`, completing the cycle.\n \n error: aborting due to previous error"}, {"sha": "6c7f4852a4ae53be89734cf1668c0b728334f9b8", "filename": "src/test/ui/suggestions/str-array-assignment.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.rs?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { //~ NOTE expected `()` because of default return type\n+  let s = \"abc\";\n+  let t = if true { s[..2] } else { s };\n+  //~^ ERROR if and else have incompatible types\n+  //~| NOTE expected str, found &str\n+  //~| NOTE expected type\n+  let u: &str = if true { s[..2] } else { s };\n+  //~^ ERROR mismatched types\n+  //~| NOTE expected &str, found str\n+  //~| NOTE expected type\n+  let v = s[..2];\n+  //~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n+  //~| HELP consider borrowing here\n+  //~| NOTE `str` does not have a constant size known at compile-time\n+  //~| HELP the trait `std::marker::Sized` is not implemented for `str`\n+  //~| NOTE all local variables must have a statically known size\n+  let w: &str = s[..2];\n+  //~^ ERROR mismatched types\n+  //~| NOTE expected &str, found str\n+  //~| NOTE expected type\n+  //~| HELP try with `&s[..2]`\n+}"}, {"sha": "14b744c2e469c3e8d67d714e48d5e6e002436401", "filename": "src/test/ui/suggestions/str-array-assignment.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -0,0 +1,44 @@\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/str-array-assignment.rs:13:11\n+   |\n+13 |   let t = if true { s[..2] } else { s };\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected str, found &str\n+   |\n+   = note: expected type `str`\n+              found type `&str`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/str-array-assignment.rs:17:27\n+   |\n+11 | fn main() { //~ NOTE expected `()` because of default return type\n+   |           - expected `()` because of default return type\n+...\n+17 |   let u: &str = if true { s[..2] } else { s };\n+   |                           ^^^^^^ expected &str, found str\n+   |\n+   = note: expected type `&str`\n+              found type `str`\n+\n+error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n+  --> $DIR/str-array-assignment.rs:21:7\n+   |\n+21 |   let v = s[..2];\n+   |       ^   ------ help: consider borrowing here: `&s[..2]`\n+   |       |\n+   |       `str` does not have a constant size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: all local variables must have a statically known size\n+\n+error[E0308]: mismatched types\n+  --> $DIR/str-array-assignment.rs:27:17\n+   |\n+27 |   let w: &str = s[..2];\n+   |                 ^^^^^^ expected &str, found str\n+   |\n+   = note: expected type `&str`\n+              found type `str`\n+   = help: try with `&s[..2]`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6fc9423a4139a47ab6a54ae7cc51ab25d333a3e7", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b087a991fca51c365ce46ad470d85b99f7c9005a/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=b087a991fca51c365ce46ad470d85b99f7c9005a", "patch": "@@ -10,6 +10,8 @@ filetime = \"0.1\"\n getopts = \"0.2\"\n log = \"0.3\"\n rustc-serialize = \"0.3\"\n+\n+[target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n \n [target.'cfg(windows)'.dependencies]"}]}