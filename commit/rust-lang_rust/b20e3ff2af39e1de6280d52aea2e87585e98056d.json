{"sha": "b20e3ff2af39e1de6280d52aea2e87585e98056d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMGUzZmYyYWYzOWUxZGU2MjgwZDUyYWVhMmU4NzU4NWU5ODA1NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-06T22:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-06T22:20:43Z"}, "message": "Auto merge of #86911 - bjorn3:crate_info_refactor, r=petrochenkov\n\nRefactor linker code\n\nThis merges `LinkerInfo` into `CrateInfo` as there is no reason to keep them separate. `LinkerInfo::to_linker` is merged into `get_linker` as both have different logic for each linker type and `to_linker` is directly called after `get_linker`. Also contains a couple of small cleanups.\n\nSee the individual commits for all changes.", "tree": {"sha": "475f9dc55c47e934a81eb86820a7f63483faf197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/475f9dc55c47e934a81eb86820a7f63483faf197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20e3ff2af39e1de6280d52aea2e87585e98056d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20e3ff2af39e1de6280d52aea2e87585e98056d", "html_url": "https://github.com/rust-lang/rust/commit/b20e3ff2af39e1de6280d52aea2e87585e98056d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20e3ff2af39e1de6280d52aea2e87585e98056d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "885399992c4c1dde37b506b8507a7d69415646b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/885399992c4c1dde37b506b8507a7d69415646b9", "html_url": "https://github.com/rust-lang/rust/commit/885399992c4c1dde37b506b8507a7d69415646b9"}, {"sha": "25e45baf55280eb310cfb182024194c69347c890", "url": "https://api.github.com/repos/rust-lang/rust/commits/25e45baf55280eb310cfb182024194c69347c890", "html_url": "https://github.com/rust-lang/rust/commit/25e45baf55280eb310cfb182024194c69347c890"}], "stats": {"total": 367, "additions": 166, "deletions": 201}, "files": [{"sha": "50fd53481f74580c59afbd09346dd1b5b48dfe59", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -4,7 +4,6 @@\n use std::path::PathBuf;\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n-use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n@@ -296,8 +295,7 @@ pub(crate) fn run_aot(\n             allocator_module,\n             metadata_module,\n             metadata,\n-            linker_info: LinkerInfo::new(tcx, crate::target_triple(tcx.sess).to_string()),\n-            crate_info: CrateInfo::new(tcx),\n+            crate_info: CrateInfo::new(tcx, crate::target_triple(tcx.sess).to_string()),\n         },\n         work_products,\n     ))"}, {"sha": "04ec01ad28148483519cefcf65e9615e2203d2d2", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -178,7 +178,7 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n \n     let mut dylib_paths = Vec::new();\n \n-    let crate_info = CrateInfo::new(tcx);\n+    let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n     let formats = tcx.dependency_formats(());\n     let data = &formats\n         .iter()"}, {"sha": "ebf98e8694b78f96f0e8dee0d25324256d7fcac7", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -219,7 +219,6 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             sess,\n             &codegen_results,\n             outputs,\n-            &codegen_results.crate_info.local_crate_name.as_str(),\n         );\n \n         Ok(())"}, {"sha": "26fd1cfbcd08e7dad15a1281f814106b86e50c9d", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -292,12 +292,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        link_binary::<LlvmArchiveBuilder<'_>>(\n-            sess,\n-            &codegen_results,\n-            outputs,\n-            &codegen_results.crate_info.local_crate_name.as_str(),\n-        );\n+        link_binary::<LlvmArchiveBuilder<'_>>(sess, &codegen_results, outputs);\n \n         Ok(())\n     }"}, {"sha": "59447e9de13507cf1a8ec5c0b2c3f103960b84e7", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 20, "deletions": 101, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -54,7 +54,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n-    crate_name: &str,\n ) {\n     let _timer = sess.timer(\"link_binary\");\n     let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n@@ -87,7 +86,12 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                 .tempdir()\n                 .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n             let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n-            let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+            let out_filename = out_filename(\n+                sess,\n+                crate_type,\n+                outputs,\n+                &codegen_results.crate_info.local_crate_name.as_str(),\n+            );\n             match crate_type {\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n@@ -143,97 +147,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     });\n }\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n-fn get_linker(\n-    sess: &Session,\n-    linker: &Path,\n-    flavor: LinkerFlavor,\n-    self_contained: bool,\n-) -> Command {\n-    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n-\n-    // If our linker looks like a batch script on Windows then to execute this\n-    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n-    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n-    // `cmd /c emcc.bat ...`.\n-    //\n-    // This worked historically but is needed manually since #42436 (regression\n-    // was tagged as #42791) and some more info can be found on #44443 for\n-    // emscripten itself.\n-    let mut cmd = match linker.to_str() {\n-        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n-        _ => match flavor {\n-            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n-            LinkerFlavor::Msvc if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() => {\n-                Command::new(msvc_tool.as_ref().map_or(linker, |t| t.path()))\n-            }\n-            _ => Command::new(linker),\n-        },\n-    };\n-\n-    // UWP apps have API restrictions enforced during Store submissions.\n-    // To comply with the Windows App Certification Kit,\n-    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n-    let t = &sess.target;\n-    if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n-        && t.vendor == \"uwp\"\n-    {\n-        if let Some(ref tool) = msvc_tool {\n-            let original_path = tool.path();\n-            if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n-                let arch = match t.arch.as_str() {\n-                    \"x86_64\" => Some(\"x64\"),\n-                    \"x86\" => Some(\"x86\"),\n-                    \"aarch64\" => Some(\"arm64\"),\n-                    \"arm\" => Some(\"arm\"),\n-                    _ => None,\n-                };\n-                if let Some(ref a) = arch {\n-                    // FIXME: Move this to `fn linker_with_args`.\n-                    let mut arg = OsString::from(\"/LIBPATH:\");\n-                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a));\n-                    cmd.arg(&arg);\n-                } else {\n-                    warn!(\"arch is not supported\");\n-                }\n-            } else {\n-                warn!(\"MSVC root path lib location not found\");\n-            }\n-        } else {\n-            warn!(\"link.exe not found\");\n-        }\n-    }\n-\n-    // The compiler's sysroot often has some bundled tools, so add it to the\n-    // PATH for the child.\n-    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n-    let mut msvc_changed_path = false;\n-    if sess.target.is_like_msvc {\n-        if let Some(ref tool) = msvc_tool {\n-            cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n-                if k == \"PATH\" {\n-                    new_path.extend(env::split_paths(v));\n-                    msvc_changed_path = true;\n-                } else {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-    }\n-\n-    if !msvc_changed_path {\n-        if let Some(path) = env::var_os(\"PATH\") {\n-            new_path.extend(env::split_paths(&path));\n-        }\n-    }\n-    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n-\n-    cmd\n-}\n-\n pub fn each_linked_rlib(\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n@@ -1800,11 +1713,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n ) -> Command {\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n-    let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n-    // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n-    // to the linker args construction.\n-    assert!(base_cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n-    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor);\n+    let cmd = &mut *super::linker::get_linker(\n+        sess,\n+        path,\n+        flavor,\n+        crt_objects_fallback,\n+        &codegen_results.crate_info.target_cpu,\n+    );\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n     // ------------ Early order-dependent options ------------\n@@ -1814,7 +1729,11 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // dynamic library.\n     // Must be passed before any libraries to prevent the symbols to export from being thrown away,\n     // at least on some platforms (e.g. windows-gnu).\n-    cmd.export_symbols(tmpdir, crate_type);\n+    cmd.export_symbols(\n+        tmpdir,\n+        crate_type,\n+        &codegen_results.crate_info.exported_symbols[&crate_type],\n+    );\n \n     // Can be used for adding custom CRT objects or overriding order-dependent options above.\n     // FIXME: In practice built-in target specs use this for arbitrary order-independent options,\n@@ -1986,10 +1905,10 @@ fn add_order_independent_options(\n     if flavor == LinkerFlavor::PtxLinker {\n         // Provide the linker with fallback to internal `target-cpu`.\n         cmd.arg(\"--fallback-arch\");\n-        cmd.arg(&codegen_results.linker_info.target_cpu);\n+        cmd.arg(&codegen_results.crate_info.target_cpu);\n     } else if flavor == LinkerFlavor::BpfLinker {\n         cmd.arg(\"--cpu\");\n-        cmd.arg(&codegen_results.linker_info.target_cpu);\n+        cmd.arg(&codegen_results.crate_info.target_cpu);\n         cmd.arg(\"--cpu-features\");\n         cmd.arg(match &sess.opts.cg.target_feature {\n             feat if !feat.is_empty() => feat,"}, {"sha": "9e1c6a169f1525235ac04d526f6a54dd944cd6b4", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -7,19 +7,21 @@ use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n-use std::mem;\n use std::path::{Path, PathBuf};\n+use std::{env, mem, str};\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n+use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n+use cc::windows_registry;\n+\n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n /// and prevent inspection of linker output in case of errors, which we occasionally do.\n@@ -33,60 +35,121 @@ pub fn disable_localization(linker: &mut Command) {\n     linker.env(\"VSLANG\", \"1033\");\n }\n \n-/// For all the linkers we support, and information they might\n-/// need out of the shared crate context before we get rid of it.\n-#[derive(Encodable, Decodable)]\n-pub struct LinkerInfo {\n-    pub(super) target_cpu: String,\n-    exports: FxHashMap<CrateType, Vec<String>>,\n-}\n-\n-impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt<'_>, target_cpu: String) -> LinkerInfo {\n-        LinkerInfo {\n-            target_cpu,\n-            exports: tcx\n-                .sess\n-                .crate_types()\n-                .iter()\n-                .map(|&c| (c, exported_symbols(tcx, c)))\n-                .collect(),\n+// The third parameter is for env vars, used on windows to set up the\n+// path for MSVC to find its DLLs, and gcc to find its bundled\n+// toolchain\n+pub fn get_linker<'a>(\n+    sess: &'a Session,\n+    linker: &Path,\n+    flavor: LinkerFlavor,\n+    self_contained: bool,\n+    target_cpu: &'a str,\n+) -> Box<dyn Linker + 'a> {\n+    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n+\n+    // If our linker looks like a batch script on Windows then to execute this\n+    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n+    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n+    // `cmd /c emcc.bat ...`.\n+    //\n+    // This worked historically but is needed manually since #42436 (regression\n+    // was tagged as #42791) and some more info can be found on #44443 for\n+    // emscripten itself.\n+    let mut cmd = match linker.to_str() {\n+        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n+        _ => match flavor {\n+            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n+            LinkerFlavor::Msvc if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() => {\n+                Command::new(msvc_tool.as_ref().map_or(linker, |t| t.path()))\n+            }\n+            _ => Command::new(linker),\n+        },\n+    };\n+\n+    // UWP apps have API restrictions enforced during Store submissions.\n+    // To comply with the Windows App Certification Kit,\n+    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n+    let t = &sess.target;\n+    if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n+        && t.vendor == \"uwp\"\n+    {\n+        if let Some(ref tool) = msvc_tool {\n+            let original_path = tool.path();\n+            if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n+                let arch = match t.arch.as_str() {\n+                    \"x86_64\" => Some(\"x64\"),\n+                    \"x86\" => Some(\"x86\"),\n+                    \"aarch64\" => Some(\"arm64\"),\n+                    \"arm\" => Some(\"arm\"),\n+                    _ => None,\n+                };\n+                if let Some(ref a) = arch {\n+                    // FIXME: Move this to `fn linker_with_args`.\n+                    let mut arg = OsString::from(\"/LIBPATH:\");\n+                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a));\n+                    cmd.arg(&arg);\n+                } else {\n+                    warn!(\"arch is not supported\");\n+                }\n+            } else {\n+                warn!(\"MSVC root path lib location not found\");\n+            }\n+        } else {\n+            warn!(\"link.exe not found\");\n         }\n     }\n \n-    pub fn to_linker<'a>(\n-        &'a self,\n-        cmd: Command,\n-        sess: &'a Session,\n-        flavor: LinkerFlavor,\n-    ) -> Box<dyn Linker + 'a> {\n-        match flavor {\n-            LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n-                Box::new(MsvcLinker { cmd, sess, info: self }) as Box<dyn Linker>\n-            }\n-            LinkerFlavor::Em => Box::new(EmLinker { cmd, sess, info: self }) as Box<dyn Linker>,\n-            LinkerFlavor::Gcc => {\n-                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: false })\n-                    as Box<dyn Linker>\n+    // The compiler's sysroot often has some bundled tools, so add it to the\n+    // PATH for the child.\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n+    let mut msvc_changed_path = false;\n+    if sess.target.is_like_msvc {\n+        if let Some(ref tool) = msvc_tool {\n+            cmd.args(tool.args());\n+            for &(ref k, ref v) in tool.env() {\n+                if k == \"PATH\" {\n+                    new_path.extend(env::split_paths(v));\n+                    msvc_changed_path = true;\n+                } else {\n+                    cmd.env(k, v);\n+                }\n             }\n+        }\n+    }\n \n-            LinkerFlavor::Lld(LldFlavor::Ld)\n-            | LinkerFlavor::Lld(LldFlavor::Ld64)\n-            | LinkerFlavor::Ld => {\n-                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: true })\n-                    as Box<dyn Linker>\n-            }\n+    if !msvc_changed_path {\n+        if let Some(path) = env::var_os(\"PATH\") {\n+            new_path.extend(env::split_paths(&path));\n+        }\n+    }\n+    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n \n-            LinkerFlavor::Lld(LldFlavor::Wasm) => {\n-                Box::new(WasmLd::new(cmd, sess, self)) as Box<dyn Linker>\n-            }\n+    // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n+    // to the linker args construction.\n+    assert!(cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n \n-            LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n+    match flavor {\n+        LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n+            Box::new(MsvcLinker { cmd, sess }) as Box<dyn Linker>\n+        }\n+        LinkerFlavor::Em => Box::new(EmLinker { cmd, sess }) as Box<dyn Linker>,\n+        LinkerFlavor::Gcc => {\n+            Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: false })\n+                as Box<dyn Linker>\n+        }\n \n-            LinkerFlavor::BpfLinker => {\n-                Box::new(BpfLinker { cmd, sess, info: self }) as Box<dyn Linker>\n-            }\n+        LinkerFlavor::Lld(LldFlavor::Ld)\n+        | LinkerFlavor::Lld(LldFlavor::Ld64)\n+        | LinkerFlavor::Ld => {\n+            Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: true })\n+                as Box<dyn Linker>\n         }\n+\n+        LinkerFlavor::Lld(LldFlavor::Wasm) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n+\n+        LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n+\n+        LinkerFlavor::BpfLinker => Box::new(BpfLinker { cmd, sess }) as Box<dyn Linker>,\n     }\n }\n \n@@ -122,7 +185,7 @@ pub trait Linker {\n     fn debuginfo(&mut self, strip: Strip);\n     fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n-    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType, symbols: &[String]);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n@@ -150,7 +213,7 @@ impl dyn Linker + '_ {\n pub struct GccLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n+    target_cpu: &'a str,\n     hinted_static: bool, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n@@ -225,7 +288,7 @@ impl<'a> GccLinker<'a> {\n         };\n \n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n-        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.info.target_cpu));\n+        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.target_cpu));\n     }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n@@ -554,7 +617,7 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType, symbols: &[String]) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable && self.sess.target.override_export_symbols.is_none()\n         {\n@@ -583,7 +646,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // Write a plain, newline-separated list of symbols\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n-                for sym in self.info.exports[&crate_type].iter() {\n+                for sym in symbols {\n                     debug!(\"  _{}\", sym);\n                     writeln!(f, \"_{}\", sym)?;\n                 }\n@@ -598,7 +661,7 @@ impl<'a> Linker for GccLinker<'a> {\n                 // .def file similar to MSVC one but without LIBRARY section\n                 // because LD doesn't like when it's empty\n                 writeln!(f, \"EXPORTS\")?;\n-                for symbol in self.info.exports[&crate_type].iter() {\n+                for symbol in symbols {\n                     debug!(\"  _{}\", symbol);\n                     writeln!(f, \"  {}\", symbol)?;\n                 }\n@@ -611,9 +674,9 @@ impl<'a> Linker for GccLinker<'a> {\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 writeln!(f, \"{{\")?;\n-                if !self.info.exports[&crate_type].is_empty() {\n+                if !symbols.is_empty() {\n                     writeln!(f, \"  global:\")?;\n-                    for sym in self.info.exports[&crate_type].iter() {\n+                    for sym in symbols {\n                         debug!(\"    {};\", sym);\n                         writeln!(f, \"    {};\", sym)?;\n                     }\n@@ -713,7 +776,6 @@ impl<'a> Linker for GccLinker<'a> {\n pub struct MsvcLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for MsvcLinker<'a> {\n@@ -887,7 +949,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // crates. Upstream rlibs may be linked statically to this dynamic library,\n     // in which case they may continue to transitively be used and hence need\n     // their symbols exported.\n-    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType, symbols: &[String]) {\n         // Symbol visibility takes care of this typically\n         if crate_type == CrateType::Executable {\n             return;\n@@ -901,7 +963,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n             // straight to exports.\n             writeln!(f, \"LIBRARY\")?;\n             writeln!(f, \"EXPORTS\")?;\n-            for symbol in self.info.exports[&crate_type].iter() {\n+            for symbol in symbols {\n                 debug!(\"  _{}\", symbol);\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n@@ -954,7 +1016,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n pub struct EmLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for EmLinker<'a> {\n@@ -1066,9 +1127,7 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n \n-    fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n-        let symbols = &self.info.exports[&crate_type];\n-\n+    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n         debug!(\"EXPORTED SYMBOLS:\");\n \n         self.cmd.arg(\"-s\");\n@@ -1110,11 +1169,10 @@ impl<'a> Linker for EmLinker<'a> {\n pub struct WasmLd<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n }\n \n impl<'a> WasmLd<'a> {\n-    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+    fn new(mut cmd: Command, sess: &'a Session) -> WasmLd<'a> {\n         // If the atomics feature is enabled for wasm then we need a whole bunch\n         // of flags:\n         //\n@@ -1147,7 +1205,7 @@ impl<'a> WasmLd<'a> {\n             cmd.arg(\"--export=__tls_align\");\n             cmd.arg(\"--export=__tls_base\");\n         }\n-        WasmLd { cmd, sess, info }\n+        WasmLd { cmd, sess }\n     }\n }\n \n@@ -1263,8 +1321,8 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_default_libraries(&mut self) {}\n \n-    fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n-        for sym in self.info.exports[&crate_type].iter() {\n+    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n+        for sym in symbols {\n             self.cmd.arg(\"--export\").arg(&sym);\n         }\n \n@@ -1287,7 +1345,7 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n }\n \n-fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n+pub(crate) fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n     if let Some(ref exports) = tcx.sess.target.override_export_symbols {\n         return exports.clone();\n     }\n@@ -1416,7 +1474,7 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn control_flow_guard(&mut self) {}\n \n-    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n+    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType, _symbols: &[String]) {}\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n@@ -1430,7 +1488,6 @@ impl<'a> Linker for PtxLinker<'a> {\n pub struct BpfLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for BpfLinker<'a> {\n@@ -1517,11 +1574,11 @@ impl<'a> Linker for BpfLinker<'a> {\n \n     fn control_flow_guard(&mut self) {}\n \n-    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n+    fn export_symbols(&mut self, tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n         let path = tmpdir.join(\"symbols\");\n         let res: io::Result<()> = try {\n             let mut f = BufWriter::new(File::create(&path)?);\n-            for sym in self.info.exports[&crate_type].iter() {\n+            for sym in symbols {\n                 writeln!(f, \"{}\", sym)?;\n             }\n         };"}, {"sha": "41823f7d80d69acd3d28c95060a91c4b517c33b4", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -1,5 +1,4 @@\n use super::link::{self, ensure_removed};\n-use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n \n@@ -430,8 +429,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n     let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n \n-    let linker_info = LinkerInfo::new(tcx, target_cpu);\n-    let crate_info = CrateInfo::new(tcx);\n+    let crate_info = CrateInfo::new(tcx, target_cpu);\n \n     let regular_config =\n         ModuleConfig::new(ModuleKind::Regular, sess, no_builtins, is_compiler_builtins);\n@@ -461,7 +459,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     OngoingCodegen {\n         backend,\n         metadata,\n-        linker_info,\n         crate_info,\n \n         coordinator_send,\n@@ -1799,7 +1796,6 @@ impl SharedEmitterMain {\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub metadata: EncodedMetadata,\n-    pub linker_info: LinkerInfo,\n     pub crate_info: CrateInfo,\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n     pub codegen_worker_receive: Receiver<Message<B>>,\n@@ -1842,7 +1838,6 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         (\n             CodegenResults {\n                 metadata: self.metadata,\n-                linker_info: self.linker_info,\n                 crate_info: self.crate_info,\n \n                 modules: compiled_modules.modules,"}, {"sha": "7df17bd20b99208873e69d284c42c835e3108ab2", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -754,7 +754,13 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n }\n \n impl CrateInfo {\n-    pub fn new(tcx: TyCtxt<'_>) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt<'_>, target_cpu: String) -> CrateInfo {\n+        let exported_symbols = tcx\n+            .sess\n+            .crate_types()\n+            .iter()\n+            .map(|&c| (c, crate::back::linker::exported_symbols(tcx, c)))\n+            .collect();\n         let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n         let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n@@ -770,8 +776,9 @@ impl CrateInfo {\n         });\n \n         let mut info = CrateInfo {\n+            target_cpu,\n+            exported_symbols,\n             local_crate_name,\n-            panic_runtime: None,\n             compiler_builtins: None,\n             profiler_runtime: None,\n             is_no_builtins: Default::default(),\n@@ -800,9 +807,6 @@ impl CrateInfo {\n                 .insert(cnum, tcx.native_libraries(cnum).iter().map(Into::into).collect());\n             info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n             info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n-            if tcx.is_panic_runtime(cnum) {\n-                info.panic_runtime = Some(cnum);\n-            }\n             if tcx.is_compiler_builtins(cnum) {\n                 info.compiler_builtins = Some(cnum);\n             }"}, {"sha": "b6ee70c419b160e224a8dcb60067c8ff9e240e06", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::cstore::{self, CrateSource};\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::ty::query::Providers;\n-use rustc_session::config::{OutputFilenames, OutputType, RUST_CGU_EXT};\n+use rustc_session::config::{CrateType, OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_session::utils::NativeLibKind;\n use rustc_span::symbol::Symbol;\n use std::path::{Path, PathBuf};\n@@ -135,8 +135,9 @@ impl From<&cstore::NativeLib> for NativeLib {\n /// and the corresponding properties without referencing information outside of a `CrateInfo`.\n #[derive(Debug, Encodable, Decodable)]\n pub struct CrateInfo {\n+    pub target_cpu: String,\n+    pub exported_symbols: FxHashMap<CrateType, Vec<String>>,\n     pub local_crate_name: Symbol,\n-    pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,\n     pub profiler_runtime: Option<CrateNum>,\n     pub is_no_builtins: FxHashSet<CrateNum>,\n@@ -157,7 +158,6 @@ pub struct CodegenResults {\n     pub allocator_module: Option<CompiledModule>,\n     pub metadata_module: Option<CompiledModule>,\n     pub metadata: rustc_middle::middle::cstore::EncodedMetadata,\n-    pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }\n "}, {"sha": "d3862309ce46f54c6f33aa493dc522bfd709e32c", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b20e3ff2af39e1de6280d52aea2e87585e98056d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20e3ff2af39e1de6280d52aea2e87585e98056d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=b20e3ff2af39e1de6280d52aea2e87585e98056d", "patch": "@@ -12,7 +12,6 @@ extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n \n-use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::{CodegenResults, CrateInfo};\n use rustc_data_structures::fx::FxHashMap;\n@@ -38,8 +37,7 @@ impl CodegenBackend for TheBackend {\n             allocator_module: None,\n             metadata_module: None,\n             metadata,\n-            linker_info: LinkerInfo::new(tcx, \"fake_target_cpu\".to_string()),\n-            crate_info: CrateInfo::new(tcx),\n+            crate_info: CrateInfo::new(tcx, \"fake_target_cpu\".to_string()),\n         })\n     }\n "}]}