{"sha": "7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDZjNTU3MmE4YzRjNWMwZjZhYTZlNjliYjYzZDY0ZGU1MGQ2OTc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-03-30T14:58:05Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-12T07:10:27Z"}, "message": "libsyntax: derive Clone, Eq, TotalEq, Ord, TotalOrd with the new generic deriving code.\n\nCloses #4269, #5588 and #5589.", "tree": {"sha": "c60b9e98a0bd0bbc5198ce74ac7c0d9b6b3217c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60b9e98a0bd0bbc5198ce74ac7c0d9b6b3217c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "html_url": "https://github.com/rust-lang/rust/commit/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85b82c763bfbfd5de59f4c6b026dca58f3ba4687", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b82c763bfbfd5de59f4c6b026dca58f3ba4687", "html_url": "https://github.com/rust-lang/rust/commit/85b82c763bfbfd5de59f4c6b026dca58f3ba4687"}], "stats": {"total": 1172, "additions": 411, "deletions": 761}, "files": [{"sha": "0c62566702d908149b9986b014c82c954d24d320", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 64, "deletions": 258, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -8,29 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n-use ast;\n-use ast::*;\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n+use ext::deriving::generic::*;\n+use core::option::{None,Some};\n \n-use core::uint;\n \n pub fn expand_deriving_clone(cx: @ext_ctxt,\n                              span: span,\n-                             _: @meta_item,\n+                             mitem: @meta_item,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_clone_struct_def,\n-                    expand_deriving_clone_enum_def)\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"clone\", ~\"Clone\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"clone\",\n+                nargs: 0,\n+                output_type: None, // return Self\n+                combine_substructure: cs_clone\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span,\n+                            mitem, in_items,\n+                            &trait_def)\n }\n \n pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n@@ -42,252 +48,52 @@ pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n     in_items\n }\n \n-fn create_derived_clone_impl(cx: @ext_ctxt,\n-                             span: span,\n-                             type_ident: ident,\n-                             generics: &Generics,\n-                             method: @method)\n-                          -> @item {\n-    let methods = [ method ];\n-    let trait_path = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"clone\"),\n-        cx.ident_of(~\"Clone\"),\n-    ];\n-    let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path,\n-                        opt_vec::Empty, opt_vec::Empty)\n-}\n-// Creates a method from the given expression conforming to the signature of\n-// the `clone` method.\n-fn create_clone_method(cx: @ext_ctxt,\n-                       span: span,\n-                       +type_ident: ast::ident,\n-                       generics: &Generics,\n-                       expr: @ast::expr)\n-                    -> @method {\n-    // Create the type parameters of the return value.\n-    let mut output_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n-        output_ty_params.push(path);\n-    }\n-\n-    // Create the type of the return value.\n-    let output_type_path = build::mk_raw_path_(span,\n-                                               ~[ type_ident ],\n-                                               output_ty_params);\n-    let output_type = ast::ty_path(output_type_path, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n-\n-    // Create the self type and method identifier.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"clone\");\n-\n-    // Create the method.\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public,\n+fn cs_clone(cx: @ext_ctxt, span: span,\n+            substr: &Substructure) -> @expr {\n+    let clone_ident = substr.method_ident;\n+    let ctor_ident;\n+    let all_fields;\n+    let subcall = |field|\n+        build::mk_method_call(cx, span, field, clone_ident, ~[]);\n+\n+    match *substr.fields {\n+        Struct(af) => {\n+            ctor_ident = ~[ substr.type_ident ];\n+            all_fields = af;\n+        }\n+        EnumMatching(_, variant, af) => {\n+            ctor_ident = ~[ variant.node.name ];\n+            all_fields = af;\n+        },\n+        EnumNonMatching(*) => cx.bug(\"Non-matching enum variants in `deriving(Clone)`\")\n     }\n-}\n-\n-fn call_substructure_clone_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  self_field: @expr)\n-                               -> @expr {\n-    // Call the substructure method.\n-    let clone_ident = cx.ident_of(~\"clone\");\n-    build::mk_method_call(cx, span,\n-                          self_field, clone_ident,\n-                          ~[])\n-}\n-\n-fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-                                 -> @item {\n-    // Create the method.\n-    let method = if !is_struct_tuple(struct_def) {\n-        expand_deriving_clone_struct_method(cx,\n-                                            span,\n-                                            struct_def,\n-                                            type_ident,\n-                                            generics)\n-    } else {\n-        expand_deriving_clone_tuple_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  type_ident,\n-                                                  generics)\n-    };\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  type_ident: ident,\n-                                  generics: &Generics)\n-                               -> @item {\n-    // Create the method.\n-    let method = expand_deriving_clone_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   type_ident,\n-                                                   generics);\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       struct_def: &struct_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the new fields.\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n \n-                // Call the substructure method.\n-                let call = call_substructure_clone_method(cx,\n-                                                          span,\n-                                                          self_field);\n-\n-                let field = build::Field { ident: ident, ex: call };\n-                fields.push(field);\n-            }\n-            unnamed_field => {\n-                cx.span_bug(span, ~\"unnamed fields in `deriving(Clone)`\");\n+    match all_fields {\n+        [(None, _, _), .. _] => {\n+            // enum-like\n+            let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n+            build::mk_call(cx, span, ctor_ident, subcalls)\n+        },\n+        _ => {\n+            // struct-like\n+            let fields = do all_fields.map |&(o_id, self_f, _)| {\n+                let ident = match o_id {\n+                    Some(i) => i,\n+                    None => cx.span_bug(span,\n+                                        ~\"unnamed field in normal struct \\\n+                                          in `deriving(Clone)`\")\n+                };\n+                build::Field { ident: ident, ex: subcall(self_f) }\n+            };\n+\n+            if fields.is_empty() {\n+                // no fields, so construct like `None`\n+                build::mk_path(cx, span, ctor_ident)\n+            } else {\n+                build::mk_struct_e(cx, span,\n+                                   ctor_ident,\n+                                   fields)\n             }\n         }\n     }\n-\n-    // Create the struct literal.\n-    let struct_literal = build::mk_struct_e(cx,\n-                                            span,\n-                                            ~[ type_ident ],\n-                                            fields);\n-    create_clone_method(cx, span, type_ident, generics, struct_literal)\n-}\n-\n-fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n-                                             span: span,\n-                                             struct_def: &struct_def,\n-                                             type_ident: ident,\n-                                             generics: &Generics)\n-                                          -> @method {\n-    // Create the pattern for the match.\n-    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n-    let field_count = struct_def.fields.len();\n-    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n-    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n-\n-    // Create the new fields.\n-    let mut subcalls = ~[];\n-    for uint::range(0, struct_def.fields.len()) |i| {\n-        // Create the expression for this field.\n-        let field_ident = cx.ident_of(~\"__self_\" + i.to_str());\n-        let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-        // Call the substructure method.\n-        let subcall = call_substructure_clone_method(cx, span, field);\n-        subcalls.push(subcall);\n-    }\n-\n-    // Create the call to the struct constructor.\n-    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n-\n-    // Create the pattern body.\n-    let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-    // Create the arm.\n-    let arm = ast::arm {\n-        pats: ~[ pat ],\n-        guard: None,\n-        body: match_body_block\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n-                                     span: span,\n-                                     enum_definition: &enum_def,\n-                                     type_ident: ident,\n-                                     generics: &Generics)\n-                                  -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.map |variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Iterate over the variant arguments, creating the subcalls.\n-        let mut subcalls = ~[];\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let subcall = call_substructure_clone_method(cx, span, field);\n-            subcalls.push(subcall);\n-        }\n-\n-        // Create the call to the enum variant (if necessary).\n-        let call = if subcalls.len() > 0 {\n-            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n-        } else {\n-            build::mk_path(cx, span, ~[ variant.node.name ])\n-        };\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-        // Create the arm.\n-        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n }"}, {"sha": "142f0565e149e3d4fd59c38ba2d568b2e60daacf", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+use core::option::Some;\n+\n+pub fn expand_deriving_eq(cx: @ext_ctxt,\n+                          span: span,\n+                          mitem: @meta_item,\n+                          in_items: ~[@item]) -> ~[@item] {\n+    // structures are equal if all fields are equal, and non equal, if\n+    // any fields are not equal or if the enum variants are different\n+    fn cs_eq(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+                                 cx, span, substr)\n+    }\n+    fn cs_ne(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_or(|cx, span, _| build::mk_bool(cx, span, true),\n+              cx, span, substr)\n+    }\n+\n+\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"Eq\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"ne\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: cs_ne\n+            },\n+            MethodDef {\n+                name: ~\"eq\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: cs_eq\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n+                                span: span,\n+                                _mitem: @meta_item,\n+                                in_items: ~[@item]) -> ~[@item] {\n+    cx.span_err(span, ~\"`#[deriving_eq]` is obsolete; use `#[deriving(Eq)]` instead\");\n+    in_items\n+}"}, {"sha": "7f7babab45cc4caf8558fb137b1702562de11404", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr_if, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+use core::option::Some;\n+\n+macro_rules! mk_cso {\n+    ($less:expr, $equal:expr) => {\n+        |cx, span, substr|\n+        cs_ord($less, $equal, cx, span, substr)\n+    }\n+}\n+\n+pub fn expand_deriving_ord(cx: @ext_ctxt,\n+                           span: span,\n+                           mitem: @meta_item,\n+                           in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"Ord\"],\n+        // XXX: Ord doesn't imply Eq yet\n+        additional_bounds: ~[~[~\"core\", ~\"cmp\", ~\"Eq\"]],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"lt\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: mk_cso!(true, false)\n+            },\n+            MethodDef {\n+                name: ~\"le\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: mk_cso!(true, true)\n+            },\n+            MethodDef {\n+                name: ~\"gt\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: mk_cso!(false, false)\n+            },\n+            MethodDef {\n+                name: ~\"ge\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: mk_cso!(false, true)\n+            },\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+/// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n+fn cs_ord(less: bool, equal: bool,\n+          cx: @ext_ctxt, span: span,\n+          substr: &Substructure) -> @expr {\n+    let binop = if less {\n+        cx.ident_of(~\"lt\")\n+    } else {\n+        cx.ident_of(~\"gt\")\n+    };\n+    let false_blk_expr = build::mk_block(cx, span,\n+                                         ~[], ~[],\n+                                         Some(build::mk_bool(cx, span, false)));\n+    let true_blk = build::mk_simple_block(cx, span,\n+                                          build::mk_bool(cx, span, true));\n+    let base = build::mk_bool(cx, span, equal);\n+\n+    cs_fold(\n+        false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            /*\n+\n+            build up a series of nested ifs from the inside out to get\n+            lexical ordering (hence foldr), i.e.\n+\n+            ```\n+            if self.f1 `binop` other.f1 {\n+                true\n+            } else if self.f1 == other.f1 {\n+                if self.f2 `binop` other.f2 {\n+                    true\n+                } else if self.f2 == other.f2 {\n+                    `equal`\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+            ```\n+\n+            The inner \"`equal`\" case is only reached if the two\n+            items have all fields equal.\n+            */\n+            if other_fs.len() != 1 {\n+                cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n+            }\n+\n+            let cmp = build::mk_method_call(cx, span,\n+                                            self_f, cx.ident_of(~\"eq\"), other_fs);\n+            let subexpr = build::mk_simple_block(cx, span, subexpr);\n+            let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n+            let elseif = build::mk_expr(cx, span, elseif);\n+\n+            let cmp = build::mk_method_call(cx, span,\n+                                            self_f, binop, other_fs);\n+            let if_ = expr_if(cmp, true_blk, Some(elseif));\n+\n+            build::mk_expr(cx, span, if_)\n+        },\n+        base,\n+        |cx, span, args| {\n+            // nonmatching enums, order by the order the variants are\n+            // written\n+            match args {\n+                [(self_var, _, _),\n+                 (other_var, _, _)] =>\n+                    build::mk_bool(cx, span,\n+                                   if less {\n+                                       self_var < other_var\n+                                   } else {\n+                                       self_var > other_var\n+                                   }),\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n+            }\n+        },\n+        cx, span, substr)\n+}"}, {"sha": "d71db22591dd6f1303aadf7bdc5941619a9b8e2f", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+use core::option::Some;\n+\n+pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n+                          span: span,\n+                          mitem: @meta_item,\n+                          in_items: ~[@item]) -> ~[@item] {\n+\n+    fn cs_equals(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+               cx, span, substr)\n+    }\n+\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"TotalEq\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"equals\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                combine_substructure: cs_equals\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}"}, {"sha": "d82c63e9dd343b6a815c005c512b3295f12fb87e", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+use core::cmp::{Ordering, Equal, Less, Greater};\n+use core::option::Some;\n+\n+pub fn expand_deriving_totalord(cx: @ext_ctxt,\n+                                span: span,\n+                                mitem: @meta_item,\n+                                in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"TotalOrd\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"cmp\",\n+                output_type: Some(~[~\"core\", ~\"cmp\", ~\"Ordering\"]),\n+                nargs: 1,\n+                combine_substructure: cs_cmp\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+\n+pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n+    let cnst = match cnst {\n+        Less => ~\"Less\",\n+        Equal => ~\"Equal\",\n+        Greater => ~\"Greater\"\n+    };\n+    build::mk_path(cx, span,\n+                   ~[cx.ident_of(~\"core\"),\n+                     cx.ident_of(~\"cmp\"),\n+                     cx.ident_of(cnst)])\n+}\n+\n+pub fn cs_cmp(cx: @ext_ctxt, span: span,\n+              substr: &Substructure) -> @expr {\n+    let lexical_ord = ~[cx.ident_of(~\"core\"),\n+                        cx.ident_of(~\"cmp\"),\n+                        cx.ident_of(~\"lexical_ordering\")];\n+\n+    cs_same_method_fold(\n+        // foldr (possibly) nests the matches in lexical_ordering better\n+        false,\n+        |cx, span, old, new| {\n+            build::mk_call(cx, span, lexical_ord, ~[old, new])\n+        },\n+        ordering_const(cx, span, Equal),\n+        |cx, span, list| {\n+            match list {\n+                // an earlier nonmatching variant is Less than a\n+                // later one\n+                [(self_var, _, _),\n+                 (other_var, _, _)] => ordering_const(cx, span,\n+                                                   self_var.cmp(&other_var)),\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(TotalOrd)`\")\n+            }\n+        },\n+        cx, span, substr)\n+}"}, {"sha": "0afb667c69ab9d521ff57da9cf095f0ebf8e7bcc", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "removed", "additions": 0, "deletions": 500, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/85b82c763bfbfd5de59f4c6b026dca58f3ba4687/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b82c763bfbfd5de59f4c6b026dca58f3ba4687/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=85b82c763bfbfd5de59f4c6b026dca58f3ba4687", "patch": "@@ -1,500 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use ast;\n-use ast::*;\n-use ext::base::ext_ctxt;\n-use ext::build;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n-\n-use core::uint;\n-\n-enum Junction {\n-    Conjunction,\n-    Disjunction,\n-}\n-\n-pub impl Junction {\n-    fn to_binop(self) -> binop {\n-        match self {\n-            Conjunction => and,\n-            Disjunction => or,\n-        }\n-    }\n-}\n-\n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n-                          span: span,\n-                          _mitem: @meta_item,\n-                          in_items: ~[@item])\n-                       -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_eq_struct_def,\n-                    expand_deriving_eq_enum_def)\n-}\n-\n-pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n-                                span: span,\n-                                _mitem: @meta_item,\n-                                in_items: ~[@item])\n-                             -> ~[@item] {\n-    cx.span_err(span, ~\"`#[deriving_eq]` is obsolete; use `#[deriving(Eq)]` instead\");\n-    in_items\n-}\n-\n-/// Creates a method from the given expression, the signature of which\n-/// conforms to the `eq` or `ne` method.\n-fn create_eq_method(cx: @ext_ctxt,\n-                    span: span,\n-                    method_ident: ident,\n-                    type_ident: ident,\n-                    generics: &Generics,\n-                    body: @expr)\n-                 -> @method {\n-    // Create the type of the `other` parameter.\n-    let arg_path_type = create_self_type_with_params(cx,\n-                                                     span,\n-                                                     type_ident,\n-                                                     generics);\n-    let arg_type = ty_rptr(\n-        None,\n-        ast::mt { ty: arg_path_type, mutbl: m_imm }\n-    );\n-    let arg_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: arg_type,\n-        span: span,\n-    };\n-\n-    // Create the `other` parameter.\n-    let other_ident = cx.ident_of(~\"__other\");\n-    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n-\n-    // Create the type of the return value.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n-    let output_type = ty_path(output_type, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span,\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, body);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn create_derived_eq_impl(cx: @ext_ctxt,\n-                          span: span,\n-                          type_ident: ident,\n-                          generics: &Generics,\n-                          eq_method: @method,\n-                          ne_method: @method)\n-                       -> @item {\n-    let methods = [ eq_method, ne_method ];\n-    let trait_path = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"cmp\"),\n-        cx.ident_of(~\"Eq\")\n-    ];\n-    let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty, [])\n-}\n-\n-fn call_substructure_eq_method(cx: @ext_ctxt,\n-                               span: span,\n-                               self_field: @expr,\n-                               other_field_ref: @expr,\n-                               method_ident: ident,\n-                               junction: Junction,\n-                               chain_expr: &mut Option<@expr>) {\n-    // Call the substructure method.\n-    let self_call = build::mk_method_call(cx, span,\n-                                          self_field, method_ident,\n-                                          ~[ other_field_ref ]);\n-\n-    // Connect to the outer expression if necessary.\n-    *chain_expr = match *chain_expr {\n-        None => Some(self_call),\n-        Some(copy old_outer_expr) => {\n-            let binop = junction.to_binop();\n-            let chain_expr = build::mk_binary(cx,\n-                                              span,\n-                                              binop,\n-                                              old_outer_expr,\n-                                              self_call);\n-            Some(chain_expr)\n-        }\n-    };\n-}\n-\n-fn finish_eq_chain_expr(cx: @ext_ctxt,\n-                        span: span,\n-                        chain_expr: Option<@expr>,\n-                        junction: Junction)\n-                     -> @expr {\n-    match chain_expr {\n-        None => {\n-            match junction {\n-                Conjunction => build::mk_bool(cx, span, true),\n-                Disjunction => build::mk_bool(cx, span, false),\n-            }\n-        }\n-        Some(ref outer_expr) => *outer_expr,\n-    }\n-}\n-\n-fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n-                                 span: span,\n-                                 struct_def: &struct_def,\n-                                 type_ident: ident,\n-                                 generics: &Generics)\n-                              -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-\n-    let derive_struct_fn = if is_struct_tuple(struct_def) {\n-        expand_deriving_eq_struct_tuple_method\n-    } else {\n-        expand_deriving_eq_struct_method\n-    };\n-\n-    let eq_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     eq_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Conjunction);\n-    let ne_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     ne_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               type_ident: ident,\n-                               generics: &Generics)\n-                            -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   eq_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Conjunction);\n-    let ne_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   ne_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    method_ident: ident,\n-                                    type_ident: ident,\n-                                    generics: &Generics,\n-                                    junction: Junction)\n-                                 -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    // Create the body of the method.\n-    let mut outer_expr = None;\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for the other field.\n-                let other_field = build::mk_access(cx,\n-                                                   span,\n-                                                   ~[ other_ident ],\n-                                                   ident);\n-                let other_field_ref = build::mk_addr_of(cx,\n-                                                        span,\n-                                                        other_field);\n-\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                call_substructure_eq_method(cx,\n-                                            span,\n-                                            self_field,\n-                                            other_field_ref,\n-                                            method_ident,\n-                                            junction,\n-                                            &mut outer_expr);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span, ~\"unnamed fields with `deriving(Eq)`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            body);\n-}\n-\n-fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  method_ident: ident,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  junction: Junction)\n-                               -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    let is_eq;\n-    match junction {\n-        Conjunction => is_eq = true,\n-        Disjunction => is_eq = false,\n-    }\n-\n-    // Create the arms of the self match in the method body.\n-    let mut self_arms = ~[];\n-    for enum_definition.variants.each |self_variant| {\n-        let mut other_arms = ~[];\n-\n-        // Create the matching pattern.\n-        let matching_pat = create_enum_variant_pattern(cx,\n-                                                       span,\n-                                                       self_variant,\n-                                                       ~\"__other\");\n-\n-        // Create the matching pattern body.\n-        let mut matching_body_expr = None;\n-        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n-            // Create the expression for the other field.\n-            let other_field_ident = cx.ident_of(~\"__other_\" + i.to_str());\n-            let other_field = build::mk_path(cx,\n-                                             span,\n-                                             ~[ other_field_ident ]);\n-\n-            // Create the expression for this field.\n-            let self_field_ident = cx.ident_of(~\"__self_\" + i.to_str());\n-            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-            // Call the substructure method.\n-            call_substructure_eq_method(cx,\n-                                        span,\n-                                        self_field,\n-                                        other_field,\n-                                        method_ident,\n-                                        junction,\n-                                        &mut matching_body_expr);\n-        }\n-\n-        let matching_body_expr = finish_eq_chain_expr(cx,\n-                                                      span,\n-                                                      matching_body_expr,\n-                                                      junction);\n-        let matching_body_block = build::mk_simple_block(cx,\n-                                                         span,\n-                                                         matching_body_expr);\n-\n-        // Create the matching arm.\n-        let matching_arm = ast::arm {\n-            pats: ~[ matching_pat ],\n-            guard: None,\n-            body: matching_body_block\n-        };\n-        other_arms.push(matching_arm);\n-\n-        // Maybe generate a non-matching case. If there is only one\n-        // variant then there will always be a match.\n-        if enum_definition.variants.len() > 1 {\n-            // Create the nonmatching pattern.\n-            let nonmatching_pat = @ast::pat {\n-                id: cx.next_id(),\n-                node: pat_wild,\n-                span: span\n-            };\n-\n-            // Create the nonmatching pattern body.\n-            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n-            let nonmatching_body_block =\n-                build::mk_simple_block(cx,\n-                                       span,\n-                                       nonmatching_expr);\n-\n-            // Create the nonmatching arm.\n-            let nonmatching_arm = ast::arm {\n-                pats: ~[ nonmatching_pat ],\n-                guard: None,\n-                body: nonmatching_body_block,\n-            };\n-            other_arms.push(nonmatching_arm);\n-        }\n-\n-        // Create the self pattern.\n-        let self_pat = create_enum_variant_pattern(cx,\n-                                                   span,\n-                                                   self_variant,\n-                                                   ~\"__self\");\n-\n-        // Create the self pattern body.\n-        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n-        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_match_expr = expr_match(other_expr, other_arms);\n-        let other_match_expr = build::mk_expr(cx,\n-                                              span,\n-                                              other_match_expr);\n-        let other_match_body_block = build::mk_simple_block(cx,\n-                                                            span,\n-                                                            other_match_expr);\n-\n-        // Create the self arm.\n-        let self_arm = ast::arm {\n-            pats: ~[ self_pat ],\n-            guard: None,\n-            body: other_match_body_block,\n-        };\n-        self_arms.push(self_arm);\n-    }\n-\n-    // Create the method body.\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            self_match_expr);\n-}\n-\n-fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          struct_def: &struct_def,\n-                                          method_ident: ident,\n-                                          type_ident: ident,\n-                                          generics: &Generics,\n-                                          junction: Junction)\n-                                        -> @method {\n-    let self_str = ~\"self\";\n-    let other_str = ~\"__other\";\n-    let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = copy struct_def.fields;\n-\n-    // Create comparison expression, comparing each of the fields\n-    let mut match_body = None;\n-    for fields.eachi |i, _| {\n-        let other_field_ident = cx.ident_of(fmt!(\"%s_%u\", other_str, i));\n-        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n-\n-        let self_field_ident = cx.ident_of(fmt!(\"%s_%u\", self_str, i));\n-        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-        call_substructure_eq_method(cx, span, self_field, other_field,\n-            method_ident, junction, &mut match_body);\n-    }\n-    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n-\n-    // Create arm for the '__other' match, containing the comparison expr\n-    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n-    let other_arm = ast::arm {\n-        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, match_body),\n-    };\n-\n-    // Create the match on '__other'\n-    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n-    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n-    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n-\n-    // Create arm for the 'self' match, which contains the '__other' match\n-    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n-    let self_arm = ast::arm {\n-        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, other_match_expr),\n-    };\n-\n-    // Create the match on 'self'\n-    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    create_eq_method(cx, span, method_ident,\n-        type_ident, generics, self_match_expr)\n-}"}, {"sha": "78faf5556b2cec0273f877efa38db65d1272e1e8", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7906c5572a8c4c5c0f6aa6e69bb63d64de50d697/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=7906c5572a8c4c5c0f6aa6e69bb63d64de50d697", "patch": "@@ -30,12 +30,21 @@ use opt_vec;\n \n use core::uint;\n \n-pub mod eq;\n pub mod clone;\n pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n \n+#[path=\"cmp/eq.rs\"]\n+pub mod eq;\n+#[path=\"cmp/totaleq.rs\"]\n+pub mod totaleq;\n+#[path=\"cmp/ord.rs\"]\n+pub mod ord;\n+#[path=\"cmp/totalord.rs\"]\n+pub mod totalord;\n+\n+\n pub mod generic;\n \n pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n@@ -74,8 +83,6 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                     meta_list(tname, _) |\n                     meta_word(tname) => {\n                         match *tname {\n-                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n-                                                            titem, in_items),\n                             ~\"Clone\" => clone::expand_deriving_clone(cx,\n                                 titem.span, titem, in_items),\n                             ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n@@ -84,6 +91,14 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                                 titem.span, titem, in_items),\n                             ~\"Decodable\" => decodable::expand_deriving_decodable(cx,\n                                 titem.span, titem, in_items),\n+                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n+                                                             titem, in_items),\n+                            ~\"TotalEq\" => totaleq::expand_deriving_totaleq(cx, titem.span,\n+                                                                           titem, in_items),\n+                            ~\"Ord\" => ord::expand_deriving_ord(cx, titem.span,\n+                                                               titem, in_items),\n+                            ~\"TotalOrd\" => totalord::expand_deriving_totalord(cx, titem.span,\n+                                                                              titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));"}]}