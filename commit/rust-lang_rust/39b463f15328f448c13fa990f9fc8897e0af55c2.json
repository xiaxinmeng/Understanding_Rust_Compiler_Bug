{"sha": "39b463f15328f448c13fa990f9fc8897e0af55c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjQ2M2YxNTMyOGY0NDhjMTNmYTk5MGY5ZmM4ODk3ZTBhZjU1YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-12T20:03:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-12T20:03:50Z"}, "message": "Auto merge of #22182 - nikomatsakis:cycles-in-collect, r=nikomatsakis\n\nThis resolves a number of bugs that trigger stack overflows or other cyclic errors.\r\n\r\nr? @nick29581 (it is based on work that you started)\r\nf? @jroesch (also based on your branch)", "tree": {"sha": "84e7a693dfc0575f10699fc6de0876995d894ebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84e7a693dfc0575f10699fc6de0876995d894ebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b463f15328f448c13fa990f9fc8897e0af55c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b463f15328f448c13fa990f9fc8897e0af55c2", "html_url": "https://github.com/rust-lang/rust/commit/39b463f15328f448c13fa990f9fc8897e0af55c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b463f15328f448c13fa990f9fc8897e0af55c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca1cf613b8e535ab274d6ce5aecadf4708990bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca1cf613b8e535ab274d6ce5aecadf4708990bf", "html_url": "https://github.com/rust-lang/rust/commit/cca1cf613b8e535ab274d6ce5aecadf4708990bf"}, {"sha": "a25ed227a7887454bd1717286a7ada4f8a8d9a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25ed227a7887454bd1717286a7ada4f8a8d9a00", "html_url": "https://github.com/rust-lang/rust/commit/a25ed227a7887454bd1717286a7ada4f8a8d9a00"}], "stats": {"total": 1699, "additions": 1073, "deletions": 626}, "files": [{"sha": "7eeb0589118fbf8dbfd1cc47df80f92a576083b2", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -233,6 +233,14 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n+pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                            -> ty::GenericPredicates<'tcx>\n+{\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_predicates(&*cdata, def.node, tcx)\n+}\n+\n pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n                             def: ast::DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;"}, {"sha": "e5576de6e842442c0de92fc94f2b2c630b08eaca", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -417,16 +417,22 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n-    -> ty::TypeScheme<'tcx> {\n-\n-    let item = lookup_item(id, cdata.data());\n+pub fn get_predicates<'tcx>(cdata: Cmd,\n+                            item_id: ast::NodeId,\n+                            tcx: &ty::ctxt<'tcx>)\n+                            -> ty::GenericPredicates<'tcx>\n+{\n+    let item_doc = lookup_item(item_id, cdata.data());\n+    doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n+}\n \n-    let t = item_type(ast::DefId { krate: cdata.cnum, node: id }, item, tcx,\n+pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+                      -> ty::TypeScheme<'tcx>\n+{\n+    let item_doc = lookup_item(id, cdata.data());\n+    let t = item_type(ast::DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n                       cdata);\n-\n-    let generics = doc_generics(item, tcx, cdata, tag_item_generics);\n-\n+    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     ty::TypeScheme {\n         generics: generics,\n         ty: t\n@@ -882,14 +888,15 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n     match item_sort(method_doc) {\n         'r' | 'p' => {\n-            let generics = doc_generics(method_doc, tcx, cdata,\n-                                        tag_method_ty_generics);\n+            let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n+            let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n             let fty = doc_method_fty(method_doc, tcx, cdata);\n             let explicit_self = get_explicit_self(method_doc);\n             let provided_source = get_provided_source(method_doc, cdata);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,\n+                                                        predicates,\n                                                         fty,\n                                                         explicit_self,\n                                                         vis,\n@@ -1520,6 +1527,17 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         true\n     });\n \n+    ty::Generics { types: types, regions: regions }\n+}\n+\n+fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        cdata: Cmd,\n+                        tag: uint)\n+                        -> ty::GenericPredicates<'tcx>\n+{\n+    let doc = reader::get_doc(base_doc, tag);\n+\n     let mut predicates = subst::VecPerParamSpace::empty();\n     reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n         let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n@@ -1533,7 +1551,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         true\n     });\n \n-    ty::Generics { types: types, regions: regions, predicates: predicates }\n+    ty::GenericPredicates { predicates: predicates }\n }\n \n pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {"}, {"sha": "3123fa31abdd1ed18a2dd5b360db452a49d0047c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -139,11 +139,21 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n+fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n+                                             ecx: &EncodeContext<'a, 'tcx>,\n+                                             id: ast::NodeId) {\n+    encode_bounds_and_type(rbml_w,\n+                           ecx,\n+                           &ty::lookup_item_type(ecx.tcx, local_def(id)),\n+                           &ty::lookup_predicates(ecx.tcx, local_def(id)));\n+}\n+\n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n-                                    pty: &ty::TypeScheme<'tcx>) {\n-    encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n-    encode_type(ecx, rbml_w, pty.ty);\n+                                    scheme: &ty::TypeScheme<'tcx>,\n+                                    predicates: &ty::GenericPredicates<'tcx>) {\n+    encode_generics(rbml_w, ecx, &scheme.generics, &predicates, tag_item_generics);\n+    encode_type(ecx, rbml_w, scheme.ty);\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n@@ -353,8 +363,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n             disr_val = (*vi)[i].disr_val;\n         }\n-        encode_bounds_and_type(rbml_w, ecx,\n-                               &lookup_item_type(ecx.tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n \n         ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n@@ -698,8 +707,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                token::get_name(nm), id);\n         encode_struct_field_family(rbml_w, field.vis);\n         encode_name(rbml_w, nm);\n-        encode_bounds_and_type(rbml_w, ecx,\n-                               &lookup_item_type(ecx.tcx, local_def(id)));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, id);\n         encode_def_id(rbml_w, local_def(id));\n \n         let stab = stability::lookup(ecx.tcx, field.id);\n@@ -724,8 +732,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, local_def(ctor_id));\n     encode_family(rbml_w, 'o');\n-    encode_bounds_and_type(rbml_w, ecx,\n-                           &lookup_item_type(ecx.tcx, local_def(ctor_id)));\n+    encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n     encode_name(rbml_w, name.name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, local_def(struct_id));\n@@ -749,6 +756,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n+                             predicates: &ty::GenericPredicates<'tcx>,\n                              tag: uint)\n {\n     rbml_w.start_tag(tag);\n@@ -790,7 +798,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n-    for (space, _, predicate) in generics.predicates.iter_enumerated() {\n+    for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n         rbml_w.start_tag(tag_predicate);\n \n         rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n@@ -810,7 +818,7 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n     encode_def_id(rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n-    encode_generics(rbml_w, ecx, &method_ty.generics,\n+    encode_generics(rbml_w, ecx, &method_ty.generics, &method_ty.predicates,\n                     tag_method_ty_generics);\n     encode_method_fty(ecx, rbml_w, &method_ty.fty);\n     encode_visibility(rbml_w, method_ty.vis);\n@@ -844,15 +852,15 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_stability(rbml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n-    let pty = lookup_item_type(ecx.tcx, m.def_id);\n-    encode_bounds_and_type(rbml_w, ecx, &pty);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, m.def_id.local_id());\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n             encode_attributes(rbml_w, &ast_method.attrs[]);\n-            let any_types = !pty.generics.types.is_empty();\n+            let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n+            let any_types = !scheme.generics.types.is_empty();\n             if any_types || is_default_impl || should_inline(&ast_method.attrs[]) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n@@ -887,8 +895,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     encode_parent_item(rbml_w, local_def(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    let type_scheme = ty::lookup_item_type(ecx.tcx, associated_type.def_id);\n-    encode_bounds_and_type(rbml_w, ecx, &type_scheme);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, associated_type.def_id.local_id());\n \n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n@@ -1027,7 +1034,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n@@ -1041,7 +1048,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -1056,7 +1063,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs[]);\n@@ -1105,7 +1112,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n@@ -1119,7 +1126,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n@@ -1161,7 +1168,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'S');\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n@@ -1204,7 +1211,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n-        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n@@ -1305,10 +1312,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n+        let trait_predicates = ty::lookup_predicates(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n+        encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs[]);\n@@ -1384,9 +1392,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                           METHOD_FAMILY);\n                         }\n                     }\n-                    let pty = ty::lookup_item_type(tcx,\n-                                                   method_def_id);\n-                    encode_bounds_and_type(rbml_w, ecx, &pty);\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, method_def_id.local_id());\n \n                     is_nonstatic_method = method_ty.explicit_self !=\n                         ty::StaticExplicitSelfCategory;\n@@ -1415,8 +1421,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 if is_nonstatic_method {\n                     // FIXME: I feel like there is something funny\n                     // going on.\n-                    let pty = ty::lookup_item_type(tcx, item_def_id.def_id());\n-                    encode_bounds_and_type(rbml_w, ecx, &pty);\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, item_def_id.def_id().local_id());\n                 }\n             };\n             match trait_item {\n@@ -1468,8 +1473,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     match nitem.node {\n       ast::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n-        encode_bounds_and_type(rbml_w, ecx,\n-                               &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n             encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n@@ -1486,8 +1490,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type(rbml_w, ecx,\n-                               &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n+        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));\n         encode_stability(rbml_w, stab);"}, {"sha": "423032d1287d7e994c8713525f5bb43b469c1fe3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -951,11 +951,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                         Ok(encode_vec_per_param_space(\n                             this, &type_scheme.generics.regions,\n                             |this, def| def.encode(this).unwrap()))\n-                    });\n-                    this.emit_struct_field(\"predicates\", 2, |this| {\n-                        Ok(encode_vec_per_param_space(\n-                            this, &type_scheme.generics.predicates,\n-                            |this, def| this.emit_predicate(ecx, def)))\n                     })\n                 })\n             });\n@@ -1574,7 +1569,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                 -> ty::TypeScheme<'tcx> {\n-        self.read_struct(\"TypeScheme\", 2, |this| {\n+        self.read_struct(\"TypeScheme\", 3, |this| {\n             Ok(ty::TypeScheme {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n@@ -1590,12 +1585,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Ok(this.read_vec_per_param_space(\n                                     |this| Decodable::decode(this).unwrap()))\n                             }).unwrap(),\n-\n-                            predicates:\n-                            this.read_struct_field(\"predicates\", 2, |this| {\n-                                Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_predicate(dcx)))\n-                            }).unwrap(),\n                         })\n                     })\n                 }).unwrap(),"}, {"sha": "e20968a9ac997c15cb1148f7ea9482ea9e860e3f", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -18,6 +18,7 @@ use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n+use std::iter::IntoIterator;\n use std::slice::Iter;\n use std::vec::{Vec, IntoIter};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -529,6 +530,23 @@ impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n     }\n }\n \n+impl<T> IntoIterator for VecPerParamSpace<T> {\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_vec().into_iter()\n+    }\n+}\n+\n+impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.as_slice().into_iter()\n+    }\n+}\n+\n+\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //"}, {"sha": "395e486059eff8f9f1337802f3578a15c1c78d9a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -283,7 +283,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n-                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> PredicateObligations<'tcx>\n {\n     util::predicates_for_generics(tcx, cause, 0, generic_bounds)"}, {"sha": "b2701ae875c0cb51cc1b914236bda73260b64e1a", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -130,7 +130,10 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n     let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n-    let predicates = trait_def.generics.to_bounds(tcx, &free_substs).predicates.into_vec();\n+\n+    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n+    let predicates = trait_predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n+\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {"}, {"sha": "13f309e129ac9c9a63bd613cd9a5235211323bec", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -561,8 +561,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_def = ty::lookup_trait_def(selcx.tcx(), trait_ref.def_id);\n-    let bounds = trait_def.generics.to_bounds(selcx.tcx(), trait_ref.substs);\n+    let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n+    let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, bounds.predicates.into_vec());\n }"}, {"sha": "5f659aa303e90fd44f7d6d9acbc36dc3a7985191", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -923,8 +923,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 projection_trait_ref={}\",\n                projection_trait_ref.repr(self.tcx()));\n \n-        let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n-        let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+        let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n+        let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 bounds={}\",\n                bounds.repr(self.tcx()));\n@@ -2314,8 +2314,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         snapshot: &infer::CombinedSnapshot)\n                         -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n-        let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n-        let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n+        let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+        let bounds = impl_bounds.instantiate(self.tcx(), impl_substs);\n         let normalized_bounds =\n             project::normalize_with_depth(self, cause.clone(), recursion_depth, &bounds);\n         let normalized_bounds ="}, {"sha": "6c54da1c134f5c63c01086e7090ecccab78c9806", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -290,7 +290,7 @@ impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n                                      recursion_depth: uint,\n-                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n     debug!(\"predicates_for_generics(generic_bounds={})\","}, {"sha": "6026359ddace071f5091598c88b824b3c98a6d57", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -192,7 +192,8 @@ impl ImplOrTraitItemId {\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: ast::Name,\n-    pub generics: ty::Generics<'tcx>,\n+    pub generics: Generics<'tcx>,\n+    pub predicates: GenericPredicates<'tcx>,\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: ast::Visibility,\n@@ -206,6 +207,7 @@ pub struct Method<'tcx> {\n impl<'tcx> Method<'tcx> {\n     pub fn new(name: ast::Name,\n                generics: ty::Generics<'tcx>,\n+               predicates: GenericPredicates<'tcx>,\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: ast::Visibility,\n@@ -216,6 +218,7 @@ impl<'tcx> Method<'tcx> {\n        Method {\n             name: name,\n             generics: generics,\n+            predicates: predicates,\n             fty: fty,\n             explicit_self: explicit_self,\n             vis: vis,\n@@ -710,6 +713,10 @@ pub struct ctxt<'tcx> {\n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n \n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated predicates.\n+    pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n     /// Maps from node-id of a trait object cast (like `foo as\n     /// Box<Trait>`) to the trait reference.\n     pub object_cast_map: ObjectCastMap<'tcx>,\n@@ -1782,33 +1789,45 @@ impl RegionParameterDef {\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n-    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n impl<'tcx> Generics<'tcx> {\n     pub fn empty() -> Generics<'tcx> {\n         Generics {\n             types: VecPerParamSpace::empty(),\n             regions: VecPerParamSpace::empty(),\n-            predicates: VecPerParamSpace::empty(),\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.types.is_empty() && self.regions.is_empty()\n+    }\n+\n     pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n         !self.types.is_empty_in(space)\n     }\n \n     pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n         !self.regions.is_empty_in(space)\n     }\n+}\n \n-    pub fn is_empty(&self) -> bool {\n-        self.types.is_empty() && self.regions.is_empty()\n+/// Bounds on generics.\n+#[derive(Clone, Debug)]\n+pub struct GenericPredicates<'tcx> {\n+    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n+}\n+\n+impl<'tcx> GenericPredicates<'tcx> {\n+    pub fn empty() -> GenericPredicates<'tcx> {\n+        GenericPredicates {\n+            predicates: VecPerParamSpace::empty(),\n+        }\n     }\n \n-    pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n-                     -> GenericBounds<'tcx> {\n-        GenericBounds {\n+    pub fn instantiate(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n+                       -> InstantiatedPredicates<'tcx> {\n+        InstantiatedPredicates {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n@@ -2022,11 +2041,11 @@ impl<'tcx> Predicate<'tcx> {\n \n /// Represents the bounds declared on a particular set of type\n /// parameters.  Should eventually be generalized into a flag list of\n-/// where clauses.  You can obtain a `GenericBounds` list from a\n-/// `Generics` by using the `to_bounds` method. Note that this method\n-/// reflects an important semantic invariant of `GenericBounds`: while\n-/// the bounds in a `Generics` are expressed in terms of the bound type\n-/// parameters of the impl/trait/whatever, a `GenericBounds` instance\n+/// where clauses.  You can obtain a `InstantiatedPredicates` list from a\n+/// `GenericPredicates` by using the `instantiate` method. Note that this method\n+/// reflects an important semantic invariant of `InstantiatedPredicates`: while\n+/// the `GenericPredicates` are expressed in terms of the bound type\n+/// parameters of the impl/trait/whatever, an `InstantiatedPredicates` instance\n /// represented a set of bounds for some particular instantiation,\n /// meaning that the generic parameters have been substituted with\n /// their values.\n@@ -2035,18 +2054,18 @@ impl<'tcx> Predicate<'tcx> {\n ///\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n-/// Here, the `Generics` for `Foo` would contain a list of bounds like\n+/// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+/// like `Foo<int,uint>`, then the `InstantiatedPredicates` would be `[[],\n /// [uint:Bar<int>]]`.\n #[derive(Clone, Debug)]\n-pub struct GenericBounds<'tcx> {\n+pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n-impl<'tcx> GenericBounds<'tcx> {\n-    pub fn empty() -> GenericBounds<'tcx> {\n-        GenericBounds { predicates: VecPerParamSpace::empty() }\n+impl<'tcx> InstantiatedPredicates<'tcx> {\n+    pub fn empty() -> InstantiatedPredicates<'tcx> {\n+        InstantiatedPredicates { predicates: VecPerParamSpace::empty() }\n     }\n \n     pub fn has_escaping_regions(&self) -> bool {\n@@ -2134,10 +2153,12 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n+                                let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n                                     method.span,\n                                     method_generics,\n+                                    method_bounds,\n                                     method.pe_body().id)\n                             }\n                             TypeTraitItem(_) => {\n@@ -2169,10 +2190,12 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n+                                let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n                                     method.span,\n                                     method_generics,\n+                                    method_bounds,\n                                     method.pe_body().id)\n                             }\n                             TypeTraitItem(_) => {\n@@ -2195,11 +2218,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemFn(_, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = ast_util::local_def(id);\n-                        let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n+                        let fn_scheme = lookup_item_type(cx, fn_def_id);\n+                        let fn_predicates = lookup_predicates(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n                                                         item.span,\n-                                                        &fn_pty.generics,\n+                                                        &fn_scheme.generics,\n+                                                        &fn_predicates,\n                                                         body.id)\n                     }\n                     ast::ItemEnum(..) |\n@@ -2208,8 +2233,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemConst(..) |\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n-                        let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, item.span, &pty.generics, id)\n+                        let scheme = lookup_item_type(cx, def_id);\n+                        let predicates = lookup_predicates(cx, def_id);\n+                        construct_parameter_environment(cx,\n+                                                        item.span,\n+                                                        &scheme.generics,\n+                                                        &predicates,\n+                                                        id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -2248,10 +2278,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n /// stray references in a comment or something). We try to reserve the\n /// \"poly\" prefix to refer to higher-ranked things, as in\n /// `PolyTraitRef`.\n+///\n+/// Note that each item also comes with predicates, see\n+/// `lookup_predicates`.\n #[derive(Clone, Debug)]\n pub struct TypeScheme<'tcx> {\n     pub generics: Generics<'tcx>,\n-    pub ty: Ty<'tcx>\n+    pub ty: Ty<'tcx>,\n }\n \n /// As `TypeScheme` but for a trait ref.\n@@ -2393,6 +2426,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         item_substs: RefCell::new(NodeMap()),\n         trait_refs: RefCell::new(NodeMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n+        predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap()),\n@@ -5378,13 +5412,23 @@ pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n-                              -> Rc<ty::TraitDef<'tcx>> {\n+                              -> Rc<TraitDef<'tcx>> {\n     memoized(&cx.trait_defs, did, |did: DefId| {\n         assert!(did.krate != ast::LOCAL_CRATE);\n         Rc::new(csearch::get_trait_def(cx, did))\n     })\n }\n \n+/// Given the did of a trait, returns its full set of predicates.\n+pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                                -> GenericPredicates<'tcx>\n+{\n+    memoized(&cx.predicates, did, |did: DefId| {\n+        assert!(did.krate != ast::LOCAL_CRATE);\n+        csearch::get_predicates(cx, did)\n+    })\n+}\n+\n /// Given a reference to a trait, returns the \"superbounds\" declared\n /// on the trait, with appropriate substitutions applied. Basically,\n /// this applies a filter to the where clauses on the trait, returning\n@@ -6287,7 +6331,7 @@ pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvi\n /// parameters in the same way, this only has an effect on regions.\n pub fn construct_free_substs<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n-    generics: &ty::Generics<'tcx>,\n+    generics: &Generics<'tcx>,\n     free_id: ast::NodeId)\n     -> Substs<'tcx>\n {\n@@ -6332,6 +6376,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n     span: Span,\n     generics: &ty::Generics<'tcx>,\n+    generic_predicates: &ty::GenericPredicates<'tcx>,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment<'a, 'tcx>\n {\n@@ -6346,7 +6391,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     // Compute the bounds on Self and the type parameters.\n     //\n \n-    let bounds = generics.to_bounds(tcx, &free_substs);\n+    let bounds = generic_predicates.instantiate(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_outlive, &ty::Binder(bounds));\n     let predicates = bounds.predicates.into_vec();\n \n@@ -6980,8 +7025,7 @@ impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n \n impl<'tcx> RegionEscape for TypeScheme<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.ty.has_regions_escaping_depth(depth) ||\n-            self.generics.has_regions_escaping_depth(depth)\n+        self.ty.has_regions_escaping_depth(depth)\n     }\n }\n \n@@ -6991,7 +7035,7 @@ impl RegionEscape for Region {\n     }\n }\n \n-impl<'tcx> RegionEscape for Generics<'tcx> {\n+impl<'tcx> RegionEscape for GenericPredicates<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.predicates.has_regions_escaping_depth(depth)\n     }\n@@ -7100,7 +7144,7 @@ impl<'tcx> HasProjectionTypes for ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::GenericBounds<'tcx> {\n+impl<'tcx> HasProjectionTypes for ty::InstantiatedPredicates<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.predicates.has_projection_types()\n     }"}, {"sha": "645a7ab9440b9908520a87f0920487ac181ae3a8", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -400,6 +400,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n+        ty::GenericPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }\n@@ -440,9 +447,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n-        ty::GenericBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n+        ty::InstantiatedPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }"}, {"sha": "0363978bada2530db3160b99b0f9ffa8443771aa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -395,8 +395,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n-            let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, &base, substs, &generics, did, &[])\n+            parameterized(cx, &base, substs, did, &[],\n+                          || ty::lookup_item_type(cx, did).generics)\n         }\n         ty_trait(ref data) => {\n             data.user_string(cx)\n@@ -444,23 +444,40 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n     }\n }\n \n-pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n-                           base: &str,\n-                           substs: &subst::Substs<'tcx>,\n-                           generics: &ty::Generics<'tcx>,\n-                           did: ast::DefId,\n-                           projections: &[ty::ProjectionPredicate<'tcx>])\n-                           -> String\n+pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n+                              base: &str,\n+                              substs: &subst::Substs<'tcx>,\n+                              did: ast::DefId,\n+                              projections: &[ty::ProjectionPredicate<'tcx>],\n+                              get_generics: GG)\n+                              -> String\n+    where GG : FnOnce() -> ty::Generics<'tcx>\n {\n     if cx.sess.verbose() {\n-        if substs.is_noop() {\n-            return format!(\"{}\", base);\n-        } else {\n-            return format!(\"{}<{},{}>\",\n-                           base,\n-                           substs.regions.repr(cx),\n-                           substs.types.repr(cx));\n+        let mut strings = vec![];\n+        match substs.regions {\n+            subst::ErasedRegions => {\n+                strings.push(format!(\"..\"));\n+            }\n+            subst::NonerasedRegions(ref regions) => {\n+                for region in regions.iter() {\n+                    strings.push(region.repr(cx));\n+                }\n+            }\n         }\n+        for ty in substs.types.iter() {\n+            strings.push(ty.repr(cx));\n+        }\n+        for projection in projections.iter() {\n+            strings.push(format!(\"{}={}\",\n+                                 projection.projection_ty.item_name.user_string(cx),\n+                                 projection.ty.user_string(cx)));\n+        }\n+        return if strings.is_empty() {\n+            format!(\"{}\", base)\n+        } else {\n+            format!(\"{}<{}>\", base, strings.connect(\",\"))\n+        };\n     }\n \n     let mut strs = Vec::new();\n@@ -484,6 +501,13 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         }\n     }\n \n+    // It is important to execute this conditionally, only if -Z\n+    // verbose is false. Otherwise, debug logs can sometimes cause\n+    // ICEs trying to fetch the generics early in the pipeline. This\n+    // is kind of a hacky workaround in that -Z verbose is required to\n+    // avoid those ICEs.\n+    let generics = get_generics();\n+\n     let tps = substs.types.get_slice(subst::TypeSpace);\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n@@ -645,13 +669,12 @@ impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let &(ref trait_ref, ref projection_bounds) = self;\n         let base = ty::item_path_str(tcx, trait_ref.def_id);\n-        let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n         parameterized(tcx,\n                       &base,\n                       trait_ref.substs,\n-                      &trait_def.generics,\n                       trait_ref.def_id,\n-                      &projection_bounds[])\n+                      &projection_bounds[],\n+                      || ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n     }\n }\n \n@@ -687,10 +710,9 @@ impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n }\n \n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n+    fn repr(&self, _tcx: &ctxt<'tcx>) -> String {\n+        format!(\"TypeParameterDef({:?}, {:?}/{})\",\n                 self.def_id,\n-                self.bounds.repr(tcx),\n                 self.space,\n                 self.index)\n     }\n@@ -781,11 +803,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n-        let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"TraitRef({}, {})\",\n-                self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, &base, self.substs,\n-                              &trait_def.generics, self.def_id, &[]))\n+        parameterized(tcx, &base, self.substs, self.def_id, &[],\n+                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n     }\n }\n \n@@ -987,16 +1006,22 @@ impl<'tcx> Repr<'tcx> for ty::TypeScheme<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Generics(types: {}, regions: {}, predicates: {})\",\n+        format!(\"Generics(types: {}, regions: {})\",\n                 self.types.repr(tcx),\n-                self.regions.repr(tcx),\n+                self.regions.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"GenericPredicates(predicates: {})\",\n                 self.predicates.repr(tcx))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::GenericBounds<'tcx> {\n+impl<'tcx> Repr<'tcx> for ty::InstantiatedPredicates<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"GenericBounds({})\",\n+        format!(\"InstantiatedPredicates({})\",\n                 self.predicates.repr(tcx))\n     }\n }\n@@ -1249,9 +1274,8 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n-        let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, &path_str, self.substs,\n-                      &trait_def.generics, self.def_id, &[])\n+        parameterized(tcx, &path_str, self.substs, self.def_id, &[],\n+                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n     }\n }\n "}, {"sha": "1951d9946bca9ac54b1bed5c07a946df28574364", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -16,11 +16,12 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type_scheme()` function\n-//! triggers a recursive call to `ty_of_item()`  (note that\n-//! `ast_ty_to_ty()` will detect recursive types and report an error).\n-//! In the check phase, when the FnCtxt is used as the `AstConv`,\n-//! `get_item_type_scheme()` just looks up the item type in `tcx.tcache`.\n+//! `AstConv` instance; in this phase, the `get_item_type_scheme()`\n+//! function triggers a recursive call to `type_scheme_of_item()`\n+//! (note that `ast_ty_to_ty()` will detect recursive types and report\n+//! an error).  In the check phase, when the FnCtxt is used as the\n+//! `AstConv`, `get_item_type_scheme()` just looks up the item type in\n+//! `tcx.tcache` (using `ty::lookup_item_type`).\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required"}, {"sha": "3ea2743c63e6ce466c6417b8850a04838debe36c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -467,8 +467,14 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         }\n     };\n \n-    instantiate_path(pcx.fcx, path, ty::lookup_item_type(tcx, enum_def_id),\n-                     None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx,\n+                     path,\n+                     ty::lookup_item_type(tcx, enum_def_id),\n+                     &ty::lookup_predicates(tcx, enum_def_id),\n+                     None,\n+                     def,\n+                     pat.span,\n+                     pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n@@ -499,6 +505,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n+    let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n     let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n         let fn_ret = ty::assert_no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty));\n         ty::TypeScheme {\n@@ -508,7 +515,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_scheme, None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, path_scheme, &ctor_predicates, None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "1e1d7e0926038ee833713e13e6f1ca8b7928bbae", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -205,7 +205,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n     let impl_bounds =\n-        impl_m.generics.to_bounds(tcx, impl_to_skol_substs);\n+        impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n \n     let (impl_bounds, _) =\n         infcx.replace_late_bound_regions_with_fresh_var(\n@@ -216,7 +216,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_bounds.repr(tcx));\n \n     // Normalize the associated types in the trait_bounds.\n-    let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n+    let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n \n     // Obtain the predicate split predicate sets for each.\n     let trait_pred = trait_bounds.predicates.split();"}, {"sha": "ce67369ca9dda132ecfa707b24b6c0ea8d9cc0be", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -131,8 +131,9 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n+            let dtor_predicates = ty::lookup_predicates(rcx.tcx(), impl_did);\n \n-            let has_pred_of_interest = dtor_generics.predicates.iter().any(|pred| {\n+            let has_pred_of_interest = dtor_predicates.predicates.iter().any(|pred| {\n                 // In `impl<T> Drop where ...`, we automatically\n                 // assume some predicate will be meaningful and thus\n                 // represents a type through which we could reach"}, {"sha": "dfbfc86c659704db316a77dc8f6cf8347126676a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -46,7 +46,7 @@ struct InstantiatedMethodSig<'tcx> {\n \n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n-    method_bounds: ty::GenericBounds<'tcx>,\n+    method_predicates: ty::InstantiatedPredicates<'tcx>,\n }\n \n pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -99,15 +99,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_bounds\n+            method_sig, all_substs, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs, &method_bounds);\n+        self.add_obligations(&pick, &all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -416,18 +416,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // that obligation is not necessarily satisfied. (In the\n         // future, it would be.) But we know that the true `Self` DOES implement\n         // the trait. So we just delete this requirement. Hack hack hack.\n-        let mut method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &all_substs);\n+        let mut method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n         match pick.kind {\n             probe::ObjectPick(..) => {\n-                assert_eq!(method_bounds.predicates.get_slice(subst::SelfSpace).len(), 1);\n-                method_bounds.predicates.pop(subst::SelfSpace);\n+                assert_eq!(method_predicates.predicates.get_slice(subst::SelfSpace).len(), 1);\n+                method_predicates.predicates.pop(subst::SelfSpace);\n             }\n             _ => { }\n         }\n-        let method_bounds = self.fcx.normalize_associated_types_in(self.span, &method_bounds);\n+        let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n+                                                                       &method_predicates);\n \n-        debug!(\"method_bounds after subst = {}\",\n-               method_bounds.repr(self.tcx()));\n+        debug!(\"method_predicates after subst = {}\",\n+               method_predicates.repr(self.tcx()));\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -446,22 +447,22 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         InstantiatedMethodSig {\n             method_sig: method_sig,\n             all_substs: all_substs,\n-            method_bounds: method_bounds,\n+            method_predicates: method_predicates,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        pick: &probe::Pick<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n-                       method_bounds: &ty::GenericBounds<'tcx>) {\n-        debug!(\"add_obligations: pick={} all_substs={} method_bounds={}\",\n+                       method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n+        debug!(\"add_obligations: pick={} all_substs={} method_predicates={}\",\n                pick.repr(self.tcx()),\n                all_substs.repr(self.tcx()),\n-               method_bounds.repr(self.tcx()));\n+               method_predicates.repr(self.tcx()));\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n-            method_bounds);\n+            method_predicates);\n \n         self.fcx.add_default_region_param_bounds(\n             all_substs,"}, {"sha": "55b4dae5b9eb1a4865aa9e38825bc5af4439ff04", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -221,7 +221,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = fcx.instantiate_bounds(span, trait_ref.substs, &method_ty.generics);\n+    let method_bounds = fcx.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),"}, {"sha": "82bd4ae87ffae8d9cecefac8af626982caa1c848", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -666,8 +666,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n                    projection_trait_ref.repr(self.tcx()));\n \n-            let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n-            let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+            let trait_predicates = ty::lookup_predicates(self.tcx(),\n+                                                         projection_trait_ref.def_id);\n+            let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={}\",\n                    predicates.repr(self.tcx()));\n@@ -943,8 +944,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n-                    let impl_bounds = impl_generics.to_bounds(self.tcx(), substs);\n+                    let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+                    let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n                     let traits::Normalized { value: impl_bounds,\n                                              obligations: norm_obligations } =\n                         traits::normalize(selcx, cause.clone(), &impl_bounds);"}, {"sha": "d12b23187b80b0498036b11b9f68598f9c4edc85", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -93,15 +93,15 @@ use middle::pat_util::{self, pat_id_map};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{FnSig, VariantInfo, TypeScheme};\n+use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n-use {CrateCtxt, lookup_def_ccx, no_params, require_same_types};\n+use {CrateCtxt, lookup_def_ccx, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n@@ -1446,11 +1446,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn instantiate_bounds(&self,\n                           span: Span,\n                           substs: &Substs<'tcx>,\n-                          generics: &ty::Generics<'tcx>)\n-                          -> ty::GenericBounds<'tcx>\n+                          bounds: &ty::GenericPredicates<'tcx>)\n+                          -> ty::InstantiatedPredicates<'tcx>\n     {\n-        ty::GenericBounds {\n-            predicates: self.instantiate_type_scheme(span, substs, &generics.predicates)\n+        ty::InstantiatedPredicates {\n+            predicates: self.instantiate_type_scheme(span, substs, &bounds.predicates)\n         }\n     }\n \n@@ -1561,12 +1561,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let type_scheme =\n             ty::lookup_item_type(self.tcx(), def_id);\n+        let type_predicates =\n+            ty::lookup_predicates(self.tcx(), def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n                 &type_scheme.generics);\n         let bounds =\n-            self.instantiate_bounds(span, &substs, &type_scheme.generics);\n+            self.instantiate_bounds(span, &substs, &type_predicates);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n@@ -1594,7 +1596,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        let ty::TypeScheme { generics, ty: decl_ty } = ty::lookup_item_type(tcx, did);\n+        let ty::TypeScheme { generics, ty: decl_ty } =\n+            ty::lookup_item_type(tcx, did);\n \n         let wants_params =\n             generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n@@ -1843,16 +1846,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// and `T`. This routine will add a region obligation `$1:'$0` and register it locally.\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause<'tcx>,\n-                                          generic_bounds: &ty::GenericBounds<'tcx>)\n+                                          predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n-        assert!(!generic_bounds.has_escaping_regions());\n+        assert!(!predicates.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(generic_bounds={})\",\n-               generic_bounds.repr(self.tcx()));\n+        debug!(\"add_obligations_for_parameters(predicates={})\",\n+               predicates.repr(self.tcx()));\n \n         let obligations = traits::predicates_for_generics(self.tcx(),\n                                                           cause,\n-                                                          generic_bounds);\n+                                                          predicates);\n \n         obligations.map_move(|o| self.register_predicate(o));\n     }\n@@ -3616,8 +3619,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprPath(ref path) => {\n           let defn = lookup_def(fcx, path.span, id);\n-          let pty = type_scheme_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, path, pty, None, defn, expr.span, expr.id);\n+          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n+          instantiate_path(fcx, path, scheme, &predicates, None, defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -3629,10 +3632,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           astconv::instantiate_trait_ref(fcx, fcx, &*qpath.trait_ref, Some(self_ty), None);\n \n           let defn = lookup_def(fcx, expr.span, id);\n-          let pty = type_scheme_for_def(fcx, expr.span, defn);\n+          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n           let mut path = qpath.trait_ref.path.clone();\n           path.segments.push(qpath.item_path.clone());\n-          instantiate_path(fcx, &path, pty, Some(self_ty), defn, expr.span, expr.id);\n+          instantiate_path(fcx, &path, scheme, &predicates, Some(self_ty),\n+                           defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -4048,9 +4052,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n-                    let polytype = ty::lookup_item_type(tcx, did);\n+                    let predicates = ty::lookup_predicates(tcx, did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n-                    let bounds = fcx.instantiate_bounds(expr.span, &substs, &polytype.generics);\n+                    let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n                     fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(expr.span,\n                                                      fcx.body_id,\n@@ -4631,46 +4635,36 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     sp: Span,\n-                                     defn: def::Def)\n-                                     -> TypeScheme<'tcx> {\n+fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                sp: Span,\n+                                                defn: def::Def)\n+                                                -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n     match defn {\n-      def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n-          let typ = fcx.local_ty(sp, nid);\n-          return no_params(typ);\n-      }\n-      def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n-      def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-      def::DefStruct(id) | def::DefConst(id) => {\n-        return ty::lookup_item_type(fcx.ccx.tcx, id);\n-      }\n-      def::DefTrait(_) |\n-      def::DefTy(..) |\n-      def::DefAssociatedTy(..) |\n-      def::DefAssociatedPath(..) |\n-      def::DefPrimTy(_) |\n-      def::DefTyParam(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type\");\n-      }\n-      def::DefMod(..) | def::DefForeignMod(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found module\");\n-      }\n-      def::DefUse(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found use\");\n-      }\n-      def::DefRegion(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found region\");\n-      }\n-      def::DefTyParamBinder(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type parameter\");\n-      }\n-      def::DefLabel(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found label\");\n-      }\n-      def::DefSelfTy(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found self ty\");\n-      }\n+        def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n+            let typ = fcx.local_ty(sp, nid);\n+            (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n+             ty::GenericPredicates::empty())\n+        }\n+        def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n+        def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n+        def::DefStruct(id) | def::DefConst(id) => {\n+            (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n+        }\n+        def::DefTrait(_) |\n+        def::DefTy(..) |\n+        def::DefAssociatedTy(..) |\n+        def::DefAssociatedPath(..) |\n+        def::DefPrimTy(_) |\n+        def::DefTyParam(..) |\n+        def::DefMod(..) |\n+        def::DefForeignMod(..) |\n+        def::DefUse(..) |\n+        def::DefRegion(..) |\n+        def::DefTyParamBinder(..) |\n+        def::DefLabel(..) |\n+        def::DefSelfTy(..) => {\n+            fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n+        }\n     }\n }\n \n@@ -4679,6 +4673,7 @@ pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   path: &ast::Path,\n                                   type_scheme: TypeScheme<'tcx>,\n+                                  type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: def::Def,\n                                   span: Span,\n@@ -4864,7 +4859,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Add all the obligations that are required, substituting and\n     // normalized appropriately.\n-    let bounds = fcx.instantiate_bounds(span, &substs, &type_scheme.generics);\n+    let bounds = fcx.instantiate_bounds(span, &substs, &type_predicates);\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def.def_id())),\n         &bounds);"}, {"sha": "bcb2ba6231df361520c26e9fd700f1924540cf8b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -1588,8 +1588,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // ```\n     //\n     // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n-    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    let trait_predicates = ty::lookup_predicates(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_predicates.predicates.as_slice().to_vec();\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             // we're only interesting in `T : 'a` style predicates:"}, {"sha": "94670305be7557edcb27a449161c37014b9edd00", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -107,12 +107,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 });\n             }\n             ast::ItemTrait(..) => {\n-                let trait_def =\n-                    ty::lookup_trait_def(ccx.tcx, local_def(item.id));\n+                let trait_predicates =\n+                    ty::lookup_predicates(ccx.tcx, local_def(item.id));\n                 reject_non_type_param_bounds(\n                     ccx.tcx,\n                     item.span,\n-                    &trait_def.generics);\n+                    &trait_predicates);\n             }\n             _ => {}\n         }\n@@ -124,11 +124,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n         let type_scheme = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        reject_non_type_param_bounds(ccx.tcx, item.span, &type_scheme.generics);\n+        let type_predicates = ty::lookup_predicates(ccx.tcx, item_def_id);\n+        reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n                                                 item.span,\n                                                 &type_scheme.generics,\n+                                                &type_predicates,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n@@ -283,9 +285,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n // Reject any predicates that do not involve a type parameter.\n fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       span: Span,\n-                                      generics: &ty::Generics<'tcx>) {\n-\n-    for predicate in generics.predicates.iter() {\n+                                      predicates: &ty::GenericPredicates<'tcx>) {\n+    for predicate in predicates.predicates.iter() {\n         match predicate {\n             &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n                 let found_param = tr.input_types().iter()\n@@ -367,7 +368,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                         reject_non_type_param_bounds(\n                             self.ccx.tcx,\n                             method.span,\n-                            &ty_method.generics);\n+                            &ty_method.predicates);\n                         reject_shadowing_type_parameters(\n                             self.ccx.tcx,\n                             method.span,\n@@ -415,9 +416,11 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n     pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n-        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n+        let trait_predicates = ty::lookup_predicates(self.fcx.tcx(), trait_ref.def_id);\n \n-        let bounds = self.fcx.instantiate_bounds(self.span, trait_ref.substs, &trait_def.generics);\n+        let bounds = self.fcx.instantiate_bounds(self.span,\n+                                                 trait_ref.substs,\n+                                                 &trait_predicates);\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n@@ -482,8 +485,9 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::ty_struct(type_id, substs) |\n             ty::ty_enum(type_id, substs) => {\n-                let type_scheme = ty::lookup_item_type(self.fcx.tcx(), type_id);\n-                let bounds = self.fcx.instantiate_bounds(self.span, substs, &type_scheme.generics);\n+                let type_predicates = ty::lookup_predicates(self.fcx.tcx(), type_id);\n+                let bounds = self.fcx.instantiate_bounds(self.span, substs,\n+                                                         &type_predicates);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n@@ -603,10 +607,10 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .collect()\n }\n \n-fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n-                                     -> ty::GenericBounds<'tcx>\n+fn filter_to_trait_obligations<'tcx>(bounds: ty::InstantiatedPredicates<'tcx>)\n+                                     -> ty::InstantiatedPredicates<'tcx>\n {\n-    let mut result = ty::GenericBounds::empty();\n+    let mut result = ty::InstantiatedPredicates::empty();\n     for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n         match *predicate {\n             ty::Predicate::Trait(..) |"}, {"sha": "1542e74ff81672769a7fc68b8397bfe4f523b409", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -247,6 +247,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n+            tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n             tcx.impl_or_trait_items\n                .borrow_mut()\n                .insert(new_did, ty::MethodTraitItem(new_method_ty));\n@@ -555,6 +556,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n            combined_substs.repr(tcx));\n \n+    let method_predicates = method.predicates.subst(tcx, &combined_substs);\n     let mut method_generics = method.generics.subst(tcx, &combined_substs);\n \n     // replace the type parameters declared on the trait with those\n@@ -579,6 +581,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     ty::Method::new(\n         method.name,\n         method_generics,\n+        method_predicates,\n         method_fty,\n         method.explicit_self,\n         method.vis,"}, {"sha": "8a1945c16a6aa37c31326d41df123ef7fe37b952", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 555, "deletions": 361, "changes": 916, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -20,28 +20,83 @@ current crate: we assume that after the collect phase, the types of\n all local items will be present in the table.\n \n Unlike most of the types that are present in Rust, the types computed\n-for each item are in fact polytypes.  In \"layman's terms\", this means\n-that they are generic types that may have type parameters (more\n-mathematically phrased, they are universally quantified over a set of\n-type parameters).  TypeSchemes are represented by an instance of\n-`ty::TypeScheme`.  This combines the core type along with a list of the\n-bounds for each parameter.  Type parameters themselves are represented\n-as `ty_param()` instances.\n+for each item are in fact type schemes. This means that they are\n+generic types that may have type parameters. TypeSchemes are\n+represented by an instance of `ty::TypeScheme`.  This combines the\n+core type along with a list of the bounds for each parameter. Type\n+parameters themselves are represented as `ty_param()` instances.\n+\n+The phasing of type conversion is somewhat complicated. There are a\n+number of possible cycles that can arise.\n+\n+Converting types can require:\n+\n+1. `Foo<X>` where `Foo` is a type alias, or trait requires knowing:\n+   - number of region / type parameters\n+   - for type parameters, `T:'a` annotations to control defaults for object lifetimes\n+   - defaults for type parameters (which are themselves types!)\n+2. `Foo<X>` where `Foo` is a type alias requires knowing what `Foo` expands to\n+3. Translating `SomeTrait` with no explicit lifetime bound requires knowing\n+   - supertraits of `SomeTrait`\n+4. Translating `T::X` (vs `<T as Trait>::X`) requires knowing\n+   - bounds on `T`\n+   - supertraits of those bounds\n+\n+So as you can see, in general translating types requires knowing the\n+trait hierarchy. But this gets a bit tricky because translating the\n+trait hierarchy requires converting the types that appear in trait\n+references. One potential saving grace is that in general knowing the\n+trait hierarchy is only necessary for shorthands like `T::X` or\n+handling omitted lifetime bounds on object types. Therefore, if we are\n+lazy about expanding out the trait hierachy, users can sever cycles if\n+necessary. Lazy expansion is also needed for type aliases.\n+\n+This system is not perfect yet. Currently, we \"convert\" types and\n+traits in three phases (note that conversion only affects the types of\n+items / enum variants / methods; it does not e.g. compute the types of\n+individual expressions):\n+\n+0. Intrinsics\n+1. Trait definitions\n+2. Type definitions\n+\n+Conversion itself is done by simply walking each of the items in turn\n+and invoking an appropriate function (e.g., `trait_def_of_item` or\n+`convert_item`). However, it is possible that while converting an\n+item, we may need to compute the *type scheme* or *trait definition*\n+for other items. This is a kind of shallow conversion that is\n+triggered on demand by calls to `AstConv::get_item_type_scheme` or\n+`AstConv::lookup_trait_def`. It is possible for cycles to result from\n+this (e.g., `type A = B; type B = A;`), in which case astconv\n+(currently) reports the error.\n+\n+There are some shortcomings in this design:\n+\n+- Cycles through trait definitions (e.g. supertraits) are not currently\n+  detected by astconv. (#12511)\n+- Because the type scheme includes defaults, cycles through type\n+  parameter defaults are illegal even if those defaults are never\n+  employed. This is not necessarily a bug.\n+- The phasing of trait definitions before type definitions does not\n+  seem to be necessary, sufficient, or particularly helpful, given that\n+  processing a trait definition can trigger processing a type def and\n+  vice versa. However, if I remove it, I get ICEs, so some more work is\n+  needed in that area. -nmatsakis\n \n */\n+\n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n-use metadata::csearch;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n-use middle::subst::{Substs, TypeSpace};\n+use middle::subst::{Substs, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n-use no_params;\n use rscope::*;\n+use util::common::memoized;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n@@ -130,11 +185,11 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        convert(self.ccx, i);\n+        convert_item(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        convert_foreign(self.ccx, i);\n+        convert_foreign_item(self.ccx, i);\n         visit::walk_foreign_item(self, i);\n     }\n }\n@@ -157,16 +212,16 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n \n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n-            return csearch::get_type(self.tcx, id)\n+            return ty::lookup_item_type(self.tcx, id);\n         }\n \n         match self.tcx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n-                ty_of_item(self, &*item)\n+                type_scheme_of_item(self, &*item)\n             }\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n-                ty_of_foreign_item(self, &*foreign_item, abi)\n+                type_scheme_of_foreign_item(self, &*foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(&format!(\"unexpected sort of node \\\n@@ -181,7 +236,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        span_err!(self.tcx.sess, span, E0121,\n+        span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n         self.tcx().types.err\n     }\n@@ -192,14 +247,14 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        ty::mk_projection(self.tcx, trait_ref, item_name)\n+        ty::mk_projection(self.tcx(), trait_ref, item_name)\n     }\n }\n \n fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                        enum_ty: Ty<'tcx>,\n-                                        variants: &[P<ast::Variant>],\n-                                        generics: &ast::Generics) {\n+                                    enum_scheme: ty::TypeScheme<'tcx>,\n+                                    enum_predicates: ty::GenericPredicates<'tcx>,\n+                                    variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -212,38 +267,35 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n-                enum_ty\n+                enum_scheme.ty\n             }\n \n             ast::StructVariantKind(ref struct_def) => {\n-                let scheme = TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(ccx, generics),\n-                    ty: enum_ty\n-                };\n-\n-                convert_struct(ccx, &**struct_def, scheme, variant.node.id);\n-                enum_ty\n+                convert_struct(ccx, &**struct_def, enum_scheme.clone(),\n+                               enum_predicates.clone(), variant.node.id);\n+                enum_scheme.ty\n             }\n         };\n \n-        let scheme = TypeScheme {\n-            generics: ty_generics_for_type_or_impl(ccx, generics),\n+        let variant_scheme = TypeScheme {\n+            generics: enum_scheme.generics.clone(),\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(variant_def_id, scheme);\n-\n+        tcx.tcache.borrow_mut().insert(variant_def_id, variant_scheme.clone());\n+        tcx.predicates.borrow_mut().insert(variant_def_id, enum_predicates.clone());\n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n }\n \n fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n-                                   trait_def: &ty::TraitDef<'tcx>) {\n+                                   trait_def: &ty::TraitDef<'tcx>,\n+                                   trait_predicates: &ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n     if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n         if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n@@ -259,6 +311,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n+                                    &trait_predicates,\n                                     &trait_items[],\n                                     &m.id,\n                                     &m.ident.name,\n@@ -273,6 +326,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n+                                    &trait_predicates,\n                                     &trait_items[],\n                                     &m.id,\n                                     &m.pe_ident().name,\n@@ -342,12 +396,17 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             m.def_id,\n             TypeScheme {\n                 generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone()))\n+            });\n+        ccx.tcx.predicates.borrow_mut().insert(\n+            m.def_id,\n+            m.predicates.clone());\n     }\n \n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n+                                           trait_bounds: &ty::GenericPredicates<'tcx>,\n                                            _trait_items: &[ast::TraitItem],\n                                            m_id: &ast::NodeId,\n                                            m_name: &ast::Name,\n@@ -358,10 +417,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            m_decl: &ast::FnDecl)\n                                            -> ty::Method<'tcx> {\n         let ty_generics =\n-            ty_generics_for_fn_or_method(\n-                ccx,\n-                m_generics,\n-                (*trait_generics).clone());\n+            ty_generics_for_fn_or_method(ccx,\n+                                         m_generics,\n+                                         trait_generics.clone());\n+\n+        let ty_bounds =\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               m_generics,\n+                                               &ty_generics,\n+                                               trait_bounds.clone());\n \n         let (fty, explicit_self_category) = {\n             let trait_self_ty = ty::mk_self_type(ccx.tcx);\n@@ -376,6 +440,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ty::Method::new(\n             *m_name,\n             ty_generics,\n+            ty_bounds,\n             fty,\n             explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n@@ -389,16 +454,20 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_generics: &ty::Generics<'tcx>,\n+                                struct_predicates: &ty::GenericPredicates<'tcx>,\n                                 v: &ast::StructField,\n                                 origin: ast::DefId) -> ty::field_ty {\n     let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n+\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n                                        ty::TypeScheme {\n                                            generics: struct_generics.clone(),\n                                            ty: tt\n                                        });\n+    ccx.tcx.predicates.borrow_mut().insert(local_def(v.node.id),\n+                                           struct_predicates.clone());\n \n     match v.node.kind {\n         ast::NamedField(ident, visibility) => {\n@@ -442,6 +511,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n+                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<Item=&'i ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n@@ -456,11 +526,13 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n \n         let m_def_id = local_def(m.id);\n+\n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n+                                       rcvr_ty_predicates,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n         debug!(\"method {} (id {}) has type {}\",\n@@ -473,6 +545,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                 generics: mty.generics.clone(),\n                 ty: fty\n             });\n+        tcx.predicates.borrow_mut().insert(m_def_id, mty.predicates.clone());\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n@@ -489,13 +562,19 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n                               rcvr_ty_generics: &ty::Generics<'tcx>,\n+                              rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                               rcvr_visibility: ast::Visibility)\n                               -> ty::Method<'tcx> {\n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(\n-                ccx,\n-                m.pe_generics(),\n-                (*rcvr_ty_generics).clone());\n+            ty_generics_for_fn_or_method(ccx,\n+                                         m.pe_generics(),\n+                                         rcvr_ty_generics.clone());\n+\n+        let m_ty_bounds =\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               m.pe_generics(),\n+                                               &m_ty_generics,\n+                                               rcvr_ty_predicates.clone());\n \n         let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n                                                                   m.pe_unsafety(),\n@@ -512,6 +591,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n \n         ty::Method::new(m.pe_ident().name,\n                         m_ty_generics,\n+                        m_ty_bounds,\n                         fty,\n                         explicit_self_category,\n                         method_vis,\n@@ -550,39 +630,43 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n     }\n }\n \n-fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n+fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n         ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-        ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n-        ast::ItemEnum(ref enum_definition, ref generics) => {\n-            let scheme = ty_of_item(ccx, it);\n+        ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {\n+        }\n+        ast::ItemEnum(ref enum_definition, _) => {\n+            let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             get_enum_variant_types(ccx,\n-                                   scheme.ty,\n-                                   &enum_definition.variants,\n-                                   generics);\n+                                   scheme,\n+                                   predicates,\n+                                   &enum_definition.variants);\n         },\n         ast::ItemImpl(_, _,\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n+\n+            debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            let ty_predicates = ty_generic_bounds_for_type_or_impl(ccx, &ty_generics, generics);\n+\n+            debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.tcache\n-               .borrow_mut()\n-               .insert(local_def(it.id),\n-                       TypeScheme {\n-                        generics: ty_generics.clone(),\n-                        ty: selfty,\n-                       });\n+            tcx.tcache.borrow_mut().insert(local_def(it.id),\n+                                           TypeScheme { generics: ty_generics.clone(),\n+                                                        ty: selfty });\n+            tcx.predicates.borrow_mut().insert(local_def(it.id),\n+                                               ty_predicates.clone());\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -614,14 +698,14 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                         }\n \n                         let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n-                        tcx.tcache\n-                           .borrow_mut()\n-                           .insert(local_def(typedef.id),\n-                                   TypeScheme {\n-                                    generics: ty::Generics::empty(),\n-                                    ty: typ,\n-                                   });\n-                        write_ty_to_tcx(ccx.tcx, typedef.id, typ);\n+                        tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n+                                                       TypeScheme {\n+                                                           generics: ty::Generics::empty(),\n+                                                           ty: typ,\n+                                                       });\n+                        tcx.predicates.borrow_mut().insert(local_def(typedef.id),\n+                                                           ty::GenericPredicates::empty());\n+                        write_ty_to_tcx(tcx, typedef.id, typ);\n \n                         let associated_type = Rc::new(ty::AssociatedType {\n                             name: typedef.ident.name,\n@@ -642,6 +726,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n+                            &ty_predicates,\n                             parent_visibility);\n \n             if let Some(ref trait_ref) = *opt_trait_ref {\n@@ -652,16 +737,16 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                                                None);\n             }\n \n-            enforce_impl_ty_params_are_constrained(ccx.tcx,\n+            enforce_impl_ty_params_are_constrained(tcx,\n                                                    generics,\n                                                    local_def(it.id));\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n+            convert_trait_predicates(ccx, it);\n+            let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n-            debug!(\"trait_def: ident={} trait_def={}\",\n-                   it.ident.repr(ccx.tcx),\n-                   trait_def.repr(ccx.tcx));\n+            debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n             for trait_method in trait_methods {\n                 let self_type = ty::mk_self_type(tcx);\n@@ -700,47 +785,46 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             }),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n+                            &trait_predicates,\n                             it.vis);\n \n             // We need to do this *after* converting methods, since\n             // convert_methods produces a tcache entry that is wrong for\n             // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def);\n+            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n-            let scheme = ty_of_item(ccx, it);\n+            let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-\n-            convert_struct(ccx, &**struct_def, scheme, it.id);\n+            convert_struct(ccx, &**struct_def, scheme, predicates, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let (scheme, _) = convert_typed_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n         _ => {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let scheme = ty_of_item(ccx, it);\n+            let (scheme, _) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n     }\n }\n \n fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                struct_def: &ast::StructDef,\n-                                scheme: ty::TypeScheme<'tcx>,\n-                                id: ast::NodeId) {\n+                            struct_def: &ast::StructDef,\n+                            scheme: ty::TypeScheme<'tcx>,\n+                            predicates: ty::GenericPredicates<'tcx>,\n+                            id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &scheme.generics, f, local_def(id));\n+        let result = convert_field(ccx, &scheme.generics, &predicates, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.get(&result.name) {\n@@ -778,6 +862,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id), scheme);\n+                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n@@ -789,44 +874,30 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                  TypeScheme {\n-                    generics: scheme.generics,\n-                    ty: ctor_fn_ty\n-                });\n+                                               TypeScheme {\n+                                                   generics: scheme.generics,\n+                                                   ty: ctor_fn_ty\n+                                               });\n+                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             }\n         }\n     }\n }\n \n-fn convert_foreign(ccx: &CollectCtxt, i: &ast::ForeignItem) {\n-    // As above, this call populates the type table with the converted\n-    // type of the foreign item. We simply write it into the node type\n-    // table.\n-\n-    // For reasons I cannot fully articulate, I do so hate the AST\n-    // map, and I regard each time that I use it as a personal and\n-    // moral failing, but at the moment it seems like the only\n-    // convenient way to extract the ABI. - ndm\n-    let abi = ccx.tcx.map.get_foreign_abi(i.id);\n-\n-    let scheme = ty_of_foreign_item(ccx, i, abi);\n-    write_ty_to_tcx(ccx.tcx, i.id, scheme.ty);\n-\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n-}\n-\n fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n+    let tcx = ccx.tcx;\n+\n     if trait_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_trait_def(ccx.tcx, trait_id)\n+        return ty::lookup_trait_def(tcx, trait_id)\n     }\n \n-    match ccx.tcx.map.get(trait_id.node) {\n+    match tcx.map.get(trait_id.node) {\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n-            ccx.tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node)[])\n+            tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n+                                  trait_id.node)[])\n         }\n     }\n }\n@@ -837,6 +908,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n+\n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n         return def.clone();\n     }\n@@ -868,16 +940,13 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n \n-    let ty_generics = ty_generics_for_trait(ccx,\n-                                            it.id,\n-                                            substs,\n-                                            generics,\n-                                            items);\n+    let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let self_param_ty = ty::ParamTy::for_self();\n+    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n \n+    // supertraits:\n     let bounds = compute_bounds(ccx,\n-                                self_param_ty.to_ty(ccx.tcx),\n+                                self_param_ty,\n                                 bounds,\n                                 SizedByDefault::No,\n                                 it.span);\n@@ -890,11 +959,11 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                      ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n                  }\n              })\n-            .collect();\n+             .collect();\n \n     let trait_ref = Rc::new(ty::TraitRef {\n         def_id: def_id,\n-        substs: substs\n+        substs: substs,\n     });\n \n     let trait_def = Rc::new(ty::TraitDef {\n@@ -905,6 +974,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n     });\n+\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n \n     return trait_def;\n@@ -913,6 +983,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n+        let tcx = ccx.tcx;\n+\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -929,137 +1001,293 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n+                    .map(|(i, def)| ty::mk_param(tcx, subst::TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n-        let self_ty = ty::mk_self_type(ccx.tcx);\n+        let self_ty = ty::mk_self_type(tcx);\n \n         subst::Substs::new_trait(types, regions, self_ty)\n     }\n }\n \n-fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n-                            -> ty::TypeScheme<'tcx> {\n-    let def_id = local_def(it.id);\n+fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item) {\n     let tcx = ccx.tcx;\n-    if let Some(scheme) = tcx.tcache.borrow().get(&def_id) {\n-        return scheme.clone();\n+    let trait_def = trait_def_of_item(ccx, it);\n+\n+    let def_id = local_def(it.id);\n+\n+    let (generics, items) = match it.node {\n+        ast::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n+        ref s => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+        }\n+    };\n+\n+    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n+\n+    let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n+\n+    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.trait_ref, items);\n+\n+    // `ty_generic_bounds` below will consider the bounds on the type\n+    // parameters (including `Self`) and the explicit where-clauses,\n+    // but to get the full set of predicates on a trait we need to add\n+    // in the supertrait bounds and anything declared on the\n+    // associated types.\n+    let mut base_predicates =\n+        ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n+        };\n+    base_predicates.predicates.extend(subst::TypeSpace, assoc_predicates.into_iter());\n+\n+    let self_bounds = &trait_def.generics.types.get_self().unwrap().bounds;\n+    base_predicates.predicates.extend(\n+        subst::SelfSpace,\n+        ty::predicates(ccx.tcx, self_param_ty, self_bounds).into_iter());\n+\n+    // add in the explicit where-clauses\n+    let trait_predicates =\n+        ty_generic_bounds(ccx,\n+                          subst::TypeSpace,\n+                          &trait_def.generics,\n+                          base_predicates,\n+                          &generics.where_clause);\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n+    assert!(prev_predicates.is_none());\n+\n+    return;\n+\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 trait_items: &[ast::TraitItem])\n+                                                 -> Vec<ty::Predicate<'tcx>>\n+    {\n+        trait_items\n+            .iter()\n+            .flat_map(|trait_item| {\n+                let assoc_type_def = match *trait_item {\n+                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n+                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                        return vec!().into_iter();\n+                    }\n+                };\n+\n+                let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                                 self_trait_ref.clone(),\n+                                                 assoc_type_def.ident.name);\n+\n+                let bounds = compute_bounds(ccx,\n+                                            assoc_ty,\n+                                            &*assoc_type_def.bounds,\n+                                            SizedByDefault::Yes,\n+                                            assoc_type_def.span);\n+\n+                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+            })\n+            .collect()\n     }\n+}\n+\n+fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                it: &ast::Item)\n+                                -> ty::TypeScheme<'tcx>\n+{\n+    memoized(&ccx.tcx.tcache,\n+             local_def(it.id),\n+             |_| compute_type_scheme_of_item(ccx, it))\n+}\n+\n+\n+fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                              it: &ast::Item)\n+                                              -> ty::TypeScheme<'tcx>\n+{\n+    let tcx = ccx.tcx;\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, &**t);\n-            let scheme = no_params(typ);\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx,\n                                                            generics,\n                                                            ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n-            };\n-            debug!(\"type of {} (id {}) is {}\",\n-                    token::get_ident(it.ident),\n-                    it.id,\n-                    scheme.repr(tcx));\n-\n-            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n+            ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n-                Some(scheme) => return scheme.clone(),\n-                None => { }\n-            }\n-\n-            let scheme = {\n-                let ty = ccx.to_ty(&ExplicitRscope, &**t);\n-                TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(ccx, generics),\n-                    ty: ty\n-                }\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: t\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n-        }\n-        ast::ItemTrait(..) => {\n-            tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n+            ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: t\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            ty::TypeScheme { ty: t, generics: ty_generics }\n+        }\n+        ast::ItemTrait(..) |\n+        ast::ItemImpl(..) |\n+        ast::ItemMod(..) |\n+        ast::ItemForeignMod(..) |\n+        ast::ItemExternCrate(..) |\n+        ast::ItemUse(..) |\n+        ast::ItemMac(..) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                        it.node).as_slice());\n         }\n-        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-        ast::ItemImpl(..) | ast::ItemMod(_) |\n-        ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }\n }\n \n-fn ty_of_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                    it: &ast::ForeignItem,\n-                                    abi: abi::Abi) -> ty::TypeScheme<'tcx>\n+fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                it: &ast::Item)\n+                                -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n+{\n+    let tcx = ccx.tcx;\n+\n+    let tag = type_scheme_of_item(ccx, it);\n+    let scheme = TypeScheme { generics: tag.generics, ty: tag.ty };\n+    let predicates = match it.node {\n+        ast::ItemStatic(..) | ast::ItemConst(..) => {\n+            ty::GenericPredicates::empty()\n+        }\n+        ast::ItemFn(_, _, _, ref ast_generics, _) => {\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               ast_generics,\n+                                               &scheme.generics,\n+                                               ty::GenericPredicates::empty())\n+        }\n+        ast::ItemTy(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemEnum(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemStruct(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemTrait(..) |\n+        ast::ItemExternCrate(..) |\n+        ast::ItemUse(..) |\n+        ast::ItemImpl(..) |\n+        ast::ItemMod(..) |\n+        ast::ItemForeignMod(..) |\n+        ast::ItemMac(..) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                        it.node).as_slice());\n+        }\n+    };\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id),\n+                                                             predicates.clone());\n+    assert!(prev_predicates.is_none());\n+\n+    return (scheme, predicates);\n+\n+}\n+\n+fn type_scheme_of_foreign_item<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    it: &ast::ForeignItem,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n+{\n+    memoized(&ccx.tcx().tcache,\n+             local_def(it.id),\n+             |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n+}\n+\n+fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    it: &ast::ForeignItem,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n-            ty_of_foreign_fn_decl(ccx,\n-                                  &**fn_decl,\n-                                  local_def(it.id),\n-                                  generics,\n-                                  abi)\n+            compute_type_scheme_of_foreign_fn_decl(ccx, fn_decl, generics, abi)\n         }\n         ast::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n+fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                  it: &ast::ForeignItem)\n+{\n+    // For reasons I cannot fully articulate, I do so hate the AST\n+    // map, and I regard each time that I use it as a personal and\n+    // moral failing, but at the moment it seems like the only\n+    // convenient way to extract the ABI. - ndm\n+    let tcx = ccx.tcx;\n+    let abi = tcx.map.get_foreign_abi(it.id);\n+\n+    let scheme = type_scheme_of_foreign_item(ccx, it, abi);\n+    write_ty_to_tcx(ccx.tcx, it.id, scheme.ty);\n+\n+    let predicates = match it.node {\n+        ast::ForeignItemFn(_, ref generics) => {\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               generics,\n+                                               &scheme.generics,\n+                                               ty::GenericPredicates::empty())\n+        }\n+        ast::ForeignItemStatic(..) => {\n+            ty::GenericPredicates::empty()\n+        }\n+    };\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id), predicates);\n+    assert!(prev_predicates.is_none());\n+}\n+\n fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 &generics.lifetimes[],\n                 &generics.ty_params[],\n-                ty::Generics::empty(),\n-                &generics.where_clause)\n+                ty::Generics::empty())\n+}\n+\n+fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                               ty_generics: &ty::Generics<'tcx>,\n+                                               generics: &ast::Generics)\n+                                               -> ty::GenericPredicates<'tcx>\n+{\n+    ty_generic_bounds(ccx,\n+                      subst::TypeSpace,\n+                      ty_generics,\n+                      ty::GenericPredicates::empty(),\n+                      &generics.where_clause)\n }\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n-                                   ast_generics: &ast::Generics,\n-                                   trait_items: &[ast::TraitItem])\n+                                   ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n@@ -1070,8 +1298,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                     subst::TypeSpace,\n                     &ast_generics.lifetimes[],\n                     &ast_generics.ty_params[],\n-                    ty::Generics::empty(),\n-                    &ast_generics.where_clause);\n+                    ty::Generics::empty());\n \n     // Add in the self type parameter.\n     //\n@@ -1101,49 +1328,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     generics.types.push(subst::SelfSpace, def);\n \n-    generics.predicates.push(subst::SelfSpace, self_trait_ref.as_predicate());\n-\n-    let assoc_predicates = predicates_for_associated_types(ccx,\n-                                                           &self_trait_ref,\n-                                                           trait_items);\n-\n-    debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n-\n-    for assoc_predicate in assoc_predicates {\n-        generics.predicates.push(subst::TypeSpace, assoc_predicate);\n-    }\n-\n     return generics;\n-\n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n-                                                 trait_items: &[ast::TraitItem])\n-                                                 -> Vec<ty::Predicate<'tcx>>\n-    {\n-        trait_items\n-            .iter()\n-            .flat_map(|trait_item| {\n-                let assoc_type_def = match *trait_item {\n-                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n-                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n-                        return vec!().into_iter();\n-                    }\n-                };\n-\n-                let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                                 self_trait_ref.clone(),\n-                                                 assoc_type_def.ident.name);\n-\n-                let bounds = compute_bounds(ccx,\n-                                            assoc_ty,\n-                                            &*assoc_type_def.bounds,\n-                                            SizedByDefault::Yes,\n-                                            assoc_type_def.span);\n-\n-                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n-            })\n-            .collect()\n-    }\n }\n \n fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n@@ -1156,8 +1341,20 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 subst::FnSpace,\n                 &early_lifetimes[],\n                 &generics.ty_params[],\n-                base_generics,\n-                &generics.where_clause)\n+                base_generics)\n+}\n+\n+fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                               generics: &ast::Generics,\n+                                               ty_generics: &ty::Generics<'tcx>,\n+                                               base: ty::GenericPredicates<'tcx>)\n+                                               -> ty::GenericPredicates<'tcx>\n+{\n+    ty_generic_bounds(ccx,\n+                      subst::FnSpace,\n+                      ty_generics,\n+                      base,\n+                      &generics.where_clause)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n@@ -1207,47 +1404,29 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                        space: subst::ParamSpace,\n-                        lifetime_defs: &[ast::LifetimeDef],\n-                        types: &[ast::TyParam],\n-                        base_generics: ty::Generics<'tcx>,\n-                        where_clause: &ast::WhereClause)\n-                        -> ty::Generics<'tcx>\n+fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                              space: subst::ParamSpace,\n+                              generics: &ty::Generics<'tcx>,\n+                              base: ty::GenericPredicates<'tcx>,\n+                              where_clause: &ast::WhereClause)\n+                              -> ty::GenericPredicates<'tcx>\n {\n-    let mut result = base_generics;\n-\n-    for (i, l) in lifetime_defs.iter().enumerate() {\n-        let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(ccx.tcx, l))\n-                             .collect();\n-        let def = ty::RegionParameterDef { name: l.lifetime.name,\n-                                           space: space,\n-                                           index: i as u32,\n-                                           def_id: local_def(l.lifetime.id),\n-                                           bounds: bounds };\n-        debug!(\"ty_generics: def for region param: {:?}\", def);\n-        result.regions.push(space, def);\n+    let tcx = ccx.tcx;\n+    let mut result = base;\n+\n+    // For now, scrape the bounds out of parameters from Generics. This is not great.\n+    for def in generics.regions.get_slice(space) {\n+        let r_a = def.to_early_bound_region();\n+        for &r_b in &def.bounds {\n+            let outlives = ty::Binder(ty::OutlivesPredicate(r_a, r_b));\n+            result.predicates.push(def.space, ty::Predicate::RegionOutlives(outlives));\n+        }\n     }\n-\n-    assert!(result.types.is_empty_in(space));\n-\n-    // Now create the real type parameters.\n-    for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx,\n-                                                   space,\n-                                                   param,\n-                                                   i as u32);\n-        debug!(\"ty_generics: def for type param: {}, {:?}\",\n-               def.repr(ccx.tcx),\n-               space);\n-        result.types.push(space, def);\n+    for def in generics.types.get_slice(space) {\n+        let t = ty::mk_param_from_def(ccx.tcx, def);\n+        result.predicates.extend(def.space, ty::predicates(ccx.tcx, t, &def.bounds).into_iter());\n     }\n \n-    // Just for fun, also push the bounds from the type parameters\n-    // into the predicates list. This is currently kind of non-DRY.\n-    create_predicates(ccx.tcx, &mut result, space);\n-\n     // Add the bounds not associated with a type parameter\n     for predicate in &where_clause.predicates {\n         match predicate {\n@@ -1275,7 +1454,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(ccx.tcx, lifetime);\n+                            let region = ast_region_to_region(tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1284,49 +1463,60 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             }\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n+                let r1 = ast_region_to_region(tcx, &region_pred.lifetime);\n                 for bound in &region_pred.bounds {\n-                    let r2 = ast_region_to_region(ccx.tcx, bound);\n+                    let r2 = ast_region_to_region(tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n             &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                ccx.tcx.sess.span_bug(eq_pred.span,\n-                                         \"Equality constraints are not yet \\\n-                                            implemented (#20041)\")\n+                tcx.sess.span_bug(eq_pred.span,\n+                                    \"Equality constraints are not yet \\\n+                                        implemented (#20041)\")\n             }\n         }\n     }\n \n     return result;\n+}\n \n-    fn create_predicates<'tcx>(\n-        tcx: &ty::ctxt<'tcx>,\n-        result: &mut ty::Generics<'tcx>,\n-        space: subst::ParamSpace)\n-    {\n-        for type_param_def in result.types.get_slice(space) {\n-            let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n-            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds) {\n-                result.predicates.push(space, predicate);\n-            }\n-        }\n+fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                        space: subst::ParamSpace,\n+                        lifetime_defs: &[ast::LifetimeDef],\n+                        types: &[ast::TyParam],\n+                        base_generics: ty::Generics<'tcx>)\n+                        -> ty::Generics<'tcx>\n+{\n+    let tcx = ccx.tcx;\n+    let mut result = base_generics;\n \n-        for region_param_def in result.regions.get_slice(space) {\n-            let region = region_param_def.to_early_bound_region();\n-            for &bound_region in &region_param_def.bounds {\n-                // account for new binder introduced in the predicate below; no need\n-                // to shift `region` because it is never a late-bound region\n-                let bound_region = ty_fold::shift_region(bound_region, 1);\n-                result.predicates.push(\n-                    space,\n-                    ty::Binder(ty::OutlivesPredicate(region, bound_region)).as_predicate());\n-            }\n-        }\n+    for (i, l) in lifetime_defs.iter().enumerate() {\n+        let bounds = l.bounds.iter()\n+                             .map(|l| ast_region_to_region(tcx, l))\n+                             .collect();\n+        let def = ty::RegionParameterDef { name: l.lifetime.name,\n+                                           space: space,\n+                                           index: i as u32,\n+                                           def_id: local_def(l.lifetime.id),\n+                                           bounds: bounds };\n+        // debug!(\"ty_generics: def for region param: {:?}\",\n+        //        def.repr(tcx));\n+        result.regions.push(space, def);\n+    }\n+\n+    assert!(result.types.is_empty_in(space));\n+\n+    // Now create the real type parameters.\n+    for (i, param) in types.iter().enumerate() {\n+        let def = get_or_create_type_parameter_def(ccx, space, param, i as u32);\n+        debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n+        result.types.push(space, def);\n     }\n+\n+    result\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n@@ -1335,8 +1525,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                              index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n-    match ccx.tcx.ty_param_defs.borrow().get(&param.id) {\n-        Some(d) => { return (*d).clone(); }\n+    let tcx = ccx.tcx;\n+    match tcx.ty_param_defs.borrow().get(&param.id) {\n+        Some(d) => { return d.clone(); }\n         None => { }\n     }\n \n@@ -1355,9 +1546,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             ty::walk_ty(ty, |t| {\n                 match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n-                        span_err!(ccx.tcx.sess, path.span, E0128,\n+                        span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n-                                   forward declared identifiers\");\n+                                  forward declared identifiers\");\n                         },\n                         _ => {}\n                     }\n@@ -1376,7 +1567,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n         default: default\n     };\n \n-    ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     def\n }\n@@ -1404,7 +1595,7 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(ccx.tcx,\n+        check_bounds_compatible(ccx,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1415,24 +1606,22 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     param_bounds\n }\n \n-fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 param_ty: Ty<'tcx>,\n-                                 param_bounds: &ty::ParamBounds<'tcx>,\n-                                 span: Span) {\n-    // Currently the only bound which is incompatible with other bounds is\n-    // Sized/Unsized.\n+fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                    param_ty: Ty<'tcx>,\n+                                    param_bounds: &ty::ParamBounds<'tcx>,\n+                                    span: Span) {\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n-            tcx,\n+            ccx.tcx,\n             &param_bounds.trait_bounds[],\n             |trait_ref| {\n-                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n+                let trait_def = ccx.get_trait_def(trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                    span_err!(tcx.sess, span, E0129,\n+                    span_err!(ccx.tcx.sess, span, E0129,\n                               \"incompatible bounds on `{}`, \\\n                                bound `{}` does not allow unsized type\",\n-                              param_ty.user_string(tcx),\n-                              trait_ref.user_string(tcx));\n+                              param_ty.user_string(ccx.tcx),\n+                              trait_ref.user_string(ccx.tcx));\n                 }\n                 true\n             });\n@@ -1445,10 +1634,12 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n {\n-    let astconv::PartitionedBounds { builtin_bounds,\n-                                     trait_bounds,\n-                                     region_bounds } =\n-        astconv::partition_bounds(ccx.tcx, span, ast_bounds);\n+    let tcx = ccx.tcx;\n+    let astconv::PartitionedBounds {\n+        builtin_bounds,\n+        trait_bounds,\n+        region_bounds\n+    } = astconv::partition_bounds(tcx, span, ast_bounds.as_slice());\n \n     let mut projection_bounds = Vec::new();\n \n@@ -1461,11 +1652,13 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                                 Some(param_ty),\n                                                 &mut projection_bounds)\n         })\n-        .collect();\n+    .collect();\n+\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-        .map(|r| ast_region_to_region(ccx.tcx, r))\n-        .collect();\n+                     .map(|r| ast_region_to_region(ccx.tcx, r))\n+                     .collect();\n+\n     ty::ParamBounds {\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n@@ -1474,13 +1667,14 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                       decl: &ast::FnDecl,\n-                                       def_id: ast::DefId,\n-                                       ast_generics: &ast::Generics,\n-                                       abi: abi::Abi)\n-                                       -> ty::TypeScheme<'tcx> {\n-    for i in &decl.inputs {\n+fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    decl: &ast::FnDecl,\n+    ast_generics: &ast::Generics,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n+{\n+    for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild(ast::PatWildSingle) => (),\n@@ -1491,9 +1685,8 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(ccx,\n-                                                                    ast_generics,\n-                                                                    ty::Generics::empty());\n+    let ty_generics = ty_generics_for_fn_or_method(ccx, ast_generics, ty::Generics::empty());\n+\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n@@ -1519,13 +1712,11 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        output: output,\n                                        variadic: decl.variadic}),\n         }));\n-    let scheme = TypeScheme {\n-        generics: ty_generics_for_fn_or_method,\n-        ty: t_fn\n-    };\n \n-    ccx.tcx.tcache.borrow_mut().insert(def_id, scheme.clone());\n-    return scheme;\n+    ty::TypeScheme {\n+        generics: ty_generics,\n+        ty: t_fn\n+    }\n }\n \n fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n@@ -1556,6 +1747,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n+    let tcx = ccx.tcx;\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n         let typ = ccx.to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n@@ -1573,35 +1765,36 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n             liberate_early_bound_regions(\n-                ccx.tcx, body_scope,\n+                tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    ccx.tcx, body_scope, &ty::Binder(required_type)));\n+                    tcx, body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n-                ccx.tcx, body_scope,\n+                tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    ccx.tcx, body_scope, &ty::Binder(base_type)));\n+                    tcx, body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n-               required_type.repr(ccx.tcx),\n-               required_type_free.repr(ccx.tcx),\n-               base_type.repr(ccx.tcx),\n-               base_type_free.repr(ccx.tcx));\n-        let infcx = infer::new_infer_ctxt(ccx.tcx);\n-        drop(::require_same_types(ccx.tcx,\n+               required_type.repr(tcx),\n+               required_type_free.repr(tcx),\n+               base_type.repr(tcx),\n+               base_type_free.repr(tcx));\n+\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,\n                                   explicit_self.span,\n                                   base_type_free,\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                        ppaux::ty_to_string(ccx.tcx, required_type))\n+                        ppaux::ty_to_string(tcx, required_type))\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }\n@@ -1639,6 +1832,7 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 impl_def_id: ast::DefId)\n {\n     let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n+    let impl_predicates = ty::lookup_predicates(tcx, impl_def_id);\n     let impl_trait_ref = ty::impl_trait_ref(tcx, impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n@@ -1656,18 +1850,18 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let num_inputs = input_parameters.len();\n \n         let projection_predicates =\n-            impl_scheme.generics.predicates\n-            .iter()\n-            .filter_map(|predicate| {\n-                match *predicate {\n-                    // Ignore higher-ranked binders. For the purposes\n-                    // of this check, they don't matter because they\n-                    // only affect named regions, and we're just\n-                    // concerned about type parameters here.\n-                    ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                    _ => None,\n-                }\n-            });\n+            impl_predicates.predicates\n+                           .iter()\n+                           .filter_map(|predicate| {\n+                               match *predicate {\n+                                   // Ignore higher-ranked binders. For the purposes\n+                                   // of this check, they don't matter because they\n+                                   // only affect named regions, and we're just\n+                                   // concerned about type parameters here.\n+                                   ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                                   _ => None,\n+                               }\n+                           });\n \n         for projection in projection_predicates {\n             // Special case: watch out for some kind of sneaky attempt"}, {"sha": "ccfadaba2440b2ad7578b41bf5c8019c7f1ac73a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -102,7 +102,6 @@ pub use rustc::util;\n use middle::def;\n use middle::infer;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use session::config;\n use util::common::time;\n@@ -177,17 +176,6 @@ fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-fn no_params<'tcx>(t: Ty<'tcx>) -> ty::TypeScheme<'tcx> {\n-    ty::TypeScheme {\n-        generics: ty::Generics {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-            predicates: VecPerParamSpace::empty(),\n-        },\n-        ty: t\n-    }\n-}\n-\n fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n                                    t1_is_expected: bool,"}, {"sha": "d1283d6f46bd842ed3a945f5ef3668df9af1e2d8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -166,10 +166,11 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n         unsafety: def.unsafety,\n-        generics: (&def.generics, subst::TypeSpace).clean(cx),\n+        generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n         bounds: bounds,\n     }\n@@ -181,9 +182,10 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n         ty::ty_bare_fn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety),\n         _ => panic!(\"bad function\"),\n     };\n+    let predicates = ty::lookup_predicates(tcx, did);\n     clean::Function {\n         decl: decl,\n-        generics: (&t.generics, subst::FnSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n         unsafety: style,\n     }\n }\n@@ -192,6 +194,7 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n     use syntax::parse::token::special_idents::unnamed_field;\n \n     let t = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let fields = ty::lookup_struct_fields(tcx, did);\n \n     clean::Struct {\n@@ -201,18 +204,19 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n         fields: fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     match t.ty.sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, subst::TypeSpace).clean(cx),\n+                generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n                 variants: ty::enum_variants(tcx, edid).clean(cx),\n             })\n@@ -222,7 +226,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(cx),\n-        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n     })\n }\n \n@@ -293,6 +297,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n \n     let attrs = load_attrs(cx, tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n             .filter_map(|did| {\n@@ -323,9 +328,10 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n                 let type_scheme = ty::lookup_item_type(tcx, did);\n+                let predicates = ty::lookup_predicates(tcx, did);\n                 // Not sure the choice of ParamSpace actually matters here, because an\n                 // associated type won't have generics on the LHS\n-                let typedef = (type_scheme, subst::ParamSpace::TypeSpace).clean(cx);\n+                let typedef = (type_scheme, predicates, subst::ParamSpace::TypeSpace).clean(cx);\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef),\n@@ -349,7 +355,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                 }\n             }),\n             for_: ty.ty.clean(cx),\n-            generics: (&ty.generics, subst::TypeSpace).clean(cx),\n+            generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),\n         }),"}, {"sha": "6c3d2d8fa19d1f213a436bd747f68f638ae606c5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -860,7 +860,9 @@ impl Clean<Generics> for ast::Generics {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n+impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n+                                    &'a ty::GenericPredicates<'tcx>,\n+                                    subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use std::collections::HashSet;\n         use syntax::ast::TraitBoundModifier as TBM;\n@@ -885,7 +887,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             false\n         }\n \n-        let (gens, space) = *self;\n+        let (gens, preds, space) = *self;\n+\n         // Bounds in the type_params and lifetimes fields are repeated in the predicates\n         // field (see rustc_typeck::collect::ty_generics), so remove them.\n         let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n@@ -899,7 +902,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             srp.clean(cx)\n         }).collect::<Vec<_>>();\n \n-        let where_predicates = gens.predicates.get_slice(space).to_vec().clean(cx);\n+        let where_predicates = preds.predicates.get_slice(space).to_vec().clean(cx);\n+\n         // Type parameters have a Sized bound by default unless removed with ?Sized.\n         // Scan through the predicates and mark any type parameter with a Sized\n         // bound, removing the bounds as we find them.\n@@ -913,6 +917,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             }\n             Some(pred)\n         }).collect::<Vec<_>>();\n+\n         // Finally, run through the type parameters again and insert a ?Sized unbound for\n         // any we didn't find to be Sized.\n         for tp in &stripped_typarams {\n@@ -1303,7 +1308,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 unsafety: self.fty.unsafety,\n-                generics: (&self.generics, subst::FnSpace).clean(cx),\n+                generics: (&self.generics, &self.predicates, subst::FnSpace).clean(cx),\n                 self_: self_,\n                 decl: (self.def_id, &sig).clean(cx),\n                 abi: self.fty.abi\n@@ -2560,12 +2565,12 @@ impl Clean<Item> for ast::Typedef {\n     }\n }\n \n-impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ParamSpace) {\n+impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>, ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Typedef {\n-        let (ref ty_scheme, ps) = *self;\n+        let (ref ty_scheme, ref predicates, ps) = *self;\n         Typedef {\n             type_: ty_scheme.ty.clean(cx),\n-            generics: (&ty_scheme.generics, ps).clean(cx)\n+            generics: (&ty_scheme.generics, predicates, ps).clean(cx)\n         }\n     }\n }"}, {"sha": "d6778be553e8b2ec3655853a51a862bb3a0cfc25", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -366,6 +366,14 @@ pub struct DefId {\n     pub node: NodeId,\n }\n \n+impl DefId {\n+    /// Read the node id, asserting that this def-id is krate-local.\n+    pub fn local_id(&self) -> NodeId {\n+        assert_eq!(self.krate, LOCAL_CRATE);\n+        self.node\n+    }\n+}\n+\n /// Item definitions in the currently-compiled crate would have the CrateNum\n /// LOCAL_CRATE in their DefId.\n pub const LOCAL_CRATE: CrateNum = 0;"}, {"sha": "a253fbde5633f112d400adf95e997a5149f1c36d", "filename": "src/test/run-pass/associated-types-issue-20220.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20220.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20220.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20220.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test references to `Self::Item` in the trait. Issue #20220.\n+\n+use std::vec;\n+\n+trait IntoIteratorX {\n+    type Item;\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    fn into_iter_x(self) -> Self::IntoIter;\n+}\n+\n+impl<T> IntoIteratorX for Vec<T> {\n+    type Item = T;\n+    type IntoIter = vec::IntoIter<T>;\n+\n+    fn into_iter_x(self) -> vec::IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+fn main() {\n+    let vec = vec![1, 2, 3];\n+    for (i, e) in vec.into_iter().enumerate() {\n+        assert_eq!(i+1, e);\n+    }\n+}"}, {"sha": "ef7fbe87b304744dd51ce8791b9783ae8433c48e", "filename": "src/test/run-pass/associated-types-stream.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fassociated-types-stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fassociated-types-stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-stream.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test references to the trait `Stream` in the bounds for associated\n+// types defined on `Stream`. Issue #20551.\n+\n+trait Stream {\n+    type Car;\n+    type Cdr: Stream;\n+\n+    fn car(&self) -> Self::Car;\n+    fn cdr(self) -> Self::Cdr;\n+}\n+\n+impl Stream for () {\n+    type Car = ();\n+    type Cdr = ();\n+    fn car(&self) -> () { () }\n+    fn cdr(self) -> () { self }\n+}\n+\n+impl<T,U> Stream for (T, U)\n+    where T : Clone, U : Stream\n+{\n+    type Car = T;\n+    type Cdr = U;\n+    fn car(&self) -> T { self.0.clone() }\n+    fn cdr(self) -> U { self.1 }\n+}\n+\n+fn main() {\n+    let p = (22, (44, (66, ())));\n+    assert_eq!(p.car(), 22);\n+\n+    let p = p.cdr();\n+    assert_eq!(p.car(), 44);\n+\n+    let p = p.cdr();\n+    assert_eq!(p.car(), 66);\n+}"}, {"sha": "0c6d91eda26af4ba9055beb05ea81b3da39c7d74", "filename": "src/test/run-pass/astconv-cycle-between-trait-and-type.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fastconv-cycle-between-trait-and-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b463f15328f448c13fa990f9fc8897e0af55c2/src%2Ftest%2Frun-pass%2Fastconv-cycle-between-trait-and-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fastconv-cycle-between-trait-and-type.rs?ref=39b463f15328f448c13fa990f9fc8897e0af55c2", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to successfully compile a setup where a trait\n+// (`Trait1`) references a struct (`SomeType<u32>`) which in turn\n+// carries a predicate that references the trait (`u32 : Trait1`,\n+// substituted).\n+\n+#![allow(dead_code)]\n+\n+trait Trait1 : Trait2<SomeType<u32>> {\n+    fn dumb(&self) { }\n+}\n+\n+trait Trait2<A> {\n+    fn dumber(&self, _: A) { }\n+}\n+\n+struct SomeType<A>\n+    where A : Trait1\n+{\n+    a: A\n+}\n+\n+impl Trait1 for u32 { }\n+\n+impl Trait2<SomeType<u32>> for u32 { }\n+\n+fn main() { }"}]}