{"sha": "999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OWEwMGJmNWU3MGFjMmJlMWFmMjFmZWIwMmVjOGFmMDJhNWQyZDM=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-07-04T13:32:55Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-07-04T13:32:55Z"}, "message": "address reviews", "tree": {"sha": "97eb59abb2a1fab9a71017b1b26243bd98bb8739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97eb59abb2a1fab9a71017b1b26243bd98bb8739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "html_url": "https://github.com/rust-lang/rust/commit/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4ec40346591755b5401bf95a048974542c43bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4ec40346591755b5401bf95a048974542c43bc", "html_url": "https://github.com/rust-lang/rust/commit/7c4ec40346591755b5401bf95a048974542c43bc"}], "stats": {"total": 75, "additions": 47, "deletions": 28}, "files": [{"sha": "98258189701594e827aaf48092e6cb7808788e8f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "patch": "@@ -365,7 +365,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box let_if_seq::LetIfSeq);\n     reg.register_late_lint_pass(box eval_order_dependence::EvalOrderDependence);\n     reg.register_late_lint_pass(box missing_doc::MissingDoc::new());\n-    reg.register_late_lint_pass(box missing_inline::MissingInline::new());\n+    reg.register_late_lint_pass(box missing_inline::MissingInline);\n     reg.register_late_lint_pass(box ok_if_let::Pass);\n     reg.register_late_lint_pass(box if_let_redundant_pattern_matching::Pass);\n     reg.register_late_lint_pass(box partialeq_ne_impl::Pass);"}, {"sha": "ba4c7678d6c17225ec94553526294519b1879f35", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999a00bf5e70ac2be1af21feb02ec8af02a5d2d3/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=999a00bf5e70ac2be1af21feb02ec8af02a5d2d3", "patch": "@@ -26,32 +26,50 @@ use syntax::codemap::Span;\n /// out for specific methods where this might not make sense.\n ///\n /// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// pub fn foo() {} // missing #[inline]\n+/// fn ok() {} // ok\n+/// #[inline] pub fn bar() {} // ok\n+/// #[inline(always)] pub fn baz() {} // ok\n+///\n+/// pub trait Bar {\n+///   fn bar(); // ok\n+///   fn def_bar() {} // missing #[inline]\n+/// }\n+///\n+/// struct Baz;\n+/// impl Baz {\n+///    fn priv() {} // ok\n+/// }\n+///\n+/// impl Bar for Baz {\n+///   fn bar() {} // ok - Baz is not exported\n+/// }\n+///\n+/// pub struct PubBaz;\n+/// impl PubBaz {\n+///    fn priv() {} // ok\n+///    pub not_ptriv() {} // missing #[inline]\n+/// }\n+///\n+/// impl Bar for PubBaz {\n+///    fn bar() {} // missing #[inline]\n+///    fn def_bar() {} // missing #[inline]\n+/// }\n+/// ```\n declare_clippy_lint! {\n     pub MISSING_INLINE_IN_PUBLIC_ITEMS,\n     restriction,\n     \"detects missing #[inline] attribute for public callables (functions, trait methods, methods...)\"\n }\n \n-pub struct MissingInline {}\n-\n-impl ::std::default::Default for MissingInline {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n+pub struct MissingInline;\n \n impl MissingInline {\n-    pub fn new() -> Self {\n-        Self {}\n-    }\n-\n     fn check_missing_inline_attrs(&self, cx: &LateContext,\n                                   attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-        // If we're building a test harness, FIXME: is this relevant?\n-        // if cx.sess().opts.test {\n-        //    return;\n-        // }\n-\n         let has_inline = attrs\n             .iter()\n             .any(|a| a.name() == \"inline\" );\n@@ -91,6 +109,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             },\n             hir::ItemTrait(ref _is_auto, ref _unsafe, ref _generics,\n                            ref _bounds, ref trait_items)  => {\n+                // note: we need to check if the trait is exported so we can't use\n+                // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {\n                     let tit_ = cx.tcx.hir.trait_item(tit.id);\n                     match tit_.node {\n@@ -134,12 +154,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n+        let desc = match impl_item.node {\n+            hir::ImplItemKind::Method(..) => \"a method\",\n+            hir::ImplItemKind::Const(..) |\n+            hir::ImplItemKind::Type(_) => return,\n+        };\n+\n         let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n             TraitContainer(cid) => {\n-                let n = cx.tcx.hir.as_local_node_id(cid);\n-                if n.is_some() {\n-                    if !cx.access_levels.is_exported(n.unwrap()) {\n+                if let Some(n) = cx.tcx.hir.as_local_node_id(cid) {\n+                    if !cx.access_levels.is_exported(n) {\n                         // If a trait is being implemented for an item, and the\n                         // trait is not exported, we don't need #[inline]\n                         return;\n@@ -149,9 +174,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             ImplContainer(cid) => {\n                 if cx.tcx.impl_trait_ref(cid).is_some() {\n                     let trait_ref = cx.tcx.impl_trait_ref(cid).unwrap();\n-                    let n = cx.tcx.hir.as_local_node_id(trait_ref.def_id);\n-                    if n.is_some() {\n-                        if !cx.access_levels.is_exported(n.unwrap()) {\n+                    if let Some(n) = cx.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+                        if !cx.access_levels.is_exported(n) {\n                             // If a trait is being implemented for an item, and the\n                             // trait is not exported, we don't need #[inline]\n                             return;\n@@ -161,11 +185,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             },\n         }\n \n-        let desc = match impl_item.node {\n-            hir::ImplItemKind::Method(..) => \"a method\",\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Type(_) => return,\n-        };\n         self.check_missing_inline_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }\n }"}]}