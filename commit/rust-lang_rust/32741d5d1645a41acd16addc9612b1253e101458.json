{"sha": "32741d5d1645a41acd16addc9612b1253e101458", "node_id": "C_kwDOAAsO6NoAKDMyNzQxZDVkMTY0NWE0MWFjZDE2YWRkYzk2MTJiMTI1M2UxMDE0NTg", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-02T07:51:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-05T22:47:49Z"}, "message": "Split `process_obligation` in two.\n\nBecause it really has two halves:\n- A read-only part that checks if further work is needed.\n- The further work part, which is much less hot.\n\nThis makes things a bit clearer and nicer.", "tree": {"sha": "9ed55442a347a9563f26c9b716d67736ccc6d661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ed55442a347a9563f26c9b716d67736ccc6d661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32741d5d1645a41acd16addc9612b1253e101458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32741d5d1645a41acd16addc9612b1253e101458", "html_url": "https://github.com/rust-lang/rust/commit/32741d5d1645a41acd16addc9612b1253e101458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32741d5d1645a41acd16addc9612b1253e101458/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "281229a6d392c192d44d9de0d98675303b3fa271", "url": "https://api.github.com/repos/rust-lang/rust/commits/281229a6d392c192d44d9de0d98675303b3fa271", "html_url": "https://github.com/rust-lang/rust/commit/281229a6d392c192d44d9de0d98675303b3fa271"}], "stats": {"total": 90, "additions": 44, "deletions": 46}, "files": [{"sha": "07a96dd7dbbf1dfb9a0750912bef073d415971d6", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=32741d5d1645a41acd16addc9612b1253e101458", "patch": "@@ -96,6 +96,8 @@ pub trait ObligationProcessor {\n     type Obligation: ForestObligation;\n     type Error: Debug;\n \n+    fn needs_process_obligation(&self, obligation: &Self::Obligation) -> bool;\n+\n     fn process_obligation(\n         &mut self,\n         obligation: &mut Self::Obligation,\n@@ -143,7 +145,7 @@ pub struct ObligationForest<O: ForestObligation> {\n \n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n-    /// comments in [`Self::process_obligation` for details.\n+    /// comments in `Self::process_obligation` for details.\n     active_cache: FxHashMap<O::CacheKey, usize>,\n \n     /// A vector reused in [Self::compress()] and [Self::find_cycles_from_node()],\n@@ -417,15 +419,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // nodes. Therefore we use a `while` loop.\n             let mut index = 0;\n             while let Some(node) = self.nodes.get_mut(index) {\n+                if node.state.get() != NodeState::Pending\n+                    || !processor.needs_process_obligation(&node.obligation)\n+                {\n+                    index += 1;\n+                    continue;\n+                }\n+\n                 // `processor.process_obligation` can modify the predicate within\n                 // `node.obligation`, and that predicate is the key used for\n                 // `self.active_cache`. This means that `self.active_cache` can get\n                 // out of sync with `nodes`. It's not very common, but it does\n                 // happen, and code in `compress` has to allow for it.\n-                if node.state.get() != NodeState::Pending {\n-                    index += 1;\n-                    continue;\n-                }\n \n                 match processor.process_obligation(&mut node.obligation) {\n                     ProcessResult::Unchanged => {"}, {"sha": "e2991aae1742c89f076553fff6a79bf6d6e6bc4a", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=32741d5d1645a41acd16addc9612b1253e101458", "patch": "@@ -65,6 +65,10 @@ where\n     type Obligation = O;\n     type Error = E;\n \n+    fn needs_process_obligation(&self, _obligation: &Self::Obligation) -> bool {\n+        true\n+    }\n+\n     fn process_obligation(\n         &mut self,\n         obligation: &mut Self::Obligation,"}, {"sha": "50b8baecbcae9e0396a37d6191e45c2e59119290", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32741d5d1645a41acd16addc9612b1253e101458/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=32741d5d1645a41acd16addc9612b1253e101458", "patch": "@@ -253,22 +253,16 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n \n-    /// Processes a predicate obligation and returns either:\n-    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n-    /// - `Unchanged` if we don't have enough info to be sure\n-    /// - `Error(e)` if the predicate does not hold\n+    /// Identifies whether a predicate obligation needs processing.\n     ///\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n-    fn process_obligation(\n-        &mut self,\n-        pending_obligation: &mut Self::Obligation,\n-    ) -> ProcessResult<Self::Obligation, Self::Error> {\n+    fn needs_process_obligation(&self, pending_obligation: &Self::Obligation) -> bool {\n         // If we were stalled on some unresolved variables, first check whether\n         // any of them have been resolved; if not, don't bother doing more work\n         // yet.\n-        let change = match pending_obligation.stalled_on.len() {\n+        match pending_obligation.stalled_on.len() {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n@@ -291,42 +285,18 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     false\n                 })()\n             }\n-        };\n-\n-        if !change {\n-            debug!(\n-                \"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                self.selcx.infcx().resolve_vars_if_possible(pending_obligation.obligation.clone()),\n-                pending_obligation.stalled_on\n-            );\n-            return ProcessResult::Unchanged;\n         }\n-\n-        self.process_changed_obligations(pending_obligation)\n     }\n \n-    fn process_backedge<'c, I>(\n-        &mut self,\n-        cycle: I,\n-        _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,\n-    ) where\n-        I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,\n-    {\n-        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n-            debug!(\"process_child_obligations: coinductive match\");\n-        } else {\n-            let cycle: Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n-            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n-    // The code calling this method is extremely hot and only rarely\n-    // actually uses this, so move this part of the code\n-    // out of that loop.\n+    /// Processes a predicate obligation and returns either:\n+    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n+    /// - `Unchanged` if we don't have enough info to be sure\n+    /// - `Error(e)` if the predicate does not hold\n+    ///\n+    /// This is called much less often than `needs_process_obligation`, so we\n+    /// never inline it.\n     #[inline(never)]\n-    fn process_changed_obligations(\n+    fn process_obligation(\n         &mut self,\n         pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n@@ -341,6 +311,8 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n         }\n \n+        let obligation = &pending_obligation.obligation;\n+\n         debug!(?obligation, ?obligation.cause, \"process_obligation\");\n \n         let infcx = self.selcx.infcx();\n@@ -655,6 +627,23 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         }\n     }\n \n+    fn process_backedge<'c, I>(\n+        &mut self,\n+        cycle: I,\n+        _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,\n+    ) where\n+        I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,\n+    {\n+        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle: Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, obligation, stalled_on))]\n     fn process_trait_obligation(\n         &mut self,"}]}