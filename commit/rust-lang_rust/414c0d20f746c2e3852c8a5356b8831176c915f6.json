{"sha": "414c0d20f746c2e3852c8a5356b8831176c915f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNGMwZDIwZjc0NmMyZTM4NTJjOGE1MzU2Yjg4MzExNzZjOTE1ZjY=", "commit": {"author": {"name": "wartman4404", "email": "wartman4404@my.mstc.edu", "date": "2015-10-31T04:58:37Z"}, "committer": {"name": "wartman4404", "email": "wartman4404@my.mstc.edu", "date": "2015-11-04T03:01:52Z"}, "message": "New lint for using `.cloned()`", "tree": {"sha": "c1c05a4969d1f2d49fa7087e56a73842ee6a9931", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1c05a4969d1f2d49fa7087e56a73842ee6a9931"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/414c0d20f746c2e3852c8a5356b8831176c915f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/414c0d20f746c2e3852c8a5356b8831176c915f6", "html_url": "https://github.com/rust-lang/rust/commit/414c0d20f746c2e3852c8a5356b8831176c915f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/414c0d20f746c2e3852c8a5356b8831176c915f6/comments", "author": null, "committer": null, "parents": [{"sha": "4b1409684a4860a73608609fd50dfd256c87a785", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1409684a4860a73608609fd50dfd256c87a785", "html_url": "https://github.com/rust-lang/rust/commit/4b1409684a4860a73608609fd50dfd256c87a785"}], "stats": {"total": 175, "additions": 175, "deletions": 0}, "files": [{"sha": "fcfeca1509eb3adefa4f5a392fbb54212a721665", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/414c0d20f746c2e3852c8a5356b8831176c915f6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/414c0d20f746c2e3852c8a5356b8831176c915f6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=414c0d20f746c2e3852c8a5356b8831176c915f6", "patch": "@@ -34,6 +34,7 @@ name\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                       | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                 | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                               | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                       | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                     | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant"}, {"sha": "37e1ace61ded590091d440c70023a058c08f28a4", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/414c0d20f746c2e3852c8a5356b8831176c915f6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414c0d20f746c2e3852c8a5356b8831176c915f6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=414c0d20f746c2e3852c8a5356b8831176c915f6", "patch": "@@ -45,6 +45,7 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod map_clone;\n pub mod matches;\n pub mod precedence;\n pub mod mutex_atomic;\n@@ -100,6 +101,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box needless_features::NeedlessFeaturesPass);\n     reg.register_late_lint_pass(box needless_update::NeedlessUpdatePass);\n     reg.register_late_lint_pass(box no_effect::NoEffectPass);\n+    reg.register_late_lint_pass(box map_clone::MapClonePass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -141,6 +143,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::UNUSED_COLLECT,\n         loops::WHILE_LET_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n+        map_clone::MAP_CLONE,\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,"}, {"sha": "570ee91dd7bd133e78cc9fc2ab20ef2b0d950c61", "filename": "src/map_clone.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/414c0d20f746c2e3852c8a5356b8831176c915f6/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414c0d20f746c2e3852c8a5356b8831176c915f6/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=414c0d20f746c2e3852c8a5356b8831176c915f6", "patch": "@@ -0,0 +1,102 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use syntax::ast::Ident;\n+use utils::OPTION_PATH;\n+use utils::{match_trait_method, match_type, snippet, span_help_and_lint};\n+use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n+\n+declare_lint!(pub MAP_CLONE, Warn,\n+              \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\\n+              `.cloned()` instead)\");\n+\n+#[derive(Copy, Clone)]\n+pub struct MapClonePass;\n+\n+impl LateLintPass for MapClonePass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if_let_chain! {\n+            [\n+                // call to .map()\n+                let ExprMethodCall(name, _, ref args) = expr.node,\n+                name.node.as_str() == \"map\" && args.len() == 2,\n+                let ExprClosure(_, ref decl, ref blk) = args[1].node,\n+                // just one expression in the closure\n+                blk.stmts.is_empty(),\n+                let Some(ref closure_expr) = blk.expr,\n+                // nothing special in the argument, besides reference bindings\n+                // (e.g. .map(|&x| x) )\n+                let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n+                // the method is being called on a known type (option or iterator)\n+                let Some(type_name) = get_type_name(cx, expr, &args[0])\n+            ], {\n+                // look for derefs, for .map(|x| *x)\n+                if only_derefs(&*closure_expr, arg_ident) &&\n+                    // .cloned() only removes one level of indirection, don't lint on more\n+                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                {\n+                    span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                        \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                        using `.cloned()`\", type_name),\n+                        &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                }\n+                // explicit clone() calls ( .map(|x| x.clone()) )\n+                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n+                    if clone_call.node.as_str() == \"clone\" &&\n+                        clone_args.len() == 1 &&\n+                        match_trait_method(cx, closure_expr, &[\"core\", \"clone\", \"Clone\"]) &&\n+                        expr_eq_ident(&clone_args[0], arg_ident)\n+                    {\n+                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                            using `.cloned()`\", type_name),\n+                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n+    match expr.node {\n+        ExprPath(None, ref path) => {\n+            let arg_segment = [PathSegment { identifier: id, parameters: PathParameters::none() }];\n+            !path.global && path.segments == arg_segment\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n+    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+        Some(\"iterator\")\n+    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &OPTION_PATH) {\n+        Some(\"Option\")\n+    } else {\n+        None\n+    }\n+}\n+\n+fn get_arg_name(pat: &Pat) -> Option<Ident> {\n+    match pat.node {\n+        PatIdent(_, ident, None) => Some(ident.node),\n+        PatRegion(ref subpat, _) => get_arg_name(subpat),\n+        _ => None,\n+    }\n+}\n+\n+fn only_derefs(expr: &Expr, id: Ident) -> bool {\n+    if expr_eq_ident(expr, id) {\n+        true\n+    } else if let ExprUnary(UnDeref, ref subexpr) = expr.node {\n+        only_derefs(subexpr, id)\n+    } else {\n+        false\n+    }\n+}\n+\n+impl LintPass for MapClonePass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MAP_CLONE)\n+    }\n+}"}, {"sha": "9d9f253defe89b49369d6e9e812b36257ba0fd2f", "filename": "tests/compile-fail/map_clone.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/414c0d20f746c2e3852c8a5356b8831176c915f6/tests%2Fcompile-fail%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414c0d20f746c2e3852c8a5356b8831176c915f6/tests%2Fcompile-fail%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmap_clone.rs?ref=414c0d20f746c2e3852c8a5356b8831176c915f6", "patch": "@@ -0,0 +1,69 @@\n+#![feature(plugin)]\n+\n+#![plugin(clippy)]\n+#![deny(map_clone)]\n+\n+#![allow(unused)]\n+\n+fn map_clone_iter() {\n+    let x = [1,2,3];\n+    x.iter().map(|y| y.clone()); //~ ERROR you seem to be using .map()\n+                                 //~^ HELP try\n+    x.iter().map(|&y| y); //~ ERROR you seem to be using .map()\n+                          //~^ HELP try\n+    x.iter().map(|y| *y); //~ ERROR you seem to be using .map()\n+                          //~^ HELP try\n+}\n+\n+fn map_clone_option() {\n+    let x = Some(4);\n+    x.as_ref().map(|y| y.clone()); //~ ERROR you seem to be using .map()\n+                                   //~^ HELP try\n+    x.as_ref().map(|&y| y); //~ ERROR you seem to be using .map()\n+                            //~^ HELP try\n+    x.as_ref().map(|y| *y); //~ ERROR you seem to be using .map()\n+                            //~^ HELP try\n+}\n+\n+fn not_linted_option() {\n+    let x = Some(5);\n+\n+    // Not linted: other statements\n+    x.as_ref().map(|y| {\n+        println!(\"y: {}\", y);\n+        y.clone()\n+    });\n+\n+    // Not linted: argument bindings\n+    let x = Some((6, 7));\n+    x.map(|(y, _)| y.clone());\n+\n+    // Not linted: cloning something else\n+    x.map(|y| y.0.clone());\n+\n+    // Not linted: no dereferences\n+    x.map(|y| y);\n+\n+    // Not linted: multiple dereferences\n+    let _: Option<(i32, i32)> = x.as_ref().as_ref().map(|&&x| x);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Wrapper<T>(T);\n+impl<T> Wrapper<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Wrapper<U> {\n+        Wrapper(f(self.0))\n+    }\n+}\n+\n+fn map_clone_other() {\n+    let eight = 8;\n+    let x = Wrapper(&eight);\n+\n+    // Not linted: not a linted type\n+    x.map(|y| y.clone());\n+    x.map(|&y| y);\n+    x.map(|y| *y);\n+}\n+\n+fn main() { }"}]}