{"sha": "def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZjVmODRmYTY0ZjRhNjQxMzdkY2ZjNGNjNWUzMDA3Y2M5MjU3ZTY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-29T08:46:30Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-29T08:46:30Z"}, "message": "Rollup merge of #54577 - QuietMisdreavus:docs-for-procs, r=GuillaumeGomez\n\nrustdoc: give proc-macros their own pages\n\nrelated to https://github.com/rust-lang/rust/issues/49553 but i don't think it'll fix it\n\nCurrently, rustdoc doesn't expose proc-macros all that well. In the source crate, only their definition function is exposed, but when re-exported, they're treated as a macro! This is an awkward situation in all accounts. This PR checks functions to see whether they have any of `#[proc_macro]`, `#[proc_macro_attribute]`, or `#[proc_macro_derive]`, and exposes them as macros instead. In addition, attributes and derives are exposed differently than other macros, getting their own item-type, CSS class, and module heading.\n\n![image](https://user-images.githubusercontent.com/5217170/46044803-6df8da00-c0e1-11e8-8c3b-25d2c3beb55c.png)\n\nFunction-like proc-macros are lumped in with `macro_rules!` macros, but they get a different declaration block (i'm open to tweaking this, it's just what i thought of given how function-proc-macros operate):\n\n![image](https://user-images.githubusercontent.com/5217170/46044828-84069a80-c0e1-11e8-9cc4-127e5477c395.png)\n\nProc-macro attributes and derives get their own pages, with a representative declaration block. Derive macros also show off their helper attributes:\n\n![image](https://user-images.githubusercontent.com/5217170/46094583-ef9f4500-c17f-11e8-8f71-fa0a7895c9f6.png)\n\n![image](https://user-images.githubusercontent.com/5217170/46101529-cab3cd80-c191-11e8-857a-946897750da1.png)\n\nThere's one wrinkle which this PR doesn't address, which is why i didn't mark this as fixing the linked issue. Currently, proc-macros don't expose their attributes or source span across crates, so while rustdoc knows they exist, that's about all the information it gets. This leads to an \"inlined\" macro that has absolutely no docs on it, and no `[src]` link to show you where it was declared.\n\nThe way i got around it was to keep proc-macro re-export disabled, since we do get enough information across crates to properly link to the source page:\n\n![image](https://user-images.githubusercontent.com/5217170/46045074-2cb4fa00-c0e2-11e8-81bc-33a8205fbd03.png)\n\nUntil we can get a proc-macro's docs (and ideally also its source span) across crates, i believe this is the best way forward.", "tree": {"sha": "08e5f783a646addc58ba008ca8b893fa3bc5c72f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08e5f783a646addc58ba008ca8b893fa3bc5c72f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAluvO+gACgkQ/vbIBR0O\nATx7MQ//alvzWCS9p/SYEzYannmltOvKA5MLNAQLioakyZyhWTo27qgWjLQJXaXs\nBvIhCeLZWirfvkUjXR/kWbIcieFTBZZNFPKsRUsOrvEQGYTZrqQUpuN5bt8jx7/2\nQCtt5WCvVRVTkcdh0Mq3scMH89iRdJNIubK3wZEX+c1ecWMVZz6MJVvwrrsHJcte\noqqER3508aHEWH0o+Ncuh14hdw+kTPxLaVG8D/x+9ApccoSo6VNi1D7h+YEYyyYh\na1GZuBubUoMRlUNvxkDTxmqa6cezicEOClDVyJMdXsGK305Vaxf7TybS3rSZfhkL\n5aHC80XHylQigPxq1TrFjQ/fF18sPnLi/kMMM2LWcEEwa7S68jvK/zVAk1tjASH3\nJ2pt3hhCynhrmtS5JtqpTJCzMeHpsRDZSyuU6x73xTpOi01/1x9eYHt8ClJbY3c9\n2UB/r/EmA3u0St9G0WniSXtAopuEq7vg7zY+H32ulQS+QTbha23kpHV461RyT+5p\nOOfP3ymdrOjXRRO8uKBF71ujxm+k2NAI7ZX9AYMhySaSLuzLxJzVTzXELzpOOeRx\nA7JBfJZANbCqOeyl5NvP8EUPJgk9hZyFRjBy3szmFgbzuBWtc1FEiKh3bGKeFkqk\nLVmJBcMw8tyHywKvellh8CdXqUXqjcRan+2U7ICwZl57iuQZ3W0=\n=8+i0\n-----END PGP SIGNATURE-----", "payload": "tree 08e5f783a646addc58ba008ca8b893fa3bc5c72f\nparent 3861591946a58faaab861d1336ad0ae51e36c0a1\nparent d37f3696b167251a96b8f0e4b33336d023daa2c5\nauthor kennytm <kennytm@gmail.com> 1538210790 +0800\ncommitter kennytm <kennytm@gmail.com> 1538210790 +0800\n\nRollup merge of #54577 - QuietMisdreavus:docs-for-procs, r=GuillaumeGomez\n\nrustdoc: give proc-macros their own pages\n\nrelated to https://github.com/rust-lang/rust/issues/49553 but i don't think it'll fix it\n\nCurrently, rustdoc doesn't expose proc-macros all that well. In the source crate, only their definition function is exposed, but when re-exported, they're treated as a macro! This is an awkward situation in all accounts. This PR checks functions to see whether they have any of `#[proc_macro]`, `#[proc_macro_attribute]`, or `#[proc_macro_derive]`, and exposes them as macros instead. In addition, attributes and derives are exposed differently than other macros, getting their own item-type, CSS class, and module heading.\n\n![image](https://user-images.githubusercontent.com/5217170/46044803-6df8da00-c0e1-11e8-8c3b-25d2c3beb55c.png)\n\nFunction-like proc-macros are lumped in with `macro_rules!` macros, but they get a different declaration block (i'm open to tweaking this, it's just what i thought of given how function-proc-macros operate):\n\n![image](https://user-images.githubusercontent.com/5217170/46044828-84069a80-c0e1-11e8-9cc4-127e5477c395.png)\n\nProc-macro attributes and derives get their own pages, with a representative declaration block. Derive macros also show off their helper attributes:\n\n![image](https://user-images.githubusercontent.com/5217170/46094583-ef9f4500-c17f-11e8-8f71-fa0a7895c9f6.png)\n\n![image](https://user-images.githubusercontent.com/5217170/46101529-cab3cd80-c191-11e8-857a-946897750da1.png)\n\nThere's one wrinkle which this PR doesn't address, which is why i didn't mark this as fixing the linked issue. Currently, proc-macros don't expose their attributes or source span across crates, so while rustdoc knows they exist, that's about all the information it gets. This leads to an \"inlined\" macro that has absolutely no docs on it, and no `[src]` link to show you where it was declared.\n\nThe way i got around it was to keep proc-macro re-export disabled, since we do get enough information across crates to properly link to the source page:\n\n![image](https://user-images.githubusercontent.com/5217170/46045074-2cb4fa00-c0e2-11e8-81bc-33a8205fbd03.png)\n\nUntil we can get a proc-macro's docs (and ideally also its source span) across crates, i believe this is the best way forward.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "html_url": "https://github.com/rust-lang/rust/commit/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3861591946a58faaab861d1336ad0ae51e36c0a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3861591946a58faaab861d1336ad0ae51e36c0a1", "html_url": "https://github.com/rust-lang/rust/commit/3861591946a58faaab861d1336ad0ae51e36c0a1"}, {"sha": "d37f3696b167251a96b8f0e4b33336d023daa2c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37f3696b167251a96b8f0e4b33336d023daa2c5", "html_url": "https://github.com/rust-lang/rust/commit/d37f3696b167251a96b8f0e4b33336d023daa2c5"}], "stats": {"total": 426, "additions": 374, "deletions": 52}, "files": [{"sha": "a435712ac3d6ce75ae6f52e5995eb5c550d5bf7f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -13,7 +13,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::MacroKind;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -105,12 +105,12 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n-        // FIXME(misdreavus): if attributes/derives come down here we should probably document them\n-        // separately\n+        // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n         Def::Macro(did, MacroKind::Bang) => {\n-            record_extern_fqn(cx, did, clean::TypeKind::Macro);\n-            if let Some(mac) = build_macro(cx, did, name) {\n-                clean::MacroItem(mac)\n+            let mac = build_macro(cx, did, name);\n+            if let clean::MacroItem(..) = mac {\n+                record_extern_fqn(cx, did, clean::TypeKind::Macro);\n+                mac\n             } else {\n                 return None;\n             }\n@@ -442,31 +442,41 @@ fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     }\n }\n \n-fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> Option<clean::Macro> {\n+fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    let def = match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(macro_def) => macro_def,\n-        // FIXME(jseyfried): document proc macro re-exports\n-        LoadedMacro::ProcMacro(..) => return None,\n-    };\n-\n-    let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n-        let tts: Vec<_> = def.stream().into_trees().collect();\n-        tts.chunks(4).map(|arm| arm[0].span()).collect()\n-    } else {\n-        unreachable!()\n-    };\n-\n-    let source = format!(\"macro_rules! {} {{\\n{}}}\",\n-                         name.clean(cx),\n-                         matchers.iter().map(|span| {\n-                             format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n-                         }).collect::<String>());\n+    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n+        LoadedMacro::MacroDef(def) => {\n+            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+                let tts: Vec<_> = def.stream().into_trees().collect();\n+                tts.chunks(4).map(|arm| arm[0].span()).collect()\n+            } else {\n+                unreachable!()\n+            };\n+\n+            let source = format!(\"macro_rules! {} {{\\n{}}}\",\n+                                 name.clean(cx),\n+                                 matchers.iter().map(|span| {\n+                                     format!(\"    {} => {{ ... }};\\n\", span.to_src(cx))\n+                                 }).collect::<String>());\n+\n+            clean::MacroItem(clean::Macro {\n+                source,\n+                imported_from: Some(imported_from).clean(cx),\n+            })\n+        }\n+        LoadedMacro::ProcMacro(ext) => {\n+            let helpers = match &*ext {\n+                &SyntaxExtension::ProcMacroDerive(_, ref syms, ..) => { syms.clean(cx) }\n+                _ => Vec::new(),\n+            };\n+\n+            clean::ProcMacroItem(clean::ProcMacro {\n+                kind: ext.kind(),\n+                helpers,\n+            })\n+        }\n+    }\n \n-    Some(clean::Macro {\n-        source,\n-        imported_from: Some(imported_from).clean(cx),\n-    })\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "41c4ee982ff79a1da107559239da00e0a4e426db", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -21,6 +21,7 @@ pub use self::Visibility::{Public, Inherited};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n@@ -527,6 +528,7 @@ pub enum ItemEnum {\n     /// `type`s from an extern block\n     ForeignTypeItem,\n     MacroItem(Macro),\n+    ProcMacroItem(ProcMacro),\n     PrimitiveItem(PrimitiveType),\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<GenericBound>, Option<Type>),\n@@ -588,6 +590,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n+        items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -2189,6 +2192,8 @@ pub enum TypeKind {\n     Typedef,\n     Foreign,\n     Macro,\n+    Attr,\n+    Derive,\n }\n \n pub trait GetDefId {\n@@ -3725,7 +3730,12 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n-        Def::Macro(i, _) => (i, TypeKind::Macro),\n+        Def::Macro(i, mac_kind) => match mac_kind {\n+            MacroKind::Bang => (i, TypeKind::Macro),\n+            MacroKind::Attr => (i, TypeKind::Attr),\n+            MacroKind::Derive => (i, TypeKind::Derive),\n+            MacroKind::ProcMacroStub => unreachable!(),\n+        },\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n@@ -3780,6 +3790,30 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct ProcMacro {\n+    pub kind: MacroKind,\n+    pub helpers: Vec<String>,\n+}\n+\n+impl Clean<Item> for doctree::ProcMacro {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: Some(Public),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n+            inner: ProcMacroItem(ProcMacro {\n+                kind: self.kind,\n+                helpers: self.helpers.clean(cx),\n+            }),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stability {\n     pub level: stability::StabilityLevel,"}, {"sha": "4a6a4ee09ea1a0276af9ad19b6e9c924c221edf0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -15,6 +15,7 @@ pub use self::StructType::*;\n use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::ptr::P;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n@@ -46,6 +47,7 @@ pub struct Module {\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<hir::ForeignMod>,\n     pub macros: Vec<Macro>,\n+    pub proc_macros: Vec<ProcMacro>,\n     pub is_crate: bool,\n }\n \n@@ -75,6 +77,7 @@ impl Module {\n             impls      : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n+            proc_macros: Vec::new(),\n             is_crate   : false,\n         }\n     }\n@@ -264,6 +267,17 @@ pub struct Import {\n     pub whence: Span,\n }\n \n+pub struct ProcMacro {\n+    pub name: Name,\n+    pub id: NodeId,\n+    pub kind: MacroKind,\n+    pub helpers: Vec<Name>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub whence: Span,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+}\n+\n pub fn struct_type_from_def(vdata: &hir::VariantData) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "acb8f6a66dfcb42ff3d87c4fdb52ca4186dfac0d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -11,6 +11,7 @@\n //! Item types.\n \n use std::fmt;\n+use syntax::ext::base::MacroKind;\n use clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n@@ -19,6 +20,11 @@ use clean;\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n /// the `itemTypes` mapping table in `static/main.js`.\n+///\n+/// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n+/// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n+/// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n+/// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Clone, Debug)]\n pub enum ItemType {\n     Module          = 0,\n@@ -44,6 +50,8 @@ pub enum ItemType {\n     ForeignType     = 20,\n     Keyword         = 21,\n     Existential     = 22,\n+    ProcAttribute   = 23,\n+    ProcDerive      = 24,\n }\n \n \n@@ -88,6 +96,12 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::ForeignTypeItem         => ItemType::ForeignType,\n             clean::KeywordItem(..)         => ItemType::Keyword,\n+            clean::ProcMacroItem(ref mac)  => match mac.kind {\n+                MacroKind::Bang            => ItemType::Macro,\n+                MacroKind::Attr            => ItemType::ProcAttribute,\n+                MacroKind::Derive          => ItemType::ProcDerive,\n+                MacroKind::ProcMacroStub   => unreachable!(),\n+            }\n             clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n@@ -107,7 +121,9 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Variant  => ItemType::Variant,\n             clean::TypeKind::Typedef  => ItemType::Typedef,\n             clean::TypeKind::Foreign  => ItemType::ForeignType,\n-            clean::TypeKind::Macro  => ItemType::Macro,\n+            clean::TypeKind::Macro    => ItemType::Macro,\n+            clean::TypeKind::Attr     => ItemType::ProcAttribute,\n+            clean::TypeKind::Derive   => ItemType::ProcDerive,\n         }\n     }\n }\n@@ -138,6 +154,8 @@ impl ItemType {\n             ItemType::ForeignType     => \"foreigntype\",\n             ItemType::Keyword         => \"keyword\",\n             ItemType::Existential     => \"existential\",\n+            ItemType::ProcAttribute   => \"attr\",\n+            ItemType::ProcDerive      => \"derive\",\n         }\n     }\n \n@@ -166,7 +184,9 @@ impl ItemType {\n             ItemType::Constant |\n             ItemType::AssociatedConst => NameSpace::Value,\n \n-            ItemType::Macro => NameSpace::Macro,\n+            ItemType::Macro |\n+            ItemType::ProcAttribute |\n+            ItemType::ProcDerive => NameSpace::Macro,\n \n             ItemType::Keyword => NameSpace::Keyword,\n         }"}, {"sha": "1c61e73fae03cdd0f8346bee6244c05bfd517256", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -56,6 +56,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -1595,6 +1596,8 @@ struct AllTypes {\n     statics: FxHashSet<ItemEntry>,\n     constants: FxHashSet<ItemEntry>,\n     keywords: FxHashSet<ItemEntry>,\n+    attributes: FxHashSet<ItemEntry>,\n+    derives: FxHashSet<ItemEntry>,\n }\n \n impl AllTypes {\n@@ -1613,6 +1616,8 @@ impl AllTypes {\n             statics: new_set(100),\n             constants: new_set(100),\n             keywords: new_set(100),\n+            attributes: new_set(100),\n+            derives: new_set(100),\n         }\n     }\n \n@@ -1634,6 +1639,8 @@ impl AllTypes {\n                 ItemType::Existential => self.existentials.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Static => self.statics.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Constant => self.constants.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcAttribute => self.attributes.insert(ItemEntry::new(new_url, name)),\n+                ItemType::ProcDerive => self.derives.insert(ItemEntry::new(new_url, name)),\n                 _ => true,\n             };\n         }\n@@ -1673,6 +1680,8 @@ impl fmt::Display for AllTypes {\n         print_entries(f, &self.primitives, \"Primitives\", \"primitives\")?;\n         print_entries(f, &self.traits, \"Traits\", \"traits\")?;\n         print_entries(f, &self.macros, \"Macros\", \"macros\")?;\n+        print_entries(f, &self.attributes, \"Attribute Macros\", \"attributes\")?;\n+        print_entries(f, &self.derives, \"Derive Macros\", \"derives\")?;\n         print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n         print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n         print_entries(f, &self.existentials, \"Existentials\", \"existentials\")?;\n@@ -2155,6 +2164,12 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n             clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n             clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n+            clean::ProcMacroItem(ref mac) => match mac.kind {\n+                MacroKind::Bang => write!(fmt, \"Macro \")?,\n+                MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n+                MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n+                MacroKind::ProcMacroStub => unreachable!(),\n+            }\n             clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n             clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n@@ -2191,6 +2206,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n             clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n+            clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n             clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n                 item_static(fmt, self.cx, self.item, i),\n@@ -4079,11 +4095,12 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 write!(fmt,\n                        \"<div class='block version'>\\\n                         <p>Version {}</p>\\\n-                        </div>\n-                        <a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n-                       version,\n-                       it.name.as_ref().unwrap())?;\n+                        </div>\",\n+                       version)?;\n             }\n+\n+            write!(fmt, \"<a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n+                   it.name.as_ref().expect(\"crates always have a name\"))?;\n         }\n \n         write!(fmt, \"<div class=\\\"sidebar-elems\\\">\")?;\n@@ -4523,6 +4540,8 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n         ItemType::ForeignType     => (\"foreign-types\", \"Foreign Types\"),\n         ItemType::Keyword         => (\"keywords\", \"Keywords\"),\n         ItemType::Existential     => (\"existentials\", \"Existentials\"),\n+        ItemType::ProcAttribute   => (\"attributes\", \"Attribute Macros\"),\n+        ItemType::ProcDerive      => (\"derives\", \"Derive Macros\"),\n     }\n }\n \n@@ -4598,6 +4617,39 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n+fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n+    -> fmt::Result\n+{\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            write!(w, \"<pre class='rust macro'>\")?;\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Attr => {\n+            write!(w, \"<pre class='rust attr'>\")?;\n+            write!(w, \"#[{}]\", name)?;\n+            write!(w, \"</pre>\")?;\n+        }\n+        MacroKind::Derive => {\n+            write!(w, \"<pre class='rust derive'>\")?;\n+            write!(w, \"#[derive({})]\", name)?;\n+            if !m.helpers.is_empty() {\n+                writeln!(w, \"\\n{{\")?;\n+                writeln!(w, \"    // Attributes available to this derive:\")?;\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr)?;\n+                }\n+                write!(w, \"}}\")?;\n+            }\n+            write!(w, \"</pre>\")?;\n+        }\n+        _ => {}\n+    }\n+    document(w, cx, it)\n+}\n+\n fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {"}, {"sha": "6307dda454da892b261ed71c8d2d40e908956df3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -39,7 +39,10 @@\n                      \"associatedconstant\",\n                      \"union\",\n                      \"foreigntype\",\n-                     \"keyword\"];\n+                     \"keyword\",\n+                     \"existential\",\n+                     \"attr\",\n+                     \"derive\"];\n \n     var search_input = document.getElementsByClassName('search-input')[0];\n "}, {"sha": "34a1d71beecfcdf863f5fdc29b89549b9c7fadaf", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #4950ed; }\n .content .highlighted.type { background-color: #38902c; }\n .content .highlighted.foreigntype { background-color: #b200d6; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #217d1c; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #0063cc; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #2dbfb8; }\n .content span.type, .content a.type, .block a.current.type { color: #ff7f00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #dd7de8; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #09bd00; }\n .content span.union, .content a.union, .block a.current.union { color: #a6ae37; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "8218b1b371ea72fcba87a0e3fb2205ef90c34355", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -124,6 +124,8 @@ pre {\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #ffc891; }\n .content .highlighted.foreigntype { background-color: #f5c4ff; }\n+.content .highlighted.attr,\n+.content .highlighted.derive,\n .content .highlighted.macro { background-color: #8ce488; }\n .content .highlighted.constant,\n .content .highlighted.static { background-color: #c3e0ff; }\n@@ -134,6 +136,8 @@ pre {\n .content span.struct, .content a.struct, .block a.current.struct { color: #ad448e; }\n .content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #cd00e2; }\n+.content span.attr, .content a.attr, .block a.current.attr,\n+.content span.derive, .content a.derive, .block a.current.derive,\n .content span.macro, .content a.macro, .block a.current.macro { color: #068000; }\n .content span.union, .content a.union, .block a.current.union { color: #767b27; }\n .content span.constant, .content a.constant, .block a.current.constant,"}, {"sha": "d00eb3257d43c6a5aacb537390c24361fcceb10d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -249,6 +249,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // tymethods/macros have no control over privacy\n             clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n \n+            // Proc-macros are always public\n+            clean::ProcMacroItem(..) => {}\n+\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n "}, {"sha": "92d8dbed0718a5a1ecefde7e31024384de4b5188", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -15,6 +15,7 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n@@ -168,24 +169,75 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &hir::Item,\n+    pub fn visit_fn(&mut self, om: &mut Module, item: &hir::Item,\n                     name: ast::Name, fd: &hir::FnDecl,\n                     header: hir::FnHeader,\n                     gen: &hir::Generics,\n-                    body: hir::BodyId) -> Function {\n+                    body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n-        Function {\n-            id: item.id,\n-            vis: item.vis.clone(),\n-            stab: self.stability(item.id),\n-            depr: self.deprecation(item.id),\n-            attrs: item.attrs.clone(),\n-            decl: fd.clone(),\n-            name,\n-            whence: item.span,\n-            generics: gen.clone(),\n-            header,\n-            body,\n+        let macro_kind = item.attrs.iter().filter_map(|a| {\n+            if a.check_name(\"proc_macro\") {\n+                Some(MacroKind::Bang)\n+            } else if a.check_name(\"proc_macro_derive\") {\n+                Some(MacroKind::Derive)\n+            } else if a.check_name(\"proc_macro_attribute\") {\n+                Some(MacroKind::Attr)\n+            } else {\n+                None\n+            }\n+        }).next();\n+        match macro_kind {\n+            Some(kind) => {\n+                let name = if kind == MacroKind::Derive {\n+                    item.attrs.lists(\"proc_macro_derive\")\n+                              .filter_map(|mi| mi.name())\n+                              .next()\n+                              .expect(\"proc-macro derives require a name\")\n+                } else {\n+                    name\n+                };\n+\n+                let mut helpers = Vec::new();\n+                for mi in item.attrs.lists(\"proc_macro_derive\") {\n+                    if !mi.check_name(\"attributes\") {\n+                        continue;\n+                    }\n+\n+                    if let Some(list) = mi.meta_item_list() {\n+                        for inner_mi in list {\n+                            if let Some(name) = inner_mi.name() {\n+                                helpers.push(name);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                om.proc_macros.push(ProcMacro {\n+                    name,\n+                    id: item.id,\n+                    kind,\n+                    helpers,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                });\n+            }\n+            None => {\n+                om.fns.push(Function {\n+                    id: item.id,\n+                    vis: item.vis.clone(),\n+                    stab: self.stability(item.id),\n+                    depr: self.deprecation(item.id),\n+                    attrs: item.attrs.clone(),\n+                    decl: fd.clone(),\n+                    name,\n+                    whence: item.span,\n+                    generics: gen.clone(),\n+                    header,\n+                    body,\n+                });\n+            }\n         }\n     }\n \n@@ -425,7 +477,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             hir::ItemKind::Union(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n             hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n-                om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n+                self.visit_fn(om, item, name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "6aac070c45bd9d777c18867e49a500fd28efd9b3", "filename": "src/test/rustdoc/inline_cross/auxiliary/proc_macro.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fproc_macro.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"some_macros\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+/// a proc-macro that swallows its input and does nothing.\n+#[proc_macro]\n+pub fn some_proc_macro(_input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+/// a proc-macro attribute that passes its item through verbatim.\n+#[proc_macro_attribute]\n+pub fn some_proc_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\n+/// a derive attribute that adds nothing to its input.\n+#[proc_macro_derive(SomeDerive)]\n+pub fn some_derive(_item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+"}, {"sha": "a879258f82aee8a58ac7d254d2b7da99f2b6b687", "filename": "src/test/rustdoc/inline_cross/proc_macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// aux-build:proc_macro.rs\n+// build-aux-docs\n+\n+// FIXME: if/when proc-macros start exporting their doc attributes across crates, we can turn on\n+// cross-crate inlining for them\n+\n+extern crate some_macros;\n+\n+// @has proc_macro/index.html\n+// @has - '//a/@href' '../some_macros/macro.some_proc_macro.html'\n+// @has - '//a/@href' '../some_macros/attr.some_proc_attr.html'\n+// @has - '//a/@href' '../some_macros/derive.SomeDerive.html'\n+// @!has proc_macro/macro.some_proc_macro.html\n+// @!has proc_macro/attr.some_proc_attr.html\n+// @!has proc_macro/derive.SomeDerive.html\n+pub use some_macros::{some_proc_macro, some_proc_attr, SomeDerive};"}, {"sha": "bfd194701c85db8714742757102117ea51984446", "filename": "src/test/rustdoc/proc-macro.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def5f84fa64f4a64137dcfc4cc5e3007cc9257e6/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=def5f84fa64f4a64137dcfc4cc5e3007cc9257e6", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"some_macros\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+// @has some_macros/index.html\n+// @has - '//h2' 'Macros'\n+// @has - '//h2' 'Attribute Macros'\n+// @has - '//h2' 'Derive Macros'\n+// @!has - '//h2' 'Functions'\n+\n+// @has some_macros/all.html\n+// @has - '//a[@href=\"macro.some_proc_macro.html\"]' 'some_proc_macro'\n+// @has - '//a[@href=\"attr.some_proc_attr.html\"]' 'some_proc_attr'\n+// @has - '//a[@href=\"derive.SomeDerive.html\"]' 'SomeDerive'\n+// @!has - '//a/@href' 'fn.some_proc_macro.html'\n+// @!has - '//a/@href' 'fn.some_proc_attr.html'\n+// @!has - '//a/@href' 'fn.some_derive.html'\n+\n+// @has some_macros/index.html '//a/@href' 'macro.some_proc_macro.html'\n+// @!has - '//a/@href' 'fn.some_proc_macro.html'\n+// @has some_macros/macro.some_proc_macro.html\n+// @!has some_macros/fn.some_proc_macro.html\n+/// a proc-macro that swallows its input and does nothing.\n+#[proc_macro]\n+pub fn some_proc_macro(_input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+// @has some_macros/index.html '//a/@href' 'attr.some_proc_attr.html'\n+// @!has - '//a/@href' 'fn.some_proc_attr.html'\n+// @has some_macros/attr.some_proc_attr.html\n+// @!has some_macros/fn.some_proc_attr.html\n+/// a proc-macro attribute that passes its item through verbatim.\n+#[proc_macro_attribute]\n+pub fn some_proc_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\n+// @has some_macros/index.html '//a/@href' 'derive.SomeDerive.html'\n+// @!has - '//a/@href' 'fn.some_derive.html'\n+// @has some_macros/derive.SomeDerive.html\n+// @!has some_macros/fn.some_derive.html\n+/// a derive attribute that adds nothing to its input.\n+#[proc_macro_derive(SomeDerive)]\n+pub fn some_derive(_item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}]}