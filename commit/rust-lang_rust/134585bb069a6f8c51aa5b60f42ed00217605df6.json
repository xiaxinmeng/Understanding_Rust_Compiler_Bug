{"sha": "134585bb069a6f8c51aa5b60f42ed00217605df6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNDU4NWJiMDY5YTZmOGM1MWFhNWI2MGY0MmVkMDAyMTc2MDVkZjY=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-07T21:08:25Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-19T04:44:21Z"}, "message": "Add debug information for boxed and unique values.", "tree": {"sha": "643d776e565d2b044741285694293c228a6ce7a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643d776e565d2b044741285694293c228a6ce7a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134585bb069a6f8c51aa5b60f42ed00217605df6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134585bb069a6f8c51aa5b60f42ed00217605df6", "html_url": "https://github.com/rust-lang/rust/commit/134585bb069a6f8c51aa5b60f42ed00217605df6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134585bb069a6f8c51aa5b60f42ed00217605df6/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e25f6d03eb037ed905297e28edccc2346efbbc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/e25f6d03eb037ed905297e28edccc2346efbbc99", "html_url": "https://github.com/rust-lang/rust/commit/e25f6d03eb037ed905297e28edccc2346efbbc99"}], "stats": {"total": 185, "additions": 163, "deletions": 22}, "files": [{"sha": "75a374094dc16e0ee6840289b5f663cafa0852a6", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 163, "deletions": 22, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/134585bb069a6f8c51aa5b60f42ed00217605df6/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134585bb069a6f8c51aa5b60f42ed00217605df6/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=134585bb069a6f8c51aa5b60f42ed00217605df6", "patch": "@@ -1,11 +1,12 @@\n-import std::{vec, str, option, unsafe, fs, sys};\n+import std::{vec, str, option, unsafe, fs, sys, ctypes};\n import std::map::hashmap;\n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import middle::trans_common::*;\n import middle::ty;\n import syntax::{ast, codemap};\n import ast::ty;\n+import util::ppaux::ty_to_str;\n \n const LLVMDebugVersion: int = (9 << 16);\n \n@@ -21,6 +22,9 @@ const AutoVariableTag: int = 256;\n const ArgVariableTag: int = 257;\n const ReturnVariableTag: int = 258;\n const LexicalBlockTag: int = 11;\n+const PointerTypeTag: int = 15;\n+const StructureTypeTag: int = 19;\n+const MemberTag: int = 13;\n \n const DW_ATE_boolean: int = 0x02;\n const DW_ATE_float: int = 0x04;\n@@ -219,31 +223,21 @@ fn get_block_metadata(cx: @block_ctxt) -> @metadata<block_md> {\n       ret mdval;\n }\n \n-fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n+fn size_and_align_of<T>() -> (int, int) {\n+    (sys::size_of::<T>() as int, sys::align_of::<T>() as int)\n+}\n+\n+fn get_basic_type_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n+    -> @metadata<tydesc_md> {\n     let cache = cx.llmetadata;\n+    let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n-        cache, BasicTypeDescriptorTag,\n+        cache, tg,\n         {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n-    fn size_and_align_of<T>() -> (int, int) {\n-        (sys::size_of::<T>() as int, sys::align_of::<T>() as int)\n-    }\n-    let ast_ty = alt ty.node {\n-      ast::ty_infer. {\n-        alt ty::struct(ccx_tcx(cx), t) {\n-          ty::ty_bool. { ast::ty_bool }\n-          ty::ty_int. { ast::ty_int }\n-          ty::ty_uint. { ast::ty_uint }\n-          ty::ty_float. { ast::ty_float }\n-          ty::ty_machine(m) { ast::ty_machine(m) }\n-          ty::ty_char. { ast::ty_char }\n-        }\n-      }\n-      _ { ty.node }\n-    };\n-    let (name, (size, align), encoding) = alt ast_ty {\n+    let (name, (size, align), encoding) = alt ty.node {\n       ast::ty_bool. {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n       ast::ty_int. {(\"int\", size_and_align_of::<int>(), DW_ATE_signed)}\n       ast::ty_uint. {(\"uint\", size_and_align_of::<uint>(), DW_ATE_unsigned)}\n@@ -265,7 +259,7 @@ fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_\n     let fname = filename_from_span(cx, ty.span);\n     let file_node = get_file_metadata(cx, fname);\n     let cu_node = get_compile_unit_metadata(cx, fname);\n-    let lldata = [lltag(BasicTypeDescriptorTag),\n+    let lldata = [lltag(tg),\n                   cu_node.node,\n                   llstr(name),\n                   file_node.node,\n@@ -277,13 +271,160 @@ fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_\n                   lli32(encoding)];\n     let llnode = llmdnode(lldata);\n     let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n-    update_cache(cache, BasicTypeDescriptorTag, tydesc_metadata(mdval));\n+    update_cache(cache, tg, tydesc_metadata(mdval));\n+    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n+                                      str::byte_len(\"llvm.dbg.ty\"),\n+                                      llnode);\n+    ret mdval;\n+}\n+\n+fn get_pointer_type_metadata(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n+                             pointee: @metadata<tydesc_md>)\n+    -> @metadata<tydesc_md> {\n+    let tg = PointerTypeTag;\n+    /*let cache = cx.llmetadata;\n+    alt cached_metadata::<@metadata<tydesc_md>>(\n+        cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n+      option::some(md) { ret md; }\n+      option::none. {}\n+    }*/\n+    let (size, align) = size_and_align_of::<ctypes::intptr_t>();\n+    let fname = filename_from_span(cx, span);\n+    let file_node = get_file_metadata(cx, fname);\n+    //let cu_node = get_compile_unit_metadata(cx, fname);\n+    let lldata = [lltag(tg),\n+                  file_node.node,\n+                  llstr(\"\"),\n+                  file_node.node,\n+                  lli32(0), //XXX source line\n+                  lli64(size * 8),  // size in bits\n+                  lli64(align * 8), // alignment in bits\n+                  lli64(0), //XXX offset?\n+                  lli32(0),\n+                  pointee.node];\n+    let llnode = llmdnode(lldata);\n+    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    //update_cache(cache, tg, tydesc_metadata(mdval));\n+    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n+                                      str::byte_len(\"llvm.dbg.ty\"),\n+                                      llnode);\n+    ret mdval;\n+}\n+\n+fn get_boxed_type_metadata(cx: @crate_ctxt, outer: ty::t, inner: ty::t,\n+                           span: codemap::span, boxed: @metadata<tydesc_md>)\n+    -> @metadata<tydesc_md> {\n+    let tg = StructureTypeTag;\n+    /*let cache = cx.llmetadata;\n+    alt cached_metadata::<@metadata<tydesc_md>>(\n+        cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n+      option::some(md) { ret md; }\n+      option::none. {}\n+    }*/\n+    let (size, align) = size_and_align_of::<@int>();\n+    let fname = filename_from_span(cx, span);\n+    let file_node = get_file_metadata(cx, fname);\n+    //let cu_node = get_compile_unit_metadata(cx, fname);\n+    let tcx = ccx_tcx(cx);\n+    let uint_t = ty::mk_uint(tcx);\n+    let uint_ty = @{node: ast::ty_uint, span: span};\n+    let refcount_type = get_basic_type_metadata(cx, uint_t, uint_ty);\n+    /*let refcount_ptr_type = get_pointer_type_metadata(cx,\n+                                                      ty::mk_imm_uniq(tcx, uint_t),\n+                                                      span, refcount_type);*/\n+    /*let boxed_ptr_type = get_pointer_type_metadata(cx, ty::mk_imm_uniq(tcx, inner),\n+                                                   span, boxed);*/\n+    //let ptr_size = sys::size_of::<ctypes::intptr_t>() as int;\n+    //let ptr_align = sys::align_of::<ctypes::intptr_t>() as int;\n+    let size = sys::size_of::<uint>() as int * 8;\n+    let total_size = size;\n+    let refcount = [lltag(MemberTag),\n+                    file_node.node,\n+                    llstr(\"refcnt\"),\n+                    file_node.node,\n+                    lli32(0),\n+                    lli64(size),\n+                    lli64(sys::align_of::<uint>() as int * 8),\n+                    lli64(0),\n+                    lli32(0),\n+                    refcount_type.node];\n+    let size = 64; //XXX size of inner\n+    let boxed_member = [lltag(MemberTag),\n+                        file_node.node,\n+                        llstr(\"boxed\"),\n+                        file_node.node,\n+                        lli32(0),\n+                        lli64(size),\n+                        lli64(64), //XXX align of inner\n+                        lli64(total_size),\n+                        lli32(0),\n+                        boxed.node];\n+    total_size += size;\n+    let members = [llmdnode(refcount), llmdnode(boxed_member)];\n+    let lldata = [lltag(tg),\n+                  file_node.node,\n+                  llstr(ty_to_str(ccx_tcx(cx), outer)),\n+                  file_node.node,\n+                  lli32(0), //XXX source line\n+                  lli64(total_size),  // size in bits\n+                  lli64(align * 8), // alignment in bits\n+                  lli64(0), //XXX offset?\n+                  lli32(0), //XXX flags\n+                  llnull(), // derived from\n+                  llmdnode(members), // members\n+                  lli32(0) // runtime language\n+                 ];\n+    let llnode = llmdnode(lldata);\n+    let mdval = @{node: llnode, data: {hash: ty::hash_ty(outer)}};\n+    //update_cache(cache, tg, tydesc_metadata(mdval));\n     llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n                                       str::byte_len(\"llvm.dbg.ty\"),\n                                       llnode);\n     ret mdval;\n }\n \n+fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n+    fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: codemap::span) -> @ast::ty {\n+        let ty = alt ty::struct(ccx_tcx(cx), t) {\n+          ty::ty_nil. { ast::ty_nil }\n+          ty::ty_bot. { ast::ty_bot }\n+          ty::ty_bool. { ast::ty_bool }\n+          ty::ty_int. { ast::ty_int }\n+          ty::ty_float. { ast::ty_float }\n+          ty::ty_uint. { ast::ty_uint }\n+          ty::ty_machine(mt) { ast::ty_machine(mt) }\n+          ty::ty_char. { ast::ty_char }\n+          ty::ty_box(mt) { ast::ty_box({ty: t_to_ty(cx, mt.ty, span),\n+                                        mut: mt.mut}) }\n+          ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n+                                          mut: mt.mut}) }\n+        };\n+        ret @{node: ty, span: span};\n+    }\n+    alt ty.node {\n+      ast::ty_box(mt) {\n+        let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n+          ty::ty_box(boxed) { boxed.ty }\n+        };\n+        let md = get_ty_metadata(cx, inner_t, mt.ty);\n+        let box = get_boxed_type_metadata(cx, t, inner_t, ty.span, md);\n+        ret get_pointer_type_metadata(cx, t, ty.span, box);\n+      }\n+      ast::ty_uniq(mt) {\n+        let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n+          ty::ty_uniq(boxed) { boxed.ty }\n+        };\n+        let md = get_ty_metadata(cx, inner_t, mt.ty);\n+        ret get_pointer_type_metadata(cx, t, ty.span, md);\n+      }\n+      ast::ty_infer. {\n+        let inferred = t_to_ty(cx, t, ty.span);\n+        ret get_ty_metadata(cx, t, inferred);\n+      }\n+      _ { ret get_basic_type_metadata(cx, t, ty); }\n+    };\n+}\n+\n fn function_metadata_from_block(bcx: @block_ctxt) -> @metadata<subprogram_md> {\n     let cx = bcx_ccx(bcx);\n     let fcx = bcx_fcx(bcx);"}]}