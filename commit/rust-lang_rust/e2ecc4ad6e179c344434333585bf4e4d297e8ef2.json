{"sha": "e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZWNjNGFkNmUxNzljMzQ0NDM0MzMzNTg1YmY0ZTRkMjk3ZThlZjI=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2020-12-03T09:21:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-03T09:21:33Z"}, "message": "Rollup merge of #6402 - camsteffen:collapsible-match, r=llogiq\n\nAdd Collapsible match lint\n\nchangelog: Add collapsible_match lint\n\nCloses #1252\nCloses #2521\n\nThis lint finds nested `match` or `if let` patterns that can be squashed together. It is designed to be very conservative to only find cases where merging the patterns would most likely reduce cognitive complexity.\n\nExample:\n\n```rust\nmatch result {\n    Ok(opt) => match opt {\n        Some(x) => x,\n        _ => return,\n    }\n    _ => return,\n}\n```\nto\n```rust\nmatch result {\n    Ok(Some(x)) => x,\n    _ => return,\n}\n```\n\nThese criteria must be met for the lint to fire:\n\n* The inner match has exactly 2 branches.\n* Both the outer and inner match have a \"wild\" branch like `_ => ..`. There is a special case for `None => ..` to also be considered \"wild-like\".\n* The contents of the wild branches are identical.\n* The binding which \"links\" the matches is never used elsewhere.\n\nThanks to the hir, `if let`'s are easily included with this lint since they are desugared into equivalent `match`'es.\n\nI think this would fit into the style category, but I would also understand changing it to pedantic.", "tree": {"sha": "8f0d5d4794a375b5255a569be58a67eddaa756b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f0d5d4794a375b5255a569be58a67eddaa756b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfyK4dCRBK7hj4Ov3rIwAAdHIIAF895a3/Z4WHfUBJ3V/Wt5RQ\nXiviGLPw0AwVVpxB1uN6iViOHhIvywYgDz8GN9ZQdYvaiQI5S1oID7XRno5wdTv9\nmmDRbKfFnCMPE7+B9DIm9BJcEUHvf94am7brIVRWd2Ufmdz2V92zAbCAmulMedV7\nGAS9lRpSi7Mrx3axvRZCbK9mFdfp3D0KJQe6MoF6QiU459Xw/+6OBu8o9qnhDYIE\nkBVFyzPOoceO23/WPOo4stQ9P96CweFcihUSKJyVHJwpAhEVGHV4PNMEtHihJQoI\nGoGu9vFFMyCTc0h+WVSiEWCmxpDwNi7azk9x4Y5zauPqRLVgH8PZ94mDkIVT6gI=\n=+nEM\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f0d5d4794a375b5255a569be58a67eddaa756b8\nparent b3d6d6e2e77f030c63770512ae4c8e40531fa728\nparent 0e207888391fb8b55fa75d19259812b6cb97a75c\nauthor Philipp Krones <hello@philkrones.com> 1606987293 +0100\ncommitter GitHub <noreply@github.com> 1606987293 +0100\n\nRollup merge of #6402 - camsteffen:collapsible-match, r=llogiq\n\nAdd Collapsible match lint\n\nchangelog: Add collapsible_match lint\n\nCloses #1252\nCloses #2521\n\nThis lint finds nested `match` or `if let` patterns that can be squashed together. It is designed to be very conservative to only find cases where merging the patterns would most likely reduce cognitive complexity.\n\nExample:\n\n```rust\nmatch result {\n    Ok(opt) => match opt {\n        Some(x) => x,\n        _ => return,\n    }\n    _ => return,\n}\n```\nto\n```rust\nmatch result {\n    Ok(Some(x)) => x,\n    _ => return,\n}\n```\n\nThese criteria must be met for the lint to fire:\n\n* The inner match has exactly 2 branches.\n* Both the outer and inner match have a \"wild\" branch like `_ => ..`. There is a special case for `None => ..` to also be considered \"wild-like\".\n* The contents of the wild branches are identical.\n* The binding which \"links\" the matches is never used elsewhere.\n\nThanks to the hir, `if let`'s are easily included with this lint since they are desugared into equivalent `match`'es.\n\nI think this would fit into the style category, but I would also understand changing it to pedantic.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "html_url": "https://github.com/rust-lang/rust/commit/e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d6d6e2e77f030c63770512ae4c8e40531fa728", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d6d6e2e77f030c63770512ae4c8e40531fa728", "html_url": "https://github.com/rust-lang/rust/commit/b3d6d6e2e77f030c63770512ae4c8e40531fa728"}, {"sha": "0e207888391fb8b55fa75d19259812b6cb97a75c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e207888391fb8b55fa75d19259812b6cb97a75c", "html_url": "https://github.com/rust-lang/rust/commit/0e207888391fb8b55fa75d19259812b6cb97a75c"}], "stats": {"total": 961, "additions": 829, "deletions": 132}, "files": [{"sha": "e65e7cc639f7a256860ffe4f3066f263111a31a9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -1770,6 +1770,7 @@ Released 2018-09-13\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n+[`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator"}, {"sha": "a34ba2d00a8c7bc71873bcb692b8ad7498542543", "filename": "clippy_lints/src/collapsible_match.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -0,0 +1,172 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{span_lint_and_then, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{MultiSpan, Span};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+    /// without adding any branches.\n+    ///\n+    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+    /// cases where merging would most likely make the code more readable.\n+    ///\n+    /// **Why is this bad?** It is unnecessarily verbose and complex.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(n) => match n {\n+    ///             Ok(n) => n,\n+    ///             _ => return,\n+    ///         }\n+    ///         None => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(Ok(n)) => n,\n+    ///         _ => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_MATCH,\n+    style,\n+    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n+}\n+\n+declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+        if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(arm, cx.tcx)) {\n+                for arm in arms {\n+                    check_arm(arm, wild_arm, cx);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_arm(arm: &Arm<'_>, wild_outer_arm: &Arm<'_>, cx: &LateContext<'_>) {\n+    if_chain! {\n+        let expr = strip_singleton_blocks(arm.body);\n+        if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n+        // the outer arm pattern and the inner match\n+        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n+        // there must be no more than two arms in the inner match for this lint\n+        if arms_inner.len() == 2;\n+        // no if guards on the inner match\n+        if arms_inner.iter().all(|arm| arm.guard.is_none());\n+        // match expression must be a local binding\n+        // match <local> { .. }\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = expr_in.kind;\n+        if let Res::Local(binding_id) = path.res;\n+        // one of the branches must be \"wild-like\"\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n+        let (wild_inner_arm, non_wild_inner_arm) =\n+            (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n+        if !pat_contains_or(non_wild_inner_arm.pat);\n+        // the binding must come from the pattern of the containing match arm\n+        // ..<local>.. => match <local> { .. }\n+        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n+        // the \"wild-like\" branches must be equal\n+        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        // the binding must not be used in the if guard\n+        if !matches!(arm.guard, Some(Guard::If(guard)) if LocalUsedVisitor::new(binding_id).check_expr(guard));\n+        // ...or anywhere in the inner match\n+        if !arms_inner.iter().any(|arm| LocalUsedVisitor::new(binding_id).check_arm(arm));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                COLLAPSIBLE_MATCH,\n+                expr.span,\n+                \"Unnecessary nested match\",\n+                |diag| {\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n+                    help_span.push_span_label(binding_span, \"Replace this binding\".into());\n+                    help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n+                    diag.span_help(help_span, \"The outer pattern can be modified to include the inner pattern.\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    while let ExprKind::Block(block, _) = expr.kind {\n+        match (block.stmts, block.expr) {\n+            ([stmt], None) => match stmt.kind {\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n+                _ => break,\n+            },\n+            ([], Some(e)) => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n+/// A \"wild-like\" pattern is wild (\"_\") or `None`.\n+/// For this lint to apply, both the outer and inner match expressions\n+/// must have \"wild-like\" branches that can be combined.\n+fn arm_is_wild_like(arm: &Arm<'_>, tcx: TyCtxt<'_>) -> bool {\n+    if arm.guard.is_some() {\n+        return false;\n+    }\n+    match arm.pat.kind {\n+        PatKind::Binding(..) | PatKind::Wild => true,\n+        PatKind::Path(QPath::Resolved(None, path)) if is_none_ctor(path.res, tcx) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn find_pat_binding(pat: &Pat<'_>, hir_id: HirId) -> Option<Span> {\n+    let mut span = None;\n+    pat.walk_short(|p| match &p.kind {\n+        // ignore OR patterns\n+        PatKind::Or(_) => false,\n+        PatKind::Binding(_bm, _, _ident, _) => {\n+            let found = p.hir_id == hir_id;\n+            if found {\n+                span = Some(p.span);\n+            }\n+            !found\n+        },\n+        _ => true,\n+    });\n+    span\n+}\n+\n+fn pat_contains_or(pat: &Pat<'_>) -> bool {\n+    let mut result = false;\n+    pat.walk(|p| {\n+        let is_or = matches!(p.kind, PatKind::Or(_));\n+        result |= is_or;\n+        !is_or\n+    });\n+    result\n+}\n+\n+fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n+    if let Some(none_id) = tcx.lang_items().option_none_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = res {\n+            if let Some(variant_id) = tcx.parent(id) {\n+                return variant_id == none_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "f69f6f1412af97d0c35cfc044b887dd6111def9e", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -280,8 +280,7 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         // only take assignments to fields where the left-hand side field is a field of\n         // the same binding as the previous statement\n         if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n-        if let ExprKind::Path(ref qpath) = binding.kind;\n-        if let QPath::Resolved(_, path) = qpath;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = binding.kind;\n         if let Some(second_binding_name) = path.segments.last();\n         if second_binding_name.ident.name == binding_name;\n         then {"}, {"sha": "1194bd7e55e2566e5ad5c20f741d8888829e5e5f", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -41,8 +41,7 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(ref op, ref body, source) = expr.kind; //test if expr is a match\n-            if let MatchSource::IfLetDesugar { .. } = source; //test if it is an If Let\n+            if let ExprKind::Match(ref op, ref body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;"}, {"sha": "03e95c9e27f6ae241627945d537a629306da4d73", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -68,8 +68,7 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 if_chain! {\n                     if let StmtKind::Semi(expr, ..) = &stmt.kind;\n                     // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., break_expr) = &expr.kind;\n-                    if let Some(break_expr) = break_expr;\n+                    if let ExprKind::Break(.., Some(break_expr)) = &expr.kind;\n                     then {\n                             lint(cx, expr.span, break_expr.span, LINT_BREAK);\n                     }"}, {"sha": "3a01acd8fdc97a94e779a93ce6b3123d43fd4662", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -59,8 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             if let Some(target) = subtracts_one(cx, e);\n \n             // Extracting out the variable name\n-            if let ExprKind::Path(ref assign_path) = target.kind;\n-            if let QPath::Resolved(_, ref ares_path) = assign_path;\n+            if let ExprKind::Path(QPath::Resolved(_, ref ares_path)) = target.kind;\n \n             then {\n                 // Handle symmetric conditions in the if statement"}, {"sha": "a76595ed0897dd85ffa73afc66bfe79211d4392b", "filename": "clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -52,8 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(val) = cst.val;\n-            if let ConstValue::Scalar(element_count) = val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n             if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;"}, {"sha": "9a448ab125686cf2ce405a7ca9c1a84416b800c7", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -43,8 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(val) = cst.val;\n-            if let ConstValue::Scalar(element_count) = val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n             if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;"}, {"sha": "0d2d95324c4f7556f400230f5b33e852f9b2099c", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -1,12 +1,11 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{higher, qpath_res, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::intravisit;\n use rustc_hir::BindingAnnotation;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -66,10 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(ref if_) = expr.kind;\n                 if let Some((ref cond, ref then, ref else_)) = higher::if_block(&if_);\n-                if !used_in_expr(cx, canonical_id, cond);\n+                if !LocalUsedVisitor::new(canonical_id).check_expr(cond);\n                 if let hir::ExprKind::Block(ref then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_in_expr(cx, canonical_id, value);\n+                if !LocalUsedVisitor::new(canonical_id).check_expr(value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -136,32 +135,6 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n     }\n }\n \n-struct UsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    id: hir::HirId,\n-    used: bool,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = expr.kind;\n-            if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n-            if self.id == local_id;\n-            then {\n-                self.used = true;\n-                return;\n-            }\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n fn check_assign<'tcx>(\n     cx: &LateContext<'tcx>,\n     decl: hir::HirId,\n@@ -176,18 +149,10 @@ fn check_assign<'tcx>(\n         if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n         if decl == local_id;\n         then {\n-            let mut v = UsedVisitor {\n-                cx,\n-                id: decl,\n-                used: false,\n-            };\n-\n-            for s in block.stmts.iter().take(block.stmts.len()-1) {\n-                intravisit::walk_stmt(&mut v, s);\n+            let mut v = LocalUsedVisitor::new(decl);\n \n-                if v.used {\n-                    return None;\n-                }\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n+                return None;\n             }\n \n             return Some(value);\n@@ -196,9 +161,3 @@ fn check_assign<'tcx>(\n \n     None\n }\n-\n-fn used_in_expr<'tcx>(cx: &LateContext<'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n-    let mut v = UsedVisitor { cx, id, used: false };\n-    intravisit::walk_expr(&mut v, expr);\n-    v.used\n-}"}, {"sha": "167e5b6b87fed21fa4d9f167fe8089becd77dfb7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -172,6 +172,7 @@ mod cargo_common_metadata;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n+mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -549,6 +550,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n         &collapsible_if::COLLAPSIBLE_IF,\n+        &collapsible_match::COLLAPSIBLE_MATCH,\n         &comparison_chain::COMPARISON_CHAIN,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n@@ -978,6 +980,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box len_zero::LenZero);\n     store.register_late_pass(|| box attrs::Attributes);\n     store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n+    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n     store.register_late_pass(|| box unicode::Unicode);\n     store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n     store.register_late_pass(|| box strings::StringAdd);\n@@ -1359,6 +1362,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n@@ -1625,6 +1629,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&doc::MISSING_SAFETY_DOC),"}, {"sha": "400148ab81dd997d20050228c4e6d2a39ebf0d69", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -2,6 +2,7 @@ use crate::consts::constant;\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n+use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n@@ -1919,8 +1920,7 @@ fn check_for_single_element_loop<'tcx>(\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n         if let PatKind::Binding(.., target, _) = pat.kind;\n-        if let ExprKind::Array(ref arg_expr_list) = arg_expr.kind;\n-        if let [arg_expression] = arg_expr_list;\n+        if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n         if let ExprKind::Path(ref list_item) = arg_expression.kind;\n         if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(ref block, _) = body.kind;\n@@ -2025,8 +2025,7 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n                 let node_str = cx.tcx.hir().get(hir_id);\n                 if_chain! {\n                     if let Node::Binding(pat) = node_str;\n-                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                    if let BindingAnnotation::Mutable = bind_ann;\n+                    if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n                     then {\n                         return Some(hir_id);\n                     }\n@@ -2071,28 +2070,6 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     }\n }\n \n-struct LocalUsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    local: HirId,\n-    used: bool,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LocalUsedVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if same_var(self.cx, expr, self.local) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n struct VarVisitor<'a, 'tcx> {\n     /// context reference\n     cx: &'a LateContext<'tcx>,\n@@ -2126,11 +2103,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             then {\n                 let index_used_directly = same_var(self.cx, idx, self.var);\n                 let indexed_indirectly = {\n-                    let mut used_visitor = LocalUsedVisitor {\n-                        cx: self.cx,\n-                        local: self.var,\n-                        used: false,\n-                    };\n+                    let mut used_visitor = LocalUsedVisitor::new(self.var);\n                     walk_expr(&mut used_visitor, idx);\n                     used_visitor.used\n                 };"}, {"sha": "3c4368a3545a9f71b5a432b700a630e652b70250", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -219,8 +219,7 @@ fn find_stripping<'tcx>(\n                 if is_ref_str(self.cx, ex);\n                 let unref = peel_ref(ex);\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n-                if let Some(range) = higher::range(index);\n-                if let higher::Range { start, end, .. } = range;\n+                if let Some(higher::Range { start, end, .. }) = higher::range(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n                 if qpath_res(self.cx, path, ex.hir_id) == self.target;\n                 then {"}, {"sha": "274d20cfa8005b772f3aabeb9866b524d67fed95", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -646,8 +646,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), pat.span);\n             if !in_macro(pat.span);\n-            if let PatKind::Struct(ref qpath, fields, true) = pat.kind;\n-            if let QPath::Resolved(_, ref path) = qpath;\n+            if let PatKind::Struct(QPath::Resolved(_, ref path), fields, true) = pat.kind;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n             if let ty::Adt(def, _) = ty.kind();\n@@ -956,16 +955,14 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                 if let QPath::Resolved(_, p) = path {\n                     missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n-            } else if let PatKind::TupleStruct(ref path, ref patterns, ..) = arm.pat.kind {\n-                if let QPath::Resolved(_, p) = path {\n-                    // Some simple checks for exhaustive patterns.\n-                    // There is a room for improvements to detect more cases,\n-                    // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive =\n-                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n-                    if patterns.iter().all(is_pattern_exhaustive) {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n-                    }\n+            } else if let PatKind::TupleStruct(QPath::Resolved(_, p), ref patterns, ..) = arm.pat.kind {\n+                // Some simple checks for exhaustive patterns.\n+                // There is a room for improvements to detect more cases,\n+                // but it can be more expensive to do so.\n+                let is_pattern_exhaustive =\n+                    |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n+                if patterns.iter().all(is_pattern_exhaustive) {\n+                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n             }\n         }\n@@ -1440,8 +1437,7 @@ fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n         if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprKind::Path(ref qpath) = args[0].kind;\n-        if let &QPath::Resolved(_, ref path2) = qpath;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n             return Some(rb)"}, {"sha": "44c974b9d98577c2add2c02bedb8f8e1feea592e", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -90,8 +90,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     if_chain! {\n         if let hir::ExprKind::Call(func, args) = &expr.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(path) = &func.kind;\n-        if let hir::QPath::TypeRelative(_, segment) = path;\n+        if let hir::ExprKind::Path(hir::QPath::TypeRelative(_, segment)) = &func.kind;\n         then {\n             match &*segment.ident.as_str() {\n                 \"max_value\" => return Some(MinMax::Max),"}, {"sha": "42f97b2ac497aa3151bda4f96da00c3a190b9930", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -6,7 +6,6 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{\n     higher, is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg,\n };\n-use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -198,13 +197,9 @@ struct ExpressionInfoWithSpan {\n }\n \n fn is_unary_not(e: &Expr<'_>) -> (bool, Span) {\n-    if_chain! {\n-        if let ExprKind::Unary(unop, operand) = e.kind;\n-        if let UnOp::UnNot = unop;\n-        then {\n-            return (true, operand.span);\n-        }\n-    };\n+    if let ExprKind::Unary(UnOp::UnNot, operand) = e.kind {\n+        return (true, operand.span);\n+    }\n     (false, e.span)\n }\n "}, {"sha": "b91233ac582808dd7916039fe4c219bf4862634d", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -176,8 +176,7 @@ impl QuestionMark {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n             if let StmtKind::Semi(ref expr) = expr.kind;\n-            if let ExprKind::Ret(ret_expr) = expr.kind;\n-            if let Some(ret_expr) = ret_expr;\n+            if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n \n             then {\n                 return Some(ret_expr);"}, {"sha": "77e790733789c23c061436734afb9b15b5073d2c", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -222,8 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             if method_names[0] == sym!(as_bytes);\n \n             // Check for slicer\n-            if let ExprKind::Struct(ref path, _, _) = right.kind;\n-            if let QPath::LangItem(LangItem::Range, _) = path;\n+            if let ExprKind::Struct(QPath::LangItem(LangItem::Range, _), _, _) = right.kind;\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "daff5f81e8c34c926a830089025eff5294a7d540", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -168,8 +168,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !in_macro(bound_predicate.span);\n-            if let TyKind::Path(ref path) = bound_predicate.bounded_ty.kind;\n-            if let QPath::Resolved(_, Path { ref segments, .. }) = path;\n+            if let TyKind::Path(QPath::Resolved(_, Path { ref segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {"}, {"sha": "6b171a0fa1af2ef2058f402837237f957153908f", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -48,8 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 if_chain! {\n                     if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);\n-                    if let Some(constant) = x;\n-                    if let Constant::RawPtr(0) = constant;\n+                    if let Some(Constant::RawPtr(0)) = x;\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n                     }"}, {"sha": "74ba53e6a9a02fbd9c7f90b63ed72e8d58ea00c9", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -738,8 +738,7 @@ fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n     if_chain! {\n         if let Some(did) = qpath_res(cx, qpath, id).opt_def_id();\n-        if let Some(node) = cx.tcx.hir().get_if_local(did);\n-        if let Node::GenericParam(generic_param) = node;\n+        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n         then {\n@@ -1470,8 +1469,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // don't lint for positive constants\n     let const_val = constant(cx, &cx.typeck_results(), op);\n     if_chain! {\n-        if let Some((const_val, _)) = const_val;\n-        if let Constant::Int(n) = const_val;\n+        if let Some((Constant::Int(n), _)) = const_val;\n         if let ty::Int(ity) = *cast_from.kind();\n         if sext(cx.tcx, n, ity) >= 0;\n         then {"}, {"sha": "01ffac5b5599d547dee26056a8f549b574e3a799", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -162,8 +162,7 @@ pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n         if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n         if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n-        if let [arm, ..] = &arms[..];\n-        if let hir::Arm { body, .. } = arm;\n+        if let [hir::Arm { body, .. }, ..] = &arms[..];\n         then {\n             return Some((cond, body));\n         }"}, {"sha": "d847d22275e831df1ff791418da5a2e02891cf22", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             }\n         }\n \n-        match (&left.kind, &right.kind) {\n+        match (&reduce_exprkind(&left.kind), &reduce_exprkind(&right.kind)) {\n             (&ExprKind::AddrOf(lb, l_mut, ref le), &ExprKind::AddrOf(rb, r_mut, ref re)) => {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n@@ -306,6 +306,32 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n+/// Some simple reductions like `{ return }` => `return`\n+fn reduce_exprkind<'hir>(kind: &'hir ExprKind<'hir>) -> &ExprKind<'hir> {\n+    if let ExprKind::Block(block, _) = kind {\n+        match (block.stmts, block.expr) {\n+            // `{}` => `()`\n+            ([], None) => &ExprKind::Tup(&[]),\n+            ([], Some(expr)) => match expr.kind {\n+                // `{ return .. }` => `return ..`\n+                ExprKind::Ret(..) => &expr.kind,\n+                _ => kind,\n+            },\n+            ([stmt], None) => match stmt.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n+                    // `{ return ..; }` => `return ..`\n+                    ExprKind::Ret(..) => &expr.kind,\n+                    _ => kind,\n+                },\n+                _ => kind,\n+            },\n+            _ => kind,\n+        }\n+    } else {\n+        kind\n+    }\n+}\n+\n fn swap_binop<'a>(\n     binop: BinOpKind,\n     lhs: &'a Expr<'a>,"}, {"sha": "28b3e79d7a6d6d9646edbb7804d1ddf6fad3a3d3", "filename": "clippy_lints/src/utils/visitors.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -1,5 +1,7 @@\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, QPath, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -123,3 +125,54 @@ where\n         !ret_finder.failed\n     }\n }\n+\n+pub struct LocalUsedVisitor {\n+    pub local_hir_id: HirId,\n+    pub used: bool,\n+}\n+\n+impl LocalUsedVisitor {\n+    pub fn new(local_hir_id: HirId) -> Self {\n+        Self {\n+            local_hir_id,\n+            used: false,\n+        }\n+    }\n+\n+    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n+        visit(self, t);\n+        std::mem::replace(&mut self.used, false)\n+    }\n+\n+    pub fn check_arm(&mut self, arm: &Arm<'_>) -> bool {\n+        self.check(arm, Self::visit_arm)\n+    }\n+\n+    pub fn check_expr(&mut self, expr: &Expr<'_>) -> bool {\n+        self.check(expr, Self::visit_expr)\n+    }\n+\n+    pub fn check_stmt(&mut self, stmt: &Stmt<'_>) -> bool {\n+        self.check(stmt, Self::visit_stmt)\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for LocalUsedVisitor {\n+    type Map = Map<'v>;\n+\n+    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n+            if let Res::Local(id) = path.res {\n+                if id == self.local_hir_id {\n+                    self.used = true;\n+                    return;\n+                }\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "a83e6c77b12e5bc38dc8b76a76611d539160d91a", "filename": "tests/ui/collapsible_match.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -0,0 +1,239 @@\n+#![warn(clippy::collapsible_match)]\n+#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+\n+fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n+    // match without block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // match with block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if let, if let\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        }\n+    }\n+\n+    // if let else, if let else\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        } else {\n+            return;\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // if let, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => (),\n+        }\n+    }\n+\n+    // match, if let\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    // if let else, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // match, if let else\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // None in inner match same as outer wild branch\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            None => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // None in outer match same as inner wild branch\n+    match opt_opt {\n+        Some(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        None => return,\n+    }\n+}\n+\n+fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u32, String>, String>) {\n+    // no wild pattern in outer match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        Err(_) => return,\n+    }\n+\n+    // inner branch is not wild or None\n+    match res_res {\n+        Ok(val) => match val {\n+            Ok(n) => foo(n),\n+            Err(_) => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // statement before inner match\n+    match res_opt {\n+        Ok(val) => {\n+            \"hi buddy\";\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // statement after inner match\n+    match res_opt {\n+        Ok(val) => {\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+            \"hi buddy\";\n+        },\n+        _ => return,\n+    }\n+\n+    // wild branches do not match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => {\n+                \"sup\";\n+                return;\n+            },\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in if guard\n+    match res_opt {\n+        Ok(val) if val.is_some() => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in inner match body\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(_) => take(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if guard on inner match\n+    {\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) if make() => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                _ => make(),\n+                _ if make() => return,\n+            },\n+            _ => return,\n+        }\n+    }\n+\n+    // differing macro contexts\n+    {\n+        macro_rules! mac {\n+            ($val:ident) => {\n+                match $val {\n+                    Some(n) => foo(n),\n+                    _ => return,\n+                }\n+            };\n+        }\n+        match res_opt {\n+            Ok(val) => mac!(val),\n+            _ => return,\n+        }\n+    }\n+\n+    // OR pattern\n+    enum E<T> {\n+        A(T),\n+        B(T),\n+        C(T),\n+    };\n+    match make::<E<Option<u32>>>() {\n+        E::A(val) | E::B(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+    match make::<Option<E<u32>>>() {\n+        Some(val) => match val {\n+            E::A(val) | E::B(val) => foo(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+}\n+\n+fn make<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn foo<T, U>(t: T) -> U {\n+    unimplemented!()\n+}\n+\n+fn take<T>(t: T) {}\n+\n+fn main() {}"}, {"sha": "63ac6a1613dc648ce44a90a139d768d18e2a7788", "filename": "tests/ui/collapsible_match.stderr", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.stderr?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -0,0 +1,179 @@\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:7:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+   = note: `-D clippy::collapsible-match` implied by `-D warnings`\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:7:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:16:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:16:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:25:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:24:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:32:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         } else {\n+LL | |             return;\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:31:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:43:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => (),\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:42:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:52:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:51:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:61:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:60:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:72:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             } else {\n+LL | |                 return;\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:71:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:83:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             None => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:83:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:92:22\n+   |\n+LL |           Some(val) => match val {\n+   |  ______________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:92:14\n+   |\n+LL |         Some(val) => match val {\n+   |              ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "d571ac4ab693e3cc1415cfe200b840c41617c92d", "filename": "tests/ui/collapsible_match2.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.rs?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -0,0 +1,53 @@\n+#![warn(clippy::collapsible_match)]\n+#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+\n+fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n+    // if guards on outer match\n+    {\n+        match res_opt {\n+            Ok(val) if make() => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ if make() => return,\n+            _ => return,\n+        }\n+    }\n+\n+    // macro\n+    {\n+        macro_rules! mac {\n+            ($outer:expr => $pat:pat, $e:expr => $inner_pat:pat, $then:expr) => {\n+                match $outer {\n+                    $pat => match $e {\n+                        $inner_pat => $then,\n+                        _ => return,\n+                    },\n+                    _ => return,\n+                }\n+            };\n+        }\n+        // Lint this since the patterns are not defined by the macro.\n+        // Allows the lint to work on if_chain! for example.\n+        // Fixing the lint requires knowledge of the specific macro, but we optimistically assume that\n+        // there is still a better way to write this.\n+        mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+    }\n+}\n+\n+fn make<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn foo<T, U>(t: T) -> U {\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "490d82d12cd59d3099b750d112174c034e1bc013", "filename": "tests/ui/collapsible_match2.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecc4ad6e179c344434333585bf4e4d297e8ef2/tests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.stderr?ref=e2ecc4ad6e179c344434333585bf4e4d297e8ef2", "patch": "@@ -0,0 +1,61 @@\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:8:34\n+   |\n+LL |               Ok(val) if make() => match val {\n+   |  __________________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+   = note: `-D clippy::collapsible-match` implied by `-D warnings`\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:8:16\n+   |\n+LL |             Ok(val) if make() => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:15:24\n+   |\n+LL |               Ok(val) => match val {\n+   |  ________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:15:16\n+   |\n+LL |             Ok(val) => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:29:29\n+   |\n+LL |                       $pat => match $e {\n+   |  _____________________________^\n+LL | |                         $inner_pat => $then,\n+LL | |                         _ => return,\n+LL | |                     },\n+   | |_____________________^\n+...\n+LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |           ------------------------------------------------- in this macro invocation\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:41:28\n+   |\n+LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |                            ^^^          ^^^^^^^ with this pattern\n+   |                            |\n+   |                            Replace this binding\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}]}