{"sha": "3d693d74b814eed6140b9ca29ff01eb3411255a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNjkzZDc0YjgxNGVlZDYxNDBiOWNhMjlmZjAxZWIzNDExMjU1YTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-12T21:40:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-15T01:00:54Z"}, "message": "rustdoc: Use privacy visibility for pruning\n\nThis commit ends rustdoc's approximation of privacy and instead uses the result\nof the various compiler passes instead.\n\nCloses #9827", "tree": {"sha": "d7a020d5a6420947a646cee46ba14be16c183120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7a020d5a6420947a646cee46ba14be16c183120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d693d74b814eed6140b9ca29ff01eb3411255a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d693d74b814eed6140b9ca29ff01eb3411255a2", "html_url": "https://github.com/rust-lang/rust/commit/3d693d74b814eed6140b9ca29ff01eb3411255a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d693d74b814eed6140b9ca29ff01eb3411255a2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7e8957c591651b6568d1b495d29ee85d11c0975", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e8957c591651b6568d1b495d29ee85d11c0975", "html_url": "https://github.com/rust-lang/rust/commit/a7e8957c591651b6568d1b495d29ee85d11c0975"}], "stats": {"total": 253, "additions": 166, "deletions": 87}, "files": [{"sha": "ef8b859efd63e102de80ba07e827921fe4b97d84", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3d693d74b814eed6140b9ca29ff01eb3411255a2", "patch": "@@ -199,6 +199,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n \n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n+    exported_items: middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @mut HashSet<ast::NodeId>\n@@ -310,6 +311,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     CrateAnalysis {\n         exp_map2: exp_map2,\n         ty_cx: ty_cx,\n+        exported_items: exported_items,\n         maps: astencode::Maps {\n             root_map: root_map,\n             method_map: method_map,"}, {"sha": "69d9f8f5946d75fd126424777e914d00f7ec02f6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3d693d74b814eed6140b9ca29ff01eb3411255a2", "patch": "@@ -10,14 +10,17 @@\n \n use rustc;\n use rustc::{driver, middle};\n+use rustc::middle::privacy;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n use syntax::diagnostic;\n use syntax::parse;\n use syntax;\n \n use std::os;\n use std::local_data;\n+use std::hashmap::HashMap;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -29,10 +32,19 @@ pub struct DocContext {\n     sess: driver::session::Session\n }\n \n+pub struct CrateAnalysis {\n+    exported_items: privacy::ExportedItems,\n+    reexports: HashMap<ast::NodeId, ~[ast::NodeId]>,\n+}\n+\n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n+fn get_ast_and_resolve(cpath: &Path,\n+                       libs: ~[Path]) -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n-    use rustc::driver::driver::*;\n+    use rustc::driver::driver::{file_input, build_configuration,\n+                                phase_1_parse_input,\n+                                phase_2_configure_and_expand,\n+                                phase_3_run_analysis_passes};\n \n     let parsesess = parse::new_parse_sess(None);\n     let input = file_input(cpath.clone());\n@@ -60,14 +72,26 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n \n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = phase_3_run_analysis_passes(sess, &crate);\n+    let driver::driver::CrateAnalysis {\n+        exported_items, ty_cx, exp_map2, _\n+    } = phase_3_run_analysis_passes(sess, &crate);\n+\n+    let mut reexports = HashMap::new();\n+    for (&module, nodes) in exp_map2.iter() {\n+        reexports.insert(module, nodes.iter()\n+                                      .filter(|e| e.reexport && is_local(e.def_id))\n+                                      .map(|e| e.def_id.node)\n+                                      .to_owned_vec());\n+    }\n \n     debug2!(\"crate: {:?}\", crate);\n-    DocContext { crate: crate, tycx: analysis.ty_cx, sess: sess }\n+    return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n+            CrateAnalysis { reexports: reexports, exported_items: exported_items });\n }\n \n-pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n-    let ctxt = @get_ast_and_resolve(path, libs);\n+pub fn run_core (libs: ~[Path], path: &Path) -> (clean::Crate, CrateAnalysis) {\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs);\n+    let ctxt = @ctxt;\n     debug2!(\"defmap:\");\n     for (k, v) in ctxt.tycx.def_map.iter() {\n         debug2!(\"{:?}: {:?}\", k, v);\n@@ -77,5 +101,5 @@ pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n     let v = @mut RustdocVisitor::new();\n     v.visit(&ctxt.crate);\n \n-    v.clean()\n+    (v.clean(), analysis)\n }"}, {"sha": "5b27adb2967043c9c4ea0569a293c4c20a862c62", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3d693d74b814eed6140b9ca29ff01eb3411255a2", "patch": "@@ -582,7 +582,7 @@ impl DocFolder for Cache {\n             clean::StructItem(*) | clean::EnumItem(*) |\n             clean::TypedefItem(*) | clean::TraitItem(*) |\n             clean::FunctionItem(*) | clean::ModuleItem(*) |\n-            clean::VariantItem(*) => {\n+            clean::ForeignFunctionItem(*) | clean::VariantItem(*) => {\n                 self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n             }\n             _ => {}"}, {"sha": "aa419a90563b75e71aea168e469ce700fa2420e5", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 128, "deletions": 78, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=3d693d74b814eed6140b9ca29ff01eb3411255a2", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use std::num;\n+use std::cell::Cell;\n use std::uint;\n use std::hashmap::HashSet;\n+use std::local_data;\n \n use syntax::ast;\n \n+use core;\n use clean;\n use clean::Item;\n use plugins;\n@@ -51,110 +54,157 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut crate: clean::Crate) -> plugins::PluginResult {\n+pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n-    struct Stripper<'self>(&'self mut HashSet<ast::NodeId>);\n-    impl<'self> fold::DocFolder for Stripper<'self> {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            match i.inner {\n-                // These items can all get re-exported\n-                clean::TypedefItem(*) | clean::StaticItem(*) |\n-                clean::StructItem(*) | clean::EnumItem(*) |\n-                clean::TraitItem(*) | clean::FunctionItem(*) |\n-                clean::ViewItemItem(*) | clean::MethodItem(*) |\n-                clean::ForeignFunctionItem(*) | clean::ForeignStaticItem(*) => {\n-                    // XXX: re-exported items should get surfaced in the docs as\n-                    //      well (using the output of resolve analysis)\n-                    if i.visibility != Some(ast::public) {\n-                        return None;\n-                    }\n-                }\n+    let mut retained = HashSet::new();\n+    let crate = Cell::new(crate);\n+    let exported_items = do local_data::get(super::analysiskey) |analysis| {\n+        let analysis = analysis.unwrap();\n+        let mut exported_items = analysis.exported_items.clone();\n+        {\n+            let mut finder = ExportedItemsFinder {\n+                exported_items: &mut exported_items,\n+                analysis: analysis,\n+            };\n+            let c = finder.fold_crate(crate.take());\n+            crate.put_back(c);\n+        }\n+        exported_items\n+    };\n+    let mut crate = crate.take();\n \n-                // These are public-by-default (if the enum/struct was public)\n-                clean::VariantItem(*) | clean::StructFieldItem(*) => {\n-                    if i.visibility == Some(ast::private) {\n-                        return None;\n+    // strip all private items\n+    {\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            exported_items: &exported_items,\n+        };\n+        crate = stripper.fold_crate(crate);\n+    }\n+\n+    // strip all private implementations of traits\n+    {\n+        let mut stripper = ImplStripper(&retained);\n+        crate = stripper.fold_crate(crate);\n+    }\n+    (crate, None)\n+}\n+\n+struct ExportedItemsFinder<'self> {\n+    exported_items: &'self mut HashSet<ast::NodeId>,\n+    analysis: &'self core::CrateAnalysis,\n+}\n+\n+impl<'self> fold::DocFolder for ExportedItemsFinder<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ModuleItem(*) => {\n+                if self.analysis.exported_items.contains(&i.id) {\n+                    match self.analysis.reexports.find(&i.id) {\n+                        Some(l) => {\n+                            for &id in l.iter() {\n+                                self.exported_items.insert(id);\n+                            }\n+                        }\n+                        None => {}\n                     }\n                 }\n+            }\n+            _ => {}\n+        }\n+        return self.fold_item_recur(i);\n+    }\n+}\n+\n+struct Stripper<'self> {\n+    retained: &'self mut HashSet<ast::NodeId>,\n+    exported_items: &'self HashSet<ast::NodeId>,\n+}\n \n-                // handled below\n-                clean::ModuleItem(*) => {}\n+impl<'self> fold::DocFolder for Stripper<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            // These items can all get re-exported\n+            clean::TypedefItem(*) | clean::StaticItem(*) |\n+            clean::StructItem(*) | clean::EnumItem(*) |\n+            clean::TraitItem(*) | clean::FunctionItem(*) |\n+            clean::VariantItem(*) | clean::MethodItem(*) |\n+            clean::ForeignFunctionItem(*) | clean::ForeignStaticItem(*) => {\n+                if !self.exported_items.contains(&i.id) {\n+                    return None;\n+                }\n+            }\n \n-                // impls/tymethods have no control over privacy\n-                clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+            clean::ViewItemItem(*) | clean::StructFieldItem(*) => {\n+                if i.visibility != Some(ast::public) {\n+                    return None;\n+                }\n             }\n \n-            let fastreturn = match i.inner {\n-                // nothing left to do for traits (don't want to filter their\n-                // methods out, visibility controlled by the trait)\n-                clean::TraitItem(*) => true,\n+            // handled below\n+            clean::ModuleItem(*) => {}\n \n-                // implementations of traits are always public.\n-                clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // impls/tymethods have no control over privacy\n+            clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+        }\n \n-                _ => false,\n-            };\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(*) => true,\n \n-            let i = if fastreturn {\n-                self.insert(i.id);\n-                return Some(i);\n-            } else {\n-                self.fold_item_recur(i)\n-            };\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n \n-            match i {\n-                Some(i) => {\n-                    match i.inner {\n-                        // emptied modules/impls have no need to exist\n-                        clean::ModuleItem(ref m) if m.items.len() == 0 => None,\n-                        clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n-                        _ => {\n-                            self.insert(i.id);\n-                            Some(i)\n-                        }\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            self.retained.insert(i.id);\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        match i {\n+            Some(i) => {\n+                match i.inner {\n+                    // emptied modules/impls have no need to exist\n+                    clean::ModuleItem(ref m) if m.items.len() == 0 => None,\n+                    clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n+                    _ => {\n+                        self.retained.insert(i.id);\n+                        Some(i)\n                     }\n                 }\n-                None => None,\n             }\n+            None => None,\n         }\n     }\n+}\n \n-    // This stripper discards all private impls of traits\n-    struct ImplStripper<'self>(&'self HashSet<ast::NodeId>);\n-    impl<'self> fold::DocFolder for ImplStripper<'self> {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            match i.inner {\n-                clean::ImplItem(ref imp) => {\n-                    match imp.trait_ {\n-                        Some(clean::ResolvedPath{ id, _ }) => {\n-                            if !self.contains(&id) {\n-                                return None;\n-                            }\n+// This stripper discards all private impls of traits\n+struct ImplStripper<'self>(&'self HashSet<ast::NodeId>);\n+impl<'self> fold::DocFolder for ImplStripper<'self> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ImplItem(ref imp) => {\n+                match imp.trait_ {\n+                    Some(clean::ResolvedPath{ id, _ }) => {\n+                        if !self.contains(&id) {\n+                            return None;\n                         }\n-                        Some(*) | None => {}\n                     }\n+                    Some(*) | None => {}\n                 }\n-                _ => {}\n             }\n-            self.fold_item_recur(i)\n+            _ => {}\n         }\n+        self.fold_item_recur(i)\n     }\n-\n-    let mut retained = HashSet::new();\n-    // First, strip all private items\n-    {\n-        let mut stripper = Stripper(&mut retained);\n-        crate = stripper.fold_crate(crate);\n-    }\n-\n-    // Next, strip all private implementations of traits\n-    {\n-        let mut stripper = ImplStripper(&retained);\n-        crate = stripper.fold_crate(crate);\n-    }\n-    (crate, None)\n }\n \n+\n pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n     struct CommentCleaner;\n     impl fold::DocFolder for CommentCleaner {"}, {"sha": "e989796ae8876ea97e03700618b053586b9c84cd", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d693d74b814eed6140b9ca29ff01eb3411255a2/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=3d693d74b814eed6140b9ca29ff01eb3411255a2", "patch": "@@ -24,6 +24,7 @@ extern mod rustc;\n extern mod extra;\n \n use std::cell::Cell;\n+use std::local_data;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n use std::rt::io;\n@@ -73,6 +74,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n ];\n \n local_data_key!(pub ctxtkey: @core::DocContext)\n+local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, ~[plugins::PluginJson]);\n \n@@ -191,11 +193,12 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n     let cr = Cell::new(Path(cratefile));\n     info2!(\"starting to run rustc\");\n-    let crate = do std::task::try {\n+    let (crate, analysis) = do std::task::try {\n         let cr = cr.take();\n         core::run_core(libs.take(), &cr)\n     }.unwrap();\n     info2!(\"finished with rustc\");\n+    local_data::set(analysiskey, analysis);\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run."}]}