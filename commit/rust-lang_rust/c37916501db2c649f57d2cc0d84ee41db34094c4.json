{"sha": "c37916501db2c649f57d2cc0d84ee41db34094c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNzkxNjUwMWRiMmM2NDlmNTdkMmNjMGQ4NGVlNDFkYjM0MDk0YzQ=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-27T13:41:55Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-27T13:49:55Z"}, "message": "Move lints related to must_use to their own module", "tree": {"sha": "160af35a88ca6e747850c316b51fb90c7109d3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/160af35a88ca6e747850c316b51fb90c7109d3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c37916501db2c649f57d2cc0d84ee41db34094c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c37916501db2c649f57d2cc0d84ee41db34094c4", "html_url": "https://github.com/rust-lang/rust/commit/c37916501db2c649f57d2cc0d84ee41db34094c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c37916501db2c649f57d2cc0d84ee41db34094c4/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9782fc42852927428736f27f0496deece545f46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9782fc42852927428736f27f0496deece545f46c", "html_url": "https://github.com/rust-lang/rust/commit/9782fc42852927428736f27f0496deece545f46c"}], "stats": {"total": 531, "additions": 283, "deletions": 248}, "files": [{"sha": "a1f4a453608dca8f8b65a21707b96a3f7ebd55d8", "filename": "clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 11, "deletions": 248, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/c37916501db2c649f57d2cc0d84ee41db34094c4/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37916501db2c649f57d2cc0d84ee41db34094c4/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=c37916501db2c649f57d2cc0d84ee41db34094c4", "patch": "@@ -1,22 +1,17 @@\n+mod must_use;\n mod not_unsafe_ptr_arg_deref;\n mod too_many_arguments;\n mod too_many_lines;\n \n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item};\n-use clippy_utils::{attr_by_name, attrs::is_proc_macro, match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::trait_ref_of_method;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n-use rustc_ast::ast::Attribute;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n-use rustc_hir::{def::Res, def_id::DefId, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n@@ -260,88 +255,38 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n-        if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+        must_use::check_item(cx, item);\n+        if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n             let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-                return;\n-            }\n-            if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this function could have a `#[must_use]` attribute\",\n-                );\n-            }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+        must_use::check_impl_item(cx, item);\n+        if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n             let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none()\n-            {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this method could have a `#[must_use]` attribute\",\n-                );\n-            }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         too_many_arguments::check_trait_item(cx, item, self.too_many_arguments_threshold);\n         not_unsafe_ptr_arg_deref::check_trait_item(cx, item);\n+        must_use::check_trait_item(cx, item);\n \n-        if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n+        if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n             let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n-\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            }\n-            if let hir::TraitFn::Provided(eid) = *eid {\n-                let body = cx.tcx.hir().body(eid);\n-                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n-                    check_must_use_candidate(\n-                        cx,\n-                        &sig.decl,\n-                        body,\n-                        item.span,\n-                        item.hir_id(),\n-                        item.span.with_hi(sig.decl.output.span().hi()),\n-                        \"this method could have a `#[must_use]` attribute\",\n-                    );\n-                }\n-            }\n         }\n     }\n }\n@@ -367,185 +312,3 @@ fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span\n         }\n     }\n }\n-\n-fn check_needless_must_use(\n-    cx: &LateContext<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    item_id: hir::HirId,\n-    item_span: Span,\n-    fn_header_span: Span,\n-    attr: &Attribute,\n-) {\n-    if in_external_macro(cx.sess(), item_span) {\n-        return;\n-    }\n-    if returns_unit(decl) {\n-        span_lint_and_then(\n-            cx,\n-            MUST_USE_UNIT,\n-            fn_header_span,\n-            \"this unit-returning function has a `#[must_use]` attribute\",\n-            |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-        );\n-    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n-        span_lint_and_help(\n-            cx,\n-            DOUBLE_MUST_USE,\n-            fn_header_span,\n-            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n-            None,\n-            \"either add some descriptive text or remove the attribute\",\n-        );\n-    }\n-}\n-\n-fn check_must_use_candidate<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    decl: &'tcx hir::FnDecl<'_>,\n-    body: &'tcx hir::Body<'_>,\n-    item_span: Span,\n-    item_id: hir::HirId,\n-    fn_span: Span,\n-    msg: &str,\n-) {\n-    if has_mutable_arg(cx, body)\n-        || mutates_static(cx, body)\n-        || in_external_macro(cx.sess(), item_span)\n-        || returns_unit(decl)\n-        || !cx.access_levels.is_exported(item_id)\n-        || is_must_use_ty(cx, return_ty(cx, item_id))\n-    {\n-        return;\n-    }\n-    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n-        if let Some(snippet) = snippet_opt(cx, fn_span) {\n-            diag.span_suggestion(\n-                fn_span,\n-                \"add the attribute\",\n-                format!(\"#[must_use] {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n-}\n-\n-fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => true,\n-        hir::FnRetTy::Return(ref ty) => match ty.kind {\n-            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n-            hir::TyKind::Never => true,\n-            _ => false,\n-        },\n-    }\n-}\n-\n-fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n-    let mut tys = FxHashSet::default();\n-    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n-}\n-\n-fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n-    if let hir::PatKind::Wild = pat.kind {\n-        return false; // ignore `_` patterns\n-    }\n-    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n-    } else {\n-        false\n-    }\n-}\n-\n-static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n-\n-fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n-    match *ty.kind() {\n-        // primitive types are never mutable\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n-        ty::Adt(ref adt, ref substs) => {\n-            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n-                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n-        },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n-        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n-        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n-        },\n-        // calling something constitutes a side effect, so return true on all callables\n-        // also never calls need not be used, so return true for them, too\n-        _ => true,\n-    }\n-}\n-\n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n-\n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n-            Call(_, args) | MethodCall(_, _, args, _) => {\n-                let mut tys = FxHashSet::default();\n-                for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n-                        && is_mutated_static(arg)\n-                    {\n-                        self.mutates_static = true;\n-                        return;\n-                    }\n-                    tys.clear();\n-                }\n-            },\n-            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n-                self.mutates_static |= is_mutated_static(target)\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, &body.value);\n-    v.mutates_static\n-}"}, {"sha": "3825699936ffde6d2b136cb470e2195c89fe115c", "filename": "clippy_lints/src/functions/must_use.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/c37916501db2c649f57d2cc0d84ee41db34094c4/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c37916501db2c649f57d2cc0d84ee41db34094c4/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=c37916501db2c649f57d2cc0d84ee41db34094c4", "patch": "@@ -0,0 +1,272 @@\n+use rustc_ast::ast::Attribute;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def::Res, def_id::DefId, intravisit, QPath};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::{\n+    hir::map::Map,\n+    lint::in_external_macro,\n+    ty::{self, Ty},\n+};\n+use rustc_span::Span;\n+\n+use clippy_utils::attrs::is_proc_macro;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::{attr_by_name, match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+\n+use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n+\n+pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let attr = must_use_attr(attrs);\n+    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            return;\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n+            check_must_use_candidate(\n+                cx,\n+                &sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this function could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            check_must_use_candidate(\n+                cx,\n+                &sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this method could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if let hir::TraitFn::Provided(eid) = *eid {\n+            let body = cx.tcx.hir().body(eid);\n+            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+                check_must_use_candidate(\n+                    cx,\n+                    &sig.decl,\n+                    body,\n+                    item.span,\n+                    item.hir_id(),\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this method could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_must_use(\n+    cx: &LateContext<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    item_id: hir::HirId,\n+    item_span: Span,\n+    fn_header_span: Span,\n+    attr: &Attribute,\n+) {\n+    if in_external_macro(cx.sess(), item_span) {\n+        return;\n+    }\n+    if returns_unit(decl) {\n+        span_lint_and_then(\n+            cx,\n+            MUST_USE_UNIT,\n+            fn_header_span,\n+            \"this unit-returning function has a `#[must_use]` attribute\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    \"\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        span_lint_and_help(\n+            cx,\n+            DOUBLE_MUST_USE,\n+            fn_header_span,\n+            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n+            None,\n+            \"either add some descriptive text or remove the attribute\",\n+        );\n+    }\n+}\n+\n+fn check_must_use_candidate<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    body: &'tcx hir::Body<'_>,\n+    item_span: Span,\n+    item_id: hir::HirId,\n+    fn_span: Span,\n+    msg: &str,\n+) {\n+    if has_mutable_arg(cx, body)\n+        || mutates_static(cx, body)\n+        || in_external_macro(cx.sess(), item_span)\n+        || returns_unit(decl)\n+        || !cx.access_levels.is_exported(item_id)\n+        || is_must_use_ty(cx, return_ty(cx, item_id))\n+    {\n+        return;\n+    }\n+    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n+        if let Some(snippet) = snippet_opt(cx, fn_span) {\n+            diag.span_suggestion(\n+                fn_span,\n+                \"add the attribute\",\n+                format!(\"#[must_use] {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n+    match decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => true,\n+        hir::FnRetTy::Return(ref ty) => match ty.kind {\n+            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n+            hir::TyKind::Never => true,\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n+    let mut tys = FxHashSet::default();\n+    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n+}\n+\n+fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n+    if let hir::PatKind::Wild = pat.kind {\n+        return false; // ignore `_` patterns\n+    }\n+    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n+    } else {\n+        false\n+    }\n+}\n+\n+static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n+    match *ty.kind() {\n+        // primitive types are never mutable\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n+        ty::Adt(ref adt, ref substs) => {\n+            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+        },\n+        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+        },\n+        // calling something constitutes a side effect, so return true on all callables\n+        // also never calls need not be used, so return true for them, too\n+        _ => true,\n+    }\n+}\n+\n+struct StaticMutVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    mutates_static: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n+\n+        if self.mutates_static {\n+            return;\n+        }\n+        match expr.kind {\n+            Call(_, args) | MethodCall(_, _, args, _) => {\n+                let mut tys = FxHashSet::default();\n+                for arg in args {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n+            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n+                self.mutates_static |= is_mutated_static(target)\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n+}\n+\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    let mut v = StaticMutVisitor {\n+        cx,\n+        mutates_static: false,\n+    };\n+    intravisit::walk_expr(&mut v, &body.value);\n+    v.mutates_static\n+}"}]}