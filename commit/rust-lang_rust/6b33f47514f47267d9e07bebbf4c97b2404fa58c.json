{"sha": "6b33f47514f47267d9e07bebbf4c97b2404fa58c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMzNmNDc1MTRmNDcyNjdkOWUwN2JlYmJmNGM5N2IyNDA0ZmE1OGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-16T15:42:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:59Z"}, "message": "remove `usize: DepGraphRead` and add `Untracked`\n\nThe idea is that a `usize` is sort of ambiguous: in this case, it\nrepresents indices that do not need tracking, but it could as easily be\nsome data read out from a tracked location, and hence represent tracked\ndata. Therefore, we add an `Untracked` type that lets user assert\nthat value is not tracked.\n\nAlso correct various typos.", "tree": {"sha": "d5d4ff7b97e46cee783294812ee3bbc2e9df8e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d4ff7b97e46cee783294812ee3bbc2e9df8e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b33f47514f47267d9e07bebbf4c97b2404fa58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b33f47514f47267d9e07bebbf4c97b2404fa58c", "html_url": "https://github.com/rust-lang/rust/commit/6b33f47514f47267d9e07bebbf4c97b2404fa58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b33f47514f47267d9e07bebbf4c97b2404fa58c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "url": "https://api.github.com/repos/rust-lang/rust/commits/9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "html_url": "https://github.com/rust-lang/rust/commit/9daea5b6393af6706dd50a48d4bf8e6eeaff9860"}], "stats": {"total": 48, "additions": 35, "deletions": 13}, "files": [{"sha": "791d090273ffca9ca3221a4999da39b1ecc92771", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6b33f47514f47267d9e07bebbf4c97b2404fa58c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b33f47514f47267d9e07bebbf4c97b2404fa58c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6b33f47514f47267d9e07bebbf4c97b2404fa58c", "patch": "@@ -53,7 +53,7 @@ use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n use rustc::hir::map::DefKey;\n \n-use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, XRef};\n+use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n@@ -206,15 +206,20 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         for (i, variant) in def.variants.iter().enumerate() {\n             self.record(variant.did,\n                         ItemContentBuilder::encode_enum_variant_info,\n-                        (enum_did, i));\n+                        (enum_did, Untracked(i)));\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    /// Encode data for the given variant of the given ADT. The\n+    /// index of the variant is untracked: this is ok because we\n+    /// will have to lookup the adt-def by its id, and that gives us\n+    /// the right to access any information in the adt-def (including,\n+    /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(&mut self,\n-                                (enum_did, index):\n-                                (DefId, usize)) {\n+                                (enum_did, Untracked(index)):\n+                                (DefId, Untracked<usize>)) {\n         let ecx = self.ecx;\n         let def = ecx.tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -420,16 +425,22 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n                             ItemContentBuilder::encode_field,\n-                            (adt_def_id, variant_index, field_index));\n+                            (adt_def_id, Untracked((variant_index, field_index))));\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    /// Encode data for the given field of the given variant of the\n+    /// given ADT. The indices of the variant/field are untracked:\n+    /// this is ok because we will have to lookup the adt-def by its\n+    /// id, and that gives us the right to access any information in\n+    /// the adt-def (including, e.g., the length of the various\n+    /// vectors).\n     fn encode_field(&mut self,\n-                    (adt_def_id, variant_index, field_index):\n-                    (DefId, usize, usize)) {\n+                    (adt_def_id, Untracked((variant_index, field_index))):\n+                    (DefId, Untracked<(usize, usize)>)) {\n         let ecx = self.ecx();\n         let def = ecx.tcx.lookup_adt_def(adt_def_id);\n         let variant = &def.variants[variant_index];"}, {"sha": "1d3d09d6bc2d798871df777ef59f349240e7833f", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b33f47514f47267d9e07bebbf4c97b2404fa58c/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b33f47514f47267d9e07bebbf4c97b2404fa58c/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=6b33f47514f47267d9e07bebbf4c97b2404fa58c", "patch": "@@ -24,10 +24,10 @@\n //!\n //! In addition to the offset, we need to track the data that was used\n //! to generate the contents of each `data_item`. This is so that we\n-//! can figure out which HIR nodes contributors to that data for\n+//! can figure out which HIR nodes contributed to that data for\n //! incremental compilation purposes.\n //!\n-//! The `IndexBuilder` facilitates with both of these. It is created\n+//! The `IndexBuilder` facilitates both of these. It is created\n //! with an RBML encoder isntance (`rbml_w`) along with an\n //! `EncodingContext` (`ecx`), which it encapsulates. It has one main\n //! method, `record()`. You invoke `record` like so to create a new\n@@ -166,10 +166,6 @@ pub trait DepGraphRead {\n     fn read(&self, tcx: TyCtxt);\n }\n \n-impl DepGraphRead for usize {\n-    fn read(&self, _tcx: TyCtxt) { }\n-}\n-\n impl DepGraphRead for DefId {\n     fn read(&self, _tcx: TyCtxt) { }\n }\n@@ -229,6 +225,21 @@ read_hir!(hir::ImplItem);\n read_hir!(hir::TraitItem);\n read_hir!(hir::ForeignItem);\n \n+/// Leaks access to a value of type T without any tracking. This is\n+/// suitable for ambiguous types like `usize`, which *could* represent\n+/// tracked data (e.g., if you read it out of a HIR node) or might not\n+/// (e.g., if it's an index). Adding in an `Untracked` is an\n+/// assertion, essentially, that the data does not need to be tracked\n+/// (or that read edges will be added by some other way).\n+///\n+/// A good idea is to add to each use of `Untracked` an explanation of\n+/// why this value is ok.\n+pub struct Untracked<T>(pub T);\n+\n+impl<T> DepGraphRead for Untracked<T> {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n /// Newtype that can be used to package up misc data extracted from a\n /// HIR node that doesn't carry its own id. This will allow an\n /// arbitrary `T` to be passed in, but register a read on the given"}]}