{"sha": "bf3030404ef8a161334326bad706f60ee8838f63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMzAzMDQwNGVmOGExNjEzMzQzMjZiYWQ3MDZmNjBlZTg4MzhmNjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-24T09:03:26Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-24T09:03:26Z"}, "message": "Merge #1584\n\n1584: switch to upstream unescape r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "da9640c5086a1cc0281a7a5ee8c62e1c5cf986e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da9640c5086a1cc0281a7a5ee8c62e1c5cf986e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf3030404ef8a161334326bad706f60ee8838f63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf3030404ef8a161334326bad706f60ee8838f63", "html_url": "https://github.com/rust-lang/rust/commit/bf3030404ef8a161334326bad706f60ee8838f63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf3030404ef8a161334326bad706f60ee8838f63/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a971c6d32d7d9736ac093fa62b5116e3e4a75989", "url": "https://api.github.com/repos/rust-lang/rust/commits/a971c6d32d7d9736ac093fa62b5116e3e4a75989", "html_url": "https://github.com/rust-lang/rust/commit/a971c6d32d7d9736ac093fa62b5116e3e4a75989"}, {"sha": "2473cb6a5cc2af6d703129adc01942b00c059810", "url": "https://api.github.com/repos/rust-lang/rust/commits/2473cb6a5cc2af6d703129adc01942b00c059810", "html_url": "https://github.com/rust-lang/rust/commit/2473cb6a5cc2af6d703129adc01942b00c059810"}], "stats": {"total": 620, "additions": 91, "deletions": 529}, "files": [{"sha": "528a332249b411fdd704baf63681fbfc6eae565b", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf3030404ef8a161334326bad706f60ee8838f63/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bf3030404ef8a161334326bad706f60ee8838f63/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bf3030404ef8a161334326bad706f60ee8838f63", "patch": "@@ -1310,7 +1310,7 @@ dependencies = [\n \n [[package]]\n name = \"ra_rustc_lexer\"\n-version = \"0.1.0-pre.1\"\n+version = \"0.1.0-pre.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1322,7 +1322,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n- \"ra_rustc_lexer 0.1.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_rustc_lexer 0.1.0-pre.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_text_edit 0.1.0\",\n  \"rowan 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2259,7 +2259,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf147e022eacf0c8a054ab864914a7602618adba841d800a9a9868a5237a529f\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ce23b6b870e8f94f81fb0a363d65d86675884b34a09043c81e5562f11c1f8e1\"\n-\"checksum ra_rustc_lexer 0.1.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8d92772f822978a6c9c4657aa61af439e4e635180628b3354049b283b749f1e\"\n+\"checksum ra_rustc_lexer 0.1.0-pre.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6baccda91574dfadd7f8a0bc8f9f110f874b6b484289b2536d3dbf4f0d5d97bb\"\n \"checksum ra_vfs 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb7cd4e302032c5ab514f1c01c89727cd96fd950dd36f9ebee9252df45d9fb1a\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d47eab0e83d9693d40f825f86948aa16eff6750ead4bdffc4ab95b8b3a7f052c\""}, {"sha": "40d63ef7acb2aaef7421d8382d35b12534ae3217", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf3030404ef8a161334326bad706f60ee8838f63/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bf3030404ef8a161334326bad706f60ee8838f63/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=bf3030404ef8a161334326bad706f60ee8838f63", "patch": "@@ -11,7 +11,7 @@ repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n unicode-xid = \"0.1.0\"\n itertools = \"0.8.0\"\n rowan = \"0.6.0\"\n-ra_rustc_lexer = { version = \"0.1.0-pre.1\", features = [ \"unicode-xid\" ] }\n+ra_rustc_lexer = { version = \"0.1.0-pre.2\" }\n \n # ideally, `serde` should be enabled by `ra_lsp_server`, but we enable it here\n # to reduce number of compilations"}, {"sha": "1f904434e8ada2757693e96542dd91ec853f6b54", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bf3030404ef8a161334326bad706f60ee8838f63/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3030404ef8a161334326bad706f60ee8838f63/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=bf3030404ef8a161334326bad706f60ee8838f63", "patch": "@@ -1,16 +1,99 @@\n-mod unescape;\n-\n mod block;\n mod field_expr;\n \n+use ra_rustc_lexer::unescape;\n+\n use crate::{\n     algo::visit::{visitor_ctx, VisitorCtx},\n-    ast, SyntaxError,\n+    ast, SyntaxError, SyntaxErrorKind,\n     SyntaxKind::{BYTE, BYTE_STRING, CHAR, STRING},\n     SyntaxNode, TextUnit, T,\n };\n \n-pub(crate) use unescape::EscapeError;\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum EscapeError {\n+    ZeroChars,\n+    MoreThanOneChar,\n+    LoneSlash,\n+    InvalidEscape,\n+    BareCarriageReturn,\n+    EscapeOnlyChar,\n+    TooShortHexEscape,\n+    InvalidCharInHexEscape,\n+    OutOfRangeHexEscape,\n+    NoBraceInUnicodeEscape,\n+    InvalidCharInUnicodeEscape,\n+    EmptyUnicodeEscape,\n+    UnclosedUnicodeEscape,\n+    LeadingUnderscoreUnicodeEscape,\n+    OverlongUnicodeEscape,\n+    LoneSurrogateUnicodeEscape,\n+    OutOfRangeUnicodeEscape,\n+    UnicodeEscapeInByte,\n+    NonAsciiCharInByte,\n+}\n+\n+impl From<ra_rustc_lexer::unescape::EscapeError> for EscapeError {\n+    fn from(err: ra_rustc_lexer::unescape::EscapeError) -> Self {\n+        match err {\n+            ra_rustc_lexer::unescape::EscapeError::ZeroChars => EscapeError::ZeroChars,\n+            ra_rustc_lexer::unescape::EscapeError::MoreThanOneChar => EscapeError::MoreThanOneChar,\n+            ra_rustc_lexer::unescape::EscapeError::LoneSlash => EscapeError::LoneSlash,\n+            ra_rustc_lexer::unescape::EscapeError::InvalidEscape => EscapeError::InvalidEscape,\n+            ra_rustc_lexer::unescape::EscapeError::BareCarriageReturn\n+            | ra_rustc_lexer::unescape::EscapeError::BareCarriageReturnInRawString => {\n+                EscapeError::BareCarriageReturn\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::EscapeOnlyChar => EscapeError::EscapeOnlyChar,\n+            ra_rustc_lexer::unescape::EscapeError::TooShortHexEscape => {\n+                EscapeError::TooShortHexEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::InvalidCharInHexEscape => {\n+                EscapeError::InvalidCharInHexEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::OutOfRangeHexEscape => {\n+                EscapeError::OutOfRangeHexEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::NoBraceInUnicodeEscape => {\n+                EscapeError::NoBraceInUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::InvalidCharInUnicodeEscape => {\n+                EscapeError::InvalidCharInUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::EmptyUnicodeEscape => {\n+                EscapeError::EmptyUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::UnclosedUnicodeEscape => {\n+                EscapeError::UnclosedUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::LeadingUnderscoreUnicodeEscape => {\n+                EscapeError::LeadingUnderscoreUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::OverlongUnicodeEscape => {\n+                EscapeError::OverlongUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::LoneSurrogateUnicodeEscape => {\n+                EscapeError::LoneSurrogateUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::OutOfRangeUnicodeEscape => {\n+                EscapeError::OutOfRangeUnicodeEscape\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::UnicodeEscapeInByte => {\n+                EscapeError::UnicodeEscapeInByte\n+            }\n+            ra_rustc_lexer::unescape::EscapeError::NonAsciiCharInByte\n+            | ra_rustc_lexer::unescape::EscapeError::NonAsciiCharInByteString => {\n+                EscapeError::NonAsciiCharInByte\n+            }\n+        }\n+    }\n+}\n+\n+impl From<ra_rustc_lexer::unescape::EscapeError> for SyntaxErrorKind {\n+    fn from(err: ra_rustc_lexer::unescape::EscapeError) -> Self {\n+        SyntaxErrorKind::EscapeError(err.into())\n+    }\n+}\n \n pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();"}, {"sha": "7eed6c663360fa7df7680650422908c555fc49dd", "filename": "crates/ra_syntax/src/validation/unescape.rs", "status": "removed", "additions": 0, "deletions": 521, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/a971c6d32d7d9736ac093fa62b5116e3e4a75989/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a971c6d32d7d9736ac093fa62b5116e3e4a75989/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs?ref=a971c6d32d7d9736ac093fa62b5116e3e4a75989", "patch": "@@ -1,521 +0,0 @@\n-//! Utilities for validating  string and char literals and turning them into\n-//! values they represent.\n-//!\n-//! This file is copy-pasted from the compiler\n-//!\n-//! https://github.com/rust-lang/rust/blob/c6ac57564852cb6e2d0db60f7b46d9eb98d4b449/src/libsyntax/parse/unescape.rs\n-//!\n-//! Hopefully, we'll share this code in a proper way some day\n-\n-use std::ops::Range;\n-use std::str::Chars;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n-pub enum EscapeError {\n-    ZeroChars,\n-    MoreThanOneChar,\n-\n-    LoneSlash,\n-    InvalidEscape,\n-    BareCarriageReturn,\n-    EscapeOnlyChar,\n-\n-    TooShortHexEscape,\n-    InvalidCharInHexEscape,\n-    OutOfRangeHexEscape,\n-\n-    NoBraceInUnicodeEscape,\n-    InvalidCharInUnicodeEscape,\n-    EmptyUnicodeEscape,\n-    UnclosedUnicodeEscape,\n-    LeadingUnderscoreUnicodeEscape,\n-    OverlongUnicodeEscape,\n-    LoneSurrogateUnicodeEscape,\n-    OutOfRangeUnicodeEscape,\n-\n-    UnicodeEscapeInByte,\n-    NonAsciiCharInByte,\n-}\n-\n-/// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub(crate) fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a string literal (without quotes) and produces a\n-/// sequence of escaped characters or errors.\n-pub(crate) fn unescape_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n-{\n-    unescape_str_or_byte_str(literal_text, Mode::Str, callback)\n-}\n-\n-pub(crate) fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a string literal (without quotes) and produces a\n-/// sequence of escaped characters or errors.\n-pub(crate) fn unescape_byte_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    unescape_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n-        callback(range, char.map(byte_from_char))\n-    })\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n-pub(crate) enum Mode {\n-    Char,\n-    Str,\n-    Byte,\n-    ByteStr,\n-}\n-\n-impl Mode {\n-    fn in_single_quotes(self) -> bool {\n-        match self {\n-            Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr => false,\n-        }\n-    }\n-\n-    pub(crate) fn in_double_quotes(self) -> bool {\n-        !self.in_single_quotes()\n-    }\n-\n-    pub(crate) fn is_bytes(self) -> bool {\n-        match self {\n-            Mode::Byte | Mode::ByteStr => true,\n-            Mode::Char | Mode::Str => false,\n-        }\n-    }\n-}\n-\n-fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    if first_char != '\\\\' {\n-        return match first_char {\n-            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n-            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            _ => {\n-                if mode.is_bytes() && !first_char.is_ascii() {\n-                    return Err(EscapeError::NonAsciiCharInByte);\n-                }\n-                Ok(first_char)\n-            }\n-        };\n-    }\n-\n-    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n-\n-    let res = match second_char {\n-        '\"' => '\"',\n-        'n' => '\\n',\n-        'r' => '\\r',\n-        't' => '\\t',\n-        '\\\\' => '\\\\',\n-        '\\'' => '\\'',\n-        '0' => '\\0',\n-\n-        'x' => {\n-            let hi = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n-            let hi = hi.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n-\n-            let lo = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n-            let lo = lo.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n-\n-            let value = hi * 16 + lo;\n-\n-            if !mode.is_bytes() && !is_ascii(value) {\n-                return Err(EscapeError::OutOfRangeHexEscape);\n-            }\n-            let value = value as u8;\n-\n-            value as char\n-        }\n-\n-        'u' => {\n-            if chars.next() != Some('{') {\n-                return Err(EscapeError::NoBraceInUnicodeEscape);\n-            }\n-\n-            let mut n_digits = 1;\n-            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n-                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n-                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n-                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n-            };\n-\n-            loop {\n-                match chars.next() {\n-                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n-                    Some('_') => continue,\n-                    Some('}') => {\n-                        if n_digits > 6 {\n-                            return Err(EscapeError::OverlongUnicodeEscape);\n-                        }\n-                        if mode.is_bytes() {\n-                            return Err(EscapeError::UnicodeEscapeInByte);\n-                        }\n-\n-                        break std::char::from_u32(value).ok_or_else(|| {\n-                            if value > 0x0010_FFFF {\n-                                EscapeError::OutOfRangeUnicodeEscape\n-                            } else {\n-                                EscapeError::LoneSurrogateUnicodeEscape\n-                            }\n-                        })?;\n-                    }\n-                    Some(c) => {\n-                        let digit =\n-                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n-                        n_digits += 1;\n-                        if n_digits > 6 {\n-                            continue;\n-                        }\n-                        let digit = digit as u32;\n-                        value = value * 16 + digit;\n-                    }\n-                };\n-            }\n-        }\n-        _ => return Err(EscapeError::InvalidEscape),\n-    };\n-    Ok(res)\n-}\n-\n-fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = scan_escape(first_char, chars, mode)?;\n-    if chars.next().is_some() {\n-        return Err(EscapeError::MoreThanOneChar);\n-    }\n-    Ok(res)\n-}\n-\n-/// Takes a contents of a string literal (without quotes) and produces a\n-/// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n-{\n-    assert!(mode.in_double_quotes());\n-    let initial_len = src.len();\n-    let mut chars = src.chars();\n-    while let Some(first_char) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n-\n-        let unescaped_char = match first_char {\n-            '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n-                        skip_ascii_whitespace(&mut chars);\n-                        continue;\n-                    }\n-                    _ => scan_escape(first_char, &mut chars, mode),\n-                }\n-            }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n-            '\\n' => Ok('\\n'),\n-            '\\t' => Ok('\\t'),\n-            _ => scan_escape(first_char, &mut chars, mode),\n-        };\n-        let end = initial_len - chars.as_str().len();\n-        callback(start..end, unescaped_char);\n-    }\n-\n-    fn skip_ascii_whitespace(chars: &mut Chars<'_>) {\n-        let str = chars.as_str();\n-        let first_non_space = str\n-            .bytes()\n-            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n-            .unwrap_or_else(|| str.len());\n-        *chars = str[first_non_space..].chars()\n-    }\n-}\n-\n-fn byte_from_char(c: char) -> u8 {\n-    let res = c as u32;\n-    assert!(res <= u32::from(u8::max_value()), \"guaranteed because of Mode::Byte\");\n-    res as u8\n-}\n-\n-fn is_ascii(x: u32) -> bool {\n-    x <= 0x7F\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_unescape_char_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-        check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-\n-        check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-\n-        check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-    }\n-\n-    #[test]\n-    fn test_unescape_char_good() {\n-        fn check(literal_text: &str, expected_char: char) {\n-            let actual_result = unescape_char(literal_text);\n-            assert_eq!(actual_result, Ok(expected_char));\n-        }\n-\n-        check(\"a\", 'a');\n-        check(\"\u044b\", '\u044b');\n-        check(\"\ud83e\udd80\", '\ud83e\udd80');\n-\n-        check(r#\"\\\"\"#, '\"');\n-        check(r\"\\n\", '\\n');\n-        check(r\"\\r\", '\\r');\n-        check(r\"\\t\", '\\t');\n-        check(r\"\\\\\", '\\\\');\n-        check(r\"\\'\", '\\'');\n-        check(r\"\\0\", '\\0');\n-\n-        check(r\"\\x00\", '\\0');\n-        check(r\"\\x5a\", 'Z');\n-        check(r\"\\x5A\", 'Z');\n-        check(r\"\\x7f\", 127 as char);\n-\n-        check(r\"\\u{0}\", '\\0');\n-        check(r\"\\u{000000}\", '\\0');\n-        check(r\"\\u{41}\", 'A');\n-        check(r\"\\u{0041}\", 'A');\n-        check(r\"\\u{00_41}\", 'A');\n-        check(r\"\\u{4__1__}\", 'A');\n-        check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n-    }\n-\n-    #[test]\n-    fn test_unescape_str_good() {\n-        fn check(literal_text: &str, expected: &str) {\n-            let mut buf = Ok(String::with_capacity(literal_text.len()));\n-            unescape_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", \"foo\");\n-        check(\"\", \"\");\n-        check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", \"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", \"hello world\");\n-        check(\"thread's\", \"thread's\")\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-\n-        check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n-        check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n-\n-        check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_good() {\n-        fn check(literal_text: &str, expected_byte: u8) {\n-            let actual_result = unescape_byte(literal_text);\n-            assert_eq!(actual_result, Ok(expected_byte));\n-        }\n-\n-        check(\"a\", b'a');\n-\n-        check(r#\"\\\"\"#, b'\"');\n-        check(r\"\\n\", b'\\n');\n-        check(r\"\\r\", b'\\r');\n-        check(r\"\\t\", b'\\t');\n-        check(r\"\\\\\", b'\\\\');\n-        check(r\"\\'\", b'\\'');\n-        check(r\"\\0\", b'\\0');\n-\n-        check(r\"\\x00\", b'\\0');\n-        check(r\"\\x5a\", b'Z');\n-        check(r\"\\x5A\", b'Z');\n-        check(r\"\\x7f\", 127);\n-        check(r\"\\x80\", 128);\n-        check(r\"\\xff\", 255);\n-        check(r\"\\xFF\", 255);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_str_good() {\n-        fn check(literal_text: &str, expected: &[u8]) {\n-            let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-            unescape_byte_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", b\"foo\");\n-        check(\"\", b\"\");\n-        check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", b\"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n-        check(\"thread's\", b\"thread's\")\n-    }\n-}"}]}