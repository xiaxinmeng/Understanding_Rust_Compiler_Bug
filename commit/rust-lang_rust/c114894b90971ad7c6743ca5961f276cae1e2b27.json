{"sha": "c114894b90971ad7c6743ca5961f276cae1e2b27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMTQ4OTRiOTA5NzFhZDdjNjc0M2NhNTk2MWYyNzZjYWUxZTJiMjc=", "commit": {"author": {"name": "Soveu", "email": "marx.tomasz@gmail.com", "date": "2021-02-17T16:21:12Z"}, "committer": {"name": "Soveu", "email": "marx.tomasz@gmail.com", "date": "2021-02-17T16:21:12Z"}, "message": "Vec::dedup optimization - panic gracefully", "tree": {"sha": "fbc03412ce452df11e77317b9e0ef4404f5b8f29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbc03412ce452df11e77317b9e0ef4404f5b8f29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c114894b90971ad7c6743ca5961f276cae1e2b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c114894b90971ad7c6743ca5961f276cae1e2b27", "html_url": "https://github.com/rust-lang/rust/commit/c114894b90971ad7c6743ca5961f276cae1e2b27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c114894b90971ad7c6743ca5961f276cae1e2b27/comments", "author": {"login": "Soveu", "id": 34382234, "node_id": "MDQ6VXNlcjM0MzgyMjM0", "avatar_url": "https://avatars.githubusercontent.com/u/34382234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Soveu", "html_url": "https://github.com/Soveu", "followers_url": "https://api.github.com/users/Soveu/followers", "following_url": "https://api.github.com/users/Soveu/following{/other_user}", "gists_url": "https://api.github.com/users/Soveu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Soveu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Soveu/subscriptions", "organizations_url": "https://api.github.com/users/Soveu/orgs", "repos_url": "https://api.github.com/users/Soveu/repos", "events_url": "https://api.github.com/users/Soveu/events{/privacy}", "received_events_url": "https://api.github.com/users/Soveu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Soveu", "id": 34382234, "node_id": "MDQ6VXNlcjM0MzgyMjM0", "avatar_url": "https://avatars.githubusercontent.com/u/34382234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Soveu", "html_url": "https://github.com/Soveu", "followers_url": "https://api.github.com/users/Soveu/followers", "following_url": "https://api.github.com/users/Soveu/following{/other_user}", "gists_url": "https://api.github.com/users/Soveu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Soveu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Soveu/subscriptions", "organizations_url": "https://api.github.com/users/Soveu/orgs", "repos_url": "https://api.github.com/users/Soveu/repos", "events_url": "https://api.github.com/users/Soveu/events{/privacy}", "received_events_url": "https://api.github.com/users/Soveu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1825810a898842b4660fd684cea66906b7e32500", "url": "https://api.github.com/repos/rust-lang/rust/commits/1825810a898842b4660fd684cea66906b7e32500", "html_url": "https://github.com/rust-lang/rust/commit/1825810a898842b4660fd684cea66906b7e32500"}], "stats": {"total": 81, "additions": 65, "deletions": 16}, "files": [{"sha": "e65adb6c77eda0f5511f6fd6ffcf876889d228be", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c114894b90971ad7c6743ca5961f276cae1e2b27/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c114894b90971ad7c6743ca5961f276cae1e2b27/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c114894b90971ad7c6743ca5961f276cae1e2b27", "patch": "@@ -1523,43 +1523,92 @@ impl<T, A: Allocator> Vec<T, A> {\n             return;\n         }\n \n-        let ptr = self.as_mut_ptr();\n-        /* Offset of the element we want to check if it is duplicate */\n-        let mut read: usize = 1;\n-        /* Offset of the place where we want to place the non-duplicate\n-         * when we find it. */\n-        let mut write: usize = 1;\n+        /* INVARIANT: vec.len() > read >= write > write-1 >= 0 */\n+        struct FillGapOnDrop<'a, T, A: core::alloc::Allocator> {\n+            /* Offset of the element we want to check if it is duplicate */\n+            read: usize,\n+\n+            /* Offset of the place where we want to place the non-duplicate\n+             * when we find it. */\n+            write: usize,\n+\n+            /* The Vec that would need correction if `same_bucket` panicked */\n+            vec: &'a mut Vec<T, A>,\n+        }\n+\n+        impl<'a, T, A: core::alloc::Allocator> Drop for FillGapOnDrop<'a, T, A> {\n+            fn drop(&mut self) {\n+                /* This code gets executed either at the end of `dedup_by` or\n+                 * when `same_bucket` panics */\n+\n+                /* SAFETY (if finishing successfully): self.read == len, so\n+                 * no data is copied and length is set correctly */\n+\n+                /* SAFETY (if panicing): invariant guarantees that `read - write`\n+                 * and `len - read` never overflow and that the copy is always\n+                 * in-bounds. */\n+                unsafe {\n+                    let ptr = self.vec.as_mut_ptr();\n+                    let len = self.vec.len();\n+\n+                    /* How many items were left when `same_bucket` paniced.\n+                     * Basically vec[read..].len() */\n+                    let items_left = len - self.read;\n+\n+                    /* Pointer to first item in vec[write..write+items_left] slice */\n+                    let dropped_ptr = ptr.add(self.write);\n+                    /* Pointer to first item in vec[read..] slice */\n+                    let valid_ptr = ptr.add(self.read);\n+\n+                    /* Copy `vec[read..]` to `vec[write..write+items_left]`.\n+                     * The slices can overlap, so `copy_nonoverlapping` cannot be used */\n+                    ptr::copy(valid_ptr, dropped_ptr, items_left);\n+\n+                    /* How many items have been already dropped\n+                     * Basically vec[read..write].len() */\n+                    let dropped = self.read - self.write;\n+\n+                    self.vec.set_len(len - dropped);\n+                }\n+            }\n+        }\n+\n+        let mut gap = FillGapOnDrop { read: 1, write: 1, vec: self };\n+\n+        let ptr = gap.vec.as_mut_ptr();\n \n         /* Drop items while going through Vec, it should be more efficient than\n          * doing slice partition_dedup + truncate */\n \n-        /* INVARIANT: len > read >= write > write-1 >= 0\n-         * SAFETY: Because of the invariant, read_ptr, prev_ptr and write_ptr\n+        /* SAFETY: Because of the invariant, read_ptr, prev_ptr and write_ptr\n          * are always in-bounds and read_ptr never aliases prev_ptr */\n         unsafe {\n-            while read < len {\n-                let read_ptr = ptr.add(read);\n-                let prev_ptr = ptr.add(write.wrapping_sub(1));\n+            while gap.read < len {\n+                let read_ptr = ptr.add(gap.read);\n+                let prev_ptr = ptr.add(gap.write.wrapping_sub(1));\n \n                 if same_bucket(&mut *read_ptr, &mut *prev_ptr) {\n                     /* We have found duplicate, drop it in-place */\n                     ptr::drop_in_place(read_ptr);\n                 } else {\n-                    let write_ptr = ptr.add(write);\n+                    let write_ptr = ptr.add(gap.write);\n \n                     /* Looks like doing just `copy` can be faster than\n                      * conditional `copy_nonoverlapping` */\n                     ptr::copy(read_ptr, write_ptr, 1);\n \n                     /* We have filled that place, so go further */\n-                    write += 1;\n+                    gap.write += 1;\n                 }\n \n-                read += 1;\n+                gap.read += 1;\n             }\n \n-            /* `write` items are inside vec, rest is already dropped */\n-            self.set_len(write);\n+            /* Technically we could let `gap` clean up with its Drop, but\n+             * when `same_bucket` is guaranteed to not panic, this bloats a little\n+             * the codegen, so we just do it manually */\n+            gap.vec.set_len(gap.write);\n+            mem::forget(gap);\n         }\n     }\n "}]}