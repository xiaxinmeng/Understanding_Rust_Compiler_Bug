{"sha": "2b334f061a7e7e7ff766f934081bc40ebfdaa698", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzM0ZjA2MWE3ZTdlN2ZmNzY2ZjkzNDA4MWJjNDBlYmZkYWE2OTg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-06T18:23:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-06T19:09:55Z"}, "message": "Change unsafe aliases\n\nThis litters aberrations like 'alt({foo.bar}) { ... }' and f({*baz})\nthough the code (mostly in trans.rs). These are a way to explicitly\ncopy the given value so that it can be safely aliased. At some point\nwe'll probably want a more explicit copy operator.", "tree": {"sha": "6e0e6827936f3cc47419fad013c2162914d8ffa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0e6827936f3cc47419fad013c2162914d8ffa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b334f061a7e7e7ff766f934081bc40ebfdaa698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b334f061a7e7e7ff766f934081bc40ebfdaa698", "html_url": "https://github.com/rust-lang/rust/commit/2b334f061a7e7e7ff766f934081bc40ebfdaa698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b334f061a7e7e7ff766f934081bc40ebfdaa698/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d8f715dab7862b4ad1f0c856f0e3cdd554e212a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8f715dab7862b4ad1f0c856f0e3cdd554e212a", "html_url": "https://github.com/rust-lang/rust/commit/4d8f715dab7862b4ad1f0c856f0e3cdd554e212a"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "8ec4dfe6297ef1f9ff6ab4a62602b8500178fe66", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2b334f061a7e7e7ff766f934081bc40ebfdaa698", "patch": "@@ -150,7 +150,7 @@ fn map_crate(&@env e, &ast::crate c) {\n     fn index_vi(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n         alt (i.node) {\n             case (ast::view_item_import(_, ?ids, ?defid)) {\n-                e.imports.insert(defid._1, todo(i, *sc));\n+                e.imports.insert(defid._1, todo(i, {*sc}));\n             }\n             case (_) {}\n         }\n@@ -231,7 +231,7 @@ fn map_crate(&@env e, &ast::crate c) {\n             //if it really is a glob import, that is\n             case (ast::view_item_import_glob(?path, _)) {\n                 find_mod(e, *sc).glob_imports \n-                    += [follow_import(*e, *sc, path, vi.span)];\n+                    += [follow_import(*e, {*sc}, path, vi.span)];\n             }\n             case (_) {}\n         }\n@@ -275,8 +275,8 @@ fn resolve_names(&@env e, &ast::crate c) {\n         push_env_for_expr(sc, exp);\n         alt (exp.node) {\n             case (ast::expr_path(?p, ?a)) {\n-                auto df = lookup_path_strict(*e, *sc, exp.span, p.node.idents,\n-                                             ns_value);\n+                auto df = lookup_path_strict(*e, {*sc}, exp.span,\n+                                             p.node.idents, ns_value);\n                 e.def_map.insert(a.id, df);\n             }\n             case (_) {}\n@@ -285,15 +285,15 @@ fn resolve_names(&@env e, &ast::crate c) {\n     fn walk_ty(@env e, @mutable list[scope] sc, &@ast::ty t) {\n         alt (t.node) {\n             case (ast::ty_path(?p, ?a)) {\n-                auto new_def = lookup_path_strict(*e, *sc, t.span,\n+                auto new_def = lookup_path_strict(*e, {*sc}, t.span,\n                                                   p.node.idents, ns_type);\n                 e.def_map.insert(a.id, new_def);\n             }\n             case (_) {}\n         }\n     }\n     fn walk_arm(@env e, @mutable list[scope] sc, &ast::arm a) {\n-        walk_pat(*e, *sc, a.pat);\n+        walk_pat(*e, {*sc}, a.pat);\n         push_env_for_arm(sc, a);\n     }\n     fn walk_pat(&env e, &list[scope] sc, &@ast::pat pat) {\n@@ -325,14 +325,14 @@ fn push_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n     *sc = cons[scope](scope_crate(@c), @*sc);\n }\n fn pop_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn push_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n     *sc = cons[scope](scope_item(i), @*sc);\n }\n fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn push_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n@@ -346,21 +346,21 @@ fn push_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n     *sc = cons[scope](scope_item(i), @*sc);\n }\n fn pop_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn push_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n     *sc = cons[scope](scope_native_item(i), @*sc);\n }\n fn pop_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn push_env_for_block(@mutable list[scope] sc, &ast::block b) {\n     *sc = cons[scope](scope_block(b), @*sc);\n }\n fn pop_env_for_block(@mutable list[scope] sc, &ast::block b) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn push_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n@@ -377,10 +377,10 @@ fn push_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n fn pop_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n     alt (x.node) {\n         case (ast::expr_for(?d, _, _, _)) {\n-            *sc = std::list::cdr(*sc);\n+            *sc = std::list::cdr({*sc});\n         }\n         case (ast::expr_for_each(?d, _, _, _)) {\n-            *sc = std::list::cdr(*sc);\n+            *sc = std::list::cdr({*sc});\n         }\n         case (_) {}\n     }\n@@ -390,7 +390,7 @@ fn push_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n     *sc = cons[scope](scope_arm(p), @*sc);\n }\n fn pop_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n-    *sc = std::list::cdr(*sc);\n+    *sc = std::list::cdr({*sc});\n }\n \n fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp) \n@@ -613,7 +613,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     // Used to determine whether obj fields are in scope\n     auto left_fn_level2 = false;\n     while (true) {\n-        alt (sc) {\n+        alt ({sc}) {\n             case (nil) {\n                 ret none[def];\n             }\n@@ -869,7 +869,7 @@ fn lookup_in_local_mod(&env e, def_id defid, &span sp,\n         case (none) { }\n         case (some(?lst)) {\n             while (true) {\n-                alt (lst) {\n+                alt ({lst}) {\n                     case (nil) { break; }\n                     case (cons(?hd, ?tl)) {\n                         auto found = lookup_in_mie(e, hd, ns);\n@@ -1126,7 +1126,7 @@ fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n     }\n \n     while (true) {\n-        alt (entries) {\n+        alt ({entries}) {\n             case (cons(?entry, ?rest)) {\n                 if (!option::is_none(lookup_in_mie(e, entry, ns_value))) {\n                     if (saw_value) { dup(e, mie_span(entry), \"\", name); }"}, {"sha": "61de9459fac4a5dd4940491198291856b6aec5aa", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2b334f061a7e7e7ff766f934081bc40ebfdaa698", "patch": "@@ -150,7 +150,7 @@ type val_self_pair = rec(ValueRef v, ty::t t);\n type ty_self_pair = tup(TypeRef, ty::t);\n \n // Function context.  Every LLVM function we create will have one of these.\n-state type fn_ctxt = rec(\n+type fn_ctxt = rec(\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the address\n     // of the first instruction in the sequence of instructions for this\n     // function that will go in the .text section of the executable we're\n@@ -305,8 +305,8 @@ tag block_parent {\n }\n \n \n-state type result = rec(mutable @block_ctxt bcx,\n-                        mutable ValueRef val);\n+state type result = rec(@block_ctxt bcx,\n+                        ValueRef val);\n \n fn sep() -> str {\n     ret \"_\";\n@@ -364,8 +364,8 @@ fn mangle_name_by_seq(&@crate_ctxt ccx, &vec[str] path,\n }\n \n fn res(@block_ctxt bcx, ValueRef val) -> result {\n-    ret rec(mutable bcx = bcx,\n-            mutable val = val);\n+    ret rec(bcx = bcx,\n+            val = val);\n }\n \n fn ty_str(type_names tn, TypeRef t) -> str {\n@@ -2019,7 +2019,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n \n         auto ti = pair._1;\n \n-        auto take_glue = alt (ti.take_glue) {\n+        auto take_glue = alt ({ti.take_glue}) {\n             case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n@@ -2030,7 +2030,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n             }\n         };\n \n-        auto drop_glue = alt (ti.drop_glue) {\n+        auto drop_glue = alt ({ti.drop_glue}) {\n             case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n@@ -2041,7 +2041,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n             }\n         };\n \n-        auto free_glue = alt (ti.free_glue) {\n+        auto free_glue = alt ({ti.free_glue}) {\n             case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n@@ -2052,7 +2052,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n             }\n         };\n \n-        auto cmp_glue = alt (ti.cmp_glue) {\n+        auto cmp_glue = alt ({ti.cmp_glue}) {\n             case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(cmp_fn_ty)\n@@ -2998,7 +2998,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n         case (some(?ti)) {\n \n             if(field == abi::tydesc_field_take_glue) {\n-                alt (ti.take_glue) {\n+                alt ({ti.take_glue}) {\n                     case (some(_)) {}\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n@@ -3019,7 +3019,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                     }\n                 }\n             } else if (field == abi::tydesc_field_drop_glue)  {\n-                alt (ti.drop_glue) {\n+                alt ({ti.drop_glue}) {\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue DROP %s\",\n@@ -3039,7 +3039,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                 }\n \n             } else if (field == abi::tydesc_field_free_glue)  {\n-                alt (ti.free_glue) {\n+                alt ({ti.free_glue}) {\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue FREE %s\",\n@@ -3060,7 +3060,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                 }\n \n             } else if (field == abi::tydesc_field_cmp_glue) {\n-                alt (ti.cmp_glue) {\n+                alt ({ti.cmp_glue}) {\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue CMP %s\",\n@@ -3931,7 +3931,7 @@ fn trans_for(&@block_ctxt cx,\n fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n                   &ast::def_id initial_decl) -> vec[ast::def_id] {\n     type env = @rec(\n-        mutable vec[ast::def_id] refs,\n+        vec[ast::def_id] refs,\n         hashmap[ast::def_id,()] decls,\n         resolve::def_map def_map\n     );\n@@ -3965,7 +3965,7 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     let vec[ast::def_id] refs = [];\n     let hashmap[ast::def_id,()] decls = new_def_hash[()]();\n     decls.insert(initial_decl, ());\n-    let env e = @rec(mutable refs=refs,\n+    let env e = @rec(refs=refs,\n                      decls=decls,\n                      def_map=cx.fcx.lcx.ccx.tcx.def_map);\n \n@@ -4717,7 +4717,7 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n             ret lval_mem(sub.bcx, val);\n         }\n         case (ast::expr_self_method(?ident, ?ann)) {\n-            alt (cx.fcx.llself) {\n+            alt ({cx.fcx.llself}) {\n                 case (some(?pair)) {\n                     auto r =  pair.v;\n                     auto t =  pair.t;\n@@ -4765,12 +4765,15 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n         // TODO: native-to-native casts\n         if (ty::type_is_native(cx.fcx.lcx.ccx.tcx,\n                               ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n-            e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n+            e_res = res(e_res.bcx,\n+                        e_res.bcx.build.PtrToInt(e_res.val, lldsttype));\n         } else if (ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n-            e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n+            e_res = res(e_res.bcx,\n+                        e_res.bcx.build.IntToPtr(e_res.val, lldsttype));\n         } else {\n-            e_res.val = int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n-                ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t));\n+            e_res = res(e_res.bcx,\n+                        int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n+                                 ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)));\n         }\n     } else {\n         cx.fcx.lcx.ccx.sess.unimpl(\"fp cast\");\n@@ -5767,7 +5770,7 @@ fn with_out_method(fn(&out_method) -> result work, &@block_ctxt cx,\n         find_scope_cx(cx).cleanups += [clean(cleanup)];\n \n         auto done = work(save_in(res_alloca.val));\n-        done.val = load_if_immediate(done.bcx, res_alloca.val, tp);\n+        done = res(done.bcx, load_if_immediate(done.bcx, res_alloca.val, tp));\n         ret done;\n     }\n }\n@@ -5932,7 +5935,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto llcallee = C_nil();\n     auto llenv = C_nil();\n \n-    alt (cx.fcx.lliterbody) {\n+    alt ({cx.fcx.lliterbody}) {\n         case (some(?lli)) {\n             auto slot = alloca(cx, val_ty(lli));\n             cx.build.Store(lli, slot);\n@@ -5971,7 +5974,7 @@ fn trans_break_cont(&@block_ctxt cx, bool to_end) -> result {\n     auto cleanup_cx = cx;\n     while (true) {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt (cleanup_cx.kind) {\n+        alt ({cleanup_cx.kind}) {\n             case (LOOP_SCOPE_BLOCK(?_cont, ?_break)) {\n                 if (to_end) {\n                     bcx.build.Br(_break.llbb);\n@@ -5989,7 +5992,7 @@ fn trans_break_cont(&@block_ctxt cx, bool to_end) -> result {\n                         C_nil());\n             }\n             case (_) {\n-                alt (cleanup_cx.parent) {\n+                alt ({cleanup_cx.parent}) {\n                     case (parent_some(?cx)) { cleanup_cx = cx; }\n                 }\n             }\n@@ -6033,7 +6036,7 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto cleanup_cx = cx;\n     while (more_cleanups) {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt (cleanup_cx.parent) {\n+        alt ({cleanup_cx.parent}) {\n             case (parent_some(?b)) {\n                 cleanup_cx = b;\n             }\n@@ -6831,7 +6834,7 @@ fn copy_any_self_to_alloca(@fn_ctxt fcx,\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n-    alt (fcx.llself) {\n+    alt ({fcx.llself}) {\n         case (some(?pair)) {\n             alt (ty_self) {\n                 case (some[ty_self_pair](?tt)) {\n@@ -7000,7 +7003,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n \n     copy_any_self_to_alloca(fcx, ty_self);\n \n-    alt (fcx.llself) {\n+    alt ({fcx.llself}) {\n         case (some(?llself)) {\n             populate_fn_ctxt_from_llself(fcx, llself);\n         }"}, {"sha": "3b7061bb987b1bd561ff2e60ba5811d4be77ecc2", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2b334f061a7e7e7ff766f934081bc40ebfdaa698", "patch": "@@ -1540,7 +1540,7 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n         -> ty_param_substs_opt_and_ty {\n-    alt (ntt.(ann.id)) {\n+    alt ({ntt.(ann.id)}) {\n         case (none) {\n             log_err \"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n                 \"untyped node\";"}, {"sha": "11fbab4ddde44f1a2046648ee7a814f8d456f6b8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b334f061a7e7e7ff766f934081bc40ebfdaa698/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2b334f061a7e7e7ff766f934081bc40ebfdaa698", "patch": "@@ -379,11 +379,13 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n mod write {\n     fn inner(&node_type_table ntt, uint node_id,\n              &ty_param_substs_opt_and_ty tpot) {\n+        auto ntt_ = *ntt;\n         vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n-            (*ntt,\n+            (ntt_,\n              node_id,\n              none[ty_param_substs_opt_and_ty],\n              some[ty_param_substs_opt_and_ty](tpot));\n+        *ntt = ntt_;\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n@@ -792,7 +794,7 @@ mod collect {\n         // type of the native item. We simply write it into the node type\n         // table.\n         auto tpt = ty_of_native_item(cx, i,\n-                                     option::get[ast::native_abi](*abi));\n+                                     option::get[ast::native_abi]({*abi}));\n \n         alt (i.node) {\n             case (ast::native_item_ty(_,_)) {\n@@ -921,7 +923,7 @@ mod unify {\n         auto result = ty::unify::unify(expected, actual, handler, bindings,\n                                        scx.fcx.ccx.tcx);\n \n-        alt (result) {\n+        alt ({result}) {\n             case (ures_ok(?rty)) {\n                 if (ty::type_contains_vars(scx.fcx.ccx.tcx, rty)) {\n                     result = ty::unify::fixup(scx.fcx.ccx.tcx, bindings, rty);"}]}