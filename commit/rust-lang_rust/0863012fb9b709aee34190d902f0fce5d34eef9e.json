{"sha": "0863012fb9b709aee34190d902f0fce5d34eef9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NjMwMTJmYjliNzA5YWVlMzQxOTBkOTAyZjBmY2U1ZDM0ZWVmOWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-01T13:55:33Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:01Z"}, "message": "Remove librbml and the RBML-tagged auto-encoder/decoder.", "tree": {"sha": "f52693027b747a953c9aa7e308cfde2a65f0c652", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52693027b747a953c9aa7e308cfde2a65f0c652"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0863012fb9b709aee34190d902f0fce5d34eef9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0863012fb9b709aee34190d902f0fce5d34eef9e", "html_url": "https://github.com/rust-lang/rust/commit/0863012fb9b709aee34190d902f0fce5d34eef9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0863012fb9b709aee34190d902f0fce5d34eef9e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "html_url": "https://github.com/rust-lang/rust/commit/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307"}], "stats": {"total": 1927, "additions": 411, "deletions": 1516}, "files": [{"sha": "86bb3a8ca0ccc8b09ec4bf277ed59b0513732516", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -61,7 +61,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n                 rustc_const_eval rustc_const_math rustc_incremental rustc_macro\n HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n-\t\tflate arena graphviz rbml log serialize\n+\t\tflate arena graphviz log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n@@ -96,7 +96,6 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_rbml := std log serialize\n DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n@@ -110,7 +109,7 @@ DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n \t\t\t     rustc_back graphviz syntax_pos\n \n-DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n+DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t      rustc_const_math syntax_pos rustc_errors\n DEPS_rustc_back := std syntax flate log libc\n@@ -126,7 +125,7 @@ DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_macro := std syntax\n-DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math \\\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n \t\t\trustc_macro syntax_ext\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n@@ -137,7 +136,7 @@ DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n-DEPS_rustc_incremental := rbml rustc syntax_pos serialize rustc_data_structures\n+DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval rustc_errors"}, {"sha": "fc1f4b5561a78c7742bc13e830c62a1bf0caaf9f", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -27,7 +27,7 @@ TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n \t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES) arena flate fmt_macros getopts graphviz \\\n-                log rand rbml serialize syntax term test\n+                log rand serialize syntax term test\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve \\\n \t\t   \t\trustc_trans rustc_lint,\\\n                      $(HOST_CRATES))"}, {"sha": "ab89ac2b7a1eb6a1c5f66cccd696d9ca3a863c1d", "filename": "src/librbml/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrbml%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrbml%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2FCargo.toml?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rbml\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rbml\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-log = { path = \"../liblog\" }\n-serialize = { path = \"../libserialize\" }"}, {"sha": "65259f903a99cdc3c05c94cff6dd6a45e9230eaf", "filename": "src/librbml/lib.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Skeleton of RBML (Really Bad Markup Language).\n-//! See `src/librustc_metadata/reader.rs` for more details.\n-\n-#![crate_name = \"rbml\"]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n-#![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(question_mark)]\n-\n-#![cfg_attr(test, feature(test))]\n-\n-extern crate serialize;\n-\n-#[cfg(test)]\n-extern crate serialize as rustc_serialize; // Used by RustcEncodable\n-\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(test)]\n-extern crate test;\n-\n-pub mod opaque;\n-pub mod leb128;\n-\n-pub use self::Error::*;\n-\n-use std::fmt;\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    IntTooBig(usize),\n-    InvalidTag(usize),\n-    Expected(String),\n-    IoError(std::io::Error),\n-    ApplicationError(String),\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME: this should be a more useful display form\n-        fmt::Debug::fmt(self, f)\n-    }\n-}"}, {"sha": "578ef68b00386f3be294d68748acafc59128460f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -14,7 +14,6 @@ flate = { path = \"../libflate\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "c34286f0195bfb61005beb5bdc676537932ae928", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -50,7 +50,6 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rbml;\n extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;"}, {"sha": "1d6047579f6cfad9d970dfd974408e4bb7a086d7", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -265,8 +265,7 @@ pub trait CrateStore<'tcx> {\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>;\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -472,8 +471,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n "}, {"sha": "e3ee7527545042211481ecf9d36f6e228c23f0bc", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -10,10 +10,9 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n-rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "42b5657e212b02be11d3c9938372368c286e5f97", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -27,7 +27,6 @@\n #![feature(core_intrinsics)]\n \n extern crate graphviz;\n-extern crate rbml;\n #[macro_use] extern crate rustc;\n extern crate rustc_data_structures;\n extern crate serialize as rustc_serialize;"}, {"sha": "5a4716e45f6e1f9ae6af39fe04ac38394bae6cc0", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rbml::Error;\n-use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n+use rustc_serialize::opaque::Decoder;\n use std::io::{ErrorKind, Read};\n use std::fs::File;\n \n@@ -188,7 +187,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     fn load_from_data(&mut self,\n                       cnum: CrateNum,\n                       data: &[u8],\n-                      expected_svh: Svh) -> Result<(), Error> {\n+                      expected_svh: Svh) -> Result<(), String> {\n         debug!(\"load_from_data(cnum={})\", cnum);\n \n         // Load up the hashes for the def-ids from this crate."}, {"sha": "b051e6c5ab73a1f759d061c1b6049b43f2216895", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -10,14 +10,13 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rbml::Error;\n-use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n+use rustc_serialize::opaque::Decoder;\n use std::io::Read;\n use std::fs::{self, File};\n use std::path::{Path};\n@@ -121,7 +120,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n-                                  -> Result<(), Error>\n+                                  -> Result<(), String>\n {\n     // Decode the list of work_products\n     let mut work_product_decoder = Decoder::new(work_products_data, 0);"}, {"sha": "5b45874840f5676fec5c559e4dd5b86badc00def", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n+use rustc_serialize::opaque::Encoder;\n use std::hash::{Hash, Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};"}, {"sha": "fede6f663418c3cb9057302f6ff92e0e587ee8fb", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -11,7 +11,6 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate = { path = \"../libflate\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "f00c4b82a8518c32f6e344659a1253785afc0b10", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -217,7 +217,7 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n }\n \n fn decode_side_tables(dcx: &mut DecodeContext, ast_doc: rbml::Doc) {\n-    while dcx.position() < ast_doc.end {\n+    while dcx.opaque.position() < ast_doc.end {\n         let table = Decodable::decode(dcx).unwrap();\n         let id = Decodable::decode(dcx).unwrap();\n         debug!(\"decode_side_tables: entry for id={}, table={:?}\", id, table);"}, {"sha": "3b63ee6b5fa8947afda97f7f473258661268dadc", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -10,12 +10,9 @@\n \n #![allow(non_camel_case_types, non_upper_case_globals)]\n \n-// RBML enum definitions and utils shared by the encoder and decoder\n-//\n-// 0x00..0x1f: reserved for RBML generic type tags\n-// 0x20..0xef: free for use, preferred for frequent tags\n-// 0xf0..0xff: internally used by RBML to encode 0x100..0xfff in two bytes\n-// 0x100..0xfff: free for use, preferred for infrequent tags\n+pub const tag_opaque: usize = 0x00;\n+\n+// GAP 0x01...0x19\n \n pub const tag_items: usize = 0x100; // top-level only\n "}, {"sha": "b291c4927aa3f12e544714ce67f0cef10a56bfff", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -13,7 +13,6 @@ use common;\n use decoder;\n use encoder;\n use loader;\n-use rbml;\n \n use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n@@ -30,7 +29,6 @@ use rustc::mir::mir_map::MirMap;\n use rustc::util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n use rustc::session::config::PanicStrategy;\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n@@ -697,22 +695,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>\n-    {\n-        let type_abbrevs = RefCell::new(FnvHashMap());\n-        let ecx = encoder::EncodeContext {\n-            rbml_w: rbml::writer::Encoder::new(),\n-            tcx: tcx,\n-            reexports: reexports,\n-            link_meta: link_meta,\n-            cstore: self,\n-            reachable: reachable,\n-            mir_map: mir_map,\n-            type_abbrevs: &type_abbrevs,\n-        };\n-        encoder::encode_metadata(ecx, krate)\n-\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8>\n+    {\n+        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable, mir_map)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "ba593e5be9980c4b0138cd2351129f0bd708c69c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -45,22 +45,22 @@ use rustc_const_math::ConstInt;\n use rustc::mir::repr::Mir;\n \n use std::io;\n-use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::str;\n use std::u32;\n \n use rbml::reader;\n use rbml;\n-use rustc_serialize::{Decodable, SpecializedDecoder};\n+use rustc_serialize::{Decodable, SpecializedDecoder, opaque};\n+use rustc_serialize as serialize;\n use syntax::attr;\n use syntax::parse::token;\n use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n-    rbml_r: rbml::reader::Decoder<'a>,\n+    pub opaque: opaque::Decoder<'a>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     pub cdata: Option<&'a cstore::CrateMetadata>,\n     pub from_id_range: IdRange,\n@@ -76,7 +76,7 @@ impl<'doc> rbml::Doc<'doc> {\n             max: NodeId::from_u32(u32::MAX)\n         };\n         DecodeContext {\n-            rbml_r: reader::Decoder::new(self),\n+            opaque: opaque::Decoder::new(self.data, self.start),\n             cdata: None,\n             tcx: None,\n             from_id_range: id_range,\n@@ -98,24 +98,49 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     fn read_ty_encoded<F, R>(&mut self, op: F) -> R\n         where F: for<'x> FnOnce(&mut TyDecoder<'x,'tcx>) -> R\n     {\n-        self.read_opaque(|this, doc| {\n-            Ok(op(&mut TyDecoder::with_doc(\n-                this.tcx(), this.cdata().cnum, doc,\n-                &mut |d| translate_def_id(this.cdata(), d))))\n-        }).unwrap()\n+        let pos = self.opaque.position();\n+        let doc = rbml::Doc::at(self.opaque.data, pos);\n+        self.opaque.advance(doc.end - pos);\n+        op(&mut TyDecoder::with_doc(self.tcx(), self.cdata().cnum, doc,\n+                                    &mut |d| translate_def_id(self.cdata(), d)))\n     }\n }\n \n-impl<'a, 'tcx> Deref for DecodeContext<'a, 'tcx> {\n-    type Target = rbml::reader::Decoder<'a>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.rbml_r\n+macro_rules! decoder_methods {\n+    ($($name:ident -> $ty:ty;)*) => {\n+        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n+            self.opaque.$name()\n+        })*\n     }\n }\n \n-impl<'a, 'tcx> DerefMut for DecodeContext<'a, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.rbml_r\n+impl<'doc, 'tcx> serialize::Decoder for ::decoder::DecodeContext<'doc, 'tcx> {\n+    type Error = <opaque::Decoder<'doc> as serialize::Decoder>::Error;\n+\n+    decoder_methods! {\n+        read_nil -> ();\n+\n+        read_u64 -> u64;\n+        read_u32 -> u32;\n+        read_u16 -> u16;\n+        read_u8 -> u8;\n+        read_usize -> usize;\n+\n+        read_i64 -> i64;\n+        read_i32 -> i32;\n+        read_i16 -> i16;\n+        read_i8 -> i8;\n+        read_isize -> isize;\n+\n+        read_bool -> bool;\n+        read_f64 -> f64;\n+        read_f32 -> f32;\n+        read_char -> char;\n+        read_str -> String;\n+    }\n+\n+    fn error(&mut self, err: &str) -> Self::Error {\n+        self.opaque.error(err)\n     }\n }\n \n@@ -256,7 +281,7 @@ pub type Cmd<'a> = &'a CrateMetadata;\n impl CrateMetadata {\n     fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n-            reader::doc_at(self.data(), pos as usize).unwrap().doc\n+            rbml::Doc::at(self.data(), pos as usize)\n         })\n     }\n "}, {"sha": "4b603fcb1055d4a1993caa83cfced7d8f96f21f2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 134, "deletions": 110, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -35,9 +35,10 @@ use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n-use rustc_serialize::{Encodable, SpecializedEncoder};\n+use rustc_serialize::{Encodable, SpecializedEncoder, opaque};\n+use rustc_serialize as serialize;\n use std::io::prelude::*;\n-use std::io::SeekFrom;\n+use std::io::Cursor;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n@@ -55,7 +56,7 @@ use rustc::hir::map::DefKey;\n use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub rbml_w: rbml::writer::Encoder,\n+    pub rbml_w: rbml::writer::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub link_meta: &'a LinkMeta,\n@@ -66,7 +67,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n-    type Target = rbml::writer::Encoder;\n+    type Target = rbml::writer::Encoder<'a>;\n     fn deref(&self) -> &Self::Target {\n         &self.rbml_w\n     }\n@@ -78,21 +79,61 @@ impl<'a, 'tcx> DerefMut for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+macro_rules! encoder_methods {\n+    ($($name:ident($ty:ty);)*) => {\n+        $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n+            self.opaque.$name(value)\n+        })*\n+    }\n+}\n+\n+impl<'a, 'tcx> serialize::Encoder for ::encoder::EncodeContext<'a, 'tcx> {\n+    type Error = <opaque::Encoder<'a> as serialize::Encoder>::Error;\n+\n+    fn emit_nil(&mut self) -> Result<(), Self::Error> {\n+        Ok(())\n+    }\n+\n+    encoder_methods! {\n+        emit_usize(usize);\n+        emit_u64(u64);\n+        emit_u32(u32);\n+        emit_u16(u16);\n+        emit_u8(u8);\n+\n+        emit_isize(isize);\n+        emit_i64(i64);\n+        emit_i32(i32);\n+        emit_i16(i16);\n+        emit_i8(i8);\n+\n+        emit_bool(bool);\n+        emit_f64(f64);\n+        emit_f32(f32);\n+        emit_char(char);\n+        emit_str(&str);\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         let cx = self.ty_str_ctxt();\n-        self.emit_opaque(|opaque_encoder| {\n-            Ok(tyencode::enc_ty(opaque_encoder.cursor, &cx, ty))\n-        })\n+\n+        self.start_tag(tag_opaque)?;\n+        tyencode::enc_ty(&mut self.rbml_w.opaque.cursor, &cx, ty);\n+        self.mark_stable_position();\n+        self.end_tag()\n     }\n }\n \n impl<'a, 'tcx> SpecializedEncoder<&'tcx Substs<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, substs: &&'tcx Substs<'tcx>) -> Result<(), Self::Error> {\n         let cx = self.ty_str_ctxt();\n-        self.emit_opaque(|opaque_encoder| {\n-            Ok(tyencode::enc_substs(opaque_encoder.cursor, &cx, substs))\n-        })\n+\n+        self.start_tag(tag_opaque)?;\n+        tyencode::enc_substs(&mut self.rbml_w.opaque.cursor, &cx, substs);\n+        self.mark_stable_position();\n+        self.end_tag()\n     }\n }\n \n@@ -124,7 +165,7 @@ fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                               tag: usize) {\n     let cx = ecx.ty_str_ctxt();\n     ecx.start_tag(tag);\n-    tyencode::enc_trait_ref(&mut ecx.writer, &cx, trait_ref);\n+    tyencode::enc_trait_ref(&mut ecx.opaque.cursor, &cx, trait_ref);\n     ecx.mark_stable_position();\n     ecx.end_tag();\n }\n@@ -173,15 +214,15 @@ fn encode_variant_id(ecx: &mut EncodeContext, vid: DefId) {\n fn write_closure_type<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                                 closure_type: &ty::ClosureTy<'tcx>) {\n     let cx = ecx.ty_str_ctxt();\n-    tyencode::enc_closure_ty(&mut ecx.writer, &cx, closure_type);\n+    tyencode::enc_closure_ty(&mut ecx.opaque.cursor, &cx, closure_type);\n     ecx.mark_stable_position();\n }\n \n impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_type(&mut self, typ: Ty<'tcx>) {\n         let cx = self.ty_str_ctxt();\n         self.start_tag(tag_items_data_item_type);\n-        tyencode::enc_ty(&mut self.writer, &cx, typ);\n+        tyencode::enc_ty(&mut self.opaque.cursor, &cx, typ);\n         self.mark_stable_position();\n         self.end_tag();\n     }\n@@ -480,7 +521,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     {\n         let cx = self.ty_str_ctxt();\n         self.start_tag(tag_item_generics);\n-        tyencode::enc_generics(&mut self.writer, &cx, generics);\n+        tyencode::enc_generics(&mut self.opaque.cursor, &cx, generics);\n         self.mark_stable_position();\n         self.end_tag();\n         self.encode_predicates(predicates, tag_item_predicates);\n@@ -829,15 +870,15 @@ fn encode_xrefs<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n         xref_positions[id as usize] = ecx.mark_stable_position() as u32;\n         match xref {\n             XRef::Predicate(p) => {\n-                tyencode::enc_predicate(&mut ecx.writer, &cx, &p)\n+                tyencode::enc_predicate(&mut ecx.opaque.cursor, &cx, &p)\n             }\n         }\n     }\n     ecx.mark_stable_position();\n     ecx.end_tag();\n \n     ecx.start_tag(tag_xref_index);\n-    index::write_dense_index(xref_positions, &mut ecx.writer);\n+    index::write_dense_index(xref_positions, &mut ecx.opaque.cursor);\n     ecx.end_tag();\n }\n \n@@ -1396,7 +1437,7 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>)\n \n fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n     ecx.start_tag(tag_index);\n-    index.write_index(&mut ecx.writer);\n+    index.write_index(&mut ecx.opaque.cursor);\n     ecx.end_tag();\n }\n \n@@ -1710,15 +1751,33 @@ fn encode_panic_strategy(ecx: &mut EncodeContext) {\n     }\n }\n \n-pub fn encode_metadata(mut ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n-    encode_metadata_inner(&mut ecx, krate);\n+pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 cstore: &cstore::CStore,\n+                                 reexports: &def::ExportMap,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet,\n+                                 mir_map: &MirMap<'tcx>) -> Vec<u8> {\n+    let mut cursor = Cursor::new(vec![]);\n+    cursor.write_all(&[0, 0, 0, 0]).unwrap();\n+    cursor.write_all(metadata_encoding_version).unwrap();\n+    // Will be filed with the length after encoding the crate.\n+    cursor.write_all(&[0, 0, 0, 0]).unwrap();\n+\n+    encode_metadata_inner(&mut EncodeContext {\n+        rbml_w: rbml::writer::Encoder::new(&mut cursor),\n+        tcx: tcx,\n+        reexports: reexports,\n+        link_meta: link_meta,\n+        cstore: cstore,\n+        reachable: reachable,\n+        mir_map: mir_map,\n+        type_abbrevs: &Default::default(),\n+    });\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n-    let metalen = ecx.rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() as usize;\n-    let mut v = ecx.rbml_w.writer.into_inner();\n-    v.truncate(metalen);\n-    assert_eq!(v.len(), metalen);\n+    let meta_len = cursor.position() as usize;\n+    cursor.get_mut().truncate(meta_len);\n \n     // And here we run into yet another obscure archive bug: in which metadata\n     // loaded from archives may have trailing garbage bytes. Awhile back one of\n@@ -1744,55 +1803,17 @@ pub fn encode_metadata(mut ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     // this metadata, there are 4 zero bytes at the start, which are\n     // treated as a length of 0 by old compilers.\n \n-    let len = v.len();\n-    let mut result = vec![];\n-    result.push(0);\n-    result.push(0);\n-    result.push(0);\n-    result.push(0);\n-    result.extend(metadata_encoding_version.iter().cloned());\n-    result.push((len >> 24) as u8);\n-    result.push((len >> 16) as u8);\n-    result.push((len >>  8) as u8);\n-    result.push((len >>  0) as u8);\n-    result.extend(v);\n+    let meta_start = 8 + ::common::metadata_encoding_version.len();\n+    let len = meta_len - meta_start;\n+    let mut result = cursor.into_inner();\n+    result[meta_start - 4] = (len >> 24) as u8;\n+    result[meta_start - 3] = (len >> 16) as u8;\n+    result[meta_start - 2] = (len >>  8) as u8;\n+    result[meta_start - 1] = (len >>  0) as u8;\n     result\n }\n \n-fn encode_metadata_inner(ecx: &mut EncodeContext, krate: &hir::Crate) {\n-    struct Stats {\n-        attr_bytes: u64,\n-        dep_bytes: u64,\n-        lang_item_bytes: u64,\n-        native_lib_bytes: u64,\n-        plugin_registrar_fn_bytes: u64,\n-        codemap_bytes: u64,\n-        macro_defs_bytes: u64,\n-        impl_bytes: u64,\n-        reachable_bytes: u64,\n-        item_bytes: u64,\n-        index_bytes: u64,\n-        xref_bytes: u64,\n-        zero_bytes: u64,\n-        total_bytes: u64,\n-    }\n-    let mut stats = Stats {\n-        attr_bytes: 0,\n-        dep_bytes: 0,\n-        lang_item_bytes: 0,\n-        native_lib_bytes: 0,\n-        plugin_registrar_fn_bytes: 0,\n-        codemap_bytes: 0,\n-        macro_defs_bytes: 0,\n-        impl_bytes: 0,\n-        reachable_bytes: 0,\n-        item_bytes: 0,\n-        index_bytes: 0,\n-        xref_bytes: 0,\n-        zero_bytes: 0,\n-        total_bytes: 0,\n-    };\n-\n+fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     encode_rustc_version(ecx);\n \n     let tcx = ecx.tcx;\n@@ -1804,89 +1825,92 @@ fn encode_metadata_inner(ecx: &mut EncodeContext, krate: &hir::Crate) {\n     encode_dylib_dependency_formats(ecx);\n     encode_panic_strategy(ecx);\n \n-    let mut i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    let krate = tcx.map.krate();\n+\n+    let mut i = ecx.position();\n     encode_attributes(ecx, &krate.attrs);\n-    stats.attr_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let attr_bytes = ecx.position() - i;\n \n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_crate_deps(ecx, ecx.cstore);\n-    stats.dep_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let dep_bytes = ecx.position() - i;\n \n     // Encode the language items.\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_lang_items(ecx);\n-    stats.lang_item_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let lang_item_bytes = ecx.position() - i;\n \n     // Encode the native libraries used\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_native_libraries(ecx);\n-    stats.native_lib_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let native_lib_bytes = ecx.position() - i;\n \n     // Encode the plugin registrar function\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_plugin_registrar_fn(ecx);\n-    stats.plugin_registrar_fn_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let plugin_registrar_fn_bytes = ecx.position() - i;\n \n     // Encode codemap\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_codemap(ecx);\n-    stats.codemap_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let codemap_bytes = ecx.position() - i;\n \n     // Encode macro definitions\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_macro_defs(ecx, krate);\n-    stats.macro_defs_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let macro_defs_bytes = ecx.position() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_impls(ecx, krate);\n-    stats.impl_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let impl_bytes = ecx.position() - i;\n \n     // Encode reachability info.\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_reachable(ecx);\n-    stats.reachable_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let reachable_bytes = ecx.position() - i;\n \n     // Encode and index the items.\n     ecx.start_tag(tag_items);\n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     let (items, xrefs) = encode_info_for_items(ecx);\n-    stats.item_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let item_bytes = ecx.position() - i;\n     ecx.end_tag();\n \n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_item_index(ecx, items);\n-    stats.index_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let index_bytes = ecx.position() - i;\n \n-    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    i = ecx.position();\n     encode_xrefs(ecx, xrefs);\n-    stats.xref_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let xref_bytes = ecx.position() - i;\n \n     encode_struct_field_attrs(ecx, krate);\n \n-    stats.total_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    let total_bytes = ecx.position();\n \n     if ecx.tcx.sess.meta_stats() {\n-        for e in ecx.writer.get_ref() {\n+        let mut zero_bytes = 0;\n+        for e in ecx.opaque.cursor.get_ref() {\n             if *e == 0 {\n-                stats.zero_bytes += 1;\n+                zero_bytes += 1;\n             }\n         }\n \n         println!(\"metadata stats:\");\n-        println!(\"       attribute bytes: {}\", stats.attr_bytes);\n-        println!(\"             dep bytes: {}\", stats.dep_bytes);\n-        println!(\"       lang item bytes: {}\", stats.lang_item_bytes);\n-        println!(\"          native bytes: {}\", stats.native_lib_bytes);\n-        println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n-        println!(\"         codemap bytes: {}\", stats.codemap_bytes);\n-        println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n-        println!(\"            impl bytes: {}\", stats.impl_bytes);\n-        println!(\"       reachable bytes: {}\", stats.reachable_bytes);\n-        println!(\"            item bytes: {}\", stats.item_bytes);\n-        println!(\"           index bytes: {}\", stats.index_bytes);\n-        println!(\"            xref bytes: {}\", stats.xref_bytes);\n-        println!(\"            zero bytes: {}\", stats.zero_bytes);\n-        println!(\"           total bytes: {}\", stats.total_bytes);\n+        println!(\"       attribute bytes: {}\", attr_bytes);\n+        println!(\"             dep bytes: {}\", dep_bytes);\n+        println!(\"       lang item bytes: {}\", lang_item_bytes);\n+        println!(\"          native bytes: {}\", native_lib_bytes);\n+        println!(\"plugin registrar bytes: {}\", plugin_registrar_fn_bytes);\n+        println!(\"         codemap bytes: {}\", codemap_bytes);\n+        println!(\"       macro def bytes: {}\", macro_defs_bytes);\n+        println!(\"            impl bytes: {}\", impl_bytes);\n+        println!(\"       reachable bytes: {}\", reachable_bytes);\n+        println!(\"            item bytes: {}\", item_bytes);\n+        println!(\"           index bytes: {}\", index_bytes);\n+        println!(\"            xref bytes: {}\", xref_bytes);\n+        println!(\"            zero bytes: {}\", zero_bytes);\n+        println!(\"           total bytes: {}\", total_bytes);\n     }\n }"}, {"sha": "63d7f1b58bb0dc3ade660f6384cad4de9ea6227f", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -73,15 +73,15 @@ impl IndexData {\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, position: u64) {\n+    pub fn record(&mut self, def_id: DefId, position: usize) {\n         assert!(def_id.is_local());\n         self.record_index(def_id.index, position);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, position: u64) {\n+    pub fn record_index(&mut self, item: DefIndex, position: usize) {\n         let item = item.as_usize();\n \n-        assert!(position < (u32::MAX as u64));\n+        assert!(position < (u32::MAX as usize));\n         let position = position as u32;\n \n         assert!(self.positions[item] == u32::MAX,"}, {"sha": "fd25128575f1ae55124990767d6faf4f6cea260d", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -28,10 +28,9 @@\n //! incremental compilation purposes.\n //!\n //! The `IndexBuilder` facilitates both of these. It is created\n-//! with an RBML encoder isntance (`rbml_w`) along with an\n-//! `EncodingContext` (`ecx`), which it encapsulates. It has one main\n-//! method, `record()`. You invoke `record` like so to create a new\n-//! `data_item` element in the list:\n+//! with an `EncodingContext` (`ecx`), which it encapsulates.\n+//! It has one main method, `record()`. You invoke `record`\n+//! like so to create a new `data_item` element in the list:\n //!\n //! ```\n //! index.record(some_def_id, callback_fn, data)\n@@ -43,9 +42,9 @@\n //! returns, the `common::data_item` tag will be closed.\n //!\n //! The `ItemContentBuilder` is another type that just offers access\n-//! to the `ecx` and `rbml_w` that were given in, as well as\n-//! maintaining a list of `xref` instances, which are used to extract\n-//! common data so it is not re-serialized.\n+//! to the `ecx` that was given in, as well as maintaining a list of\n+//! `xref` instances, which are used to extract common data so it is\n+//! not re-serialized.\n //!\n //! `ItemContentBuilder` is a distinct type which does not offer the\n //! `record` method, so that we can ensure that `common::data_item` elements"}, {"sha": "7205a88618fcc0065c894ed393e11fc9ce014aa3", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -51,9 +51,6 @@ extern crate rustc_const_math;\n extern crate test;\n \n pub mod rbml {\n-    pub extern crate rbml as rbml_crate;\n-    pub use self::rbml_crate::{Error, leb128, opaque};\n-\n     pub mod writer;\n     pub mod reader;\n     pub use self::reader::Doc;"}, {"sha": "9bbeb73ce3ecae470dd54952938f417d157d344d", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 31, "deletions": 564, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -45,87 +45,13 @@\n //! **Data** can be either binary bytes or zero or more nested RBML documents.\n //! Nested documents cannot overflow, and should be entirely contained\n //! within a parent document.\n-//!\n-//! # Predefined Tags\n-//!\n-//! Most RBML tags are defined by the application.\n-//! (For the rust object metadata, see also `rustc::metadata::common`.)\n-//! RBML itself does define a set of predefined tags however,\n-//! intended for the auto-serialization implementation.\n-//!\n-//! Predefined tags with an implicit length:\n-//!\n-//! - `U8`  (`00`): 1-byte unsigned integer.\n-//! - `U16` (`01`): 2-byte big endian unsigned integer.\n-//! - `U32` (`02`): 4-byte big endian unsigned integer.\n-//! - `U64` (`03`): 8-byte big endian unsigned integer.\n-//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n-//!   as long as it is no greater than the actual size.\n-//!   For example, `u8` can only be represented via the `U8` tag.\n-//!\n-//! - `I8`  (`04`): 1-byte signed integer.\n-//! - `I16` (`05`): 2-byte big endian signed integer.\n-//! - `I32` (`06`): 4-byte big endian signed integer.\n-//! - `I64` (`07`): 8-byte big endian signed integer.\n-//!   Similar to `U*` tags. Always uses two's complement encoding.\n-//!\n-//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n-//!\n-//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n-//!   Surrogate pairs or out-of-bound values are invalid.\n-//!\n-//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n-//!   IEEE 754 binary32 floating-point format.\n-//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//!\n-//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n-//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n-//!   Those two tags normally occur as the first subdocument of certain tags,\n-//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n-//!   They can be used interchangeably.\n-//!\n-//! Predefined tags with an explicit length:\n-//!\n-//! - `Str` (`10`): A UTF-8-encoded string.\n-//!\n-//! - `Enum` (`11`): An enum.\n-//!   The first subdocument should be `Sub*` tags with a variant ID.\n-//!   Subsequent subdocuments, if any, encode variant arguments.\n-//!\n-//! - `Vec` (`12`): A vector (sequence).\n-//! - `VecElt` (`13`): A vector element.\n-//!   The first subdocument should be `Sub*` tags with the number of elements.\n-//!   Subsequent subdocuments should be `VecElt` tag per each element.\n-//!\n-//! - `Map` (`14`): A map (associated array).\n-//! - `MapKey` (`15`): A key part of the map entry.\n-//! - `MapVal` (`16`): A value part of the map entry.\n-//!   The first subdocument should be `Sub*` tags with the number of entries.\n-//!   Subsequent subdocuments should be an alternating sequence of\n-//!   `MapKey` and `MapVal` tags per each entry.\n-//!\n-//! - `Opaque` (`17`): An opaque, custom-format tag.\n-//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type information.\n-//!\n-//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n \n #[cfg(test)]\n use test::Bencher;\n \n-pub use self::EbmlEncoderTag::*;\n-\n-use std::char;\n-use std::isize;\n-use std::mem::transmute;\n+use std::fmt;\n use std::str;\n \n-use rustc_serialize as serialize;\n-\n-use rbml::Error;\n-use rbml::Error::*;\n-\n #[derive(Clone, Copy)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n@@ -142,6 +68,17 @@ impl<'doc> Doc<'doc> {\n         }\n     }\n \n+    pub fn at(data: &'doc [u8], start: usize) -> Doc<'doc> {\n+        let elt_tag = tag_at(data, start).unwrap();\n+        let elt_size = tag_len_at(data, elt_tag.next).unwrap();\n+        let end = elt_size.next + elt_size.val;\n+        Doc {\n+            data: data,\n+            start: elt_size.next,\n+            end: end,\n+        }\n+    }\n+\n     pub fn get(&self, tag: usize) -> Doc<'doc> {\n         get_doc(*self, tag)\n     }\n@@ -159,54 +96,19 @@ impl<'doc> Doc<'doc> {\n     }\n }\n \n-pub struct TaggedDoc<'a> {\n-    tag: usize,\n-    pub doc: Doc<'a>,\n+#[derive(Debug)]\n+pub enum Error {\n+    IntTooBig(usize),\n+    InvalidTag(usize)\n }\n \n-pub type DecodeResult<T> = Result<T, Error>;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EbmlEncoderTag {\n-    // tags 00..1f are reserved for auto-serialization.\n-    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-    EsU8 = 0x00, // + 1 byte\n-    EsU16 = 0x01, // + 2 bytes\n-    EsU32 = 0x02, // + 4 bytes\n-    EsU64 = 0x03, // + 8 bytes\n-    EsI8 = 0x04, // + 1 byte\n-    EsI16 = 0x05, // + 2 bytes\n-    EsI32 = 0x06, // + 4 bytes\n-    EsI64 = 0x07, // + 8 bytes\n-    EsBool = 0x08, // + 1 byte\n-    EsChar = 0x09, // + 4 bytes\n-    EsF32 = 0x0a, // + 4 bytes\n-    EsF64 = 0x0b, // + 8 bytes\n-    EsSub8 = 0x0c, // + 1 byte\n-    EsSub32 = 0x0d, // + 4 bytes\n-    // 0x0e and 0x0f are reserved\n-    EsStr = 0x10,\n-    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt = 0x13,\n-    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey = 0x15,\n-    EsMapVal = 0x16,\n-    EsOpaque = 0x17,\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME: this should be a more useful display form\n+        fmt::Debug::fmt(self, f)\n+    }\n }\n \n-pub const NUM_IMPLICIT_TAGS: usize = 0x0e;\n-\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    1, 2, 4, 8, // EsU*\n-    1, 2, 4, 8, // ESI*\n-    1, // EsBool\n-    4, // EsChar\n-    4, 8, // EsF*\n-    1, 4, // EsSub*\n-];\n-\n // rbml reading\n \n macro_rules! try_or {\n@@ -227,7 +129,7 @@ pub struct Res {\n     pub next: usize,\n }\n \n-pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+pub fn tag_at(data: &[u8], start: usize) -> Result<Res, Error> {\n     let v = data[start] as usize;\n     if v < 0xf0 {\n         Ok(Res {\n@@ -241,12 +143,12 @@ pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n         })\n     } else {\n         // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-        Err(InvalidTag(v))\n+        Err(Error::InvalidTag(v))\n     }\n }\n \n #[inline(never)]\n-fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n+fn vuint_at_slow(data: &[u8], start: usize) -> Result<Res, Error> {\n     let a = data[start];\n     if a & 0x80 != 0 {\n         return Ok(Res {\n@@ -275,10 +177,10 @@ fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n             next: start + 4,\n         });\n     }\n-    Err(IntTooBig(a as usize))\n+    Err(Error::IntTooBig(a as usize))\n }\n \n-pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+pub fn vuint_at(data: &[u8], start: usize) -> Result<Res, Error> {\n     if data.len() - start < 4 {\n         return vuint_at_slow(data, start);\n     }\n@@ -332,36 +234,15 @@ pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n     }\n }\n \n-pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n-    if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-        Ok(Res {\n-            val: TAG_IMPLICIT_LEN[tag.val] as usize,\n-            next: tag.next,\n-        })\n-    } else {\n-        vuint_at(data, tag.next)\n-    }\n-}\n-\n-pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-    let elt_tag = tag_at(data, start)?;\n-    let elt_size = tag_len_at(data, elt_tag)?;\n-    let end = elt_size.next + elt_size.val;\n-    Ok(TaggedDoc {\n-        tag: elt_tag.val,\n-        doc: Doc {\n-            data: data,\n-            start: elt_size.next,\n-            end: end,\n-        },\n-    })\n+pub fn tag_len_at(data: &[u8], next: usize) -> Result<Res, Error> {\n+    vuint_at(data, next)\n }\n \n pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = try_or!(tag_at(d.data, pos), None);\n-        let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n+        let elt_size = try_or!(tag_len_at(d.data, elt_tag.next), None);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n             return Some(Doc {\n@@ -378,8 +259,7 @@ pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n     match maybe_get_doc(d, tg) {\n         Some(d) => d,\n         None => {\n-            error!(\"failed to find block with tag {:?}\", tg);\n-            panic!();\n+            bug!(\"failed to find block with tag {:?}\", tg);\n         }\n     }\n }\n@@ -404,7 +284,7 @@ impl<'a> Iterator for DocsIterator<'a> {\n             self.d.start = self.d.end;\n             None\n         });\n-        let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n+        let elt_size = try_or!(tag_len_at(self.d.data, elt_tag.next), {\n             self.d.start = self.d.end;\n             None\n         });\n@@ -509,419 +389,6 @@ pub fn doc_as_i64(d: Doc) -> i64 {\n     doc_as_u64(d) as i64\n }\n \n-pub struct Decoder<'a> {\n-    parent: Doc<'a>,\n-    pos: usize,\n-}\n-\n-impl<'doc> Decoder<'doc> {\n-    pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n-        Decoder {\n-            parent: d,\n-            pos: d.start,\n-        }\n-    }\n-\n-    fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-        debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-        if self.pos >= self.parent.end {\n-            return Err(Expected(format!(\"no more documents in current node!\")));\n-        }\n-        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-        debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-               self.parent.start,\n-               self.parent.end,\n-               self.pos,\n-               r_tag,\n-               r_doc.start,\n-               r_doc.end);\n-        if r_tag != (exp_tag as usize) {\n-            return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                                        exp_tag,\n-                                        r_tag)));\n-        }\n-        if r_doc.end > self.parent.end {\n-            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                         {:#x}\",\n-                                        r_doc.end,\n-                                        self.parent.end)));\n-        }\n-        self.pos = r_doc.end;\n-        Ok(r_doc)\n-    }\n-\n-    fn _next_sub(&mut self) -> DecodeResult<usize> {\n-        // empty vector/map optimization\n-        if self.parent.is_empty() {\n-            return Ok(0);\n-        }\n-\n-        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-        let r = if r_tag == (EsSub8 as usize) {\n-            doc_as_u8(r_doc) as usize\n-        } else if r_tag == (EsSub32 as usize) {\n-            doc_as_u32(r_doc) as usize\n-        } else {\n-            return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n-                                         tag {:?}\",\n-                                        EsSub8,\n-                                        EsSub32,\n-                                        r_tag)));\n-        };\n-        if r_doc.end > self.parent.end {\n-            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                         {:#x}\",\n-                                        r_doc.end,\n-                                        self.parent.end)));\n-        }\n-        self.pos = r_doc.end;\n-        debug!(\"_next_sub result={:?}\", r);\n-        Ok(r)\n-    }\n-\n-    // variable-length unsigned integer with different tags.\n-    // `last_tag` should be the largest allowed unsigned integer tag.\n-    // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-    fn next_uint(&mut self,\n-                 last_tag: EbmlEncoderTag)\n-                 -> DecodeResult<u64> {\n-        if self.pos >= self.parent.end {\n-            return Err(Expected(format!(\"no more documents in current node!\")));\n-        }\n-\n-        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-        let r = if EsU8 as usize <= r_tag && r_tag <= last_tag as usize {\n-            match r_tag - EsU8 as usize {\n-                0 => doc_as_u8(r_doc) as u64,\n-                1 => doc_as_u16(r_doc) as u64,\n-                2 => doc_as_u32(r_doc) as u64,\n-                3 => doc_as_u64(r_doc),\n-                _ => unreachable!(),\n-            }\n-        } else {\n-            return Err(Expected(format!(\"expected EBML doc with tag EsU8 through {:?} but \\\n-                                         found tag {:?}\",\n-                                        last_tag,\n-                                        r_tag)));\n-        };\n-        if r_doc.end > self.parent.end {\n-            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                         {:#x}\",\n-                                        r_doc.end,\n-                                        self.parent.end)));\n-        }\n-        self.pos = r_doc.end;\n-        debug!(\"next_uint({:?}) result={:?}\", last_tag, r);\n-        Ok(r)\n-    }\n-\n-    // variable-length signed integer with different tags.\n-    // `last_tag` should be the largest allowed signed integer tag.\n-    // all tags between them should be valid, in the order of i8, i16, i32 and i64.\n-    fn next_int(&mut self,\n-                last_tag: EbmlEncoderTag)\n-                -> DecodeResult<i64> {\n-        if self.pos >= self.parent.end {\n-            return Err(Expected(format!(\"no more documents in current node!\")));\n-        }\n-\n-        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-        let r = if EsI8 as usize <= r_tag && r_tag <= last_tag as usize {\n-            match r_tag - EsI8 as usize {\n-                0 => doc_as_i8(r_doc) as i64,\n-                1 => doc_as_i16(r_doc) as i64,\n-                2 => doc_as_i32(r_doc) as i64,\n-                3 => doc_as_i64(r_doc),\n-                _ => unreachable!(),\n-            }\n-        } else {\n-            return Err(Expected(format!(\"expected EBML doc with tag EsI8 through {:?} but \\\n-                                         found tag {:?}\",\n-                                        last_tag,\n-                                        r_tag)));\n-        };\n-        if r_doc.end > self.parent.end {\n-            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                         {:#x}\",\n-                                        r_doc.end,\n-                                        self.parent.end)));\n-        }\n-        self.pos = r_doc.end;\n-        debug!(\"next_int({:?}) result={:?}\", last_tag, r);\n-        Ok(r)\n-    }\n-\n-    pub fn position(&self) -> usize {\n-        self.pos\n-    }\n-\n-    pub fn advance(&mut self, bytes: usize) {\n-        self.pos += bytes;\n-    }\n-}\n-\n-impl<'doc, 'tcx> ::decoder::DecodeContext<'doc, 'tcx> {\n-    pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-        where F: FnOnce(&mut Self, Doc) -> DecodeResult<R>\n-    {\n-        let doc = self.next_doc(EsOpaque)?;\n-        op(self, doc)\n-    }\n-\n-    fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        let d = self.next_doc(exp_tag)?;\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f(self)?;\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        Ok(r)\n-    }\n-}\n-\n-impl<'doc, 'tcx> serialize::Decoder for ::decoder::DecodeContext<'doc, 'tcx> {\n-    type Error = Error;\n-    fn read_nil(&mut self) -> DecodeResult<()> {\n-        Ok(())\n-    }\n-\n-    fn read_u64(&mut self) -> DecodeResult<u64> {\n-        self.next_uint(EsU64)\n-    }\n-    fn read_u32(&mut self) -> DecodeResult<u32> {\n-        Ok(self.next_uint(EsU32)? as u32)\n-    }\n-    fn read_u16(&mut self) -> DecodeResult<u16> {\n-        Ok(self.next_uint(EsU16)? as u16)\n-    }\n-    fn read_u8(&mut self) -> DecodeResult<u8> {\n-        Ok(doc_as_u8(self.next_doc(EsU8)?))\n-    }\n-    fn read_usize(&mut self) -> DecodeResult<usize> {\n-        let v = self.read_u64()?;\n-        if v > (::std::usize::MAX as u64) {\n-            Err(IntTooBig(v as usize))\n-        } else {\n-            Ok(v as usize)\n-        }\n-    }\n-\n-    fn read_i64(&mut self) -> DecodeResult<i64> {\n-        Ok(self.next_int(EsI64)? as i64)\n-    }\n-    fn read_i32(&mut self) -> DecodeResult<i32> {\n-        Ok(self.next_int(EsI32)? as i32)\n-    }\n-    fn read_i16(&mut self) -> DecodeResult<i16> {\n-        Ok(self.next_int(EsI16)? as i16)\n-    }\n-    fn read_i8(&mut self) -> DecodeResult<i8> {\n-        Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n-    }\n-    fn read_isize(&mut self) -> DecodeResult<isize> {\n-        let v = self.next_int(EsI64)? as i64;\n-        if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n-            debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-            Err(IntTooBig(v as usize))\n-        } else {\n-            Ok(v as isize)\n-        }\n-    }\n-\n-    fn read_bool(&mut self) -> DecodeResult<bool> {\n-        Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n-    }\n-\n-    fn read_f64(&mut self) -> DecodeResult<f64> {\n-        let bits = doc_as_u64(self.next_doc(EsF64)?);\n-        Ok(unsafe { transmute(bits) })\n-    }\n-    fn read_f32(&mut self) -> DecodeResult<f32> {\n-        let bits = doc_as_u32(self.next_doc(EsF32)?);\n-        Ok(unsafe { transmute(bits) })\n-    }\n-    fn read_char(&mut self) -> DecodeResult<char> {\n-        Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n-    }\n-    fn read_str(&mut self) -> DecodeResult<String> {\n-        Ok(self.next_doc(EsStr)?.to_string())\n-    }\n-\n-    // Compound types:\n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_enum({})\", name);\n-\n-        let doc = self.next_doc(EsEnum)?;\n-\n-        let (old_parent, old_pos) = (self.parent, self.pos);\n-        self.parent = doc;\n-        self.pos = self.parent.start;\n-\n-        let result = f(self)?;\n-\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        Ok(result)\n-    }\n-\n-    fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Self, usize) -> DecodeResult<T>\n-    {\n-        debug!(\"read_enum_variant()\");\n-        let idx = self._next_sub()?;\n-        debug!(\"  idx={}\", idx);\n-\n-        f(self, idx)\n-    }\n-\n-    fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_enum_variant_arg(idx={})\", idx);\n-        f(self)\n-    }\n-\n-    fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Self, usize) -> DecodeResult<T>\n-    {\n-        debug!(\"read_enum_struct_variant()\");\n-        let idx = self._next_sub()?;\n-        debug!(\"  idx={}\", idx);\n-\n-        f(self, idx)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            name: &str,\n-                                            idx: usize,\n-                                            f: F)\n-                                            -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-        f(self)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_struct(name={})\", name);\n-        f(self)\n-    }\n-\n-    fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-        f(self)\n-    }\n-\n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_tuple()\");\n-        self.read_seq(move |d, len| {\n-            if len == tuple_len {\n-                f(d)\n-            } else {\n-                Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n-                                      `{}`\",\n-                                     tuple_len,\n-                                     len)))\n-            }\n-        })\n-    }\n-\n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_tuple_arg(idx={})\", idx);\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_tuple_struct(name={})\", name);\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-        self.read_tuple_arg(idx, f)\n-    }\n-\n-    fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Self, bool) -> DecodeResult<T>\n-    {\n-        debug!(\"read_option()\");\n-        self.read_enum(\"Option\", move |this| {\n-            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                match idx {\n-                    0 => f(this, false),\n-                    1 => f(this, true),\n-                    _ => Err(Expected(format!(\"Expected None or Some\"))),\n-                }\n-            })\n-        })\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self, usize) -> DecodeResult<T>\n-    {\n-        debug!(\"read_seq()\");\n-        self.push_doc(EsVec, move |d| {\n-            let len = d._next_sub()?;\n-            debug!(\"  len={}\", len);\n-            f(d, len)\n-        })\n-    }\n-\n-    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_seq_elt(idx={})\", idx);\n-        self.push_doc(EsVecElt, f)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self, usize) -> DecodeResult<T>\n-    {\n-        debug!(\"read_map()\");\n-        self.push_doc(EsMap, move |d| {\n-            let len = d._next_sub()?;\n-            debug!(\"  len={}\", len);\n-            f(d, len)\n-        })\n-    }\n-\n-    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_map_elt_key(idx={})\", idx);\n-        self.push_doc(EsMapKey, f)\n-    }\n-\n-    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Self) -> DecodeResult<T>\n-    {\n-        debug!(\"read_map_elt_val(idx={})\", idx);\n-        self.push_doc(EsMapVal, f)\n-    }\n-\n-    fn error(&mut self, err: &str) -> Error {\n-        ApplicationError(err.to_string())\n-    }\n-}\n-\n #[test]\n fn test_vuint_at() {\n     let data = &["}, {"sha": "94e9b394f1f90c7eb61a02c2cead3e5264934d27", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "modified", "additions": 32, "deletions": 347, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -12,19 +12,15 @@ use std::mem;\n use std::io::prelude::*;\n use std::io::{self, SeekFrom, Cursor};\n \n-use rbml::opaque;\n-use rbml::reader::EbmlEncoderTag::*;\n-use rbml::reader::NUM_IMPLICIT_TAGS;\n-\n-use rustc_serialize as serialize;\n+use rustc_serialize::opaque;\n \n pub type EncodeResult = io::Result<()>;\n \n // rbml writing\n-pub struct Encoder {\n-    pub writer: Cursor<Vec<u8>>,\n-    size_positions: Vec<u64>,\n-    relax_limit: u64, // do not move encoded bytes before this position\n+pub struct Encoder<'a> {\n+    pub opaque: opaque::Encoder<'a>,\n+    size_positions: Vec<usize>,\n+    relax_limit: usize, // do not move encoded bytes before this position\n }\n \n const NUM_TAGS: usize = 0x1000;\n@@ -65,34 +61,32 @@ pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n     Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n }\n \n-impl Encoder {\n-    pub fn new() -> Encoder {\n+impl<'a> Encoder<'a> {\n+    pub fn new(cursor: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n         Encoder {\n-            writer: Cursor::new(vec![]),\n+            opaque: opaque::Encoder::new(cursor),\n             size_positions: vec![],\n             relax_limit: 0,\n         }\n     }\n \n     pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n         debug!(\"Start tag {:?}\", tag_id);\n-        assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n         // Write the enum ID:\n-        write_tag(&mut self.writer, tag_id)?;\n+        write_tag(&mut self.opaque.cursor, tag_id)?;\n \n         // Write a placeholder four-byte size.\n-        let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n+        let cur_pos = self.position();\n         self.size_positions.push(cur_pos);\n-        let zeroes: &[u8] = &[0, 0, 0, 0];\n-        self.writer.write_all(zeroes)\n+        self.opaque.cursor.write_all(&[0, 0, 0, 0])\n     }\n \n     pub fn end_tag(&mut self) -> EncodeResult {\n         let last_size_pos = self.size_positions.pop().unwrap();\n-        let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-        self.writer.seek(SeekFrom::Start(last_size_pos))?;\n-        let size = (cur_pos - last_size_pos - 4) as usize;\n+        let cur_pos = self.position();\n+        self.opaque.cursor.seek(SeekFrom::Start(last_size_pos as u64))?;\n+        let size = cur_pos - last_size_pos - 4;\n \n         // relax the size encoding for small tags (bigger tags are costly to move).\n         // we should never try to move the stable positions, however.\n@@ -101,18 +95,17 @@ impl Encoder {\n             // we can't alter the buffer in place, so have a temporary buffer\n             let mut buf = [0u8; RELAX_MAX_SIZE];\n             {\n-                let last_size_pos = last_size_pos as usize;\n-                let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n+                let data = &self.opaque.cursor.get_ref()[last_size_pos + 4..cur_pos];\n                 buf[..size].copy_from_slice(data);\n             }\n \n             // overwrite the size and data and continue\n-            write_vuint(&mut self.writer, size)?;\n-            self.writer.write_all(&buf[..size])?;\n+            write_vuint(&mut self.opaque.cursor, size)?;\n+            self.opaque.cursor.write_all(&buf[..size])?;\n         } else {\n             // overwrite the size with an overlong encoding and skip past the data\n-            write_sized_vuint(&mut self.writer, size, 4)?;\n-            self.writer.seek(SeekFrom::Start(cur_pos))?;\n+            write_sized_vuint(&mut self.opaque.cursor, size, 4)?;\n+            self.opaque.cursor.seek(SeekFrom::Start(cur_pos as u64))?;\n         }\n \n         debug!(\"End tag (size = {:?})\", size);\n@@ -128,10 +121,9 @@ impl Encoder {\n     }\n \n     pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-        assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-        write_tag(&mut self.writer, tag_id)?;\n-        write_vuint(&mut self.writer, b.len())?;\n-        self.writer.write_all(b)\n+        write_tag(&mut self.opaque.cursor, tag_id)?;\n+        write_vuint(&mut self.opaque.cursor, b.len())?;\n+        self.opaque.cursor.write_all(b)\n     }\n \n     pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n@@ -147,344 +139,37 @@ impl Encoder {\n         self.wr_tagged_u64(tag_id, v as u64)\n     }\n \n-    #[inline]\n-    pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-        self.wr_tagged_u64(tag_id, v as u64)\n-    }\n-\n     #[inline]\n     pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n         self.wr_tagged_bytes(tag_id, &[v])\n     }\n \n-    #[inline]\n-    pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-        self.wr_tagged_u64(tag_id, v as u64)\n-    }\n-\n-    #[inline]\n-    pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-        self.wr_tagged_u32(tag_id, v as u32)\n-    }\n-\n-    #[inline]\n-    pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-        self.wr_tagged_u16(tag_id, v as u16)\n-    }\n-\n-    #[inline]\n-    pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-        self.wr_tagged_bytes(tag_id, &[v as u8])\n-    }\n-\n     pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n         self.wr_tagged_bytes(tag_id, v.as_bytes())\n     }\n \n-    // for auto-serialization\n-    fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-        write_tag(&mut self.writer, tag_id)?;\n-        self.writer.write_all(b)\n-    }\n-\n-    fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-        let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-        self.wr_tagged_raw_bytes(tag_id, &bytes)\n-    }\n-\n-    fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-        let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-        self.wr_tagged_raw_bytes(tag_id, &bytes)\n-    }\n-\n-    fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-        let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-        self.wr_tagged_raw_bytes(tag_id, &bytes)\n-    }\n-\n-    fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-        self.wr_tagged_raw_bytes(tag_id, &[v])\n-    }\n-\n-    fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-        self.wr_tagged_raw_u64(tag_id, v as u64)\n-    }\n-\n-    fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-        self.wr_tagged_raw_u32(tag_id, v as u32)\n-    }\n-\n-    fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-        self.wr_tagged_raw_u16(tag_id, v as u16)\n-    }\n-\n-    fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-        self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n-    }\n-\n     pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n         debug!(\"Write {:?} bytes\", b.len());\n-        self.writer.write_all(b)\n+        self.opaque.cursor.write_all(b)\n     }\n \n     pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n         debug!(\"Write str: {:?}\", s);\n-        self.writer.write_all(s.as_bytes())\n+        self.opaque.cursor.write_all(s.as_bytes())\n+    }\n+\n+    pub fn position(&mut self) -> usize {\n+        self.opaque.position() as usize\n     }\n \n     /// Returns the current position while marking it stable, i.e.\n     /// generated bytes so far wouldn't be affected by relaxation.\n-    pub fn mark_stable_position(&mut self) -> u64 {\n-        let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n+    pub fn mark_stable_position(&mut self) -> usize {\n+        let pos = self.position();\n         if self.relax_limit < pos {\n             self.relax_limit = pos;\n         }\n-        pos\n-    }\n-\n-    // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-        if v as u8 as usize == v {\n-            self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n-        } else if v as u32 as usize == v {\n-            self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               &format!(\"length or variant id too big: {}\", v)[..]))\n-        }\n-    }\n-\n-    pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n-    {\n-        self.start_tag(EsOpaque as usize)?;\n-        f(&mut opaque::Encoder::new(&mut self.writer))?;\n-        self.mark_stable_position();\n-        self.end_tag()\n-    }\n-}\n-\n-impl<'a, 'tcx> serialize::Encoder for ::encoder::EncodeContext<'a, 'tcx> {\n-    type Error = io::Error;\n-\n-    fn emit_nil(&mut self) -> EncodeResult {\n-        Ok(())\n-    }\n-\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        self.emit_u64(v as u64)\n-    }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        if v as u32 as u64 == v {\n-            self.emit_u32(v as u32)\n-        } else {\n-            self.wr_tagged_raw_u64(EsU64 as usize, v)\n-        }\n-    }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        if v as u16 as u32 == v {\n-            self.emit_u16(v as u16)\n-        } else {\n-            self.wr_tagged_raw_u32(EsU32 as usize, v)\n-        }\n-    }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        if v as u8 as u16 == v {\n-            self.emit_u8(v as u8)\n-        } else {\n-            self.wr_tagged_raw_u16(EsU16 as usize, v)\n-        }\n-    }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        self.wr_tagged_raw_u8(EsU8 as usize, v)\n-    }\n-\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        self.emit_i64(v as i64)\n-    }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        if v as i32 as i64 == v {\n-            self.emit_i32(v as i32)\n-        } else {\n-            self.wr_tagged_raw_i64(EsI64 as usize, v)\n-        }\n-    }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        if v as i16 as i32 == v {\n-            self.emit_i16(v as i16)\n-        } else {\n-            self.wr_tagged_raw_i32(EsI32 as usize, v)\n-        }\n-    }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        if v as i8 as i16 == v {\n-            self.emit_i8(v as i8)\n-        } else {\n-            self.wr_tagged_raw_i16(EsI16 as usize, v)\n-        }\n-    }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        self.wr_tagged_raw_i8(EsI8 as usize, v)\n-    }\n-\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        let bits = unsafe { mem::transmute(v) };\n-        self.wr_tagged_raw_u64(EsF64 as usize, bits)\n-    }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        let bits = unsafe { mem::transmute(v) };\n-        self.wr_tagged_raw_u32(EsF32 as usize, bits)\n-    }\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n-    }\n-\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        self.wr_tagged_str(EsStr as usize, v)\n-    }\n-\n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.start_tag(EsEnum as usize)?;\n-        f(self)?;\n-        self.end_tag()\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self._emit_tagged_sub(v_id)?;\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_struct_variant<F>(&mut self,\n-                                   v_name: &str,\n-                                   v_id: usize,\n-                                   cnt: usize,\n-                                   f: F)\n-                                   -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_enum_variant(v_name, v_id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_enum(\"Option\", f)\n-    }\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-    }\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-\n-        self.emit_enum_variant(\"Some\", 1, 1, f)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        if len == 0 {\n-            // empty vector optimization\n-            return self.wr_tagged_bytes(EsVec as usize, &[]);\n-        }\n-\n-        self.start_tag(EsVec as usize)?;\n-        self._emit_tagged_sub(len)?;\n-        f(self)?;\n-        self.end_tag()\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-\n-        self.start_tag(EsVecElt as usize)?;\n-        f(self)?;\n-        self.end_tag()\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        if len == 0 {\n-            // empty map optimization\n-            return self.wr_tagged_bytes(EsMap as usize, &[]);\n-        }\n-\n-        self.start_tag(EsMap as usize)?;\n-        self._emit_tagged_sub(len)?;\n-        f(self)?;\n-        self.end_tag()\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-\n-        self.start_tag(EsMapKey as usize)?;\n-        f(self)?;\n-        self.end_tag()\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.start_tag(EsMapVal as usize)?;\n-        f(self)?;\n-        self.end_tag()\n+        let meta_start = 8 + ::common::metadata_encoding_version.len();\n+        pos - meta_start\n     }\n }"}, {"sha": "28e7b8852b300b9629eb9affaba15617f108234f", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n-use rbml::leb128;\n+use rustc_serialize::leb128;\n use std::str;\n use syntax::abi;\n use syntax::ast;"}, {"sha": "8cd18d1bfc7e806043be440da62aa0ce17eabaf5", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n use syntax::abi::Abi;\n use syntax::ast;\n \n-use rbml::leb128;\n+use rustc_serialize::leb128;\n use encoder;\n \n pub struct ctxt<'a, 'tcx: 'a> {\n@@ -186,9 +186,10 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n     abbrev.write_all(b\"#\");\n     {\n         let start_position = abbrev.position() as usize;\n+        let meta_start = 8 + ::common::metadata_encoding_version.len() as u64;\n         let bytes_written = leb128::write_unsigned_leb128(abbrev.get_mut(),\n                                                           start_position,\n-                                                          pos);\n+                                                          pos - meta_start);\n         abbrev.set_position((start_position + bytes_written) as u64);\n     }\n "}, {"sha": "a10f8c77ac05f2bd93396e8fe4334738e5046bca", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -1346,8 +1346,7 @@ fn write_metadata(cx: &SharedCrateContext,\n                                           cx.export_map(),\n                                           cx.link_meta(),\n                                           reachable_ids,\n-                                          cx.mir_map(),\n-                                          cx.tcx().map.krate());\n+                                          cx.mir_map());\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n "}, {"sha": "0c5356c0222359c70151d13a3da43bdc8aa07ce4", "filename": "src/libserialize/leb128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "previous_filename": "src/librbml/leb128.rs"}, {"sha": "7cb02e2412c65808e6363456bce5b9c0901f90ba", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -56,6 +56,9 @@ mod collection_impls;\n pub mod hex;\n pub mod json;\n \n+pub mod opaque;\n+pub mod leb128;\n+\n mod rustc_serialize {\n     pub use serialize::*;\n }"}, {"sha": "e97834f63cee4eaf7756c0e884a852fef11654a7", "filename": "src/libserialize/opaque.rs", "status": "renamed", "additions": 2, "deletions": 258, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Error as DecodeError;\n use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n use std::io::{self, Write};\n use serialize;\n@@ -125,131 +124,6 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         let _ = self.cursor.write_all(v.as_bytes());\n         Ok(())\n     }\n-\n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self,\n-                            _v_name: &str,\n-                            v_id: usize,\n-                            _len: usize,\n-                            f: F)\n-                            -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_usize(v_id)?;\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_struct_variant<F>(&mut self,\n-                                   v_name: &str,\n-                                   v_id: usize,\n-                                   cnt: usize,\n-                                   f: F)\n-                                   -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant(v_name, v_id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum(\"Option\", f)\n-    }\n-\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-    }\n-\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant(\"Some\", 1, 1, f)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n }\n \n impl<'a> Encoder<'a> {\n@@ -302,7 +176,7 @@ macro_rules! read_sleb128 {\n \n \n impl<'a> serialize::Decoder for Decoder<'a> {\n-    type Error = DecodeError;\n+    type Error = String;\n \n     fn read_nil(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n@@ -379,138 +253,8 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(s.to_string())\n     }\n \n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let disr = self.read_usize()?;\n-        f(self, disr)\n-    }\n-\n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let disr = self.read_usize()?;\n-        f(self, disr)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            _name: &str,\n-                                            _idx: usize,\n-                                            f: F)\n-                                            -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, _name: &str, _: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct_field<T, F>(&mut self, _name: &str, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_seq(move |d, len| {\n-            if len == tuple_len {\n-                f(d)\n-            } else {\n-                let err = format!(\"Invalid tuple length. Expected {}, found {}\",\n-                                  tuple_len,\n-                                  len);\n-                Err(DecodeError::Expected(err))\n-            }\n-        })\n-    }\n-\n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T, F>(&mut self, _name: &str, len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_tuple_arg(idx, f)\n-    }\n-\n-    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, bool) -> Result<T, Self::Error>\n-    {\n-        self.read_enum(\"Option\", move |this| {\n-            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                match idx {\n-                    0 => f(this, false),\n-                    1 => f(this, true),\n-                    _ => {\n-                        let msg = format!(\"Invalid Option index: {}\", idx);\n-                        Err(DecodeError::Expected(msg))\n-                    }\n-                }\n-            })\n-        })\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let len = self.read_usize()?;\n-        f(self, len)\n-    }\n-\n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let len = self.read_usize()?;\n-        f(self, len)\n-    }\n-\n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n     fn error(&mut self, err: &str) -> Self::Error {\n-        DecodeError::ApplicationError(err.to_string())\n+        err.to_string()\n     }\n }\n ", "previous_filename": "src/librbml/opaque.rs"}, {"sha": "88f6c12e98040217bcae0c98e702721f1e8819ea", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 131, "deletions": 63, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -42,66 +42,99 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n \n     // Compound types:\n-    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_enum_variant<F>(&mut self, v_name: &str,\n+    fn emit_enum_variant<F>(&mut self, _v_name: &str,\n                             v_id: usize,\n-                            len: usize,\n+                            _len: usize,\n                             f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(v_id)?;\n+        f(self)\n+    }\n+    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n                                    v_id: usize,\n                                    len: usize,\n                                    f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum_variant(v_name, v_id, len, f)\n+    }\n     fn emit_enum_struct_variant_field<F>(&mut self,\n-                                         f_name: &str,\n+                                         _f_name: &str,\n                                          f_idx: usize,\n                                          f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum_variant_arg(f_idx, f)\n+    }\n \n-    fn emit_struct<F>(&mut self, name: &str, len: usize, f: F)\n+    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F)\n                       -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n                             -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: usize, f: F)\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F)\n                             -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_tuple(len, f)\n+    }\n     fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_tuple_arg(f_idx, f)\n+    }\n \n     // Specialized types:\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_option_none(&mut self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum(\"Option\", f)\n+    }\n+    fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n+        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+\n+        self.emit_enum_variant(\"Some\", 1, 1, f)\n+    }\n \n     fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(len)?;\n+        f(self)\n+    }\n+    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n     fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_val<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(len)?;\n+        f(self)\n+    }\n+    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n }\n \n pub trait Decoder {\n@@ -126,66 +159,101 @@ pub trait Decoder {\n     fn read_str(&mut self) -> Result<String, Self::Error>;\n \n     // Compound types:\n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F)\n+    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: usize, f: F)\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let disr = self.read_usize()?;\n+        f(self, disr)\n+    }\n+    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n                                       -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        self.read_enum_variant(names, f)\n+    }\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            &f_name: &str,\n+                                            _f_name: &str,\n                                             f_idx: usize,\n                                             f: F)\n                                             -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_enum_variant_arg(f_idx, f)\n+    }\n \n-    fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n+    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F)\n                          -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n     fn read_struct_field<T, F>(&mut self,\n-                               f_name: &str,\n-                               f_idx: usize,\n+                               _f_name: &str,\n+                               _f_idx: usize,\n                                f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_tuple<T, F>(&mut self, len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: usize, f: F)\n+    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F)\n                             -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n+    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_tuple(len, f)\n+    }\n     fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_tuple_arg(a_idx, f)\n+    }\n \n     // Specialized types:\n-    fn read_option<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>;\n+    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>\n+    {\n+        self.read_enum(\"Option\", move |this| {\n+            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n+                match idx {\n+                    0 => f(this, false),\n+                    1 => f(this, true),\n+                    _ => Err(this.error(\"read_option: expected 0 for None or 1 for Some\")),\n+                }\n+            })\n+        })\n+    }\n \n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let len = self.read_usize()?;\n+        f(self, len)\n+    }\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F)\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let len = self.read_usize()?;\n+        f(self, len)\n+    }\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F)\n                               -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F)\n                               -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     // Failure\n     fn error(&mut self, err: &str) -> Self::Error;"}, {"sha": "d8a02badceede21503c3a460a1b6c63a03ad8c6e", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -50,14 +50,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rbml\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"log 0.0.0\",\n- \"serialize 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc\"\n version = \"0.0.0\"\n@@ -67,7 +59,6 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -185,7 +176,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -227,7 +217,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\","}, {"sha": "8369d08db36d478526946d596bf1b42b82dc4205", "filename": "src/test/run-pass-fulldeps/issue-11881.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0863012fb9b709aee34190d902f0fce5d34eef9e/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs?ref=0863012fb9b709aee34190d902f0fce5d34eef9e", "patch": "@@ -11,7 +11,6 @@\n \n #![feature(rustc_private)]\n \n-extern crate rbml;\n extern crate serialize;\n \n use std::io::Cursor;\n@@ -21,8 +20,7 @@ use std::slice;\n \n use serialize::{Encodable, Encoder};\n use serialize::json;\n-\n-use rbml::writer;\n+use serialize::opaque;\n \n #[derive(Encodable)]\n struct Foo {\n@@ -44,7 +42,7 @@ fn encode_json<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n fn encode_rbml<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n-    let mut encoder = writer::Encoder::new(wr);\n+    let mut encoder = opaque::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n "}]}