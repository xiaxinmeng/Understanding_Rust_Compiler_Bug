{"sha": "6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDlmNDRhNTBmZGZkYjIzODg4NTBmYmQ5YjA3ZGI2NmY0NTJlYzc=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-25T22:42:43Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Clarify specialization into two steps\n\nFirst is checking for constructor overlap, second is extracting the\nresulting fields.", "tree": {"sha": "7abe3a6e6dc54ba2d1f2c13ad1c8bafff15b25e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7abe3a6e6dc54ba2d1f2c13ad1c8bafff15b25e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "html_url": "https://github.com/rust-lang/rust/commit/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa", "html_url": "https://github.com/rust-lang/rust/commit/7c4f94be4859ee6b6bc8fd50fa75328b3d30c9aa"}], "stats": {"total": 104, "additions": 48, "deletions": 56}, "files": [{"sha": "aee1320ec89f89c12f0d48ab5eb9f6af0d864216", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad9f44a50fdfdb2388850fbd9b07db66f452ec7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=6ad9f44a50fdfdb2388850fbd9b07db66f452ec7", "patch": "@@ -2527,9 +2527,9 @@ fn pat_constructor<'tcx>(\n fn specialize_one_pattern<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n-    constructor: &Constructor<'tcx>,\n+    ctor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    is_its_own_ctor: bool, // Whether `constructor` is known to be derived from `pat`\n+    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n     if pat.is_wildcard() {\n         return Some(ctor_wild_subpatterns.clone());\n@@ -2539,57 +2539,34 @@ fn specialize_one_pattern<'p, 'tcx>(\n     // `unwrap` is safe because `pat` is not a wildcard.\n     let pat_ctor = pat_constructor(cx.tcx, cx.param_env, pat).unwrap();\n \n-    let result = match (constructor, &pat_ctor, pat.kind.as_ref()) {\n-        (Single, Single, PatKind::Leaf { subpatterns }) => {\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n-        }\n-        (Single, Single, PatKind::Deref { subpattern }) => {\n-            Some(Fields::from_single_pattern(subpattern))\n-        }\n-        (Variant(_), Variant(_), _) if constructor != &pat_ctor => None,\n-        (Variant(_), Variant(_), PatKind::Variant { subpatterns, .. }) => {\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n-        }\n+    let ctor_covered_by_pat = match (ctor, &pat_ctor) {\n+        (Single, Single) => true,\n+        (Variant(ctor_id), Variant(pat_id)) => ctor_id == pat_id,\n \n-        (IntRange(ctor_range), IntRange(pat_range), _) => {\n-            ctor_range.intersection(cx.tcx, &pat_range)?;\n-            // Constructor splitting should ensure that all intersections we encounter\n-            // are actually inclusions.\n-            assert!(ctor_range.is_subrange(&pat_range));\n-            Some(Fields::empty())\n+        (IntRange(ctor_range), IntRange(pat_range)) => {\n+            if ctor_range.intersection(cx.tcx, pat_range).is_some() {\n+                // Constructor splitting should ensure that all intersections we encounter\n+                // are actually inclusions.\n+                assert!(ctor_range.is_subrange(pat_range));\n+                true\n+            } else {\n+                false\n+            }\n         }\n-        (FloatRange(ctor_from, ctor_to, ctor_end), FloatRange(pat_from, pat_to, pat_end), _) => {\n+        (FloatRange(ctor_from, ctor_to, ctor_end), FloatRange(pat_from, pat_to, pat_end)) => {\n             let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n             let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n-            let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n-                && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n-            if intersects { Some(Fields::empty()) } else { None }\n+            (from == Ordering::Greater || from == Ordering::Equal)\n+                && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal))\n         }\n-        (Str(ctor_val), Str(pat_val), _) => {\n+        (Str(ctor_val), Str(pat_val)) => {\n             // FIXME: there's probably a more direct way of comparing for equality\n             let comparison = compare_const_vals(cx.tcx, ctor_val, pat_val, cx.param_env, ty)?;\n-            if comparison == Ordering::Equal { Some(Fields::empty()) } else { None }\n-        }\n-\n-        (Slice(ctor_slice), Slice(pat_slice), _)\n-            if !pat_slice.pattern_kind().covers_length(ctor_slice.arity()) =>\n-        {\n-            None\n+            comparison == Ordering::Equal\n         }\n-        (\n-            Slice(ctor_slice),\n-            Slice(_),\n-            PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. },\n-        ) => {\n-            // Number of subpatterns for the constructor\n-            let ctor_arity = ctor_slice.arity();\n \n-            // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n-            // the middle if there was a subslice pattern `..`.\n-            let prefix = prefix.iter().enumerate();\n-            let suffix =\n-                suffix.iter().enumerate().map(|(i, p)| (ctor_arity as usize - suffix.len() + i, p));\n-            Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n+        (Slice(ctor_slice), Slice(pat_slice)) => {\n+            pat_slice.pattern_kind().covers_length(ctor_slice.arity())\n         }\n \n         // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n@@ -2611,23 +2588,38 @@ fn specialize_one_pattern<'p, 'tcx>(\n         //     (FOO, false) => {}\n         // }\n         // ```\n-        (Opaque, Opaque, _) if is_its_own_ctor => Some(Fields::empty()),\n+        (Opaque, Opaque) if is_its_own_ctor => true,\n         // We are trying to inspect an opaque constant. Thus we skip the row.\n-        (Opaque, _, _) | (_, Opaque, _) => None,\n+        (Opaque, _) | (_, Opaque) => false,\n         // Only a wildcard pattern can match the special extra constructor.\n-        (NonExhaustive, _, _) => None,\n+        (NonExhaustive, _) => false,\n \n-        _ => bug!(\"trying to specialize pattern {:?} with constructor {:?}\", pat, constructor),\n+        _ => bug!(\"trying to specialize pattern {:?} with constructor {:?}\", pat, ctor),\n     };\n \n-    debug!(\n-        \"specialize({:#?}, {:#?}, {:#?}) = {:#?}\",\n-        pat, constructor, ctor_wild_subpatterns, result\n-    );\n-\n-    if let Some(fields) = &result {\n-        debug_assert_eq!(fields.len(), ctor_wild_subpatterns.len());\n+    if !ctor_covered_by_pat {\n+        return None;\n     }\n \n-    result\n+    let fields = match pat.kind.as_ref() {\n+        PatKind::Deref { subpattern } => Fields::from_single_pattern(subpattern),\n+        PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+            ctor_wild_subpatterns.replace_with_fieldpats(subpatterns)\n+        }\n+        PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n+            // Number of subpatterns for the constructor\n+            let ctor_arity = ctor_wild_subpatterns.len();\n+\n+            // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n+            // the middle if there was a subslice pattern `..`.\n+            let prefix = prefix.iter().enumerate();\n+            let suffix = suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n+            ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix))\n+        }\n+        _ => ctor_wild_subpatterns.clone(),\n+    };\n+\n+    debug!(\"specialize({:#?}, {:#?}, {:#?}) = {:#?}\", pat, ctor, ctor_wild_subpatterns, fields);\n+\n+    Some(fields)\n }"}]}