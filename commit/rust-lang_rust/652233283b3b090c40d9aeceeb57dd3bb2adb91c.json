{"sha": "652233283b3b090c40d9aeceeb57dd3bb2adb91c", "node_id": "C_kwDOAAsO6NoAKDY1MjIzMzI4M2IzYjA5MGM0MGQ5YWVjZWViNTdkZDNiYjJhZGI5MWM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-23T00:36:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-23T00:36:11Z"}, "message": "Merge #11791\n\n11791: fix: some fixes and improvements to signature help r=jonas-schievink a=jonas-schievink\n\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "137f6c3c7d5fa2c47870d745556093afea439d0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/137f6c3c7d5fa2c47870d745556093afea439d0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/652233283b3b090c40d9aeceeb57dd3bb2adb91c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiOmt7CRBK7hj4Ov3rIwAAKMkIADfh7sqwKLiGJj7//hBaIa8g\nCDpN/gFTZm4QtwBYYyegbjelMJ4XI8P/He4/Wd06K4s48No1Si3skZBKBf8kP6mD\nH57AMufKI8IwiH+b9r/K6Rm2txSF4JGEORoORkdsqM7oDy2JXDSDUmv+7N5zhe/i\nQXlHd7PoHVCNbhQ0N0mYlPgOfpIQSWQSWi00yYzNKBSYebzK8WWOp9jcWsWyL2/m\njKOXldLtvKDGmjTFzcLH3LKAZ7oBmg/FmfAsZpoN+sr0j8eJ1px19OoBZJyQuuYU\njdqx+7+PwdgCiaCRHKbOqlT8v5b7PS5n4dmsoX1/aJzoRWqLz9ZzH8vvuKz2Zuw=\n=mmtQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 137f6c3c7d5fa2c47870d745556093afea439d0d\nparent c2ea378920aa82d13ba12dbf04807f4cd7975897\nparent 4e07864f591c76265639725762b3b6ad9e9d8bb1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647995771 +0000\ncommitter GitHub <noreply@github.com> 1647995771 +0000\n\nMerge #11791\n\n11791: fix: some fixes and improvements to signature help r=jonas-schievink a=jonas-schievink\n\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/652233283b3b090c40d9aeceeb57dd3bb2adb91c", "html_url": "https://github.com/rust-lang/rust/commit/652233283b3b090c40d9aeceeb57dd3bb2adb91c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/652233283b3b090c40d9aeceeb57dd3bb2adb91c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ea378920aa82d13ba12dbf04807f4cd7975897", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ea378920aa82d13ba12dbf04807f4cd7975897", "html_url": "https://github.com/rust-lang/rust/commit/c2ea378920aa82d13ba12dbf04807f4cd7975897"}, {"sha": "4e07864f591c76265639725762b3b6ad9e9d8bb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e07864f591c76265639725762b3b6ad9e9d8bb1", "html_url": "https://github.com/rust-lang/rust/commit/4e07864f591c76265639725762b3b6ad9e9d8bb1"}], "stats": {"total": 437, "additions": 270, "deletions": 167}, "files": [{"sha": "f33b09ed578964b836351ddf5dc546bffd6ae54e", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 260, "deletions": 116, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=652233283b3b090c40d9aeceeb57dd3bb2adb91c", "patch": "@@ -2,13 +2,14 @@\n //! a call or use-site.\n \n use either::Either;\n-use hir::{HasAttrs, HirDisplay, Semantics};\n-use ide_db::{\n-    active_parameter::{callable_for_token, generics_for_token},\n-    base_db::FilePosition,\n-};\n+use hir::{GenericParam, HasAttrs, HirDisplay, Semantics};\n+use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n use stdx::format_to;\n-use syntax::{algo, AstNode, Direction, TextRange, TextSize};\n+use syntax::{\n+    algo,\n+    ast::{self, HasArgList},\n+    AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+};\n \n use crate::RootDatabase;\n \n@@ -65,25 +66,50 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n         .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;\n     let token = sema.descend_into_macros_single(token);\n \n-    if let Some((callable, active_parameter)) = callable_for_token(&sema, token.clone()) {\n-        return Some(signature_help_for_callable(db, callable, active_parameter));\n+    if let Some(help) = signature_help_for_call(&sema, &token) {\n+        return Some(help);\n     }\n \n-    if let Some((generic_def, active_parameter)) = generics_for_token(&sema, token.clone()) {\n-        return signature_help_for_generics(db, generic_def, active_parameter);\n+    if let Some(help) = signature_help_for_generics(&sema, &token) {\n+        return Some(help);\n     }\n \n     None\n }\n \n-fn signature_help_for_callable(\n-    db: &RootDatabase,\n-    callable: hir::Callable,\n-    active_parameter: Option<usize>,\n-) -> SignatureHelp {\n+fn signature_help_for_call(\n+    sema: &Semantics<RootDatabase>,\n+    token: &SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    // Find the calling expression and its NameRef\n+    let mut node = token.parent()?;\n+    let calling_node = loop {\n+        if let Some(callable) = ast::CallableExpr::cast(node.clone()) {\n+            if callable\n+                .arg_list()\n+                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n+            {\n+                break callable;\n+            }\n+        }\n+\n+        // Stop at multi-line expressions, since the signature of the outer call is not very\n+        // helpful inside them.\n+        if let Some(expr) = ast::Expr::cast(node.clone()) {\n+            if expr.syntax().text().contains_char('\\n') {\n+                return None;\n+            }\n+        }\n+\n+        node = node.parent()?;\n+    };\n+\n+    let (callable, active_parameter) = callable_for_node(sema, &calling_node, token)?;\n+\n     let mut res =\n         SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n \n+    let db = sema.db;\n     match callable.kind() {\n         hir::CallableKind::Function(func) => {\n             res.doc = func.docs(db).map(|it| it.into());\n@@ -134,21 +160,73 @@ fn signature_help_for_callable(\n         }\n         hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n     }\n-    res\n+    Some(res)\n }\n \n fn signature_help_for_generics(\n-    db: &RootDatabase,\n-    mut generics_def: hir::GenericDef,\n-    active_parameter: usize,\n+    sema: &Semantics<RootDatabase>,\n+    token: &SyntaxToken,\n ) -> Option<SignatureHelp> {\n+    let parent = token.parent()?;\n+    let arg_list = parent\n+        .ancestors()\n+        .filter_map(ast::GenericArgList::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let mut active_parameter = arg_list\n+        .generic_args()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    let mut generics_def = if let Some(path) =\n+        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n+    {\n+        let res = sema.resolve_path(&path)?;\n+        let generic_def: hir::GenericDef = match res {\n+            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+            hir::PathResolution::AssocItem(hir::AssocItem::Function(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::Const(_)) => return None,\n+            hir::PathResolution::BuiltinAttr(_)\n+            | hir::PathResolution::ToolModule(_)\n+            | hir::PathResolution::Local(_)\n+            | hir::PathResolution::TypeParam(_)\n+            | hir::PathResolution::ConstParam(_)\n+            | hir::PathResolution::SelfType(_) => return None,\n+        };\n+\n+        generic_def\n+    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n+    {\n+        // recv.method::<$0>()\n+        let method = sema.resolve_method_call(&method_call)?;\n+        method.into()\n+    } else {\n+        return None;\n+    };\n+\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n         parameters: vec![],\n-        active_parameter: Some(active_parameter),\n+        active_parameter: None,\n     };\n \n+    let db = sema.db;\n     match generics_def {\n         hir::GenericDef::Function(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n@@ -187,8 +265,16 @@ fn signature_help_for_generics(\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n     }\n \n+    let params = generics_def.params(sema.db);\n+    let num_lifetime_params =\n+        params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();\n+    if first_arg_is_non_lifetime {\n+        // Lifetime parameters were omitted.\n+        active_parameter += num_lifetime_params;\n+    }\n+    res.active_parameter = Some(active_parameter);\n+\n     res.signature.push('<');\n-    let params = generics_def.params(db);\n     let mut buf = String::new();\n     for param in params {\n         if let hir::GenericParam::TypeParam(ty) = param {\n@@ -208,8 +294,11 @@ fn signature_help_for_generics(\n \n #[cfg(test)]\n mod tests {\n+    use std::iter;\n+\n     use expect_test::{expect, Expect};\n     use ide_db::base_db::{fixture::ChangeFixture, FilePosition};\n+    use stdx::format_to;\n \n     use crate::RootDatabase;\n \n@@ -233,26 +322,32 @@ mod tests {\n             \"#\n         );\n         let (db, position) = position(&fixture);\n-        let call_info = crate::signature_help::signature_help(&db, position);\n-        let actual = match call_info {\n-            Some(call_info) => {\n-                let docs = match &call_info.doc {\n-                    None => \"\".to_string(),\n-                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n-                };\n-                let params = call_info\n-                    .parameter_labels()\n-                    .enumerate()\n-                    .map(|(i, param)| {\n-                        if Some(i) == call_info.active_parameter {\n-                            format!(\"<{}>\", param)\n-                        } else {\n-                            param.to_string()\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n+        let sig_help = crate::signature_help::signature_help(&db, position);\n+        let actual = match sig_help {\n+            Some(sig_help) => {\n+                let mut rendered = String::new();\n+                if let Some(docs) = &sig_help.doc {\n+                    format_to!(rendered, \"{}\\n------\\n\", docs.as_str());\n+                }\n+                format_to!(rendered, \"{}\\n\", sig_help.signature);\n+                let mut offset = 0;\n+                for (i, range) in sig_help.parameter_ranges().iter().enumerate() {\n+                    let is_active = sig_help.active_parameter == Some(i);\n+\n+                    let start = u32::from(range.start());\n+                    let gap = start.checked_sub(offset).unwrap_or_else(|| {\n+                        panic!(\"parameter ranges out of order: {:?}\", sig_help.parameter_ranges())\n+                    });\n+                    rendered.extend(iter::repeat(' ').take(gap as usize));\n+                    let width = u32::from(range.end() - range.start());\n+                    let marker = if is_active { '^' } else { '-' };\n+                    rendered.extend(iter::repeat(marker).take(width as usize));\n+                    offset += gap + width;\n+                }\n+                if !sig_help.parameter_ranges().is_empty() {\n+                    format_to!(rendered, \"\\n\");\n+                }\n+                rendered\n             }\n             None => String::new(),\n         };\n@@ -268,7 +363,7 @@ fn bar() { foo($03, ); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n+                       ^^^^^^  ------\n             \"#]],\n         );\n         check(\n@@ -278,7 +373,7 @@ fn bar() { foo(3$0, ); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n+                       ^^^^^^  ------\n             \"#]],\n         );\n         check(\n@@ -288,7 +383,7 @@ fn bar() { foo(3,$0 ); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n+                       ------  ^^^^^^\n             \"#]],\n         );\n         check(\n@@ -298,7 +393,7 @@ fn bar() { foo(3, $0); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n+                       ------  ^^^^^^\n             \"#]],\n         );\n     }\n@@ -312,7 +407,7 @@ fn bar() { foo($0); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n+                       ^^^^^^  ------\n             \"#]],\n         );\n     }\n@@ -329,7 +424,7 @@ fn bar() { foo($03, ); }\n \"#,\n             expect![[r#\"\n                 fn foo(x: i32, y: {unknown}) -> u32\n-                (<x: i32>, y: {unknown})\n+                       ^^^^^^  ------------\n             \"#]],\n         );\n     }\n@@ -343,7 +438,6 @@ fn bar() { foo($0); }\n \"#,\n             expect![[r#\"\n                 fn foo() -> {unknown}\n-                ()\n             \"#]],\n         );\n     }\n@@ -360,7 +454,6 @@ fn bar() {\n \"#,\n             expect![[r#\"\n                 fn new()\n-                ()\n             \"#]],\n         );\n     }\n@@ -379,7 +472,6 @@ fn bar() {\n \"#,\n             expect![[r#\"\n                 fn do_it(&self)\n-                ()\n             \"#]],\n         );\n     }\n@@ -397,7 +489,7 @@ fn main() { S.foo($0); }\n \"#,\n             expect![[r#\"\n                 fn foo(&self, x: i32)\n-                (<x: i32>)\n+                              ^^^^^^\n             \"#]],\n         );\n     }\n@@ -415,7 +507,7 @@ fn main() { S(1u32).foo($0); }\n \"#,\n             expect![[r#\"\n                 fn foo(&self, x: u32)\n-                (<x: u32>)\n+                              ^^^^^^\n             \"#]],\n         );\n     }\n@@ -433,7 +525,7 @@ fn main() { S::foo($0); }\n \"#,\n             expect![[r#\"\n                 fn foo(self: &S, x: i32)\n-                (<self: &S>, x: i32)\n+                       ^^^^^^^^  ------\n             \"#]],\n         );\n     }\n@@ -453,11 +545,11 @@ fn bar() {\n }\n \"#,\n             expect![[r#\"\n-            test\n-            ------\n-            fn foo(j: u32) -> u32\n-            (<j: u32>)\n-        \"#]],\n+                test\n+                ------\n+                fn foo(j: u32) -> u32\n+                       ^^^^^^\n+            \"#]],\n         );\n     }\n \n@@ -482,19 +574,19 @@ pub fn do() {\n     add_one($0\n }\"#,\n             expect![[r##\"\n-            Adds one to the number given.\n+                Adds one to the number given.\n \n-            # Examples\n+                # Examples\n \n-            ```\n-            let five = 5;\n+                ```\n+                let five = 5;\n \n-            assert_eq!(6, my_crate::add_one(5));\n-            ```\n-            ------\n-            fn add_one(x: i32) -> i32\n-            (<x: i32>)\n-        \"##]],\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                fn add_one(x: i32) -> i32\n+                           ^^^^^^\n+            \"##]],\n         );\n     }\n \n@@ -524,19 +616,19 @@ pub fn do_it() {\n }\n \"#,\n             expect![[r##\"\n-            Adds one to the number given.\n+                Adds one to the number given.\n \n-            # Examples\n+                # Examples\n \n-            ```\n-            let five = 5;\n+                ```\n+                let five = 5;\n \n-            assert_eq!(6, my_crate::add_one(5));\n-            ```\n-            ------\n-            fn add_one(x: i32) -> i32\n-            (<x: i32>)\n-        \"##]],\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                fn add_one(x: i32) -> i32\n+                           ^^^^^^\n+            \"##]],\n         );\n     }\n \n@@ -568,13 +660,13 @@ pub fn foo(mut r: WriteHandler<()>) {\n }\n \"#,\n             expect![[r#\"\n-            Method is called when writer finishes.\n+                Method is called when writer finishes.\n \n-            By default this method stops actor's `Context`.\n-            ------\n-            fn finished(&mut self, ctx: &mut {unknown})\n-            (<ctx: &mut {unknown}>)\n-        \"#]],\n+                By default this method stops actor's `Context`.\n+                ------\n+                fn finished(&mut self, ctx: &mut {unknown})\n+                                       ^^^^^^^^^^^^^^^^^^^\n+            \"#]],\n         );\n     }\n \n@@ -605,7 +697,7 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 fn bar(&self, _: u32)\n-                (<_: u32>)\n+                              ^^^^^^\n             \"#]],\n         );\n     }\n@@ -621,11 +713,11 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-            A cool tuple struct\n-            ------\n-            struct S(u32, i32)\n-            (u32, <i32>)\n-        \"#]],\n+                A cool tuple struct\n+                ------\n+                struct S(u32, i32)\n+                         ---  ^^^\n+            \"#]],\n         );\n     }\n \n@@ -640,7 +732,7 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 struct S({unknown})\n-                (<{unknown}>)\n+                         ^^^^^^^^^\n             \"#]],\n         );\n     }\n@@ -663,11 +755,11 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-            A Variant\n-            ------\n-            enum E::A(i32)\n-            (<i32>)\n-        \"#]],\n+                A Variant\n+                ------\n+                enum E::A(i32)\n+                          ^^^\n+            \"#]],\n         );\n     }\n \n@@ -717,7 +809,6 @@ id! {\n \"#,\n             expect![[r#\"\n                 fn foo()\n-                ()\n             \"#]],\n         );\n     }\n@@ -734,7 +825,7 @@ fn main() {\n         \"#,\n             expect![[r#\"\n                 (S) -> i32\n-                (<S>)\n+                 ^\n             \"#]],\n         )\n     }\n@@ -749,7 +840,7 @@ fn main(f: fn(i32, f64) -> char) {\n         \"#,\n             expect![[r#\"\n                 (i32, f64) -> char\n-                (i32, <f64>)\n+                 ---  ^^^\n             \"#]],\n         )\n     }\n@@ -763,9 +854,9 @@ fn main() {\n     foo($0\n }\"#,\n             expect![[r#\"\n-            fn foo(foo: u32, bar: u32)\n-            (<foo: u32>, bar: u32)\n-        \"#]],\n+                fn foo(foo: u32, bar: u32)\n+                       ^^^^^^^^  --------\n+            \"#]],\n         );\n         // check with surrounding space\n         check(\n@@ -775,12 +866,52 @@ fn main() {\n     foo( $0\n }\"#,\n             expect![[r#\"\n-            fn foo(foo: u32, bar: u32)\n-            (<foo: u32>, bar: u32)\n-        \"#]],\n+                fn foo(foo: u32, bar: u32)\n+                       ^^^^^^^^  --------\n+            \"#]],\n         )\n     }\n \n+    #[test]\n+    fn test_multiline_argument() {\n+        check(\n+            r#\"\n+fn callee(a: u8, b: u8) {}\n+fn main() {\n+    callee(match 0 {\n+        0 => 1,$0\n+    })\n+}\"#,\n+            expect![[r#\"\"#]],\n+        );\n+        check(\n+            r#\"\n+fn callee(a: u8, b: u8) {}\n+fn main() {\n+    callee(match 0 {\n+        0 => 1,\n+    },$0)\n+}\"#,\n+            expect![[r#\"\n+                fn callee(a: u8, b: u8)\n+                          -----  ^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn callee(a: u8, b: u8) {}\n+fn main() {\n+    callee($0match 0 {\n+        0 => 1,\n+    })\n+}\"#,\n+            expect![[r#\"\n+                fn callee(a: u8, b: u8)\n+                          ^^^^^  -----\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_generics_simple() {\n         check(\n@@ -799,7 +930,7 @@ fn f() {\n                 Option docs.\n                 ------\n                 enum Option<T>\n-                (<T>)\n+                            ^\n             \"#]],\n         );\n     }\n@@ -826,7 +957,7 @@ fn f() {\n                 None docs.\n                 ------\n                 enum Option<T>\n-                (<T>)\n+                            ^\n             \"#]],\n         );\n     }\n@@ -849,7 +980,7 @@ fn f() {\n         \"#,\n             expect![[r#\"\n                 fn f<G: Tr<()>, H>\n-                (G: Tr<()>, <H>)\n+                     ---------  ^\n             \"#]],\n         );\n     }\n@@ -872,7 +1003,7 @@ fn f() {\n         \"#,\n             expect![[r#\"\n                 fn f<T: Tr, U>\n-                (<T: Tr>, U)\n+                     ^^^^^  -\n             \"#]],\n         );\n     }\n@@ -892,26 +1023,39 @@ fn f() {\n }\n         \"#,\n             expect![[r#\"\n-            fn f<T>\n-            (<T>)\n-        \"#]],\n+                fn f<T>\n+                     ^\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_generic_kinds() {\n         check(\n             r#\"\n-fn callee<'a, const A: (), T, const C: u8>() {}\n+fn callee<'a, const A: u8, T, const C: u8>() {}\n \n fn f() {\n     callee::<'static, $0\n }\n         \"#,\n             expect![[r#\"\n-            fn callee<'a, const A: (), T, const C: u8>\n-            ('a, <const A: ()>, T, const C: u8)\n-        \"#]],\n+                fn callee<'a, const A: u8, T, const C: u8>\n+                          --  ^^^^^^^^^^^  -  -----------\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn callee<'a, const A: u8, T, const C: u8>() {}\n+\n+fn f() {\n+    callee::<NON_LIFETIME$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn callee<'a, const A: u8, T, const C: u8>\n+                          --  ^^^^^^^^^^^  -  -----------\n+            \"#]],\n         );\n     }\n }"}, {"sha": "1850fd1aa851526116cd28781d472eaf11445458", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=652233283b3b090c40d9aeceeb57dd3bb2adb91c", "patch": "@@ -272,6 +272,7 @@ fn render_resolution_simple_(\n                 cov_mark::hit!(inserts_angle_brackets_for_generics);\n                 item.lookup_by(local_name.clone())\n                     .label(SmolStr::from_iter([&local_name, \"<\u2026>\"]))\n+                    .trigger_call_info()\n                     .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n             }\n         }"}, {"sha": "788a5ed17e63e8f06ec9a24b7f616ded62a5f262", "filename": "crates/ide_db/src/active_parameter.rs", "status": "modified", "additions": 9, "deletions": 51, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652233283b3b090c40d9aeceeb57dd3bb2adb91c/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Factive_parameter.rs?ref=652233283b3b090c40d9aeceeb57dd3bb2adb91c", "patch": "@@ -43,13 +43,21 @@ pub fn callable_for_token(\n     sema: &Semantics<RootDatabase>,\n     token: SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n-    // Find the calling expression and it's NameRef\n+    // Find the calling expression and its NameRef\n     let parent = token.parent()?;\n     let calling_node = parent.ancestors().filter_map(ast::CallableExpr::cast).find(|it| {\n         it.arg_list()\n             .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n     })?;\n \n+    callable_for_node(sema, &calling_node, &token)\n+}\n+\n+pub fn callable_for_node(\n+    sema: &Semantics<RootDatabase>,\n+    calling_node: &ast::CallableExpr,\n+    token: &SyntaxToken,\n+) -> Option<(hir::Callable, Option<usize>)> {\n     let callable = match &calling_node {\n         ast::CallableExpr::Call(call) => {\n             let expr = call.expr()?;\n@@ -68,53 +76,3 @@ pub fn callable_for_token(\n     };\n     Some((callable, active_param))\n }\n-\n-pub fn generics_for_token(\n-    sema: &Semantics<RootDatabase>,\n-    token: SyntaxToken,\n-) -> Option<(hir::GenericDef, usize)> {\n-    let parent = token.parent()?;\n-    let arg_list = parent\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_param = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    if let Some(path) = arg_list.syntax().ancestors().find_map(ast::Path::cast) {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::AssocItem(hir::AssocItem::Function(it)) => it.into(),\n-            hir::PathResolution::AssocItem(hir::AssocItem::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::AssocItem(hir::AssocItem::Const(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_) => return None,\n-        };\n-\n-        Some((generic_def, active_param))\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        Some((method.into(), active_param))\n-    } else {\n-        None\n-    }\n-}"}]}