{"sha": "c4ead49361e4b8c0586b810399c8e96a468b891c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZWFkNDkzNjFlNGI4YzA1ODZiODEwMzk5YzhlOTZhNDY4Yjg5MWM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-25T11:38:46Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-25T11:38:46Z"}, "message": "Merge #1034\n\n1034: HIR diagnostics API r=matklad a=matklad\n\nThis PR introduces diagnostics API for HIR, so we can now start issuing errors and warnings! Here are requirements that this solution aims to fulfill:\r\n\r\n* structured diagnostics: rather than immediately rendering error to string, we provide a well-typed blob of data with error-description. These data is used by IDE to provide fixes\r\n* open set diagnostics: there's no single enum with all possible diagnostics, which hopefully should result in better modularity\r\n\r\nThe `Diagnostic` trait describes \"a diagnostic\", which can be downcast to a specific diagnostic kind. Diagnostics are expressed in terms of macro-expanded syntax tree: they store pointers to syntax nodes. Diagnostics are self-contained: you don't need any context, besides `db`, to fully understand the meaning of a diagnostic. \r\n\r\nBecause diagnostics are tied to the source, we can't store them in salsa. So subsystems like type-checking produce subsystem-local diagnostic (which is a closed `enum`), which is expressed in therms of subsystem IR. A separate step converts these proto-diagnostics into `Diagnostic`, by merging them with source-maps.\r\n\r\nNote that this PR stresses type-system quite a bit: we now type-check every function in open files to compute errors!\r\n\r\nDiscussion on Zulip: https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Diagnostics.20API\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0b1ba767e34e3baef938f6b7672f95ce4572ec07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b1ba767e34e3baef938f6b7672f95ce4572ec07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4ead49361e4b8c0586b810399c8e96a468b891c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ead49361e4b8c0586b810399c8e96a468b891c", "html_url": "https://github.com/rust-lang/rust/commit/c4ead49361e4b8c0586b810399c8e96a468b891c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4ead49361e4b8c0586b810399c8e96a468b891c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638", "html_url": "https://github.com/rust-lang/rust/commit/8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638"}, {"sha": "309716cffe93d065bcad0344b0f332425576c1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/309716cffe93d065bcad0344b0f332425576c1e5", "html_url": "https://github.com/rust-lang/rust/commit/309716cffe93d065bcad0344b0f332425576c1e5"}], "stats": {"total": 589, "additions": 424, "deletions": 165}, "files": [{"sha": "5437133b87eb25d6889de60609e777a8381cbfa9", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -1,8 +1,7 @@\n use std::sync::Arc;\n \n-use relative_path::RelativePathBuf;\n use ra_db::{CrateId, SourceRootId, Edition};\n-use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n+use ra_syntax::{ast::self, TreeArc};\n \n use crate::{\n     Name, ScopesWithSourceMap, Ty, HirFileId,\n@@ -17,6 +16,7 @@ use crate::{\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n+    diagnostics::DiagnosticSink,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -95,11 +95,6 @@ pub enum ModuleSource {\n     Module(TreeArc<ast::Module>),\n }\n \n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule { candidate: RelativePathBuf },\n-}\n-\n impl Module {\n     /// Name of this module.\n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n@@ -171,8 +166,24 @@ impl Module {\n         db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        self.problems_impl(db)\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n+        for decl in self.declarations(db) {\n+            match decl {\n+                crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n+                crate::ModuleDef::Module(f) => f.diagnostics(db, sink),\n+                _ => (),\n+            }\n+        }\n+\n+        for impl_block in self.impl_blocks(db) {\n+            for item in impl_block.items(db) {\n+                match item {\n+                    crate::ImplItem::Method(f) => f.diagnostics(db, sink),\n+                    _ => (),\n+                }\n+            }\n+        }\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n@@ -519,6 +530,10 @@ impl Function {\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n+\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+        self.infer(db).add_diagnostics(db, *self, sink);\n+    }\n }\n \n impl Docs for Function {"}, {"sha": "14237060cfb755ea21868118072b2bbceca0d293", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -1,8 +1,8 @@\n use ra_db::FileId;\n-use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n+use ra_syntax::{ast, TreeArc, AstNode};\n \n use crate::{\n-    Module, ModuleSource, Problem, Name,\n+    Module, ModuleSource, Name,\n     nameres::{CrateModuleId, ImportId},\n     HirDatabase, DefDatabase,\n     HirFileId, SourceItemId,\n@@ -108,19 +108,4 @@ impl Module {\n         let parent_id = def_map[self.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n-\n-    pub(crate) fn problems_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let (my_file_id, _) = self.definition_source(db);\n-        // FIXME: not entirely corret filterint by module\n-        def_map\n-            .problems()\n-            .iter()\n-            .filter(|(source_item_id, _problem)| my_file_id == source_item_id.file_id)\n-            .map(|(source_item_id, problem)| (db.file_item(*source_item_id), problem.clone()))\n-            .collect()\n-    }\n }"}, {"sha": "d6a51b8332ac244eb7f1f03efdd063bb078deeb1", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -0,0 +1,115 @@\n+use std::{fmt, any::Any};\n+\n+use ra_syntax::{SyntaxNodePtr, TreeArc, AstPtr, TextRange, ast, SyntaxNode};\n+use relative_path::RelativePathBuf;\n+\n+use crate::{HirFileId, HirDatabase};\n+\n+/// Diagnostic defines hir API for errors and warnings.\n+///\n+/// It is used as a `dyn` object, which you can downcast to a concrete\n+/// diagnostic. DiagnosticSink are structured, meaning that they include rich\n+/// information which can be used by IDE to create fixes. DiagnosticSink are\n+/// expressed in terms of macro-expanded syntax tree nodes (so, it's a bad idea\n+/// to diagnostic in a salsa value).\n+///\n+/// Internally, various subsystems of hir produce diagnostics specific to a\n+/// subsystem (typically, an `enum`), which are safe to store in salsa but do not\n+/// include source locations. Such internal diagnostic are transformed into an\n+/// instance of `Diagnostic` on demand.\n+pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n+    fn message(&self) -> String;\n+    fn file(&self) -> HirFileId;\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr;\n+    fn highlight_range(&self) -> TextRange {\n+        self.syntax_node_ptr().range()\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static);\n+}\n+\n+impl dyn Diagnostic {\n+    pub fn syntax_node(&self, db: &impl HirDatabase) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(self.file());\n+        self.syntax_node_ptr().to_node(&source_file).to_owned()\n+    }\n+    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n+        self.as_any().downcast_ref()\n+    }\n+}\n+\n+pub struct DiagnosticSink<'a> {\n+    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n+    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n+}\n+\n+impl<'a> DiagnosticSink<'a> {\n+    pub fn new(cb: impl FnMut(&dyn Diagnostic) + 'a) -> DiagnosticSink<'a> {\n+        DiagnosticSink { callbacks: Vec::new(), default_callback: Box::new(cb) }\n+    }\n+\n+    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> DiagnosticSink<'a> {\n+        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n+            Some(d) => {\n+                cb(d);\n+                Ok(())\n+            }\n+            None => Err(()),\n+        };\n+        self.callbacks.push(Box::new(cb));\n+        self\n+    }\n+\n+    pub(crate) fn push(&mut self, d: impl Diagnostic) {\n+        let d: &dyn Diagnostic = &d;\n+        for cb in self.callbacks.iter_mut() {\n+            match cb(d) {\n+                Ok(()) => return,\n+                Err(()) => (),\n+            }\n+        }\n+        (self.default_callback)(d)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NoSuchField {\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::NamedField>,\n+}\n+\n+impl Diagnostic for NoSuchField {\n+    fn message(&self) -> String {\n+        \"no such field\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.field.into()\n+    }\n+    fn as_any(&self) -> &(Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: RelativePathBuf,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.decl.into()\n+    }\n+    fn as_any(&self) -> &(Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "a85422955b991b39d535e65394931af2c89a3487", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -5,7 +5,7 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n-    SyntaxNodePtr, AstNode,\n+    SyntaxNodePtr, AstPtr, AstNode,\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor, TypeAscriptionOwner}\n };\n \n@@ -54,6 +54,7 @@ pub struct BodySourceMap {\n     expr_map_back: ArenaMap<ExprId, SyntaxNodePtr>,\n     pat_map: FxHashMap<SyntaxNodePtr, PatId>,\n     pat_map_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::NamedField>>,\n }\n \n impl Body {\n@@ -138,6 +139,10 @@ impl BodySourceMap {\n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n+        self.field_map[&(expr, field)].clone()\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -629,8 +634,10 @@ impl ExprCollector {\n             }\n             ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n+                let mut field_ptrs = Vec::new();\n                 let fields = if let Some(nfl) = e.named_field_list() {\n                     nfl.fields()\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n                         .map(|field| StructLitField {\n                             name: field\n                                 .name_ref()\n@@ -657,7 +664,11 @@ impl ExprCollector {\n                     Vec::new()\n                 };\n                 let spread = e.spread().map(|s| self.collect_expr(s));\n-                self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr)\n+                let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n+                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n+                    self.source_map.field_map.insert((res, i), ptr);\n+                }\n+                res\n             }\n             ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());"}, {"sha": "ce54d76084a3e7391c4c1e0ac69092a8184ac7cc", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -35,6 +35,7 @@ mod expr;\n mod generics;\n mod docs;\n mod resolve;\n+pub mod diagnostics;\n \n mod code_model_api;\n mod code_model_impl;\n@@ -63,7 +64,7 @@ pub use self::{\n \n pub use self::code_model_api::{\n     Crate, CrateDependency,\n-    Module, ModuleDef, ModuleSource, Problem,\n+    Module, ModuleDef, ModuleSource,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature,\n     StructField, FieldSource,"}, {"sha": "aeab6b180026ff8f2e4419016b4d94f2db937643", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -9,7 +9,7 @@ use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n use rustc_hash::FxHashMap;\n \n-use crate::{db, HirInterner};\n+use crate::{db, HirInterner, diagnostics::DiagnosticSink};\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n@@ -70,6 +70,22 @@ impl MockDatabase {\n         self.set_crate_graph(Arc::new(crate_graph))\n     }\n \n+    pub fn diagnostics(&self) -> String {\n+        let mut buf = String::from(\"\\n\");\n+        let mut files: Vec<FileId> = self.files.values().map(|&it| it).collect();\n+        files.sort();\n+        for file in files {\n+            let module = crate::source_binder::module_from_file_id(self, file).unwrap();\n+            module.diagnostics(\n+                self,\n+                &mut DiagnosticSink::new(|d| {\n+                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                }),\n+            )\n+        }\n+        buf\n+    }\n+\n     fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n "}, {"sha": "56ed872d591a85fd0db223789b61c6fb82c43273", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 59, "deletions": 22, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -61,9 +61,11 @@ use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module, Problem,\n+    ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId,\n     ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    diagnostics::DiagnosticSink,\n+    nameres::diagnostics::DefDiagnostic,\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -85,7 +87,7 @@ pub struct CrateDefMap {\n     macros: Arena<CrateMacroId, mbe::MacroRules>,\n     public_macros: FxHashMap<Name, CrateMacroId>,\n     macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n-    problems: CrateDefMapProblems,\n+    diagnostics: Vec<DefDiagnostic>,\n }\n \n impl std::ops::Index<CrateModuleId> for CrateDefMap {\n@@ -125,21 +127,6 @@ pub(crate) struct ModuleData {\n     pub(crate) definition: Option<FileId>,\n }\n \n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct CrateDefMapProblems {\n-    problems: Vec<(SourceItemId, Problem)>,\n-}\n-\n-impl CrateDefMapProblems {\n-    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n-        self.problems.push((source_item_id, problem))\n-    }\n-\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n-        self.problems.iter().map(|(s, p)| (s, p))\n-    }\n-}\n-\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n@@ -212,7 +199,7 @@ impl CrateDefMap {\n                 macros: Arena::default(),\n                 public_macros: FxHashMap::default(),\n                 macro_resolutions: FxHashMap::default(),\n-                problems: CrateDefMapProblems::default(),\n+                diagnostics: Vec::new(),\n             }\n         };\n         let def_map = collector::collect_defs(db, def_map);\n@@ -224,10 +211,6 @@ impl CrateDefMap {\n         self.root\n     }\n \n-    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n-        &self.problems\n-    }\n-\n     pub(crate) fn mk_module(&self, module_id: CrateModuleId) -> Module {\n         Module { krate: self.krate, module_id }\n     }\n@@ -240,6 +223,15 @@ impl CrateDefMap {\n         &self.extern_prelude\n     }\n \n+    pub(crate) fn add_diagnostics(\n+        &self,\n+        db: &impl DefDatabase,\n+        module: CrateModuleId,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n+    }\n+\n     pub(crate) fn resolve_macro(\n         &self,\n         macro_call_id: MacroCallId,\n@@ -452,3 +444,48 @@ impl CrateDefMap {\n         }\n     }\n }\n+\n+mod diagnostics {\n+    use relative_path::RelativePathBuf;\n+    use ra_syntax::{AstPtr, AstNode, ast};\n+\n+    use crate::{\n+        SourceItemId, DefDatabase,\n+        nameres::CrateModuleId,\n+        diagnostics::{DiagnosticSink, UnresolvedModule},\n+};\n+\n+    #[derive(Debug, PartialEq, Eq)]\n+    pub(super) enum DefDiagnostic {\n+        UnresolvedModule {\n+            module: CrateModuleId,\n+            declaration: SourceItemId,\n+            candidate: RelativePathBuf,\n+        },\n+    }\n+\n+    impl DefDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl DefDatabase,\n+            target_module: CrateModuleId,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n+                    if *module != target_module {\n+                        return;\n+                    }\n+                    let syntax = db.file_item(*declaration);\n+                    let decl = ast::Module::cast(&syntax).unwrap();\n+                    sink.push(UnresolvedModule {\n+                        file: declaration.file_id,\n+                        decl: AstPtr::new(&decl),\n+                        candidate: candidate.clone(),\n+                    })\n+                }\n+            }\n+        }\n+    }\n+\n+}"}, {"sha": "8830b4624acb8476dbec4ebc6c24b05b3ddb2563", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -6,14 +6,17 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Problem, Crate,\n+    DefDatabase, HirFileId, Name, Path, Crate,\n     KnownName,\n-    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n+    nameres::{\n+        Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n+        CrateDefMap, CrateModuleId, ModuleData, CrateMacroId,\n+        diagnostics::DefDiagnostic,\n+        raw,\n+    },\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n };\n \n-use super::{CrateDefMap, CrateModuleId, ModuleData, CrateMacroId};\n-\n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n     // populate external prelude\n     for dep in def_map.krate.dependencies(db) {\n@@ -405,25 +408,27 @@ where\n             raw::ModuleData::Declaration { name, source_item_id } => {\n                 let source_item_id = source_item_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                let (file_ids, problem) =\n-                    resolve_submodule(self.def_collector.db, self.file_id, name, is_root);\n-\n-                if let Some(problem) = problem {\n-                    self.def_collector.def_map.problems.add(source_item_id, problem)\n-                }\n-\n-                if let Some(&file_id) = file_ids.first() {\n-                    let module_id =\n-                        self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                    let raw_items = self.def_collector.db.raw_items(file_id);\n-                    ModCollector {\n-                        def_collector: &mut *self.def_collector,\n-                        module_id,\n-                        file_id: file_id.into(),\n-                        raw_items: &raw_items,\n+                match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n+                    Ok(file_id) => {\n+                        let module_id =\n+                            self.push_child_module(name.clone(), source_item_id, Some(file_id));\n+                        let raw_items = self.def_collector.db.raw_items(file_id);\n+                        ModCollector {\n+                            def_collector: &mut *self.def_collector,\n+                            module_id,\n+                            file_id: file_id.into(),\n+                            raw_items: &raw_items,\n+                        }\n+                        .collect(raw_items.items())\n                     }\n-                    .collect(raw_items.items())\n-                }\n+                    Err(candidate) => self.def_collector.def_map.diagnostics.push(\n+                        DefDiagnostic::UnresolvedModule {\n+                            module: self.module_id,\n+                            declaration: source_item_id,\n+                            candidate,\n+                        },\n+                    ),\n+                };\n             }\n         }\n     }\n@@ -524,7 +529,7 @@ fn resolve_submodule(\n     file_id: HirFileId,\n     name: &Name,\n     is_root: bool,\n-) -> (Vec<FileId>, Option<Problem>) {\n+) -> Result<FileId, RelativePathBuf> {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n@@ -545,17 +550,10 @@ fn resolve_submodule(\n         candidates.push(file_dir_mod.clone());\n     };\n     let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n+    let mut points_to = candidates.into_iter().filter_map(|path| sr.files.get(&path)).map(|&it| it);\n+    // FIXME: handle ambiguity\n+    match points_to.next() {\n+        Some(file_id) => Ok(file_id),\n+        None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n+    }\n }"}, {"sha": "572bd1bf74734725ef27aa728733b63abde75579", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -552,3 +552,22 @@ foo: v\n \"###\n     );\n }\n+\n+#[test]\n+fn unresolved_module_diagnostics() {\n+    let diagnostics = MockDatabase::with_files(\n+        r\"\n+        //- /lib.rs\n+        mod foo;\n+        mod bar;\n+        mod baz {}\n+        //- /foo.rs\n+        \",\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot_matches!(diagnostics, @r###\"\n+\"mod bar;\": unresolved module\n+\"###\n+    );\n+}"}, {"sha": "5fd602a9e63d24d6d005af0418c7a2cb87409204", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -36,7 +36,9 @@ use crate::{\n     path::{GenericArgs, GenericArg},\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n-    nameres::Namespace\n+    nameres::Namespace,\n+    ty::infer::diagnostics::InferenceDiagnostic,\n+    diagnostics::DiagnosticSink,\n };\n use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n \n@@ -96,6 +98,7 @@ pub struct InferenceResult {\n     field_resolutions: FxHashMap<ExprId, StructField>,\n     /// For each associated item record what it resolves to\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n+    diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -113,6 +116,14 @@ impl InferenceResult {\n     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n         self.assoc_resolutions.get(&id.into()).map(|it| *it)\n     }\n+    pub(crate) fn add_diagnostics(\n+        &self,\n+        db: &impl HirDatabase,\n+        owner: Function,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -143,6 +154,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n+    diagnostics: Vec<InferenceDiagnostic>,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n@@ -155,6 +167,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n+            diagnostics: Vec::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n@@ -181,6 +194,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: self.assoc_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n+            diagnostics: self.diagnostics,\n         }\n     }\n \n@@ -915,9 +929,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n-                for field in fields {\n+                for (field_idx, field) in fields.into_iter().enumerate() {\n                     let field_ty = def_id\n-                        .and_then(|it| it.field(self.db, &field.name))\n+                        .and_then(|it| match it.field(self.db, &field.name) {\n+                            Some(field) => Some(field),\n+                            None => {\n+                                self.diagnostics.push(InferenceDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        })\n                         .map_or(Ty::Unknown, |field| field.ty(self.db))\n                         .subst(&substs);\n                     self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n@@ -1244,3 +1267,29 @@ impl Expectation {\n         Expectation { ty: Ty::Unknown }\n     }\n }\n+\n+mod diagnostics {\n+    use crate::{expr::ExprId, diagnostics::{DiagnosticSink, NoSuchField}, HirDatabase, Function};\n+\n+    #[derive(Debug, PartialEq, Eq, Clone)]\n+    pub(super) enum InferenceDiagnostic {\n+        NoSuchField { expr: ExprId, field: usize },\n+    }\n+\n+    impl InferenceDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl HirDatabase,\n+            owner: Function,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                InferenceDiagnostic::NoSuchField { expr, field } => {\n+                    let (file, _) = owner.source(db);\n+                    let field = owner.body_source_map(db).field_syntax(*expr, *field);\n+                    sink.push(NoSuchField { file, field })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3aedba2431d554fca9a616c64cc3397df5496fbb", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -2319,3 +2319,27 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }\n }\n+\n+#[test]\n+fn no_such_field_diagnostics() {\n+    let diagnostics = MockDatabase::with_files(\n+        r\"\n+        //- /lib.rs\n+        struct S { foo: i32, bar: () }\n+        impl S {\n+            fn new() -> S {\n+                S {\n+                    foo: 92,\n+                    baz: 62,\n+                }\n+            }\n+        }\n+        \",\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot_matches!(diagnostics, @r###\"\n+\"baz: 62\": no such field\n+\"###\n+    );\n+}"}, {"sha": "5a78e94d82225eb230b2643badf472a90bc5216b", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -1,10 +1,11 @@\n+use std::cell::RefCell;\n+\n use itertools::Itertools;\n-use hir::{Problem, source_binder};\n+use hir::{source_binder, diagnostics::{Diagnostic as _, DiagnosticSink}};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n     ast::{self, AstNode},\n-\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n@@ -26,11 +27,31 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n         check_struct_shorthand_initialization(&mut res, file_id, node);\n     }\n-\n+    let res = RefCell::new(res);\n+    let mut sink = DiagnosticSink::new(|d| {\n+        res.borrow_mut().push(Diagnostic {\n+            message: d.message(),\n+            range: d.highlight_range(),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+    })\n+    .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n+        let source_root = db.file_source_root(d.file().original_file(db));\n+        let create_file = FileSystemEdit::CreateFile { source_root, path: d.candidate.clone() };\n+        let fix = SourceChange::file_system_edit(\"create module\", create_file);\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: Some(fix),\n+        })\n+    });\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n-        check_module(&mut res, db, file_id, m);\n+        m.diagnostics(db, &mut sink);\n     };\n-    res\n+    drop(sink);\n+    res.into_inner()\n }\n \n fn syntax_errors(acc: &mut Vec<Diagnostic>, source_file: &SourceFile) {\n@@ -128,34 +149,12 @@ fn check_struct_shorthand_initialization(\n     Some(())\n }\n \n-fn check_module(\n-    acc: &mut Vec<Diagnostic>,\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    module: hir::Module,\n-) {\n-    let source_root = db.file_source_root(file_id);\n-    for (name_node, problem) in module.problems(db) {\n-        let diag = match problem {\n-            Problem::UnresolvedModule { candidate } => {\n-                let create_file =\n-                    FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n-                let fix = SourceChange::file_system_edit(\"create module\", create_file);\n-                Diagnostic {\n-                    range: name_node.range(),\n-                    message: \"unresolved module\".to_string(),\n-                    severity: Severity::Error,\n-                    fix: Some(fix),\n-                }\n-            }\n-        };\n-        acc.push(diag)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::assert_eq_text;\n+    use insta::assert_debug_snapshot_matches;\n+\n+    use crate::mock_analysis::single_file;\n \n     use super::*;\n \n@@ -184,6 +183,34 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    #[test]\n+    fn test_unresolved_module_diagnostic() {\n+        let (analysis, file_id) = single_file(\"mod foo;\");\n+        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+        assert_debug_snapshot_matches!(diagnostics, @r####\"[\n+    Diagnostic {\n+        message: \"unresolved module\",\n+        range: [0; 8),\n+        fix: Some(\n+            SourceChange {\n+                label: \"create module\",\n+                source_file_edits: [],\n+                file_system_edits: [\n+                    CreateFile {\n+                        source_root: SourceRootId(\n+                            0\n+                        ),\n+                        path: \"foo.rs\"\n+                    }\n+                ],\n+                cursor_position: None\n+            }\n+        ),\n+        severity: Error\n+    }\n+]\"####);\n+    }\n+\n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n         check_not_applicable("}, {"sha": "d4ff21c09ccab9fc79b72152f75b94952835d9e9", "filename": "crates/ra_ide_api/tests/test/main.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -1,26 +1,10 @@\n-use insta::assert_debug_snapshot_matches;\n use ra_ide_api::{\n     mock_analysis::{single_file, single_file_with_position, single_file_with_range, MockAnalysis},\n     AnalysisChange, CrateGraph, Edition::Edition2018, Query, NavigationTarget,\n     ReferenceSearchResult,\n };\n use ra_syntax::SmolStr;\n \n-#[test]\n-fn test_unresolved_module_diagnostic() {\n-    let (analysis, file_id) = single_file(\"mod foo;\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert_debug_snapshot_matches!(\"unresolved_module_diagnostic\", &diagnostics);\n-}\n-\n-// FIXME: move this test to hir\n-#[test]\n-fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n-    let (analysis, file_id) = single_file(\"mod foo {}\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert!(diagnostics.is_empty());\n-}\n-\n #[test]\n fn test_resolve_crate_root() {\n     let mock = MockAnalysis::with_files("}, {"sha": "5bb9538922312ebadc85efca82ae623c143649fa", "filename": "crates/ra_ide_api/tests/test/snapshots/test__unresolved_module_diagnostic.snap", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "raw_url": "https://github.com/rust-lang/rust/raw/8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap?ref=8aedf9603df1bc68eafcd8dcf3c14e5a6a2c8638", "patch": "@@ -1,28 +0,0 @@\n----\n-created: \"2019-01-22T14:45:01.486985900+00:00\"\n-creator: insta@0.4.0\n-expression: \"&diagnostics\"\n-source: \"crates\\\\ra_ide_api\\\\tests\\\\test\\\\main.rs\"\n----\n-[\n-    Diagnostic {\n-        message: \"unresolved module\",\n-        range: [0; 8),\n-        fix: Some(\n-            SourceChange {\n-                label: \"create module\",\n-                source_file_edits: [],\n-                file_system_edits: [\n-                    CreateFile {\n-                        source_root: SourceRootId(\n-                            0\n-                        ),\n-                        path: \"foo.rs\"\n-                    }\n-                ],\n-                cursor_position: None\n-            }\n-        ),\n-        severity: Error\n-    }\n-]"}, {"sha": "d8de1c4c1b535ee9ce554b65e7e3df8d9fb2d2f3", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ead49361e4b8c0586b810399c8e96a468b891c/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=c4ead49361e4b8c0586b810399c8e96a468b891c", "patch": "@@ -64,6 +64,12 @@ impl<N: AstNode> AstPtr<N> {\n     }\n }\n \n+impl<N: AstNode> From<AstPtr<N>> for SyntaxNodePtr {\n+    fn from(ptr: AstPtr<N>) -> SyntaxNodePtr {\n+        ptr.raw\n+    }\n+}\n+\n #[test]\n fn test_local_syntax_ptr() {\n     use crate::{ast, AstNode};"}]}