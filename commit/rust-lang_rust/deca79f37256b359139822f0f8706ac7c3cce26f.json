{"sha": "deca79f37256b359139822f0f8706ac7c3cce26f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlY2E3OWYzNzI1NmIzNTkxMzk4MjJmMGY4NzA2YWM3YzNjY2UyNmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-07T22:18:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-07T22:18:07Z"}, "message": "Merge pull request #634 from robarnold/upstream-stable\n\nAllocate ivecs out of the kernel pool", "tree": {"sha": "d56fcc4b2585d445ae1a1e1eabc3639de41fecec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d56fcc4b2585d445ae1a1e1eabc3639de41fecec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deca79f37256b359139822f0f8706ac7c3cce26f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deca79f37256b359139822f0f8706ac7c3cce26f", "html_url": "https://github.com/rust-lang/rust/commit/deca79f37256b359139822f0f8706ac7c3cce26f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deca79f37256b359139822f0f8706ac7c3cce26f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5547e5dd216f2b062809b52abff01b5baca0d6a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5547e5dd216f2b062809b52abff01b5baca0d6a0", "html_url": "https://github.com/rust-lang/rust/commit/5547e5dd216f2b062809b52abff01b5baca0d6a0"}, {"sha": "f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "html_url": "https://github.com/rust-lang/rust/commit/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb"}], "stats": {"total": 200, "additions": 188, "deletions": 12}, "files": [{"sha": "db750fe7a6d7cd33abf9772a599b9ccc83a2fd9b", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -47,6 +47,8 @@ type upcalls =\n         ValueRef exit,\n         ValueRef malloc,\n         ValueRef free,\n+        ValueRef shared_malloc,\n+        ValueRef shared_free,\n         ValueRef mark,\n         ValueRef new_str,\n         ValueRef dup_str,\n@@ -56,7 +58,9 @@ type upcalls =\n         ValueRef new_task,\n         ValueRef start_task,\n         ValueRef ivec_resize,\n-        ValueRef ivec_spill);\n+        ValueRef ivec_spill,\n+        ValueRef ivec_resize_shared,\n+        ValueRef ivec_spill_shared);\n \n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n     fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n@@ -97,6 +101,9 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n              malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n                       T_ptr(T_i8())),\n              free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+             shared_malloc=d(\"shared_malloc\",\n+                      [T_size_t(), T_ptr(T_tydesc(tn))], T_ptr(T_i8())),\n+             shared_free=dv(\"shared_free\", [T_ptr(T_i8())]),\n              mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n              new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n                        T_ptr(T_str())),\n@@ -119,7 +126,11 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n              ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n                            T_void()),\n              ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n-                          T_void()));\n+                          T_void()),\n+             ivec_resize_shared=d(\"ivec_resize_shared\",\n+                           [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+             ivec_spill_shared=d(\"ivec_spill_shared\",\n+                          [T_ptr(T_opaque_ivec()), T_int()], T_void()));\n }\n //\n // Local Variables:"}, {"sha": "61b677f058f5a92e6a47e1cb7667fb6c683cc13e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -1186,6 +1186,12 @@ fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n     ret rslt(cx, C_int(0));\n }\n \n+fn trans_shared_free(&@block_ctxt cx, ValueRef v) -> result {\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls.shared_free,\n+                  [cx.fcx.lltaskptr, cx.build.PointerCast(v, T_ptr(T_i8()))]);\n+    ret rslt(cx, C_int(0));\n+}\n+\n fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n     alt (cx.parent) {\n@@ -1614,6 +1620,18 @@ fn trans_raw_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n     ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n+// trans_shared_malloc: expects a type indicating which pointer type we want\n+// and a size indicating how much space we want malloc'd.\n+fn trans_shared_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n+   result {\n+    // FIXME: need a table to collect tydesc globals.\n+\n+    auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n+    auto rval =\n+        cx.build.Call(cx.fcx.lcx.ccx.upcalls.shared_malloc,\n+                      [cx.fcx.lltaskptr, llsize, tydesc]);\n+    ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n+}\n \n // trans_malloc_boxed: expects an unboxed type and returns a pointer to enough\n // space for something of that type, along with space for a reference count;\n@@ -2133,7 +2151,7 @@ fn maybe_free_ivec_heap_part(&@block_ctxt cx, ValueRef v0, ty::t unit_ty) ->\n             auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, v);\n             maybe_on_heap_cx.build.Load(m)\n         };\n-    auto after_free_cx = trans_non_gc_free(maybe_on_heap_cx, heap_ptr).bcx;\n+    auto after_free_cx = trans_shared_free(maybe_on_heap_cx, heap_ptr).bcx;\n     after_free_cx.build.Br(next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n@@ -3673,7 +3691,8 @@ mod ivec {\n         {\n             auto p =\n                 heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-            heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n+            auto upcall = cx.fcx.lcx.ccx.upcalls.ivec_resize_shared;\n+            heap_resize_cx.build.Call(upcall,\n                                       [cx.fcx.lltaskptr, p, new_heap_len]);\n         }\n         auto heap_ptr_resize =\n@@ -3713,7 +3732,8 @@ mod ivec {\n         {\n             auto p =\n                 stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-            stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n+            auto upcall = cx.fcx.lcx.ccx.upcalls.ivec_spill_shared;\n+            stack_spill_cx.build.Call(upcall,\n                                       [cx.fcx.lltaskptr, p, new_stack_len]);\n         }\n         auto spill_stub =\n@@ -3963,7 +3983,7 @@ mod ivec {\n                             heap_cx.build.InBoundsGEP(stub_ptr_heap,\n                                                       stub_a));\n         auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n-        auto rs = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n+        auto rs = trans_shared_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n         auto heap_part = rs.val;\n         heap_cx = rs.bcx;\n         heap_cx.build.Store(heap_part,\n@@ -4100,7 +4120,7 @@ mod ivec {\n \n         auto heap_part_sz = on_heap_cx.build.Add(alen,\n             llsize_of(T_opaque_ivec_heap_part()));\n-        auto rs = trans_raw_malloc(on_heap_cx, T_ptr(llheappartty),\n+        auto rs = trans_shared_malloc(on_heap_cx, T_ptr(llheappartty),\n                                    heap_part_sz);\n         on_heap_cx = rs.bcx;\n         auto new_heap_ptr = rs.val;\n@@ -6038,7 +6058,7 @@ fn trans_ivec(@block_ctxt bcx, &(@ast::expr)[] args, ast::node_id id) ->\n             bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n \n             auto llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n-            auto rslt = trans_raw_malloc(bcx, T_ptr(llheapty), llheapsz);\n+            auto rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n             bcx = rslt.bcx;\n             auto llheapptr = rslt.val;\n             bcx.build.Store(llheapptr,"}, {"sha": "d34b54d68e4c40f649cded880fbf13620655c342", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -11,15 +11,16 @@ native \"rust-intrinsic\" mod rusti {\n }\n \n native \"rust\" mod rustrt {\n-    fn ivec_reserve[T](&mutable T[mutable?] v, uint n);\n+    fn ivec_reserve_shared[T](&mutable T[mutable?] v, uint n);\n     fn ivec_on_heap[T](&T[] v) -> uint;\n     fn ivec_to_ptr[T](&T[] v) -> *T;\n-    fn ivec_copy_from_buf[T](&mutable T[mutable?] v, *T ptr, uint count);\n+    fn ivec_copy_from_buf_shared[T](&mutable T[mutable?] v,\n+                                    *T ptr, uint count);\n }\n \n /// Reserves space for `n` elements in the given vector.\n fn reserve[T](&mutable T[mutable?] v, uint n) {\n-    rustrt::ivec_reserve(v, n);\n+    rustrt::ivec_reserve_shared(v, n);\n }\n \n fn on_heap[T](&T[] v) -> bool {\n@@ -204,7 +205,7 @@ fn all[T](fn(&T)->bool f, &T[] v) -> bool {\n \n mod unsafe {\n     fn copy_from_buf[T](&mutable T[] v, *T ptr, uint count) {\n-        ret rustrt::ivec_copy_from_buf(v, ptr, count);\n+        ret rustrt::ivec_copy_from_buf_shared(v, ptr, count);\n     }\n }\n "}, {"sha": "872a317ca38e11c00b5d2fdadc960113f8b014b1", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -648,6 +648,37 @@ ivec_reserve(rust_task *task, type_desc *ty, rust_ivec *v, size_t n_elems)\n     v->alloc = new_alloc;\n }\n \n+/**\n+ * Preallocates the exact number of bytes in the given interior vector.\n+ */\n+extern \"C\" CDECL void\n+ivec_reserve_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n+                    size_t n_elems)\n+{\n+    size_t new_alloc = n_elems * ty->size;\n+    if (new_alloc <= v->alloc)\n+        return;     // Already big enough.\n+\n+    rust_ivec_heap *heap_part;\n+    if (v->fill || !v->payload.ptr) {\n+        // On stack; spill to heap.\n+        heap_part = (rust_ivec_heap *)task->kernel->malloc(new_alloc +\n+                                                           sizeof(size_t));\n+        heap_part->fill = v->fill;\n+        memcpy(&heap_part->data, v->payload.data, v->fill);\n+\n+        v->fill = 0;\n+        v->payload.ptr = heap_part;\n+    } else {\n+        // On heap; resize.\n+        heap_part = (rust_ivec_heap *)task->kernel->realloc(v->payload.ptr,\n+                                                new_alloc + sizeof(size_t));\n+        v->payload.ptr = heap_part;\n+    }\n+\n+    v->alloc = new_alloc;\n+}\n+\n /**\n  * Returns true if the given vector is on the heap and false if it's on the\n  * stack.\n@@ -706,6 +737,35 @@ ivec_copy_from_buf(rust_task *task, type_desc *ty, rust_ivec *v, void *ptr,\n     v->payload.ptr->fill = new_size;\n }\n \n+/**\n+ * Copies elements in an unsafe buffer to the given interior vector. The\n+ * vector must have size zero.\n+ */\n+extern \"C\" CDECL void\n+ivec_copy_from_buf_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n+                   void *ptr, size_t count)\n+{\n+    size_t old_size = get_ivec_size(v);\n+    if (old_size) {\n+        task->fail(1);\n+        return;\n+    }\n+\n+    ivec_reserve_shared(task, ty, v, count);\n+\n+    size_t new_size = count * ty->size;\n+    if (v->fill || !v->payload.ptr) {\n+        // On stack.\n+        memmove(v->payload.data, ptr, new_size);\n+        v->fill = new_size;\n+        return;\n+    }\n+\n+    // On heap.\n+    memmove(v->payload.ptr->data, ptr, new_size);\n+    v->payload.ptr->fill = new_size;\n+}\n+\n extern \"C\" CDECL void\n pin_task(rust_task *task) {\n     task->pin();"}, {"sha": "b58a6a54cb1684b8354d2360585c5b9b8ac76d0f", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -206,6 +206,11 @@ rust_kernel::malloc(size_t size) {\n     return _region->malloc(size);\n }\n \n+void *\n+rust_kernel::realloc(void *mem, size_t size) {\n+    return _region->realloc(mem, size);\n+}\n+\n void rust_kernel::free(void *mem) {\n     _region->free(mem);\n }"}, {"sha": "3ed82b221121f2efbbba026059432a8c9eda9a9a", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -110,6 +110,7 @@ class rust_kernel : public rust_thread {\n     virtual ~rust_kernel();\n \n     void *malloc(size_t size);\n+    void *realloc(void *mem, size_t size);\n     void free(void *mem);\n \n     // FIXME: this should go away"}, {"sha": "a89c01ebdfba5dc6787c9385833edd7b305ed52b", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -289,6 +289,36 @@ upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     task->free(ptr, (bool) is_gc);\n }\n \n+extern \"C\" CDECL uintptr_t\n+upcall_shared_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+\n+    LOG(task, mem,\n+                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n+                   nbytes, td);\n+    void *p = task->kernel->malloc(nbytes);\n+    LOG(task, mem,\n+                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n+                   \") = 0x%\" PRIxPTR,\n+                   nbytes, td, (uintptr_t)p);\n+    return (uintptr_t) p;\n+}\n+\n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_shared_free(rust_task *task, void* ptr) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    rust_scheduler *sched = task->sched;\n+    DLOG(sched, mem,\n+             \"upcall shared_free(0x%\" PRIxPTR\")\",\n+             (uintptr_t)ptr);\n+    task->kernel->free(ptr);\n+}\n+\n extern \"C\" CDECL uintptr_t\n upcall_mark(rust_task *task, void* ptr) {\n     LOG_UPCALL_ENTRY(task);\n@@ -537,6 +567,7 @@ extern \"C\" CDECL void\n upcall_ivec_resize(rust_task *task,\n                    rust_ivec *v,\n                    size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n     I(task->sched, !v->fill);\n \n@@ -556,6 +587,7 @@ extern \"C\" CDECL void\n upcall_ivec_spill(rust_task *task,\n                   rust_ivec *v,\n                   size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n     size_t new_alloc = next_power_of_two(newsz);\n \n@@ -569,6 +601,46 @@ upcall_ivec_spill(rust_task *task,\n     v->payload.ptr = heap_part;\n }\n \n+/**\n+ * Resizes an interior vector that has been spilled to the heap.\n+ */\n+extern \"C\" CDECL void\n+upcall_ivec_resize_shared(rust_task *task,\n+                          rust_ivec *v,\n+                          size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    I(task->sched, !v->fill);\n+\n+    size_t new_alloc = next_power_of_two(newsz);\n+    rust_ivec_heap *new_heap_part = (rust_ivec_heap *)\n+        task->kernel->realloc(v->payload.ptr, new_alloc + sizeof(size_t));\n+\n+    new_heap_part->fill = newsz;\n+    v->alloc = new_alloc;\n+    v->payload.ptr = new_heap_part;\n+}\n+\n+/**\n+ * Spills an interior vector to the heap.\n+ */\n+extern \"C\" CDECL void\n+upcall_ivec_spill_shared(rust_task *task,\n+                         rust_ivec *v,\n+                         size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    size_t new_alloc = next_power_of_two(newsz);\n+\n+    rust_ivec_heap *heap_part = (rust_ivec_heap *)\n+        task->kernel->malloc(new_alloc + sizeof(size_t));\n+    heap_part->fill = newsz;\n+    memcpy(&heap_part->data, v->payload.data, v->fill);\n+\n+    v->fill = 0;\n+    v->alloc = new_alloc;\n+    v->payload.ptr = heap_part;\n+}\n //\n // Local Variables:\n // mode: C++"}, {"sha": "481936eee69daf9842202f8236954fc46335377c", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/deca79f37256b359139822f0f8706ac7c3cce26f/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=deca79f37256b359139822f0f8706ac7c3cce26f", "patch": "@@ -11,8 +11,10 @@ debug_tydesc\n do_gc\n get_time\n ivec_copy_from_buf\n+ivec_copy_from_buf_shared\n ivec_on_heap\n ivec_reserve\n+ivec_reserve_shared\n ivec_to_ptr\n last_os_error\n nano_time\n@@ -59,7 +61,9 @@ upcall_free\n upcall_get_type_desc\n upcall_grow_task\n upcall_ivec_resize\n+upcall_ivec_resize_shared\n upcall_ivec_spill\n+upcall_ivec_spill_shared\n upcall_kill\n upcall_log_double\n upcall_log_float\n@@ -74,6 +78,8 @@ upcall_new_task\n upcall_new_vec\n upcall_recv\n upcall_send\n+upcall_shared_malloc\n+upcall_shared_free\n upcall_sleep\n upcall_start_task\n upcall_trace_str"}]}