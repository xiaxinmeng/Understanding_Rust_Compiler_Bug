{"sha": "ee24bddfc51df686c72d3a3ed52611209c655850", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMjRiZGRmYzUxZGY2ODZjNzJkM2EzZWQ1MjYxMTIwOWM2NTU4NTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-16T12:16:29Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-16T12:16:29Z"}, "message": "Rollup merge of #30320 - nrc:err-names, r=@nikomatsakis\n\nWe can now handle name resolution errors and get past type checking (if we're a bit lucky). This is the first step towards doing code completion for partial programs (we need error recovery in the parser and early access to save-analysis).", "tree": {"sha": "de9f07af7daca6f2e090a7645fc1acaae35b6674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de9f07af7daca6f2e090a7645fc1acaae35b6674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee24bddfc51df686c72d3a3ed52611209c655850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee24bddfc51df686c72d3a3ed52611209c655850", "html_url": "https://github.com/rust-lang/rust/commit/ee24bddfc51df686c72d3a3ed52611209c655850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee24bddfc51df686c72d3a3ed52611209c655850/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce7bc51933e2facb4eca029ac17b398f372f5b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce7bc51933e2facb4eca029ac17b398f372f5b41", "html_url": "https://github.com/rust-lang/rust/commit/ce7bc51933e2facb4eca029ac17b398f372f5b41"}, {"sha": "18b4fe0e3eb9c68a966fce2fec12d892db00014a", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b4fe0e3eb9c68a966fce2fec12d892db00014a", "html_url": "https://github.com/rust-lang/rust/commit/18b4fe0e3eb9c68a966fce2fec12d892db00014a"}], "stats": {"total": 521, "additions": 308, "deletions": 213}, "files": [{"sha": "0882f3f1137eca0c4a829d6b1206a0a5d0da6544", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -99,8 +99,9 @@ pub fn check_crate<'ast>(sess: &Session,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n-    krate.visit_all_items(&mut visitor);\n-    sess.abort_if_errors();\n+    sess.abort_if_new_errors(|| {\n+        krate.visit_all_items(&mut visitor);\n+    });\n }\n \n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {"}, {"sha": "809c6084b769f74c8dabeeddcbb0955bc6d89403", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -52,6 +52,7 @@ pub enum Def {\n     DefStruct(DefId),\n     DefLabel(ast::NodeId),\n     DefMethod(DefId),\n+    DefErr,\n }\n \n /// The result of resolving a path.\n@@ -124,7 +125,7 @@ impl Def {\n             DefVariant(..) | DefTy(..) | DefAssociatedTy(..) |\n             DefTyParam(..) | DefUse(..) | DefStruct(..) | DefTrait(..) |\n             DefMethod(..) | DefConst(..) | DefAssociatedConst(..) |\n-            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) => {\n+            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) | DefErr => {\n                 panic!(\"attempted .def_id() on invalid {:?}\", self)\n             }\n         }\n@@ -142,7 +143,8 @@ impl Def {\n \n             DefLabel(..)  |\n             DefPrimTy(..) |\n-            DefSelfTy(..) => {\n+            DefSelfTy(..) |\n+            DefErr => {\n                 panic!(\"attempted .def_id() on invalid def: {:?}\", self)\n             }\n         }"}, {"sha": "f869cac9236f6e710095d2a13048c33112c31334", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -609,6 +609,8 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 note: NoteNone\n             }))\n           }\n+\n+          def::DefErr => panic!(\"DefErr in memory categorization\")\n         }\n     }\n \n@@ -1196,7 +1198,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         (*op)(self, cmt.clone(), pat);\n \n         let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n-            if path_res.depth != 0 {\n+            if path_res.depth != 0 || path_res.base_def == def::DefErr {\n                 // Since patterns can be associated constants\n                 // which are resolved during typeck, we might have\n                 // some unresolved patterns reaching this stage\n@@ -1261,7 +1263,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 _ => {\n                     self.tcx().sess.span_bug(\n                         pat.span,\n-                        \"enum pattern didn't resolve to enum or struct\");\n+                        &format!(\"enum pattern didn't resolve to enum or struct {:?}\", opt_def));\n                 }\n             }\n           }"}, {"sha": "15d1546d2d5483e20edd5feb59d7b5df82a41d31", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -95,15 +95,16 @@ static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap();\n-    krate.visit_all_items(&mut LifetimeContext {\n-        sess: sess,\n-        named_region_map: &mut named_region_map,\n-        scope: &ROOT_SCOPE,\n-        def_map: def_map,\n-        trait_ref_hack: false,\n-        labels_in_fn: vec![],\n+    sess.abort_if_new_errors(|| {\n+        krate.visit_all_items(&mut LifetimeContext {\n+            sess: sess,\n+            named_region_map: &mut named_region_map,\n+            scope: &ROOT_SCOPE,\n+            def_map: def_map,\n+            trait_ref_hack: false,\n+            labels_in_fn: vec![],\n+        });\n     });\n-    sess.abort_if_errors();\n     named_region_map\n }\n "}, {"sha": "5161a28ca31e88e492146d0ca60879e6b2a1b43f", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -2100,9 +2100,8 @@ impl<'tcx> ctxt<'tcx> {\n                     }) => {\n                         true\n                     }\n-\n+                    Some(&def::PathResolution { base_def: def::DefErr, .. })=> true,\n                     Some(..) => false,\n-\n                     None => self.sess.span_bug(expr.span, &format!(\n                         \"no def for path {}\", expr.id))\n                 }"}, {"sha": "b7bfc2f8db53ecc4569c2b63cde8f22cab34bda1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -156,6 +156,15 @@ impl Session {\n             _ => {}\n         }\n     }\n+    pub fn abort_if_new_errors<F>(&self, mut f: F)\n+        where F: FnMut()\n+    {\n+        let count = self.err_count();\n+        f();\n+        if self.err_count() > count {\n+            self.abort_if_errors();\n+        }\n+    }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         if self.can_print_warnings {\n             self.diagnostic().span_warn(sp, msg)"}, {"sha": "d43ffb0fc3f3e071616857740b3208069521c435", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -407,7 +407,8 @@ impl tr for def::Def {\n               def::DefUpvar(did1, nid1, index, nid2)\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n-          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid)),\n+          def::DefErr => def::DefErr,\n         }\n     }\n }"}, {"sha": "8b5b6ff781e070c177cdfb439f65dd4c6a155698", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -709,7 +709,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DefUse(..) |\n             DefUpvar(..) |\n             DefLabel(..) |\n-            DefSelfTy(..) => {\n+            DefSelfTy(..) |\n+            DefErr => {\n                 panic!(\"didn't expect `{:?}`\", def);\n             }\n         }"}, {"sha": "4d5978f5560781eea3e31a63e003c165299ac8d8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -566,6 +566,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n+                self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n             }\n         }\n         intravisit::walk_poly_trait_ref(self, tref, m);\n@@ -2005,6 +2006,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                   prefix.span,\n                                                   ResolutionError::FailedToResolve(\n                                                       &path_names_to_string(prefix, 0)));\n+                                    self.record_def(item.id, err_path_resolution());\n                                 }\n                             }\n                         }\n@@ -2164,6 +2166,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         resolve_error(self,\n                                       eq_pred.span,\n                                       ResolutionError::UndeclaredAssociatedType);\n+                        self.record_def(eq_pred.id, err_path_resolution());\n                     }\n                 }\n             }\n@@ -2194,6 +2197,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.record_def(trait_ref.ref_id, path_res);\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n+            } else {\n+                self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n             intravisit::walk_trait_ref(self, trait_ref);\n         }\n@@ -2463,6 +2468,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, def);\n                     }\n                     None => {\n+                        self.record_def(ty.id, err_path_resolution());\n+\n                         // Keep reporting some errors even if they're ignored above.\n                         self.resolve_path(ty.id, path, 0, TypeNS, true);\n \n@@ -2545,6 +2552,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n                                     renamed)\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                         FoundConst(def, lp, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n@@ -2564,6 +2572,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::OnlyIrrefutablePatternsAllowedHere(def.def_id(),\n                                                                                     name)\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\", renamed);\n@@ -2647,6 +2656,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 resolve_error(&self,\n                                               path.span,\n                                               ResolutionError::StaticVariableReference);\n+                                self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n@@ -2665,6 +2675,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name\n                                                  .as_str())\n                                     );\n+                                    self.record_def(pattern.id, err_path_resolution());\n                                 } else {\n                                     let const_name = path.segments\n                                                          .last()\n@@ -2684,6 +2695,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             ResolutionError::UnresolvedEnumVariantStructOrConst(\n                                 &path.segments.last().unwrap().identifier.name.as_str())\n                         );\n+                        self.record_def(pattern.id, err_path_resolution());\n                     }\n                     intravisit::walk_path(self, path);\n                 }\n@@ -2726,6 +2738,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         &path.segments.last().unwrap().identifier.name.as_str()\n                                     )\n                                 );\n+                                self.record_def(pattern.id, err_path_resolution());\n                             }\n                         }\n                     } else {\n@@ -2737,6 +2750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .identifier\n                                                                                       .name\n                                                                                       .as_str()));\n+                        self.record_def(pattern.id, err_path_resolution());\n                     }\n                     intravisit::walk_pat(self, pattern);\n                 }\n@@ -2754,6 +2768,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::DoesNotNameAStruct(\n                                     &*path_names_to_string(path, 0))\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                     }\n                     intravisit::walk_path(self, path);\n@@ -3430,6 +3445,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         } else {\n                             self.session.span_help(expr.span, &msg);\n                         }\n+                        self.record_def(expr.id, err_path_resolution());\n                     } else {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n@@ -3454,6 +3470,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS, false)\n                     });\n+\n+                    self.record_def(expr.id, err_path_resolution());\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _)) if self.structs.contains_key(&struct_id) => {\n                             resolve_error(\n@@ -3540,6 +3558,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                       ResolutionError::DoesNotNameAStruct(\n                                                                 &*path_names_to_string(path, 0))\n                                      );\n+                        self.record_def(expr.id, err_path_resolution());\n                     }\n                 }\n \n@@ -3562,6 +3581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_label(label.node.name) {\n                     None => {\n+                        self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n                                       ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n@@ -3811,6 +3831,14 @@ fn module_to_string(module: &Module) -> String {\n     names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n }\n \n+fn err_path_resolution() -> PathResolution {\n+    PathResolution {\n+        base_def: DefErr,\n+        last_private: LastMod(AllPublic),\n+        depth: 0,\n+    }\n+}\n+\n \n pub struct CrateMap {\n     pub def_map: RefCell<DefMap>,\n@@ -3836,7 +3864,6 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, None);\n \n     resolver.resolve_crate(krate);\n-    session.abort_if_errors();\n \n     check_unused::check_crate(&mut resolver, krate);\n "}, {"sha": "b3e7ed7ed5e8e3a0dc479cc5cd39a8353b13b000", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -276,7 +276,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefTyParam(..) |\n             def::DefUse(_) |\n             def::DefMethod(..) |\n-            def::DefPrimTy(_) => {\n+            def::DefPrimTy(_) |\n+            def::DefErr => {\n                 self.sess.span_bug(span,\n                                    &format!(\"lookup_def_kind for unexpected item: {:?}\", def));\n             }"}, {"sha": "a22c12588e5f74a9e86703fcfa923f3f3151f8d8", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -216,7 +216,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n             def::DefUse(..) | def::DefLabel(..) | def::DefTyParam(..) |\n-            def::DefSelfTy(..) => {\n+            def::DefSelfTy(..) | def::DefErr => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "752dd6e57f64fc86fbba86c35e26d0ed9dc41d01", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -719,6 +719,9 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => trait_def_id,\n+        def::DefErr => {\n+            this.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n+        }\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path);\n@@ -1533,6 +1536,9 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         def::DefPrimTy(prim_ty) => {\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n+        def::DefErr => {\n+            return this.tcx().types.err;\n+        }\n         _ => {\n             let id_node = tcx.map.as_local_node_id(def.def_id()).unwrap();\n             span_err!(tcx.sess, span, E0248,"}, {"sha": "efcc08c69f8246f83e9321b7bbe43a528db707c5", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -142,20 +142,24 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     return;\n                 }\n             }\n-            let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n-            let const_scheme = tcx.lookup_item_type(const_did);\n-            assert!(const_scheme.generics.is_empty());\n-            let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n-                                                           &Substs::empty(),\n-                                                           &const_scheme.ty);\n-            fcx.write_ty(pat.id, const_ty);\n-\n-            // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-            // As with PatLit, what we really want here is that there\n-            // exist a LUB, but for the cases that can occur, subtype\n-            // is good enough.\n-            demand::suptype(fcx, pat.span, expected, const_ty);\n+            if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n+                let const_did = pat_def.def_id();\n+                let const_scheme = tcx.lookup_item_type(const_did);\n+                assert!(const_scheme.generics.is_empty());\n+                let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n+                                                               &Substs::empty(),\n+                                                               &const_scheme.ty);\n+                fcx.write_ty(pat.id, const_ty);\n+\n+                // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+                // As with PatLit, what we really want here is that there\n+                // exist a LUB, but for the cases that can occur, subtype\n+                // is good enough.\n+                demand::suptype(fcx, pat.span, expected, const_ty);\n+            } else {\n+                fcx.write_error(pat.id);\n+            }\n         }\n         hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n@@ -186,14 +190,15 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = *pcx.map.get(&path.node.name).unwrap();\n-            if canon_id != pat.id {\n-                let ct = fcx.local_ty(pat.span, canon_id);\n-                demand::eqtype(fcx, pat.span, ct, typ);\n-            }\n+            if let Some(&canon_id) = pcx.map.get(&path.node.name) {\n+                if canon_id != pat.id {\n+                    let ct = fcx.local_ty(pat.span, canon_id);\n+                    demand::eqtype(fcx, pat.span, ct, typ);\n+                }\n \n-            if let Some(ref p) = *sub {\n-                check_pat(pcx, &**p, expected);\n+                if let Some(ref p) = *sub {\n+                    check_pat(pcx, &**p, expected);\n+                }\n             }\n         }\n         hir::PatIdent(_, ref path, _) => {\n@@ -208,6 +213,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         hir::PatQPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                if d.base_def == def::DefErr {\n+                    fcx.write_error(pat.id);\n+                    return;\n+                }\n                 d\n             } else if qself.position == 0 {\n                 // This is just a sentinel for finish_resolving_def_to_ty.\n@@ -218,8 +227,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(pat.span,\n-                                  &format!(\"unbound path {:?}\", pat))\n+                debug!(\"unbound path {:?}\", pat);\n+                fcx.write_error(pat.id);\n+                return;\n             };\n             if let Some((opt_ty, segments, def)) =\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n@@ -597,7 +607,20 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let path_res = *tcx.def_map.borrow().get(&pat.id).unwrap();\n+    let path_res = match tcx.def_map.borrow().get(&pat.id) {\n+        Some(&path_res) if path_res.base_def != def::DefErr => path_res,\n+        _ => {\n+            fcx.write_error(pat.id);\n+\n+            if let Some(subpats) = subpats {\n+                for pat in subpats {\n+                    check_pat(pcx, &**pat, tcx.types.err);\n+                }\n+            }\n+\n+            return;\n+        }\n+    };\n \n     let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n                                                                 None, path,\n@@ -636,7 +659,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let report_bad_struct_kind = |is_warning| {\n         bad_struct_kind_err(tcx.sess, pat.span, path, is_warning);\n         if is_warning {\n-            return\n+            return;\n         }\n \n         fcx.write_error(pat.id);"}, {"sha": "1e20cd3985467f45284d72c82229e9f875b5c21b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -26,6 +26,7 @@ use super::write_call;\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n+use middle::def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::ty::{self, LvaluePreference, Ty};\n@@ -234,7 +235,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n                 let tcx = fcx.tcx();\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                    if pr.depth == 0 {\n+                    if pr.depth == 0 && pr.base_def != def::DefErr {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n                             tcx.sess.span_note(span, \"defined here\")\n                         }"}, {"sha": "1f3d8f55120aa4456517d1bc67859c976dc1d483", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 118, "deletions": 113, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -385,61 +385,60 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n }\n \n pub fn check_wf_old(ccx: &CrateCtxt) {\n-    // FIXME(#25759). The new code below is much more reliable but (for now)\n-    // only generates warnings. So as to ensure that we continue\n-    // getting errors where we used to get errors, we run the old wf\n-    // code first and abort if it encounters any errors. If no abort\n-    // comes, we run the new code and issue warnings.\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n-    krate.visit_all_items(&mut visit);\n-\n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        // FIXME(#25759). The new code below is much more reliable but (for now)\n+        // only generates warnings. So as to ensure that we continue\n+        // getting errors where we used to get errors, we run the old wf\n+        // code first and abort if it encounters any errors. If no abort\n+        // comes, we run the new code and issue warnings.\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_wf_new(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-    krate.visit_all_items(&mut visit);\n-\n-    // If types are not well-formed, it leads to all manner of errors\n-    // downstream, so stop reporting errors at this point.\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-    krate.visit_all_items(&mut visit);\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-    krate.visit_all_items(&mut visit);\n-\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_drop_impls(ccx: &CrateCtxt) {\n-    let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n-        Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n-    };\n-    drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n-        if drop_impl_did.is_local() {\n-            match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n-                Ok(()) => {}\n-                Err(()) => {\n-                    assert!(ccx.tcx.sess.has_errors());\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n+            Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n+        };\n+        drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n+            if drop_impl_did.is_local() {\n+                match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                    Ok(()) => {}\n+                    Err(()) => {\n+                        assert!(ccx.tcx.sess.has_errors());\n+                    }\n                 }\n             }\n-        }\n+        });\n     });\n-\n-    ccx.tcx.sess.abort_if_errors();\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -891,75 +890,71 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for impl_item in impl_items {\n         let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n-            .find(|ac| ac.name() == ty_impl_item.name())\n-            .unwrap_or_else(|| {\n-                // This is checked by resolve\n-                tcx.sess.span_bug(impl_item.span,\n-                                  &format!(\"impl-item `{}` is not a member of `{:?}`\",\n-                                           ty_impl_item.name(),\n-                                           impl_trait_ref));\n-            });\n-        match impl_item.node {\n-            hir::ImplItemKind::Const(..) => {\n-                let impl_const = match ty_impl_item {\n-                    ty::ConstTraitItem(ref cti) => cti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n-                };\n+            .find(|ac| ac.name() == ty_impl_item.name());\n \n-                // Find associated const definition.\n-                if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n-                    compare_const_impl(ccx.tcx,\n-                                       &impl_const,\n-                                       impl_item.span,\n-                                       trait_const,\n-                                       &*impl_trait_ref);\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0323,\n-                              \"item `{}` is an associated const, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_const.name,\n-                              impl_trait_ref)\n+        if let Some(ty_trait_item) = ty_trait_item {\n+            match impl_item.node {\n+                hir::ImplItemKind::Const(..) => {\n+                    let impl_const = match ty_impl_item {\n+                        ty::ConstTraitItem(ref cti) => cti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                    };\n+\n+                    // Find associated const definition.\n+                    if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                        compare_const_impl(ccx.tcx,\n+                                           &impl_const,\n+                                           impl_item.span,\n+                                           trait_const,\n+                                           &*impl_trait_ref);\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0323,\n+                                  \"item `{}` is an associated const, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_const.name,\n+                                  impl_trait_ref)\n+                    }\n                 }\n-            }\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n-                check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n+                hir::ImplItemKind::Method(ref sig, ref body) => {\n+                    check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n-                let impl_method = match ty_impl_item {\n-                    ty::MethodTraitItem(ref mti) => mti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n-                };\n+                    let impl_method = match ty_impl_item {\n+                        ty::MethodTraitItem(ref mti) => mti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                    };\n \n-                if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n-                    compare_impl_method(ccx.tcx,\n-                                        &impl_method,\n-                                        impl_item.span,\n-                                        body.id,\n-                                        &trait_method,\n-                                        &impl_trait_ref);\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0324,\n-                              \"item `{}` is an associated method, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_method.name,\n-                              impl_trait_ref)\n+                    if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                        compare_impl_method(ccx.tcx,\n+                                            &impl_method,\n+                                            impl_item.span,\n+                                            body.id,\n+                                            &trait_method,\n+                                            &impl_trait_ref);\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0324,\n+                                  \"item `{}` is an associated method, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_method.name,\n+                                  impl_trait_ref)\n+                    }\n                 }\n-            }\n-            hir::ImplItemKind::Type(_) => {\n-                let impl_type = match ty_impl_item {\n-                    ty::TypeTraitItem(ref tti) => tti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n-                };\n+                hir::ImplItemKind::Type(_) => {\n+                    let impl_type = match ty_impl_item {\n+                        ty::TypeTraitItem(ref tti) => tti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                    };\n \n-                if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n-                    if let Some(_) = at.ty {\n-                        overridden_associated_type = Some(impl_item);\n+                    if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n+                        if let Some(_) = at.ty {\n+                            overridden_associated_type = Some(impl_item);\n+                        }\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0325,\n+                                  \"item `{}` is an associated type, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_type.name,\n+                                  impl_trait_ref)\n                     }\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0325,\n-                              \"item `{}` is an associated type, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_type.name,\n-                              impl_trait_ref)\n                 }\n             }\n         }\n@@ -3193,6 +3188,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n+        if def == def::DefErr {\n+            check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n+            return;\n+        }\n         let (adt, variant) = match fcx.def_struct_variant(def, path.span) {\n             Some((adt, variant)) => (adt, variant),\n             None => {\n@@ -3371,17 +3370,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if let Some((opt_ty, segments, def)) =\n                   resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n                                           expr.span, expr.id) {\n-              let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n-                                                                            expr.span,\n-                                                                            def);\n-              instantiate_path(fcx,\n-                               segments,\n-                               scheme,\n-                               &predicates,\n-                               opt_ty,\n-                               def,\n-                               expr.span,\n-                               id);\n+              if def != def::DefErr {\n+                  let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n+                                                                                expr.span,\n+                                                                                def);\n+                  instantiate_path(fcx,\n+                                   segments,\n+                                   scheme,\n+                                   &predicates,\n+                                   opt_ty,\n+                                   def,\n+                                   expr.span,\n+                                   id);\n+              } else {\n+                  fcx.write_ty(id, fcx.tcx().types.err);\n+              }\n           }\n \n           // We always require that the type provided as the value for\n@@ -4326,7 +4329,8 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefForeignMod(..) |\n         def::DefUse(..) |\n         def::DefLabel(..) |\n-        def::DefSelfTy(..) => {\n+        def::DefSelfTy(..) |\n+        def::DefErr => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n         }\n     }\n@@ -4496,7 +4500,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefLocal(..) |\n         def::DefUse(..) |\n         def::DefLabel(..) |\n-        def::DefUpvar(..) => {\n+        def::DefUpvar(..) |\n+        def::DefErr => {\n             segment_spaces = vec![None; segments.len()];\n         }\n     }"}, {"sha": "c24a416a0109c7a52e789d1d9d14e6f4dd66e024", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -122,10 +122,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 } else {\n                     let tcx = self.tcx();\n \n-                    if let hir::ExprAssignOp(..) = e.node {\n+                    if let hir::ExprAssignOp(_, ref lhs, ref rhs) = e.node {\n                         if\n                             !tcx.sess.features.borrow().augmented_assignments &&\n-                            !self.fcx.expr_ty(e).references_error()\n+                            !self.fcx.expr_ty(e).references_error() &&\n+                            !self.fcx.expr_ty(lhs).references_error() &&\n+                            !self.fcx.expr_ty(rhs).references_error()\n                         {\n                             tcx.sess.span_err(\n                                 e.span,"}, {"sha": "b436a5ee524acf7dc88bc112c7d6bc707b4c6ea0", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -205,6 +205,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"f64\",\n                                                   item.span);\n                     }\n+                    ty::TyError => {\n+                        return;\n+                    }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,\n                                   \"no base type found for inherent implementation; \\"}, {"sha": "02c1f3973c61a0875b3c636e9a864165f8038e57", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -331,18 +331,21 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n         tcx: tcx\n     };\n \n-    time(time_passes, \"type collecting\", ||\n-         collect::collect_item_types(tcx));\n-\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n-    tcx.sess.abort_if_errors();\n+    tcx.sess.abort_if_new_errors(|| {\n+        time(time_passes, \"type collecting\", ||\n+             collect::collect_item_types(tcx));\n+\n+    });\n \n     time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n-    time(time_passes, \"coherence checking\", ||\n-        coherence::check_coherence(&ccx));\n+    tcx.sess.abort_if_new_errors(|| {\n+      time(time_passes, \"coherence checking\", ||\n+          coherence::check_coherence(&ccx));\n+    });\n \n     time(time_passes, \"wf checking (old)\", ||\n         check::check_wf_old(&ccx));"}, {"sha": "3e153a21e5d38c8f0dfe86adcdb706a4420a7ea7", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -23,7 +23,8 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut Vec::new());\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "6d68da54112f24da473b778e0780319813873246", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -32,13 +32,13 @@ impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n impl<'a, B: ?Sized> IntoCow<'a, B> for <B as ToOwned>::Owned where B: ToOwned {\n //~^ ERROR E0119\n     fn into_cow(self) -> Cow<'a, B> {\n-        Cow\n+        Cow(PhantomData)\n     }\n }\n \n impl<'a, B: ?Sized> IntoCow<'a, B> for &'a B where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n-        Cow\n+        Cow(PhantomData)\n     }\n }\n "}, {"sha": "a1021500be3d7ed959b035c997a1b59e88492644", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -9,14 +9,12 @@\n // except according to those terms.\n \n \n-// error-pattern: unresolved\n-\n enum color { rgb(isize, isize, isize), rgba(isize, isize, isize, isize), }\n \n fn main() {\n-    let red: color = rgb(255, 0, 0);\n+    let red: color = color::rgb(255, 0, 0);\n     match red {\n-      rgb(r, g, b) => { println!(\"rgb\"); }\n-      hsl(h, s, l) => { println!(\"hsl\"); }\n+      color::rgb(r, g, b) => { println!(\"rgb\"); }\n+      color::hsl(h, s, l) => { println!(\"hsl\"); }  //~ ERROR no associated\n     }\n }"}, {"sha": "b08e4bad1e9c9b127dde7d7b43388b5df7fd9b5b", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait-object-safe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -13,7 +13,9 @@\n \n // If the trait is not object-safe, we give a more tailored message\n // because we're such schnuckels:\n-trait NotObjectSafe { fn eq(&self, other: Self); }\n-impl NotObjectSafe for NotObjectSafe { } //~ ERROR E0372\n+trait NotObjectSafe { fn eq(&self, other: &Self); }\n+impl NotObjectSafe for NotObjectSafe {  //~ ERROR E0372\n+    fn eq(&self, other: &Self) { panic!(); }\n+}\n \n fn main() { }"}, {"sha": "9c210c132a3131084733aead1eabdf7b34870d8c", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -28,8 +28,6 @@ impl Copy for MyType {}\n \n impl Copy for &'static mut MyType {}\n //~^ ERROR E0206\n-//~| ERROR E0277\n-//~| ERROR E0277\n impl Clone for MyType { fn clone(&self) -> Self { *self } }\n \n impl Copy for (MyType, MyType) {}\n@@ -42,8 +40,6 @@ impl Copy for &'static NotSync {}\n impl Copy for [MyType] {}\n //~^ ERROR E0206\n //~| ERROR E0117\n-//~| ERROR E0277\n-//~| ERROR E0277\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR E0206"}, {"sha": "167067cb5fc0aec45ac48d9c282b1f5703875bbb", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -30,7 +30,6 @@ impl Sized for (MyType, MyType) {} //~ ERROR E0117\n impl Sized for &'static NotSync {} //~ ERROR E0322\n \n impl Sized for [MyType] {} //~ ERROR E0117\n-//~^ ERROR E0277\n \n impl Sized for &'static [NotSync] {} //~ ERROR E0117\n "}, {"sha": "3b0f8ee5bda7ac041e72feadd4105ae706e96766", "filename": "src/test/compile-fail/duplicate-type-parameter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -33,6 +33,7 @@ trait Qux<T,T> {}\n \n impl<T,T> Qux<T,T> for Option<T> {}\n //~^ ERROR the name `T` is already used\n+//~^^ ERROR the type parameter `T` is not constrained\n \n fn main() {\n }"}, {"sha": "56b681378cc9daf1141d41845dc302ee66d33463", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -10,7 +10,7 @@\n \n // see #9186\n \n-enum Bar<T> { What }\n+enum Bar<T> { What } //~ ERROR parameter `T` is never used\n \n fn foo<T>() {\n     static a: Bar<T> = Bar::What;"}, {"sha": "33fbdce4ee25a2b50fd3a4474bc31c840ccd7879", "filename": "src/test/compile-fail/issue-12796.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n trait Trait {\n-    fn outer(self) {\n-        fn inner(_: Self) {\n+    fn outer(&self) {\n+        fn inner(_: &Self) {\n             //~^ ERROR can't use type parameters from outer function\n             //~^^ ERROR use of `Self` outside of an impl or trait\n         }"}, {"sha": "5f8ccd0b0634ee22b1c9e313b319a74f2cdedd25", "filename": "src/test/compile-fail/issue-14254.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -11,7 +11,7 @@\n trait Foo {\n     fn bar(&self);\n     fn baz(&self) { }\n-    fn bah(_: Option<Self>) { }\n+    fn bah(_: Option<&Self>) { }\n }\n \n struct BarTy {"}, {"sha": "7ec3093a6e0588533f7d2ee4844d03b7ae60b044", "filename": "src/test/compile-fail/issue-19883.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -14,7 +14,7 @@ trait From<Src> {\n     fn from(src: Src) -> <Self as From<Src>>::Output;\n }\n \n-trait To {\n+trait To: Sized {\n     fn to<Dst: From<Self>>(self) ->\n         <Dst as From<Self>>::Dst\n         //~^ ERROR use of undeclared associated type `From::Dst`"}, {"sha": "99dd22a888cb56508f759f0a2183cfe23354200e", "filename": "src/test/compile-fail/issue-20427.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -62,7 +62,7 @@ fn usize<'usize>(usize: &'usize usize) -> &'usize usize { usize }\n fn main() {\n     let bool = true;\n     match bool {\n-        str @ true => if str { i32 as i64 } else { 0 },\n+        str @ true => if str { i32 as i64 } else { i64 },\n         false => i64,\n-    }\n+    };\n }"}, {"sha": "68f053c357bed341e4f2742b046f5288b3888ad0", "filename": "src/test/compile-fail/issue-23305.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -13,5 +13,6 @@ pub trait ToNbt<T> {\n }\n \n impl ToNbt<Self> {} //~ ERROR use of `Self` outside of an impl or trait\n+//~^ WARNING the trait `ToNbt` cannot be made into an object\n \n fn main() {}"}, {"sha": "6b81afe13c671d5fca639f058b7c8fdc4ada1e03", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait Groom {\n-    fn shave();\n+    fn shave(other: usize);\n }\n \n pub struct cat {\n@@ -30,7 +30,7 @@ impl MaybeDog {\n }\n \n impl Groom for cat {\n-  fn shave(&self, other: usize) {\n+  fn shave(other: usize) {\n     whiskers -= other;\n     //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n     shave(4);"}, {"sha": "0d372d300154af67727e1e7e9ec102df9896dec1", "filename": "src/test/compile-fail/issue-28109.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -11,10 +11,12 @@\n // Make sure that label for continue and break is spanned correctly\n \n fn main() {\n-    continue\n-    'b //~ ERROR use of undeclared label\n-    ;\n-    break\n-    'c //~ ERROR use of undeclared label\n-    ;\n+    loop {\n+        continue\n+        'b //~ ERROR use of undeclared label\n+        ;\n+        break\n+        'c //~ ERROR use of undeclared label\n+        ;\n+    }\n }"}, {"sha": "ecc8ac34ecf2ba5f45cc5cf2c47805a385eed093", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -13,13 +13,13 @@ trait siphash {\n     fn reset(&self);\n }\n \n-fn siphash(k0 : u64, k1 : u64) -> siphash {\n+fn siphash(k0 : u64, k1 : u64) {\n     struct SipState {\n         v0: u64,\n         v1: u64,\n     }\n \n-    fn mk_result(st : SipState) -> u64 {\n+    fn mk_result(st : &SipState) -> u64 {\n \n         let v0 = st.v0;\n         let v1 = st.v1;"}, {"sha": "7cf772b0728795334680a6b3ff01c68e27447623", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -12,7 +12,7 @@ trait SipHash {\n     fn reset(&self);\n }\n \n-fn siphash(k0 : u64) -> SipHash {\n+fn siphash(k0 : u64) {\n     struct SipState {\n         v0: u64,\n     }"}, {"sha": "27b7fb752750347690c63ac7189b8245a7b54db7", "filename": "src/test/compile-fail/issue-3214.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -15,6 +15,8 @@ fn foo<T>() {\n     }\n \n     impl<T> Drop for foo<T> {\n+        //~^ ERROR wrong number of type arguments\n+        //~^^ ERROR the type parameter `T` is not constrained\n         fn drop(&mut self) {}\n     }\n }"}, {"sha": "34cd8cae2de32a64a3255c45b05354428b7c5910", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -16,6 +16,7 @@ fn main() {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n         //~| ERROR unresolved name `foo`\n+        //~^^^ ERROR constant evaluation error: non-constant path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "1fda423e9ee8d37ab30f2bafef90a2312ededdcd", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -30,5 +30,7 @@ impl ToString_ for Point {\n \n fn main() {\n     let p = Point::new(0.0, 0.0);\n+    //~^ ERROR no associated item named `new` found for type `Point` in the current scope\n     println!(\"{}\", p.to_string());\n+    //~^ ERROR the type of this value must be known in this context\n }"}, {"sha": "e5f091d873df9c1384207472e4f6061713bf5152", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -9,12 +9,10 @@\n // except according to those terms.\n \n \n-\n-// error-pattern:unresolved enum variant\n-\n fn main() {\n     let z = match 3 {\n-        x(1) => x(1)\n+        x(1) => x(1) //~ ERROR unresolved enum variant\n+        //~^ ERROR unresolved name `x`\n     };\n-    assert_eq!(z,3);\n+    assert!(z == 3);\n }"}, {"sha": "f53122d19c1bd8bc25912ca75332e2a943bc7f2d", "filename": "src/test/compile-fail/issue-9725.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -13,4 +13,5 @@ struct A { foo: isize }\n fn main() {\n     let A { foo, foo } = A { foo: 3 };\n     //~^ ERROR: identifier `foo` is bound more than once in the same pattern\n+    //~^^ ERROR: field `foo` bound multiple times\n }"}, {"sha": "f8ea5dda183366df38ecfa9544f08d21d4406a97", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -13,5 +13,5 @@\n mod mod_file_aux;\n \n fn main() {\n-    assert_eq!(mod_file_aux::bar(), 10); //~ ERROR unresolved name\n+    assert!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n }"}, {"sha": "bc18b52a0c1c9e3f8fdfd0f65994e4e2e0daf464", "filename": "src/test/compile-fail/opt-in-copy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -16,7 +16,6 @@ struct IWantToCopyThis {\n \n impl Copy for IWantToCopyThis {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| ERROR E0277\n \n enum CantCopyThisEither {\n     A,\n@@ -29,6 +28,5 @@ enum IWantToCopyThisToo {\n \n impl Copy for IWantToCopyThisToo {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| ERROR E0277\n \n fn main() {}"}, {"sha": "284c08ef09b28fa4c475ab575af71d706fce72db", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -16,6 +16,7 @@ fn matcher1(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }\n@@ -24,6 +25,7 @@ fn matcher2(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }\n@@ -32,6 +34,7 @@ fn matcher4(x: opts) {\n     match x {\n       opts::a(ref mut i) | opts::b(ref i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }"}, {"sha": "88f09233d107ee07f5f9079220fd2dcaef924ebe", "filename": "src/test/compile-fail/resolve-type-param-in-item-in-trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -15,6 +15,7 @@\n trait TraitA<A> {\n     fn outer(self) {\n         enum Foo<B> {\n+            //~^ ERROR parameter `B` is never used\n             Variance(A)\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n@@ -27,6 +28,7 @@ trait TraitB<A> {\n         struct Foo<B>(A);\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n+                //~^^^ ERROR parameter `B` is never used\n     }\n }\n \n@@ -35,6 +37,7 @@ trait TraitC<A> {\n         struct Foo<B> { a: A }\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n+                //~^^^ ERROR parameter `B` is never used\n     }\n }\n "}, {"sha": "38a6834a9c46034772d41ffd94c7bebd76cabac3", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -14,7 +14,7 @@\n \n pub fn main() {\n     let asdf_fdsa = \"<.<\".to_string();\n-    assert_eq!(concat_idents!(asd, f_f, dsa), \"<.<\".to_string());\n+    assert!(concat_idents!(asd, f_f, dsa) == \"<.<\".to_string());\n     //~^ ERROR: unresolved name `asdf_fdsa`\n \n     assert_eq!(stringify!(use_mention_distinction), \"use_mention_distinction\");"}, {"sha": "f30c8f521bdc75b919c2dccbbeefa1c8d5cf8853", "filename": "src/test/compile-fail/trait-safety-trait-impl-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -18,7 +18,7 @@ extern crate trait_safety_lib as lib;\n struct Bar;\n impl lib::Foo for Bar { //~ ERROR requires an `unsafe impl` declaration\n     fn foo(&self) -> isize {\n-        *self as isize\n+        panic!();\n     }\n }\n "}, {"sha": "e846b660c2a175f3380f5621feb580ecbe066bce", "filename": "src/test/compile-fail/trait-safety-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee24bddfc51df686c72d3a3ed52611209c655850/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs?ref=ee24bddfc51df686c72d3a3ed52611209c655850", "patch": "@@ -12,11 +12,11 @@\n // impls cannot be unsafe.\n \n trait SafeTrait {\n-    fn foo(self) { }\n+    fn foo(&self) { }\n }\n \n unsafe trait UnsafeTrait {\n-    fn foo(self) { }\n+    fn foo(&self) { }\n }\n \n unsafe impl UnsafeTrait for u8 { } // OK"}]}