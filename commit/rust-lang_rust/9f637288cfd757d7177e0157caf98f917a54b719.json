{"sha": "9f637288cfd757d7177e0157caf98f917a54b719", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNjM3Mjg4Y2ZkNzU3ZDcxNzdlMDE1N2NhZjk4ZjkxN2E1NGI3MTk=", "commit": {"author": {"name": "Maxwell Anderson", "email": "maxwell.brayden.anderson@gmail.com", "date": "2018-10-18T21:45:05Z"}, "committer": {"name": "Maxwell Anderson", "email": "maxwell.brayden.anderson@gmail.com", "date": "2018-10-18T21:45:05Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "e3752814ae24094b55abe39200f038b85433a20d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3752814ae24094b55abe39200f038b85433a20d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f637288cfd757d7177e0157caf98f917a54b719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f637288cfd757d7177e0157caf98f917a54b719", "html_url": "https://github.com/rust-lang/rust/commit/9f637288cfd757d7177e0157caf98f917a54b719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f637288cfd757d7177e0157caf98f917a54b719/comments", "author": {"login": "Zaechus", "id": 19353212, "node_id": "MDQ6VXNlcjE5MzUzMjEy", "avatar_url": "https://avatars.githubusercontent.com/u/19353212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zaechus", "html_url": "https://github.com/Zaechus", "followers_url": "https://api.github.com/users/Zaechus/followers", "following_url": "https://api.github.com/users/Zaechus/following{/other_user}", "gists_url": "https://api.github.com/users/Zaechus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zaechus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zaechus/subscriptions", "organizations_url": "https://api.github.com/users/Zaechus/orgs", "repos_url": "https://api.github.com/users/Zaechus/repos", "events_url": "https://api.github.com/users/Zaechus/events{/privacy}", "received_events_url": "https://api.github.com/users/Zaechus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zaechus", "id": 19353212, "node_id": "MDQ6VXNlcjE5MzUzMjEy", "avatar_url": "https://avatars.githubusercontent.com/u/19353212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zaechus", "html_url": "https://github.com/Zaechus", "followers_url": "https://api.github.com/users/Zaechus/followers", "following_url": "https://api.github.com/users/Zaechus/following{/other_user}", "gists_url": "https://api.github.com/users/Zaechus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zaechus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zaechus/subscriptions", "organizations_url": "https://api.github.com/users/Zaechus/orgs", "repos_url": "https://api.github.com/users/Zaechus/repos", "events_url": "https://api.github.com/users/Zaechus/events{/privacy}", "received_events_url": "https://api.github.com/users/Zaechus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63fbeaab68065019bbe17e68bb5f54ff997ef2ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/63fbeaab68065019bbe17e68bb5f54ff997ef2ed", "html_url": "https://github.com/rust-lang/rust/commit/63fbeaab68065019bbe17e68bb5f54ff997ef2ed"}, {"sha": "8f5a2484a05448dc7e19f8711a965fa5f232f0c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5a2484a05448dc7e19f8711a965fa5f232f0c1", "html_url": "https://github.com/rust-lang/rust/commit/8f5a2484a05448dc7e19f8711a965fa5f232f0c1"}], "stats": {"total": 1750, "additions": 1440, "deletions": 310}, "files": [{"sha": "818353e0c1607291d857e587c088db85ba9859de", "filename": ".travis.yml", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -5,6 +5,7 @@ rust: nightly\n os:\n   - linux\n   - osx\n+  - windows\n \n sudo: false\n \n@@ -24,10 +25,15 @@ before_install:\n install:\n   - |\n     if [ -z ${INTEGRATION} ]; then\n-      . $HOME/.nvm/nvm.sh\n-      nvm install stable\n-      nvm use stable\n-      npm install remark-cli remark-lint\n+      if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then\n+        . $HOME/.nvm/nvm.sh\n+        nvm install stable\n+        nvm use stable\n+        npm install remark-cli remark-lint\n+      fi\n+      if [ \"$TRAVIS_OS_NAME\" == \"windows\" ]; then\n+        choco install windows-sdk-10.0\n+      fi\n     fi\n \n matrix:\n@@ -36,6 +42,8 @@ matrix:\n       env: BASE_TESTS=true\n     - os: linux\n       env: BASE_TESTS=true\n+    - os: windows\n+      env: BASE_TEST=true\n     - env: INTEGRATION=rust-lang/cargo\n     - env: INTEGRATION=rust-lang-nursery/rand\n     - env: INTEGRATION=rust-lang-nursery/stdsimd\n@@ -49,10 +57,14 @@ matrix:\n     - env: INTEGRATION=serde-rs/serde\n     - env: INTEGRATION=Geal/nom\n     - env: INTEGRATION=hyperium/hyper\n+  allow_failures:\n+  - os: windows\n+    env: BASE_TEST=true\n # prevent these jobs with default env vars\n   exclude:\n     - os: linux\n     - os: osx\n+    - os: windows\n \n script:\n   - |"}, {"sha": "626c39457e206fea0b314fb57a0eef6dc7e38d23", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -816,6 +816,7 @@ All notable changes to this project will be documented in this file.\n [`redundant_closure_call`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_field_names`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_field_names\n [`redundant_pattern`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_pattern\n+[`redundant_pattern_matching`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n [`ref_in_deref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#ref_in_deref\n [`regex_macro`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#regex_macro\n [`replace_consts`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#replace_consts\n@@ -878,6 +879,7 @@ All notable changes to this project will be documented in this file.\n [`unused_collect`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_unit`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unused_unit\n [`use_debug`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#use_self\n [`used_underscore_binding`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#used_underscore_binding"}, {"sha": "d32f66b5957417b9280fb4db7db9680bc70ff272", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 279 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 280 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n \n@@ -24,6 +24,15 @@ We have a bunch of lint categories to allow you to choose how much Clippy is sup\n \n More to come, please [file an issue](https://github.com/rust-lang-nursery/rust-clippy/issues) if you have ideas!\n \n+Only the following of those categories are enabled by default:\n+\n+* `clippy::style`\n+* `clippy::correctness`\n+* `clippy::complexity`\n+* `clippy::perf`\n+\n+Other categories need to be enabled in order for their lints to be executed.\n+\n Table of contents:\n \n *   [Usage instructions](#usage)"}, {"sha": "72a38ee5e586c3ce010c40a1a6460363a268c0d7", "filename": "ci/base-tests.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -14,7 +14,9 @@ set -ex\n echo \"Running clippy base tests\"\n \n PATH=$PATH:./node_modules/.bin\n-remark -f *.md > /dev/null\n+if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then\n+  remark -f *.md > /dev/null\n+fi\n # build clippy in debug mode and run tests\n cargo build --features debugging\n cargo test --features debugging"}, {"sha": "5380ecd9814eaa6694d701342e56f3a0464e3595", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -9,3 +9,4 @@ clap = \"~2.32\"\n itertools = \"0.7\"\n regex = \"1\"\n lazy_static = \"1.0\"\n+walkdir = \"2\""}, {"sha": "773512333815e2104e7f8bfab49c0d212e7dbddc", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 167, "deletions": 10, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -14,6 +14,7 @@\n use itertools::Itertools;\n use lazy_static::lazy_static;\n use regex::Regex;\n+use walkdir::WalkDir;\n use std::collections::HashMap;\n use std::ffi::OsStr;\n use std::fs;\n@@ -35,6 +36,7 @@ lazy_static! {\n     pub static ref DOCS_LINK: String = \"https://rust-lang-nursery.github.io/rust-clippy/master/index.html\".to_string();\n }\n \n+/// Lint data parsed from the Clippy source code.\n #[derive(Clone, PartialEq, Debug)]\n pub struct Lint {\n     pub name: String,\n@@ -55,22 +57,39 @@ impl Lint {\n         }\n     }\n \n-    /// Returns all non-deprecated lints\n-    pub fn active_lints(lints: impl Iterator<Item=Self>) -> impl Iterator<Item=Self> {\n-        lints.filter(|l| l.deprecation.is_none())\n+    /// Returns all non-deprecated lints and non-internal lints\n+    pub fn usable_lints(lints: impl Iterator<Item=Self>) -> impl Iterator<Item=Self> {\n+        lints.filter(|l| l.deprecation.is_none() && !l.is_internal())\n     }\n \n     /// Returns the lints in a HashMap, grouped by the different lint groups\n     pub fn by_lint_group(lints: &[Self]) -> HashMap<String, Vec<Self>> {\n         lints.iter().map(|lint| (lint.group.to_string(), lint.clone())).into_group_map()\n     }\n+\n+    pub fn is_internal(&self) -> bool {\n+        self.group.starts_with(\"internal\")\n+    }\n+}\n+\n+pub fn gen_changelog_lint_list(lints: Vec<Lint>) -> Vec<String> {\n+    let mut lint_list_sorted: Vec<Lint> = lints;\n+    lint_list_sorted.sort_by_key(|l| l.name.clone());\n+    lint_list_sorted\n+        .iter()\n+        .filter(|l| !l.is_internal())\n+        .map(|l| {\n+            format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK.clone(), l.name)\n+        })\n+        .collect()\n }\n \n+/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n pub fn gather_all() -> impl Iterator<Item=Lint> {\n     lint_files().flat_map(|f| gather_from_file(&f))\n }\n \n-fn gather_from_file(dir_entry: &fs::DirEntry) -> impl Iterator<Item=Lint> {\n+fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item=Lint> {\n     let mut file = fs::File::open(dir_entry.path()).unwrap();\n     let mut content = String::new();\n     file.read_to_string(&mut content).unwrap();\n@@ -89,13 +108,98 @@ fn parse_contents(content: &str, filename: &str) -> impl Iterator<Item=Lint> {\n }\n \n /// Collects all .rs files in the `clippy_lints/src` directory\n-fn lint_files() -> impl Iterator<Item=fs::DirEntry> {\n-    fs::read_dir(\"../clippy_lints/src\")\n-        .unwrap()\n+fn lint_files() -> impl Iterator<Item=walkdir::DirEntry> {\n+    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n+    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n+    WalkDir::new(\"../clippy_lints/src\")\n+        .into_iter()\n         .filter_map(|f| f.ok())\n         .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n }\n \n+/// Replace a region in a file delimited by two lines matching regexes.\n+///\n+/// `path` is the relative path to the file on which you want to perform the replacement.\n+///\n+/// See `replace_region_in_text` for documentation of the other options.\n+#[allow(clippy::expect_fun_call)]\n+pub fn replace_region_in_file<F>(path: &str, start: &str, end: &str, replace_start: bool, replacements: F) where F: Fn() -> Vec<String> {\n+    let mut f = fs::File::open(path).expect(&format!(\"File not found: {}\", path));\n+    let mut contents = String::new();\n+    f.read_to_string(&mut contents).expect(\"Something went wrong reading the file\");\n+    let replaced = replace_region_in_text(&contents, start, end, replace_start, replacements);\n+\n+    let mut f = fs::File::create(path).expect(&format!(\"File not found: {}\", path));\n+    f.write_all(replaced.as_bytes()).expect(\"Unable to write file\");\n+    // Ensure we write the changes with a trailing newline so that\n+    // the file has the proper line endings.\n+    f.write_all(b\"\\n\").expect(\"Unable to write file\");\n+}\n+\n+/// Replace a region in a text delimited by two lines matching regexes.\n+///\n+/// * `text` is the input text on which you want to perform the replacement\n+/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n+///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * `end` is a `&str` that describes the delimiter line until where the replacement should\n+///   happen.  As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * If `replace_start` is true, the `start` delimiter line is replaced as well.\n+///   The `end` delimiter line is never replaced.\n+/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n+///\n+/// If you want to perform the replacement on files instead of already parsed text,\n+/// use `replace_region_in_file`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n+/// let result = clippy_dev::replace_region_in_text(\n+///     the_text,\n+///     r#\"replace_start\"#,\n+///     r#\"replace_end\"#,\n+///     false,\n+///     || {\n+///         vec![\"a different\".to_string(), \"text\".to_string()]\n+///     }\n+/// );\n+/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n+/// ```\n+pub fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> String where F: Fn() -> Vec<String> {\n+    let lines = text.lines();\n+    let mut in_old_region = false;\n+    let mut found = false;\n+    let mut new_lines = vec![];\n+    let start = Regex::new(start).unwrap();\n+    let end = Regex::new(end).unwrap();\n+\n+    for line in lines {\n+        if in_old_region {\n+            if end.is_match(&line) {\n+                in_old_region = false;\n+                new_lines.extend(replacements());\n+                new_lines.push(line.to_string());\n+            }\n+        } else if start.is_match(&line) {\n+            if !replace_start {\n+                new_lines.push(line.to_string());\n+            }\n+            in_old_region = true;\n+            found = true;\n+        } else {\n+            new_lines.push(line.to_string());\n+        }\n+    }\n+\n+    if !found {\n+        // This happens if the provided regex in `clippy_dev/src/main.rs` is not found in the\n+        // given text or file. Most likely this is an error on the programmer's side and the Regex\n+        // is incorrect.\n+        println!(\"regex {:?} not found. You may have to update it.\", start);\n+    }\n+    new_lines.join(\"\\n\")\n+}\n+\n #[test]\n fn test_parse_contents() {\n     let result: Vec<Lint> = parse_contents(\n@@ -136,15 +240,54 @@ declare_deprecated_lint! {\n }\n \n #[test]\n-fn test_active_lints() {\n+fn test_replace_region() {\n+    let text = r#\"\n+abc\n+123\n+789\n+def\n+ghi\"#;\n+    let expected = r#\"\n+abc\n+hello world\n+def\n+ghi\"#;\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region_with_start() {\n+    let text = r#\"\n+abc\n+123\n+789\n+def\n+ghi\"#;\n+    let expected = r#\"\n+hello world\n+def\n+ghi\"#;\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_usable_lints() {\n     let lints = vec![\n         Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\")\n+        Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\")\n     ];\n     let expected = vec![\n         Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\")\n     ];\n-    assert_eq!(expected, Lint::active_lints(lints.into_iter()).collect::<Vec<Lint>>());\n+    assert_eq!(expected, Lint::usable_lints(lints.into_iter()).collect::<Vec<Lint>>());\n }\n \n #[test]\n@@ -164,3 +307,17 @@ fn test_by_lint_group() {\n     ]);\n     assert_eq!(expected, Lint::by_lint_group(&lints));\n }\n+\n+#[test]\n+fn test_gen_changelog_lint_list() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"incorrect_internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![\n+        format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK.to_string()),\n+        format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK.to_string())\n+    ];\n+    assert_eq!(expected, gen_changelog_lint_list(lints));\n+}"}, {"sha": "8769ee6b8103eb9b7a4e69f072f48f7893b6b6e6", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -32,24 +32,54 @@ fn main() {\n     if let Some(matches) = matches.subcommand_matches(\"update_lints\") {\n         if matches.is_present(\"print-only\") {\n             print_lints();\n+        } else {\n+            update_lints();\n         }\n     }\n }\n \n fn print_lints() {\n-    let lint_list = gather_all().collect::<Vec<Lint>>();\n-    let grouped_by_lint_group = Lint::by_lint_group(&lint_list);\n+    let lint_list = gather_all();\n+    let usable_lints: Vec<Lint> = Lint::usable_lints(lint_list).collect();\n+    let lint_count = usable_lints.len();\n+    let grouped_by_lint_group = Lint::by_lint_group(&usable_lints);\n \n     for (lint_group, mut lints) in grouped_by_lint_group {\n         if lint_group == \"Deprecated\" { continue; }\n         println!(\"\\n## {}\", lint_group);\n \n-        lints.sort_by(|a, b| a.name.cmp(&b.name));\n+        lints.sort_by_key(|l| l.name.clone());\n \n         for lint in lints {\n             println!(\"* [{}]({}#{}) ({})\", lint.name, clippy_dev::DOCS_LINK.clone(), lint.name, lint.desc);\n         }\n     }\n \n-    println!(\"there are {} lints\", Lint::active_lints(lint_list.into_iter()).count());\n+    println!(\"there are {} lints\", lint_count);\n+}\n+\n+fn update_lints() {\n+    let lint_list: Vec<Lint> = gather_all().collect();\n+    let usable_lints: Vec<Lint> = Lint::usable_lints(lint_list.clone().into_iter()).collect();\n+    let lint_count = usable_lints.len();\n+\n+    replace_region_in_file(\n+        \"../README.md\",\n+        r#\"\\[There are \\d+ lints included in this crate!\\]\\(https://rust-lang-nursery.github.io/rust-clippy/master/index.html\\)\"#,\n+        \"\",\n+        true,\n+        || {\n+            vec![\n+                format!(\"[There are {} lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\", lint_count)\n+            ]\n+        }\n+    );\n+\n+    replace_region_in_file(\n+        \"../CHANGELOG.md\",\n+        \"<!-- begin autogenerated links to lint list -->\",\n+        \"<!-- end autogenerated links to lint list -->\",\n+        false,\n+        || { gen_changelog_lint_list(lint_list.clone()) }\n+    );\n }"}, {"sha": "ed97cc45725dc75e25a33f2d23c2a7f8d1913ac7", "filename": "clippy_dummy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dummy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_dummy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dummy%2FCargo.toml?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"clippy\" # rename to clippy before publishing\n+name = \"clippy_dummy\" # rename to clippy before publishing\n version = \"0.0.302\"\n authors = [\"Manish Goregaokar <manishsmail@gmail.com>\"]\n edition = \"2018\""}, {"sha": "a55ca04f706a78272750f872dd12c0abd564dcc4", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -112,9 +112,17 @@ fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     }\n }\n \n+fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n+    // We trim all opening braces and whitespaces and then check if the next string is a comment.\n+    let trimmed_block_text =\n+        snippet_block(cx, expr.span, \"..\").trim_left_matches(|c: char| c.is_whitespace() || c == '{').to_owned();\n+    trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n+}\n+\n fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.node;\n+        if !block_starts_with_comment(cx, block);\n         if let Some(else_) = expr_block(block);\n         if !in_macro(else_.span);\n         then {\n@@ -135,6 +143,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n \n fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_chain! {\n+        if !block_starts_with_comment(cx, then);\n         if let Some(inner) = expr_block(then);\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;\n         then {"}, {"sha": "904036fe8886b4d4bd2e11dc4e362d9e3c2247f9", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -16,7 +16,7 @@ macro_rules! declare_deprecated_lint {\n \n /// **What it does:** Nothing. This lint has been deprecated.\n ///\n-/// **Deprecation reason:** This used to check for `assert!(a == b)` and recommend \n+/// **Deprecation reason:** This used to check for `assert!(a == b)` and recommend\n /// replacement with `assert_eq!(a, b)`, but this is no longer needed after RFC 2011.\n declare_deprecated_lint! {\n     pub SHOULD_ASSERT_EQ,\n@@ -102,3 +102,13 @@ declare_deprecated_lint! {\n     pub ASSIGN_OPS,\n     \"using compound assignment operators (e.g. `+=`) is harmless\"\n }\n+\n+/// **What it does:** Nothing. This lint has been deprecated.\n+///\n+/// **Deprecation reason:** The original rule will only lint for `if let`. After\n+/// making it support to lint `match`, naming as `if let` is not suitable for it.\n+/// So, this lint is deprecated.\n+declare_deprecated_lint! {\n+    pub IF_LET_REDUNDANT_PATTERN_MATCHING,\n+    \"this lint has been changed to redundant_pattern_matching\"\n+}"}, {"sha": "0171ac1e784f08f94aea51843fbfaed12e7f96fc", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -40,15 +40,16 @@ declare_clippy_lint! {\n     \"unnecessary double comparisons that can be simplified\"\n }\n \n-pub struct DoubleComparisonPass;\n+pub struct Pass;\n \n-impl LintPass for DoubleComparisonPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DOUBLE_COMPARISONS)\n     }\n }\n \n-impl<'a, 'tcx> DoubleComparisonPass {\n+impl<'a, 'tcx> Pass {\n+    #[allow(clippy::similar_names)]\n     fn check_binop(\n         &self,\n         cx: &LateContext<'a, 'tcx>,\n@@ -87,7 +88,7 @@ impl<'a, 'tcx> DoubleComparisonPass {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisonPass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.node {\n             self.check_binop(cx, kind.node, lhs, rhs, expr.span);"}, {"sha": "315bc54cd17931e9a8c6a4ead314b0306e0a8be4", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -63,16 +63,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 let variant = &var.node;\n                 if let Some(ref anon_const) = variant.disr_expr {\n                     let param_env = ty::ParamEnv::empty();\n-                    let did = cx.tcx.hir.body_owner_def_id(anon_const.body);\n-                    let substs = Substs::identity_for_item(cx.tcx.global_tcx(), did);\n-                    let instance = ty::Instance::new(did, substs);\n-                    let cid = GlobalId {\n+                    let def_id = cx.tcx.hir.body_owner_def_id(anon_const.body);\n+                    let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n+                    let instance = ty::Instance::new(def_id, substs);\n+                    let c_id = GlobalId {\n                         instance,\n                         promoted: None\n                     };\n-                    let constant = cx.tcx.const_eval(param_env.and(cid)).ok();\n+                    let constant = cx.tcx.const_eval(param_env.and(c_id)).ok();\n                     if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n-                        let mut ty = cx.tcx.type_of(did);\n+                        let mut ty = cx.tcx.type_of(def_id);\n                         if let ty::Adt(adt, _) = ty.sty {\n                             if adt.is_enum() {\n                                 ty = adt.repr.discr_type().to_ty(cx.tcx);"}, {"sha": "16d1e40484d0b7507923df7ab620d10208c22805", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -16,7 +16,7 @@ use crate::syntax::ast::*;\n use crate::syntax::source_map::Span;\n use crate::syntax::symbol::LocalInternedString;\n use crate::utils::{span_help_and_lint, span_lint};\n-use crate::utils::{camel_case_from, camel_case_until, in_macro};\n+use crate::utils::{camel_case, in_macro};\n \n /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n /// by the same characters.\n@@ -184,19 +184,19 @@ fn check_variant(\n         }\n     }\n     let first = var2str(&def.variants[0]);\n-    let mut pre = &first[..camel_case_until(&*first)];\n-    let mut post = &first[camel_case_from(&*first)..];\n+    let mut pre = &first[..camel_case::until(&*first)];\n+    let mut post = &first[camel_case::from(&*first)..];\n     for var in &def.variants {\n         let name = var2str(var);\n \n         let pre_match = partial_match(pre, &name);\n         pre = &pre[..pre_match];\n-        let pre_camel = camel_case_until(pre);\n+        let pre_camel = camel_case::until(pre);\n         pre = &pre[..pre_camel];\n         while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n             if next.is_lowercase() {\n                 let last = pre.len() - last.len_utf8();\n-                let last_camel = camel_case_until(&pre[..last]);\n+                let last_camel = camel_case::until(&pre[..last]);\n                 pre = &pre[..last_camel];\n             } else {\n                 break;\n@@ -206,7 +206,7 @@ fn check_variant(\n         let post_match = partial_rmatch(post, &name);\n         let post_end = post.len() - post_match;\n         post = &post[post_end..];\n-        let post_camel = camel_case_from(post);\n+        let post_camel = camel_case::from(post);\n         post = &post[post_camel..];\n     }\n     let (what, value) = match (pre.is_empty(), post.is_empty()) {\n@@ -255,6 +255,7 @@ impl EarlyLintPass for EnumVariantNames {\n         assert!(last.is_some());\n     }\n \n+    #[allow(clippy::similar_names)]\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         let item_name = item.ident.as_str();\n         let item_name_chars = item_name.chars().count();"}, {"sha": "dfe0c0180a77ab89d575832efeb6cc503e20a899", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -63,6 +63,7 @@ impl LintPass for EqOp {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n+    #[allow(clippy::similar_names)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::Binary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {"}, {"sha": "b7646dd6fdf3e08077d3e71359eb201a5ed4a489", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -65,6 +65,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n@@ -74,13 +75,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         node_id: NodeId,\n     ) {\n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+        // If the method is an impl for a trait, don't warn\n+        let parent_id = cx.tcx.hir.get_parent(node_id);\n+        let parent_node = cx.tcx.hir.find(parent_id);\n+\n+        if let Some(Node::Item(item)) = parent_node {\n+            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n+                return;\n+            }\n+        }\n+\n         let mut v = EscapeDelegate {\n             cx,\n             set: NodeSet(),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n+        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n         ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).consume_body(body);\n "}, {"sha": "15a8d47337aadd3f917f3ed181b4d6992835b0b7", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -108,6 +108,7 @@ impl ExcessivePrecision {\n     }\n }\n \n+#[allow(clippy::doc_markdown)]\n /// Should we exclude the float because it has a `.0` or `.` suffix\n /// Ex 1_000_000_000.0\n /// Ex 1_000_000_000."}, {"sha": "8b42eaa528e7f6fb2ab4e6e2feb3a57a21bd863a", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/63fbeaab68065019bbe17e68bb5f54ff997ef2ed/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbeaab68065019bbe17e68bb5f54ff997ef2ed/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=63fbeaab68065019bbe17e68bb5f54ff997ef2ed", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n-use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n-use crate::rustc_errors::Applicability;\n-\n-/// **What it does:** Lint for redundant pattern matching over `Result` or\n-/// `Option`\n-///\n-/// **Why is this bad?** It's more concise and clear to just use the proper\n-/// utility function\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// if let Ok(_) = Ok::<i32, i32>(42) {}\n-/// if let Err(_) = Err::<i32, i32>(42) {}\n-/// if let None = None::<()> {}\n-/// if let Some(_) = Some(42) {}\n-/// ```\n-///\n-/// The more idiomatic use would be:\n-///\n-/// ```rust\n-/// if Ok::<i32, i32>(42).is_ok() {}\n-/// if Err::<i32, i32>(42).is_err() {}\n-/// if None::<()>.is_none() {}\n-/// if Some(42).is_some() {}\n-/// ```\n-///\n-declare_clippy_lint! {\n-    pub IF_LET_REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Pass;\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(IF_LET_REDUNDANT_PATTERN_MATCHING)\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n-            if arms[0].pats.len() == 1 {\n-                let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n-                        if let PatKind::Wild = pats[0].node {\n-                            if match_qpath(path, &paths::RESULT_OK) {\n-                                \"is_ok()\"\n-                            } else if match_qpath(path, &paths::RESULT_ERR) {\n-                                \"is_err()\"\n-                            } else if match_qpath(path, &paths::OPTION_SOME) {\n-                                \"is_some()\"\n-                            } else {\n-                                return;\n-                            }\n-                        } else {\n-                            return;\n-                        }\n-                    },\n-\n-                    PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n-\n-                    _ => return,\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    IF_LET_REDUNDANT_PATTERN_MATCHING,\n-                    arms[0].pats[0].span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |db| {\n-                        let span = expr.span.to(op.span);\n-                        db.span_suggestion_with_applicability(\n-                            span,\n-                            \"try this\",\n-                            format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "789a569f4cd1ee9d136f119b7535043e5577b79e", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -240,7 +240,7 @@ fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Ex\n                 LEN_ZERO,\n                 span,\n                 &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n-                \"using `is_empty` is more concise\",\n+                \"using `is_empty` is clearer and more explicit\",\n                 format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")),\n             );\n         }\n@@ -276,7 +276,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n         ty::Dynamic(ref tt, ..) => cx.tcx\n-            .associated_items(tt.principal().expect(\"trait impl not found\").def_id())\n+            .associated_items(tt.principal().def_id())\n             .any(|item| is_is_empty(cx, &item)),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),"}, {"sha": "23bd71a08ab64576212afb06bf090244d621c623", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -46,6 +46,8 @@ extern crate syntax_pos;\n \n use toml;\n \n+// Currently, categories \"style\", \"correctness\", \"complexity\" and \"perf\" are enabled by default,\n+// as said in the README.md of this repository. If this changes, please update README.md.\n macro_rules! declare_clippy_lint {\n     { pub $name:tt, style, $description:tt } => {\n         declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n@@ -124,7 +126,6 @@ pub mod formatting;\n pub mod functions;\n pub mod identity_conversion;\n pub mod identity_op;\n-pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n pub mod indexing_slicing;\n pub mod infallible_destructuring_match;\n@@ -178,6 +179,7 @@ pub mod ptr_offset_with_cast;\n pub mod question_mark;\n pub mod ranges;\n pub mod redundant_field_names;\n+pub mod redundant_pattern_matching;\n pub mod reference;\n pub mod regex;\n pub mod replace_consts;\n@@ -301,6 +303,10 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         \"assign_ops\",\n         \"using compound assignment operators (e.g. `+=`) is harmless\",\n     );\n+    store.register_removed(\n+        \"if_let_redundant_pattern_matching\",\n+        \"this lint has been changed to redundant_pattern_matching\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     reg.register_late_lint_pass(box serde_api::Serde);\n@@ -400,7 +406,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box missing_doc::MissingDoc::new());\n     reg.register_late_lint_pass(box missing_inline::MissingInline);\n     reg.register_late_lint_pass(box ok_if_let::Pass);\n-    reg.register_late_lint_pass(box if_let_redundant_pattern_matching::Pass);\n+    reg.register_late_lint_pass(box redundant_pattern_matching::Pass);\n     reg.register_late_lint_pass(box partialeq_ne_impl::Pass);\n     reg.register_early_lint_pass(box reference::Pass);\n     reg.register_early_lint_pass(box reference::DerefPass);\n@@ -428,8 +434,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box fallible_impl_from::FallibleImplFrom);\n     reg.register_late_lint_pass(box replace_consts::ReplaceConsts);\n     reg.register_late_lint_pass(box types::UnitArg);\n-    reg.register_late_lint_pass(box double_comparison::DoubleComparisonPass);\n-    reg.register_late_lint_pass(box question_mark::QuestionMarkPass);\n+    reg.register_late_lint_pass(box double_comparison::Pass);\n+    reg.register_late_lint_pass(box question_mark::Pass);\n     reg.register_late_lint_pass(box suspicious_trait_impl::SuspiciousImpl);\n     reg.register_early_lint_pass(box multiple_crate_versions::Pass);\n     reg.register_late_lint_pass(box map_unit_fn::Pass);\n@@ -563,7 +569,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         functions::TOO_MANY_ARGUMENTS,\n         identity_conversion::IDENTITY_CONVERSION,\n         identity_op::IDENTITY_OP,\n-        if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n         indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n         infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         infinite_iter::INFINITE_ITER,\n@@ -678,13 +683,15 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         ranges::RANGE_PLUS_ONE,\n         ranges::RANGE_ZIP_WITH_LEN,\n         redundant_field_names::REDUNDANT_FIELD_NAMES,\n+        redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         reference::DEREF_ADDROF,\n         reference::REF_IN_DEREF,\n         regex::INVALID_REGEX,\n         regex::REGEX_MACRO,\n         regex::TRIVIAL_REGEX,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n+        returns::UNUSED_UNIT,\n         serde_api::SERDE_API_MISUSE,\n         strings::STRING_LIT_AS_BYTES,\n         suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n@@ -746,7 +753,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         excessive_precision::EXCESSIVE_PRECISION,\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n-        if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n         infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n@@ -797,10 +803,12 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         ptr::PTR_ARG,\n         question_mark::QUESTION_MARK,\n         redundant_field_names::REDUNDANT_FIELD_NAMES,\n+        redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         regex::REGEX_MACRO,\n         regex::TRIVIAL_REGEX,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n+        returns::UNUSED_UNIT,\n         strings::STRING_LIT_AS_BYTES,\n         types::FN_TO_NUMERIC_CAST,\n         types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,"}, {"sha": "9e45757f3f0f5531c9bf932b908f799ea21b8b5c", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -27,10 +27,11 @@ use crate::rustc::ty::subst::Subst;\n use crate::rustc_errors::Applicability;\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::iter::{once, Iterator};\n+use std::mem;\n use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n use crate::syntax_pos::BytePos;\n-use crate::utils::{sugg, sext};\n+use crate::utils::{in_macro, sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n@@ -949,8 +950,20 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                     (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n                     (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n                     (x, false, y, false) => format!(\"({} + {})\", x, y),\n-                    (x, false, y, true) => format!(\"({} - {})\", x, y),\n-                    (x, true, y, false) => format!(\"({} - {})\", y, x),\n+                    (x, false, y, true) => {\n+                        if x == y {\n+                            \"0\".into()\n+                        } else {\n+                            format!(\"({} - {})\", x, y)\n+                        }\n+                    },\n+                    (x, true, y, false) => {\n+                        if x == y {\n+                            \"0\".into()\n+                        } else {\n+                            format!(\"({} - {})\", y, x)\n+                        }\n+                    },\n                     (x, true, y, true) => format!(\"-({} + {})\", x, y),\n                 }\n             };\n@@ -1029,6 +1042,10 @@ fn check_for_loop_range<'a, 'tcx>(\n     body: &'tcx Expr,\n     expr: &'tcx Expr,\n ) {\n+    if in_macro(expr.span) {\n+        return;\n+    }\n+\n     if let Some(higher::Range {\n         start: Some(start),\n         ref end,\n@@ -1082,16 +1099,35 @@ fn check_for_loop_range<'a, 'tcx>(\n                     format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n                 };\n \n+                let mut end_is_start_plus_val = false;\n+\n                 let take = if let Some(end) = *end {\n+                    let mut take_expr = end;\n+\n+                    if let ExprKind::Binary(ref op, ref left, ref right) = end.node {\n+                        if let BinOpKind::Add = op.node {\n+                            let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n+                            let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n+\n+                            if start_equal_left {\n+                                take_expr = right;\n+                            } else if start_equal_right {\n+                                take_expr = left;\n+                            }\n+\n+                            end_is_start_plus_val = start_equal_left | start_equal_right;\n+                        }\n+                    }\n+\n                     if is_len_call(end, indexed) {\n                         String::new()\n                     } else {\n                         match limits {\n                             ast::RangeLimits::Closed => {\n-                                let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                                format!(\".take({})\", end + sugg::ONE)\n+                                let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n+                                format!(\".take({})\", take_expr + sugg::ONE)\n                             },\n-                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, end.span, \"..\")),\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n                         }\n                     }\n                 } else {\n@@ -1104,6 +1140,14 @@ fn check_for_loop_range<'a, 'tcx>(\n                     (\"\", \"iter\")\n                 };\n \n+                let take_is_empty = take.is_empty();\n+                let mut method_1 = take;\n+                let mut method_2 = skip;\n+\n+                if end_is_start_plus_val {\n+                    mem::swap(&mut method_1, &mut method_2);\n+                }\n+\n                 if visitor.nonindex {\n                     span_lint_and_then(\n                         cx,\n@@ -1116,16 +1160,16 @@ fn check_for_loop_range<'a, 'tcx>(\n                                 \"consider using an iterator\".to_string(),\n                                 vec![\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n-                                    (arg.span, format!(\"{}.{}().enumerate(){}{}\", indexed, method, take, skip)),\n+                                    (arg.span, format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2)),\n                                 ],\n                             );\n                         },\n                     );\n                 } else {\n-                    let repl = if starts_at_zero && take.is_empty() {\n+                    let repl = if starts_at_zero && take_is_empty {\n                         format!(\"&{}{}\", ref_mut, indexed)\n                     } else {\n-                        format!(\"{}.{}(){}{}\", indexed, method, take, skip)\n+                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n                     };\n \n                     span_lint_and_then(\n@@ -1952,10 +1996,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                     _ => (),\n                 }\n             }\n-        } else if is_loop(expr) {\n-            walk_expr(self, expr);\n-            return;\n-        } else if is_conditional(expr) {\n+        } else if is_loop(expr) || is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;"}, {"sha": "503a2ee7032e0a4fdae28aa384141d94aeedb835", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -179,7 +179,7 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n     None\n }\n \n-/// Builds a name for the let binding variable (var_arg)\n+/// Builds a name for the let binding variable (`var_arg`)\n ///\n /// `x.field` => `x_field`\n /// `y` => `_y`"}, {"sha": "accd7bc220ca83f1ec09fc189ff9c9d3356beafe", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -23,7 +23,7 @@ use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n ///\n /// **Example:**\n /// ```rust\n-/// mem::forget(Rc::new(55)))\n+/// mem::forget(Rc::new(55))\n /// ```\n declare_clippy_lint! {\n     pub MEM_FORGET,"}, {"sha": "11ed1e70e388ece68739f916b4735ef923d6c25d", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -11,7 +11,7 @@\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray, LintContext, LintPass};\n-use crate::rustc::ty::{self, Ty};\n+use crate::rustc::ty::{self, Ty, TyKind, Predicate};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n@@ -688,7 +688,8 @@ declare_clippy_lint! {\n ///\n /// **Why is this bad?** Readability.\n ///\n-/// **Known problems:** None.\n+/// **Known problems:** False positive in pattern guards. Will be resolved once\n+/// non-lexical lifetimes are stable.\n ///\n /// **Example:**\n /// ```rust\n@@ -878,6 +879,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let name = implitem.ident.name;\n         let parent = cx.tcx.hir.get_parent(implitem.id);\n         let item = cx.tcx.hir.expect_item(parent);\n+        let def_id = cx.tcx.hir.local_def_id(item.id);\n+        let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n@@ -899,8 +902,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 // check conventions w.r.t. conversion method names and predicates\n-                let def_id = cx.tcx.hir.local_def_id(item.id);\n-                let ty = cx.tcx.type_of(def_id);\n                 let is_copy = is_copy(cx, ty);\n                 for &(ref conv, self_kinds) in &CONVENTIONS {\n                     if conv.check(&name.as_str()) {\n@@ -928,16 +929,37 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         break;\n                     }\n                 }\n+            }\n+        }\n+\n+        if let hir::ImplItemKind::Method(_, _) = implitem.node {\n+            let ret_ty = return_ty(cx, implitem.id);\n+\n+            // if return type is impl trait\n+            if let TyKind::Opaque(def_id, _) = ret_ty.sty {\n \n-                let ret_ty = return_ty(cx, implitem.id);\n-                if name == \"new\" &&\n-                   !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n-                    span_lint(cx,\n-                              NEW_RET_NO_SELF,\n-                              implitem.span,\n-                              \"methods called `new` usually return `Self`\");\n+                // then one of the associated types must be Self\n+                for predicate in cx.tcx.predicates_of(def_id).predicates.iter() {\n+                    match predicate {\n+                        (Predicate::Projection(poly_projection_predicate), _) => {\n+                            let binder = poly_projection_predicate.ty();\n+                            let associated_type = binder.skip_binder();\n+                            let associated_type_is_self_type = same_tys(cx, ty, associated_type);\n+\n+                            // if the associated type is self, early return and do not trigger lint\n+                            if associated_type_is_self_type { return; }\n+                        },\n+                        (_, _) => {},\n+                    }\n                 }\n             }\n+\n+            if name == \"new\" && !same_tys(cx, ret_ty, ty) {\n+                span_lint(cx,\n+                          NEW_RET_NO_SELF,\n+                          implitem.span,\n+                          \"methods called `new` usually return `Self`\");\n+            }\n         }\n     }\n }"}, {"sha": "1cf7345e8dfa8113cbe4f997538a989b2791571f", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -21,7 +21,7 @@ use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant\n             iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n             span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n-use crate::syntax::ast::{LitKind, CRATE_NODE_ID};\n+use crate::syntax::ast::LitKind;\n use crate::consts::{constant, Constant};\n use crate::rustc_errors::Applicability;\n \n@@ -535,34 +535,39 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n         return;\n     }\n \n+    let other_gets_derefed = match other.node {\n+        ExprKind::Unary(UnDeref, _) => true,\n+        _ => false,\n+    };\n+\n+    let lint_span = if other_gets_derefed {\n+        expr.span.to(other.span)\n+    } else {\n+        expr.span\n+    };\n+\n     span_lint_and_then(\n         cx,\n         CMP_OWNED,\n-        expr.span,\n+        lint_span,\n         \"this creates an owned instance just for comparison\",\n         |db| {\n-            // this is as good as our recursion check can get, we can't prove that the\n-            // current function is\n-            // called by\n-            // PartialEq::eq, but we can at least ensure that this code is not part of it\n-            let parent_fn = cx.tcx.hir.get_parent(expr.id);\n-            let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n-            if parent_impl != CRATE_NODE_ID {\n-                if let Node::Item(item) = cx.tcx.hir.get(parent_impl) {\n-                    if let ItemKind::Impl(.., Some(ref trait_ref), _, _) = item.node {\n-                        if trait_ref.path.def.def_id() == partial_eq_trait_id {\n-                            // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise\n-                            // we go into\n-                            // recursion\n-                            db.span_label(expr.span, \"try calling implementing the comparison without allocating\");\n-                            return;\n-                        }\n-                    }\n-                }\n+            // this also catches PartialEq implementations that call to_owned\n+            if other_gets_derefed {\n+                db.span_label(lint_span, \"try implementing the comparison without allocating\");\n+                return;\n             }\n-            let try_hint = if deref_arg_impl_partial_eq_other { format!(\"*{}\", snip) } else { snip.to_string() };\n+\n+            let try_hint = if deref_arg_impl_partial_eq_other {\n+                // suggest deref on the left\n+                format!(\"*{}\", snip)\n+            } else {\n+                // suggest dropping the to_owned on the left\n+                snip.to_string()\n+            };\n+\n             db.span_suggestion_with_applicability(\n-                expr.span,\n+                lint_span,\n                 \"try\",\n                 try_hint,\n                 Applicability::MachineApplicable, // snippet"}, {"sha": "72d33e58cd30b58b227bc65a2f568703b988cbb0", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -45,15 +45,15 @@ declare_clippy_lint!{\n }\n \n #[derive(Copy, Clone)]\n-pub struct QuestionMarkPass;\n+pub struct Pass;\n \n-impl LintPass for QuestionMarkPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(QUESTION_MARK)\n     }\n }\n \n-impl QuestionMarkPass {\n+impl Pass {\n     /// Check if the given expression on the given context matches the following structure:\n     ///\n     /// ```ignore\n@@ -145,7 +145,7 @@ impl QuestionMarkPass {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for QuestionMarkPass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         Self::check_is_none_and_early_return_none(cx, expr);\n     }"}, {"sha": "f8c5b29bad16a9f6afcb844fb1cbd4d2f5a1024d", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,228 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::hir::*;\n+use crate::syntax::ptr::P;\n+use crate::syntax::ast::LitKind;\n+use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n+use crate::rustc_errors::Applicability;\n+\n+/// **What it does:** Lint for redundant pattern matching over `Result` or\n+/// `Option`\n+///\n+/// **Why is this bad?** It's more concise and clear to just use the proper\n+/// utility function\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// if let Ok(_) = Ok::<i32, i32>(42) {}\n+/// if let Err(_) = Err::<i32, i32>(42) {}\n+/// if let None = None::<()> {}\n+/// if let Some(_) = Some(42) {}\n+/// match Ok::<i32, i32>(42) {\n+///     Ok(_) => true,\n+///     Err(_) => false,\n+/// };\n+/// ```\n+///\n+/// The more idiomatic use would be:\n+///\n+/// ```rust\n+/// if Ok::<i32, i32>(42).is_ok() {}\n+/// if Err::<i32, i32>(42).is_err() {}\n+/// if None::<()>.is_none() {}\n+/// if Some(42).is_some() {}\n+/// Ok::<i32, i32>(42).is_ok();\n+/// ```\n+///\n+declare_clippy_lint! {\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(REDUNDANT_PATTERN_MATCHING)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    #[allow(clippy::similar_names)]\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if let ExprKind::Match(ref op, ref arms, ref match_source) = expr.node {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms),\n+                _ => return,\n+            }\n+        }\n+    }\n+}\n+\n+fn find_sugg_for_if_let<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    op: &P<Expr>,\n+    arms: &HirVec<Arm>\n+) {\n+    if arms[0].pats.len() == 1 {\n+        let good_method = match arms[0].pats[0].node {\n+            PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n+                if let PatKind::Wild = pats[0].node {\n+                    if match_qpath(path, &paths::RESULT_OK) {\n+                        \"is_ok()\"\n+                    } else if match_qpath(path, &paths::RESULT_ERR) {\n+                        \"is_err()\"\n+                    } else if match_qpath(path, &paths::OPTION_SOME) {\n+                        \"is_some()\"\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+            },\n+\n+            PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n+\n+            _ => return,\n+        };\n+\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pats[0].span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |db| {\n+                let span = expr.span.to(op.span);\n+                db.span_suggestion_with_applicability(\n+                    span,\n+                    \"try this\",\n+                    format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n+    } else {\n+        return;\n+    }\n+}\n+\n+fn find_sugg_for_match<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    op: &P<Expr>,\n+    arms: &HirVec<Arm>\n+) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pats[0].node, &arms[1].pats[0].node);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, ref pats_left, _),\n+                PatKind::TupleStruct(ref path_right, ref pats_right, _)\n+            ) if pats_left.len() == 1 && pats_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&pats_left[0].node, &pats_right[0].node) {\n+                    find_good_method_for_match(\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\"\n+                    )\n+                } else {\n+                    None\n+                }\n+            },\n+            (\n+                PatKind::TupleStruct(ref path_left, ref pats, _),\n+                PatKind::Path(ref path_right)\n+            ) | (\n+                PatKind::Path(ref path_left),\n+                PatKind::TupleStruct(ref path_right, ref pats, _)\n+            ) if pats.len() == 1 => {\n+                if let PatKind::Wild = pats[0].node {\n+                    find_good_method_for_match(\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\"\n+                    )\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            span_lint_and_then(\n+                cx,\n+                REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |db| {\n+                    let span = expr.span.to(op.span);\n+                    db.span_suggestion_with_applicability(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                        Applicability::MachineApplicable, // snippet\n+                    );\n+                },\n+            );\n+        }\n+    } else {\n+        return;\n+    }\n+}\n+\n+fn find_good_method_for_match<'a>(\n+    arms: &HirVec<Arm>,\n+    path_left: &QPath,\n+    path_right: &QPath,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str\n+) -> Option<&'a str> {\n+    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+        (&(*arms[0].body).node, &(*arms[1].body).node)\n+    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+        (&(*arms[1].body).node, &(*arms[0].body).node)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => {\n+            match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "d083387e852e51b52dcf9dbbd3393e2fbcd9d6b2", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -14,8 +14,8 @@ use if_chain::if_chain;\n use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n use crate::syntax::visit::FnKind;\n+use crate::syntax_pos::BytePos;\n use crate::rustc_errors::Applicability;\n-\n use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n \n /// **What it does:** Checks for return statements at the end of a block.\n@@ -68,6 +68,25 @@ declare_clippy_lint! {\n      the end of a block\"\n }\n \n+/// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+///\n+/// **Why is this bad?** Such expressions add no value, but can make the code\n+/// less readable. Depending on formatting they can make a `break` or `return`\n+/// statement look like a function call.\n+///\n+/// **Known problems:** The lint currently misses unit return types in types,\n+/// e.g. the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+///\n+/// **Example:**\n+/// ```rust\n+/// fn return_unit() -> () { () }\n+/// ```\n+declare_clippy_lint! {\n+    pub UNUSED_UNIT,\n+    style,\n+    \"needless unit expression\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct ReturnPass;\n \n@@ -162,23 +181,98 @@ impl ReturnPass {\n \n impl LintPass for ReturnPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NEEDLESS_RETURN, LET_AND_RETURN)\n+        lint_array!(NEEDLESS_RETURN, LET_AND_RETURN, UNUSED_UNIT)\n     }\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, decl: &ast::FnDecl, span: Span, _: ast::NodeId) {\n         match kind {\n             FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, Some(body.span)),\n         }\n+        if_chain! {\n+            if let ast::FunctionRetTy::Ty(ref ty) = decl.output;\n+            if let ast::TyKind::Tup(ref vals) = ty.node;\n+            if vals.is_empty() && !in_macro(ty.span) && get_def(span) == get_def(ty.span);\n+            then {\n+                let (rspan, appl) = if let Ok(fn_source) =\n+                        cx.sess().source_map()\n+                                 .span_to_snippet(span.with_hi(ty.span.hi())) {\n+                    if let Some(rpos) = fn_source.rfind(\"->\") {\n+                        (ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                            Applicability::MachineApplicable)\n+                    } else {\n+                        (ty.span, Applicability::MaybeIncorrect)\n+                    }\n+                } else {\n+                    (ty.span, Applicability::MaybeIncorrect)\n+                };\n+                span_lint_and_then(cx, UNUSED_UNIT, rspan, \"unneeded unit return type\", |db| {\n+                    db.span_suggestion_with_applicability(\n+                        rspan,\n+                        \"remove the `-> ()`\",\n+                        String::new(),\n+                        appl,\n+                    );\n+                });\n+            }\n+        }\n     }\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         self.check_let_return(cx, block);\n+        if_chain! {\n+            if let Some(ref stmt) = block.stmts.last();\n+            if let ast::StmtKind::Expr(ref expr) = stmt.node;\n+            if is_unit_expr(expr) && !in_macro(expr.span);\n+            then {\n+                let sp = expr.span;\n+                span_lint_and_then(cx, UNUSED_UNIT, sp, \"unneeded unit expression\", |db| {\n+                    db.span_suggestion_with_applicability(\n+                        sp,\n+                        \"remove the final `()`\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                });\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n+                if is_unit_expr(expr) && !in_macro(expr.span) {\n+                    span_lint_and_then(cx, UNUSED_UNIT, expr.span, \"unneeded `()`\", |db| {\n+                        db.span_suggestion_with_applicability(\n+                            expr.span,\n+                            \"remove the `()`\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    });\n+                }\n+            }\n+            _ => ()\n+        }\n     }\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n     attr.meta_item_list().is_some() && attr.name() == \"cfg\"\n }\n+\n+// get the def site\n+fn get_def(span: Span) -> Option<Span> {\n+    span.ctxt().outer().expn_info().and_then(|info| info.def_site)\n+}\n+\n+// is this expr a `()` unit?\n+fn is_unit_expr(expr: &ast::Expr) -> bool {\n+    if let ast::ExprKind::Tup(ref vals) = expr.node {\n+        vals.is_empty()\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "801b6db63f5e0c9fa3de9f94026178557bd9bdc1", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -227,6 +227,7 @@ impl LintPass for Transmute {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n+    #[allow(clippy::similar_names)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {"}, {"sha": "59c55168232915948504750e1eec478aaa1b3f36", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -1920,6 +1920,7 @@ enum ImplicitHasherType<'tcx> {\n \n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n+    #[allow(clippy::new_ret_no_self)]\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n         if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n             let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?"}, {"sha": "5ce1e08d8b53347b403c9776db9d8aadcbf621f4", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -10,7 +10,7 @@\n \n /// Return the index of the character after the first camel-case component of\n /// `s`.\n-pub fn camel_case_until(s: &str) -> usize {\n+pub fn until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n         if !first.is_uppercase() {\n@@ -43,7 +43,7 @@ pub fn camel_case_until(s: &str) -> usize {\n }\n \n /// Return index of the last camel-case component of `s`.\n-pub fn camel_case_from(s: &str) -> usize {\n+pub fn from(s: &str) -> usize {\n     let mut iter = s.char_indices().rev();\n     if let Some((_, first)) = iter.next() {\n         if !first.is_lowercase() {\n@@ -73,52 +73,52 @@ pub fn camel_case_from(s: &str) -> usize {\n \n #[cfg(test)]\n mod test {\n-    use super::{camel_case_from, camel_case_until};\n+    use super::{from, until};\n \n     #[test]\n     fn from_full() {\n-        assert_eq!(camel_case_from(\"AbcDef\"), 0);\n-        assert_eq!(camel_case_from(\"Abc\"), 0);\n+        assert_eq!(from(\"AbcDef\"), 0);\n+        assert_eq!(from(\"Abc\"), 0);\n     }\n \n     #[test]\n     fn from_partial() {\n-        assert_eq!(camel_case_from(\"abcDef\"), 3);\n-        assert_eq!(camel_case_from(\"aDbc\"), 1);\n+        assert_eq!(from(\"abcDef\"), 3);\n+        assert_eq!(from(\"aDbc\"), 1);\n     }\n \n     #[test]\n     fn from_not() {\n-        assert_eq!(camel_case_from(\"AbcDef_\"), 7);\n-        assert_eq!(camel_case_from(\"AbcDD\"), 5);\n+        assert_eq!(from(\"AbcDef_\"), 7);\n+        assert_eq!(from(\"AbcDD\"), 5);\n     }\n \n     #[test]\n     fn from_caps() {\n-        assert_eq!(camel_case_from(\"ABCD\"), 4);\n+        assert_eq!(from(\"ABCD\"), 4);\n     }\n \n     #[test]\n     fn until_full() {\n-        assert_eq!(camel_case_until(\"AbcDef\"), 6);\n-        assert_eq!(camel_case_until(\"Abc\"), 3);\n+        assert_eq!(until(\"AbcDef\"), 6);\n+        assert_eq!(until(\"Abc\"), 3);\n     }\n \n     #[test]\n     fn until_not() {\n-        assert_eq!(camel_case_until(\"abcDef\"), 0);\n-        assert_eq!(camel_case_until(\"aDbc\"), 0);\n+        assert_eq!(until(\"abcDef\"), 0);\n+        assert_eq!(until(\"aDbc\"), 0);\n     }\n \n     #[test]\n     fn until_partial() {\n-        assert_eq!(camel_case_until(\"AbcDef_\"), 6);\n-        assert_eq!(camel_case_until(\"CallTypeC\"), 8);\n-        assert_eq!(camel_case_until(\"AbcDD\"), 3);\n+        assert_eq!(until(\"AbcDef_\"), 6);\n+        assert_eq!(until(\"CallTypeC\"), 8);\n+        assert_eq!(until(\"AbcDD\"), 3);\n     }\n \n     #[test]\n     fn until_caps() {\n-        assert_eq!(camel_case_until(\"ABCD\"), 0);\n+        assert_eq!(until(\"ABCD\"), 0);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "7a0b28d15d875f47b53d78caed01d7bb1f5f47f0", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -73,6 +73,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n+    #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr, right: &Expr) -> bool {\n         if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n             return false;\n@@ -208,6 +209,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n+    #[allow(clippy::similar_names)]\n     fn eq_qpath(&mut self, left: &QPath, right: &QPath) -> bool {\n         match (left, right) {\n             (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n@@ -262,6 +264,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         self.eq_ty_kind(&left.node, &right.node)\n     }\n \n+    #[allow(clippy::similar_names)]\n     pub fn eq_ty_kind(&mut self, left: &TyKind, right: &TyKind) -> bool {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),"}, {"sha": "ea48aa9ab5e7d76e1ccb27a9751d9e6f7027116f", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -166,6 +166,7 @@ fn print_decl(cx: &LateContext<'_, '_>, decl: &hir::Decl) {\n     }\n }\n \n+#[allow(clippy::similar_names)]\n fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n@@ -424,6 +425,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     }\n }\n \n+#[allow(clippy::similar_names)]\n fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);"}, {"sha": "05356f8d3856f7d6c4f93f8d16d1b9afbbc54217", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -33,8 +33,7 @@ use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::errors::DiagnosticBuilder;\n use crate::syntax::symbol::keywords;\n \n-mod camel_case;\n-pub use self::camel_case::{camel_case_from, camel_case_until};\n+pub mod camel_case;\n \n pub mod comparisons;\n pub mod conf;"}, {"sha": "f3af698ffa2f7ecd1864d1e60ed573fa01cc030d", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -54,6 +54,7 @@ struct MutVarsDelegate {\n }\n \n impl<'tcx> MutVarsDelegate {\n+    #[allow(clippy::similar_names)]\n     fn update(&mut self, cat: &'tcx Categorization<'_>) {\n         match *cat {\n             Categorization::Local(id) => {"}, {"sha": "b640597586215e2b107661c9cf97dd0ec85736a4", "filename": "mini-macro/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/mini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/mini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2Fsrc%2Flib.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -17,5 +17,10 @@ use proc_macro::{TokenStream, quote};\n pub fn mini_macro(_: TokenStream) -> TokenStream {\n     quote!(\n         #[allow(unused)] fn needless_take_by_value(s: String) { println!(\"{}\", s.len()); }\n+        #[allow(unused)] fn needless_loop(items: &[u8]) {\n+            for i in 0..items.len() {\n+                println!(\"{}\", items[i]);\n+            }\n+        }\n     )\n }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/author/for_loop.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fauthor%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fauthor%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719"}, {"sha": "dc3d62ddfa69c8a589052f98805cce85111debde", "filename": "tests/ui/cmp_owned.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -35,6 +35,16 @@ fn main() {\n     \"abc\".chars().filter(|c| c.to_owned() != 'X');\n \n     \"abc\".chars().filter(|c| *c != 'X');\n+\n+    let x = &Baz;\n+    let y = &Baz;\n+\n+    y.to_owned() == *x;\n+\n+    let x = &&Baz;\n+    let y = &Baz;\n+\n+    y.to_owned() == **x;\n }\n \n struct Foo;\n@@ -67,3 +77,13 @@ impl std::borrow::Borrow<Foo> for Bar {\n         &FOO\n     }\n }\n+\n+#[derive(PartialEq)]\n+struct Baz;\n+\n+impl ToOwned for Baz {\n+    type Owned = Baz;\n+    fn to_owned(&self) -> Baz {\n+        Baz\n+    }\n+}"}, {"sha": "a7371ab4b6c3fbe380200d2f6365b89cd34db2ec", "filename": "tests/ui/cmp_owned.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcmp_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcmp_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -37,10 +37,22 @@ error: this creates an owned instance just for comparison\n    |                              ^^^^^^^^^^^^ help: try: `*c`\n \n error: this creates an owned instance just for comparison\n-  --> $DIR/cmp_owned.rs:44:9\n+  --> $DIR/cmp_owned.rs:42:5\n    |\n-44 |         self.to_owned() == *other\n-   |         ^^^^^^^^^^^^^^^ try calling implementing the comparison without allocating\n+42 |     y.to_owned() == *x;\n+   |     ^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating\n \n-error: aborting due to 7 previous errors\n+error: this creates an owned instance just for comparison\n+  --> $DIR/cmp_owned.rs:47:5\n+   |\n+47 |     y.to_owned() == **x;\n+   |     ^^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/cmp_owned.rs:54:9\n+   |\n+54 |         self.to_owned() == *other\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "1bc866010fd1956091271443be6084b56dcdddab", "filename": "tests/ui/collapsible_if.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -151,4 +151,62 @@ fn main() {\n     } else {\n         assert!(true); // assert! is just an `if`\n     }\n+\n+\n+    // The following tests check for the fix of https://github.com/rust-lang-nursery/rust-clippy/issues/798\n+    if x == \"hello\" {// Not collapsible\n+        if y == \"world\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" { // Not collapsible\n+        if y == \"world\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        // Not collapsible\n+        if y == \"world\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        if y == \"world\" { // Collapsible\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        // Not collapsible\n+        if y == \"world\" {\n+            println!(\"world!\")\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        // Not collapsible\n+        if let Some(42) = Some(42) {\n+            println!(\"world!\")\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        /* Not collapsible */\n+        if y == \"world\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" { /* Not collapsible */\n+        if y == \"world\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n }"}, {"sha": "3f06dca5495225eb6ed33462fbfaf728049cb038", "filename": "tests/ui/collapsible_if.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_if.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -240,5 +240,21 @@ help: try\n 122 | }\n     |\n \n-error: aborting due to 13 previous errors\n+error: this if statement can be collapsed\n+   --> $DIR/collapsible_if.rs:176:5\n+    |\n+176 | /     if x == \"hello\" {\n+177 | |         if y == \"world\" { // Collapsible\n+178 | |             println!(\"Hello world!\");\n+179 | |         }\n+180 | |     }\n+    | |_____^\n+help: try\n+    |\n+176 |     if x == \"hello\" && y == \"world\" { // Collapsible\n+177 |     println!(\"Hello world!\");\n+178 | }\n+    |\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "5c4bbecf82206e02ae0967c030c72fcf798ef35f", "filename": "tests/ui/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcopies.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(clippy::blacklisted_name, clippy::collapsible_if, clippy::cyclomatic_complexity, clippy::eq_op, clippy::needless_continue,\n+         clippy::needless_return, clippy::never_loop, clippy::no_effect, clippy::zero_divided_by_zero, clippy::unused_unit)]\n \n \n \n-#![allow(clippy::blacklisted_name, clippy::collapsible_if, clippy::cyclomatic_complexity, clippy::eq_op, clippy::needless_continue,\n-         clippy::needless_return, clippy::never_loop, clippy::no_effect, clippy::zero_divided_by_zero)]\n-\n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n \n@@ -28,6 +27,7 @@ pub enum Abc {\n \n #[warn(clippy::if_same_then_else)]\n #[warn(clippy::match_same_arms)]\n+#[allow(clippy::unused_unit)]\n fn if_same_then_else() -> Result<&'static str, ()> {\n     if true {\n         Foo { bar: 42 };"}, {"sha": "b35071546e7620761ddef16b5cb5d302388b1387", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -7,12 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n #![feature(box_syntax)]\n \n-#![allow(warnings, clippy)]\n-\n-#![warn(boxed_local)]\n+#![allow(clippy::borrowed_box, clippy::needless_pass_by_value, clippy::unused_unit)]\n+#![warn(clippy::boxed_local)]\n \n #[derive(Clone)]\n struct A;\n@@ -70,8 +68,7 @@ fn warn_pass() {\n }\n \n fn nowarn_return() -> Box<A> {\n-    let fx = box A;\n-    fx // moved out, \"escapes\"\n+    box A // moved out, \"escapes\"\n }\n \n fn nowarn_move() {\n@@ -139,3 +136,28 @@ pub struct PeekableSeekable<I: Foo> {\n \n pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {\n }\n+\n+/// Regression for #916, #1123\n+///\n+/// This shouldn't warn for `boxed_local`as the implementation of a trait\n+/// can't change much about the trait definition.\n+trait BoxedAction {\n+    fn do_sth(self: Box<Self>);\n+}\n+\n+impl BoxedAction for u64 {\n+    fn do_sth(self: Box<Self>) {\n+        println!(\"{}\", *self)\n+    }\n+}\n+\n+/// Regression for #1478\n+///\n+/// This shouldn't warn for `boxed_local`as self itself is a box type.\n+trait MyTrait {\n+    fn do_sth(self);\n+}\n+\n+impl<T> MyTrait for Box<T> {\n+    fn do_sth(self) {}\n+}"}, {"sha": "25ba413b75a5fb6cb0a49261e4c3ed2a6623dc94", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,16 @@\n+error: local variable doesn't need to be boxed here\n+  --> $DIR/escape_analysis.rs:45:13\n+   |\n+45 | fn warn_arg(x: Box<A>) {\n+   |             ^\n+   |\n+   = note: `-D clippy::boxed-local` implied by `-D warnings`\n+\n+error: local variable doesn't need to be boxed here\n+   --> $DIR/escape_analysis.rs:137:12\n+    |\n+137 | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {\n+    |            ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f80270d9fe8f71514a37fa4afe7cd91505460932", "filename": "tests/ui/for_loop.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -550,6 +550,19 @@ pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n     for i in 0..10 {\n         dst_vec[i] = src[i];\n     }\n+\n+    // Simplify suggestion (issue #3004)\n+    let src = [0, 1, 2, 3, 4];\n+    let mut dst = [0, 0, 0, 0, 0, 0];\n+    let from = 1;\n+\n+    for i in from..from + src.len() {\n+        dst[i] = src[i - from];\n+    }\n+\n+    for i in from..from + 3 {\n+        dst[i] = src[i - from];\n+    }\n }\n \n #[warn(clippy::needless_range_loop)]\n@@ -646,3 +659,38 @@ mod issue_1219 {\n         }\n     }\n }\n+\n+mod issue_3308 {\n+    #[warn(clippy::explicit_counter_loop)]\n+    pub fn test() {\n+        // should not trigger the lint because the count is incremented multiple times\n+        let mut skips = 0;\n+        let erasures = vec![];\n+        for i in 0..10 {\n+            while erasures.contains(&(i + skips)) {\n+                skips += 1;\n+            }\n+            println!(\"{}\", skips);\n+        }\n+\n+        // should not trigger the lint because the count is incremented multiple times\n+        let mut skips = 0;\n+        for i in 0..10 {\n+            let mut j = 0;\n+            while j < 5 {\n+                skips += 1;\n+                j += 1;\n+            }\n+            println!(\"{}\", skips);\n+        }\n+\n+        // should not trigger the lint because the count is incremented multiple times\n+        let mut skips = 0;\n+        for i in 0..10 {\n+            for j in 0..5 {\n+                skips += 1;\n+            }\n+            println!(\"{}\", skips);\n+        }\n+    }\n+}"}, {"sha": "331763357832610dad9e6ba4706c4aa4560de589", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -482,22 +482,34 @@ error: it looks like you're manually copying between slices\n     |              ^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..])`\n \n error: it looks like you're manually copying between slices\n-   --> $DIR/for_loop.rs:557:14\n+   --> $DIR/for_loop.rs:559:14\n     |\n-557 |     for i in 0..src.len() {\n+559 |     for i in from..from + src.len() {\n+    |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[0..(from + src.len() - from)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:563:14\n+    |\n+563 |     for i in from..from + 3 {\n+    |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[0..(from + 3 - from)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:570:14\n+    |\n+570 |     for i in 0..src.len() {\n     |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n \n error: the variable `count` is used as a loop counter. Consider using `for (count, item) in text.chars().enumerate()` or similar iterators\n-   --> $DIR/for_loop.rs:618:19\n+   --> $DIR/for_loop.rs:631:19\n     |\n-618 |         for ch in text.chars() {\n+631 |         for ch in text.chars() {\n     |                   ^^^^^^^^^^^^\n \n error: the variable `count` is used as a loop counter. Consider using `for (count, item) in text.chars().enumerate()` or similar iterators\n-   --> $DIR/for_loop.rs:629:19\n+   --> $DIR/for_loop.rs:642:19\n     |\n-629 |         for ch in text.chars() {\n+642 |         for ch in text.chars() {\n     |                   ^^^^^^^^^^^^\n \n-error: aborting due to 61 previous errors\n+error: aborting due to 63 previous errors\n "}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/for_loop.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stdout?ref=9f637288cfd757d7177e0157caf98f917a54b719"}, {"sha": "5111de671890f94484396bcd59e2a22af9f122af", "filename": "tests/ui/if_let_redundant_pattern_matching.stderr", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/63fbeaab68065019bbe17e68bb5f54ff997ef2ed/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63fbeaab68065019bbe17e68bb5f54ff997ef2ed/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr?ref=63fbeaab68065019bbe17e68bb5f54ff997ef2ed", "patch": "@@ -1,34 +0,0 @@\n-error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/if_let_redundant_pattern_matching.rs:19:12\n-   |\n-19 |     if let Ok(_) = Ok::<i32, i32>(42) {}\n-   |     -------^^^^^------------------------ help: try this: `if Ok::<i32, i32>(42).is_ok()`\n-   |\n-   = note: `-D clippy::if-let-redundant-pattern-matching` implied by `-D warnings`\n-\n-error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/if_let_redundant_pattern_matching.rs:21:12\n-   |\n-21 |       if let Err(_) = Err::<i32, i32>(42) {\n-   |  _____-      ^^^^^^\n-22 | |     }\n-   | |_____- help: try this: `if Err::<i32, i32>(42).is_err()`\n-\n-error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/if_let_redundant_pattern_matching.rs:24:12\n-   |\n-24 |       if let None = None::<()> {\n-   |  _____-      ^^^^\n-25 | |     }\n-   | |_____- help: try this: `if None::<()>.is_none()`\n-\n-error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/if_let_redundant_pattern_matching.rs:27:12\n-   |\n-27 |       if let Some(_) = Some(42) {\n-   |  _____-      ^^^^^^^\n-28 | |     }\n-   | |_____- help: try this: `if Some(42).is_some()`\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "1f937bafdefb4020802254b00ab76ae86ffa0b32", "filename": "tests/ui/len_zero.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Flen_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Flen_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -46,87 +46,87 @@ error: length comparison to zero\n    --> $DIR/len_zero.rs:151:8\n     |\n 151 |     if x.len() == 0 {\n-    |        ^^^^^^^^^^^^ help: using `is_empty` is more concise: `x.is_empty()`\n+    |        ^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `x.is_empty()`\n     |\n     = note: `-D clippy::len-zero` implied by `-D warnings`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:155:8\n     |\n 155 |     if \"\".len() == 0 {}\n-    |        ^^^^^^^^^^^^^ help: using `is_empty` is more concise: `\"\".is_empty()`\n+    |        ^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `\"\".is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:170:8\n     |\n 170 |     if has_is_empty.len() == 0 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:173:8\n     |\n 173 |     if has_is_empty.len() != 0 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:176:8\n     |\n 176 |     if has_is_empty.len() > 0 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n    --> $DIR/len_zero.rs:179:8\n     |\n 179 |     if has_is_empty.len() < 1 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to one\n    --> $DIR/len_zero.rs:182:8\n     |\n 182 |     if has_is_empty.len() >= 1 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:193:8\n     |\n 193 |     if 0 == has_is_empty.len() {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:196:8\n     |\n 196 |     if 0 != has_is_empty.len() {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:199:8\n     |\n 199 |     if 0 < has_is_empty.len() {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n    --> $DIR/len_zero.rs:202:8\n     |\n 202 |     if 1 <= has_is_empty.len() {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n    --> $DIR/len_zero.rs:205:8\n     |\n 205 |     if 1 > has_is_empty.len() {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:219:8\n     |\n 219 |     if with_is_empty.len() == 0 {\n-    |        ^^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `with_is_empty.is_empty()`\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `with_is_empty.is_empty()`\n \n error: length comparison to zero\n    --> $DIR/len_zero.rs:232:8\n     |\n 232 |     if b.len() != 0 {}\n-    |        ^^^^^^^^^^^^ help: using `is_empty` is more concise: `!b.is_empty()`\n+    |        ^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!b.is_empty()`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n    --> $DIR/len_zero.rs:238:1"}, {"sha": "d31e97c7959efabc1fe52e83e80decff6a32f55c", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -13,7 +13,7 @@\n \n \n #![warn(clippy::all)]\n-#![allow(unused, clippy::if_let_redundant_pattern_matching)]\n+#![allow(unused, clippy::redundant_pattern_matching)]\n #![warn(clippy::single_match_else, clippy::match_same_arms)]\n \n enum ExprNode {"}, {"sha": "ae1b1642be7ead7b12914cc2d618b95bd6efbd17", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -14,7 +14,7 @@\n #![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n #![allow(clippy::blacklisted_name, unused, clippy::print_stdout, clippy::non_ascii_literal, clippy::new_without_default,\n     clippy::new_without_default_derive, clippy::missing_docs_in_private_items, clippy::needless_pass_by_value,\n-    clippy::default_trait_access, clippy::use_self, clippy::useless_format)]\n+    clippy::default_trait_access, clippy::use_self, clippy::new_ret_no_self, clippy::useless_format)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -43,7 +43,7 @@ impl T {\n \n     fn to_something(self) -> u32 { 0 }\n \n-    fn new(self) {}\n+    fn new(self) -> Self { unimplemented!(); }\n }\n \n struct Lt<'a> {"}, {"sha": "307814824eaa3613c2ec8d48c640687d04b9218e", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -23,17 +23,9 @@ error: methods called `to_*` usually take self by reference; consider choosing a\n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n   --> $DIR/methods.rs:46:12\n    |\n-46 |     fn new(self) {}\n+46 |     fn new(self) -> Self { unimplemented!(); }\n    |            ^^^^\n \n-error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:46:5\n-   |\n-46 |     fn new(self) {}\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n-\n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n    --> $DIR/methods.rs:114:13\n     |\n@@ -465,5 +457,5 @@ error: used unwrap() on an Option value. If you don't want to handle the None ca\n     |\n     = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 58 previous errors\n+error: aborting due to 57 previous errors\n "}, {"sha": "c27fd5be134522bc21f78eb2565d51f12d839e50", "filename": "tests/ui/my_lint.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmy_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fmy_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmy_lint.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,7 @@\n+#[clippy::author]\n+#[cfg(any(target_arch = \"x86\"))]\n+pub struct Foo {\n+    x: u32,\n+}\n+\n+fn main() {}"}, {"sha": "48b7b42cc8c891b16bfdcbe25f2e659d02e46b83", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -11,7 +11,7 @@\n \n \n #![warn(clippy::needless_pass_by_value)]\n-#![allow(dead_code, clippy::single_match, clippy::if_let_redundant_pattern_matching, clippy::many_single_char_names, clippy::option_option)]\n+#![allow(dead_code, clippy::single_match, clippy::redundant_pattern_matching, clippy::many_single_char_names, clippy::option_option)]\n \n use std::borrow::Borrow;\n use std::convert::AsRef;"}, {"sha": "3da9267d38b9e4a0ed745237d8505de8f009f249", "filename": "tests/ui/needless_range_loop.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -62,4 +62,18 @@ fn main() {\n         g[i] = g[i+1..].iter().sum();\n     }\n     assert_eq!(g, vec![20, 18, 15, 11, 6, 0]);\n+\n+    let x = 5;\n+    let mut vec = vec![0; 9];\n+\n+    for i in x..x + 4 {\n+        vec[i] += 1;\n+    }\n+\n+    let x = 5;\n+    let mut vec = vec![0; 10];\n+\n+    for i in x..=x + 4 {\n+        vec[i] += 1;\n+    }\n }"}, {"sha": "d62a0434d0b775cce1ecfbeb4d76515598a66c45", "filename": "tests/ui/needless_range_loop.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_range_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fneedless_range_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -30,5 +30,25 @@ help: consider using an iterator\n 45 |     for <item> in &mut ms {\n    |         ^^^^^^    ^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: the loop variable `i` is only used to index `vec`.\n+  --> $DIR/needless_range_loop.rs:69:14\n+   |\n+69 |     for i in x..x + 4 {\n+   |              ^^^^^^^^\n+help: consider using an iterator\n+   |\n+69 |     for <item> in vec.iter_mut().skip(x).take(4) {\n+   |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the loop variable `i` is only used to index `vec`.\n+  --> $DIR/needless_range_loop.rs:76:14\n+   |\n+76 |     for i in x..=x + 4 {\n+   |              ^^^^^^^^^\n+help: consider using an iterator\n+   |\n+76 |     for <item> in vec.iter_mut().skip(x).take(4 + 1) {\n+   |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "1a4b91cc9da93530171b45a04c497a379681738e", "filename": "tests/ui/new_ret_no_self.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fnew_ret_no_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fnew_ret_no_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,93 @@\n+#![warn(clippy::new_ret_no_self)]\n+#![allow(dead_code, clippy::trivially_copy_pass_by_ref)]\n+\n+fn main(){}\n+\n+trait R {\n+    type Item;\n+}\n+\n+trait Q {\n+    type Item;\n+    type Item2;\n+}\n+\n+struct S;\n+\n+impl R for S {\n+    type Item = Self;\n+}\n+\n+impl S {\n+    // should not trigger the lint\n+    pub fn new() -> impl R<Item = Self> {\n+        S\n+    }\n+}\n+\n+struct S2;\n+\n+impl R for S2 {\n+    type Item = Self;\n+}\n+\n+impl S2 {\n+    // should not trigger the lint\n+    pub fn new(_: String) -> impl R<Item = Self> {\n+        S2\n+    }\n+}\n+\n+struct S3;\n+\n+impl R for S3 {\n+    type Item = u32;\n+}\n+\n+impl S3 {\n+    // should trigger the lint\n+    pub fn new(_: String) -> impl R<Item = u32> {\n+        S3\n+    }\n+}\n+\n+struct S4;\n+\n+impl Q for S4 {\n+    type Item = u32;\n+    type Item2 = Self;\n+}\n+\n+impl S4 {\n+    // should not trigger the lint\n+    pub fn new(_: String) -> impl Q<Item = u32, Item2 = Self> {\n+        S4\n+    }\n+}\n+\n+struct T;\n+\n+impl T {\n+    // should not trigger lint\n+    pub fn new() -> Self {\n+        unimplemented!();\n+    }\n+}\n+\n+struct U;\n+\n+impl U {\n+    // should trigger lint\n+    pub fn new() -> u32 {\n+        unimplemented!();\n+    }\n+}\n+\n+struct V;\n+\n+impl V {\n+    // should trigger lint\n+    pub fn new(_: String) -> u32 {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "ad26438d4efe73e4324f9b748004d0609d4d4d12", "filename": "tests/ui/new_ret_no_self.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fnew_ret_no_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fnew_ret_no_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,28 @@\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:49:5\n+   |\n+49 | /     pub fn new(_: String) -> impl R<Item = u32> {\n+50 | |         S3\n+51 | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:81:5\n+   |\n+81 | /     pub fn new() -> u32 {\n+82 | |         unimplemented!();\n+83 | |     }\n+   | |_____^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:90:5\n+   |\n+90 | /     pub fn new(_: String) -> u32 {\n+91 | |         unimplemented!();\n+92 | |     }\n+   | |_____^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "50838584f66e7458c2b3640458ea4e2b90ec7a1d", "filename": "tests/ui/redundant_pattern_matching.rs", "status": "renamed", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -12,7 +12,7 @@\n \n \n #![warn(clippy::all)]\n-#![warn(clippy::if_let_redundant_pattern_matching)]\n+#![warn(clippy::redundant_pattern_matching)]\n \n \n fn main() {\n@@ -42,4 +42,34 @@ fn main() {\n     if let Ok(x) = Ok::<i32,i32>(42) {\n         println!(\"{}\", x);\n     }\n+\n+    match Ok::<i32, i32>(42) {\n+        Ok(_) => true,\n+        Err(_) => false,\n+    };\n+\n+    match Ok::<i32, i32>(42) {\n+        Ok(_) => false,\n+        Err(_) => true,\n+    };\n+\n+    match Err::<i32, i32>(42) {\n+        Ok(_) => false,\n+        Err(_) => true,\n+    };\n+\n+    match Err::<i32, i32>(42) {\n+        Ok(_) => true,\n+        Err(_) => false,\n+    };\n+\n+    match Some(42) {\n+        Some(_) => true,\n+        None => false,\n+    };\n+\n+    match None::<()> {\n+        Some(_) => false,\n+        None => true,\n+    };\n }", "previous_filename": "tests/ui/if_let_redundant_pattern_matching.rs"}, {"sha": "a42ac7ba04d635bc98cb2225cad262f1721caba6", "filename": "tests/ui/redundant_pattern_matching.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,88 @@\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching.rs:19:12\n+   |\n+19 |     if let Ok(_) = Ok::<i32, i32>(42) {}\n+   |     -------^^^^^------------------------ help: try this: `if Ok::<i32, i32>(42).is_ok()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching.rs:21:12\n+   |\n+21 |       if let Err(_) = Err::<i32, i32>(42) {\n+   |  _____-      ^^^^^^\n+22 | |     }\n+   | |_____- help: try this: `if Err::<i32, i32>(42).is_err()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching.rs:24:12\n+   |\n+24 |       if let None = None::<()> {\n+   |  _____-      ^^^^\n+25 | |     }\n+   | |_____- help: try this: `if None::<()>.is_none()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching.rs:27:12\n+   |\n+27 |       if let Some(_) = Some(42) {\n+   |  _____-      ^^^^^^^\n+28 | |     }\n+   | |_____- help: try this: `if Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching.rs:46:5\n+   |\n+46 | /     match Ok::<i32, i32>(42) {\n+47 | |         Ok(_) => true,\n+48 | |         Err(_) => false,\n+49 | |     };\n+   | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching.rs:51:5\n+   |\n+51 | /     match Ok::<i32, i32>(42) {\n+52 | |         Ok(_) => false,\n+53 | |         Err(_) => true,\n+54 | |     };\n+   | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching.rs:56:5\n+   |\n+56 | /     match Err::<i32, i32>(42) {\n+57 | |         Ok(_) => false,\n+58 | |         Err(_) => true,\n+59 | |     };\n+   | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching.rs:61:5\n+   |\n+61 | /     match Err::<i32, i32>(42) {\n+62 | |         Ok(_) => true,\n+63 | |         Err(_) => false,\n+64 | |     };\n+   | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching.rs:66:5\n+   |\n+66 | /     match Some(42) {\n+67 | |         Some(_) => true,\n+68 | |         None => false,\n+69 | |     };\n+   | |_____^ help: try this: `Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching.rs:71:5\n+   |\n+71 | /     match None::<()> {\n+72 | |         Some(_) => false,\n+73 | |         None => true,\n+74 | |     };\n+   | |_____^ help: try this: `None::<()>.is_none()`\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/ty_fn_sig.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fty_fn_sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Fty_fn_sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fty_fn_sig.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719"}, {"sha": "a7f08c28939d6b332116011789af5387725264a8", "filename": "tests/ui/unused_unit.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.rs?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+// compile-pass\n+\n+// The output for humans should just highlight the whole span without showing\n+// the suggested replacement, but we also want to test that suggested\n+// replacement only removes one set of parentheses, rather than na\u00efvely\n+// stripping away any starting or ending parenthesis characters\u2014hence this\n+// test of the JSON error format.\n+\n+\n+#![deny(clippy::unused_unit)]\n+#![allow(clippy::needless_return)]\n+\n+struct Unitter;\n+\n+impl Unitter {\n+    // try to disorient the lint with multiple unit returns and newlines\n+    pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) ->\n+        ()\n+    where G: Fn() -> () {\n+        let _y: &Fn() -> () = &f;\n+        (); // this should not lint, as it's not in return type position\n+    }\n+}\n+\n+impl Into<()> for Unitter {\n+    fn into(self) -> () {\n+        ()\n+    }\n+}\n+\n+fn return_unit() -> () { () }\n+\n+fn main() {\n+    let u = Unitter;\n+    assert_eq!(u.get_unit(|| {}, return_unit), u.into());\n+    return_unit();\n+    loop {\n+        break();\n+    }\n+    return();\n+}"}, {"sha": "b5d5bdbcbee391cb8950449a2be4a99e6d3f8b7c", "filename": "tests/ui/unused_unit.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/tests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.stderr?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -0,0 +1,52 @@\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:28:59\n+   |\n+28 |       pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) ->\n+   |  ___________________________________________________________^\n+29 | |         ()\n+   | |__________^ help: remove the `-> ()`\n+   |\n+note: lint level defined here\n+  --> $DIR/unused_unit.rs:21:9\n+   |\n+21 | #![deny(clippy::unused_unit)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:37:19\n+   |\n+37 |     fn into(self) -> () {\n+   |                   ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit expression\n+  --> $DIR/unused_unit.rs:38:9\n+   |\n+38 |         ()\n+   |         ^^ help: remove the final `()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:42:18\n+   |\n+42 | fn return_unit() -> () { () }\n+   |                  ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit expression\n+  --> $DIR/unused_unit.rs:42:26\n+   |\n+42 | fn return_unit() -> () { () }\n+   |                          ^^ help: remove the final `()`\n+\n+error: unneeded `()`\n+  --> $DIR/unused_unit.rs:49:14\n+   |\n+49 |         break();\n+   |              ^^ help: remove the `()`\n+\n+error: unneeded `()`\n+  --> $DIR/unused_unit.rs:51:11\n+   |\n+51 |     return();\n+   |           ^^ help: remove the `()`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "277eeaf39f4ea1c65e5be5c1005d6db15c64268e", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9f637288cfd757d7177e0157caf98f917a54b719/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/9f637288cfd757d7177e0157caf98f917a54b719/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=9f637288cfd757d7177e0157caf98f917a54b719", "patch": "@@ -167,6 +167,19 @@ <h4 class=\"list-group-item-heading\">\n             });\n         }\n \n+        function selectGroup($scope, selectedGroup) {\n+            var groups = $scope.groups;\n+            for (var group in groups) {\n+                if (groups.hasOwnProperty(group)) {\n+                    if (group === selectedGroup) {\n+                        groups[group] = true;\n+                    } else {\n+                        groups[group] = false;\n+                    }\n+                }\n+            }\n+        }\n+\n         angular.module(\"clippy\", [])\n         .filter('markdown', function ($sce) {\n             return function (text) {\n@@ -223,6 +236,11 @@ <h4 class=\"list-group-item-heading\">\n                     return result;\n                 }, {});\n \n+                var selectedGroup = getQueryVariable(\"sel\");\n+                if (selectedGroup) {\n+                    selectGroup($scope, selectedGroup.toLowerCase());\n+                }\n+\n                 scrollToLintByURL($scope);\n             })\n             .error(function (data) {\n@@ -243,6 +261,17 @@ <h4 class=\"list-group-item-heading\">\n             }, false);\n         });\n     })();\n+\n+    function getQueryVariable(variable) {\n+        var query = window.location.search.substring(1);\n+        var vars = query.split('&');\n+        for (var i = 0; i < vars.length; i++) {\n+            var pair = vars[i].split('=');\n+            if (decodeURIComponent(pair[0]) == variable) {\n+                return decodeURIComponent(pair[1]);\n+            }\n+        }\n+    }\n     </script>\n </body>\n </html>"}]}