{"sha": "314fe4d170eae08a3f5c991133946d761e077280", "node_id": "C_kwDOAAsO6NoAKDMxNGZlNGQxNzBlYWUwOGEzZjVjOTkxMTMzOTQ2ZDc2MWUwNzcyODA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-21T22:01:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-21T22:01:58Z"}, "message": "Rollup merge of #104239 - b-naber:sccs-info, r=jackh726\n\nBetter debug logs for borrowck constraint graph\n\nIt's really cumbersome to work with `RegionVar`s when trying to debug borrowck code or when trying to understand how the borrowchecker works. This PR collects some region information (behind `cfg(debug_assertions)`) for created `RegionVar`s (NLL region vars, this PR doesn't touch canonicalization) and prints the nodes and edges of the strongly connected constraints graph using representatives that use that region information (either lifetime names, locations in MIR or spans).", "tree": {"sha": "6a693b09209d1382d7ec06e0228453799dc6f212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a693b09209d1382d7ec06e0228453799dc6f212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/314fe4d170eae08a3f5c991133946d761e077280", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj9T9WCRBK7hj4Ov3rIwAAwWoIACjTnjAUvjiz07ew1T2BGyWN\nyOuYUEpK6SO9I5O80F4t9IB/N1t2QQUl0He1YKcrKMOoyutvJhDFcxn8mH60xK5m\nL6i3esbkEb9jrfOVzwl4K92ru1QFDjxPQk0RQOqQ1lsyBcBqGqA9twC+mNAFm/Kh\nLpsW7x6n8H7kXHos2Pc6oY4H72BxV6XV3YKdd4MxiuOgiPwcrbhoD0/piPbU/H7B\nUzHqvU0x0o1aZz0Bs9GWAVSWq+lJ8hdQS+NT1yuDbKaX6m1TA7Km7m7lI+g3JL41\nL6ZJPcsS5o5PUWJx3Tr7UuLTi387OMhXB1PQkmW71LImbG0kETLZYCNzw489BVs=\n=0IqN\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a693b09209d1382d7ec06e0228453799dc6f212\nparent f4c7596ac3f2d27578787da3279705fd45aefbd6\nparent 8252a6eddfc59328fe6ac36ef09feb2844f28fa2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677016918 +0100\ncommitter GitHub <noreply@github.com> 1677016918 +0100\n\nRollup merge of #104239 - b-naber:sccs-info, r=jackh726\n\nBetter debug logs for borrowck constraint graph\n\nIt's really cumbersome to work with `RegionVar`s when trying to debug borrowck code or when trying to understand how the borrowchecker works. This PR collects some region information (behind `cfg(debug_assertions)`) for created `RegionVar`s (NLL region vars, this PR doesn't touch canonicalization) and prints the nodes and edges of the strongly connected constraints graph using representatives that use that region information (either lifetime names, locations in MIR or spans).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/314fe4d170eae08a3f5c991133946d761e077280", "html_url": "https://github.com/rust-lang/rust/commit/314fe4d170eae08a3f5c991133946d761e077280", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/314fe4d170eae08a3f5c991133946d761e077280/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4c7596ac3f2d27578787da3279705fd45aefbd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c7596ac3f2d27578787da3279705fd45aefbd6", "html_url": "https://github.com/rust-lang/rust/commit/f4c7596ac3f2d27578787da3279705fd45aefbd6"}, {"sha": "8252a6eddfc59328fe6ac36ef09feb2844f28fa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8252a6eddfc59328fe6ac36ef09feb2844f28fa2", "html_url": "https://github.com/rust-lang/rust/commit/8252a6eddfc59328fe6ac36ef09feb2844f28fa2"}], "stats": {"total": 506, "additions": 438, "deletions": 68}, "files": [{"sha": "f370c02161b115590e2333b39f4d1c6866e653e2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -17,7 +17,7 @@ pub(crate) mod graph;\n /// constraints of the form `R1: R2`. Each constraint is identified by\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Debug, Default)]\n pub(crate) struct OutlivesConstraintSet<'tcx> {\n     outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }"}, {"sha": "622b57c7b7f2b20f73b6b59835dce177748529c2", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -25,7 +25,9 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{\n+    DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n+};\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n     Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n@@ -43,6 +45,7 @@ use smallvec::SmallVec;\n use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::ops::Deref;\n use std::rc::Rc;\n \n use rustc_mir_dataflow::impls::{\n@@ -94,6 +97,7 @@ use nll::{PoloniusOutput, ToRegionVid};\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n+use renumber::RegionCtxt;\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n@@ -167,10 +171,10 @@ fn do_mir_borrowck<'tcx>(\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.with_opt_param().as_local().unwrap();\n-\n     debug!(?def);\n \n     let tcx = infcx.tcx;\n+    let infcx = BorrowckInferCtxt::new(infcx);\n     let param_env = tcx.param_env(def.did);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n@@ -218,7 +222,7 @@ fn do_mir_borrowck<'tcx>(\n     let mut body_owned = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, param_env, &mut body_owned, &mut promoted);\n+        nll::replace_regions_in_mir(&infcx, param_env, &mut body_owned, &mut promoted);\n     let body = &body_owned; // no further changes\n \n     let location_table_owned = LocationTable::new(body);\n@@ -256,7 +260,7 @@ fn do_mir_borrowck<'tcx>(\n         opt_closure_req,\n         nll_errors,\n     } = nll::compute_regions(\n-        infcx,\n+        &infcx,\n         free_regions,\n         body,\n         &promoted,\n@@ -271,12 +275,12 @@ fn do_mir_borrowck<'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);\n+    nll::dump_mir_results(&infcx, &body, &regioncx, &opt_closure_req);\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n-        infcx,\n+        &infcx,\n         &body,\n         &regioncx,\n         &opt_closure_req,\n@@ -320,7 +324,7 @@ fn do_mir_borrowck<'tcx>(\n \n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n-                infcx,\n+                infcx: &infcx,\n                 param_env,\n                 body: promoted_body,\n                 move_data: &move_data,\n@@ -349,7 +353,7 @@ fn do_mir_borrowck<'tcx>(\n     }\n \n     let mut mbcx = MirBorrowckCtxt {\n-        infcx,\n+        infcx: &infcx,\n         param_env,\n         body,\n         move_data: &mdpe.move_data,\n@@ -481,8 +485,84 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n     pub location_table: LocationTable,\n }\n \n+pub struct BorrowckInferCtxt<'cx, 'tcx> {\n+    pub(crate) infcx: &'cx InferCtxt<'tcx>,\n+    pub(crate) reg_var_to_origin: RefCell<FxHashMap<ty::RegionVid, RegionCtxt>>,\n+}\n+\n+impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n+    pub(crate) fn new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n+        BorrowckInferCtxt { infcx, reg_var_to_origin: RefCell::new(Default::default()) }\n+    }\n+\n+    pub(crate) fn next_region_var<F>(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        get_ctxt_fn: F,\n+    ) -> ty::Region<'tcx>\n+    where\n+        F: Fn() -> RegionCtxt,\n+    {\n+        let next_region = self.infcx.next_region_var(origin);\n+        let vid = next_region\n+            .as_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        if cfg!(debug_assertions) {\n+            debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+            let ctxt = get_ctxt_fn();\n+            let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(vid, ctxt);\n+\n+            // This only makes sense if not called in a canonicalization context. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        next_region\n+    }\n+\n+    #[instrument(skip(self, get_ctxt_fn), level = \"debug\")]\n+    pub(crate) fn next_nll_region_var<F>(\n+        &self,\n+        origin: NllRegionVariableOrigin,\n+        get_ctxt_fn: F,\n+    ) -> ty::Region<'tcx>\n+    where\n+        F: Fn() -> RegionCtxt,\n+    {\n+        let next_region = self.infcx.next_nll_region_var(origin.clone());\n+        let vid = next_region\n+            .as_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        if cfg!(debug_assertions) {\n+            debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+            let ctxt = get_ctxt_fn();\n+            let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(vid, ctxt);\n+\n+            // This only makes sense if not called in a canonicalization context. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        next_region\n+    }\n+}\n+\n+impl<'cx, 'tcx> Deref for BorrowckInferCtxt<'cx, 'tcx> {\n+    type Target = InferCtxt<'tcx>;\n+\n+    fn deref(&self) -> &'cx Self::Target {\n+        self.infcx\n+    }\n+}\n+\n struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "e5dbb83dd0728e6951daa40bef2a62e1bde61d1f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -5,7 +5,6 @@\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n@@ -37,7 +36,7 @@ use crate::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n-    Upvar,\n+    BorrowckInferCtxt, Upvar,\n };\n \n pub type PoloniusOutput = Output<RustcFacts>;\n@@ -58,7 +57,7 @@ pub(crate) struct NllOutput<'tcx> {\n /// `compute_regions`.\n #[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n pub(crate) fn replace_regions_in_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n@@ -157,7 +156,7 @@ fn populate_polonius_move_facts(\n ///\n /// This may result in errors being reported.\n pub(crate) fn compute_regions<'cx, 'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -259,6 +258,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     );\n \n     let mut regioncx = RegionInferenceContext::new(\n+        infcx,\n         var_origins,\n         universal_regions,\n         placeholder_indices,\n@@ -322,7 +322,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n }\n \n pub(super) fn dump_mir_results<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -372,7 +372,7 @@ pub(super) fn dump_mir_results<'tcx>(\n #[allow(rustc::diagnostic_outside_of_impl)]\n #[allow(rustc::untranslatable_diagnostic)]\n pub(super) fn dump_annotation<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "8c374c2164c7b2942c148999cabc4d73ec539da6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -34,6 +34,7 @@ use crate::{\n     },\n     type_check::{free_region_relations::UniversalRegionRelations, Locations},\n     universal_regions::UniversalRegions,\n+    BorrowckInferCtxt,\n };\n \n mod dump_mir;\n@@ -243,6 +244,70 @@ pub enum ExtraConstraintInfo {\n     PlaceholderFromPredicate(Span),\n }\n \n+#[instrument(skip(infcx, sccs), level = \"debug\")]\n+fn sccs_info<'cx, 'tcx>(\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n+    sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+) {\n+    use crate::renumber::RegionCtxt;\n+\n+    let var_to_origin = infcx.reg_var_to_origin.borrow();\n+\n+    let mut var_to_origin_sorted = var_to_origin.clone().into_iter().collect::<Vec<_>>();\n+    var_to_origin_sorted.sort_by(|a, b| a.0.cmp(&b.0));\n+    let mut debug_str = \"region variables to origins:\\n\".to_string();\n+    for (reg_var, origin) in var_to_origin_sorted.into_iter() {\n+        debug_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n+    }\n+    debug!(debug_str);\n+\n+    let num_components = sccs.scc_data().ranges().len();\n+    let mut components = vec![FxHashSet::default(); num_components];\n+\n+    for (reg_var_idx, scc_idx) in sccs.scc_indices().iter().enumerate() {\n+        let reg_var = ty::RegionVid::from_usize(reg_var_idx);\n+        let origin = var_to_origin.get(&reg_var).unwrap_or_else(|| &RegionCtxt::Unknown);\n+        components[scc_idx.as_usize()].insert((reg_var, *origin));\n+    }\n+\n+    let mut components_str = \"strongly connected components:\".to_string();\n+    for (scc_idx, reg_vars_origins) in components.iter().enumerate() {\n+        let regions_info = reg_vars_origins.clone().into_iter().collect::<Vec<_>>();\n+        components_str.push_str(&format!(\n+            \"{:?}: {:?})\",\n+            ConstraintSccIndex::from_usize(scc_idx),\n+            regions_info,\n+        ))\n+    }\n+    debug!(components_str);\n+\n+    // calculate the best representative for each component\n+    let components_representatives = components\n+        .into_iter()\n+        .enumerate()\n+        .map(|(scc_idx, region_ctxts)| {\n+            let repr = region_ctxts\n+                .into_iter()\n+                .map(|reg_var_origin| reg_var_origin.1)\n+                .max_by(|x, y| x.preference_value().cmp(&y.preference_value()))\n+                .unwrap();\n+\n+            (ConstraintSccIndex::from_usize(scc_idx), repr)\n+        })\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut scc_node_to_edges = FxHashMap::default();\n+    for (scc_idx, repr) in components_representatives.iter() {\n+        let edges_range = sccs.scc_data().ranges()[*scc_idx].clone();\n+        let edges = &sccs.scc_data().all_successors()[edges_range];\n+        let edge_representatives =\n+            edges.iter().map(|scc_idx| components_representatives[scc_idx]).collect::<Vec<_>>();\n+        scc_node_to_edges.insert((scc_idx, repr), edge_representatives);\n+    }\n+\n+    debug!(\"SCC edges {:#?}\", scc_node_to_edges);\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -251,7 +316,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// The `outlives_constraints` and `type_tests` are an initial set\n     /// of constraints produced by the MIR type check.\n-    pub(crate) fn new(\n+    pub(crate) fn new<'cx>(\n+        _infcx: &BorrowckInferCtxt<'cx, 'tcx>,\n         var_infos: VarInfos,\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n@@ -263,6 +329,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n+        debug!(\"universal_regions: {:#?}\", universal_regions);\n+        debug!(\"outlives constraints: {:#?}\", outlives_constraints);\n+        debug!(\"placeholder_indices: {:#?}\", placeholder_indices);\n+        debug!(\"type tests: {:#?}\", type_tests);\n+\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .iter()\n@@ -274,6 +345,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let fr_static = universal_regions.fr_static;\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n+        if cfg!(debug_assertions) {\n+            sccs_info(_infcx, constraint_sccs.clone());\n+        }\n+\n         let mut scc_values =\n             RegionValues::new(elements, universal_regions.len(), &placeholder_indices);\n "}, {"sha": "c361357ca2134462f55a0be0b281010362b409c8", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -181,7 +181,7 @@ impl<N: Idx> LivenessValues<N> {\n /// Maps from `ty::PlaceholderRegion` values that are used in the rest of\n /// rustc to the internal `PlaceholderIndex` values that are used in\n /// NLL.\n-#[derive(Default)]\n+#[derive(Debug, Default)]\n pub(crate) struct PlaceholderIndices {\n     indices: FxIndexSet<ty::PlaceholderRegion>,\n }"}, {"sha": "960dedc74efbbaf6db2dc869b964f26b91a31f16", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -1,18 +1,20 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::BorrowckInferCtxt;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::Constant;\n use rustc_middle::mir::{Body, Location, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::{Span, Symbol};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n #[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n@@ -29,27 +31,68 @@ pub fn renumber_mir<'tcx>(\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n-#[instrument(skip(infcx), level = \"debug\")]\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> T\n+#[instrument(skip(infcx, get_ctxt_fn), level = \"debug\")]\n+pub(crate) fn renumber_regions<'tcx, T, F>(\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n+    value: T,\n+    get_ctxt_fn: F,\n+) -> T\n where\n     T: TypeFoldable<'tcx>,\n+    F: Fn() -> RegionCtxt,\n {\n     infcx.tcx.fold_regions(value, |_region, _depth| {\n         let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n-        infcx.next_nll_region_var(origin)\n+        infcx.next_nll_region_var(origin, || get_ctxt_fn())\n     })\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum BoundRegionInfo {\n+    Name(Symbol),\n+    Span(Span),\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum RegionCtxt {\n+    Location(Location),\n+    TyContext(TyContext),\n+    Free(Symbol),\n+    Bound(BoundRegionInfo),\n+    LateBound(BoundRegionInfo),\n+    Existential(Option<Symbol>),\n+    Placeholder(BoundRegionInfo),\n+    Unknown,\n+}\n+\n+impl RegionCtxt {\n+    /// Used to determine the representative of a component in the strongly connected\n+    /// constraint graph\n+    pub(crate) fn preference_value(self) -> usize {\n+        let _anon = Symbol::intern(\"anon\");\n+\n+        match self {\n+            RegionCtxt::Unknown => 1,\n+            RegionCtxt::Existential(None) => 2,\n+            RegionCtxt::Existential(Some(_anon)) | RegionCtxt::Free(_anon) => 2,\n+            RegionCtxt::Location(_) => 3,\n+            RegionCtxt::TyContext(_) => 4,\n+            _ => 5,\n+        }\n+    }\n+}\n+\n struct NllVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n-    fn renumber_regions<T>(&mut self, value: T) -> T\n+    fn renumber_regions<T, F>(&mut self, value: T, region_ctxt_fn: F) -> T\n     where\n         T: TypeFoldable<'tcx>,\n+        F: Fn() -> RegionCtxt,\n     {\n-        renumber_regions(self.infcx, value)\n+        renumber_regions(self.infcx, value, region_ctxt_fn)\n     }\n }\n \n@@ -60,30 +103,30 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        *ty = self.renumber_regions(*ty);\n+        *ty = self.renumber_regions(*ty, || RegionCtxt::TyContext(ty_context));\n \n         debug!(?ty);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(*substs);\n+        *substs = self.renumber_regions(*substs, || RegionCtxt::Location(location));\n \n         debug!(?substs);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n         let old_region = *region;\n-        *region = self.renumber_regions(old_region);\n+        *region = self.renumber_regions(old_region, || RegionCtxt::Location(location));\n \n         debug!(?region);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n         let literal = constant.literal;\n-        constant.literal = self.renumber_regions(literal);\n+        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(_location));\n         debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "f14f8f1906be737e048f49aa23072d4103db9a3b", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -64,7 +64,7 @@ use crate::{\n     region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n-    Upvar,\n+    BorrowckInferCtxt, Upvar,\n };\n \n macro_rules! span_mirbug {\n@@ -123,7 +123,7 @@ mod relate_tys;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n /// - `elements` -- MIR region map\n pub(crate) fn type_check<'mir, 'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -866,7 +866,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n struct TypeChecker<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n     body: &'a Body<'tcx>,\n@@ -1019,7 +1019,7 @@ impl Locations {\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'tcx>,\n+        infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -1356,11 +1356,34 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 };\n                 let (sig, map) = tcx.replace_late_bound_regions(sig, |br| {\n-                    self.infcx.next_region_var(LateBoundRegion(\n-                        term.source_info.span,\n-                        br.kind,\n-                        LateBoundRegionConversionTime::FnCall,\n-                    ))\n+                    use crate::renumber::{BoundRegionInfo, RegionCtxt};\n+                    use rustc_span::Symbol;\n+\n+                    let region_ctxt_fn = || {\n+                        let reg_info = match br.kind {\n+                            ty::BoundRegionKind::BrAnon(_, Some(span)) => {\n+                                BoundRegionInfo::Span(span)\n+                            }\n+                            ty::BoundRegionKind::BrAnon(..) => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"anon\"))\n+                            }\n+                            ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+                            ty::BoundRegionKind::BrEnv => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"env\"))\n+                            }\n+                        };\n+\n+                        RegionCtxt::LateBound(reg_info)\n+                    };\n+\n+                    self.infcx.next_region_var(\n+                        LateBoundRegion(\n+                            term.source_info.span,\n+                            br.kind,\n+                            LateBoundRegionConversionTime::FnCall,\n+                        ),\n+                        region_ctxt_fn,\n+                    )\n                 });\n                 debug!(?sig);\n                 // IMPORTANT: We have to prove well formed for the function signature before"}, {"sha": "d96372fb99baab5c4c38b4228dee79ca0bb340c3", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -4,11 +4,12 @@ use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::type_check::{InstantiateOpaqueType, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -100,23 +101,65 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         universe\n     }\n \n-    fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn next_existential_region_var(\n+        &mut self,\n+        from_forall: bool,\n+        _name: Option<Symbol>,\n+    ) -> ty::Region<'tcx> {\n         let origin = NllRegionVariableOrigin::Existential { from_forall };\n-        self.type_checker.infcx.next_nll_region_var(origin)\n+\n+        let reg_var =\n+            self.type_checker.infcx.next_nll_region_var(origin, || RegionCtxt::Existential(_name));\n+\n+        reg_var\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.type_checker\n+        let reg = self\n+            .type_checker\n             .borrowck_context\n             .constraints\n-            .placeholder_region(self.type_checker.infcx, placeholder)\n+            .placeholder_region(self.type_checker.infcx, placeholder);\n+\n+        let reg_info = match placeholder.name {\n+            ty::BoundRegionKind::BrAnon(_, Some(span)) => BoundRegionInfo::Span(span),\n+            ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(Symbol::intern(\"anon\")),\n+            ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+            ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(Symbol::intern(\"env\")),\n+        };\n+\n+        let reg_var =\n+            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n+        let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+        let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+        assert!(matches!(prev, None));\n+\n+        reg\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n-        self.type_checker.infcx.next_nll_region_var_in_universe(\n+        let reg = self.type_checker.infcx.next_nll_region_var_in_universe(\n             NllRegionVariableOrigin::Existential { from_forall: false },\n             universe,\n-        )\n+        );\n+\n+        let reg_var =\n+            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n+\n+        if cfg!(debug_assertions) {\n+            let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+            let prev = var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n+\n+            // It only makes sense to track region vars in non-canonicalization contexts. If this\n+            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+            // or modify how we track nll region vars for that map.\n+            assert!(matches!(prev, None));\n+        }\n+\n+        reg\n     }\n \n     fn push_outlives("}, {"sha": "f3ca896cd0de1d3598261a3ec8c6d48cefe2eacb", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -20,15 +20,18 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{\n     self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n };\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n+use rustc_span::Symbol;\n use std::iter;\n \n use crate::nll::ToRegionVid;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n+use crate::BorrowckInferCtxt;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n@@ -224,7 +227,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'tcx>,\n+        infcx: &BorrowckInferCtxt<'_, 'tcx>,\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -385,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n }\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -403,7 +406,10 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n-        let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        let fr_static = self\n+            .infcx\n+            .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"static\")))\n+            .to_region_vid();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -435,7 +441,17 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 |r| {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n-                        let region_vid = self.infcx.next_nll_region_var(FR);\n+                        let region_vid = {\n+                            let name = match r.get_name() {\n+                                Some(name) => name,\n+                                _ => Symbol::intern(\"anon\"),\n+                            };\n+\n+                            self.infcx.next_nll_region_var(FR, || {\n+                                RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                            })\n+                        };\n+\n                         debug!(?region_vid);\n                         indices.insert_late_bound_region(r, region_vid.to_region_vid());\n                     }\n@@ -463,7 +479,17 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.infcx.next_nll_region_var(FR);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.infcx.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -480,8 +506,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     LangItem::VaList,\n                     Some(self.infcx.tcx.def_span(self.mir_def.did)),\n                 );\n-                let region =\n-                    self.infcx.tcx.mk_re_var(self.infcx.next_nll_region_var(FR).to_region_vid());\n+\n+                let reg_vid = self\n+                    .infcx\n+                    .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n+                    .to_region_vid();\n+\n+                let region = self.infcx.tcx.mk_re_var(reg_vid);\n                 let va_list_ty =\n                     self.infcx.tcx.type_of(va_list_did).subst(self.infcx.tcx, &[region.into()]);\n \n@@ -491,7 +522,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n         }\n \n-        let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        let fr_fn_body = self\n+            .infcx\n+            .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n+            .to_region_vid();\n+\n         let num_universals = self.infcx.num_region_vars();\n \n         debug!(\"build: global regions = {}..{}\", FIRST_GLOBAL_INDEX, first_extern_index);\n@@ -718,7 +753,8 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -727,7 +763,17 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.fold_regions(value, |_region, _depth| self.next_nll_region_var(origin))\n+        self.infcx.tcx.fold_regions(value, |region, _depth| {\n+            let name = match region.get_name() {\n+                Some(name) => name,\n+                _ => Symbol::intern(\"anon\"),\n+            };\n+            debug!(?region, ?name);\n+\n+            let reg_var = self.next_nll_region_var(origin, || RegionCtxt::Free(name));\n+\n+            reg_var\n+        })\n     }\n \n     #[instrument(level = \"debug\", skip(self, indices))]\n@@ -744,7 +790,15 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(?br);\n             let liberated_region = self.tcx.mk_re_free(all_outlive_scope.to_def_id(), br.kind);\n-            let region_vid = self.next_nll_region_var(origin);\n+            let region_vid = {\n+                let name = match br.kind.get_name() {\n+                    Some(name) => name,\n+                    _ => Symbol::intern(\"anon\"),\n+                };\n+\n+                self.next_nll_region_var(origin, || RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n+            };\n+\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n@@ -770,7 +824,17 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.next_nll_region_var(FR);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -786,8 +850,17 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n-                let region_vid = self.next_nll_region_var(FR);\n-                debug!(?region_vid);\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, || {\n+                        RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n+                    })\n+                };\n+\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}, {"sha": "c4b11951ab7a08d477005d57ea2e2eb03a032887", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -27,7 +27,7 @@ pub struct Sccs<N: Idx, S: Idx> {\n     scc_data: SccData<S>,\n }\n \n-struct SccData<S: Idx> {\n+pub struct SccData<S: Idx> {\n     /// For each SCC, the range of `all_successors` where its\n     /// successors can be found.\n     ranges: IndexVec<S, Range<usize>>,\n@@ -43,6 +43,14 @@ impl<N: Idx, S: Idx + Ord> Sccs<N, S> {\n         SccsConstruction::construct(graph)\n     }\n \n+    pub fn scc_indices(&self) -> &IndexVec<N, S> {\n+        &self.scc_indices\n+    }\n+\n+    pub fn scc_data(&self) -> &SccData<S> {\n+        &self.scc_data\n+    }\n+\n     /// Returns the number of SCCs in the graph.\n     pub fn num_sccs(&self) -> usize {\n         self.scc_data.len()\n@@ -115,6 +123,14 @@ impl<S: Idx> SccData<S> {\n         self.ranges.len()\n     }\n \n+    pub fn ranges(&self) -> &IndexVec<S, Range<usize>> {\n+        &self.ranges\n+    }\n+\n+    pub fn all_successors(&self) -> &Vec<S> {\n+        &self.all_successors\n+    }\n+\n     /// Returns the successors of the given SCC.\n     fn successors(&self, scc: S) -> &[S] {\n         // Annoyingly, `range` does not implement `Copy`, so we have"}, {"sha": "e993fb4c22bb989d33c73d2f60e2190696284ff9", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n use std::iter;\n \n@@ -683,7 +683,11 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(\n+        &mut self,\n+        from_forall: bool,\n+        _name: Option<Symbol>,\n+    ) -> ty::Region<'tcx> {\n         let origin = NllRegionVariableOrigin::Existential { from_forall };\n         self.infcx.next_nll_region_var(origin)\n     }"}, {"sha": "29c9af5c43fb9b227cf4a6ae9001ff7c1f0362aa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -1111,11 +1111,13 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::Nll(origin))\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var_in_universe(\n         &self,\n         origin: NllRegionVariableOrigin,"}, {"sha": "954334e88b0cbf7d87dd2cb19c63d6c81750fa62", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{ir::TypeVisitor, TypeSuperVisitable, TypeVisitable};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n@@ -100,7 +100,11 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n-    fn next_existential_region_var(&mut self, was_placeholder: bool) -> ty::Region<'tcx>;\n+    fn next_existential_region_var(\n+        &mut self,\n+        was_placeholder: bool,\n+        name: Option<Symbol>,\n+    ) -> ty::Region<'tcx>;\n \n     /// Creates a new region variable representing a\n     /// higher-ranked region that is instantiated universally.\n@@ -188,7 +192,7 @@ where\n                     let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n                     delegate.next_placeholder_region(placeholder)\n                 } else {\n-                    delegate.next_existential_region_var(true)\n+                    delegate.next_existential_region_var(true, br.kind.get_name())\n                 }\n             }\n         };"}, {"sha": "7f0935fb149fa4863020777bf93a5ead94eb315a", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -1214,7 +1214,7 @@ impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting."}, {"sha": "35ff71d888501915dfd7f02c8a0ab34e0dac4158", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/314fe4d170eae08a3f5c991133946d761e077280/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=314fe4d170eae08a3f5c991133946d761e077280", "patch": "@@ -1751,6 +1751,13 @@ impl<'tcx> Region<'tcx> {\n     pub fn is_var(self) -> bool {\n         matches!(self.kind(), ty::ReVar(_))\n     }\n+\n+    pub fn as_var(self) -> Option<RegionVid> {\n+        match self.kind() {\n+            ty::ReVar(vid) => Some(vid),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Type utilities"}]}