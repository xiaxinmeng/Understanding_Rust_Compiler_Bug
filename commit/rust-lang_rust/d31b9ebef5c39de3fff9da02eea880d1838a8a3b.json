{"sha": "d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMWI5ZWJlZjVjMzlkZTNmZmY5ZGEwMmVlYTg4MGQxODM4YThhM2I=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-17T17:29:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:02Z"}, "message": "Implement `<T>::method` UFCS expression syntax.", "tree": {"sha": "320decdd7d81877f5db694e6bc6baa322f6487ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/320decdd7d81877f5db694e6bc6baa322f6487ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "html_url": "https://github.com/rust-lang/rust/commit/d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdfb532d7829d6e5637ddffa6faff69e4312b0e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdfb532d7829d6e5637ddffa6faff69e4312b0e0", "html_url": "https://github.com/rust-lang/rust/commit/fdfb532d7829d6e5637ddffa6faff69e4312b0e0"}], "stats": {"total": 486, "additions": 286, "deletions": 200}, "files": [{"sha": "3c0d9e93ccb93aa2a3ec3d9af5185b4afb9a40e7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -437,7 +437,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(_) = ty.node {\n+        if let ast::TyPath(..) = ty.node {\n             self.check_def(ty.span, ty.id);\n         }\n         visit::walk_ty(self, ty);\n@@ -682,8 +682,8 @@ impl LintPass for PathStatements {\n         match s.node {\n             ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENTS, s.span,\n-                                                     \"path statement with no effect\"),\n+                    ast::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                                                      \"path statement with no effect\"),\n                     _ => ()\n                 }\n             }"}, {"sha": "a01b17ac194de0d4e90bd43f70246d7d00bbdfa6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -1221,7 +1221,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n-            ast::TyPath(ref path) if path.segments.len() == 1 => {\n+            ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n                 encode_impl_type_basename(rbml_w, ident);\n             }"}, {"sha": "17fd80ceaea428063654da274aef672114ca5b89", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -59,7 +59,7 @@ pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n-    if let ast::TyPath(ref path) = ast_ty.node {\n+    if let ast::TyPath(None, ref path) = ast_ty.node {\n         let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n             None => {\n                 tcx.sess.span_bug(ast_ty.span,"}, {"sha": "24c54b53590c04f57a4ff6eafe82f3179b9d3cfa", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -398,8 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprMac(..) |\n             ast::ExprClosure(..) |\n             ast::ExprLit(..) |\n-            ast::ExprPath(..) |\n-            ast::ExprQPath(..) => {\n+            ast::ExprPath(..) => {\n                 self.straightline(expr, pred, None::<ast::Expr>.iter())\n             }\n         }"}, {"sha": "8401d25024d3577e7fa4921445d7d03a0694393b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -439,7 +439,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {"}, {"sha": "b97978fc03fff33ae23e04c0cb05595511f2d380", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -93,8 +93,8 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                match self.def_map.borrow().get(&e.id).map(|d| d.full_def()) {\n+            ast::ExprPath(..) => {\n+                match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {"}, {"sha": "f793d3ce2fb4522c08aca64f0849c4022d18bf39", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -178,7 +178,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatVec(pats, None, vec![])\n         }\n \n-        ast::ExprPath(ref path) => {\n+        ast::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n@@ -194,13 +194,6 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             }\n         }\n \n-        ast::ExprQPath(_) => {\n-            match lookup_const(tcx, expr) {\n-                Some(actual) => return const_expr_to_pat(tcx, actual, span),\n-                _ => unreachable!()\n-            }\n-        }\n-\n         _ => ast::PatLit(P(expr.clone()))\n     };\n     P(ast::Pat { id: expr.id, node: pat, span: span })\n@@ -388,7 +381,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         cast_const(val, ety)\n       }\n-      ast::ExprPath(_) | ast::ExprQPath(_) => {\n+      ast::ExprPath(..) => {\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {"}, {"sha": "9c85b7748ab0c3449118daaf2502ea9ffbe44538", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }"}, {"sha": "a1e38a1c8bda795d4c35e304cb35bc4bc406fc32", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -422,7 +422,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.walk_expr(&**subexpr)\n             }\n \n-            ast::ExprPath(_) | ast::ExprQPath(_) => { }\n+            ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n                 if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {"}, {"sha": "da4df813030c3ab504f228b24935a4f1d5b4a79f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -1233,7 +1233,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref path) => {\n+                ast::TyPath(ref maybe_qself, ref path) => {\n                     let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n                         None => {\n                             self.tcx\n@@ -1277,9 +1277,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 region_names: region_names\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n+                            let qself = maybe_qself.as_ref().map(|qself| {\n+                                ast::QSelf {\n+                                    ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n+                                                                      anon_nums, region_names),\n+                                    position: qself.position\n+                                }\n+                            });\n                             let to = ast::Ty {\n                                 id: cur_ty.id,\n-                                node: ast::TyPath(new_path),\n+                                node: ast::TyPath(qself, new_path),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));"}, {"sha": "2ac019aa964dc6f1f0f15c9c4a17e917d8085a13", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -445,7 +445,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ast::ExprPath(_) | ast::ExprQPath(_) => {\n+      ast::ExprPath(..) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n@@ -947,7 +947,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n@@ -1275,7 +1275,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => succ,\n+            ast::ExprPath(..) => succ,\n             ast::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             ast::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                     -> LiveNode {\n         match expr.node {\n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n               self.access_path(expr, succ, acc)\n           }\n \n@@ -1468,7 +1468,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n       ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n-      ast::ExprRange(..) | ast::ExprQPath(..) => {\n+      ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {\n@@ -1561,7 +1561,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually"}, {"sha": "c4446b87855ca622d6a5ebd4fcca78f7ca0b9042", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -529,7 +529,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n             let def = self.tcx().def_map.borrow()[expr.id].full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }"}, {"sha": "45d565ec693807f63e74e3887839602091372ecd", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n \n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(d) => d.full_def(),\n                     None => {"}, {"sha": "a8a2887644a9da40a237e472e9f0e5a66985f4e4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_ty(this, ty);\n                 });\n             }\n-            ast::TyPath(ref path) => {\n+            ast::TyPath(None, ref path) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&ty.id).map(|d| (d.base_def, d.depth)) {"}, {"sha": "7b05e510852791377c7fb4530fc4aa5708417b86", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -4550,7 +4550,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     }\n \n     match expr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             match resolve_expr(tcx, expr) {\n                 def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n@@ -5838,7 +5838,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n-                ast::ExprPath(ast::Path {\n+                ast::ExprPath(None, ast::Path {\n                     global: false,\n                     ref segments,\n                     .."}, {"sha": "e16df61c25c47a9e83c97746f13b61ab3c13f41c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -244,8 +244,7 @@ mod svh_visitor {\n         SawExprAssignOp(ast::BinOp_),\n         SawExprIndex,\n         SawExprRange,\n-        SawExprPath,\n-        SawExprQPath,\n+        SawExprPath(Option<usize>),\n         SawExprAddrOf(ast::Mutability),\n         SawExprRet,\n         SawExprInlineAsm(&'a ast::InlineAsm),\n@@ -277,8 +276,7 @@ mod svh_visitor {\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprRange(..)            => SawExprRange,\n-            ExprPath(..)             => SawExprPath,\n-            ExprQPath(..)            => SawExprQPath,\n+            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(content)),\n             ExprAgain(id)            => SawExprAgain(id.map(content)),"}, {"sha": "29448c68c80b9a65330c613d33102740b7cc38c0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // * Private trait impls for private types can be completely ignored\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n-                    ast::TyPath(_) => {\n+                    ast::TyPath(..) => {\n                         match self.tcx.def_map.borrow()[ty.id].full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n@@ -325,7 +325,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemTy(ref ty, _) if public_first => {\n-                if let ast::TyPath(_) = ty.node {\n+                if let ast::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow()[ty.id].full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     // was private.\n                     ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                         match ty.node {\n-                            ast::TyPath(_) => {}\n+                            ast::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n                         let def = self.tcx.def_map.borrow()[ty.id].full_def();\n@@ -908,7 +908,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                                             struct type?!\"),\n                 }\n             }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 let guard = |did: ast::DefId| {\n                     let fields = ty::lookup_struct_fields(self.tcx, did);\n                     let any_priv = fields.iter().any(|f| {\n@@ -1254,7 +1254,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(_) = ty.node {\n+        if let ast::TyPath(..) = ty.node {\n             if self.inner.path_is_private_type(ty.id) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n@@ -1460,7 +1460,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        if let ast::TyPath(ref p) = t.node {\n+        if let ast::TyPath(_, ref p) = t.node {\n             if !self.tcx.sess.features.borrow().visible_private_types &&\n                 self.path_is_private_type(t.id) {\n                 self.tcx.sess.span_err(p.span,"}, {"sha": "cb7224f7cbfe82856e7f846edbd9a71bf6ab9890", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -65,7 +65,7 @@ use rustc::util::lev_distance::lev_distance;\n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n-use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n+use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n@@ -75,7 +75,7 @@ use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use syntax::ast::{TyPath, TyPtr, TyQPath};\n+use syntax::ast::{TyPath, TyPtr};\n use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem};\n use syntax::ast;\n@@ -2821,7 +2821,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n-                            ast::TypeTraitItem(_) => NoTypeParameters,\n+                            ast::TypeTraitItem(ref assoc_ty) => {\n+                                let ty_param = &assoc_ty.ty_param;\n+                                this.check_if_primitive_type_name(ty_param.ident.name,\n+                                                                  ty_param.span);\n+                                NoTypeParameters\n+                            }\n                         };\n                         this.with_type_parameter_rib(type_parameters, |this| {\n                             visit::walk_trait_item(this, trait_item)\n@@ -3243,14 +3248,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            // Like path expressions, the interpretation of path types depends\n-            // on whether the path has multiple elements in it or not.\n+            // `<T>::a::b::c` is resolved by typeck alone.\n+            TyPath(Some(ast::QSelf { position: 0, .. }), _) => {}\n \n-            TyPath(ref path) | TyQPath(ast::QPath { ref path, .. }) => {\n-                let max_assoc_types = if let TyQPath(_) = ty.node {\n+            TyPath(ref maybe_qself, ref path) => {\n+                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n                     // Make sure the trait is valid.\n                     let _ = self.resolve_trait_reference(ty.id, path, 1);\n-                    1\n+                    path.segments.len() - qself.position\n                 } else {\n                     path.segments.len()\n                 };\n@@ -3284,10 +3289,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // Keep reporting some errors even if they're ignored above.\n                         self.resolve_path(ty.id, path, 0, TypeNS, true);\n \n-                        let kind = match ty.node {\n-                            TyQPath(_) => \"associated type\",\n-                            _ => \"type name\"\n+                        let kind = if maybe_qself.is_some() {\n+                            \"associated type\"\n+                        } else {\n+                            \"type name\"\n                         };\n+\n                         let msg = format!(\"use of undeclared {} `{}`\", kind,\n                                           self.path_names_to_string(path, 0));\n                         self.resolve_error(ty.span, &msg[..]);\n@@ -3905,7 +3912,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         fn extract_path_and_node_id(t: &Ty, allow: FallbackChecks)\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n-                TyPath(ref path) => Some((path.clone(), t.id, allow)),\n+                TyPath(None, ref path) => Some((path.clone(), t.id, allow)),\n                 TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n                 TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n@@ -4063,14 +4070,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            // The interpretation of paths depends on whether the path has\n-            // multiple elements in it or not.\n+            // `<T>::a::b::c` is resolved by typeck alone.\n+            ExprPath(Some(ast::QSelf { position: 0, .. }), ref path) => {\n+                let method_name = path.segments.last().unwrap().identifier.name;\n+                let traits = self.search_for_traits_containing_method(method_name);\n+                self.trait_map.insert(expr.id, traits);\n+                visit::walk_expr(self, expr);\n+            }\n \n-            ExprPath(ref path) | ExprQPath(ast::QPath { ref path, .. }) => {\n-                let max_assoc_types = if let ExprQPath(_) = expr.node {\n+            ExprPath(ref maybe_qself, ref path) => {\n+                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n                     // Make sure the trait is valid.\n                     let _ = self.resolve_trait_reference(expr.id, path, 1);\n-                    1\n+                    path.segments.len() - qself.position\n                 } else {\n                     path.segments.len()\n                 };"}, {"sha": "ab7f3916728c5d8fb9616017703d901056f8ed6a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -659,7 +659,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n         match typ.node {\n             // Common case impl for a struct or something basic.\n-            ast::TyPath(ref path) => {\n+            ast::TyPath(None, ref path) => {\n                 let sub_span = self.span.sub_span_for_type_name(path.span);\n                 let self_id = self.lookup_type_ref(typ.id).map(|id| {\n                     self.fmt.ref_str(recorder::TypeRef,\n@@ -1306,7 +1306,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match t.node {\n-            ast::TyPath(ref path) => {\n+            ast::TyPath(_, ref path) => {\n                 match self.lookup_type_ref(t.id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(t.span);\n@@ -1338,7 +1338,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprPath(ref path) | ast::ExprQPath(ast::QPath { ref path, .. }) => {\n+            ast::ExprPath(_, ref path) => {\n                 self.process_path(ex.id, path.span, path, None);\n                 visit::walk_expr(self, ex);\n             }"}, {"sha": "9a121a8830b2b8d1b94d41e63e527463db1614f8", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -1277,7 +1277,7 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     let (vid, field) = match discr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => match bcx.def(discr.id) {\n+        ast::ExprPath(..) => match bcx.def(discr.id) {\n             def::DefLocal(vid) | def::DefUpvar(vid, _) => (vid, None),\n             _ => return false\n         },"}, {"sha": "59fcd5492ebde534e3be049a8331a631c9cc8dec", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -93,7 +93,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n         _ => {}"}, {"sha": "93ab4a96e6f561e5f419ba60046d0362edd7e839", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -193,7 +193,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           -> ValueRef {\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n-        ast::ExprPath(_) => {\n+        ast::ExprPath(..) => {\n             let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n             match def {\n                 def::DefConst(def_id) => {\n@@ -663,7 +663,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 C_array(llunitty, &vs[..])\n             }\n           }\n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow()[e.id].full_def();\n             match def {\n                 def::DefFn(..) | def::DefMethod(..) => {"}, {"sha": "d70a904b81189fde012837d6b320799e493eabe5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -3487,8 +3487,7 @@ fn create_scope_map(cx: &CrateContext,\n             ast::ExprLit(_)   |\n             ast::ExprBreak(_) |\n             ast::ExprAgain(_) |\n-            ast::ExprPath(_)  |\n-            ast::ExprQPath(_) => {}\n+            ast::ExprPath(..) => {}\n \n             ast::ExprCast(ref sub_exp, _)     |\n             ast::ExprAddrOf(_, ref sub_exp)  |"}, {"sha": "5cc1baf66c6219806e17520f42b2e224413ea45f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -143,7 +143,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // it prefers in-place instantiation, likely because it contains\n             // `[x; N]` somewhere within.\n             match expr.node {\n-                ast::ExprPath(_) | ast::ExprQPath(_) => {\n+                ast::ExprPath(..) => {\n                     match bcx.def(expr.id) {\n                         def::DefConst(did) => {\n                             let expr = consts::get_const_expr(bcx.ccx(), did, expr);\n@@ -629,7 +629,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprParen(ref e) => {\n             trans(bcx, &**e)\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         ast::ExprField(ref base, ident) => {\n@@ -1033,7 +1033,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprParen(ref e) => {\n             trans_into(bcx, &**e, dest)\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n         ast::ExprIf(ref cond, ref thn, ref els) => {"}, {"sha": "602f041222f2775f109e523486c52255e4ad9d94", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -52,6 +52,7 @@ use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n@@ -897,7 +898,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n      */\n \n     match ty.node {\n-        ast::TyPath(ref path) => {\n+        ast::TyPath(None, ref path) => {\n             let def = this.tcx().def_map.borrow().get(&ty.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefTrait(trait_def_id)) => {\n@@ -981,7 +982,13 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n     let assoc_name = item_segment.identifier.name;\n \n-    let ty_param_node_id = if let ty::ty_param(_) = ty.sty {\n+    let is_param = match (&ty.sty, ty_path_def) {\n+        (&ty::ty_param(_), def::DefTyParam(..)) |\n+        (&ty::ty_param(_), def::DefSelfTy(_)) => true,\n+        _ => false\n+    };\n+\n+    let ty_param_node_id = if is_param {\n         ty_path_def.local_node_id()\n     } else {\n         span_err!(tcx.sess, span, E0223,\n@@ -1195,9 +1202,14 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         segments.last().unwrap())\n         }\n         def::DefMod(id) => {\n-            tcx.sess.span_bug(span,\n-                              &format!(\"found module name used as a type: {}\",\n-                                       tcx.map.node_to_string(id.node)));\n+            // Used as sentinel by callers to indicate the `<T>::a::b::c` form.\n+            if segments.is_empty() {\n+                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n+            } else {\n+                tcx.sess.span_bug(span,\n+                                  &format!(\"found module name used as a type: {}\",\n+                                           tcx.map.node_to_string(id.node)));\n+            }\n         }\n         def::DefPrimTy(prim_ty) => {\n             prim_ty_to_ty(tcx, segments, prim_ty)\n@@ -1302,20 +1314,25 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         ast::TyPolyTraitRef(ref bounds) => {\n             conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n         }\n-        ast::TyPath(ref path) | ast::TyQPath(ast::QPath { ref path, .. }) => {\n+        ast::TyPath(ref maybe_qself, ref path) => {\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n                 d\n+            } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n+                // Create some fake resolution that can't possibly be a type.\n+                def::PathResolution {\n+                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n             } else {\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n             };\n             let mut def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n-            let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n-                Some(ast_ty_to_ty(this, rscope, &*qpath.self_type))\n-            } else {\n-                None\n-            };\n+            let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n+                ast_ty_to_ty(this, rscope, &qself.ty)\n+            });\n             let ty = finish_resolving_def_to_ty(this, rscope, ast_ty.span,\n                                                 PathParamMode::Explicit, &mut def,\n                                                 opt_self_ty,"}, {"sha": "f5d6d5baf9380b508c47a3a536d025d4ab480a0e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -91,6 +91,7 @@ use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n+use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n@@ -3397,7 +3398,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let mut checked = false;\n           opt_place.as_ref().map(|place| match place.node {\n-              ast::ExprPath(ref path) => {\n+              ast::ExprPath(None, ref path) => {\n                   // FIXME(pcwalton): For now we hardcode the two permissible\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n@@ -3590,16 +3591,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprPath(ref path) | ast::ExprQPath(ast::QPath { ref path, .. }) => {\n-          let opt_self_ty = if let ast::ExprQPath(ref qpath) = expr.node {\n-              Some(fcx.to_ty(&*qpath.self_type))\n-          } else {\n-              None\n-          };\n+      ast::ExprPath(ref maybe_qself, ref path) => {\n+          let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n+              fcx.to_ty(&qself.ty)\n+          });\n \n           let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n               d\n-          } else {\n+          } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n+                // Create some fake resolution that can't possibly be a type.\n+                def::PathResolution {\n+                    base_def: def::DefMod(local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n+            } else {\n               tcx.sess.span_bug(expr.span,\n                                 &format!(\"unbound path {}\", expr.repr(tcx))[])\n           };"}, {"sha": "7ed372d1b4b03e8aa01763d98e8c9098533c9a3f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -1683,20 +1683,15 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 index: u32)\n                 -> bool\n     {\n-        match ast_ty.node {\n-            ast::TyPath(_) => {\n-                match ccx.tcx.def_map.borrow()[ast_ty.id] {\n-                    def::DefTyParam(s, i, _, _) => {\n-                        space == s && index == i\n-                    }\n-                    _ => {\n-                        false\n-                    }\n-                }\n-            }\n-            _ => {\n+        if let ast::TyPath(None, _) = ast_ty.node {\n+            let path_res = ccx.tcx.def_map.borrow()[ast_ty.id];\n+            if let def::DefTyParam(s, i, _, _) = path_res.base_def {\n+                path_res.depth == 0 && space == s && index == i\n+            } else {\n                 false\n             }\n+        } else {\n+            false\n         }\n     }\n }"}, {"sha": "b88620d577f3766304fb24102bee2d2efee982a9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -1494,15 +1494,15 @@ impl Clean<Type> for ast::Ty {\n             TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n                                                            e.span.to_src(cx)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(ref p) => {\n+            TyPath(None, ref p) => {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n-            TyQPath(ref qp) => {\n-                let mut trait_path = qp.path.clone();\n+            TyPath(Some(ref qself), ref p) => {\n+                let mut trait_path = p.clone();\n                 trait_path.segments.pop();\n                 Type::QPath {\n-                    name: qp.path.segments.last().unwrap().identifier.clean(cx),\n-                    self_type: box qp.self_type.clean(cx),\n+                    name: p.segments.last().unwrap().identifier.clean(cx),\n+                    self_type: box qself.ty.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }"}, {"sha": "6d6fdffa95095b25c6fd6b5684df59d12d8ae611", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -753,11 +753,10 @@ pub enum Expr_ {\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n-    /// Variable reference, possibly containing `::` and/or\n-    /// type parameters, e.g. foo::bar::<baz>\n-    ExprPath(Path),\n-    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    ExprQPath(QPath),\n+    /// Variable reference, possibly containing `::` and/or type\n+    /// parameters, e.g. foo::bar::<baz>. Optionally \"qualified\",\n+    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    ExprPath(Option<QSelf>, Path),\n \n     ExprAddrOf(Mutability, P<Expr>),\n     ExprBreak(Option<Ident>),\n@@ -778,15 +777,22 @@ pub enum Expr_ {\n     ExprParen(P<Expr>)\n }\n \n-/// A \"qualified path\":\n+/// The explicit Self type in a \"qualified path\". The actual\n+/// path, including the trait and the associated item, is stored\n+/// sepparately. `position` represents the index of the associated\n+/// item qualified with this Self type.\n ///\n-///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n-///      ^~~~~     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-///      self_type  path\n+///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///      ^~~~~     ~~~~~~~~~~~~~~^\n+///      ty        position = 3\n+///\n+///     <Vec<T>>::AssociatedItem\n+///      ^~~~~    ^\n+///      ty       position = 0\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct QPath {\n-    pub self_type: P<Ty>,\n-    pub path: Path,\n+pub struct QSelf {\n+    pub ty: P<Ty>,\n+    pub position: usize\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1253,12 +1259,11 @@ pub enum Ty_ {\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(Vec<P<Ty>> ),\n-    /// A path (`module::module::...::Type`) or primitive\n+    /// A path (`module::module::...::Type`), optionally\n+    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n-    TyPath(Path),\n-    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    TyQPath(QPath),\n+    TyPath(Option<QSelf>, Path),\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`"}, {"sha": "79f0433761da531ec4a01d34401a344ce1efed58", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -134,7 +134,7 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n }\n \n pub fn is_path(e: P<Expr>) -> bool {\n-    return match e.node { ExprPath(_) => true, _ => false };\n+    match e.node { ExprPath(..) => true, _ => false }\n }\n \n /// Get a string representation of a signed int type, with its value."}, {"sha": "d916651b05617d25cedd8bd6f06867eba885f712", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -43,14 +43,14 @@ pub trait AstBuilder {\n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n              ident: ast::Ident)\n-             -> ast::QPath;\n+             -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n                 ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<P<ast::TypeBinding>>)\n-                -> ast::QPath;\n+                -> (ast::QSelf, ast::Path);\n \n     // types\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n@@ -114,7 +114,7 @@ pub trait AstBuilder {\n     // expressions\n     fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n-    fn expr_qpath(&self, span: Span, qpath: ast::QPath) -> P<ast::Expr>;\n+    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n@@ -351,7 +351,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n              ident: ast::Ident)\n-             -> ast::QPath {\n+             -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n \n@@ -365,7 +365,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<P<ast::TypeBinding>>)\n-                 -> ast::QPath {\n+                 -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n         path.segments.push(ast::PathSegment {\n             identifier: ident,\n@@ -376,10 +376,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n         });\n \n-        ast::QPath {\n-            self_type: self_type,\n-            path: path\n-        }\n+        (ast::QSelf {\n+            ty: self_type,\n+            position: path.segments.len() - 1\n+        }, path)\n     }\n \n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n@@ -398,7 +398,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n-        self.ty(path.span, ast::TyPath(path))\n+        self.ty(path.span, ast::TyPath(None, path))\n     }\n \n     fn ty_sum(&self, path: ast::Path, bounds: OwnedSlice<ast::TyParamBound>) -> P<ast::Ty> {\n@@ -603,12 +603,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(path.span, ast::ExprPath(path))\n+        self.expr(path.span, ast::ExprPath(None, path))\n     }\n \n     /// Constructs a QPath expression.\n-    fn expr_qpath(&self, span: Span, qpath: ast::QPath) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprQPath(qpath))\n+    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n+        self.expr(span, ast::ExprPath(Some(qself), path))\n     }\n \n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {"}, {"sha": "2303eb9645b640415c7c3a1f9eaac7aa1e25315e", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -53,7 +53,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(\n+        node: ast::ExprPath(None,\n             ast::Path {\n                  span: sp,\n                  global: false,"}, {"sha": "b6e7b309f356c8c3bffc9c92068c157a89ad04fe", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -41,7 +41,7 @@ pub fn expand_type(t: P<ast::Ty>,\n     debug!(\"expanding type {:?} with impl_ty {:?}\", t, impl_ty);\n     let t = match (t.node.clone(), impl_ty) {\n         // Expand uses of `Self` in impls to the concrete type.\n-        (ast::Ty_::TyPath(ref path), Some(ref impl_ty)) => {\n+        (ast::Ty_::TyPath(None, ref path), Some(ref impl_ty)) => {\n             let path_as_ident = path_to_ident(path);\n             // Note unhygenic comparison here. I think this is correct, since\n             // even though `Self` is almost just a type parameter, the treatment\n@@ -1594,13 +1594,10 @@ mod test {\n \n     impl<'v> Visitor<'v> for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n-            match expr.node {\n-                ast::ExprPath(ref p) => {\n-                    self.path_accumulator.push(p.clone());\n-                    // not calling visit_path, but it should be fine.\n-                }\n-                _ => visit::walk_expr(self, expr)\n+            if let ast::ExprPath(None, ref p) = expr.node {\n+                self.path_accumulator.push(p.clone());\n             }\n+            visit::walk_expr(self, expr);\n         }\n     }\n "}, {"sha": "32fd5b49f9a44a150e24a932be90c8b2c02af8f6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyPath(ref p) => {\n+            ast::TyPath(None, ref p) => {\n                 match &*p.segments {\n \n                     [ast::PathSegment { identifier, .. }] => {"}, {"sha": "a556b2dfd2a99a88104844817f329d13a9f6669e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -424,12 +424,14 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             }\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n-            TyPath(path) => TyPath(fld.fold_path(path)),\n-            TyQPath(qpath) => {\n-                TyQPath(QPath {\n-                    self_type: fld.fold_ty(qpath.self_type),\n-                    path: fld.fold_path(qpath.path)\n-                })\n+            TyPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: fld.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                TyPath(qself, fld.fold_path(path))\n             }\n             TyObjectSum(ty, bounds) => {\n                 TyObjectSum(fld.fold_ty(ty),\n@@ -1347,11 +1349,15 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprRange(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n-            ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n-            ExprQPath(qpath) => ExprQPath(QPath {\n-                self_type: folder.fold_ty(qpath.self_type),\n-                path: folder.fold_path(qpath.path)\n-            }),\n+            ExprPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: folder.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                ExprPath(qself, folder.fold_path(path))\n+            }\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),"}, {"sha": "4d099529cb49ae50439b15fe1b3a03142d419af8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -774,7 +774,7 @@ mod test {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(ast::Path {\n+                    node: ast::ExprPath(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n                         segments: vec!(\n@@ -792,7 +792,7 @@ mod test {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(ast::Path {\n+                    node: ast::ExprPath(None, ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n                             segments: vec!(\n@@ -974,7 +974,7 @@ mod test {\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n-                        node:ast::ExprPath(ast::Path{\n+                        node:ast::ExprPath(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n                             segments: vec!(\n@@ -995,7 +995,7 @@ mod test {\n                    P(Spanned{\n                        node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n-                           node: ast::ExprPath(ast::Path {\n+                           node: ast::ExprPath(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n                                segments: vec!(\n@@ -1041,7 +1041,7 @@ mod test {\n                             node: ast::ItemFn(P(ast::FnDecl {\n                                 inputs: vec!(ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                  node: ast::TyPath(ast::Path{\n+                                                  node: ast::TyPath(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: vec!(\n@@ -1084,7 +1084,7 @@ mod test {\n                                         stmts: vec!(P(Spanned{\n                                             node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n-                                                node: ast::ExprPath(\n+                                                node: ast::ExprPath(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,"}, {"sha": "f171e8279f49c47440ce715dd1e616d469a614fb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -25,7 +25,7 @@ use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n-use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n+use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n@@ -43,7 +43,7 @@ use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef};\n-use ast::{QPath, RequiredMethod};\n+use ast::{QSelf, RequiredMethod};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub, StrStyle};\n@@ -53,7 +53,7 @@ use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n+use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n use ast::{UnnamedField, UnsafeBlock};\n@@ -143,7 +143,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(pt)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt)))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -1076,7 +1076,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ty_path(&mut self) -> Ty_ {\n-        TyPath(self.parse_path(LifetimeAndTypesWithoutColons))\n+        TyPath(None, self.parse_path(LifetimeAndTypesWithoutColons))\n     }\n \n     /// parse a TyBareFn type:\n@@ -1524,15 +1524,36 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             let self_type = self.parse_ty_sum();\n-            self.expect_keyword(keywords::As);\n-            let mut path = self.parse_path(LifetimeAndTypesWithoutColons);\n+\n+            let mut path = if self.eat_keyword(keywords::As) {\n+                self.parse_path(LifetimeAndTypesWithoutColons)\n+            } else {\n+                ast::Path {\n+                    span: self.span,\n+                    global: false,\n+                    segments: vec![]\n+                }\n+            };\n+\n+            let qself = QSelf {\n+                ty: self_type,\n+                position: path.segments.len()\n+            };\n+\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n+\n             path.segments.push(ast::PathSegment {\n                 identifier: self.parse_ident(),\n                 parameters: ast::PathParameters::none()\n             });\n-            TyQPath(QPath { self_type: self_type, path: path })\n+\n+            if path.segments.len() == 1 {\n+                path.span.lo = self.last_span.lo;\n+            }\n+            path.span.hi = self.last_span.hi;\n+\n+            TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n@@ -2173,7 +2194,7 @@ impl<'a> Parser<'a> {\n                          }, token::Plain) => {\n                 self.bump();\n                 let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n-                ex = ExprPath(path);\n+                ex = ExprPath(None, path);\n                 hi = self.last_span.hi;\n             }\n             token::OpenDelim(token::Bracket) => {\n@@ -2215,10 +2236,22 @@ impl<'a> Parser<'a> {\n                 if self.eat_lt() {\n                     // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n                     let self_type = self.parse_ty_sum();\n-                    self.expect_keyword(keywords::As);\n-                    let mut path = self.parse_path(LifetimeAndTypesWithoutColons);\n+                    let mut path = if self.eat_keyword(keywords::As) {\n+                        self.parse_path(LifetimeAndTypesWithoutColons)\n+                    } else {\n+                        ast::Path {\n+                            span: self.span,\n+                            global: false,\n+                            segments: vec![]\n+                        }\n+                    };\n+                    let qself = QSelf {\n+                        ty: self_type,\n+                        position: path.segments.len()\n+                    };\n                     self.expect(&token::Gt);\n                     self.expect(&token::ModSep);\n+\n                     let item_name = self.parse_ident();\n                     let parameters = if self.eat(&token::ModSep) {\n                         self.expect_lt();\n@@ -2237,9 +2270,14 @@ impl<'a> Parser<'a> {\n                         identifier: item_name,\n                         parameters: parameters\n                     });\n+\n+                    if path.segments.len() == 1 {\n+                        path.span.lo = self.last_span.lo;\n+                    }\n+                    path.span.hi = self.last_span.hi;\n+\n                     let hi = self.span.hi;\n-                    return self.mk_expr(lo, hi,\n-                        ExprQPath(QPath { self_type: self_type, path: path }));\n+                    return self.mk_expr(lo, hi, ExprPath(Some(qself), path));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n                     return self.parse_lambda_expr(CaptureByValue);\n@@ -2379,7 +2417,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     hi = pth.span.hi;\n-                    ex = ExprPath(pth);\n+                    ex = ExprPath(None, pth);\n                 } else {\n                     // other literal expression\n                     let lit = self.parse_lit();\n@@ -3421,7 +3459,7 @@ impl<'a> Parser<'a> {\n                 let end = if self.token.is_ident() || self.token.is_path() {\n                     let path = self.parse_path(LifetimeAndTypesWithColons);\n                     let hi = self.span.hi;\n-                    self.mk_expr(lo, hi, ExprPath(path))\n+                    self.mk_expr(lo, hi, ExprPath(None, path))\n                 } else {\n                     self.parse_literal_maybe_minus()\n                 };\n@@ -4808,7 +4846,7 @@ impl<'a> Parser<'a> {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             match ty.node {\n-                TyPath(ref path) => {\n+                TyPath(None, ref path) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: ty.id,"}, {"sha": "78b9487d1c98ba8dcaa4e7b4daf2730cbd9ab7ef", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -729,11 +729,11 @@ impl<'a> State<'a> {\n                                       &generics,\n                                       None));\n             }\n-            ast::TyPath(ref path) => {\n+            ast::TyPath(None, ref path) => {\n                 try!(self.print_path(path, false, 0));\n             }\n-            ast::TyQPath(ref qpath) => {\n-                try!(self.print_qpath(qpath, false))\n+            ast::TyPath(Some(ref qself), ref path) => {\n+                try!(self.print_qpath(path, qself, false))\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n@@ -1852,8 +1852,12 @@ impl<'a> State<'a> {\n                     try!(self.print_expr(&**e));\n                 }\n             }\n-            ast::ExprPath(ref path) => try!(self.print_path(path, true, 0)),\n-            ast::ExprQPath(ref qpath) => try!(self.print_qpath(qpath, true)),\n+            ast::ExprPath(None, ref path) => {\n+                try!(self.print_path(path, true, 0))\n+            }\n+            ast::ExprPath(Some(ref qself), ref path) => {\n+                try!(self.print_qpath(path, qself, true))\n+            }\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n@@ -2037,18 +2041,19 @@ impl<'a> State<'a> {\n     }\n \n     fn print_qpath(&mut self,\n-                   qpath: &ast::QPath,\n+                   path: &ast::Path,\n+                   qself: &ast::QSelf,\n                    colons_before_params: bool)\n                    -> IoResult<()>\n     {\n         try!(word(&mut self.s, \"<\"));\n-        try!(self.print_type(&*qpath.self_type));\n+        try!(self.print_type(&qself.ty));\n         try!(space(&mut self.s));\n         try!(self.word_space(\"as\"));\n-        try!(self.print_path(&qpath.path, false, 1));\n+        try!(self.print_path(&path, false, 1));\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n-        let item_segment = qpath.path.segments.last().unwrap();\n+        let item_segment = path.segments.last().unwrap();\n         try!(self.print_ident(item_segment.identifier));\n         self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }"}, {"sha": "33d8d56b4b11469cb6ccbf9890a57ba9d7555389", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -396,13 +396,12 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n-        TyPath(ref path) => {\n+        TyPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyQPath(ref qpath) => {\n-            visitor.visit_ty(&*qpath.self_type);\n-            visitor.visit_path(&qpath.path, typ.id);\n-        }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(&**ty);\n             walk_ty_param_bounds_helper(visitor, bounds);\n@@ -859,13 +858,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_expr_opt(visitor, start);\n             walk_expr_opt(visitor, end)\n         }\n-        ExprPath(ref path) => {\n+        ExprPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprQPath(ref qpath) => {\n-            visitor.visit_ty(&*qpath.self_type);\n-            visitor.visit_path(&qpath.path, expression.id);\n-        }\n         ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(ref optional_expression) => {\n             walk_expr_opt(visitor, optional_expression)"}, {"sha": "29b1c8f81d3c610f5ecda098fbed2fa110eff5fb", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31b9ebef5c39de3fff9da02eea880d1838a8a3b/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=d31b9ebef5c39de3fff9da02eea880d1838a8a3b", "patch": "@@ -61,8 +61,10 @@ tests! {\n     // Inherent static methods.\n     Vec::new, fn() -> Vec<()>, ();\n     Vec::<()>::new, fn() -> Vec<()>, ();\n+    <Vec<()>>::new, fn() -> Vec<()>, ();\n     Vec::with_capacity, fn(usize) -> Vec<()>, (5);\n     Vec::<()>::with_capacity, fn(usize) -> Vec<()>, (5);\n+    <Vec<()>>::with_capacity, fn(usize) -> Vec<()>, (5);\n     BitVec::from_fn, fn(usize, fn(usize) -> bool) -> BitVec, (5, odd);\n     BitVec::from_fn::<fn(usize) -> bool>, fn(usize, fn(usize) -> bool) -> BitVec, (5, odd);\n \n@@ -78,26 +80,32 @@ tests! {\n \n     // Trait static methods.\n     bool::size, fn() -> usize, ();\n+    <bool>::size, fn() -> usize, ();\n     <bool as Size>::size, fn() -> usize, ();\n \n     Default::default, fn() -> i32, ();\n     i32::default, fn() -> i32, ();\n+    <i32>::default, fn() -> i32, ();\n     <i32 as Default>::default, fn() -> i32, ();\n \n     Rand::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n     i32::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32>::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n     <i32 as Rand>::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n     Rand::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n     i32::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32>::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n     <i32 as Rand>::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n \n     // Trait non-static methods.\n     Clone::clone, fn(&i32) -> i32, (&5);\n     i32::clone, fn(&i32) -> i32, (&5);\n+    <i32>::clone, fn(&i32) -> i32, (&5);\n     <i32 as Clone>::clone, fn(&i32) -> i32, (&5);\n \n     FromIterator::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n     Vec::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n+    <Vec<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n     <Vec<_> as FromIterator<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>,\n         (Some(5).into_iter());\n     <Vec<i32> as FromIterator<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>,\n@@ -109,11 +117,14 @@ tests! {\n \n     Add::add, fn(i32, i32) -> i32, (5, 6);\n     i32::add, fn(i32, i32) -> i32, (5, 6);\n+    <i32>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<_>>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<i32>>::add, fn(i32, i32) -> i32, (5, 6);\n \n     String::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n+    <String>::into_cow, fn(String) -> Cow<'static, str>,\n+        (\"foo\".to_string());\n     <String as IntoCow<_>>::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n     <String as IntoCow<'static, _>>::into_cow, fn(String) -> Cow<'static, str>,"}]}