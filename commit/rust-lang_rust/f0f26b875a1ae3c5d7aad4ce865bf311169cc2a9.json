{"sha": "f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjI2Yjg3NWExYWUzYzVkN2FhZDRjZTg2NWJmMzExMTY5Y2MyYTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-04-27T11:02:09Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-01T10:12:23Z"}, "message": "rustc: return impl Iterator from Terminator(Kind)::successors(_mut).", "tree": {"sha": "c0c430bb64cd61dcd506efbc3509e8c9bc0e7d00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0c430bb64cd61dcd506efbc3509e8c9bc0e7d00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "html_url": "https://github.com/rust-lang/rust/commit/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a8ad909304953973a819760071de99f2ce5fb2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8ad909304953973a819760071de99f2ce5fb2d", "html_url": "https://github.com/rust-lang/rust/commit/2a8ad909304953973a819760071de99f2ce5fb2d"}], "stats": {"total": 174, "additions": 85, "deletions": 89}, "files": [{"sha": "41ba526b73fefdafd3d707eac79698e10da0ddd9", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -68,7 +68,7 @@ fn calculate_predecessors(mir: &Mir) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n     let mut result = IndexVec::from_elem(vec![], mir.basic_blocks());\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors().iter() {\n+            for &tgt in term.successors() {\n                 result[tgt].push(bb);\n             }\n         }"}, {"sha": "f1bb7ccbd4c61d26c6dcf7c81911653b106ed0a8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -37,7 +37,7 @@ use hir::{self, InlineAsm};\n use std::borrow::{Cow};\n use rustc_data_structures::sync::ReadGuard;\n use std::fmt::{self, Debug, Formatter, Write};\n-use std::{iter, mem, u32};\n+use std::{iter, mem, option, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n@@ -859,12 +859,17 @@ pub enum TerminatorKind<'tcx> {\n     },\n }\n \n+pub type Successors<'a> =\n+    iter::Chain<option::IntoIter<&'a BasicBlock>, slice::Iter<'a, BasicBlock>>;\n+pub type SuccessorsMut<'a> =\n+    iter::Chain<option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n+\n impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> Cow<[BasicBlock]> {\n+    pub fn successors(&self) -> Successors {\n         self.kind.successors()\n     }\n \n-    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n+    pub fn successors_mut(&mut self) -> SuccessorsMut {\n         self.kind.successors_mut()\n     }\n \n@@ -885,72 +890,71 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    pub fn successors(&self) -> Cow<[BasicBlock]> {\n+    pub fn successors(&self) -> Successors {\n         use self::TerminatorKind::*;\n         match *self {\n-            Goto { target: ref b } => slice::from_ref(b).into_cow(),\n-            SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n-            Resume | Abort | GeneratorDrop => (&[]).into_cow(),\n-            Return => (&[]).into_cow(),\n-            Unreachable => (&[]).into_cow(),\n-            Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n-            Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n-                slice::from_ref(t).into_cow(),\n-            Call { destination: None, cleanup: Some(ref c), .. } => slice::from_ref(c).into_cow(),\n-            Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n-            Yield { resume: t, drop: Some(c), .. } => vec![t, c].into_cow(),\n-            Yield { resume: ref t, drop: None, .. } => slice::from_ref(t).into_cow(),\n-            DropAndReplace { target, unwind: Some(unwind), .. } |\n-            Drop { target, unwind: Some(unwind), .. } => {\n-                vec![target, unwind].into_cow()\n+            Resume | Abort | GeneratorDrop | Return | Unreachable |\n+            Call { destination: None, cleanup: None, .. } => {\n+                None.into_iter().chain(&[])\n+            }\n+            Goto { target: ref t } |\n+            Call { destination: None, cleanup: Some(ref t), .. } |\n+            Call { destination: Some((_, ref t)), cleanup: None, .. } |\n+            Yield { resume: ref t, drop: None, .. } |\n+            DropAndReplace { target: ref t, unwind: None, .. } |\n+            Drop { target: ref t, unwind: None, .. } |\n+            Assert { target: ref t, cleanup: None, .. } |\n+            FalseUnwind { real_target: ref t, unwind: None } => {\n+                Some(t).into_iter().chain(&[])\n             }\n-            DropAndReplace { ref target, unwind: None, .. } |\n-            Drop { ref target, unwind: None, .. } => {\n-                slice::from_ref(target).into_cow()\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. } |\n+            Yield { resume: ref t, drop: Some(ref u), .. } |\n+            DropAndReplace { target: ref t, unwind: Some(ref u), .. } |\n+            Drop { target: ref t, unwind: Some(ref u), .. } |\n+            Assert { target: ref t, cleanup: Some(ref u), .. } |\n+            FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n+            }\n+            SwitchInt { ref targets, .. } => {\n+                None.into_iter().chain(&targets[..])\n             }\n-            Assert { target, cleanup: Some(unwind), .. } => vec![target, unwind].into_cow(),\n-            Assert { ref target, .. } => slice::from_ref(target).into_cow(),\n             FalseEdges { ref real_target, ref imaginary_targets } => {\n-                let mut s = vec![*real_target];\n-                s.extend_from_slice(imaginary_targets);\n-                s.into_cow()\n+                Some(real_target).into_iter().chain(&imaginary_targets[..])\n             }\n-            FalseUnwind { real_target: t, unwind: Some(u) } => vec![t, u].into_cow(),\n-            FalseUnwind { real_target: ref t, unwind: None } => slice::from_ref(t).into_cow(),\n         }\n     }\n \n-    // FIXME: no mootable cow. I\u2019m honestly not sure what a \u201ccow\u201d between `&mut [BasicBlock]` and\n-    // `Vec<&mut BasicBlock>` would look like in the first place.\n-    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n+    pub fn successors_mut(&mut self) -> SuccessorsMut {\n         use self::TerminatorKind::*;\n         match *self {\n-            Goto { target: ref mut b } => vec![b],\n-            SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n-            Resume | Abort | GeneratorDrop => Vec::new(),\n-            Return => Vec::new(),\n-            Unreachable => Vec::new(),\n-            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n-            Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n-            Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n-            Call { destination: None, cleanup: None, .. } => vec![],\n-            Yield { resume: ref mut t, drop: Some(ref mut c), .. } => vec![t, c],\n-            Yield { resume: ref mut t, drop: None, .. } => vec![t],\n-            DropAndReplace { ref mut target, unwind: Some(ref mut unwind), .. } |\n-            Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n-            DropAndReplace { ref mut target, unwind: None, .. } |\n-            Drop { ref mut target, unwind: None, .. } => {\n-                vec![target]\n+            Resume | Abort | GeneratorDrop | Return | Unreachable |\n+            Call { destination: None, cleanup: None, .. } => {\n+                None.into_iter().chain(&mut [])\n+            }\n+            Goto { target: ref mut t } |\n+            Call { destination: None, cleanup: Some(ref mut t), .. } |\n+            Call { destination: Some((_, ref mut t)), cleanup: None, .. } |\n+            Yield { resume: ref mut t, drop: None, .. } |\n+            DropAndReplace { target: ref mut t, unwind: None, .. } |\n+            Drop { target: ref mut t, unwind: None, .. } |\n+            Assert { target: ref mut t, cleanup: None, .. } |\n+            FalseUnwind { real_target: ref mut t, unwind: None } => {\n+                Some(t).into_iter().chain(&mut [])\n+            }\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. } |\n+            Yield { resume: ref mut t, drop: Some(ref mut u), .. } |\n+            DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. } |\n+            Drop { target: ref mut t, unwind: Some(ref mut u), .. } |\n+            Assert { target: ref mut t, cleanup: Some(ref mut u), .. } |\n+            FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_ref_mut(u))\n+            }\n+            SwitchInt { ref mut targets, .. } => {\n+                None.into_iter().chain(&mut targets[..])\n             }\n-            Assert { ref mut target, cleanup: Some(ref mut unwind), .. } => vec![target, unwind],\n-            Assert { ref mut target, .. } => vec![target],\n             FalseEdges { ref mut real_target, ref mut imaginary_targets } => {\n-                let mut s = vec![real_target];\n-                s.extend(imaginary_targets.iter_mut());\n-                s\n+                Some(real_target).into_iter().chain(&mut imaginary_targets[..])\n             }\n-            FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => vec![t, u],\n-            FalseUnwind { ref mut real_target, unwind: None } => vec![real_target],\n         }\n     }\n \n@@ -1070,18 +1074,18 @@ impl<'tcx> BasicBlockData<'tcx> {\n impl<'tcx> Debug for TerminatorKind<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         self.fmt_head(fmt)?;\n-        let successors = self.successors();\n+        let successor_count = self.successors().count();\n         let labels = self.fmt_successor_labels();\n-        assert_eq!(successors.len(), labels.len());\n+        assert_eq!(successor_count, labels.len());\n \n-        match successors.len() {\n+        match successor_count {\n             0 => Ok(()),\n \n-            1 => write!(fmt, \" -> {:?}\", successors[0]),\n+            1 => write!(fmt, \" -> {:?}\", self.successors().nth(0).unwrap()),\n \n             _ => {\n                 write!(fmt, \" -> [\")?;\n-                for (i, target) in successors.iter().enumerate() {\n+                for (i, target) in self.successors().enumerate() {\n                     if i > 0 {\n                         write!(fmt, \", \")?;\n                     }\n@@ -1969,7 +1973,7 @@ impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n     fn successors<'graph>(&'graph self, node: Self::Node)\n                           -> <Self as GraphSuccessors<'graph>>::Iter\n     {\n-        self.basic_blocks[node].terminator().successors().into_owned().into_iter()\n+        self.basic_blocks[node].terminator().successors().cloned()\n     }\n }\n \n@@ -1980,7 +1984,7 @@ impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n \n impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n+    type Iter = iter::Cloned<Successors<'b>>;\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]"}, {"sha": "92888ed99e4729b395968a992cc69c8f7512c454", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -67,7 +65,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n             let data = &self.mir[idx];\n \n             if let Some(ref term) = data.terminator {\n-                for &succ in term.successors().iter() {\n+                for &succ in term.successors() {\n                     self.worklist.push(succ);\n                 }\n             }\n@@ -110,7 +108,7 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     visited: BitVector,\n-    visit_stack: Vec<(BasicBlock, vec::IntoIter<BasicBlock>)>\n+    visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n@@ -126,10 +124,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root.index());\n-\n-            let succs = term.successors().into_owned().into_iter();\n-\n-            po.visit_stack.push((root, succs));\n+            po.visit_stack.push((root, term.successors()));\n             po.traverse_successor();\n         }\n \n@@ -186,7 +181,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n         loop {\n             let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n-                if let Some(bb) = iter.next() {\n+                if let Some(&bb) = iter.next() {\n                     bb\n                 } else {\n                     break;\n@@ -197,8 +192,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n \n             if self.visited.insert(bb.index()) {\n                 if let Some(ref term) = self.mir[bb].terminator {\n-                    let succs = term.successors().into_owned().into_iter();\n-                    self.visit_stack.push((bb, succs));\n+                    self.visit_stack.push((bb, term.successors()));\n                 }\n             }\n         }"}, {"sha": "56e388a5b6094b81d87df6e46a7006a359ba72ca", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -193,7 +193,6 @@ impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n                         block_data\n                             .terminator()\n                             .successors()\n-                            .iter()\n                             .map(|&basic_block| Location {\n                                 statement_index: 0,\n                                 block: basic_block,"}, {"sha": "f68394d6149818833bc862f9854d233eceb191f9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -95,7 +95,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     block_data\n                         .terminator()\n                         .successors()\n-                        .iter()\n                         .map(|&basic_block| Location {\n                             statement_index: 0,\n                             block: basic_block,"}, {"sha": "9096ac1444cfc98854b6d3d3dfc2a3750157c1c1", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -73,8 +73,8 @@ pub type Node = BasicBlock;\n pub struct Edge { source: BasicBlock, index: usize }\n \n fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n-    let succ_len = mir[bb].terminator().successors().len();\n-    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n+    mir[bb].terminator().successors().enumerate()\n+        .map(|(index, _)| Edge { source: bb, index: index}).collect()\n }\n \n impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n@@ -285,6 +285,6 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n \n     fn target(&self, edge: &Edge) -> Node {\n         let mir = self.mbcx.mir();\n-        mir[edge.source].terminator().successors()[edge.index]\n+        *mir[edge.source].terminator().successors().nth(edge.index).unwrap()\n     }\n }"}, {"sha": "ee6d42b1fe542fec83a961b49d02279fc2d840e4", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n \n             if !is_drop {\n-                for &succ in &term.successors()[..] {\n+                for &succ in term.successors() {\n                     work_list.push(succ);\n                 }\n             }"}, {"sha": "bcc8fef18f013362135bb6b2162a00907215609d", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -78,7 +78,7 @@ impl RemoveNoopLandingPads {\n             TerminatorKind::SwitchInt { .. } |\n             TerminatorKind::FalseEdges { .. } |\n             TerminatorKind::FalseUnwind { .. } => {\n-                terminator.successors().iter().all(|succ| {\n+                terminator.successors().all(|succ| {\n                     nop_landing_pads.contains(succ.index())\n                 })\n             },"}, {"sha": "691fdd130e551f611237970ec47cca9976d00545", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n \n         for (_, data) in traversal::preorder(mir) {\n             if let Some(ref term) = data.terminator {\n-                for &tgt in term.successors().iter() {\n+                for &tgt in term.successors() {\n                     pred_count[tgt] += 1;\n                 }\n             }\n@@ -219,10 +219,10 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         };\n \n         let first_succ = {\n-            let successors = terminator.successors();\n-            if let Some(&first_succ) = terminator.successors().get(0) {\n-                if successors.iter().all(|s| *s == first_succ) {\n-                    self.pred_count[first_succ] -= (successors.len()-1) as u32;\n+            if let Some(&first_succ) = terminator.successors().nth(0) {\n+                if terminator.successors().all(|s| *s == first_succ) {\n+                    let count = terminator.successors().count();\n+                    self.pred_count[first_succ] -= (count - 1) as u32;\n                     first_succ\n                 } else {\n                     return false"}, {"sha": "22e2b1b0b09c9945d6a313d9f7f764502e9f3472", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -125,7 +125,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n     let terminator = mir[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n-    for (&target, label) in terminator.successors().iter().zip(labels) {\n+    for (&target, label) in terminator.successors().zip(labels) {\n         writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label)?;\n     }\n "}, {"sha": "cfb1a2cd28bcc1a115322cc3555a5632edcf915f", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -138,7 +138,7 @@ pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> Liveness\n         for b in mir.basic_blocks().indices().rev() {\n             // outs[b] = \u222a {ins of successors}\n             bits.clear();\n-            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+            for &successor in mir.basic_blocks()[b].terminator().successors() {\n                 bits.union(&ins[successor]);\n             }\n             outs[b].clone_from(&bits);"}, {"sha": "9e5298eb736a33e18c7d97710f1739fa3b925ebc", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=f0f26b875a1ae3c5d7aad4ce865bf311169cc2a9", "patch": "@@ -322,7 +322,7 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n             debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n                    bb, data, result[bb], funclet);\n \n-            for &succ in data.terminator().successors().iter() {\n+            for &succ in data.terminator().successors() {\n                 let kind = result[succ];\n                 debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n                        funclet, succ, kind);"}]}