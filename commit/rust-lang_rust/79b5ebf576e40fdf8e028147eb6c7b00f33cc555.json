{"sha": "79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YjVlYmY1NzZlNDBmZGY4ZTAyODE0N2ViNmM3YjAwZjMzY2M1NTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-21T18:14:22Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-21T19:07:34Z"}, "message": "Attach deprecation lint `proc_macro_derive_resolution_fallback` to a specific node id", "tree": {"sha": "026edec088b576b6137182525ee65ee629f01304", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026edec088b576b6137182525ee65ee629f01304"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "html_url": "https://github.com/rust-lang/rust/commit/79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "942b384d61590c39eb635596de0370a823001817", "url": "https://api.github.com/repos/rust-lang/rust/commits/942b384d61590c39eb635596de0370a823001817", "html_url": "https://github.com/rust-lang/rust/commit/942b384d61590c39eb635596de0370a823001817"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "c0e0bab7915900cc78b8cf8abb9236587796740b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "patch": "@@ -717,7 +717,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n             TyKind::ImplicitSelf => {\n                 let self_ty = keywords::SelfType.ident();\n-                let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n+                let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Def::Err, |d| d.def());\n                 self.record_def(ty.id, PathResolution::new(def));\n             }\n@@ -1839,9 +1839,10 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: Ident,\n                                       ns: Namespace,\n-                                      record_used: bool,\n+                                      record_used_id: Option<NodeId>,\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n+        let record_used = record_used_id.is_some();\n         if ns == TypeNS {\n             ident.span = if ident.name == keywords::SelfType.name() {\n                 // FIXME(jseyfried) improve `Self` hygiene\n@@ -1890,10 +1891,11 @@ impl<'a> Resolver<'a> {\n \n         ident.span = ident.span.modern();\n         loop {\n-            let (opt_module, poisoned) = if record_used {\n-                self.hygienic_lexical_parent_with_compatibility_fallback(module, &mut ident.span)\n+            let (opt_module, poisoned) = if let Some(node_id) = record_used_id {\n+                self.hygienic_lexical_parent_with_compatibility_fallback(module, &mut ident.span,\n+                                                                         node_id)\n             } else {\n-                (self.hygienic_lexical_parent(module, &mut ident.span), false)\n+                (self.hygienic_lexical_parent(module, &mut ident.span), None)\n             };\n             module = unwrap_or!(opt_module, break);\n             let orig_current_module = self.current_module;\n@@ -1905,18 +1907,18 @@ impl<'a> Resolver<'a> {\n \n             match result {\n                 Ok(binding) => {\n-                    if poisoned {\n+                    if let Some(node_id) = poisoned {\n                         self.session.buffer_lint_with_diagnostic(\n                             lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                            CRATE_NODE_ID, ident.span,\n+                            node_id, ident.span,\n                             &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n                             lint::builtin::BuiltinLintDiagnostics::\n                                 ProcMacroDeriveResolutionFallback(ident.span),\n                         );\n                     }\n                     return Some(LexicalScopeBinding::Item(binding))\n                 }\n-                _ if poisoned => break,\n+                _ if poisoned.is_some() => break,\n                 Err(Undetermined) => return None,\n                 Err(Determined) => {}\n             }\n@@ -1965,10 +1967,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn hygienic_lexical_parent_with_compatibility_fallback(\n-        &mut self, module: Module<'a>, span: &mut Span) -> (Option<Module<'a>>, /* poisoned */ bool\n-    ) {\n+        &mut self, module: Module<'a>, span: &mut Span, node_id: NodeId\n+    ) -> (Option<Module<'a>>, /* poisoned */ Option<NodeId>)\n+    {\n         if let module @ Some(..) = self.hygienic_lexical_parent(module, span) {\n-            return (module, false);\n+            return (module, None);\n         }\n \n         // We need to support the next case under a deprecation warning\n@@ -1989,13 +1992,13 @@ impl<'a> Resolver<'a> {\n                 // The macro is a proc macro derive\n                 if module.expansion.looks_like_proc_macro_derive() {\n                     if parent.expansion.is_descendant_of(span.ctxt().outer()) {\n-                        return (module.parent, true);\n+                        return (module.parent, Some(node_id));\n                     }\n                 }\n             }\n         }\n \n-        (None, false)\n+        (None, None)\n     }\n \n     fn resolve_ident_in_module(&mut self,\n@@ -2758,7 +2761,7 @@ impl<'a> Resolver<'a> {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n                     let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n-                                                                      false, pat.span)\n+                                                                      None, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n@@ -3189,13 +3192,13 @@ impl<'a> Resolver<'a> {\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n-                                                          TypeNS, false, span);\n+                                                          TypeNS, None, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n         let ident = Ident::new(keywords::SelfValue.name(), self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, path_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n@@ -3472,7 +3475,9 @@ impl<'a> Resolver<'a> {\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n+                let record_used_id =\n+                    if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used_id, path_span) {\n                     // we found a locally-imported or available item/module\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     // we found a local variable or type param\n@@ -4692,4 +4697,15 @@ enum CrateLint {\n     QPathTrait { qpath_id: NodeId, qpath_span: Span },\n }\n \n+impl CrateLint {\n+    fn node_id(&self) -> Option<NodeId> {\n+        match *self {\n+            CrateLint::No => None,\n+            CrateLint::SimplePath(id) |\n+            CrateLint::UsePath { root_id: id, .. } |\n+            CrateLint::QPathTrait { qpath_id: id, .. } => Some(id),\n+        }\n+    }\n+}\n+\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "632dba42ad00f21f037a19bb259322f3795ac7de", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/generate-mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs?ref=79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "patch": "@@ -52,3 +52,16 @@ pub fn check_derive(_: TokenStream) -> TokenStream {\n     }\n     \".parse().unwrap()\n }\n+\n+#[proc_macro_derive(CheckDeriveLint)]\n+pub fn check_derive_lint(_: TokenStream) -> TokenStream {\n+    \"\n+    type AliasDeriveLint = FromOutside; // OK\n+    struct OuterDeriveLint;\n+    #[allow(proc_macro_derive_resolution_fallback)]\n+    mod inner_derive_lint {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterDeriveLint; // `OuterDeriveLint` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "ee0077c3ed3ff189f7f6ffd0bddcb89aef4a9bd5", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b5ebf576e40fdf8e028147eb6c7b00f33cc555/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=79b5ebf576e40fdf8e028147eb6c7b00f33cc555", "patch": "@@ -31,4 +31,7 @@ struct S;\n                                      //~| WARN this was previously accepted\n struct Z;\n \n+#[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+struct W;\n+\n fn main() {}"}]}