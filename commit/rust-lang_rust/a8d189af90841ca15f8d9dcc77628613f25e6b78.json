{"sha": "a8d189af90841ca15f8d9dcc77628613f25e6b78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDE4OWFmOTA4NDFjYTE1ZjhkOWRjYzc3NjI4NjEzZjI1ZTZiNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-14T23:15:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-14T23:15:42Z"}, "message": "Auto merge of #37170 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 10 pull requests\n\n- Successful merges: #36307, #36755, #36961, #37102, #37115, #37119, #37122, #37123, #37141, #37159\n- Failed merges:", "tree": {"sha": "5fe5b973f3603bfbacc24b11b63c3dcfa10bc840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fe5b973f3603bfbacc24b11b63c3dcfa10bc840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d189af90841ca15f8d9dcc77628613f25e6b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d189af90841ca15f8d9dcc77628613f25e6b78", "html_url": "https://github.com/rust-lang/rust/commit/a8d189af90841ca15f8d9dcc77628613f25e6b78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d189af90841ca15f8d9dcc77628613f25e6b78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "html_url": "https://github.com/rust-lang/rust/commit/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf"}, {"sha": "881f0f81f05dbc8288f2076ce439910536de287d", "url": "https://api.github.com/repos/rust-lang/rust/commits/881f0f81f05dbc8288f2076ce439910536de287d", "html_url": "https://github.com/rust-lang/rust/commit/881f0f81f05dbc8288f2076ce439910536de287d"}], "stats": {"total": 411, "additions": 283, "deletions": 128}, "files": [{"sha": "b79c9703f44ef17d2c37c7e6869e22d55f6ed0a7", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -89,6 +89,7 @@ build.\n    $ pacman -S git \\\n                make \\\n                diffutils \\\n+               tar \\\n                mingw-w64-x86_64-python2 \\\n                mingw-w64-x86_64-cmake \\\n                mingw-w64-x86_64-gcc"}, {"sha": "df1ee5a293c9d6b8e2638ff8c8394c2a6a286ed6", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -50,11 +50,78 @@ complicated. For example, imagine this set of operations:\n 4. You decide to use the resource.\n \n Uh oh! Your reference is pointing to an invalid resource. This is called a\n-dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+dangling pointer or \u2018use after free\u2019, when the resource is memory. A small\n+example of such a situation would be:\n+\n+```rust,compile_fail\n+let r;              // Introduce reference: r\n+{\n+    let i = 1;      // Introduce scoped value: i\n+    r = &i;         // Store reference of i in r\n+}                   // i goes out of scope and is dropped.\n+\n+println!(\"{}\", r);  // r still refers to i\n+```\n \n To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-lifetimes, which describe the scope that a reference is valid for.\n+three. In the small example above the Rust compiler is able to report the issue\n+as it can see the lifetimes of the various values in the function.\n+\n+When we have a function that takes arguments by reference the situation becomes\n+more complex. Consider the following example:\n+\n+```rust,compile_fail,E0106\n+fn skip_prefix(line: &str, prefix: &str) -> &str {\n+    // ...\n+#   line\n+}\n+\n+let line = \"lang:en=Hello World!\";\n+let lang = \"en\";\n+\n+let v;\n+{\n+    let p = format!(\"lang:{}=\", lang);  // -+ p goes into scope\n+    v = skip_prefix(line, p.as_str());  //  |\n+}                                       // -+ p goes out of scope\n+println!(\"{}\", v);\n+```\n+\n+Here we have a function `skip_prefix` which takes two `&str` references\n+as parameters and returns a single `&str` reference. We call it\n+by passing in references to `line` and `p`: Two variables with different\n+lifetimes. Now the safety of the `println!`-line depends on whether the\n+reference returned by `skip_prefix` function references the still living\n+`line` or the already dropped `p` string.\n+\n+Because of the above ambiguity, Rust will refuse to compile the example\n+code. To get it to compile we need to tell the compiler more about the\n+lifetimes of the references. This can be done by making the lifetimes\n+explicit in the function declaration:\n+\n+```rust\n+fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {\n+    // ...\n+#   line\n+}\n+```\n+\n+Let's examine the changes without going too deep into the syntax for now -\n+we'll get to that later. The first change was adding the `<'a, 'b>` after the\n+method name. This introduces two lifetime parameters: `'a` and `'b`. Next each\n+reference in the function signature was associated with one of the lifetime\n+parameters by adding the lifetime name after the `&`. This tells the compiler\n+how the lifetimes between different references are related.\n+\n+As a result the compiler is now able to deduce that the return value of\n+`skip_prefix` has the same lifetime as the `line` parameter, which makes the `v`\n+reference safe to use even after the `p` goes out of scope in the original\n+example.\n+\n+In addition to the compiler being able to validate the usage of `skip_prefix`\n+return value, it can also ensure that the implementation follows the contract\n+established by the function declaration. This is useful especially when you are\n+implementing traits that are introduced [later in the book][traits].\n \n **Note** It's important to understand that lifetime annotations are\n _descriptive_, not _prescriptive_. This means that how long a reference is valid\n@@ -63,20 +130,14 @@ give information about lifetimes to the compiler that uses them to check the\n validity of references. The compiler can do so without annotations in simple\n cases, but needs the programmers support in complex scenarios.\n \n-```rust\n-// implicit\n-fn foo(x: &i32) {\n-}\n+[traits]: traits.html\n \n-// explicit\n-fn bar<'a>(x: &'a i32) {\n-}\n-```\n+# Syntax\n \n The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n associated with it, but the compiler lets you elide (i.e. omit, see\n-[\"Lifetime Elision\"][lifetime-elision] below) them in common cases.\n-Before we get to that, though, let\u2019s break the explicit example down:\n+[\"Lifetime Elision\"][lifetime-elision] below) them in common cases. Before we\n+get to that, though, let\u2019s look at a short example with explicit lifetimes:\n \n [lifetime-elision]: #lifetime-elision\n \n@@ -94,7 +155,8 @@ focus on the lifetimes aspect.\n [generics]: generics.html\n \n We use `<>` to declare our lifetimes. This says that `bar` has one lifetime,\n-`'a`. If we had two reference parameters, it would look like this:\n+`'a`. If we had two reference parameters with different lifetimes, it would\n+look like this:\n \n \n ```rust,ignore"}, {"sha": "3798336f0a52419c579cf8f9c1c2b8e191c27a0b", "filename": "src/doc/book/type-aliases.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fdoc%2Fbook%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fdoc%2Fbook%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftype-aliases.md?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -1,4 +1,4 @@\n-% `type` Aliases\n+% Type Aliases\n \n The `type` keyword lets you declare an alias of another type:\n "}, {"sha": "ac36cbaace7a89fe85cc97e5e57ee86b85dca396", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -38,7 +38,9 @@\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n-//! the `Hash` trait:\n+//! the [`Hash`] trait:\n+//!\n+//! [`Hash`]: trait.Hash.html\n //!\n //! ```rust\n //! use std::hash::{Hash, Hasher, SipHasher};\n@@ -90,21 +92,21 @@ mod sip;\n /// The `H` type parameter is an abstract hash state that is used by the `Hash`\n /// to compute the hash.\n ///\n-/// If you are also implementing `Eq`, there is an additional property that\n+/// If you are also implementing [`Eq`], there is an additional property that\n /// is important:\n ///\n /// ```text\n /// k1 == k2 -> hash(k1) == hash(k2)\n /// ```\n ///\n /// In other words, if two keys are equal, their hashes should also be equal.\n-/// `HashMap` and `HashSet` both rely on this behavior.\n+/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n ///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]` if all fields implement `Hash`.\n /// When `derive`d, the resulting hash will be the combination of the values\n-/// from calling `.hash()` on each field.\n+/// from calling [`.hash()`] on each field.\n ///\n /// ## How can I implement `Hash`?\n ///\n@@ -127,6 +129,11 @@ mod sip;\n ///     }\n /// }\n /// ```\n+///\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n+/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n+/// [`.hash()`]: #tymethod.hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n@@ -151,35 +158,35 @@ pub trait Hasher {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n-    /// Writes some data into this `Hasher`\n+    /// Writes some data into this `Hasher`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n-    /// Write a single `u8` into this hasher\n+    /// Write a single `u8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u8(&mut self, i: u8) {\n         self.write(&[i])\n     }\n-    /// Write a single `u16` into this hasher.\n+    /// Writes a single `u16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n-    /// Write a single `u32` into this hasher.\n+    /// Writes a single `u32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n-    /// Write a single `u64` into this hasher.\n+    /// Writes a single `u64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n-    /// Write a single `usize` into this hasher.\n+    /// Writes a single `usize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n@@ -189,31 +196,31 @@ pub trait Hasher {\n         self.write(bytes);\n     }\n \n-    /// Write a single `i8` into this hasher.\n+    /// Writes a single `i8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i8(&mut self, i: i8) {\n         self.write_u8(i as u8)\n     }\n-    /// Write a single `i16` into this hasher.\n+    /// Writes a single `i16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i16(&mut self, i: i16) {\n         self.write_u16(i as u16)\n     }\n-    /// Write a single `i32` into this hasher.\n+    /// Writes a single `i32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i32(&mut self, i: i32) {\n         self.write_u32(i as u32)\n     }\n-    /// Write a single `i64` into this hasher.\n+    /// Writes a single `i64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i64(&mut self, i: i64) {\n         self.write_u64(i as u64)\n     }\n-    /// Write a single `isize` into this hasher.\n+    /// Writes a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_isize(&mut self, i: isize) {"}, {"sha": "a1f4630c304bf93dff849a7d479910658e085a43", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -34,19 +34,22 @@ use intrinsics;\n pub trait FullOps: Sized {\n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);\n+    fn full_add(self, other: Self, carry: bool) -> (bool /* carry */, Self);\n \n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_mul(self, other: Self, carry: Self) -> (Self /*carry*/, Self);\n+    fn full_mul(self, other: Self, carry: Self) -> (Self /* carry */, Self);\n \n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /*carry*/, Self);\n+    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /* carry */, Self);\n \n     /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n     /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n-    fn full_div_rem(self, other: Self, borrow: Self) -> (Self /*quotient*/, Self /*remainder*/);\n+    fn full_div_rem(self,\n+                    other: Self,\n+                    borrow: Self)\n+                    -> (Self /* quotient */, Self /* remainder */);\n }\n \n macro_rules! impl_full_ops {\n@@ -100,11 +103,7 @@ impl_full_ops! {\n \n /// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value\n /// that's a power of five, plus the corresponding exponent. Used in `mul_pow5`.\n-const SMALL_POW5: [(u64, usize); 3] = [\n-    (125, 3),\n-    (15625, 6),\n-    (1_220_703_125, 13),\n-];\n+const SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n \n macro_rules! define_bignum {\n     ($name:ident: type=$ty:ty, n=$n:expr) => ("}, {"sha": "11eea753f93f912a579dd607cddae2e39f61eb24", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -49,12 +49,30 @@ impl Fp {\n     pub fn normalize(&self) -> Fp {\n         let mut f = self.f;\n         let mut e = self.e;\n-        if f >> (64 - 32) == 0 { f <<= 32; e -= 32; }\n-        if f >> (64 - 16) == 0 { f <<= 16; e -= 16; }\n-        if f >> (64 -  8) == 0 { f <<=  8; e -=  8; }\n-        if f >> (64 -  4) == 0 { f <<=  4; e -=  4; }\n-        if f >> (64 -  2) == 0 { f <<=  2; e -=  2; }\n-        if f >> (64 -  1) == 0 { f <<=  1; e -=  1; }\n+        if f >> (64 - 32) == 0 {\n+            f <<= 32;\n+            e -= 32;\n+        }\n+        if f >> (64 - 16) == 0 {\n+            f <<= 16;\n+            e -= 16;\n+        }\n+        if f >> (64 - 8) == 0 {\n+            f <<= 8;\n+            e -= 8;\n+        }\n+        if f >> (64 - 4) == 0 {\n+            f <<= 4;\n+            e -= 4;\n+        }\n+        if f >> (64 - 2) == 0 {\n+            f <<= 2;\n+            e -= 2;\n+        }\n+        if f >> (64 - 1) == 0 {\n+            f <<= 1;\n+            e -= 1;\n+        }\n         debug_assert!(f >= (1 >> 63));\n         Fp { f: f, e: e }\n     }\n@@ -66,6 +84,9 @@ impl Fp {\n         assert!(edelta >= 0);\n         let edelta = edelta as usize;\n         assert_eq!(self.f << edelta >> edelta, self.f);\n-        Fp { f: self.f << edelta, e: e }\n+        Fp {\n+            f: self.f << edelta,\n+            e: e,\n+        }\n     }\n }"}, {"sha": "4527d46a27d8a9590f6e64ebdf0376ae561996d6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -61,13 +61,13 @@ pub const MAX_10_EXP: i32 = 38;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f32 = 0.0_f32/0.0_f32;\n+pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n /// Negative infinity (-\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,26 +144,40 @@ pub mod consts {\n            issue = \"32110\")]\n impl Float for f32 {\n     #[inline]\n-    fn nan() -> f32 { NAN }\n+    fn nan() -> f32 {\n+        NAN\n+    }\n \n     #[inline]\n-    fn infinity() -> f32 { INFINITY }\n+    fn infinity() -> f32 {\n+        INFINITY\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> f32 { NEG_INFINITY }\n+    fn neg_infinity() -> f32 {\n+        NEG_INFINITY\n+    }\n \n     #[inline]\n-    fn zero() -> f32 { 0.0 }\n+    fn zero() -> f32 {\n+        0.0\n+    }\n \n     #[inline]\n-    fn neg_zero() -> f32 { -0.0 }\n+    fn neg_zero() -> f32 {\n+        -0.0\n+    }\n \n     #[inline]\n-    fn one() -> f32 { 1.0 }\n+    fn one() -> f32 {\n+        1.0\n+    }\n \n     /// Returns `true` if the number is NaN.\n     #[inline]\n-    fn is_nan(self) -> bool { self != self }\n+    fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if the number is infinite.\n     #[inline]\n@@ -192,11 +206,11 @@ impl Float for f32 {\n \n         let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => Fp::Zero,\n-            (_, 0)        => Fp::Subnormal,\n+            (0, 0) => Fp::Zero,\n+            (_, 0) => Fp::Subnormal,\n             (0, EXP_MASK) => Fp::Infinite,\n             (_, EXP_MASK) => Fp::Nan,\n-            _             => Fp::Normal,\n+            _ => Fp::Normal,\n         }\n     }\n \n@@ -252,7 +266,9 @@ impl Float for f32 {\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n-    fn recip(self) -> f32 { 1.0 / self }\n+    fn recip(self) -> f32 {\n+        1.0 / self\n+    }\n \n     #[inline]\n     fn powi(self, n: i32) -> f32 {\n@@ -261,7 +277,9 @@ impl Float for f32 {\n \n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n-    fn to_degrees(self) -> f32 { self * (180.0f32 / consts::PI) }\n+    fn to_degrees(self) -> f32 {\n+        self * (180.0f32 / consts::PI)\n+    }\n \n     /// Converts to radians, assuming the number is in degrees.\n     #[inline]"}, {"sha": "991a856834948687cf00c59d5879149733af6bc6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -61,13 +61,13 @@ pub const MAX_10_EXP: i32 = 308;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f64 = 0.0_f64/0.0_f64;\n+pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n+pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n /// Negative infinity (-\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n+pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,26 +144,40 @@ pub mod consts {\n            issue = \"32110\")]\n impl Float for f64 {\n     #[inline]\n-    fn nan() -> f64 { NAN }\n+    fn nan() -> f64 {\n+        NAN\n+    }\n \n     #[inline]\n-    fn infinity() -> f64 { INFINITY }\n+    fn infinity() -> f64 {\n+        INFINITY\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> f64 { NEG_INFINITY }\n+    fn neg_infinity() -> f64 {\n+        NEG_INFINITY\n+    }\n \n     #[inline]\n-    fn zero() -> f64 { 0.0 }\n+    fn zero() -> f64 {\n+        0.0\n+    }\n \n     #[inline]\n-    fn neg_zero() -> f64 { -0.0 }\n+    fn neg_zero() -> f64 {\n+        -0.0\n+    }\n \n     #[inline]\n-    fn one() -> f64 { 1.0 }\n+    fn one() -> f64 {\n+        1.0\n+    }\n \n     /// Returns `true` if the number is NaN.\n     #[inline]\n-    fn is_nan(self) -> bool { self != self }\n+    fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if the number is infinite.\n     #[inline]\n@@ -192,11 +206,11 @@ impl Float for f64 {\n \n         let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => Fp::Zero,\n-            (_, 0)        => Fp::Subnormal,\n+            (0, 0) => Fp::Zero,\n+            (_, 0) => Fp::Subnormal,\n             (0, EXP_MASK) => Fp::Infinite,\n             (_, EXP_MASK) => Fp::Nan,\n-            _             => Fp::Normal,\n+            _ => Fp::Normal,\n         }\n     }\n \n@@ -252,7 +266,9 @@ impl Float for f64 {\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n-    fn recip(self) -> f64 { 1.0 / self }\n+    fn recip(self) -> f64 {\n+        1.0 / self\n+    }\n \n     #[inline]\n     fn powi(self, n: i32) -> f64 {\n@@ -261,7 +277,9 @@ impl Float for f64 {\n \n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n-    fn to_degrees(self) -> f64 { self * (180.0f64 / consts::PI) }\n+    fn to_degrees(self) -> f64 {\n+        self * (180.0f64 / consts::PI)\n+    }\n \n     /// Converts to radians, assuming the number is in degrees.\n     #[inline]"}, {"sha": "a4529909e83ef61ddbd82d2fb5586ca317c98308", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -43,7 +43,8 @@ use str::FromStr;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n-pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n+pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                       pub T);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n@@ -2402,7 +2403,7 @@ pub enum FpCategory {\n \n     /// Positive or negative infinity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Infinite ,\n+    Infinite,\n \n     /// Positive or negative zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2662,8 +2663,7 @@ macro_rules! doit {\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n-                                         -> Result<T, ParseIntError> {\n+fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n     use self::ParseIntError as PIE;\n \n@@ -2686,7 +2686,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n     let (is_positive, digits) = match src[0] {\n         b'+' => (true, &src[1..]),\n         b'-' if is_signed_ty => (false, &src[1..]),\n-        _ => (true, src)\n+        _ => (true, src),\n     };\n \n     if digits.is_empty() {\n@@ -2738,7 +2738,9 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n /// [`i8::from_str_radix()`]: ../../std/primitive.i8.html#method.from_str_radix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseIntError { kind: IntErrorKind }\n+pub struct ParseIntError {\n+    kind: IntErrorKind,\n+}\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n enum IntErrorKind {"}, {"sha": "d35c451ac2604471de90bf2426d18d528fde1486", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -310,13 +310,13 @@ mod shift_max {\n         pub const isize: u32 = super::i64;\n     }\n \n-    pub const  i8: u32 = (1 << 3) - 1;\n+    pub const i8: u32 = (1 << 3) - 1;\n     pub const i16: u32 = (1 << 4) - 1;\n     pub const i32: u32 = (1 << 5) - 1;\n     pub const i64: u32 = (1 << 6) - 1;\n     pub use self::platform::isize;\n \n-    pub const  u8: u32 = i8;\n+    pub const u8: u32 = i8;\n     pub const u16: u32 = i16;\n     pub const u32: u32 = i32;\n     pub const u64: u32 = i64;"}, {"sha": "eb50d6e6135ef2124e10987519d18225fdf566f4", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -22,12 +22,12 @@ pub const LOG_LEVEL_NAMES: [&'static str; 5] = [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"\n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n     level.parse::<u32>()\n-         .ok()\n-         .or_else(|| {\n-             let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n-             pos.map(|p| p as u32 + 1)\n-         })\n-         .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n+        .ok()\n+        .or_else(|| {\n+            let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n+            pos.map(|p| p as u32 + 1)\n+        })\n+        .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n@@ -52,32 +52,31 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n                 continue;\n             }\n             let mut parts = s.split('=');\n-            let (log_level, name) = match (parts.next(),\n-                                           parts.next().map(|s| s.trim()),\n-                                           parts.next()) {\n-                (Some(part0), None, None) => {\n-                    // if the single argument is a log-level string or number,\n-                    // treat that as a global fallback\n-                    match parse_log_level(part0) {\n-                        Some(num) => (num, None),\n-                        None => (::MAX_LOG_LEVEL, Some(part0)),\n+            let (log_level, name) =\n+                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n+                    (Some(part0), None, None) => {\n+                        // if the single argument is a log-level string or number,\n+                        // treat that as a global fallback\n+                        match parse_log_level(part0) {\n+                            Some(num) => (num, None),\n+                            None => (::MAX_LOG_LEVEL, Some(part0)),\n+                        }\n                     }\n-                }\n-                (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n-                (Some(part0), Some(part1), None) => {\n-                    match parse_log_level(part1) {\n-                        Some(num) => (num, Some(part0)),\n-                        _ => {\n-                            println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n-                            continue;\n+                    (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n+                    (Some(part0), Some(part1), None) => {\n+                        match parse_log_level(part1) {\n+                            Some(num) => (num, Some(part0)),\n+                            _ => {\n+                                println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n+                                continue;\n+                            }\n                         }\n                     }\n-                }\n-                _ => {\n-                    println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n-                    continue;\n-                }\n-            };\n+                    _ => {\n+                        println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n+                        continue;\n+                    }\n+                };\n             dirs.push(LogDirective {\n                 name: name.map(str::to_owned),\n                 level: log_level,"}, {"sha": "83e66fdd3bc40e4c72c7bcaf2350b2be4084061d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -276,13 +276,15 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err\n         }\n         ResolutionError::VariableNotBoundInPattern(variable_name, from, to) => {\n-            struct_span_err!(resolver.session,\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0408,\n                              \"variable `{}` from pattern #{} is not bound in pattern #{}\",\n                              variable_name,\n                              from,\n-                             to)\n+                             to);\n+            err.span_label(span, &format!(\"pattern doesn't bind `{}`\", variable_name));\n+            err\n         }\n         ResolutionError::VariableBoundWithDifferentMode(variable_name,\n                                                         pattern_number,"}, {"sha": "d1fe7853445f204cb3c6be10f2e7964933b58c07", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -104,6 +104,7 @@ pub enum Class {\n     Lifetime,\n     PreludeTy,\n     PreludeVal,\n+    QuestionMark,\n }\n \n /// Trait that controls writing the output of syntax highlighting. Users should\n@@ -237,8 +238,10 @@ impl<'a> Classifier<'a> {\n             token::Dot | token::DotDot | token::DotDotDot | token::Comma | token::Semi |\n                 token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n                 token::CloseDelim(token::Brace) | token::CloseDelim(token::Paren) |\n-                token::CloseDelim(token::NoDelim) |\n-                token::Question => Class::None,\n+                token::CloseDelim(token::NoDelim) => Class::None,\n+\n+            token::Question => Class::QuestionMark,\n+\n             token::Dollar => {\n                 if self.lexer.peek().tok.is_ident() {\n                     self.in_macro_nonterminal = true;\n@@ -348,6 +351,7 @@ impl Class {\n             Class::Lifetime => \"lifetime\",\n             Class::PreludeTy => \"prelude-ty\",\n             Class::PreludeVal => \"prelude-val\",\n+            Class::QuestionMark => \"question-mark\"\n         }\n     }\n }"}, {"sha": "85ec4fe3f3f4d32c2d7b60a2c0576e3ca9512489", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -570,6 +570,10 @@ pre.rust .self, pre.rust .bool-val, pre.rust .prelude-val,\n pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }\n pre.rust .macro, pre.rust .macro-nonterminal { color: #3E999F; }\n pre.rust .lifetime { color: #B76514; }\n+pre.rust .question-mark {\n+    color: #ff9011;\n+    font-weight: bold;\n+}\n \n .rusttest { display: none; }\n pre.rust { position: relative; }"}, {"sha": "44dd4e9874ac43fe6d8ac5bc0b80158ba69b5584", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -20,11 +20,15 @@ use memchr;\n \n /// The `BufReader` struct adds buffering to any reader.\n ///\n-/// It can be excessively inefficient to work directly with a `Read` instance.\n-/// For example, every call to `read` on `TcpStream` results in a system call.\n-/// A `BufReader` performs large, infrequent reads on the underlying `Read`\n+/// It can be excessively inefficient to work directly with a [`Read`] instance.\n+/// For example, every call to [`read`] on [`TcpStream`] results in a system call.\n+/// A `BufReader` performs large, infrequent reads on the underlying [`Read`]\n /// and maintains an in-memory buffer of the results.\n ///\n+/// [`Read`]: ../../std/io/trait.Read.html\n+/// [`read`]: ../../std/net/struct.TcpStream.html#method.read\n+/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -254,15 +258,15 @@ impl<R: Seek> Seek for BufReader<R> {\n /// Wraps a writer and buffers its output.\n ///\n /// It can be excessively inefficient to work directly with something that\n-/// implements `Write`. For example, every call to `write` on `TcpStream`\n+/// implements [`Write`]. For example, every call to [`write`] on [`TcpStream`]\n /// results in a system call. A `BufWriter` keeps an in-memory buffer of data\n /// and writes it to an underlying writer in large, infrequent batches.\n ///\n /// The buffer will be written out when the writer is dropped.\n ///\n /// # Examples\n ///\n-/// Let's write the numbers one through ten to a `TcpStream`:\n+/// Let's write the numbers one through ten to a [`TcpStream`]:\n ///\n /// ```no_run\n /// use std::io::prelude::*;\n@@ -294,6 +298,10 @@ impl<R: Seek> Seek for BufReader<R> {\n /// By wrapping the stream with a `BufWriter`, these ten writes are all grouped\n /// together by the buffer, and will all be written out in one system call when\n /// the `stream` is dropped.\n+///\n+/// [`Write`]: ../../std/io/trait.Write.html\n+/// [`write`]: ../../std/net/struct.TcpStream.html#method.write\n+/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,"}, {"sha": "f08b7641521447582b4786c64c7db41c3480268a", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -136,6 +136,10 @@ impl<T: ?Sized> RwLock<T> {\n     /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic when called if the lock is already held by the current thread.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n@@ -188,6 +192,10 @@ impl<T: ?Sized> RwLock<T> {\n     /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic when called if the lock is already held by the current thread.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {"}, {"sha": "d75f6124827726d79cba494eec55509332645490", "filename": "src/test/compile-fail/E0408.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2FE0408.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2FE0408.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0408.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let x = Some(0);\n \n     match x {\n-        Some(y) | None => {} //~ ERROR E0408\n-        _ => ()\n+        Some(y) | None => {} //~  ERROR variable `y` from pattern #1 is not bound in pattern #2\n+        _ => ()              //~| NOTE pattern doesn't bind `y`\n     }\n }"}, {"sha": "f5e0c545bb52436fa4714d87aa3e59511d7f424c", "filename": "src/test/compile-fail/issue-2848.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -19,7 +19,7 @@ mod bar {\n fn main() {\n     use bar::foo::{alpha, charlie};\n     match alpha {\n-      alpha | beta => {} //~ ERROR variable `beta` from pattern #2 is not bound in pattern #1\n-      charlie => {}\n+      alpha | beta => {} //~  ERROR variable `beta` from pattern #2 is not bound in pattern #1\n+      charlie => {}      //~| NOTE pattern doesn't bind `beta`\n     }\n }"}, {"sha": "1e2541502ace874c04d28188a6557850d45361c9", "filename": "src/test/compile-fail/resolve-inconsistent-names.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d189af90841ca15f8d9dcc77628613f25e6b78/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs?ref=a8d189af90841ca15f8d9dcc77628613f25e6b78", "patch": "@@ -11,7 +11,9 @@\n fn main() {\n     let y = 1;\n     match y {\n-       a | b => {} //~ ERROR variable `a` from pattern #1 is not bound in pattern #2\n-       //~^ ERROR variable `b` from pattern #2 is not bound in pattern #1\n+       a | b => {} //~  ERROR variable `a` from pattern #1 is not bound in pattern #2\n+                   //~^ ERROR variable `b` from pattern #2 is not bound in pattern #1\n+                   //~| NOTE pattern doesn't bind `a`\n+                   //~| NOTE pattern doesn't bind `b`\n     }\n }"}]}