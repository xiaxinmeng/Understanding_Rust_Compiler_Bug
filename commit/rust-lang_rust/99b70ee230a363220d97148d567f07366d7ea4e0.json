{"sha": "99b70ee230a363220d97148d567f07366d7ea4e0", "node_id": "C_kwDOAAsO6NoAKDk5YjcwZWUyMzBhMzYzMjIwZDk3MTQ4ZDU2N2YwNzM2NmQ3ZWE0ZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-27T01:01:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-27T01:01:58Z"}, "message": "Auto merge of #96459 - Dylan-DPC:rollup-de6ud9d, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #92569 (Improve Error Messaging for Unconstructed Structs and Enum Variants in Generic Contexts)\n - #96370 (Cleanup `report_method_error` a bit)\n - #96383 (Fix erased region escaping into wfcheck due to #95395)\n - #96385 (Recover most `impl Trait` and `dyn Trait` lifetime bound suggestions under NLL)\n - #96410 (rustdoc: do not write `{{root}}` in `pub use ::foo` docs)\n - #96430 (Fix handling of `!` in rustdoc search)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5c9df8d245757383f2ee1c52162320d91dc98d09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c9df8d245757383f2ee1c52162320d91dc98d09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99b70ee230a363220d97148d567f07366d7ea4e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99b70ee230a363220d97148d567f07366d7ea4e0", "html_url": "https://github.com/rust-lang/rust/commit/99b70ee230a363220d97148d567f07366d7ea4e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99b70ee230a363220d97148d567f07366d7ea4e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7197189cd0e3a86d1b661d1dceb8bdff021d0b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7197189cd0e3a86d1b661d1dceb8bdff021d0b8", "html_url": "https://github.com/rust-lang/rust/commit/a7197189cd0e3a86d1b661d1dceb8bdff021d0b8"}, {"sha": "c0ed53c0dab14b9000abe4e6c9e86918d8c48224", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0ed53c0dab14b9000abe4e6c9e86918d8c48224", "html_url": "https://github.com/rust-lang/rust/commit/c0ed53c0dab14b9000abe4e6c9e86918d8c48224"}], "stats": {"total": 1334, "additions": 904, "deletions": 430}, "files": [{"sha": "b5ee4a5edce7d6e3ef60a36a91a8124699c137ac", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 42, "deletions": 77, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -1,17 +1,17 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::{\n-    error_reporting::nice_region_error::NiceRegionError,\n-    error_reporting::unexpected_hidden_region_diagnostic, NllRegionVariableOrigin,\n-    RelateParamBound,\n+    error_reporting::nice_region_error::{self, find_param_with_region, NiceRegionError},\n+    error_reporting::unexpected_hidden_region_diagnostic,\n+    NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::{kw, sym};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n \n use crate::borrowck_errors;\n \n@@ -651,82 +651,47 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         fr_name: RegionName,\n         outlived_fr: RegionVid,\n     ) {\n-        if let (Some(f), Some(ty::ReStatic)) =\n-            (self.to_error_region(fr), self.to_error_region(outlived_fr).as_deref())\n+        if let (Some(f), Some(outlived_f)) =\n+            (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some(&ty::Opaque(did, substs)) = self\n+            if *outlived_f != ty::ReStatic {\n+                return;\n+            }\n+\n+            let fn_returns = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n-                .map(|r| r.def_id)\n-                .and_then(|id| self.infcx.tcx.return_type_impl_trait(id))\n-                .map(|(ty, _)| ty.kind())\n-            {\n-                // Check whether or not the impl trait return type is intended to capture\n-                // data with the static lifetime.\n-                //\n-                // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n-                let has_static_predicate = {\n-                    let bounds = self.infcx.tcx.explicit_item_bounds(did);\n-\n-                    let mut found = false;\n-                    for (bound, _) in bounds {\n-                        if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            bound.kind().skip_binder()\n-                        {\n-                            let r = r.subst(self.infcx.tcx, substs);\n-                            if r.is_static() {\n-                                found = true;\n-                                break;\n-                            } else {\n-                                // If there's already a lifetime bound, don't\n-                                // suggest anything.\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    found\n-                };\n+                .map(|r| self.infcx.tcx.return_type_impl_or_dyn_traits(r.def_id))\n+                .unwrap_or_default();\n \n-                debug!(\n-                    \"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n-                    has_static_predicate\n-                );\n-                let static_str = kw::StaticLifetime;\n-                // If there is a static predicate, then the only sensible suggestion is to replace\n-                // fr with `'static`.\n-                if has_static_predicate {\n-                    diag.help(&format!(\"consider replacing `{fr_name}` with `{static_str}`\"));\n-                } else {\n-                    // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = self.infcx.tcx.def_span(did);\n-                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestable_fr_name = if fr_name.was_named() {\n-                            fr_name.to_string()\n-                        } else {\n-                            \"'_\".to_string()\n-                        };\n-                        let span = if snippet.ends_with(';') {\n-                            // `type X = impl Trait;`\n-                            span.with_hi(span.hi() - BytePos(1))\n-                        } else {\n-                            span\n-                        };\n-                        let suggestion = format!(\" + {suggestable_fr_name}\");\n-                        let span = span.shrink_to_hi();\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n-                                 `{fr_name}`, add `{suggestable_fr_name}` as a bound\",\n-                            ),\n-                            suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n+            if fn_returns.is_empty() {\n+                return;\n             }\n+\n+            let param = if let Some(param) = find_param_with_region(self.infcx.tcx, f, outlived_f) {\n+                param\n+            } else {\n+                return;\n+            };\n+\n+            let lifetime = if f.has_name() { fr_name.to_string() } else { \"'_\".to_string() };\n+\n+            let arg = match param.param.pat.simple_ident() {\n+                Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                None => \"the argument\".to_string(),\n+            };\n+            let captures = format!(\"captures data from {}\", arg);\n+\n+            return nice_region_error::suggest_new_region_bound(\n+                self.infcx.tcx,\n+                diag,\n+                fn_returns,\n+                lifetime,\n+                Some(arg),\n+                captures,\n+                Some((param.param_ty_span, param.param_ty.to_string())),\n+            );\n         }\n     }\n }"}, {"sha": "2d01673b61d315a6412be74cbe8bfcd40bccd026", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -3314,6 +3314,12 @@ impl<'hir> Node<'hir> {\n             _ => None,\n         }\n     }\n+\n+    /// Get the fields for the tuple-constructor,\n+    /// if this node is a tuple constructor, otherwise None\n+    pub fn tuple_fields(&self) -> Option<&'hir [FieldDef<'hir>]> {\n+        if let Node::Ctor(&VariantData::Tuple(fields, _)) = self { Some(fields) } else { None }\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "79f852d8a95e739e0ed1c10a4c11ff4c5b2cf4f0", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -15,6 +15,7 @@ mod trait_impl_difference;\n mod util;\n \n pub use static_impl_trait::suggest_new_region_bound;\n+pub use util::find_param_with_region;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {"}, {"sha": "7d3ed2ed38a307b6ff8c1b01b7cd40c5f88a2ebc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -2,14 +2,15 @@\n //! anonymous regions.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, Binder, DefIdTree, Region, Ty, TypeFoldable};\n use rustc_span::Span;\n \n /// Information about the anonymous region we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousParamInfo<'tcx> {\n+pub struct AnonymousParamInfo<'tcx> {\n     /// The parameter corresponding to the anonymous region.\n     pub param: &'tcx hir::Param<'tcx>,\n     /// The type corresponding to the anonymous region parameter.\n@@ -22,76 +23,83 @@ pub(super) struct AnonymousParamInfo<'tcx> {\n     pub is_first: bool,\n }\n \n+// This method walks the Type of the function body parameters using\n+// `fold_regions()` function and returns the\n+// &hir::Param of the function parameter corresponding to the anonymous\n+// region and the Ty corresponding to the named region.\n+// Currently only the case where the function declaration consists of\n+// one named region and one anonymous region is handled.\n+// Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n+// Here, we would return the hir::Param for y, we return the type &'a\n+// i32, which is the type of y but with the anonymous region replaced\n+// with 'a, the corresponding bound region and is_first which is true if\n+// the hir::Param is the first parameter in the function declaration.\n+pub fn find_param_with_region<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    anon_region: Region<'tcx>,\n+    replace_region: Region<'tcx>,\n+) -> Option<AnonymousParamInfo<'tcx>> {\n+    let (id, bound_region) = match *anon_region {\n+        ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+        ty::ReEarlyBound(ebr) => {\n+            (tcx.parent(ebr.def_id).unwrap(), ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name))\n+        }\n+        _ => return None, // not a free region\n+    };\n+\n+    let hir = &tcx.hir();\n+    let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n+    let body_id = hir.maybe_body_owned_by(hir_id)?;\n+    let body = hir.body(body_id);\n+    let owner_id = hir.body_owner(body_id);\n+    let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n+    let poly_fn_sig = tcx.fn_sig(id);\n+    let fn_sig = tcx.liberate_late_bound_regions(id, poly_fn_sig);\n+    body.params\n+        .iter()\n+        .take(if fn_sig.c_variadic {\n+            fn_sig.inputs().len()\n+        } else {\n+            assert_eq!(fn_sig.inputs().len(), body.params.len());\n+            body.params.len()\n+        })\n+        .enumerate()\n+        .find_map(|(index, param)| {\n+            // May return None; sometimes the tables are not yet populated.\n+            let ty = fn_sig.inputs()[index];\n+            let mut found_anon_region = false;\n+            let new_param_ty = tcx.fold_regions(ty, &mut false, |r, _| {\n+                if r == anon_region {\n+                    found_anon_region = true;\n+                    replace_region\n+                } else {\n+                    r\n+                }\n+            });\n+            if found_anon_region {\n+                let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                let param_ty_span = hir.span(ty_hir_id);\n+                let is_first = index == 0;\n+                Some(AnonymousParamInfo {\n+                    param,\n+                    param_ty: new_param_ty,\n+                    param_ty_span,\n+                    bound_region,\n+                    is_first,\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+}\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body parameters using\n-    // `fold_regions()` function and returns the\n-    // &hir::Param of the function parameter corresponding to the anonymous\n-    // region and the Ty corresponding to the named region.\n-    // Currently only the case where the function declaration consists of\n-    // one named region and one anonymous region is handled.\n-    // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Param for y, we return the type &'a\n-    // i32, which is the type of y but with the anonymous region replaced\n-    // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Param is the first parameter in the function declaration.\n     pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n     ) -> Option<AnonymousParamInfo<'_>> {\n-        let (id, bound_region) = match *anon_region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ebr) => (\n-                self.tcx().parent(ebr.def_id).unwrap(),\n-                ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name),\n-            ),\n-            _ => return None, // not a free region\n-        };\n-\n-        let hir = &self.tcx().hir();\n-        let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n-        let body_id = hir.maybe_body_owned_by(hir_id)?;\n-        let body = hir.body(body_id);\n-        let owner_id = hir.body_owner(body_id);\n-        let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n-        let poly_fn_sig = self.tcx().fn_sig(id);\n-        let fn_sig = self.tcx().liberate_late_bound_regions(id, poly_fn_sig);\n-        body.params\n-            .iter()\n-            .take(if fn_sig.c_variadic {\n-                fn_sig.inputs().len()\n-            } else {\n-                assert_eq!(fn_sig.inputs().len(), body.params.len());\n-                body.params.len()\n-            })\n-            .enumerate()\n-            .find_map(|(index, param)| {\n-                // May return None; sometimes the tables are not yet populated.\n-                let ty = fn_sig.inputs()[index];\n-                let mut found_anon_region = false;\n-                let new_param_ty = self.tcx().fold_regions(ty, &mut false, |r, _| {\n-                    if r == anon_region {\n-                        found_anon_region = true;\n-                        replace_region\n-                    } else {\n-                        r\n-                    }\n-                });\n-                if found_anon_region {\n-                    let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                    let param_ty_span = hir.span(ty_hir_id);\n-                    let is_first = index == 0;\n-                    Some(AnonymousParamInfo {\n-                        param,\n-                        param_ty: new_param_ty,\n-                        param_ty_span,\n-                        bound_region,\n-                        is_first,\n-                    })\n-                } else {\n-                    None\n-                }\n-            })\n+        find_param_with_region(self.tcx(), anon_region, replace_region)\n     }\n \n     // Here, we check for the case where the anonymous region"}, {"sha": "1caf93e5fe055fef2fc7eefdc603bb18b8362209", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -2681,21 +2681,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let trait_ref =\n             self.instantiate_mono_trait_ref(i.of_trait.as_ref()?, self.ast_ty_to_ty(i.self_ty));\n \n-        let x: &ty::AssocItem = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n+        let assoc = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n             tcx,\n             *ident,\n             ty::AssocKind::Fn,\n             trait_ref.def_id,\n         )?;\n \n-        let fn_sig = tcx.fn_sig(x.def_id).subst(\n+        let fn_sig = tcx.fn_sig(assoc.def_id).subst(\n             tcx,\n-            trait_ref.substs.extend_to(tcx, x.def_id, |param, _| tcx.mk_param_from_def(param)),\n+            trait_ref.substs.extend_to(tcx, assoc.def_id, |param, _| tcx.mk_param_from_def(param)),\n         );\n \n         let ty = if let Some(arg_idx) = arg_idx { fn_sig.input(arg_idx) } else { fn_sig.output() };\n \n-        Some(tcx.erase_late_bound_regions(ty))\n+        Some(tcx.liberate_late_bound_regions(fn_hir_id.expect_owner().to_def_id(), ty))\n     }\n \n     fn validate_late_bound_regions("}, {"sha": "47cb1ea48cb54c3c6f4519979d14da23015a3ce1", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -21,11 +21,13 @@ use crate::errors::{\n };\n use crate::type_error_struct;\n \n+use super::suggest_call_constructor;\n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::Diagnostic;\n+use rustc_errors::EmissionGuarantee;\n use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n@@ -1986,6 +1988,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n+    fn check_call_constructor<G: EmissionGuarantee>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, G>,\n+        base: &'tcx hir::Expr<'tcx>,\n+        def_id: DefId,\n+    ) {\n+        let local_id = def_id.expect_local();\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_id);\n+        let node = self.tcx.hir().get(hir_id);\n+\n+        if let Some(fields) = node.tuple_fields() {\n+            let kind = match self.tcx.opt_def_kind(local_id) {\n+                Some(DefKind::Ctor(of, _)) => of,\n+                _ => return,\n+            };\n+\n+            suggest_call_constructor(base.span, kind, fields.len(), err);\n+        }\n+    }\n+\n     fn suggest_await_on_field_access(\n         &self,\n         err: &mut Diagnostic,\n@@ -2055,6 +2077,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Opaque(_, _) => {\n                 self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n             }\n+            ty::FnDef(def_id, _) => {\n+                self.check_call_constructor(&mut err, base, def_id);\n+            }\n             _ => {}\n         }\n "}, {"sha": "80c31355fe71dde81b6a7d3db6e914749b1381fe", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 280, "deletions": 256, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::{\n     MultiSpan,\n };\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n@@ -29,7 +30,7 @@ use std::cmp::Ordering;\n use std::iter;\n \n use super::probe::{Mode, ProbeScope};\n-use super::{CandidateSource, MethodError, NoMatchData};\n+use super::{super::suggest_call_constructor, CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -271,205 +272,82 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                // FIXME(eddyb) this indentation is probably unnecessary.\n-                let mut err = {\n-                    // Suggest clamping down the type if the method that is being attempted to\n-                    // be used exists at all, and the type is an ambiguous numeric type\n-                    // ({integer}/{float}).\n-                    let mut candidates = all_traits(self.tcx)\n-                        .into_iter()\n-                        .filter_map(|info| self.associated_value(info.def_id, item_name));\n-                    // There are methods that are defined on the primitive types and won't be\n-                    // found when exploring `all_traits`, but we also need them to be accurate on\n-                    // our suggestions (#47759).\n-                    let found_assoc = |ty: Ty<'tcx>| {\n-                        simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n-                            .and_then(|simp| {\n-                                tcx.incoherent_impls(simp)\n-                                    .iter()\n-                                    .find_map(|&id| self.associated_value(id, item_name))\n-                            })\n-                            .is_some()\n-                    };\n-                    let found_candidate = candidates.next().is_some()\n-                        || found_assoc(tcx.types.i8)\n-                        || found_assoc(tcx.types.i16)\n-                        || found_assoc(tcx.types.i32)\n-                        || found_assoc(tcx.types.i64)\n-                        || found_assoc(tcx.types.i128)\n-                        || found_assoc(tcx.types.u8)\n-                        || found_assoc(tcx.types.u16)\n-                        || found_assoc(tcx.types.u32)\n-                        || found_assoc(tcx.types.u64)\n-                        || found_assoc(tcx.types.u128)\n-                        || found_assoc(tcx.types.f32)\n-                        || found_assoc(tcx.types.f32);\n-                    if let (true, false, SelfSource::MethodCall(expr), true) = (\n-                        actual.is_numeric(),\n-                        actual.has_concrete_skeleton(),\n-                        source,\n-                        found_candidate,\n-                    ) {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0689,\n-                            \"can't call {} `{}` on ambiguous numeric type `{}`\",\n-                            item_kind,\n-                            item_name,\n-                            ty_str\n-                        );\n-                        let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n-                        match expr.kind {\n-                            ExprKind::Lit(ref lit) => {\n-                                // numeric literal\n-                                let snippet = tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n-\n-                                // If this is a floating point literal that ends with '.',\n-                                // get rid of it to stop this from becoming a member access.\n-                                let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n \n-                                err.span_suggestion(\n-                                    lit.span,\n-                                    &format!(\n-                                        \"you must specify a concrete type for this numeric value, \\\n-                                         like `{}`\",\n-                                        concrete_type\n-                                    ),\n-                                    format!(\"{snippet}_{concrete_type}\"),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            ExprKind::Path(QPath::Resolved(_, path)) => {\n-                                // local binding\n-                                if let hir::def::Res::Local(hir_id) = path.res {\n-                                    let span = tcx.hir().span(hir_id);\n-                                    let snippet = tcx.sess.source_map().span_to_snippet(span);\n-                                    let filename = tcx.sess.source_map().span_to_filename(span);\n-\n-                                    let parent_node =\n-                                        self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n-                                    let msg = format!(\n-                                        \"you must specify a type for this binding, like `{}`\",\n-                                        concrete_type,\n-                                    );\n-\n-                                    match (filename, parent_node, snippet) {\n-                                        (\n-                                            FileName::Real(_),\n-                                            Node::Local(hir::Local {\n-                                                source: hir::LocalSource::Normal,\n-                                                ty,\n-                                                ..\n-                                            }),\n-                                            Ok(ref snippet),\n-                                        ) => {\n-                                            err.span_suggestion(\n-                                                // account for `let x: _ = 42;`\n-                                                //                  ^^^^\n-                                                span.to(ty\n-                                                    .as_ref()\n-                                                    .map(|ty| ty.span)\n-                                                    .unwrap_or(span)),\n-                                                &msg,\n-                                                format!(\"{}: {}\", snippet, concrete_type),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                        }\n-                                        _ => {\n-                                            err.span_label(span, msg);\n-                                        }\n-                                    }\n-                                }\n+                if self.suggest_constraining_numerical_ty(\n+                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                ) {\n+                    return None;\n+                }\n+\n+                span = item_name.span;\n+\n+                // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+                let mut ty_str_reported = ty_str.clone();\n+                if let ty::Adt(_, generics) = actual.kind() {\n+                    if generics.len() > 0 {\n+                        let mut autoderef = self.autoderef(span, actual);\n+                        let candidate_found = autoderef.any(|(ty, _)| {\n+                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                                self.tcx\n+                                    .inherent_impls(adt_deref.did())\n+                                    .iter()\n+                                    .filter_map(|def_id| self.associated_value(*def_id, item_name))\n+                                    .count()\n+                                    >= 1\n+                            } else {\n+                                false\n                             }\n-                            _ => {}\n-                        }\n-                        err.emit();\n-                        return None;\n-                    } else {\n-                        span = item_name.span;\n-\n-                        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-                        let mut ty_str_reported = ty_str.clone();\n-                        if let ty::Adt(_, generics) = actual.kind() {\n-                            if generics.len() > 0 {\n-                                let mut autoderef = self.autoderef(span, actual);\n-                                let candidate_found = autoderef.any(|(ty, _)| {\n-                                    if let ty::Adt(adt_deref, _) = ty.kind() {\n-                                        self.tcx\n-                                            .inherent_impls(adt_deref.did())\n-                                            .iter()\n-                                            .filter_map(|def_id| {\n-                                                self.associated_value(*def_id, item_name)\n-                                            })\n-                                            .count()\n-                                            >= 1\n-                                    } else {\n-                                        false\n-                                    }\n-                                });\n-                                let has_deref = autoderef.step_count() > 0;\n-                                if !candidate_found\n-                                    && !has_deref\n-                                    && unsatisfied_predicates.is_empty()\n-                                {\n-                                    if let Some((path_string, _)) = ty_str.split_once('<') {\n-                                        ty_str_reported = path_string.to_string();\n-                                    }\n-                                }\n+                        });\n+                        let has_deref = autoderef.step_count() > 0;\n+                        if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n+                            if let Some((path_string, _)) = ty_str.split_once('<') {\n+                                ty_str_reported = path_string.to_string();\n                             }\n                         }\n+                    }\n+                }\n \n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0599,\n-                            \"no {} named `{}` found for {} `{}` in the current scope\",\n-                            item_kind,\n-                            item_name,\n-                            actual.prefix_string(self.tcx),\n-                            ty_str_reported,\n-                        );\n-                        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n-                            self.suggest_await_before_method(\n-                                &mut err, item_name, actual, cal, span,\n-                            );\n-                        }\n-                        if let Some(span) =\n-                            tcx.resolutions(()).confused_type_with_std_module.get(&span)\n-                        {\n-                            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n-                                err.span_suggestion(\n-                                    *span,\n-                                    \"you are looking for the module in `std`, \\\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0599,\n+                    \"no {} named `{}` found for {} `{}` in the current scope\",\n+                    item_kind,\n+                    item_name,\n+                    actual.prefix_string(self.tcx),\n+                    ty_str_reported,\n+                );\n+                if actual.references_error() {\n+                    err.downgrade_to_delayed_bug();\n+                }\n+\n+                if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+                    self.suggest_await_before_method(\n+                        &mut err, item_name, actual, cal, span,\n+                    );\n+                }\n+                if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            \"you are looking for the module in `std`, \\\n                                      not the primitive type\",\n-                                    format!(\"std::{}\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        if let ty::RawPtr(_) = &actual.kind() {\n-                            err.note(\n-                                \"try using `<*const T>::as_ref()` to get a reference to the \\\n+                            format!(\"std::{}\", snippet),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                if let ty::RawPtr(_) = &actual.kind() {\n+                    err.note(\n+                        \"try using `<*const T>::as_ref()` to get a reference to the \\\n                                       type behind the pointer: https://doc.rust-lang.org/std/\\\n                                       primitive.pointer.html#method.as_ref\",\n-                            );\n-                            err.note(\n-                                \"using `<*const T>::as_ref()` on a pointer \\\n+                    );\n+                    err.note(\n+                        \"using `<*const T>::as_ref()` on a pointer \\\n                                       which is unaligned or points to invalid \\\n                                       or uninitialized memory is undefined behavior\",\n-                            );\n-                        }\n-                        err\n-                    }\n-                };\n-\n-                if actual.references_error() {\n-                    err.downgrade_to_delayed_bug();\n+                    );\n                 }\n \n                 if let Some(def) = actual.ty_adt_def() {\n@@ -488,19 +366,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if self.is_fn_ty(rcvr_ty, span) {\n-                    fn report_function<T: std::fmt::Display>(err: &mut Diagnostic, name: T) {\n-                        err.note(\n-                            &format!(\"`{}` is a function, perhaps you wish to call it\", name,),\n-                        );\n-                    }\n-\n                     if let SelfSource::MethodCall(expr) = source {\n-                        if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n-                            report_function(&mut err, expr_string);\n-                        } else if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n-                            if let Some(segment) = path.segments.last() {\n-                                report_function(&mut err, segment.ident);\n+                        let suggest = if let ty::FnDef(def_id, _) = rcvr_ty.kind() {\n+                            let local_id = def_id.expect_local();\n+                            let hir_id = tcx.hir().local_def_id_to_hir_id(local_id);\n+                            let node = tcx.hir().get(hir_id);\n+                            let fields = node.tuple_fields();\n+\n+                            if let Some(fields) = fields\n+                                && let Some(DefKind::Ctor(of, _)) = self.tcx.opt_def_kind(local_id) {\n+                                    Some((fields, of))\n+                            } else {\n+                                None\n                             }\n+                        } else {\n+                            None\n+                        };\n+\n+                        // If the function is a tuple constructor, we recommend that they call it\n+                        if let Some((fields, kind)) = suggest {\n+                            suggest_call_constructor(expr.span, kind, fields.len(), &mut err);\n+                        } else {\n+                            // General case\n+                            err.span_label(\n+                                expr.span,\n+                                \"this is a function, perhaps you wish to call it\",\n+                            );\n                         }\n                     }\n                 }\n@@ -985,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let mut label_span_not_found = || {\n+                let label_span_not_found = |err: &mut DiagnosticBuilder<'_, _>| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n                         let is_string_or_ref_str = match actual.kind() {\n@@ -1071,62 +962,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    let field_receiver =\n-                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n-                                let variant = &def.non_enum_variant();\n-                                self.tcx.find_field_index(item_name, variant).map(|index| {\n-                                    let field = &variant.fields[index];\n-                                    let field_ty = field.ty(tcx, substs);\n-                                    (field, field_ty)\n-                                })\n-                            }\n-                            _ => None,\n-                        });\n-\n-                    if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n-                        let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n-\n-                        if is_accessible {\n-                            if self.is_fn_ty(field_ty, span) {\n-                                let expr_span = expr.span.to(item_name.span);\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"to call the function stored in `{}`, \\\n-                                         surround the field access with parentheses\",\n-                                        item_name,\n-                                    ),\n-                                    vec![\n-                                        (expr_span.shrink_to_lo(), '('.to_string()),\n-                                        (expr_span.shrink_to_hi(), ')'.to_string()),\n-                                    ],\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                let call_expr = self\n-                                    .tcx\n-                                    .hir()\n-                                    .expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-\n-                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"remove the arguments\",\n-                                        String::new(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        }\n-\n-                        let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n-                        err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n-                    } else if lev_candidate.is_none() && !custom_span_label {\n-                        label_span_not_found();\n+                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                        && lev_candidate.is_none()\n+                        && !custom_span_label\n+                    {\n+                        label_span_not_found(&mut err);\n                     }\n                 } else if !custom_span_label {\n-                    label_span_not_found();\n+                    label_span_not_found(&mut err);\n                 }\n \n                 if let SelfSource::MethodCall(expr) = source\n@@ -1313,6 +1156,187 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn suggest_field_call(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        expr: &hir::Expr<'_>,\n+        item_name: Ident,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let field_receiver = self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n+            ty::Adt(def, substs) if !def.is_enum() => {\n+                let variant = &def.non_enum_variant();\n+                tcx.find_field_index(item_name, variant).map(|index| {\n+                    let field = &variant.fields[index];\n+                    let field_ty = field.ty(tcx, substs);\n+                    (field, field_ty)\n+                })\n+            }\n+            _ => None,\n+        });\n+        if let Some((field, field_ty)) = field_receiver {\n+            let scope = tcx.parent_module(self.body_id).to_def_id();\n+            let is_accessible = field.vis.is_accessible_from(scope, tcx);\n+\n+            if is_accessible {\n+                if self.is_fn_ty(field_ty, span) {\n+                    let expr_span = expr.span.to(item_name.span);\n+                    err.multipart_suggestion(\n+                        &format!(\n+                            \"to call the function stored in `{}`, \\\n+                                         surround the field access with parentheses\",\n+                            item_name,\n+                        ),\n+                        vec![\n+                            (expr_span.shrink_to_lo(), '('.to_string()),\n+                            (expr_span.shrink_to_hi(), ')'.to_string()),\n+                        ],\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+                    if let Some(span) = call_expr.span.trim_start(item_name.span) {\n+                        err.span_suggestion(\n+                            span,\n+                            \"remove the arguments\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+\n+            let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n+            err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn suggest_constraining_numerical_ty(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        actual: Ty<'tcx>,\n+        source: SelfSource<'_>,\n+        span: Span,\n+        item_kind: &str,\n+        item_name: Ident,\n+        ty_str: &str,\n+    ) -> bool {\n+        let found_candidate = all_traits(self.tcx)\n+            .into_iter()\n+            .any(|info| self.associated_value(info.def_id, item_name).is_some());\n+        let found_assoc = |ty: Ty<'tcx>| {\n+            simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+                .and_then(|simp| {\n+                    tcx.incoherent_impls(simp)\n+                        .iter()\n+                        .find_map(|&id| self.associated_value(id, item_name))\n+                })\n+                .is_some()\n+        };\n+        let found_candidate = found_candidate\n+            || found_assoc(tcx.types.i8)\n+            || found_assoc(tcx.types.i16)\n+            || found_assoc(tcx.types.i32)\n+            || found_assoc(tcx.types.i64)\n+            || found_assoc(tcx.types.i128)\n+            || found_assoc(tcx.types.u8)\n+            || found_assoc(tcx.types.u16)\n+            || found_assoc(tcx.types.u32)\n+            || found_assoc(tcx.types.u64)\n+            || found_assoc(tcx.types.u128)\n+            || found_assoc(tcx.types.f32)\n+            || found_assoc(tcx.types.f32);\n+        if found_candidate\n+            && actual.is_numeric()\n+            && !actual.has_concrete_skeleton()\n+            && let SelfSource::MethodCall(expr) = source\n+        {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0689,\n+                \"can't call {} `{}` on ambiguous numeric type `{}`\",\n+                item_kind,\n+                item_name,\n+                ty_str\n+            );\n+            let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n+            match expr.kind {\n+                ExprKind::Lit(ref lit) => {\n+                    // numeric literal\n+                    let snippet = tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(lit.span)\n+                        .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n+\n+                    // If this is a floating point literal that ends with '.',\n+                    // get rid of it to stop this from becoming a member access.\n+                    let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n+\n+                    err.span_suggestion(\n+                        lit.span,\n+                        &format!(\n+                            \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n+                            concrete_type\n+                        ),\n+                        format!(\"{snippet}_{concrete_type}\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ExprKind::Path(QPath::Resolved(_, path)) => {\n+                    // local binding\n+                    if let hir::def::Res::Local(hir_id) = path.res {\n+                        let span = tcx.hir().span(hir_id);\n+                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n+                        let filename = tcx.sess.source_map().span_to_filename(span);\n+\n+                        let parent_node =\n+                            self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                        let msg = format!(\n+                            \"you must specify a type for this binding, like `{}`\",\n+                            concrete_type,\n+                        );\n+\n+                        match (filename, parent_node, snippet) {\n+                            (\n+                                FileName::Real(_),\n+                                Node::Local(hir::Local {\n+                                    source: hir::LocalSource::Normal,\n+                                    ty,\n+                                    ..\n+                                }),\n+                                Ok(ref snippet),\n+                            ) => {\n+                                err.span_suggestion(\n+                                    // account for `let x: _ = 42;`\n+                                    //                  ^^^^\n+                                    span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n+                                    &msg,\n+                                    format!(\"{}: {}\", snippet, concrete_type),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            _ => {\n+                                err.span_label(span, msg);\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            err.emit();\n+            return true;\n+        }\n+        false\n+    }\n+\n     crate fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "f7bb30cd13e6f030b0ba1d50e6d9225e2491f917", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -98,12 +98,15 @@ pub use check::{check_item_type, check_wf_new};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::*;\n+use hir::def::CtorOf;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticBuilder, EmissionGuarantee, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -988,3 +991,36 @@ fn has_expected_num_generic_args<'tcx>(\n         generics.count() == expected + if generics.has_self { 1 } else { 0 }\n     })\n }\n+\n+/// Suggests calling the constructor of a tuple struct or enum variant\n+///\n+/// * `snippet` - The snippet of code that references the constructor\n+/// * `span` - The span of the snippet\n+/// * `params` - The number of parameters the constructor accepts\n+/// * `err` - A mutable diagnostic builder to add the suggestion to\n+fn suggest_call_constructor<G: EmissionGuarantee>(\n+    span: Span,\n+    kind: CtorOf,\n+    params: usize,\n+    err: &mut DiagnosticBuilder<'_, G>,\n+) {\n+    // Note: tuple-structs don't have named fields, so just use placeholders\n+    let args = vec![\"_\"; params].join(\", \");\n+    let applicable = if params > 0 {\n+        Applicability::HasPlaceholders\n+    } else {\n+        // When n = 0, it's an empty-tuple struct/enum variant\n+        // so we trivially know how to construct it\n+        Applicability::MachineApplicable\n+    };\n+    let kind = match kind {\n+        CtorOf::Struct => \"a struct\",\n+        CtorOf::Variant => \"an enum variant\",\n+    };\n+    err.span_label(span, &format!(\"this is the constructor of {kind}\"));\n+    err.multipart_suggestion(\n+        \"call the constructor\",\n+        vec![(span.shrink_to_lo(), \"(\".to_string()), (span.shrink_to_hi(), format!(\")({args})\"))],\n+        applicable,\n+    );\n+}"}, {"sha": "118807a82864faceeac7ad25cc7b28c1b447a052", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::kw;\n use rustc_span::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n@@ -679,7 +680,7 @@ fn resolved_path<'cx>(\n \n     if print_all {\n         for seg in &path.segments[..path.segments.len() - 1] {\n-            write!(w, \"{}::\", seg.name)?;\n+            write!(w, \"{}::\", if seg.name == kw::PathRoot { \"\" } else { seg.name.as_str() })?;\n         }\n     }\n     if w.alternate() {"}, {"sha": "c1d2ec540b0b0bcf14cfcbc5cbe7e4253986ccf7", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -310,10 +310,20 @@ window.initSearch = function(rawSearchIndex) {\n      */\n     function getIdentEndPosition(parserState) {\n         let end = parserState.pos;\n+        let foundExclamation = false;\n         while (parserState.pos < parserState.length) {\n             const c = parserState.userQuery[parserState.pos];\n             if (!isIdentCharacter(c)) {\n-                if (isErrorCharacter(c)) {\n+                if (c === \"!\") {\n+                    if (foundExclamation) {\n+                        throw new Error(\"Cannot have more than one `!` in an ident\");\n+                    } else if (parserState.pos + 1 < parserState.length &&\n+                        isIdentCharacter(parserState.userQuery[parserState.pos + 1]))\n+                    {\n+                        throw new Error(\"`!` can only be at the end of an ident\");\n+                    }\n+                    foundExclamation = true;\n+                } else if (isErrorCharacter(c)) {\n                     throw new Error(`Unexpected \\`${c}\\``);\n                 } else if (\n                     isStopCharacter(c) ||\n@@ -329,6 +339,7 @@ window.initSearch = function(rawSearchIndex) {\n                     }\n                     // Skip current \":\".\n                     parserState.pos += 1;\n+                    foundExclamation = false;\n                 } else {\n                     throw new Error(`Unexpected \\`${c}\\``);\n                 }\n@@ -591,7 +602,7 @@ window.initSearch = function(rawSearchIndex) {\n      *\n      * The supported syntax by this parser is as follow:\n      *\n-     * ident = *(ALPHA / DIGIT / \"_\")\n+     * ident = *(ALPHA / DIGIT / \"_\") [!]\n      * path = ident *(DOUBLE-COLON ident)\n      * arg = path [generics]\n      * arg-without-generic = path"}, {"sha": "dc42031e05f2f21f2522fe94e1a6fbade387fec8", "filename": "src/test/rustdoc-js-std/parser-errors.js", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -35,6 +35,8 @@ const QUERY = [\n     \"a,:\",\n     \"  a<>  :\",\n     \"mod : :\",\n+    \"a!a\",\n+    \"a!!\",\n ];\n \n const PARSED = [\n@@ -362,4 +364,22 @@ const PARSED = [\n         userQuery: \"mod : :\",\n         error: 'Unexpected `:`',\n     },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a!a\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a!a\",\n+        error: '`!` can only be at the end of an ident',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a!!\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a!!\",\n+        error: 'Cannot have more than one `!` in an ident',\n+    },\n ];"}, {"sha": "4b5ab01ac761b5fb449ec11920757e6a8ffedcec", "filename": "src/test/rustdoc-js-std/parser-ident.js", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-ident.js", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-ident.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-ident.js?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,93 @@\n+const QUERY = [\n+    \"R<!>\",\n+    \"!\",\n+    \"a!\",\n+    \"a!::b\",\n+    \"a!::b!\",\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [{\n+            name: \"r\",\n+            fullPath: [\"r\"],\n+            pathWithoutLast: [],\n+            pathLast: \"r\",\n+            generics: [\n+                {\n+                    name: \"!\",\n+                    fullPath: [\"!\"],\n+                    pathWithoutLast: [],\n+                    pathLast: \"!\",\n+                    generics: [],\n+                },\n+            ],\n+        }],\n+        foundElems: 1,\n+        original: \"R<!>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"r<!>\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"!\",\n+            fullPath: [\"!\"],\n+            pathWithoutLast: [],\n+            pathLast: \"!\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"!\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"!\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"a!\",\n+            fullPath: [\"a!\"],\n+            pathWithoutLast: [],\n+            pathLast: \"a!\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"a!\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a!\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"a!::b\",\n+            fullPath: [\"a!\", \"b\"],\n+            pathWithoutLast: [\"a!\"],\n+            pathLast: \"b\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"a!::b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a!::b\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"a!::b!\",\n+            fullPath: [\"a!\", \"b!\"],\n+            pathWithoutLast: [\"a!\"],\n+            pathLast: \"b!\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"a!::b!\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a!::b!\",\n+        error: null,\n+    },\n+];"}, {"sha": "6fce17dcabdd815085239bae4348a83cb8ef26db", "filename": "src/test/rustdoc-js-std/parser-returned.js", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -1,4 +1,10 @@\n-const QUERY = ['-> F<P>', '-> P', '->,a', 'aaaaa->a'];\n+const QUERY = [\n+    \"-> F<P>\",\n+    \"-> P\",\n+    \"->,a\",\n+    \"aaaaa->a\",\n+    \"-> !\",\n+];\n \n const PARSED = [\n     {\n@@ -75,4 +81,19 @@ const PARSED = [\n         userQuery: \"aaaaa->a\",\n         error: null,\n     },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> !\",\n+        returned: [{\n+            name: \"!\",\n+            fullPath: [\"!\"],\n+            pathWithoutLast: [],\n+            pathLast: \"!\",\n+            generics: [],\n+        }],\n+        typeFilter: -1,\n+        userQuery: \"-> !\",\n+        error: null,\n+    },\n ];"}, {"sha": "ff33fb63a0bab20208d3ca2bcb7ac59785a0caa5", "filename": "src/test/rustdoc/issue-95873.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc%2Fissue-95873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc%2Fissue-95873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-95873.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,2 @@\n+// @has issue_95873/index.html \"//*[@class='item-left import-item']\" \"pub use ::std as x;\"\n+pub use ::std as x;"}, {"sha": "f0f123f85a03f1ad5f1c67172b429c11a9d9c251", "filename": "src/test/rustdoc/issue-96381.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc%2Fissue-96381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Frustdoc%2Fissue-96381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-96381.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+// should-fail\n+\n+#![allow(unused)]\n+\n+trait Foo<T>: Sized {\n+    fn bar(i: i32, t: T, s: &Self) -> (T, i32);\n+}\n+\n+impl Foo<usize> for () {\n+    fn bar(i: _, t: _, s: _) -> _ {\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+        (1, 2)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3d2bcb8ad3550922d568c46c90673cf16ef72f8f", "filename": "src/test/ui/functions-closures/fn-help-with-err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -3,14 +3,14 @@ fn main() {\n     let arc = std::sync::Arc::new(oops);\n     //~^ ERROR cannot find value `oops` in this scope\n     //~| NOTE not found\n-    // The error \"note: `arc` is a function, perhaps you wish to call it\" MUST NOT appear.\n+    // The error \"note: this is a function, perhaps you wish to call it\" MUST NOT appear.\n     arc.blablabla();\n     //~^ ERROR no method named `blablabla`\n     //~| NOTE method not found\n     let arc2 = std::sync::Arc::new(|| 1);\n-    // The error \"note: `arc2` is a function, perhaps you wish to call it\" SHOULD appear\n+    // The error \"note: this is a function, perhaps you wish to call it\" SHOULD appear\n     arc2.blablabla();\n     //~^ ERROR no method named `blablabla`\n     //~| NOTE method not found\n-    //~| NOTE `arc2` is a function, perhaps you wish to call it\n+    //~| NOTE this is a function, perhaps you wish to call it\n }"}, {"sha": "3e42cb1fb6ec02d6f160894aa0a551501101ba28", "filename": "src/test/ui/functions-closures/fn-help-with-err.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -14,9 +14,9 @@ error[E0599]: no method named `blablabla` found for struct `Arc<[closure@$DIR/fn\n   --> $DIR/fn-help-with-err.rs:12:10\n    |\n LL |     arc2.blablabla();\n-   |          ^^^^^^^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:40]>`\n-   |\n-   = note: `arc2` is a function, perhaps you wish to call it\n+   |     ---- ^^^^^^^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:40]>`\n+   |     |\n+   |     this is a function, perhaps you wish to call it\n \n error: aborting due to 3 previous errors\n "}, {"sha": "66cffa9e36c0ddcea71577acfe208186ba921fe5", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -24,10 +24,14 @@ LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send\n LL |     x\n    |     ^ returning this value requires that `'b` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, add `'b` as a bound\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n    |                                                                                  ++++\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a + 'b> {\n+   |                                                                                 ++++\n \n error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:20:5"}, {"sha": "5a190649b63191436cd3db3ab939f774f32e4e34", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -32,15 +32,29 @@ LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               |\n    |               let's call the lifetime of this reference `'1`\n    |\n-   = help: consider replacing `'1` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n+   |                                    ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n+   |               ~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n    |\n-   = help: consider replacing `'a` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                             ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n+   |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n   --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n@@ -57,14 +71,30 @@ LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               -                                       ^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n    |               |\n    |               let's call the lifetime of this reference `'1`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ++++\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ++++\n \n error: lifetime may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n    |\n-   = help: consider replacing `'a` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n+   |                                                           ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:34:5"}, {"sha": "9d9f32a97c065a0f29a86308087bfae20c36e374", "filename": "src/test/ui/issues/issue-16922.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -5,6 +5,11 @@ LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n    |                       - let's call the lifetime of this reference `'1`\n LL |     Box::new(value) as Box<dyn Any>\n    |     ^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `value`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n+   |                                          ++++\n \n error: aborting due to previous error\n "}, {"sha": "c5d2ec0840996ac6afc42868ae0082c82226f913", "filename": "src/test/ui/issues/issue-29124.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -2,17 +2,17 @@ error[E0599]: no method named `x` found for fn item `fn() -> Ret {Obj::func}` in\n   --> $DIR/issue-29124.rs:15:15\n    |\n LL |     Obj::func.x();\n-   |               ^ method not found in `fn() -> Ret {Obj::func}`\n-   |\n-   = note: `Obj::func` is a function, perhaps you wish to call it\n+   |     --------- ^ method not found in `fn() -> Ret {Obj::func}`\n+   |     |\n+   |     this is a function, perhaps you wish to call it\n \n error[E0599]: no method named `x` found for fn item `fn() -> Ret {func}` in the current scope\n   --> $DIR/issue-29124.rs:17:10\n    |\n LL |     func.x();\n-   |          ^ method not found in `fn() -> Ret {func}`\n-   |\n-   = note: `func` is a function, perhaps you wish to call it\n+   |     ---- ^ method not found in `fn() -> Ret {func}`\n+   |     |\n+   |     this is a function, perhaps you wish to call it\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8e19f14009a0ea92e0498c5f81d2a1c0ff012fe2", "filename": "src/test/ui/issues/issue-57362-1.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -2,9 +2,10 @@ error[E0599]: no method named `f` found for fn pointer `fn(&u8)` in the current\n   --> $DIR/issue-57362-1.rs:20:7\n    |\n LL |     a.f();\n-   |       ^ method not found in `fn(&u8)`\n+   |     - ^ method not found in `fn(&u8)`\n+   |     |\n+   |     this is a function, perhaps you wish to call it\n    |\n-   = note: `a` is a function, perhaps you wish to call it\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Trait` defines an item `f`, perhaps you need to implement it\n   --> $DIR/issue-57362-1.rs:8:1"}, {"sha": "8d02ef71d1bc6c3636e906620b1debf76b8b0d06", "filename": "src/test/ui/nll/mir_check_cast_unsize.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -5,6 +5,11 @@ LL | fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n    |        -- lifetime `'a` defined here\n LL |     x\n    |     ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn bar<'a>(x: &'a u32) -> &'static dyn Debug + 'a {\n+   |                                              ++++\n \n error: aborting due to previous error\n "}, {"sha": "43695a7511d275b711eee07a87e59b51086c17c1", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -6,6 +6,11 @@ LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n ...\n LL |     ss.r\n    |     ^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `ss`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n+   |                                                   ++++\n \n error[E0507]: cannot move out of `ss.r` which is behind a mutable reference\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5"}, {"sha": "724b06ce8b168563f110d8b80f4f4edd4d90eebb", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -5,6 +5,15 @@ LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n    |         - let's call the lifetime of this reference `'1`\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n    |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn a(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn a(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ~~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:19:5\n@@ -13,6 +22,15 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n    |         - let's call the lifetime of this reference `'1`\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn b(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn b(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ~~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:27:5\n@@ -22,6 +40,11 @@ LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n ...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `v`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                               ++++\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:33:5"}, {"sha": "473c99b672fb692125395e117e4bcd0241a2385f", "filename": "src/test/ui/regions/regions-close-object-into-object-2.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -5,6 +5,15 @@ LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n    |      -- lifetime `'a` defined here\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'a> {\n+   |                                                            ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn g<'a, T: 'static>(v: Box<(dyn A<T> + 'static)>) -> Box<dyn X + 'static> {\n+   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0515]: cannot return value referencing local data `*v`\n   --> $DIR/regions-close-object-into-object-2.rs:13:5"}, {"sha": "05ddc09b2d0b7a31a37969a18b48a571e671075f", "filename": "src/test/ui/regions/regions-close-object-into-object-4.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -29,6 +29,15 @@ LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n    |      -- lifetime `'a` defined here\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'a> {\n+   |                                                    ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn i<'a, T, U>(v: Box<(dyn A<U> + 'static)>) -> Box<dyn X + 'static> {\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0515]: cannot return value referencing local data `*v`\n   --> $DIR/regions-close-object-into-object-4.rs:13:5"}, {"sha": "ce4d2d4d111c3dc7d4c2745dfa53e155119e6a5b", "filename": "src/test/ui/regions/regions-proc-bound-capture.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -6,6 +6,15 @@ LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n LL |     // This is illegal, because the region bound on `proc` is 'static.\n LL |     Box::new(move || { *x })\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + '_> {\n+   |                                                           ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn static_proc(x: &'static isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "6c65e4f0175428e10640dac31ffcac1d78bb3785", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.nll.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -9,10 +9,14 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'1` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n    |                                                          ++++\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> {\n+   |                                                        ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:39:9\n@@ -24,6 +28,11 @@ LL | |             current: None,\n LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n+   |                                                        ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:50:9\n@@ -35,6 +44,11 @@ LL | |             current: None,\n LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n+   |                                                               ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:61:9\n@@ -47,10 +61,14 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n    |                                                                 ++++\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> {\n+   |                                                               ++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1875d8280cb627b21e8b25be5406249f85b3cbcb", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,14 @@\n+struct Bar<T> {\n+    bar: T\n+}\n+\n+struct Foo();\n+impl Foo {\n+    fn foo() { }\n+}\n+\n+fn main() {\n+    let thing = Bar { bar: Foo };\n+    thing.bar.foo();\n+    //~^ ERROR no method named `foo` found for fn item `fn() -> Foo {Foo}` in the current scope [E0599]\n+}"}, {"sha": "6ed70b301e4a45543e547148177fd1222fa9bfad", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo}` in the current scope\n+  --> $DIR/empty-tuple-method.rs:12:15\n+   |\n+LL |     thing.bar.foo();\n+   |     --------- ^^^ method not found in `fn() -> Foo {Foo}`\n+   |     |\n+   |     this is the constructor of a struct\n+   |\n+help: call the constructor\n+   |\n+LL |     (thing.bar)().foo();\n+   |     +         +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "3b926b90f10bbe23c293dea4a226c8d640576f78", "filename": "src/test/ui/typeck/issue-87181/enum-variant.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+struct Bar<T> {\n+    bar: T\n+}\n+\n+enum Foo{\n+    Tup()\n+}\n+impl Foo {\n+    fn foo() { }\n+}\n+\n+fn main() {\n+    let thing = Bar { bar: Foo::Tup };\n+    thing.bar.foo();\n+    //~^ ERROR no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` in the current scope [E0599]\n+}"}, {"sha": "a3a818696ab5ba18afc336f88130dd2f4ade7ed3", "filename": "src/test/ui/typeck/issue-87181/enum-variant.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` in the current scope\n+  --> $DIR/enum-variant.rs:14:15\n+   |\n+LL |     thing.bar.foo();\n+   |     --------- ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n+   |     |\n+   |     this is the constructor of an enum variant\n+   |\n+help: call the constructor\n+   |\n+LL |     (thing.bar)().foo();\n+   |     +         +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "00e3b460ecf3239fb67380d436cfc40be485c247", "filename": "src/test/ui/typeck/issue-87181/tuple-field.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,14 @@\n+struct Bar<T> {\n+    bar: T\n+}\n+\n+struct Foo(char, u16);\n+impl Foo {\n+    fn foo() { }\n+}\n+\n+fn main() {\n+    let thing = Bar { bar: Foo };\n+    thing.bar.0;\n+    //~^ ERROR no field `0` on type `fn(char, u16) -> Foo {Foo}` [E0609]\n+}"}, {"sha": "4d22ada0247e98f71e76c9d0813926bc12ada199", "filename": "src/test/ui/typeck/issue-87181/tuple-field.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+error[E0609]: no field `0` on type `fn(char, u16) -> Foo {Foo}`\n+  --> $DIR/tuple-field.rs:12:15\n+   |\n+LL |     thing.bar.0;\n+   |     --------- ^\n+   |     |\n+   |     this is the constructor of a struct\n+   |\n+help: call the constructor\n+   |\n+LL |     (thing.bar)(_, _).0;\n+   |     +         +++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "e88f642b0707bf4c4428289cdfedcdac66bb47b1", "filename": "src/test/ui/typeck/issue-87181/tuple-method.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,14 @@\n+struct Bar<T> {\n+    bar: T\n+}\n+\n+struct Foo(u8, i32);\n+impl Foo {\n+    fn foo() { }\n+}\n+\n+fn main() {\n+    let thing = Bar { bar: Foo };\n+    thing.bar.foo();\n+    //~^ ERROR no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}` in the current scope [E0599]\n+}"}, {"sha": "1e392e17984b09167daaf428c24cf68837c02739", "filename": "src/test/ui/typeck/issue-87181/tuple-method.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -0,0 +1,16 @@\n+error[E0599]: no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}` in the current scope\n+  --> $DIR/tuple-method.rs:12:15\n+   |\n+LL |     thing.bar.foo();\n+   |     --------- ^^^ method not found in `fn(u8, i32) -> Foo {Foo}`\n+   |     |\n+   |     this is the constructor of a struct\n+   |\n+help: call the constructor\n+   |\n+LL |     (thing.bar)(_, _).foo();\n+   |     +         +++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "e9883903674ad47e1f3a2d657b5dd69ab0509f11", "filename": "src/test/ui/unboxed-closures/unboxed-closures-static-call-wrong-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -2,9 +2,9 @@ error[E0599]: no method named `call` found for closure `[closure@$DIR/unboxed-cl\n   --> $DIR/unboxed-closures-static-call-wrong-trait.rs:7:10\n    |\n LL |     mut_.call((0, ));\n-   |          ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:31]`\n-   |\n-   = note: `mut_` is a function, perhaps you wish to call it\n+   |     ---- ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:31]`\n+   |     |\n+   |     this is a function, perhaps you wish to call it\n \n error: aborting due to previous error\n "}, {"sha": "0ffb77cf02164355c14f61d30aeeefcf98b4d8c7", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99b70ee230a363220d97148d567f07366d7ea4e0/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=99b70ee230a363220d97148d567f07366d7ea4e0", "patch": "@@ -6,6 +6,11 @@ LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n    |     ^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `items`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n+   |                                                   ++++\n \n error: aborting due to previous error\n "}]}