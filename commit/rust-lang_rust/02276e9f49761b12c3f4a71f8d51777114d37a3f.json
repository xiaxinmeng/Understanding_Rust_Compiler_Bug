{"sha": "02276e9f49761b12c3f4a71f8d51777114d37a3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMjc2ZTlmNDk3NjFiMTJjM2Y0YTcxZjhkNTE3NzcxMTRkMzdhM2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-15T19:42:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: collapse Layout::{Raw,StructWrapped}NullablePointer into one variant.", "tree": {"sha": "d1a9058b90ccdb431d5954e7575a910c6b41d9eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1a9058b90ccdb431d5954e7575a910c6b41d9eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02276e9f49761b12c3f4a71f8d51777114d37a3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02276e9f49761b12c3f4a71f8d51777114d37a3f", "html_url": "https://github.com/rust-lang/rust/commit/02276e9f49761b12c3f4a71f8d51777114d37a3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02276e9f49761b12c3f4a71f8d51777114d37a3f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caef91d7c6dcfc307b9e915bd9a80a25063cce22", "url": "https://api.github.com/repos/rust-lang/rust/commits/caef91d7c6dcfc307b9e915bd9a80a25063cce22", "html_url": "https://github.com/rust-lang/rust/commit/caef91d7c6dcfc307b9e915bd9a80a25063cce22"}], "stats": {"total": 296, "additions": 91, "deletions": 205}, "files": [{"sha": "aebe0c852b3657b0225902e3a6d22cf5f255a891", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 31, "deletions": 58, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -1133,24 +1133,14 @@ pub enum Layout {\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` must have single field which is known to be nonnull due to its type.\n-    /// The other case is known to be zero sized. Hence we represent the enum\n-    /// as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n-    /// otherwise it indicates the other case.\n+    /// `nndiscr` is represented by the struct `nonnull`, where the field at the\n+    /// `discr_offset` offset is known to be nonnull due to its type; if that field is null, then\n+    /// it represents the other case, which is known to be zero sized.\n     ///\n     /// For example, `std::option::Option` instantiated at a safe pointer type\n     /// is represented such that `None` is a null pointer and `Some` is the\n     /// identity function.\n-    RawNullablePointer {\n-        nndiscr: u64,\n-        discr: Primitive\n-    },\n-\n-    /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the field at the\n-    /// `discr_offset` offset is known to be nonnull due to its type; if that field is null, then\n-    /// it represents the other case, which is known to be zero sized.\n-    StructWrappedNullablePointer {\n+    NullablePointer {\n         nndiscr: u64,\n         nonnull: Struct,\n         discr: Primitive,\n@@ -1259,18 +1249,16 @@ impl<'a, 'tcx> Layout {\n                     FieldPlacement::union(def.struct_variant().fields.len())\n                 }\n \n-                General { .. } |\n-                RawNullablePointer { .. } => FieldPlacement::union(1),\n+                General { .. } => FieldPlacement::union(1),\n \n-                StructWrappedNullablePointer { ref discr_offset, .. } => {\n+                NullablePointer { ref discr_offset, .. } => {\n                     FieldPlacement::Arbitrary {\n                         offsets: ref_slice(discr_offset)\n                     }\n                 }\n             };\n             let abi = match *layout {\n-                Scalar { value, .. } |\n-                RawNullablePointer { discr: value, .. } => Abi::Scalar(value),\n+                Scalar { value, .. } => Abi::Scalar(value),\n                 CEnum { discr, .. } => Abi::Scalar(Int(discr)),\n \n                 Vector { .. } => Abi::Vector,\n@@ -1279,8 +1267,15 @@ impl<'a, 'tcx> Layout {\n                 FatPointer { .. } |\n                 Univariant(_) |\n                 UntaggedUnion(_) |\n-                General { .. } |\n-                StructWrappedNullablePointer { .. } => Abi::Aggregate\n+                General { .. } => Abi::Aggregate,\n+\n+                NullablePointer { discr, discr_offset, .. } => {\n+                    if discr_offset.bytes() == 0 && discr.size(cx) == layout.size(cx) {\n+                        Abi::Scalar(discr)\n+                    } else {\n+                        Abi::Aggregate\n+                    }\n+                }\n             };\n             Ok(CachedLayout {\n                 layout,\n@@ -1562,15 +1557,6 @@ impl<'a, 'tcx> Layout {\n                         // out of arrays with just the indexing operator.\n                         let mut st = if discr == 0 { st0 } else { st1 };\n \n-                        // FIXME(eddyb) should take advantage of a newtype.\n-                        if offset.bytes() == 0 && primitive.size(dl) == st.stride() &&\n-                           variants[discr].len() == 1 {\n-                            return success(RawNullablePointer {\n-                                nndiscr: discr as u64,\n-                                discr: primitive,\n-                            });\n-                        }\n-\n                         let mut discr_align = primitive.align(dl);\n                         if offset.abi_align(discr_align) != offset {\n                             st.packed = true;\n@@ -1579,7 +1565,7 @@ impl<'a, 'tcx> Layout {\n                         st.align = st.align.max(discr_align);\n                         st.primitive_align = st.primitive_align.max(discr_align);\n \n-                        return success(StructWrappedNullablePointer {\n+                        return success(NullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n                             discr: primitive,\n@@ -1715,8 +1701,7 @@ impl<'a, 'tcx> Layout {\n         match *self {\n             Scalar {..} | Vector {..} | FatPointer {..} |\n             CEnum {..} | UntaggedUnion {..} | General {..} |\n-            RawNullablePointer {..} |\n-            StructWrappedNullablePointer {..} => false,\n+            NullablePointer {..} => false,\n \n             Array { sized, .. } |\n             Univariant(Struct { sized, .. }) => !sized\n@@ -1727,7 +1712,7 @@ impl<'a, 'tcx> Layout {\n         let dl = cx.data_layout();\n \n         match *self {\n-            Scalar { value, .. } | RawNullablePointer { discr: value, .. } => {\n+            Scalar { value, .. } => {\n                 value.size(dl)\n             }\n \n@@ -1760,7 +1745,7 @@ impl<'a, 'tcx> Layout {\n             UntaggedUnion(ref un) => un.stride(),\n \n             Univariant(ref variant) |\n-            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+            NullablePointer { nonnull: ref variant, .. } => {\n                 variant.stride()\n             }\n         }\n@@ -1770,7 +1755,7 @@ impl<'a, 'tcx> Layout {\n         let dl = cx.data_layout();\n \n         match *self {\n-            Scalar { value, .. } | RawNullablePointer { discr: value, .. } => {\n+            Scalar { value, .. } => {\n                 value.align(dl)\n             }\n \n@@ -1794,7 +1779,7 @@ impl<'a, 'tcx> Layout {\n             UntaggedUnion(ref un) => un.align,\n \n             Univariant(ref variant) |\n-            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+            NullablePointer { nonnull: ref variant, .. } => {\n                 variant.align\n             }\n         }\n@@ -1809,7 +1794,7 @@ impl<'a, 'tcx> Layout {\n         match *self {\n             Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n             Univariant(ref variant) |\n-            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+            NullablePointer { nonnull: ref variant, .. } => {\n                 variant.primitive_align\n             },\n \n@@ -1924,11 +1909,11 @@ impl<'a, 'tcx> Layout {\n         };\n \n         match *layout {\n-            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n-                                                   nndiscr,\n-                                                   discr: _,\n-                                                   discr_offset: _ } => {\n-                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n+            Layout::NullablePointer { nonnull: ref variant_layout,\n+                                      nndiscr,\n+                                      discr: _,\n+                                      discr_offset: _ } => {\n+                debug!(\"print-type-size t: `{:?}` adt nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n                 let variant_def = &adt_def.variants[nndiscr as usize];\n                 let fields: Vec<_> =\n@@ -1941,13 +1926,6 @@ impl<'a, 'tcx> Layout {\n                                                &fields,\n                                                variant_layout)]);\n             }\n-            Layout::RawNullablePointer { nndiscr, discr } => {\n-                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, discr);\n-                let variant_def = &adt_def.variants[nndiscr as usize];\n-                record(adt_kind.into(), None,\n-                       vec![build_primitive_info(variant_def.name, &discr)]);\n-            }\n             Layout::Univariant(ref variant_layout) => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n@@ -2314,7 +2292,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                 }\n             }\n \n-            StructWrappedNullablePointer { nndiscr, ref nonnull, .. }\n+            NullablePointer { nndiscr, ref nonnull, .. }\n                     if nndiscr as usize == variant_index => {\n                 FieldPlacement::Arbitrary {\n                     offsets: &nonnull.offsets\n@@ -2402,8 +2380,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                             General { discr, .. } => {\n                                 return [discr.to_ty(tcx, false)][i];\n                             }\n-                            RawNullablePointer { discr, .. } |\n-                            StructWrappedNullablePointer { discr, .. } => {\n+                            NullablePointer { discr, .. } => {\n                                 return [discr.to_ty(tcx)][i];\n                             }\n                             _ if def.variants.len() > 1 => return [][i],\n@@ -2483,11 +2460,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n                 align.hash_stable(hcx, hasher);\n                 primitive_align.hash_stable(hcx, hasher);\n             }\n-            RawNullablePointer { nndiscr, ref discr } => {\n-                nndiscr.hash_stable(hcx, hasher);\n-                discr.hash_stable(hcx, hasher);\n-            }\n-            StructWrappedNullablePointer {\n+            NullablePointer {\n                 nndiscr,\n                 ref nonnull,\n                 ref discr,"}, {"sha": "871d25c046849a65dd8a002858749473140f61d1", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -69,10 +69,11 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let l = cx.layout_of(t);\n     debug!(\"finish_type_of: {} with layout {:#?}\", t, l);\n     match *l {\n-        layout::CEnum { .. } | layout::General { .. }\n-        | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n-        layout::Univariant { ..}\n-        | layout::StructWrappedNullablePointer { .. } => {\n+        layout::CEnum { .. } | layout::General { .. } | layout::UntaggedUnion { .. } => { }\n+        layout::Univariant { ..} | layout::NullablePointer { .. } => {\n+            if let layout::Abi::Scalar(_) = l.abi {\n+                return;\n+            }\n             let (variant_layout, variant) = match *l {\n                 layout::Univariant(ref variant) => {\n                     let is_enum = if let ty::TyAdt(def, _) = t.sty {\n@@ -86,7 +87,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         (l, variant)\n                     }\n                 }\n-                layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n+                layout::NullablePointer { nndiscr, ref nonnull, .. } =>\n                     (l.for_variant(nndiscr as usize), nonnull),\n                 _ => unreachable!()\n             };\n@@ -103,15 +104,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnfield = l.for_variant(nndiscr as usize).field(cx, 0);\n-            if let layout::Scalar { value: layout::Pointer, .. } = *nnfield {\n-                Type::i8p(cx)\n-            } else {\n-                cx.llvm_type_of(nnfield.ty)\n+        layout::NullablePointer { nndiscr, ref nonnull, .. } => {\n+            if let layout::Abi::Scalar(_) = l.abi {\n+                return cx.llvm_type_of(l.field(cx, 0).ty);\n             }\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n             match name {\n                 None => {\n                     Type::struct_(cx, &struct_llfields(cx, l.for_variant(nndiscr as usize),"}, {"sha": "6e5bc576be5f50234850503cd03a6a6f312f53c4", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -92,7 +92,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 // by putting variants in fields, or be more clever.\n                 match *layout {\n                     Layout::General { .. } |\n-                    Layout::StructWrappedNullablePointer { .. } => return Err(Memory),\n+                    Layout::NullablePointer { .. } => return Err(Memory),\n                     _ => {}\n                 }\n                 for i in 0..layout.fields.count() {"}, {"sha": "e8af81a3d3bde6bd2782719abb74e46f6d05130c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 75, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -1142,7 +1142,6 @@ struct EnumMemberDescriptionFactory<'tcx> {\n     type_rep: FullLayout<'tcx>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n-    file_metadata: DIFile,\n     span: Span,\n }\n \n@@ -1218,76 +1217,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     ]\n                 }\n             }\n-            layout::RawNullablePointer { nndiscr, .. } => {\n-                // As far as debuginfo is concerned, the pointer this enum\n-                // represents is still wrapped in a struct. This is to make the\n-                // DWARF representation of enums uniform.\n-\n-                // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &adt.variants[nndiscr as usize];\n-                let non_null_variant_name = non_null_variant.name.as_str();\n-\n-                // The llvm type and metadata of the pointer\n-                let nnfield = self.type_rep.for_variant(nndiscr as usize).field(cx, 0);\n-                let (size, align) = nnfield.size_and_align(cx);\n-                let non_null_type_metadata = type_metadata(cx, nnfield.ty, self.span);\n-\n-                // For the metadata of the wrapper struct, we need to create a\n-                // MemberDescription of the struct's single field.\n-                let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.ctor_kind {\n-                        CtorKind::Fn => \"__0\".to_string(),\n-                        CtorKind::Fictive => {\n-                            non_null_variant.fields[0].name.to_string()\n-                        }\n-                        CtorKind::Const => bug!()\n-                    },\n-                    type_metadata: non_null_type_metadata,\n-                    offset: Size::from_bytes(0),\n-                    size,\n-                    align,\n-                    flags: DIFlags::FlagZero\n-                };\n-\n-                let unique_type_id = debug_context(cx).type_map\n-                                                      .borrow_mut()\n-                                                      .get_unique_type_id_of_enum_variant(\n-                                                          cx,\n-                                                          self.enum_type,\n-                                                          &non_null_variant_name);\n-\n-                // Now we can create the metadata of the artificial struct\n-                let artificial_struct_metadata =\n-                    composite_type_metadata(cx,\n-                                            nnfield.ty,\n-                                            &non_null_variant_name,\n-                                            unique_type_id,\n-                                            &[sole_struct_member_description],\n-                                            self.containing_scope,\n-                                            self.file_metadata,\n-                                            syntax_pos::DUMMY_SP);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_name = adt.variants[(1 - nndiscr) as usize].name;\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                0,\n-                                                null_variant_name);\n-\n-                // Finally create the (singleton) list of descriptions of union\n-                // members.\n-                vec![\n-                    MemberDescription {\n-                        name: union_member_name,\n-                        type_metadata: artificial_struct_metadata,\n-                        offset: Size::from_bytes(0),\n-                        size,\n-                        align,\n-                        flags: DIFlags::FlagZero\n-                    }\n-                ]\n-            },\n-            layout::StructWrappedNullablePointer {\n+            layout::NullablePointer {\n                 nonnull: ref struct_def,\n                 nndiscr,\n                 discr,\n@@ -1566,9 +1496,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         layout::CEnum { discr, signed, .. } => {\n             return FinalMetadata(discriminant_type_metadata(discr, signed))\n         },\n-        layout::RawNullablePointer { .. }           |\n-        layout::StructWrappedNullablePointer { .. } |\n-        layout::Univariant { .. }                      => None,\n+        layout::NullablePointer { .. } | layout::Univariant { .. } => None,\n         layout::General { discr, .. } => Some(discriminant_type_metadata(discr, false)),\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n@@ -1604,7 +1532,6 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             type_rep,\n             discriminant_type_metadata,\n             containing_scope,\n-            file_metadata,\n             span,\n         }),\n     );"}, {"sha": "befb5409e46f0ec0456789a9c59cb2ee862ab623", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -1127,15 +1127,7 @@ fn trans_const_adt<'a, 'tcx>(\n         layout::Vector { .. } => {\n             Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n         }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            if variant_index as u64 == nndiscr {\n-                assert_eq!(vals.len(), 1);\n-                Const::new(vals[0].llval, t)\n-            } else {\n-                Const::new(C_null(ccx.llvm_type_of(t)), t)\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+        layout::NullablePointer { ref nonnull, nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n                 build_const_struct(ccx, l, &nonnull, vals, None)\n             } else {"}, {"sha": "1b0486dbf96428a29231cf261c65b173432e25ee", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -18,7 +18,7 @@ use abi;\n use adt;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize, C_u8, C_u32, C_int, C_null, val_ty};\n+use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, val_ty};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -210,17 +210,33 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let alignment = self.alignment | Alignment::from(&*l);\n \n-        // Handle all the non-aggregate cases first.\n+        // Unions and newtypes only use an offset of 0.\n         match *l {\n-            layout::UntaggedUnion { .. } => {\n+            // FIXME(eddyb) The fields of a fat pointer aren't correct, especially\n+            // to unsized structs, we can't represent their pointee types in `Ty`.\n+            Layout::FatPointer { .. } => {}\n+\n+            _ if offset == 0 => {\n                 let ty = ccx.llvm_type_of(field.ty);\n-                return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty, alignment);\n+                return LvalueRef {\n+                    llval: bcx.pointercast(self.llval, ty.ptr_to()),\n+                    llextra: if field.is_unsized() {\n+                        self.llextra\n+                    } else {\n+                        ptr::null_mut()\n+                    },\n+                    ty: LvalueTy::from_ty(field.ty),\n+                    alignment,\n+                };\n             }\n-            // Discriminant field of enums.\n+\n+            _ => {}\n+        }\n+\n+        // Discriminant field of enums.\n+        match *l {\n             layout::General { .. } |\n-            layout::RawNullablePointer { .. } |\n-            layout::StructWrappedNullablePointer { .. } if l.variant_index.is_none() => {\n+            layout::NullablePointer { .. } if l.variant_index.is_none() => {\n                 let ty = ccx.llvm_type_of(field.ty);\n                 let size = field.size(ccx).bytes();\n \n@@ -239,22 +255,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                     bcx.inbounds_gep(discr_ptr, &[C_usize(ccx, offset / size)]),\n                     field.ty, alignment);\n             }\n-            layout::RawNullablePointer { nndiscr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr,  .. }\n-                if l.variant_index.unwrap() as u64 != nndiscr => {\n-                // The unit-like case might have a nonzero number of unit-like fields.\n-                // (e.d., Result of Either with (), as one side.)\n-                let ty = ccx.llvm_type_of(field.ty);\n-                assert_eq!(field.size(ccx).bytes(), 0);\n-                return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty,\n-                    Alignment::Packed(Align::from_bytes(1, 1).unwrap()));\n-            }\n-            layout::RawNullablePointer { .. } => {\n-                let ty = ccx.llvm_type_of(field.ty);\n-                return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty, alignment);\n-            }\n             _ => {}\n         }\n \n@@ -274,7 +274,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         // Check whether the variant being used is packed, if applicable.\n         let is_packed = match (&*l, l.variant_index) {\n             (&layout::Univariant(ref variant), _) => variant.packed,\n-            (&layout::StructWrappedNullablePointer { ref nonnull, .. }, _) => nonnull.packed,\n+            (&layout::NullablePointer { ref nonnull, .. }, _) => nonnull.packed,\n             (&layout::General { ref variants, .. }, Some(v)) => variants[v].packed,\n             _ => return simple()\n         };\n@@ -351,10 +351,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     /// Helper for cases where the discriminant is simply loaded.\n-    fn load_discr(self, bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n-                  min: u64, max: u64) -> ValueRef {\n-        let llty = Type::from_integer(bcx.ccx, ity);\n-        assert_eq!(val_ty(ptr), llty.ptr_to());\n+    fn load_discr(self, bcx: &Builder, ity: layout::Integer, min: u64, max: u64) -> ValueRef {\n         let bits = ity.size().bits();\n         assert!(bits <= 64);\n         let bits = bits as usize;\n@@ -366,11 +363,11 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             // rejected by the LLVM verifier (it would mean either an\n             // empty set, which is impossible, or the entire range of the\n             // type, which is pointless).\n-            bcx.load(ptr, self.alignment.non_abi())\n+            bcx.load(self.llval, self.alignment.non_abi())\n         } else {\n             // llvm::ConstantRange can deal with ranges that wrap around,\n             // so an overflow on (max + 1) is fine.\n-            bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ llvm::True,\n+            bcx.load_range_assert(self.llval, min, max.wrapping_add(1), /* signed: */ llvm::True,\n                                   self.alignment.non_abi())\n         }\n     }\n@@ -379,25 +376,25 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n \n+        let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n         let val = match *l {\n+            layout::Univariant { .. } |\n+            layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n             layout::CEnum { discr, min, max, .. } => {\n-                self.load_discr(bcx, discr, self.llval, min, max)\n+                self.load_discr(bcx, discr, min, max)\n             }\n             layout::General { discr, ref variants, .. } => {\n                 let ptr = self.project_field(bcx, 0);\n-                self.load_discr(bcx, discr, ptr.llval, 0, variants.len() as u64 - 1)\n+                ptr.load_discr(bcx, discr, 0, variants.len() as u64 - 1)\n             }\n-            layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n-            layout::RawNullablePointer { nndiscr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr, .. } => {\n+            layout::NullablePointer { nndiscr, .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 let lldiscr = bcx.load(ptr.llval, ptr.alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n                 bcx.icmp(cmp, lldiscr, C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx()))))\n             },\n             _ => bug!(\"{} is not an enum\", l.ty)\n         };\n-        let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n         bcx.intcast(val, cast_to, adt::is_discr_signed(&l))\n     }\n \n@@ -424,14 +421,11 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             | layout::Vector { .. } => {\n                 assert_eq!(to, 0);\n             }\n-            layout::RawNullablePointer { nndiscr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr, .. } => {\n+            layout::NullablePointer { nndiscr, .. } => {\n                 if to != nndiscr {\n-                    let use_memset = match *l {\n-                        layout::StructWrappedNullablePointer { .. } => {\n-                            target_sets_discr_via_memset(bcx)\n-                        }\n-                        _ => false,\n+                    let use_memset = match l.abi {\n+                        layout::Abi::Scalar(_) => false,\n+                        _ => target_sets_discr_via_memset(bcx)\n                     };\n                     if use_memset {\n                         // Issue #34427: As workaround for LLVM bug on"}, {"sha": "11c09960a3e098a6c3eeb52478e50b61a6c83d03", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -115,8 +115,9 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     /// Immediate aggregate with the two values.\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n-            // Reconstruct the immediate aggregate.\n             let llty = bcx.ccx.llvm_type_of(self.ty);\n+            debug!(\"Operand::pack_if_pair: packing {:?} into {:?}\", self, llty);\n+            // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n             let elems = [a, b];\n             let layout = bcx.ccx.layout_of(self.ty);"}, {"sha": "264f711de8f9303e8ff83a661c21a2e85b6dd5eb", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -12,7 +12,7 @@ use abi::FnType;\n use adt;\n use common::*;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{Align, Layout, LayoutOf, Size, FullLayout};\n+use rustc::ty::layout::{self, Align, Layout, LayoutOf, Size, FullLayout};\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -237,11 +237,13 @@ pub trait LayoutLlvmExt {\n \n impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n     fn llvm_field_index(&self, index: usize) -> u64 {\n+        if let layout::Abi::Scalar(_) = self.abi {\n+            bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);\n+        }\n         match **self {\n             Layout::Scalar { .. } |\n             Layout::CEnum { .. } |\n-            Layout::UntaggedUnion { .. } |\n-            Layout::RawNullablePointer { .. } => {\n+            Layout::UntaggedUnion { .. } => {\n                 bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n@@ -266,7 +268,7 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n                 }\n             }\n \n-            Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+            Layout::NullablePointer { nndiscr, ref nonnull, .. } => {\n                 if self.variant_index == Some(nndiscr as usize) {\n                     adt::memory_index_to_gep(nonnull.memory_index[index] as u64)\n                 } else {"}, {"sha": "830678f174f88cf38e0d76836bac2cc7c9a9ee96", "filename": "src/test/ui/print_type_sizes/nullable.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/02276e9f49761b12c3f4a71f8d51777114d37a3f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout?ref=02276e9f49761b12c3f4a71f8d51777114d37a3f", "patch": "@@ -19,5 +19,6 @@ print-type-size     field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes"}]}