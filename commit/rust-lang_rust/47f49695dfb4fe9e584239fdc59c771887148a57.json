{"sha": "47f49695dfb4fe9e584239fdc59c771887148a57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZjQ5Njk1ZGZiNGZlOWU1ODQyMzlmZGM1OWM3NzE4ODcxNDhhNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-13T23:54:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-13T23:54:52Z"}, "message": "Auto merge of #71111 - Dylan-DPC:rollup-esp17qn, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #70654 (Explain how to work with subtree)\n - #71092 (Remove some usage of `DUMMY_HIR_ID`)\n - #71103 (Add test case for type aliasing `impl Sized`)\n - #71109 (allow const generics in const fn)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e271d2067fdf1ba88460820d94592c2cce07cbb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e271d2067fdf1ba88460820d94592c2cce07cbb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f49695dfb4fe9e584239fdc59c771887148a57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f49695dfb4fe9e584239fdc59c771887148a57", "html_url": "https://github.com/rust-lang/rust/commit/47f49695dfb4fe9e584239fdc59c771887148a57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f49695dfb4fe9e584239fdc59c771887148a57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e18e26f12b1e8b3e913b15278bf6185f0f61add", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e18e26f12b1e8b3e913b15278bf6185f0f61add", "html_url": "https://github.com/rust-lang/rust/commit/8e18e26f12b1e8b3e913b15278bf6185f0f61add"}, {"sha": "dd27462ea9c7c12e107272f699e940c76c4adb95", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd27462ea9c7c12e107272f699e940c76c4adb95", "html_url": "https://github.com/rust-lang/rust/commit/dd27462ea9c7c12e107272f699e940c76c4adb95"}], "stats": {"total": 181, "additions": 108, "deletions": 73}, "files": [{"sha": "051f5af7bc105cd53d393093ef45a15de27c248c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -188,7 +188,70 @@ with one another are rolled up.\n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found [here][rctd].\n \n-### External Dependencies\n+### External Dependencies (subtree)\n+\n+As a developer to this repository, you don't have to treat the following external projects\n+differently from other crates that are directly in this repo:\n+\n+* none so far, see https://github.com/rust-lang/rust/issues/70651 for more info\n+\n+They are just regular files and directories. This is in contrast to `submodule` dependencies\n+(see below for those). Only tool authors will actually use any operations here.\n+\n+#### Synchronizing a subtree\n+\n+There are two synchronization directions: `subtree push` and `subtree pull`.\n+\n+```\n+git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n+```\n+\n+takes all the changes that\n+happened to the copy in this repo and creates commits on the remote repo that match the local\n+changes. Every local commit that touched the subtree causes a commit on the remote repo, but is\n+modified to move the files from the specified directory to the tool repo root.\n+\n+Make sure to not pick the `master` branch on the tool repo, so you can open a normal PR to the tool\n+to merge that subrepo push.\n+\n+```\n+git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n+```\n+\n+takes all changes since the last `subtree pull` from the tool repo\n+repo and adds these commits to the rustc repo + a merge commit that moves the tool changes into\n+the specified directory in the rust repository.\n+\n+It is recommended that you always do a push first and get that merged to the tool master branch.\n+Then, when you do a pull, the merge works without conflicts.\n+While it's definitely possible to resolve conflicts during a pull, you may have to redo the conflict\n+resolution if your PR doesn't get merged fast enough and there are new conflicts. Do not try to\n+rebase the result of a `git subtree pull`, rebasing merge commits is a bad idea in general.\n+\n+You always need to specify the `-P` prefix to the subtree directory and the corresponding remote\n+repository. If you specify the wrong directory or repository\n+you'll get very fun merges that try to push the wrong directory to the wrong remote repository.\n+Luckily you can just abort this without any consequences by throwing away either the pulled commits\n+in rustc or the pushed branch on the remote and try again. It is usually fairly obvious\n+that this is happening because you suddenly get thousands of commits that want to be synchronized.\n+\n+#### Creating a new subtree dependency\n+\n+If you want to create a new subtree dependency from an existing repository, call (from this\n+repository's root directory!)\n+\n+```\n+git subtree add -P src/tools/clippy https://github.com/rust-lang/rust-clippy.git master\n+```\n+\n+This will create a new commit, which you may not rebase under any circumstances! Delete the commit\n+and redo the operation if you need to rebase.\n+\n+Now you're done, the `src/tools/clippy` directory behaves as if clippy were part of the rustc\n+monorepo, so no one but you (or others that synchronize subtrees) actually needs to use `git subtree`.\n+\n+\n+### External Dependencies (submodules)\n \n Currently building Rust will also build the following external projects:\n \n@@ -221,7 +284,6 @@ before the PR is merged.\n \n Rust's build system builds a number of tools that make use of the\n internals of the compiler. This includes\n-[Clippy](https://github.com/rust-lang/rust-clippy),\n [RLS](https://github.com/rust-lang/rls) and\n [rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n break because of your changes, you may run into a sort of \"chicken and egg\""}, {"sha": "395fd7460850f1de623bfbe733735eaa5d31501d", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -561,28 +561,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// We currently do not permit const generics in `const fn`,\n-    /// as this is tantamount to allowing compile-time dependent typing.\n-    ///\n-    /// FIXME(const_generics): Is this really true / necessary? Discuss with @varkor.\n-    /// At any rate, the restriction feels too syntactic. Consider moving it to e.g. typeck.\n-    fn check_const_fn_const_generic(&self, span: Span, sig: &FnSig, generics: &Generics) {\n-        if let Const::Yes(const_span) = sig.header.constness {\n-            // Look for const generics and error if we find any.\n-            for param in &generics.params {\n-                if let GenericParamKind::Const { .. } = param.kind {\n-                    self.err_handler()\n-                        .struct_span_err(\n-                            span,\n-                            \"const parameters are not permitted in const functions\",\n-                        )\n-                        .span_label(const_span, \"`const` because of this\")\n-                        .emit();\n-                }\n-            }\n-        }\n-    }\n-\n     fn check_item_named(&self, ident: Ident, kind: &str) {\n         if ident.name != kw::Underscore {\n             return;\n@@ -966,9 +944,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         .emit();\n                 }\n             }\n-            ItemKind::Fn(def, ref sig, ref generics, ref body) => {\n+            ItemKind::Fn(def, _, _, ref body) => {\n                 self.check_defaultness(item.span, def);\n-                self.check_const_fn_const_generic(item.span, sig, generics);\n \n                 if body.is_none() {\n                     let msg = \"free function without a body\";"}, {"sha": "4189570a0da58d5f163705b50050da72b279440a", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -191,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+    let node = tcx.hir().as_local_hir_id(scope).unwrap();\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),"}, {"sha": "627a438c2c3b19e9a108c2f216081275477c9209", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -1354,15 +1354,15 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: hir::HirId, // HirId of the item under which things are not nameable\n+    boundary: Option<hir::HirId>, // HirId of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n impl_lint_pass!(UnnameableTestItems => [UNNAMEABLE_TEST_ITEMS]);\n \n impl UnnameableTestItems {\n     pub fn new() -> Self {\n-        Self { boundary: hir::DUMMY_HIR_ID, items_nameable: true }\n+        Self { boundary: None, items_nameable: true }\n     }\n }\n \n@@ -1372,7 +1372,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = it.hir_id;\n+                self.boundary = Some(it.hir_id);\n             }\n             return;\n         }\n@@ -1385,7 +1385,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == it.hir_id {\n+        if !self.items_nameable && self.boundary == Some(it.hir_id) {\n             self.items_nameable = true;\n         }\n     }"}, {"sha": "ee2ed8826ba125427e2701f7ae75ef6da7e6d5b1", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -43,14 +43,14 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n-    negated_expr_id: hir::HirId,\n+    negated_expr_id: Option<hir::HirId>,\n }\n \n impl_lint_pass!(TypeLimits => [UNUSED_COMPARISONS, OVERFLOWING_LITERALS]);\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits { negated_expr_id: hir::DUMMY_HIR_ID }\n+        TypeLimits { negated_expr_id: None }\n     }\n }\n \n@@ -244,7 +244,7 @@ fn lint_int_literal<'a, 'tcx>(\n     let int_type = t.normalize(cx.sess().target.ptr_width);\n     let (min, max) = int_ty_range(int_type);\n     let max = max as u128;\n-    let negative = type_limits.negated_expr_id == e.hir_id;\n+    let negative = type_limits.negated_expr_id == Some(e.hir_id);\n \n     // Detect literal value out of range [min, max] inclusive\n     // avoiding use of -min to prevent overflow/panic\n@@ -397,8 +397,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.hir_id {\n-                    self.negated_expr_id = expr.hir_id;\n+                if self.negated_expr_id != Some(e.hir_id) {\n+                    self.negated_expr_id = Some(expr.hir_id);\n                 }\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {"}, {"sha": "e02e97be19db584928c2fbdaf6677675f909cc85", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -1012,7 +1012,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n struct NamePrivacyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: hir::HirId,\n+    current_item: Option<hir::HirId>,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     ) {\n         // definition of the field\n         let ident = Ident::new(kw::Invalid, use_ctxt);\n-        let current_hir = self.current_item;\n+        let current_hir = self.current_item.unwrap();\n         let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             let label = if in_update_syntax {\n@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.hir_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, Some(item.hir_id));\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n@@ -2059,7 +2059,7 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     let mut visitor = NamePrivacyVisitor {\n         tcx,\n         tables: &empty_tables,\n-        current_item: hir::DUMMY_HIR_ID,\n+        current_item: None,\n         empty_tables: &empty_tables,\n     };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);"}, {"sha": "6db2e557fea694a05f29cb2897c06e710f56a993", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -62,7 +62,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, hir::DUMMY_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "4cb7b7d8fda247f0a8ae11585e448b383e127d3e", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -265,7 +265,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let unnormalized_env =\n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n \n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::CRATE_HIR_ID, |id| {\n         tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);"}, {"sha": "0a7d87adac7e1fd6c765007e3aa75031f5e1695c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -217,14 +217,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         expected: Ty<'tcx>,\n         checked_ty: Ty<'tcx>,\n+        hir_id: hir::HirId,\n     ) -> Vec<AssocItem> {\n-        let mut methods = self.probe_for_return_type(\n-            span,\n-            probe::Mode::MethodCall,\n-            expected,\n-            checked_ty,\n-            hir::DUMMY_HIR_ID,\n-        );\n+        let mut methods =\n+            self.probe_for_return_type(span, probe::Mode::MethodCall, expected, checked_ty, hir_id);\n         methods.retain(|m| {\n             self.has_no_input_arg(m)\n                 && self"}, {"sha": "66a6790d45ef63f804b48439808f1e9466d25a58", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -452,7 +452,7 @@ fn method_autoderef_steps<'tcx>(\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, hir::DUMMY_HIR_ID, DUMMY_SP, self_ty)\n+        let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n             .include_raw_pointers()\n             .silence_errors();\n         let mut reached_raw_pointer = false;\n@@ -1512,7 +1512,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             );\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n-            pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)?;\n \n             let method_names = pcx.candidate_method_names();\n             pcx.allow_similar_names = false;\n@@ -1522,10 +1521,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pcx.reset();\n                     pcx.method_name = Some(method_name);\n                     pcx.assemble_inherent_candidates();\n-                    pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)\n-                        .map_or(None, |_| {\n-                            pcx.pick_core().and_then(|pick| pick.ok()).map(|pick| pick.item)\n-                        })\n+                    pcx.pick_core().and_then(|pick| pick.ok()).map(|pick| pick.item)\n                 })\n                 .collect();\n "}, {"sha": "514186ba9a15c6e3e3c1cbe9bc782b6f09d54f58", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -4981,7 +4981,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if !self.check_for_cast(err, expr, found, expected) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n-            let methods = self.get_conversion_methods(expr.span, expected, found);\n+            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let mut suggestions = iter::repeat(&expr_text)\n                     .zip(methods.iter())"}, {"sha": "3d8b77bcf7b47d4444e0d1c5069c451cbd4c9a69", "filename": "src/test/ui/const-generics/const-fn-with-const-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -1,11 +1,11 @@\n+// run-pass\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n const fn const_u32_identity<const X: u32>() -> u32 {\n-    //~^ ERROR const parameters are not permitted in const functions\n     X\n }\n \n fn main() {\n-    println!(\"{:?}\", const_u32_identity::<18>());\n+    assert_eq!(const_u32_identity::<18>(), 18);\n }"}, {"sha": "64b9c18a8f5255f2c4a6a1c298e3be8e792e64d0", "filename": "src/test/ui/const-generics/const-fn-with-const-param.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -1,23 +1,10 @@\n-error: const parameters are not permitted in const functions\n-  --> $DIR/const-fn-with-const-param.rs:4:1\n-   |\n-LL |   const fn const_u32_identity<const X: u32>() -> u32 {\n-   |   ^----\n-   |   |\n-   |  _`const` because of this\n-   | |\n-LL | |\n-LL | |     X\n-LL | | }\n-   | |_^\n-\n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n-  --> $DIR/const-fn-with-const-param.rs:1:12\n+  --> $DIR/const-fn-with-const-param.rs:2:12\n    |\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: aborting due to previous error; 1 warning emitted\n+warning: 1 warning emitted\n "}, {"sha": "c54df664243e78dcc29e53abdf5cffc7a8d3df00", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-sized.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f49695dfb4fe9e584239fdc59c771887148a57/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-sized.rs?ref=47f49695dfb4fe9e584239fdc59c771887148a57", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Sized;\n+fn f1() -> A { 0 }\n+\n+type B = impl ?Sized;\n+fn f2() -> &'static B { &[0] }\n+\n+type C = impl ?Sized + 'static;\n+fn f3() -> &'static C { &[0] }\n+\n+type D = impl ?Sized;\n+fn f4() -> &'static D { &1 }\n+\n+fn main() {}"}]}