{"sha": "465a2bd75ffa2271020cd3ccd08b2d3e35aab60e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NWEyYmQ3NWZmYTIyNzEwMjBjZDNjY2QwOGIyZDNlMzVhYWI2MGU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-21T05:23:40Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T19:01:55Z"}, "message": "Items", "tree": {"sha": "13fce3b5134e776a988bbe3d19764700662e37be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13fce3b5134e776a988bbe3d19764700662e37be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e", "html_url": "https://github.com/rust-lang/rust/commit/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b40e1b5c20b99f3461b78f2ede2165f183d5b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b40e1b5c20b99f3461b78f2ede2165f183d5b9", "html_url": "https://github.com/rust-lang/rust/commit/c0b40e1b5c20b99f3461b78f2ede2165f183d5b9"}], "stats": {"total": 182, "additions": 113, "deletions": 69}, "files": [{"sha": "ccace77795c96271b0ec43603f37c4bccb0fd4f6", "filename": "src/doc/reference/src/items.md", "status": "modified", "additions": 113, "deletions": 69, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/465a2bd75ffa2271020cd3ccd08b2d3e35aab60e/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems.md?ref=465a2bd75ffa2271020cd3ccd08b2d3e35aab60e", "patch": "@@ -1,10 +1,13 @@\n # Items\n \n An _item_ is a component of a crate. Items are organized within a crate by a\n-nested set of [modules](#modules). Every crate has a single \"outermost\"\n-anonymous module; all further items within the crate have [paths](#paths)\n+nested set of [modules]. Every crate has a single \"outermost\"\n+anonymous module; all further items within the crate have [paths]\n within the module tree of the crate.\n \n+[modules]: modules.html\n+[paths]: paths.html\n+\n Items are entirely determined at compile-time, generally remain fixed during\n execution, and may reside in read-only memory.\n \n@@ -15,7 +18,7 @@ There are several kinds of item:\n * [modules](#modules)\n * [function definitions](#functions)\n * [`extern` blocks](#external-blocks)\n-* [type definitions](grammar.html#type-definitions)\n+* [type definitions](../grammar.html#type-definitions)\n * [struct definitions](#structs)\n * [enumeration definitions](#enumerations)\n * [constant items](#constant-items)\n@@ -39,25 +42,29 @@ All items except modules, constants and statics may be *parameterized* by type.\n Type parameters are given as a comma-separated list of identifiers enclosed in\n angle brackets (`<...>`), after the name of the item and before its definition.\n The type parameters of an item are considered \"part of the name\", not part of\n-the type of the item. A referencing [path](#paths) must (in principle) provide\n+the type of the item. A referencing [path] must (in principle) provide\n type arguments as a list of comma-separated types enclosed within angle\n brackets, in order to refer to the type-parameterized item. In practice, the\n type-inference system can usually infer such argument types from context. There\n are no general type-parametric types, only type-parametric items. That is, Rust\n has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n abstracted over other types, though higher-ranked types do exist for lifetimes.\n \n+[path]: paths.html\n+\n ## Modules\n \n-A module is a container for zero or more [items](#items).\n+A module is a container for zero or more [items].\n+\n+[items]: items.html\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n keyword `mod`. A module item introduces a new, named module into the tree of\n modules making up a crate. Modules can nest arbitrarily.\n \n An example of a module:\n \n-```\n+```rust\n mod math {\n     type Complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n@@ -85,7 +92,7 @@ same name as the module, plus the `.rs` extension. When a nested submodule is\n loaded from an external file, it is loaded from a subdirectory path that\n mirrors the module hierarchy.\n \n-```{.ignore}\n+```rust,ignore\n // Load the `vec` module from `vec.rs`\n mod vec;\n \n@@ -99,7 +106,7 @@ mod thread {\n The directories and files used for loading external file modules can be\n influenced with the `path` attribute.\n \n-```{.ignore}\n+```rust,ignore\n #[path = \"thread_files\"]\n mod thread {\n     // Load the `local_data` module from `thread_files/tls.rs`\n@@ -124,7 +131,7 @@ equal to the `ident` given in the `extern_crate_decl`.\n \n Three examples of `extern crate` declarations:\n \n-```{.ignore}\n+```rust,ignore\n extern crate pcre;\n \n extern crate std; // equivalent to: extern crate std as std;\n@@ -139,7 +146,7 @@ details).\n \n Here is an example:\n \n-```{.ignore}\n+```rust,ignore\n // Importing the Cargo package hello-world\n extern crate hello_world; // hyphen replaced with an underscore\n ```\n@@ -149,9 +156,13 @@ extern crate hello_world; // hyphen replaced with an underscore\n ### Use declarations\n \n A _use declaration_ creates one or more local name bindings synonymous with\n-some other [path](#paths). Usually a `use` declaration is used to shorten the\n+some other [path]. Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear in\n-[modules](#modules) and [blocks](grammar.html#block-expressions), usually at the top.\n+[modules] and [blocks], usually at the top.\n+\n+[path]: paths.html\n+[modules]: #modules\n+[blocks]: ../grammar.html#block-expressions\n \n > **Note**: Unlike in many languages,\n > `use` declarations in Rust do *not* declare linkage dependency with external crates.\n@@ -199,7 +210,7 @@ cannot be resolved unambiguously, they represent a compile-time error.\n \n An example of re-exporting:\n \n-```\n+```rust\n # fn main() { }\n mod quux {\n     pub use quux::foo::{bar, baz};\n@@ -226,7 +237,7 @@ declarations.\n \n An example of what will and will not work for `use` items:\n \n-```\n+```rust\n # #![allow(unused_imports)]\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n \n@@ -256,27 +267,34 @@ fn main() {}\n \n ## Functions\n \n-A _function item_ defines a sequence of [statements](#statements) and a\n-final [expression](#expressions), along with a name and a set of\n+A _function item_ defines a sequence of [statements] and a\n+final [expression], along with a name and a set of\n parameters. Other than a name, all these are optional.\n Functions are declared with the keyword `fn`. Functions may declare a\n-set of *input* [*variables*](#variables) as parameters, through which the caller\n-passes arguments into the function, and the *output* [*type*](#types)\n+set of *input* [*variables*][variables] as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*][type]\n of the value the function will return to its caller on completion.\n \n+[statements]: statements.html\n+[expression]: expressions.html\n+[variables]: variables.html\n+[type]: types.html\n+\n A function may also be copied into a first-class *value*, in which case the\n-value has the corresponding [*function type*](#function-types), and can be used\n+value has the corresponding [*function type*][function type], and can be used\n otherwise exactly as a function item (with a minor additional cost of calling\n the function indirectly).\n \n+[function type]: types.html#function-types\n+\n Every control path in a function logically ends with a `return` expression or a\n diverging expression. If the outermost block of a function has a\n value-producing expression in its final-expression position, that expression is\n interpreted as an implicit `return` expression applied to the final-expression.\n \n An example of a function:\n \n-```\n+```rust\n fn add(x: i32, y: i32) -> i32 {\n     x + y\n }\n@@ -285,7 +303,7 @@ fn add(x: i32, y: i32) -> i32 {\n As with `let` bindings, function arguments are irrefutable patterns, so any\n pattern that is valid in a let binding is also valid as an argument.\n \n-```\n+```rust\n fn first((value, _): (i32, i32)) -> i32 { value }\n ```\n \n@@ -314,7 +332,7 @@ fn foo<T>(x: T) where T: Debug {\n When a generic function is referenced, its type is instantiated based on the\n context of the reference. For example, calling the `foo` function here:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn foo<T>(x: &[T]) where T: Debug {\n@@ -328,16 +346,18 @@ foo(&[1, 2]);\n will instantiate type parameter `T` with `i32`.\n \n The type parameters can also be explicitly supplied in a trailing\n-[path](#paths) component after the function name. This might be necessary if\n+[path] component after the function name. This might be necessary if\n there is not sufficient context to determine the type parameters. For example,\n `mem::size_of::<u32>() == 4`.\n \n+[path]: paths.html\n+\n ### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n output type would normally be. For example:\n \n-```\n+```rust\n fn my_err(s: &str) -> ! {\n     println!(\"{}\", s);\n     panic!();\n@@ -351,11 +371,13 @@ does *not* denote a type.\n \n It might be necessary to declare a diverging function because as mentioned\n previously, the typechecker checks that every control path in a function ends\n-with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n+with a [`return`] or diverging expression. So, if `my_err`\n were declared without the `!` annotation, the following code would not\n typecheck:\n \n-```\n+[`return`]: expressions.html#return-expressions\n+\n+```rust\n # fn my_err(s: &str) -> ! { panic!() }\n \n fn f(i: i32) -> i32 {\n@@ -385,7 +407,7 @@ bodies defined in Rust code _can be called by foreign code_. They are defined\n in the same way as any other Rust function, except that they have the `extern`\n modifier.\n \n-```\n+```rust\n // Declares an extern fn, the ABI defaults to \"C\"\n extern fn new_i32() -> i32 { 0 }\n \n@@ -396,7 +418,7 @@ extern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }\n Unlike normal functions, extern fns have type `extern \"ABI\" fn()`. This is the\n same type as the functions declared in an extern block.\n \n-```\n+```rust\n # extern fn new_i32() -> i32 { 0 }\n let fptr: extern \"C\" fn() -> i32 = new_i32;\n ```\n@@ -406,23 +428,25 @@ contiguous stack segments like C.\n \n ## Type aliases\n \n-A _type alias_ defines a new name for an existing [type](#types). Type\n+A _type alias_ defines a new name for an existing [type]. Type\n aliases are declared with the keyword `type`. Every value has a single,\n specific type, but may implement several different traits, or be compatible with\n several different type constraints.\n \n+[type]: types.html\n+\n For example, the following defines the type `Point` as a synonym for the type\n `(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n \n-```\n+```rust\n type Point = (u8, u8);\n let p: Point = (41, 68);\n ```\n \n Currently a type alias to an enum type cannot be used to qualify the\n constructors:\n \n-```\n+```rust\n enum E { A }\n type F = E;\n let _: F = E::A;  // OK\n@@ -431,21 +455,24 @@ let _: F = E::A;  // OK\n \n ## Structs\n \n-A _struct_ is a nominal [struct type](#struct-types) defined with the\n+A _struct_ is a nominal [struct type] defined with the\n keyword `struct`.\n \n An example of a `struct` item and its use:\n \n-```\n+```rust\n struct Point {x: i32, y: i32}\n let p = Point {x: 10, y: 11};\n let px: i32 = p.x;\n ```\n \n-A _tuple struct_ is a nominal [tuple type](#tuple-types), also defined with\n+A _tuple struct_ is a nominal [tuple type], also defined with\n the keyword `struct`. For example:\n \n-```\n+[struct type]: types.html#struct-types\n+[tuple type]: types.html#tuple-types\n+\n+```rust\n struct Point(i32, i32);\n let p = Point(10, 11);\n let px: i32 = match p { Point(x, _) => x };\n@@ -455,33 +482,37 @@ A _unit-like struct_ is a struct without any fields, defined by leaving off\n the list of fields entirely. Such a struct implicitly defines a constant of\n its type with the same name. For example:\n \n-```\n+```rust\n struct Cookie;\n let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n ```\n \n is equivalent to\n \n-```\n+```rust\n struct Cookie {}\n const Cookie: Cookie = Cookie {};\n let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n ```\n \n The precise memory layout of a struct is not specified. One can specify a\n-particular layout using the [`repr` attribute](#ffi-attributes).\n+particular layout using the [`repr` attribute].\n+\n+[`repr` attribute]: attributes.html#ffi-attributes\n \n ## Enumerations\n \n An _enumeration_ is a simultaneous definition of a nominal [enumerated\n-type](#enumerated-types) as well as a set of *constructors*, that can be used\n+type] as well as a set of *constructors*, that can be used\n to create or pattern-match values of the corresponding enumerated type.\n \n+[enumerated type]: types.html#enumerated-types\n+\n Enumerations are declared with the keyword `enum`.\n \n An example of an `enum` item and its use:\n \n-```\n+```rust\n enum Animal {\n     Dog,\n     Cat,\n@@ -509,23 +540,25 @@ whereas `Dog` is simply called an enum variant.\n Each enum value has a _discriminant_ which is an integer associated to it. You\n can specify it explicitly:\n \n-```\n+```rust\n enum Foo {\n     Bar = 123,\n }\n ```\n \n The right hand side of the specification is interpreted as an `isize` value,\n but the compiler is allowed to use a smaller type in the actual memory layout.\n-The [`repr` attribute](#ffi-attributes) can be added in order to change\n+The [`repr` attribute] can be added in order to change\n the type of the right hand side and specify the memory layout.\n \n+[`repr` attribute]: attributes.html#ffi-attributes\n+\n If a discriminant isn't specified, they start at zero, and add one for each\n variant, in order.\n \n You can cast an enum to get its discriminant:\n \n-```\n+```rust\n # enum Foo { Bar = 123 }\n let x = Foo::Bar as u32; // x is now 123u32\n ```\n@@ -662,7 +695,7 @@ standard elision rules ([see discussion in the nomicon][elision-nomicon]). If it\n is unable to resolve the lifetimes by its usual rules, it will default to using\n the `'static` lifetime. By way of example:\n \n-[elision-nomicon]: https://doc.rust-lang.org/nomicon/lifetime-elision.html\n+[elision-nomicon]: ../nomicon/lifetime-elision.html\n \n ```rust,ignore\n // Resolved as `fn<'a>(&'a str) -> &'a str`.\n@@ -698,14 +731,14 @@ contain additional type parameters. These type parameters (including\n Trait bounds on `Self` are considered \"supertraits\". These are\n required to be acyclic.  Supertraits are somewhat different from other\n constraints in that they affect what methods are available in the\n-vtable when the trait is used as a [trait object](#trait-objects).\n+vtable when the trait is used as a [trait object].\n \n Traits are implemented for specific types through separate\n-[implementations](#implementations).\n+[implementations].\n \n Consider the following trait:\n \n-```\n+```rust\n # type Surface = i32;\n # type BoundingBox = i32;\n trait Shape {\n@@ -715,13 +748,17 @@ trait Shape {\n ```\n \n This defines a trait with two methods. All values that have\n-[implementations](#implementations) of this trait in scope can have their\n+[implementations] of this trait in scope can have their\n `draw` and `bounding_box` methods called, using `value.bounding_box()`\n-[syntax](#method-call-expressions).\n+[syntax].\n+\n+[trait object]: types.html#trait-objects\n+[implementations]: #implementations\n+[syntax]: expressions.html#method-call-expressions\n \n Traits can include default implementations of methods, as in:\n \n-```\n+```rust\n trait Foo {\n     fn bar(&self);\n     fn baz(&self) { println!(\"We called baz.\"); }\n@@ -736,7 +773,7 @@ Type parameters can be specified for a trait to make it generic. These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n \n-```\n+```rust\n trait Seq<T> {\n     fn len(&self) -> u32;\n     fn elt_at(&self, n: u32) -> T;\n@@ -748,7 +785,7 @@ It is also possible to define associated types for a trait. Consider the\n following example of a `Container` trait. Notice how the type is available\n for use in the method signatures:\n \n-```\n+```rust\n trait Container {\n     type E;\n     fn empty() -> Self;\n@@ -760,7 +797,7 @@ In order for a type to implement this trait, it must not only provide\n implementations for every method, but it must specify the type `E`. Here's\n an implementation of `Container` for the standard library type `Vec`:\n \n-```\n+```rust\n # trait Container {\n #     type E;\n #     fn empty() -> Self;\n@@ -782,7 +819,7 @@ will have two effects:\n \n For example:\n \n-```\n+```rust\n # type Surface = i32;\n # trait Shape { fn draw(&self, Surface); }\n fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n@@ -791,15 +828,18 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n }\n ```\n \n-Traits also define a [trait object](#trait-objects) with the same\n+Traits also define a [trait object] with the same\n name as the trait. Values of this type are created by coercing from a\n pointer of some specific type to a pointer of trait type. For example,\n `&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n for `Box<T>`). This coercion can either be implicit or\n-[explicit](#type-cast-expressions). Here is an example of an explicit\n+[explicit]. Here is an example of an explicit\n coercion:\n \n-```\n+[trait object]: types.html#trait-objects\n+[explicit]: expressions.html#type-cast-expressions\n+\n+```rust\n trait Shape { }\n impl Shape for i32 { }\n let mycircle = 0i32;\n@@ -808,17 +848,19 @@ let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n \n The resulting value is a box containing the value that was cast, along with\n information that identifies the methods of the implementation that was used.\n-Values with a trait type can have [methods called](#method-call-expressions) on\n+Values with a trait type can have [methods called] on\n them, for any method in the trait, and can be used to instantiate type\n parameters that are bounded by the trait.\n \n+[methods called]: expressions.html#method-call-expressions\n+\n Trait methods may be static, which means that they lack a `self` argument.\n This means that they can only be called with function call syntax (`f(x)`) and\n not method call syntax (`obj.f()`). The way to refer to the name of a static\n method is to qualify it with the trait name, treating the trait name like a\n module. For example:\n \n-```\n+```rust\n trait Num {\n     fn from_i32(n: i32) -> Self;\n }\n@@ -830,7 +872,7 @@ let x: f64 = Num::from_i32(42);\n \n Traits may inherit from other traits. Consider the following example:\n \n-```\n+```rust\n trait Shape { fn area(&self) -> f64; }\n trait Circle : Shape { fn radius(&self) -> f64; }\n ```\n@@ -868,7 +910,7 @@ In type-parameterized functions, methods of the supertrait may be called on\n values of subtrait-bound type parameters. Referring to the previous example of\n `trait Circle : Shape`:\n \n-```\n+```rust\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n fn radius_times_area<T: Circle>(c: T) -> f64 {\n@@ -879,7 +921,7 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n \n Likewise, supertrait methods may also be called on trait objects.\n \n-```{.ignore}\n+```rust,ignore\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # impl Shape for i32 { fn area(&self) -> f64 { 0.0 } }\n@@ -896,7 +938,7 @@ specific type.\n \n Implementations are defined with the keyword `impl`.\n \n-```\n+```rust\n # #[derive(Copy, Clone)]\n # struct Point {x: f64, y: f64};\n # type Surface = i32;\n@@ -935,7 +977,7 @@ trait type and `for` after `impl` are omitted. Such implementations are limited\n to nominal types (enums, structs, trait objects), and the implementation must\n appear in the same crate as the `self` type:\n \n-```\n+```rust\n struct Point {x: i32, y: i32}\n \n impl Point {\n@@ -955,7 +997,7 @@ An implementation can take type parameters, which can be different from the\n type parameters taken by the trait it implements. Implementation parameters\n are written after the `impl` keyword.\n \n-```\n+```rust\n # trait Seq<T> { fn dummy(&self, _: T) { } }\n impl<T> Seq<T> for Vec<T> {\n     /* ... */\n@@ -982,19 +1024,21 @@ the Rust ABI and the foreign ABI.\n Functions within external blocks may be variadic by specifying `...` after one\n or more named arguments in the argument list:\n \n-```ignore\n+```rust,ignore\n extern {\n     fn foo(x: i32, ...);\n }\n ```\n \n-A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n+A number of [attributes] control the behavior of external blocks.\n+\n+[attributes]: attributes.html#ffi-attributes\n \n By default external blocks assume that the library they are calling uses the\n standard C ABI on the specific platform. Other ABIs may be specified using an\n `abi` string, as shown here:\n \n-```ignore\n+```rust,ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n@@ -1033,7 +1077,7 @@ The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name.\n \n-```{.ignore}\n+```rust,ignore\n #[link(name = \"crypto\")]\n extern { }\n ```"}]}