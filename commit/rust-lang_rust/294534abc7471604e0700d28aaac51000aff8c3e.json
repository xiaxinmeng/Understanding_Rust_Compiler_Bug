{"sha": "294534abc7471604e0700d28aaac51000aff8c3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NDUzNGFiYzc0NzE2MDRlMDcwMGQyOGFhYWM1MTAwMGFmZjhjM2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-04T02:04:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-04T02:04:55Z"}, "message": "accidentally quadratic", "tree": {"sha": "717fa1e9563b0fa81e2149a783917b678ff0cb43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/717fa1e9563b0fa81e2149a783917b678ff0cb43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/294534abc7471604e0700d28aaac51000aff8c3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/294534abc7471604e0700d28aaac51000aff8c3e", "html_url": "https://github.com/rust-lang/rust/commit/294534abc7471604e0700d28aaac51000aff8c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/294534abc7471604e0700d28aaac51000aff8c3e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4df965a002b5296fc728f1bc2fb9312fe421ea5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4df965a002b5296fc728f1bc2fb9312fe421ea5d", "html_url": "https://github.com/rust-lang/rust/commit/4df965a002b5296fc728f1bc2fb9312fe421ea5d"}], "stats": {"total": 51, "additions": 35, "deletions": 16}, "files": [{"sha": "1ee6bdf183ecae8bd53dac679e6de720dc1ad8f1", "filename": "crates/libsyntax2/src/yellow/red.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/294534abc7471604e0700d28aaac51000aff8c3e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294534abc7471604e0700d28aaac51000aff8c3e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fred.rs?ref=294534abc7471604e0700d28aaac51000aff8c3e", "patch": "@@ -5,7 +5,28 @@ use {yellow::{GreenNode, RedPtr}, TextUnit};\n pub(crate) struct RedNode {\n     green: GreenNode,\n     parent: Option<ParentData>,\n-    children: RwLock<Box<[Option<RedNode>]>>,\n+    children: RwLock<Box<[RedChild]>>,\n+}\n+\n+#[derive(Debug)]\n+enum RedChild {\n+    Zigot(TextUnit),\n+    Child(RedNode)\n+}\n+\n+impl RedChild {\n+    fn set(&mut self, node: RedNode) -> &RedNode {\n+        match self {\n+            RedChild::Child(node) => return node,\n+            RedChild::Zigot(_) => {\n+                *self = RedChild::Child(node);\n+                match self {\n+                    RedChild::Child(node) => return node,\n+                    RedChild::Zigot(_) => unreachable!()\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug)]\n@@ -35,9 +56,14 @@ impl RedNode {\n     }\n \n     fn new(green: GreenNode, parent: Option<ParentData>) -> RedNode {\n-        let n_children = green.children().len();\n-        let children = (0..n_children)\n-            .map(|_| None)\n+        let start_offset = parent.as_ref().map(|it| it.start_offset).unwrap_or(0.into());\n+        let children = green.children()\n+            .iter()\n+            .scan(start_offset, |start_offset, child| {\n+                let res = RedChild::Zigot(*start_offset);\n+                *start_offset += child.text_len();\n+                Some(res)\n+            })\n             .collect::<Vec<_>>()\n             .into_boxed_slice();\n         RedNode {\n@@ -66,23 +92,16 @@ impl RedNode {\n         if idx >= self.n_children() {\n             return None;\n         }\n-        match &self.children.read()[idx] {\n-            Some(child) => return Some(RedPtr::new(child)),\n-            None => (),\n+        let start_offset = match &self.children.read()[idx] {\n+            RedChild::Child(child) => return Some(RedPtr::new(child)),\n+            RedChild::Zigot(start_offset) => *start_offset,\n         };\n         let green_children = self.green.children();\n-        let start_offset = self.start_offset()\n-            + green_children[..idx]\n-            .iter()\n-            .map(|x| x.text_len())\n-            .sum::<TextUnit>();\n         let child =\n             RedNode::new_child(green_children[idx].clone(), RedPtr::new(self), start_offset, idx);\n         let mut children = self.children.write();\n-        if children[idx].is_none() {\n-            children[idx] = Some(child)\n-        }\n-        Some(RedPtr::new(children[idx].as_ref().unwrap()))\n+        let child = children[idx].set(child);\n+        Some(RedPtr::new(child))\n     }\n \n     pub(crate) fn parent(&self) -> Option<RedPtr> {"}]}