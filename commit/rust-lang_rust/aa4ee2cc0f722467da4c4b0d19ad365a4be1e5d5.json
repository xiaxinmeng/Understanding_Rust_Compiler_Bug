{"sha": "aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNGVlMmNjMGY3MjI0NjdkYTRjNGIwZDE5YWQzNjVhNGJlMWU1ZDU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-10-07T22:23:16Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-10-17T23:16:41Z"}, "message": "Move to storing constructor functions inside LintStore\n\nThis stops storing the pass objects and instead stores constructor\nfunctions.\n\nThe primary effect is that LintStore no longer has any interior\nmutability.", "tree": {"sha": "f3d612538247d7a35fbb332840af06c237e4a0f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3d612538247d7a35fbb332840af06c237e4a0f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "html_url": "https://github.com/rust-lang/rust/commit/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24545128ebf7e19536e1384f64b89a18742471b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/24545128ebf7e19536e1384f64b89a18742471b0", "html_url": "https://github.com/rust-lang/rust/commit/24545128ebf7e19536e1384f64b89a18742471b0"}], "stats": {"total": 59, "additions": 26, "deletions": 33}, "files": [{"sha": "6e67c0315cf23f2788c71514fdc41fda32a679d8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "patch": "@@ -35,7 +35,7 @@ use crate::util::common::time;\n use errors::DiagnosticBuilder;\n use std::slice;\n use std::default::Default as StdDefault;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_data_structures::sync::{ReadGuard, ParallelIterator, join, par_iter};\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n use syntax::edition;\n@@ -52,12 +52,17 @@ pub struct LintStore {\n     /// added by a plugin.\n     lints: Vec<&'static Lint>,\n \n-    /// Trait objects for each lint pass.\n-    /// This is only `None` while performing a lint pass.\n-    pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n-    early_passes: Option<Vec<EarlyLintPassObject>>,\n-    late_passes: Lock<Option<Vec<LateLintPassObject>>>,\n-    late_module_passes: Vec<LateLintPassObject>,\n+    /// Constructor functions for each variety of lint pass.\n+    ///\n+    /// These should only be called once, but since we want to avoid locks or\n+    /// interior mutability, we don't enforce this (and lints should, in theory,\n+    /// be compatible with being constructed more than once, though not\n+    /// necessarily in a sane manner. This is safe though.)\n+    pre_expansion_passes: Vec<fn() -> EarlyLintPassObject>,\n+    early_passes: Vec<fn() -> EarlyLintPassObject>,\n+    late_passes: Vec<fn() -> LateLintPassObject>,\n+    /// This is unique in that we construct them per-module, so not once.\n+    late_module_passes: Vec<fn() -> LateLintPassObject>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -142,9 +147,9 @@ impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n-            pre_expansion_passes: Some(vec![]),\n-            early_passes: Some(vec![]),\n-            late_passes: Lock::new(Some(vec![])),\n+            pre_expansion_passes: vec![],\n+            early_passes: vec![],\n+            late_passes: vec![],\n             late_module_passes: vec![],\n             by_name: Default::default(),\n             future_incompatible: Default::default(),\n@@ -169,19 +174,19 @@ impl LintStore {\n     }\n \n     pub fn register_early_pass(&mut self, pass: fn() -> EarlyLintPassObject) {\n-        self.early_passes.as_mut().unwrap().push((pass)());\n+        self.early_passes.push(pass);\n     }\n \n     pub fn register_pre_expansion_pass(&mut self, pass: fn() -> EarlyLintPassObject) {\n-        self.pre_expansion_passes.as_mut().unwrap().push((pass)());\n+        self.pre_expansion_passes.push(pass);\n     }\n \n     pub fn register_late_pass(&mut self, pass: fn() -> LateLintPassObject) {\n-        self.late_passes.lock().as_mut().unwrap().push((pass)());\n+        self.late_passes.push(pass);\n     }\n \n     pub fn register_late_mod_pass(&mut self, pass: fn() -> LateLintPassObject) {\n-        self.late_module_passes.push((pass)());\n+        self.late_module_passes.push(pass);\n     }\n \n     // Helper method for register_early/late_pass\n@@ -1374,7 +1379,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n \n     let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                .iter().map(|pass| pass.fresh_late_pass()).collect();\n+                                .iter().map(|pass| (pass)()).collect();\n \n     if !passes.is_empty() {\n         late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n@@ -1415,7 +1420,8 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n+    let mut passes = tcx.sess.lint_store.borrow()\n+        .late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n         if !passes.is_empty() {\n@@ -1431,17 +1437,14 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         }\n \n         let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                    .iter().map(|pass| pass.fresh_late_pass()).collect();\n+                                    .iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n             time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n                 late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n             });\n         }\n     }\n-\n-    // Put the passes back in the session.\n-    *tcx.sess.lint_store.borrow().late_passes.lock() = Some(passes);\n }\n \n /// Performs lint checking on a crate.\n@@ -1525,14 +1528,14 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n     pre_expansion: bool,\n     builtin_lints: T,\n ) {\n-    let (mut passes, mut buffered) = if pre_expansion {\n+    let (mut passes, mut buffered): (Vec<_>, _) = if pre_expansion {\n         (\n-            sess.lint_store.borrow_mut().pre_expansion_passes.take().unwrap(),\n+            sess.lint_store.borrow().pre_expansion_passes.iter().map(|p| (p)()).collect(),\n             LintBuffer::default(),\n         )\n     } else {\n         (\n-            sess.lint_store.borrow_mut().early_passes.take().unwrap(),\n+            sess.lint_store.borrow().early_passes.iter().map(|p| (p)()).collect(),\n             sess.buffered_lints.borrow_mut().take().unwrap(),\n         )\n     };\n@@ -1561,13 +1564,6 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     }\n \n-    // Put the lint store levels and passes back in the session.\n-    if pre_expansion {\n-        sess.lint_store.borrow_mut().pre_expansion_passes = Some(passes);\n-    } else {\n-        sess.lint_store.borrow_mut().early_passes = Some(passes);\n-    }\n-\n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug."}, {"sha": "63c4013e1d31785d205c34d3f62e050bb17a5f5e", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=aa4ee2cc0f722467da4c4b0d19ad365a4be1e5d5", "patch": "@@ -286,9 +286,6 @@ macro_rules! expand_lint_pass_methods {\n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n         pub trait LateLintPass<'a, $hir>: LintPass {\n-            fn fresh_late_pass(&self) -> LateLintPassObject {\n-                panic!()\n-            }\n             expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n         }\n     )"}]}