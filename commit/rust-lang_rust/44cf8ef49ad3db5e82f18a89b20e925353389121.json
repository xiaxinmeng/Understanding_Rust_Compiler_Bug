{"sha": "44cf8ef49ad3db5e82f18a89b20e925353389121", "node_id": "C_kwDOAAsO6NoAKDQ0Y2Y4ZWY0OWFkM2RiNWU4MmYxOGE4OWIyMGU5MjUzNTMzODkxMjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T19:43:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T19:43:51Z"}, "message": "Auto merge of #14470 - HKalbasi:mir, r=HKalbasi\n\nCompute closure captures\n\nThis PR:\n* Computes closure captures and the trait it implements (Fn, FnMut or FnOnce)\n* Computes data layout of closures\n* Adds support for closure MIR lowering\n* Changes the closure type display from `|arg1: ty1, arg2: ty| -> ret` to `impl FnX(arg1: ty1, arg2: ty2) -> ret`\n\nfix #12297", "tree": {"sha": "439783fc580c779b5a503ed63125046f9d717b4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/439783fc580c779b5a503ed63125046f9d717b4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44cf8ef49ad3db5e82f18a89b20e925353389121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44cf8ef49ad3db5e82f18a89b20e925353389121", "html_url": "https://github.com/rust-lang/rust/commit/44cf8ef49ad3db5e82f18a89b20e925353389121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44cf8ef49ad3db5e82f18a89b20e925353389121/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51d5862caf428c9e160ccf28d684f0a33faccd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/51d5862caf428c9e160ccf28d684f0a33faccd7d", "html_url": "https://github.com/rust-lang/rust/commit/51d5862caf428c9e160ccf28d684f0a33faccd7d"}, {"sha": "59b6f2d9f2fe40b0176b64bf295562d0beaabc3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/59b6f2d9f2fe40b0176b64bf295562d0beaabc3e", "html_url": "https://github.com/rust-lang/rust/commit/59b6f2d9f2fe40b0176b64bf295562d0beaabc3e"}], "stats": {"total": 2968, "additions": 2536, "deletions": 432}, "files": [{"sha": "688c9e86bbb614b9659c7a4220293eda44791378", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -28,9 +28,9 @@ use crate::{\n     data::adt::StructKind,\n     db::DefDatabase,\n     hir::{\n-        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n-        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n-        Statement,\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Expr,\n+        ExprId, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat,\n+        RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n@@ -67,6 +67,7 @@ pub(super) fn lower(\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n         label_ribs: Vec::new(),\n+        current_binding_owner: None,\n     }\n     .collect(params, body, is_async_fn)\n }\n@@ -92,6 +93,7 @@ struct ExprCollector<'a> {\n \n     // resolution\n     label_ribs: Vec<LabelRib>,\n+    current_binding_owner: Option<ExprId>,\n }\n \n #[derive(Clone, Debug)]\n@@ -261,11 +263,16 @@ impl ExprCollector<'_> {\n                 }\n                 Some(ast::BlockModifier::Const(_)) => {\n                     self.with_label_rib(RibKind::Constant, |this| {\n-                        this.collect_block_(e, |id, statements, tail| Expr::Const {\n-                            id,\n-                            statements,\n-                            tail,\n-                        })\n+                        this.collect_as_a_binding_owner_bad(\n+                            |this| {\n+                                this.collect_block_(e, |id, statements, tail| Expr::Const {\n+                                    id,\n+                                    statements,\n+                                    tail,\n+                                })\n+                            },\n+                            syntax_ptr,\n+                        )\n                     })\n                 }\n                 None => self.collect_block(e),\n@@ -461,6 +468,8 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {\n+                let (result_expr_id, prev_binding_owner) =\n+                    this.initialize_binding_owner(syntax_ptr);\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -494,17 +503,19 @@ impl ExprCollector<'_> {\n                     ClosureKind::Closure\n                 };\n                 this.is_lowering_generator = prev_is_lowering_generator;\n-\n-                this.alloc_expr(\n-                    Expr::Closure {\n-                        args: args.into(),\n-                        arg_types: arg_types.into(),\n-                        ret_type,\n-                        body,\n-                        closure_kind,\n-                    },\n-                    syntax_ptr,\n-                )\n+                let capture_by =\n+                    if e.move_token().is_some() { CaptureBy::Value } else { CaptureBy::Ref };\n+                this.is_lowering_generator = prev_is_lowering_generator;\n+                this.current_binding_owner = prev_binding_owner;\n+                this.body.exprs[result_expr_id] = Expr::Closure {\n+                    args: args.into(),\n+                    arg_types: arg_types.into(),\n+                    ret_type,\n+                    body,\n+                    closure_kind,\n+                    capture_by,\n+                };\n+                result_expr_id\n             }),\n             ast::Expr::BinExpr(e) => {\n                 let op = e.op_kind();\n@@ -545,7 +556,15 @@ impl ExprCollector<'_> {\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n                         let repeat = self.with_label_rib(RibKind::Constant, |this| {\n-                            this.collect_expr_opt(repeat)\n+                            if let Some(repeat) = repeat {\n+                                let syntax_ptr = AstPtr::new(&repeat);\n+                                this.collect_as_a_binding_owner_bad(\n+                                    |this| this.collect_expr(repeat),\n+                                    syntax_ptr,\n+                                )\n+                            } else {\n+                                this.missing_expr()\n+                            }\n                         });\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n@@ -592,6 +611,32 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    fn initialize_binding_owner(\n+        &mut self,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> (ExprId, Option<ExprId>) {\n+        let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);\n+        let prev_binding_owner = self.current_binding_owner.take();\n+        self.current_binding_owner = Some(result_expr_id);\n+        (result_expr_id, prev_binding_owner)\n+    }\n+\n+    /// FIXME: This function is bad. It will produce a dangling `Missing` expr which wastes memory. Currently\n+    /// it is used only for const blocks and repeat expressions, which are also hacky and ideally should have\n+    /// their own body. Don't add more usage for this function so that we can remove this function after\n+    /// separating those bodies.\n+    fn collect_as_a_binding_owner_bad(\n+        &mut self,\n+        job: impl FnOnce(&mut ExprCollector<'_>) -> ExprId,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> ExprId {\n+        let (id, prev_owner) = self.initialize_binding_owner(syntax_ptr);\n+        let tmp = job(self);\n+        self.body.exprs[id] = mem::replace(&mut self.body.exprs[tmp], Expr::Missing);\n+        self.current_binding_owner = prev_owner;\n+        id\n+    }\n+\n     /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n     /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n     /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n@@ -1112,8 +1157,13 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n                 if let Some(block) = const_block_pat.block_expr() {\n-                    let expr_id =\n-                        self.with_label_rib(RibKind::Constant, |this| this.collect_block(block));\n+                    let expr_id = self.with_label_rib(RibKind::Constant, |this| {\n+                        let syntax_ptr = AstPtr::new(&block.clone().into());\n+                        this.collect_as_a_binding_owner_bad(\n+                            |this| this.collect_block(block),\n+                            syntax_ptr,\n+                        )\n+                    });\n                     Pat::ConstBlock(expr_id)\n                 } else {\n                     Pat::Missing\n@@ -1272,7 +1322,12 @@ impl ExprCollector<'_> {\n     }\n \n     fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n-        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n+        self.body.bindings.alloc(Binding {\n+            name,\n+            mode,\n+            definitions: SmallVec::new(),\n+            owner: self.current_binding_owner,\n+        })\n     }\n \n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {"}, {"sha": "c3bd99b94876a0562fb29d8c601406e28ebb89e5", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -5,7 +5,9 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    hir::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n+    hir::{\n+        Array, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Literal, Movability, Statement,\n+    },\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -360,7 +362,7 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind, capture_by } => {\n                 match closure_kind {\n                     ClosureKind::Generator(Movability::Static) => {\n                         w!(self, \"static \");\n@@ -370,6 +372,12 @@ impl<'a> Printer<'a> {\n                     }\n                     _ => (),\n                 }\n+                match capture_by {\n+                    CaptureBy::Value => {\n+                        w!(self, \"move \");\n+                    }\n+                    CaptureBy::Ref => (),\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {"}, {"sha": "8709ad0e99b8d6a541e85a4db34c492163be813f", "filename": "crates/hir-def/src/hir.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -275,6 +275,7 @@ pub enum Expr {\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n         closure_kind: ClosureKind,\n+        capture_by: CaptureBy,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -292,6 +293,14 @@ pub enum ClosureKind {\n     Async,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureBy {\n+    /// `move |x| y + x`.\n+    Value,\n+    /// `move` keyword was not specified.\n+    Ref,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Movability {\n     Static,\n@@ -484,6 +493,22 @@ pub struct Binding {\n     pub name: Name,\n     pub mode: BindingAnnotation,\n     pub definitions: SmallVec<[PatId; 1]>,\n+    /// Id of the closure/generator that owns this binding. If it is owned by the\n+    /// top level expression, this field would be `None`.\n+    pub owner: Option<ExprId>,\n+}\n+\n+impl Binding {\n+    pub fn is_upvar(&self, relative_to: ExprId) -> bool {\n+        match self.owner {\n+            Some(x) => {\n+                // We assign expression ids in a way that outer closures will recieve\n+                // a lower id\n+                x.into_raw() < relative_to.into_raw()\n+            }\n+            None => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "d6a56124856513f34fe65eb5436668f0367b2d08", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -12,8 +12,9 @@ use hir_def::{\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n-    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n+    CallableDefId, CallableSig, ClosureId, DynTy, FnPointer, ImplTraitId, Interner, Lifetime,\n+    ProjectionTy, QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags,\n+    WhereClause,\n };\n \n pub trait TyExt {\n@@ -28,6 +29,7 @@ pub trait TyExt {\n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n     fn as_builtin(&self) -> Option<BuiltinType>;\n     fn as_tuple(&self) -> Option<&Substitution>;\n+    fn as_closure(&self) -> Option<ClosureId>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)>;\n@@ -128,6 +130,13 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn as_closure(&self) -> Option<ClosureId> {\n+        match self.kind(Interner) {\n+            TyKind::Closure(id, _) => Some(*id),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId> {\n         match self.callable_def(db) {\n             Some(CallableDefId::FunctionId(func)) => Some(func),"}, {"sha": "d987f41c7064744065bd1cdd91ae6cf6f890fc8f", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1105,6 +1105,81 @@ fn try_block() {\n     );\n }\n \n+#[test]\n+fn closures() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |x| x + y;\n+        c(2)\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |(a, b): &(i32, i32)| *a + *b + y;\n+        c(&(2, 3))\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let mut y = 5;\n+        let c = |x| {\n+            y = y + x;\n+        };\n+        c(2);\n+        c(3);\n+        y\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    struct X(i32);\n+    impl X {\n+        fn mult(&mut self, n: i32) {\n+            self.0 = self.0 * n\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x = X(1);\n+        let c = || {\n+            x.mult(2);\n+            || {\n+                x.mult(3);\n+                || {\n+                    || {\n+                        x.mult(4);\n+                        || {\n+                            x.mult(x.0);\n+                            || {\n+                                x.0\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+        let r = c()()()()()();\n+        r + x.0\n+    };\n+        \"#,\n+        24 * 24 * 2,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number("}, {"sha": "3a8fb665c44f5297488cac79d515a79617b6359f", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -19,9 +19,9 @@ use crate::{\n     consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     mir::{BorrowckResult, MirBody, MirLowerError},\n-    Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n-    PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n-    ValueTyDefId,\n+    Binders, CallableDefId, ClosureId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult,\n+    Interner, PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty,\n+    TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -38,8 +38,11 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::mir::mir_body_recover)]\n     fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::mir_body_for_closure_query)]\n+    fn mir_body_for_closure(&self, def: ClosureId) -> Result<Arc<MirBody>, MirLowerError>;\n+\n     #[salsa::invoke(crate::mir::borrowck_query)]\n-    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<[BorrowckResult]>, MirLowerError>;\n \n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]"}, {"sha": "f892a815197082e201d0e1108c993580cea5548d", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -23,6 +23,7 @@ use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n+use stdx::never;\n \n use crate::{\n     db::HirDatabase,\n@@ -64,6 +65,7 @@ pub struct HirFormatter<'a> {\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    closure_style: ClosureStyle,\n     display_target: DisplayTarget,\n }\n \n@@ -87,6 +89,7 @@ pub trait HirDisplay {\n         max_size: Option<usize>,\n         omit_verbose_types: bool,\n         display_target: DisplayTarget,\n+        closure_style: ClosureStyle,\n     ) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n@@ -95,7 +98,14 @@ pub trait HirDisplay {\n             !matches!(display_target, DisplayTarget::SourceCode { .. }),\n             \"HirDisplayWrapper cannot fail with DisplaySourceCodeError, use HirDisplay::hir_fmt directly instead\"\n         );\n-        HirDisplayWrapper { db, t: self, max_size, omit_verbose_types, display_target }\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types,\n+            display_target,\n+            closure_style,\n+        }\n     }\n \n     /// Returns a `Display`able type that is human-readable.\n@@ -109,6 +119,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Diagnostics,\n         }\n     }\n@@ -128,6 +139,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size,\n             omit_verbose_types: true,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Diagnostics,\n         }\n     }\n@@ -147,6 +159,7 @@ pub trait HirDisplay {\n             curr_size: 0,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::SourceCode { module_id },\n         }) {\n             Ok(()) => {}\n@@ -166,6 +179,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Test,\n         }\n     }\n@@ -253,7 +267,6 @@ impl DisplayTarget {\n pub enum DisplaySourceCodeError {\n     PathNotFound,\n     UnknownType,\n-    Closure,\n     Generator,\n }\n \n@@ -274,9 +287,23 @@ pub struct HirDisplayWrapper<'a, T> {\n     t: &'a T,\n     max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    closure_style: ClosureStyle,\n     display_target: DisplayTarget,\n }\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum ClosureStyle {\n+    /// `impl FnX(i32, i32) -> i32`, where `FnX` is the most special trait between `Fn`, `FnMut`, `FnOnce` that the\n+    /// closure implements. This is the default.\n+    ImplFn,\n+    /// `|i32, i32| -> i32`\n+    RANotation,\n+    /// `{closure#14825}`, useful for some diagnostics (like type mismatch) and internal usage.\n+    ClosureWithId,\n+    /// `\u2026`, which is the `TYPE_HINT_TRUNCATION`\n+    Hide,\n+}\n+\n impl<T: HirDisplay> HirDisplayWrapper<'_, T> {\n     pub fn write_to<F: HirWrite>(&self, f: &mut F) -> Result<(), HirDisplayError> {\n         self.t.hir_fmt(&mut HirFormatter {\n@@ -287,8 +314,14 @@ impl<T: HirDisplay> HirDisplayWrapper<'_, T> {\n             max_size: self.max_size,\n             omit_verbose_types: self.omit_verbose_types,\n             display_target: self.display_target,\n+            closure_style: self.closure_style,\n         })\n     }\n+\n+    pub fn with_closure_style(mut self, c: ClosureStyle) -> Self {\n+        self.closure_style = c;\n+        self\n+    }\n }\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n@@ -919,26 +952,42 @@ impl HirDisplay for Ty {\n                     }\n                 }\n             }\n-            TyKind::Closure(.., substs) => {\n-                if f.display_target.is_source_code() {\n-                    return Err(HirDisplayError::DisplaySourceCodeError(\n-                        DisplaySourceCodeError::Closure,\n-                    ));\n+            TyKind::Closure(id, substs) => {\n+                if f.display_target.is_source_code() && f.closure_style != ClosureStyle::ImplFn {\n+                    never!(\"Only `impl Fn` is valid for displaying closures in source code\");\n+                }\n+                match f.closure_style {\n+                    ClosureStyle::Hide => return write!(f, \"{TYPE_HINT_TRUNCATION}\"),\n+                    ClosureStyle::ClosureWithId => {\n+                        return write!(f, \"{{closure#{:?}}}\", id.0.as_u32())\n+                    }\n+                    _ => (),\n                 }\n                 let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db);\n                 if let Some(sig) = sig {\n+                    let (def, _) = db.lookup_intern_closure((*id).into());\n+                    let infer = db.infer(def);\n+                    let (_, kind) = infer.closure_info(id);\n+                    match f.closure_style {\n+                        ClosureStyle::ImplFn => write!(f, \"impl {kind:?}(\")?,\n+                        ClosureStyle::RANotation => write!(f, \"|\")?,\n+                        _ => unreachable!(),\n+                    }\n                     if sig.params().is_empty() {\n-                        write!(f, \"||\")?;\n                     } else if f.should_truncate() {\n-                        write!(f, \"|{TYPE_HINT_TRUNCATION}|\")?;\n+                        write!(f, \"{TYPE_HINT_TRUNCATION}\")?;\n                     } else {\n-                        write!(f, \"|\")?;\n                         f.write_joined(sig.params(), \", \")?;\n-                        write!(f, \"|\")?;\n                     };\n-\n-                    write!(f, \" -> \")?;\n-                    sig.ret().hir_fmt(f)?;\n+                    match f.closure_style {\n+                        ClosureStyle::ImplFn => write!(f, \")\")?,\n+                        ClosureStyle::RANotation => write!(f, \"|\")?,\n+                        _ => unreachable!(),\n+                    }\n+                    if f.closure_style == ClosureStyle::RANotation || !sig.ret().is_unit() {\n+                        write!(f, \" -> \")?;\n+                        sig.ret().hir_fmt(f)?;\n+                    }\n                 } else {\n                     write!(f, \"{{closure}}\")?;\n                 }"}, {"sha": "b4da1a308d3bf1a2a921c3de24b1ab6d196861da", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -39,9 +39,9 @@ use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n-    static_lifetime, to_assoc_type_id, AliasEq, AliasTy, DomainGoal, GenericArg, Goal, ImplTraitId,\n-    InEnvironment, Interner, ProjectionTy, RpitId, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n-    TyKind,\n+    static_lifetime, to_assoc_type_id, traits::FnTrait, AliasEq, AliasTy, ClosureId, DomainGoal,\n+    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n+    TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -52,6 +52,8 @@ pub use coerce::could_coerce;\n #[allow(unreachable_pub)]\n pub use unify::could_unify;\n \n+pub(crate) use self::closure::{CaptureKind, CapturedItem, CapturedItemWithoutTy};\n+\n pub(crate) mod unify;\n mod path;\n mod expr;\n@@ -103,6 +105,8 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n \n     ctx.infer_mut_body();\n \n+    ctx.infer_closures();\n+\n     Arc::new(ctx.resolve_all())\n }\n \n@@ -312,6 +316,13 @@ pub enum AutoBorrow {\n     RawPtr(Mutability),\n }\n \n+impl AutoBorrow {\n+    fn mutability(self) -> Mutability {\n+        let (AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) = self;\n+        m\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum PointerCast {\n     /// Go from a fn-item type to a fn-pointer type.\n@@ -373,6 +384,9 @@ pub struct InferenceResult {\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n     pub pat_binding_modes: FxHashMap<PatId, BindingMode>,\n     pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n+    pub(crate) closure_info: FxHashMap<ClosureId, (Vec<CapturedItem>, FnTrait)>,\n+    // FIXME: remove this field\n+    pub mutated_bindings_in_closure: FxHashSet<BindingId>,\n }\n \n impl InferenceResult {\n@@ -409,6 +423,9 @@ impl InferenceResult {\n             _ => None,\n         })\n     }\n+    pub(crate) fn closure_info(&self, closure: &ClosureId) -> &(Vec<CapturedItem>, FnTrait) {\n+        self.closure_info.get(closure).unwrap()\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -460,6 +477,14 @@ pub(crate) struct InferenceContext<'a> {\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n+\n+    // fields related to closure capture\n+    current_captures: Vec<CapturedItemWithoutTy>,\n+    current_closure: Option<ClosureId>,\n+    /// Stores the list of closure ids that need to be analyzed before this closure. See the\n+    /// comment on `InferenceContext::sort_closures`\n+    closure_dependecies: FxHashMap<ClosureId, Vec<ClosureId>>,\n+    deferred_closures: FxHashMap<ClosureId, Vec<(Ty, Ty, Vec<Ty>, ExprId)>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -527,6 +552,10 @@ impl<'a> InferenceContext<'a> {\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n+            current_captures: vec![],\n+            current_closure: None,\n+            deferred_closures: FxHashMap::default(),\n+            closure_dependecies: FxHashMap::default(),\n         }\n     }\n "}, {"sha": "e994546356b2c1e9211002aaa160252422493933", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 718, "deletions": 4, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1,12 +1,29 @@\n //! Inference of closure parameter types based on the closure's expected type.\n \n-use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, WhereClause};\n-use hir_def::{hir::ExprId, HasModule};\n+use std::{cmp, collections::HashMap, convert::Infallible, mem};\n+\n+use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, Mutability, TyKind, WhereClause};\n+use hir_def::{\n+    hir::{\n+        Array, BinaryOp, BindingAnnotation, BindingId, CaptureBy, Expr, ExprId, Pat, PatId,\n+        Statement, UnaryOp,\n+    },\n+    lang_item::LangItem,\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    FieldId, HasModule, VariantId,\n+};\n+use hir_expand::name;\n+use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n+use stdx::never;\n \n use crate::{\n-    to_chalk_trait_id, utils, ChalkTraitId, DynTy, FnPointer, FnSig, Interner, Substitution, Ty,\n-    TyExt, TyKind,\n+    mir::{BorrowKind, ProjectionElem},\n+    static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait,\n+    utils::{self, pattern_matching_dereference_count},\n+    Adjust, Adjustment, Canonical, CanonicalVarKinds, ChalkTraitId, ClosureId, DynTy, FnPointer,\n+    FnSig, InEnvironment, Interner, Substitution, Ty, TyBuilder, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -86,3 +103,700 @@ impl InferenceContext<'_> {\n         None\n     }\n }\n+\n+// The below functions handle capture and closure kind (Fn, FnMut, ..)\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct HirPlace {\n+    pub(crate) local: BindingId,\n+    pub(crate) projections: Vec<ProjectionElem<Infallible, Ty>>,\n+}\n+impl HirPlace {\n+    fn ty(&self, ctx: &mut InferenceContext<'_>) -> Ty {\n+        let mut ty = ctx.table.resolve_completely(ctx.result[self.local].clone());\n+        for p in &self.projections {\n+            ty = p.projected_ty(ty, ctx.db, |_, _| {\n+                unreachable!(\"Closure field only happens in MIR\");\n+            });\n+        }\n+        ty.clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub(crate) enum CaptureKind {\n+    ByRef(BorrowKind),\n+    ByValue,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct CapturedItem {\n+    pub(crate) place: HirPlace,\n+    pub(crate) kind: CaptureKind,\n+    pub(crate) ty: Ty,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct CapturedItemWithoutTy {\n+    pub(crate) place: HirPlace,\n+    pub(crate) kind: CaptureKind,\n+}\n+\n+impl CapturedItemWithoutTy {\n+    fn with_ty(self, ctx: &mut InferenceContext<'_>) -> CapturedItem {\n+        let ty = self.place.ty(ctx).clone();\n+        let ty = match &self.kind {\n+            CaptureKind::ByValue => ty,\n+            CaptureKind::ByRef(bk) => {\n+                let m = match bk {\n+                    BorrowKind::Mut { .. } => Mutability::Mut,\n+                    _ => Mutability::Not,\n+                };\n+                TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n+            }\n+        };\n+        CapturedItem { place: self.place, kind: self.kind, ty }\n+    }\n+}\n+\n+impl InferenceContext<'_> {\n+    fn place_of_expr(&mut self, tgt_expr: ExprId) -> Option<HirPlace> {\n+        let r = self.place_of_expr_without_adjust(tgt_expr)?;\n+        let default = vec![];\n+        let adjustments = self.result.expr_adjustments.get(&tgt_expr).unwrap_or(&default);\n+        apply_adjusts_to_place(r, adjustments)\n+    }\n+\n+    fn place_of_expr_without_adjust(&mut self, tgt_expr: ExprId) -> Option<HirPlace> {\n+        match &self.body[tgt_expr] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n+                if let Some(r) = resolver.resolve_path_in_value_ns(self.db.upcast(), p) {\n+                    if let ResolveValueResult::ValueNs(v) = r {\n+                        if let ValueNs::LocalBinding(b) = v {\n+                            return Some(HirPlace { local: b, projections: vec![] });\n+                        }\n+                    }\n+                }\n+            }\n+            Expr::Field { expr, name } => {\n+                let mut place = self.place_of_expr(*expr)?;\n+                if let TyKind::Tuple(..) = self.expr_ty(*expr).kind(Interner) {\n+                    let index = name.as_tuple_index()?;\n+                    place.projections.push(ProjectionElem::TupleOrClosureField(index))\n+                } else {\n+                    let field = self.result.field_resolution(tgt_expr)?;\n+                    place.projections.push(ProjectionElem::Field(field));\n+                }\n+                return Some(place);\n+            }\n+            _ => (),\n+        }\n+        None\n+    }\n+\n+    fn push_capture(&mut self, capture: CapturedItemWithoutTy) {\n+        self.current_captures.push(capture);\n+    }\n+\n+    fn ref_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.add_capture(place, CaptureKind::ByRef(BorrowKind::Shared));\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn add_capture(&mut self, place: HirPlace, kind: CaptureKind) {\n+        if self.is_upvar(&place) {\n+            self.push_capture(CapturedItemWithoutTy { place, kind });\n+        }\n+    }\n+\n+    fn mutate_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.add_capture(\n+                place,\n+                CaptureKind::ByRef(BorrowKind::Mut { allow_two_phase_borrow: false }),\n+            );\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn consume_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.consume_place(place);\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn consume_place(&mut self, place: HirPlace) {\n+        if self.is_upvar(&place) {\n+            let ty = place.ty(self).clone();\n+            let kind = if self.is_ty_copy(ty) {\n+                CaptureKind::ByRef(BorrowKind::Shared)\n+            } else {\n+                CaptureKind::ByValue\n+            };\n+            self.push_capture(CapturedItemWithoutTy { place, kind });\n+        }\n+    }\n+\n+    fn walk_expr_with_adjust(&mut self, tgt_expr: ExprId, adjustment: &[Adjustment]) {\n+        if let Some((last, rest)) = adjustment.split_last() {\n+            match last.kind {\n+                Adjust::NeverToAny | Adjust::Deref(None) | Adjust::Pointer(_) => {\n+                    self.walk_expr_with_adjust(tgt_expr, rest)\n+                }\n+                Adjust::Deref(Some(m)) => match m.0 {\n+                    Some(m) => {\n+                        self.ref_capture_with_adjusts(m, tgt_expr, rest);\n+                    }\n+                    None => unreachable!(),\n+                },\n+                Adjust::Borrow(b) => {\n+                    self.ref_capture_with_adjusts(b.mutability(), tgt_expr, rest);\n+                }\n+            }\n+        } else {\n+            self.walk_expr_without_adjust(tgt_expr);\n+        }\n+    }\n+\n+    fn ref_capture_with_adjusts(&mut self, m: Mutability, tgt_expr: ExprId, rest: &[Adjustment]) {\n+        let capture_kind = match m {\n+            Mutability::Mut => {\n+                CaptureKind::ByRef(BorrowKind::Mut { allow_two_phase_borrow: false })\n+            }\n+            Mutability::Not => CaptureKind::ByRef(BorrowKind::Shared),\n+        };\n+        if let Some(place) = self.place_of_expr_without_adjust(tgt_expr) {\n+            if let Some(place) = apply_adjusts_to_place(place, rest) {\n+                if self.is_upvar(&place) {\n+                    self.push_capture(CapturedItemWithoutTy { place, kind: capture_kind });\n+                }\n+            }\n+        }\n+        self.walk_expr_with_adjust(tgt_expr, rest);\n+    }\n+\n+    fn walk_expr(&mut self, tgt_expr: ExprId) {\n+        if let Some(x) = self.result.expr_adjustments.get_mut(&tgt_expr) {\n+            // FIXME: this take is completely unneeded, and just is here to make borrow checker\n+            // happy. Remove it if you can.\n+            let x_taken = mem::take(x);\n+            self.walk_expr_with_adjust(tgt_expr, &x_taken);\n+            *self.result.expr_adjustments.get_mut(&tgt_expr).unwrap() = x_taken;\n+        } else {\n+            self.walk_expr_without_adjust(tgt_expr);\n+        }\n+    }\n+\n+    fn walk_expr_without_adjust(&mut self, tgt_expr: ExprId) {\n+        match &self.body[tgt_expr] {\n+            Expr::If { condition, then_branch, else_branch } => {\n+                self.consume_expr(*condition);\n+                self.consume_expr(*then_branch);\n+                if let &Some(expr) = else_branch {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::Async { statements, tail, .. }\n+            | Expr::Const { statements, tail, .. }\n+            | Expr::Unsafe { statements, tail, .. }\n+            | Expr::Block { statements, tail, .. } => {\n+                for s in statements.iter() {\n+                    match s {\n+                        Statement::Let { pat, type_ref: _, initializer, else_branch } => {\n+                            if let Some(else_branch) = else_branch {\n+                                self.consume_expr(*else_branch);\n+                                if let Some(initializer) = initializer {\n+                                    self.consume_expr(*initializer);\n+                                }\n+                                return;\n+                            }\n+                            if let Some(initializer) = initializer {\n+                                self.walk_expr(*initializer);\n+                                if let Some(place) = self.place_of_expr(*initializer) {\n+                                    let ty = self.expr_ty(*initializer);\n+                                    self.consume_with_pat(\n+                                        place,\n+                                        ty,\n+                                        BindingAnnotation::Unannotated,\n+                                        *pat,\n+                                    );\n+                                }\n+                            }\n+                        }\n+                        Statement::Expr { expr, has_semi: _ } => {\n+                            self.consume_expr(*expr);\n+                        }\n+                    }\n+                }\n+                if let Some(tail) = tail {\n+                    self.consume_expr(*tail);\n+                }\n+            }\n+            Expr::While { condition, body, label: _ }\n+            | Expr::For { iterable: condition, pat: _, body, label: _ } => {\n+                self.consume_expr(*condition);\n+                self.consume_expr(*body);\n+            }\n+            Expr::Call { callee, args, is_assignee_expr: _ } => {\n+                self.consume_expr(*callee);\n+                self.consume_exprs(args.iter().copied());\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                self.consume_expr(*receiver);\n+                self.consume_exprs(args.iter().copied());\n+            }\n+            Expr::Match { expr, arms } => {\n+                self.consume_expr(*expr);\n+                for arm in arms.iter() {\n+                    self.consume_expr(arm.expr);\n+                }\n+            }\n+            Expr::Break { expr, label: _ }\n+            | Expr::Return { expr }\n+            | Expr::Yield { expr }\n+            | Expr::Yeet { expr } => {\n+                if let &Some(expr) = expr {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::RecordLit { fields, spread, .. } => {\n+                if let &Some(expr) = spread {\n+                    self.consume_expr(expr);\n+                }\n+                self.consume_exprs(fields.iter().map(|x| x.expr));\n+            }\n+            Expr::Field { expr, name: _ } => self.select_from_expr(*expr),\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if let Some((f, _)) = self.result.method_resolution(tgt_expr) {\n+                    let mutability = 'b: {\n+                        if let Some(deref_trait) =\n+                            self.resolve_lang_item(LangItem::DerefMut).and_then(|x| x.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref_mut])\n+                            {\n+                                break 'b deref_fn == f;\n+                            }\n+                        }\n+                        false\n+                    };\n+                    if mutability {\n+                        self.mutate_expr(*expr);\n+                    } else {\n+                        self.ref_expr(*expr);\n+                    }\n+                } else {\n+                    self.select_from_expr(*expr);\n+                }\n+            }\n+            Expr::UnaryOp { expr, op: _ }\n+            | Expr::Array(Array::Repeat { initializer: expr, repeat: _ })\n+            | Expr::Await { expr }\n+            | Expr::Loop { body: expr, label: _ }\n+            | Expr::Let { pat: _, expr }\n+            | Expr::Box { expr }\n+            | Expr::Cast { expr, type_ref: _ } => {\n+                self.consume_expr(*expr);\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => match mutability {\n+                hir_def::type_ref::Mutability::Shared => self.ref_expr(*expr),\n+                hir_def::type_ref::Mutability::Mut => self.mutate_expr(*expr),\n+            },\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let Some(op) = op else {\n+                    return;\n+                };\n+                if matches!(op, BinaryOp::Assignment { .. }) {\n+                    self.mutate_expr(*lhs);\n+                    self.consume_expr(*rhs);\n+                    return;\n+                }\n+                self.consume_expr(*lhs);\n+                self.consume_expr(*rhs);\n+            }\n+            Expr::Range { lhs, rhs, range_type: _ } => {\n+                if let &Some(expr) = lhs {\n+                    self.consume_expr(expr);\n+                }\n+                if let &Some(expr) = rhs {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::Index { base, index } => {\n+                self.select_from_expr(*base);\n+                self.consume_expr(*index);\n+            }\n+            Expr::Closure { .. } => {\n+                let ty = self.expr_ty(tgt_expr);\n+                let TyKind::Closure(id, _) = ty.kind(Interner) else {\n+                    never!(\"closure type is always closure\");\n+                    return;\n+                };\n+                let (captures, _) =\n+                    self.result.closure_info.get(id).expect(\n+                        \"We sort closures, so we should always have data for inner closures\",\n+                    );\n+                let mut cc = mem::take(&mut self.current_captures);\n+                cc.extend(\n+                    captures\n+                        .iter()\n+                        .filter(|x| self.is_upvar(&x.place))\n+                        .map(|x| CapturedItemWithoutTy { place: x.place.clone(), kind: x.kind }),\n+                );\n+                self.current_captures = cc;\n+            }\n+            Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ })\n+            | Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                self.consume_exprs(exprs.iter().copied())\n+            }\n+            Expr::Missing\n+            | Expr::Continue { .. }\n+            | Expr::Path(_)\n+            | Expr::Literal(_)\n+            | Expr::Underscore => (),\n+        }\n+    }\n+\n+    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n+        self.infer_expr_no_expect(expr)\n+    }\n+\n+    fn is_upvar(&self, place: &HirPlace) -> bool {\n+        let b = &self.body[place.local];\n+        if let Some(c) = self.current_closure {\n+            let (_, root) = self.db.lookup_intern_closure(c.into());\n+            return b.is_upvar(root);\n+        }\n+        false\n+    }\n+\n+    fn is_ty_copy(&self, ty: Ty) -> bool {\n+        if let TyKind::Closure(id, _) = ty.kind(Interner) {\n+            // FIXME: We handle closure as a special case, since chalk consider every closure as copy. We\n+            // should probably let chalk know which closures are copy, but I don't know how doing it\n+            // without creating query cycles.\n+            return self.result.closure_info.get(id).map(|x| x.1 == FnTrait::Fn).unwrap_or(true);\n+        }\n+        let crate_id = self.owner.module(self.db.upcast()).krate();\n+        let Some(copy_trait) = self.db.lang_item(crate_id, LangItem::Copy).and_then(|x| x.as_trait()) else {\n+            return false;\n+        };\n+        let trait_ref = TyBuilder::trait_ref(self.db, copy_trait).push(ty).build();\n+        let env = self.db.trait_environment_for_body(self.owner);\n+        let goal = Canonical {\n+            value: InEnvironment::new(&env.env, trait_ref.cast(Interner)),\n+            binders: CanonicalVarKinds::empty(Interner),\n+        };\n+        self.db.trait_solve(crate_id, None, goal).is_some()\n+    }\n+\n+    fn select_from_expr(&mut self, expr: ExprId) {\n+        self.walk_expr(expr);\n+    }\n+\n+    fn adjust_for_move_closure(&mut self) {\n+        for capture in &mut self.current_captures {\n+            if let Some(first_deref) =\n+                capture.place.projections.iter().position(|proj| *proj == ProjectionElem::Deref)\n+            {\n+                capture.place.projections.truncate(first_deref);\n+            }\n+            capture.kind = CaptureKind::ByValue;\n+        }\n+    }\n+\n+    fn minimize_captures(&mut self) {\n+        self.current_captures.sort_by_key(|x| x.place.projections.len());\n+        let mut hash_map = HashMap::<HirPlace, usize>::new();\n+        let result = mem::take(&mut self.current_captures);\n+        for item in result {\n+            let mut lookup_place = HirPlace { local: item.place.local, projections: vec![] };\n+            let mut it = item.place.projections.iter();\n+            let prev_index = loop {\n+                if let Some(k) = hash_map.get(&lookup_place) {\n+                    break Some(*k);\n+                }\n+                match it.next() {\n+                    Some(x) => lookup_place.projections.push(x.clone()),\n+                    None => break None,\n+                }\n+            };\n+            match prev_index {\n+                Some(p) => {\n+                    self.current_captures[p].kind =\n+                        cmp::max(item.kind, self.current_captures[p].kind);\n+                }\n+                None => {\n+                    hash_map.insert(item.place.clone(), self.current_captures.len());\n+                    self.current_captures.push(item);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_with_pat(\n+        &mut self,\n+        mut place: HirPlace,\n+        mut ty: Ty,\n+        mut bm: BindingAnnotation,\n+        pat: PatId,\n+    ) {\n+        match &self.body[pat] {\n+            Pat::Missing | Pat::Wild => (),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => return,\n+                };\n+                let fields = subst.iter(Interner).map(|x| x.assert_ty_ref(Interner)).enumerate();\n+                let it = al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n+                for (arg, (i, ty)) in it {\n+                    let mut p = place.clone();\n+                    p.projections.push(ProjectionElem::TupleOrClosureField(i));\n+                    self.consume_with_pat(p, ty.clone(), bm, *arg);\n+                }\n+            }\n+            Pat::Or(pats) => {\n+                for pat in pats.iter() {\n+                    self.consume_with_pat(place.clone(), ty.clone(), bm, *pat);\n+                }\n+            }\n+            Pat::Record { args, .. } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Adt(_, s) => s,\n+                    _ => return,\n+                };\n+                let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n+                    return;\n+                };\n+                match variant {\n+                    VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n+                        self.consume_place(place)\n+                    }\n+                    VariantId::StructId(s) => {\n+                        let vd = &*self.db.struct_data(s).variant_data;\n+                        let field_types = self.db.field_types(variant);\n+                        for field_pat in args.iter() {\n+                            let arg = field_pat.pat;\n+                            let Some(local_id) = vd.field(&field_pat.name) else {\n+                                continue;\n+                            };\n+                            let mut p = place.clone();\n+                            p.projections.push(ProjectionElem::Field(FieldId {\n+                                parent: variant.into(),\n+                                local_id,\n+                            }));\n+                            self.consume_with_pat(\n+                                p,\n+                                field_types[local_id].clone().substitute(Interner, subst),\n+                                bm,\n+                                arg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Pat::Range { .. }\n+            | Pat::Slice { .. }\n+            | Pat::ConstBlock(_)\n+            | Pat::Path(_)\n+            | Pat::Lit(_) => self.consume_place(place),\n+            Pat::Bind { id, subpat: _ } => {\n+                let mode = self.body.bindings[*id].mode;\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    bm = mode;\n+                }\n+                let capture_kind = match bm {\n+                    BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                        self.consume_place(place);\n+                        return;\n+                    }\n+                    BindingAnnotation::Ref => BorrowKind::Shared,\n+                    BindingAnnotation::RefMut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+                };\n+                self.add_capture(place, CaptureKind::ByRef(capture_kind));\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Adt(_, s) => s,\n+                    _ => return,\n+                };\n+                let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n+                    return;\n+                };\n+                match variant {\n+                    VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n+                        self.consume_place(place)\n+                    }\n+                    VariantId::StructId(s) => {\n+                        let vd = &*self.db.struct_data(s).variant_data;\n+                        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+                        let fields = vd.fields().iter();\n+                        let it =\n+                            al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n+                        let field_types = self.db.field_types(variant);\n+                        for (arg, (i, _)) in it {\n+                            let mut p = place.clone();\n+                            p.projections.push(ProjectionElem::Field(FieldId {\n+                                parent: variant.into(),\n+                                local_id: i,\n+                            }));\n+                            self.consume_with_pat(\n+                                p,\n+                                field_types[i].clone().substitute(Interner, subst),\n+                                bm,\n+                                *arg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Pat::Ref { pat, mutability: _ } => {\n+                if let Some((inner, _, _)) = ty.as_reference() {\n+                    ty = inner.clone();\n+                    place.projections.push(ProjectionElem::Deref);\n+                    self.consume_with_pat(place, ty, bm, *pat)\n+                }\n+            }\n+            Pat::Box { .. } => (), // not supported\n+        }\n+    }\n+\n+    fn consume_exprs(&mut self, exprs: impl Iterator<Item = ExprId>) {\n+        for expr in exprs {\n+            self.consume_expr(expr);\n+        }\n+    }\n+\n+    fn closure_kind(&self) -> FnTrait {\n+        let mut r = FnTrait::Fn;\n+        for x in &self.current_captures {\n+            r = cmp::min(\n+                r,\n+                match &x.kind {\n+                    CaptureKind::ByRef(BorrowKind::Unique | BorrowKind::Mut { .. }) => {\n+                        FnTrait::FnMut\n+                    }\n+                    CaptureKind::ByRef(BorrowKind::Shallow | BorrowKind::Shared) => FnTrait::Fn,\n+                    CaptureKind::ByValue => FnTrait::FnOnce,\n+                },\n+            )\n+        }\n+        r\n+    }\n+\n+    fn analyze_closure(&mut self, closure: ClosureId) -> FnTrait {\n+        let (_, root) = self.db.lookup_intern_closure(closure.into());\n+        self.current_closure = Some(closure);\n+        let Expr::Closure { body, capture_by, .. } = &self.body[root] else {\n+            unreachable!(\"Closure expression id is always closure\");\n+        };\n+        self.consume_expr(*body);\n+        for item in &self.current_captures {\n+            if matches!(item.kind, CaptureKind::ByRef(BorrowKind::Mut { .. })) {\n+                // FIXME: remove the `mutated_bindings_in_closure` completely and add proper fake reads in\n+                // MIR. I didn't do that due duplicate diagnostics.\n+                self.result.mutated_bindings_in_closure.insert(item.place.local);\n+            }\n+        }\n+        // closure_kind should be done before adjust_for_move_closure\n+        let closure_kind = self.closure_kind();\n+        match capture_by {\n+            CaptureBy::Value => self.adjust_for_move_closure(),\n+            CaptureBy::Ref => (),\n+        }\n+        self.minimize_captures();\n+        let result = mem::take(&mut self.current_captures);\n+        let captures = result.into_iter().map(|x| x.with_ty(self)).collect::<Vec<_>>();\n+        self.result.closure_info.insert(closure, (captures, closure_kind));\n+        closure_kind\n+    }\n+\n+    pub(crate) fn infer_closures(&mut self) {\n+        let deferred_closures = self.sort_closures();\n+        for (closure, exprs) in deferred_closures.into_iter().rev() {\n+            self.current_captures = vec![];\n+            let kind = self.analyze_closure(closure);\n+\n+            for (derefed_callee, callee_ty, params, expr) in exprs {\n+                if let &Expr::Call { callee, .. } = &self.body[expr] {\n+                    let mut adjustments =\n+                        self.result.expr_adjustments.remove(&callee).unwrap_or_default();\n+                    self.write_fn_trait_method_resolution(\n+                        kind,\n+                        &derefed_callee,\n+                        &mut adjustments,\n+                        &callee_ty,\n+                        &params,\n+                        expr,\n+                    );\n+                    self.result.expr_adjustments.insert(callee, adjustments);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We want to analyze some closures before others, to have a correct analysis:\n+    /// * We should analyze nested closures before the parent, since the parent should capture some of\n+    ///   the things that its children captures.\n+    /// * If a closure calls another closure, we need to analyze the callee, to find out how we should\n+    ///   capture it (e.g. by move for FnOnce)\n+    ///\n+    /// These dependencies are collected in the main inference. We do a topological sort in this function. It\n+    /// will consume the `deferred_closures` field and return its content in a sorted vector.\n+    fn sort_closures(&mut self) -> Vec<(ClosureId, Vec<(Ty, Ty, Vec<Ty>, ExprId)>)> {\n+        let mut deferred_closures = mem::take(&mut self.deferred_closures);\n+        let mut dependents_count: FxHashMap<ClosureId, usize> =\n+            deferred_closures.keys().map(|x| (*x, 0)).collect();\n+        for (_, deps) in &self.closure_dependecies {\n+            for dep in deps {\n+                *dependents_count.entry(*dep).or_default() += 1;\n+            }\n+        }\n+        let mut queue: Vec<_> =\n+            deferred_closures.keys().copied().filter(|x| dependents_count[x] == 0).collect();\n+        let mut result = vec![];\n+        while let Some(x) = queue.pop() {\n+            if let Some(d) = deferred_closures.remove(&x) {\n+                result.push((x, d));\n+            }\n+            for dep in self.closure_dependecies.get(&x).into_iter().flat_map(|x| x.iter()) {\n+                let cnt = dependents_count.get_mut(dep).unwrap();\n+                *cnt -= 1;\n+                if *cnt == 0 {\n+                    queue.push(*dep);\n+                }\n+            }\n+        }\n+        result\n+    }\n+}\n+\n+fn apply_adjusts_to_place(mut r: HirPlace, adjustments: &[Adjustment]) -> Option<HirPlace> {\n+    for adj in adjustments {\n+        match &adj.kind {\n+            Adjust::Deref(None) => {\n+                r.projections.push(ProjectionElem::Deref);\n+            }\n+            _ => return None,\n+        }\n+    }\n+    Some(r)\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut HirPlace,\n+) {\n+    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n+    cond_place.projections.extend((0..cnt).map(|_| ProjectionElem::Deref));\n+}"}, {"sha": "2249d84edbfc92d7944af5a215eac7e1013e2c13", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -7,7 +7,7 @@\n \n use std::{iter, sync::Arc};\n \n-use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyKind, TyVariableKind};\n use hir_def::{\n     hir::ExprId,\n     lang_item::{LangItem, LangItemTarget},\n@@ -22,7 +22,7 @@ use crate::{\n         TypeError, TypeMismatch,\n     },\n     static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner,\n-    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n+    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::unify::InferenceTable;\n@@ -111,6 +111,8 @@ impl CoerceMany {\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n         let sig = match (self.merged_ty().kind(Interner), expr_ty.kind(Interner)) {\n+            (TyKind::FnDef(x, _), TyKind::FnDef(y, _)) if x == y => None,\n+            (TyKind::Closure(x, _), TyKind::Closure(y, _)) if x == y => None,\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef"}, {"sha": "64f37c761e963cb6a1ac4ccb42c2c645b3bb6c4f", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -221,7 +221,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind, capture_by: _ } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::with_capacity(arg_types.len() + 1);\n@@ -256,7 +256,7 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = match closure_kind {\n+                let (id, ty, resume_yield_tys) = match closure_kind {\n                     ClosureKind::Generator(_) => {\n                         // FIXME: report error when there are more than 1 parameter.\n                         let resume_ty = match sig_tys.first() {\n@@ -276,7 +276,7 @@ impl<'a> InferenceContext<'a> {\n                         let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n                         let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                        (generator_ty, Some((resume_ty, yield_ty)))\n+                        (None, generator_ty, Some((resume_ty, yield_ty)))\n                     }\n                     ClosureKind::Closure | ClosureKind::Async => {\n                         let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n@@ -285,8 +285,11 @@ impl<'a> InferenceContext<'a> {\n                             Substitution::from1(Interner, sig_ty.clone()),\n                         )\n                         .intern(Interner);\n-\n-                        (closure_ty, None)\n+                        self.deferred_closures.entry(closure_id).or_default();\n+                        if let Some(c) = self.current_closure {\n+                            self.closure_dependecies.entry(c).or_default().push(closure_id);\n+                        }\n+                        (Some(closure_id), closure_ty, None)\n                     }\n                 };\n \n@@ -302,6 +305,7 @@ impl<'a> InferenceContext<'a> {\n \n                 // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_closure = mem::replace(&mut self.current_closure, id);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n                 let prev_ret_coercion =\n                     mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty)));\n@@ -315,6 +319,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n                 self.return_coercion = prev_ret_coercion;\n+                self.current_closure = prev_closure;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -340,43 +345,28 @@ impl<'a> InferenceContext<'a> {\n                 let (param_tys, ret_ty) = match res {\n                     Some((func, params, ret_ty)) => {\n                         let mut adjustments = auto_deref_adjust_steps(&derefs);\n-                        if let Some(fn_x) = func {\n-                            match fn_x {\n-                                FnTrait::FnOnce => (),\n-                                FnTrait::FnMut => {\n-                                    if !matches!(\n-                                        derefed_callee.kind(Interner),\n-                                        TyKind::Ref(Mutability::Mut, _, _)\n-                                    ) {\n-                                        adjustments.push(Adjustment::borrow(\n-                                            Mutability::Mut,\n-                                            derefed_callee.clone(),\n-                                        ));\n-                                    }\n-                                }\n-                                FnTrait::Fn => {\n-                                    if !matches!(\n-                                        derefed_callee.kind(Interner),\n-                                        TyKind::Ref(Mutability::Not, _, _)\n-                                    ) {\n-                                        adjustments.push(Adjustment::borrow(\n-                                            Mutability::Not,\n-                                            derefed_callee.clone(),\n-                                        ));\n-                                    }\n-                                }\n-                            }\n-                            let trait_ = fn_x\n-                                .get_id(self.db, self.table.trait_env.krate)\n-                                .expect(\"We just used it\");\n-                            let trait_data = self.db.trait_data(trait_);\n-                            if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n-                                let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                                    .push(callee_ty.clone())\n-                                    .push(TyBuilder::tuple_with(params.iter().cloned()))\n-                                    .build();\n-                                self.write_method_resolution(tgt_expr, func, subst)\n+                        if let TyKind::Closure(c, _) =\n+                            self.table.resolve_completely(callee_ty.clone()).kind(Interner)\n+                        {\n+                            if let Some(par) = self.current_closure {\n+                                self.closure_dependecies.entry(par).or_default().push(*c);\n                             }\n+                            self.deferred_closures.entry(*c).or_default().push((\n+                                derefed_callee.clone(),\n+                                callee_ty.clone(),\n+                                params.clone(),\n+                                tgt_expr,\n+                            ));\n+                        }\n+                        if let Some(fn_x) = func {\n+                            self.write_fn_trait_method_resolution(\n+                                fn_x,\n+                                &derefed_callee,\n+                                &mut adjustments,\n+                                &callee_ty,\n+                                &params,\n+                                tgt_expr,\n+                            );\n                         }\n                         self.write_expr_adj(*callee, adjustments);\n                         (params, ret_ty)\n@@ -906,6 +896,41 @@ impl<'a> InferenceContext<'a> {\n         TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty)).intern(Interner)\n     }\n \n+    pub(crate) fn write_fn_trait_method_resolution(\n+        &mut self,\n+        fn_x: FnTrait,\n+        derefed_callee: &Ty,\n+        adjustments: &mut Vec<Adjustment>,\n+        callee_ty: &Ty,\n+        params: &Vec<Ty>,\n+        tgt_expr: ExprId,\n+    ) {\n+        match fn_x {\n+            FnTrait::FnOnce => (),\n+            FnTrait::FnMut => {\n+                if !matches!(derefed_callee.kind(Interner), TyKind::Ref(Mutability::Mut, _, _)) {\n+                    adjustments.push(Adjustment::borrow(Mutability::Mut, derefed_callee.clone()));\n+                }\n+            }\n+            FnTrait::Fn => {\n+                if !matches!(derefed_callee.kind(Interner), TyKind::Ref(Mutability::Not, _, _)) {\n+                    adjustments.push(Adjustment::borrow(Mutability::Not, derefed_callee.clone()));\n+                }\n+            }\n+        }\n+        let Some(trait_) = fn_x.get_id(self.db, self.table.trait_env.krate) else {\n+            return;\n+        };\n+        let trait_data = self.db.trait_data(trait_);\n+        if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n+            let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                .push(callee_ty.clone())\n+                .push(TyBuilder::tuple_with(params.iter().cloned()))\n+                .build();\n+            self.write_method_resolution(tgt_expr, func, subst.clone());\n+        }\n+    }\n+\n     fn infer_expr_array(\n         &mut self,\n         array: &Array,"}, {"sha": "f344b0610c99ce1ec420acf0beea2d9a8c5c5029", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -3,7 +3,7 @@\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    hir::{Array, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n+    hir::{Array, BinaryOp, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n     lang_item::LangItem,\n };\n use hir_expand::name;\n@@ -80,6 +80,9 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_mut_expr(*expr, m);\n                 for arm in arms.iter() {\n                     self.infer_mut_expr(arm.expr, Mutability::Not);\n+                    if let Some(g) = arm.guard {\n+                        self.infer_mut_expr(g, Mutability::Not);\n+                    }\n                 }\n             }\n             Expr::Yield { expr }\n@@ -158,14 +161,19 @@ impl<'a> InferenceContext<'a> {\n                 let mutability = lower_to_chalk_mutability(*mutability);\n                 self.infer_mut_expr(*expr, mutability);\n             }\n+            Expr::BinaryOp { lhs, rhs, op: Some(BinaryOp::Assignment { .. }) } => {\n+                self.infer_mut_expr(*lhs, Mutability::Mut);\n+                self.infer_mut_expr(*rhs, Mutability::Not);\n+            }\n             Expr::Array(Array::Repeat { initializer: lhs, repeat: rhs })\n             | Expr::BinaryOp { lhs, rhs, op: _ }\n             | Expr::Range { lhs: Some(lhs), rhs: Some(rhs), range_type: _ } => {\n                 self.infer_mut_expr(*lhs, Mutability::Not);\n                 self.infer_mut_expr(*rhs, Mutability::Not);\n             }\n-            // not implemented\n-            Expr::Closure { .. } => (),\n+            Expr::Closure { body, .. } => {\n+                self.infer_mut_expr(*body, Mutability::Not);\n+            }\n             Expr::Tuple { exprs, is_assignee_expr: _ }\n             | Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ }) => {\n                 self.infer_mut_not_expr_iter(exprs.iter().copied());"}, {"sha": "277998b61784499cade383f90c0f5e413d03c4dd", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -229,7 +229,20 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n                 }\n             }\n         }\n-        TyKind::Closure(_, _) | TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n+        TyKind::Closure(c, _) => {\n+            let (def, _) = db.lookup_intern_closure((*c).into());\n+            let infer = db.infer(def);\n+            let (captures, _) = infer.closure_info(c);\n+            let fields = captures\n+                .iter()\n+                .map(|x| layout_of_ty(db, &x.ty, krate))\n+                .collect::<Result<Vec<_>, _>>()?;\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            cx.univariant(dl, &fields, &ReprOptions::default(), StructKind::AlwaysSized)\n+                .ok_or(LayoutError::Unknown)?\n+        }\n+        TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n             return Err(LayoutError::NotImplemented)\n         }\n         TyKind::AssociatedType(_, _)"}, {"sha": "43ace8ff0326cccfe6cd55cff6bc4ac73e9a4c16", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -11,6 +11,8 @@ use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n \n use super::layout_of_ty;\n \n+mod closure;\n+\n fn current_machine_data_layout() -> String {\n     project_model::target_data_layout::get(None, None, &HashMap::default()).unwrap()\n }\n@@ -81,8 +83,8 @@ fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64)\n #[track_caller]\n fn check_size_and_align_expr(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_expr(ra_fixture, minicore).unwrap();\n-    assert_eq!(l.size.bytes(), size);\n-    assert_eq!(l.align.abi.bytes(), align);\n+    assert_eq!(l.size.bytes(), size, \"size mismatch\");\n+    assert_eq!(l.align.abi.bytes(), align, \"align mismatch\");\n }\n \n #[track_caller]\n@@ -118,13 +120,31 @@ macro_rules! size_and_align {\n     };\n }\n \n+#[macro_export]\n macro_rules! size_and_align_expr {\n+    (minicore: $($x:tt),*; stmts: [$($s:tt)*] $($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            #[allow(unused_must_use)]\n+            #[allow(path_statements)]\n+            {\n+                $($s)*\n+                let val = { $($t)* };\n+                $crate::layout::tests::check_size_and_align_expr(\n+                    &format!(\"{{ {} let val = {{ {} }}; val }}\", stringify!($($s)*), stringify!($($t)*)),\n+                    &format!(\"//- minicore: {}\\n\", stringify!($($x),*)),\n+                    ::std::mem::size_of_val(&val) as u64,\n+                    ::std::mem::align_of_val(&val) as u64,\n+                );\n+            }\n+        }\n+    };\n     ($($t:tt)*) => {\n         {\n             #[allow(dead_code)]\n             {\n                 let val = { $($t)* };\n-                check_size_and_align_expr(\n+                $crate::layout::tests::check_size_and_align_expr(\n                     stringify!($($t)*),\n                     \"\",\n                     ::std::mem::size_of_val(&val) as u64,"}, {"sha": "31b6765a7a2b2f11ed56300ee107f525754333a7", "filename": "crates/hir-ty/src/layout/tests/closure.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -0,0 +1,175 @@\n+use crate::size_and_align_expr;\n+\n+#[test]\n+fn zero_capture_simple() {\n+    size_and_align_expr! {\n+        |x: i32| x + 2\n+    }\n+}\n+\n+#[test]\n+fn move_simple() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: []\n+        let y: i32 = 5;\n+        move |x: i32| {\n+            x + y\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ref_simple() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            let y: i32 = 5;\n+        ]\n+        |x: i32| {\n+            x + y\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            let mut y: i32 = 5;\n+        ]\n+        |x: i32| {\n+            y = y + x;\n+            y\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i32, i64);\n+            let x: X = X(2, 6);\n+        ]\n+        || {\n+            x\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ref_then_mut_then_move() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i32, i64);\n+            let mut x: X = X(2, 6);\n+        ]\n+        || {\n+            &x;\n+            &mut x;\n+            x;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn nested_closures() {\n+    size_and_align_expr! {\n+        || {\n+            || {\n+                || {\n+                    let x = 2;\n+                    move || {\n+                        move || {\n+                            x\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn capture_specific_fields() {\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let _ = &y;\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i64, i32, (u8, i128));\n+            let y: X = X(2, 5, (7, 3));\n+        ]\n+        let y = &y;\n+        move |x: i64| {\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a, _, (b, _)) = y;\n+            a + x + (b as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y = &&X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a, _, (b, _)) = y;\n+            *a + x + (*b as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            match y {\n+                X(a, _, (b, _)) => a + x + (b as i64),\n+            }\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a @ 2, _, (b, _)) = y else { return 5 };\n+            a + x + (b as i64)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ellipsis_pattern() {\n+    size_and_align_expr! {\n+        struct X(i8, u16, i32, u64, i128, u8);\n+        let y: X = X(1, 2, 3, 4, 5, 6);\n+        move |_: i64| {\n+            let X(_a, .., _b, _c) = y;\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X { a: i32, b: u8, c: i128}\n+        let y: X = X { a: 1, b: 2, c: 3 };\n+        move |_: i64| {\n+            let X { a, b, .. } = y;\n+            _ = (a, b);\n+        }\n+    }\n+    size_and_align_expr! {\n+        let y: (&&&(i8, u16, i32, u64, i128, u8), u16, i32, u64, i128, u8) = (&&&(1, 2, 3, 4, 5, 6), 2, 3, 4, 5, 6);\n+        move |_: i64| {\n+            let ((_a, .., _b, _c), .., _e, _f) = y;\n+        }\n+    }\n+}"}, {"sha": "2fa1bf2b7e6456600061a17f2a08315bfa4cf3d7", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 149, "deletions": 7, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -3,7 +3,8 @@\n use std::{fmt::Display, iter};\n \n use crate::{\n-    infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n+    db::HirDatabase, infer::PointerCast, ClosureId, Const, ConstScalar, InferenceResult, Interner,\n+    MemoryMap, Substitution, Ty, TyKind,\n };\n use chalk_ir::Mutability;\n use hir_def::{\n@@ -19,9 +20,11 @@ mod pretty;\n \n pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n-pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n+pub use lower::{\n+    lower_to_mir, mir_body_for_closure_query, mir_body_query, mir_body_recover, MirLowerError,\n+};\n use smallvec::{smallvec, SmallVec};\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n \n use super::consteval::{intern_const_scalar, try_const_usize};\n \n@@ -89,18 +92,76 @@ impl Operand {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(FieldId),\n-    TupleField(usize),\n+    // FIXME: get rid of this, and use FieldId for tuples and closures\n+    TupleOrClosureField(usize),\n     Index(V),\n     ConstantIndex { offset: u64, min_length: u64, from_end: bool },\n     Subslice { from: u64, to: u64, from_end: bool },\n     //Downcast(Option<Symbol>, VariantIdx),\n     OpaqueCast(T),\n }\n \n+impl<V, T> ProjectionElem<V, T> {\n+    pub fn projected_ty(\n+        &self,\n+        base: Ty,\n+        db: &dyn HirDatabase,\n+        closure_field: impl FnOnce(ClosureId, usize) -> Ty,\n+    ) -> Ty {\n+        match self {\n+            ProjectionElem::Deref => match &base.data(Interner).kind {\n+                TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n+                _ => {\n+                    never!(\"Overloaded deref is not a projection\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::Field(f) => match &base.data(Interner).kind {\n+                TyKind::Adt(_, subst) => {\n+                    db.field_types(f.parent)[f.local_id].clone().substitute(Interner, subst)\n+                }\n+                _ => {\n+                    never!(\"Only adt has field\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::TupleOrClosureField(f) => match &base.data(Interner).kind {\n+                TyKind::Tuple(_, subst) => subst\n+                    .as_slice(Interner)\n+                    .get(*f)\n+                    .map(|x| x.assert_ty_ref(Interner))\n+                    .cloned()\n+                    .unwrap_or_else(|| {\n+                        never!(\"Out of bound tuple field\");\n+                        TyKind::Error.intern(Interner)\n+                    }),\n+                TyKind::Closure(id, _) => closure_field(*id, *f),\n+                _ => {\n+                    never!(\"Only tuple or closure has tuple or closure field\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::Index(_) => match &base.data(Interner).kind {\n+                TyKind::Array(inner, _) | TyKind::Slice(inner) => inner.clone(),\n+                _ => {\n+                    never!(\"Overloaded index is not a projection\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::OpaqueCast(_) => {\n+                never!(\"We don't emit these yet\");\n+                return TyKind::Error.intern(Interner);\n+            }\n+        }\n+    }\n+}\n+\n type PlaceElem = ProjectionElem<LocalId, Ty>;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -123,7 +184,7 @@ pub enum AggregateKind {\n     Tuple(Ty),\n     Adt(VariantId, Substitution),\n     Union(UnionId, FieldId),\n-    //Closure(LocalDefId, SubstsRef),\n+    Closure(Ty),\n     //Generator(LocalDefId, SubstsRef, Movability),\n }\n \n@@ -418,7 +479,7 @@ pub enum Terminator {\n     },\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -847,6 +908,87 @@ pub struct MirBody {\n     pub arg_count: usize,\n     pub binding_locals: ArenaMap<BindingId, LocalId>,\n     pub param_locals: Vec<LocalId>,\n+    /// This field stores the closures directly owned by this body. It is used\n+    /// in traversing every mir body.\n+    pub closures: Vec<ClosureId>,\n+}\n+\n+impl MirBody {\n+    fn walk_places(&mut self, mut f: impl FnMut(&mut Place)) {\n+        fn for_operand(op: &mut Operand, f: &mut impl FnMut(&mut Place)) {\n+            match op {\n+                Operand::Copy(p) | Operand::Move(p) => {\n+                    f(p);\n+                }\n+                Operand::Constant(_) => (),\n+            }\n+        }\n+        for (_, block) in self.basic_blocks.iter_mut() {\n+            for statement in &mut block.statements {\n+                match &mut statement.kind {\n+                    StatementKind::Assign(p, r) => {\n+                        f(p);\n+                        match r {\n+                            Rvalue::ShallowInitBox(o, _)\n+                            | Rvalue::UnaryOp(_, o)\n+                            | Rvalue::Cast(_, o, _)\n+                            | Rvalue::Use(o) => for_operand(o, &mut f),\n+                            Rvalue::CopyForDeref(p)\n+                            | Rvalue::Discriminant(p)\n+                            | Rvalue::Len(p)\n+                            | Rvalue::Ref(_, p) => f(p),\n+                            Rvalue::CheckedBinaryOp(_, o1, o2) => {\n+                                for_operand(o1, &mut f);\n+                                for_operand(o2, &mut f);\n+                            }\n+                            Rvalue::Aggregate(_, ops) => {\n+                                for op in ops {\n+                                    for_operand(op, &mut f);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    StatementKind::Deinit(p) => f(p),\n+                    StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n+                }\n+            }\n+            match &mut block.terminator {\n+                Some(x) => match x {\n+                    Terminator::SwitchInt { discr, .. } => for_operand(discr, &mut f),\n+                    Terminator::FalseEdge { .. }\n+                    | Terminator::FalseUnwind { .. }\n+                    | Terminator::Goto { .. }\n+                    | Terminator::Resume\n+                    | Terminator::GeneratorDrop\n+                    | Terminator::Abort\n+                    | Terminator::Return\n+                    | Terminator::Unreachable => (),\n+                    Terminator::Drop { place, .. } => {\n+                        f(place);\n+                    }\n+                    Terminator::DropAndReplace { place, value, .. } => {\n+                        f(place);\n+                        for_operand(value, &mut f);\n+                    }\n+                    Terminator::Call { func, args, destination, .. } => {\n+                        for_operand(func, &mut f);\n+                        args.iter_mut().for_each(|x| for_operand(x, &mut f));\n+                        f(destination);\n+                    }\n+                    Terminator::Assert { cond, .. } => {\n+                        for_operand(cond, &mut f);\n+                    }\n+                    Terminator::Yield { value, resume_arg, .. } => {\n+                        for_operand(value, &mut f);\n+                        f(resume_arg);\n+                    }\n+                },\n+                None => (),\n+            }\n+        }\n+    }\n }\n \n fn const_as_usize(c: &Const) -> usize {"}, {"sha": "5b2bca955f5938e3e2b55a41e400e2caac671727", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -3,13 +3,13 @@\n // Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n // if needed for implementing a proper borrow checker.\n \n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use hir_def::DefWithBodyId;\n use la_arena::ArenaMap;\n use stdx::never;\n \n-use crate::db::HirDatabase;\n+use crate::{db::HirDatabase, ClosureId};\n \n use super::{\n     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n@@ -29,14 +29,48 @@ pub struct BorrowckResult {\n     pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n }\n \n+fn all_mir_bodies(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Box<dyn Iterator<Item = Result<Arc<MirBody>, MirLowerError>> + '_> {\n+    fn for_closure(\n+        db: &dyn HirDatabase,\n+        c: ClosureId,\n+    ) -> Box<dyn Iterator<Item = Result<Arc<MirBody>, MirLowerError>> + '_> {\n+        match db.mir_body_for_closure(c) {\n+            Ok(body) => {\n+                let closures = body.closures.clone();\n+                Box::new(\n+                    iter::once(Ok(body))\n+                        .chain(closures.into_iter().flat_map(|x| for_closure(db, x))),\n+                )\n+            }\n+            Err(e) => Box::new(iter::once(Err(e))),\n+        }\n+    }\n+    match db.mir_body(def) {\n+        Ok(body) => {\n+            let closures = body.closures.clone();\n+            Box::new(\n+                iter::once(Ok(body)).chain(closures.into_iter().flat_map(|x| for_closure(db, x))),\n+            )\n+        }\n+        Err(e) => Box::new(iter::once(Err(e))),\n+    }\n+}\n+\n pub fn borrowck_query(\n     db: &dyn HirDatabase,\n     def: DefWithBodyId,\n-) -> Result<Arc<BorrowckResult>, MirLowerError> {\n+) -> Result<Arc<[BorrowckResult]>, MirLowerError> {\n     let _p = profile::span(\"borrowck_query\");\n-    let body = db.mir_body(def)?;\n-    let r = BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body };\n-    Ok(Arc::new(r))\n+    let r = all_mir_bodies(db, def)\n+        .map(|body| {\n+            let body = body?;\n+            Ok(BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body })\n+        })\n+        .collect::<Result<Vec<_>, MirLowerError>>()?;\n+    Ok(r.into())\n }\n \n fn is_place_direct(lvalue: &Place) -> bool {\n@@ -60,7 +94,7 @@ fn place_case(lvalue: &Place) -> ProjectionCase {\n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(_)\n-            | ProjectionElem::TupleField(_)\n+            | ProjectionElem::TupleOrClosureField(_)\n             | ProjectionElem::Index(_) => {\n                 is_part_of = true;\n             }"}, {"sha": "8c911b7f7b77841dd33048f602738df4fe9ff10b", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 90, "deletions": 82, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -25,8 +25,8 @@ use crate::{\n     mapping::from_chalk,\n     method_resolution::{is_dyn_method, lookup_impl_method},\n     traits::FnTrait,\n-    CallableDefId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyExt,\n+    CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n+    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n@@ -92,6 +92,7 @@ pub struct Evaluator<'a> {\n enum Address {\n     Stack(usize),\n     Heap(usize),\n+    Invalid(usize),\n }\n \n use Address::*;\n@@ -169,8 +170,10 @@ impl Address {\n     fn from_usize(x: usize) -> Self {\n         if x > usize::MAX / 2 {\n             Stack(x - usize::MAX / 2)\n+        } else if x > usize::MAX / 4 {\n+            Heap(x - usize::MAX / 4)\n         } else {\n-            Heap(x)\n+            Invalid(x)\n         }\n     }\n \n@@ -181,7 +184,8 @@ impl Address {\n     fn to_usize(&self) -> usize {\n         let as_num = match self {\n             Stack(x) => *x + usize::MAX / 2,\n-            Heap(x) => *x,\n+            Heap(x) => *x + usize::MAX / 4,\n+            Invalid(x) => *x,\n         };\n         as_num\n     }\n@@ -190,6 +194,7 @@ impl Address {\n         match self {\n             Stack(x) => Stack(f(*x)),\n             Heap(x) => Heap(f(*x)),\n+            Invalid(x) => Invalid(f(*x)),\n         }\n     }\n \n@@ -209,6 +214,7 @@ pub enum MirEvalError {\n     UndefinedBehavior(&'static str),\n     Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n+    MirLowerErrorForClosure(ClosureId, MirLowerError),\n     TypeIsUnsized(Ty, &'static str),\n     NotSupported(String),\n     InvalidConst(Const),\n@@ -238,6 +244,9 @@ impl std::fmt::Debug for MirEvalError {\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n+            Self::MirLowerErrorForClosure(arg0, arg1) => {\n+                f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n+            }\n             Self::InvalidVTableId(arg0) => f.debug_tuple(\"InvalidVTableId\").field(arg0).finish(),\n             Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n             Self::InvalidConst(arg0) => {\n@@ -355,16 +364,15 @@ impl Evaluator<'_> {\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n         let mut metadata = None; // locals are always sized\n         for proj in &p.projection {\n+            let prev_ty = ty.clone();\n+            ty = proj.projected_ty(ty, self.db, |c, f| {\n+                let (def, _) = self.db.lookup_intern_closure(c.into());\n+                let infer = self.db.infer(def);\n+                let (captures, _) = infer.closure_info(&c);\n+                captures.get(f).expect(\"broken closure field\").ty.clone()\n+            });\n             match proj {\n                 ProjectionElem::Deref => {\n-                    ty = match &ty.data(Interner).kind {\n-                        TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n-                        _ => {\n-                            return Err(MirEvalError::TypeError(\n-                                \"Overloaded deref in MIR is disallowed\",\n-                            ))\n-                        }\n-                    };\n                     metadata = if self.size_of(&ty, locals)?.is_none() {\n                         Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n                     } else {\n@@ -377,78 +385,41 @@ impl Evaluator<'_> {\n                     let offset =\n                         from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n                     metadata = None; // Result of index is always sized\n-                    match &ty.data(Interner).kind {\n-                        TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n-                            TyKind::Slice(inner) => {\n-                                ty = inner.clone();\n-                                let ty_size = self.size_of_sized(\n-                                    &ty,\n-                                    locals,\n-                                    \"slice inner type should be sized\",\n-                                )?;\n-                                let value = self.read_memory(addr, self.ptr_size() * 2)?;\n-                                addr = Address::from_bytes(&value[0..8])?.offset(ty_size * offset);\n-                            }\n-                            x => not_supported!(\"MIR index for ref type {x:?}\"),\n-                        },\n-                        TyKind::Array(inner, _) | TyKind::Slice(inner) => {\n-                            ty = inner.clone();\n-                            let ty_size = self.size_of_sized(\n-                                &ty,\n-                                locals,\n-                                \"array inner type should be sized\",\n-                            )?;\n-                            addr = addr.offset(ty_size * offset);\n+                    let ty_size =\n+                        self.size_of_sized(&ty, locals, \"array inner type should be sized\")?;\n+                    addr = addr.offset(ty_size * offset);\n+                }\n+                &ProjectionElem::TupleOrClosureField(f) => {\n+                    let layout = self.layout(&prev_ty)?;\n+                    let offset = layout.fields.offset(f).bytes_usize();\n+                    addr = addr.offset(offset);\n+                    metadata = None; // tuple field is always sized\n+                }\n+                ProjectionElem::Field(f) => {\n+                    let layout = self.layout(&prev_ty)?;\n+                    let variant_layout = match &layout.variants {\n+                        Variants::Single { .. } => &layout,\n+                        Variants::Multiple { variants, .. } => {\n+                            &variants[match f.parent {\n+                                hir_def::VariantId::EnumVariantId(x) => {\n+                                    RustcEnumVariantIdx(x.local_id)\n+                                }\n+                                _ => {\n+                                    return Err(MirEvalError::TypeError(\n+                                        \"Multivariant layout only happens for enums\",\n+                                    ))\n+                                }\n+                            }]\n                         }\n-                        x => not_supported!(\"MIR index for type {x:?}\"),\n-                    }\n+                    };\n+                    let offset = variant_layout\n+                        .fields\n+                        .offset(u32::from(f.local_id.into_raw()) as usize)\n+                        .bytes_usize();\n+                    addr = addr.offset(offset);\n+                    // FIXME: support structs with unsized fields\n+                    metadata = None;\n                 }\n-                &ProjectionElem::TupleField(f) => match &ty.data(Interner).kind {\n-                    TyKind::Tuple(_, subst) => {\n-                        let layout = self.layout(&ty)?;\n-                        ty = subst\n-                            .as_slice(Interner)\n-                            .get(f)\n-                            .ok_or(MirEvalError::TypeError(\"not enough tuple fields\"))?\n-                            .assert_ty_ref(Interner)\n-                            .clone();\n-                        let offset = layout.fields.offset(f).bytes_usize();\n-                        addr = addr.offset(offset);\n-                        metadata = None; // tuple field is always sized\n-                    }\n-                    _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n-                },\n-                ProjectionElem::Field(f) => match &ty.data(Interner).kind {\n-                    TyKind::Adt(adt, subst) => {\n-                        let layout = self.layout_adt(adt.0, subst.clone())?;\n-                        let variant_layout = match &layout.variants {\n-                            Variants::Single { .. } => &layout,\n-                            Variants::Multiple { variants, .. } => {\n-                                &variants[match f.parent {\n-                                    hir_def::VariantId::EnumVariantId(x) => {\n-                                        RustcEnumVariantIdx(x.local_id)\n-                                    }\n-                                    _ => {\n-                                        return Err(MirEvalError::TypeError(\n-                                            \"Multivariant layout only happens for enums\",\n-                                        ))\n-                                    }\n-                                }]\n-                            }\n-                        };\n-                        ty = self.db.field_types(f.parent)[f.local_id]\n-                            .clone()\n-                            .substitute(Interner, subst);\n-                        let offset = variant_layout\n-                            .fields\n-                            .offset(u32::from(f.local_id.into_raw()) as usize)\n-                            .bytes_usize();\n-                        addr = addr.offset(offset);\n-                        // FIXME: support structs with unsized fields\n-                        metadata = None;\n-                    }\n-                    _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n-                },\n                 ProjectionElem::ConstantIndex { .. } => {\n                     not_supported!(\"constant index\")\n                 }\n@@ -845,6 +816,15 @@ impl Evaluator<'_> {\n                             values.iter().copied(),\n                         )?)\n                     }\n+                    AggregateKind::Closure(ty) => {\n+                        let layout = self.layout(&ty)?;\n+                        Owned(self.make_by_layout(\n+                            layout.size.bytes_usize(),\n+                            &layout,\n+                            None,\n+                            values.iter().copied(),\n+                        )?)\n+                    }\n                 }\n             }\n             Rvalue::Cast(kind, operand, target_ty) => match kind {\n@@ -1065,6 +1045,9 @@ impl Evaluator<'_> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&self.stack, x),\n             Heap(x) => (&self.heap, x),\n+            Invalid(_) => {\n+                return Err(MirEvalError::UndefinedBehavior(\"read invalid memory address\"))\n+            }\n         };\n         mem.get(pos..pos + size).ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory read\"))\n     }\n@@ -1073,6 +1056,9 @@ impl Evaluator<'_> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&mut self.stack, x),\n             Heap(x) => (&mut self.heap, x),\n+            Invalid(_) => {\n+                return Err(MirEvalError::UndefinedBehavior(\"write invalid memory address\"))\n+            }\n         };\n         mem.get_mut(pos..pos + r.len())\n             .ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory write\"))?\n@@ -1394,6 +1380,25 @@ impl Evaluator<'_> {\n         Ok(())\n     }\n \n+    fn exec_closure(\n+        &mut self,\n+        closure: ClosureId,\n+        closure_data: Interval,\n+        generic_args: &Substitution,\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n+    ) -> Result<()> {\n+        let mir_body = self\n+            .db\n+            .mir_body_for_closure(closure)\n+            .map_err(|x| MirEvalError::MirLowerErrorForClosure(closure, x))?;\n+        let arg_bytes = iter::once(Ok(closure_data.get(self)?.to_owned()))\n+            .chain(args.iter().map(|x| Ok(x.get(&self)?.to_owned())))\n+            .collect::<Result<Vec<_>>>()?;\n+        let bytes = self.interpret_mir(&mir_body, arg_bytes.into_iter(), generic_args.clone())?;\n+        destination.write_from_bytes(self, &bytes)\n+    }\n+\n     fn exec_fn_def(\n         &mut self,\n         def: FnDefId,\n@@ -1546,6 +1551,9 @@ impl Evaluator<'_> {\n             TyKind::Function(_) => {\n                 self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n             }\n+            TyKind::Closure(closure, subst) => {\n+                self.exec_closure(*closure, func_data, subst, destination, &args[1..])?;\n+            }\n             x => not_supported!(\"Call FnTrait methods with type {x:?}\"),\n         }\n         Ok(())"}, {"sha": "78a2d90f7fb016673d1306fd751c298fc4ef9a10", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 277, "deletions": 90, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -21,9 +21,16 @@ use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n-    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n-    utils::generics, Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    consteval::ConstEvalError,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    infer::{CaptureKind, CapturedItem, TypeMismatch},\n+    inhabitedness::is_ty_uninhabited_from,\n+    layout::layout_of_ty,\n+    mapping::ToChalk,\n+    static_lifetime,\n+    utils::generics,\n+    Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n@@ -74,10 +81,12 @@ pub enum MirLowerError {\n     BreakWithoutLoop,\n     Loop,\n     /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n-    ImplementationError(&'static str),\n+    ImplementationError(String),\n     LangItemNotFound(LangItem),\n     MutatingRvalue,\n     UnresolvedLabel,\n+    UnresolvedUpvar(Place),\n+    UnaccessableLocal,\n }\n \n macro_rules! not_supported {\n@@ -88,8 +97,8 @@ macro_rules! not_supported {\n \n macro_rules! implementation_error {\n     ($x: expr) => {{\n-        ::stdx::never!(\"MIR lower implementation bug: {}\", $x);\n-        return Err(MirLowerError::ImplementationError($x));\n+        ::stdx::never!(\"MIR lower implementation bug: {}\", format!($x));\n+        return Err(MirLowerError::ImplementationError(format!($x)));\n     }};\n }\n \n@@ -116,7 +125,44 @@ impl MirLowerError {\n \n type Result<T> = std::result::Result<T, MirLowerError>;\n \n-impl MirLowerCtx<'_> {\n+impl<'ctx> MirLowerCtx<'ctx> {\n+    fn new(\n+        db: &'ctx dyn HirDatabase,\n+        owner: DefWithBodyId,\n+        body: &'ctx Body,\n+        infer: &'ctx InferenceResult,\n+    ) -> Self {\n+        let mut basic_blocks = Arena::new();\n+        let start_block = basic_blocks.alloc(BasicBlock {\n+            statements: vec![],\n+            terminator: None,\n+            is_cleanup: false,\n+        });\n+        let locals = Arena::new();\n+        let binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+        let mir = MirBody {\n+            basic_blocks,\n+            locals,\n+            start_block,\n+            binding_locals,\n+            param_locals: vec![],\n+            owner,\n+            arg_count: body.params.len(),\n+            closures: vec![],\n+        };\n+        let ctx = MirLowerCtx {\n+            result: mir,\n+            db,\n+            infer,\n+            body,\n+            owner,\n+            current_loop_blocks: None,\n+            labeled_loop_blocks: Default::default(),\n+            discr_temp: None,\n+        };\n+        ctx\n+    }\n+\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n             implementation_error!(\"unsized temporaries\");\n@@ -268,7 +314,7 @@ impl MirLowerCtx<'_> {\n                         self.push_assignment(\n                             current,\n                             place,\n-                            Operand::Copy(self.result.binding_locals[pat_id].into()).into(),\n+                            Operand::Copy(self.binding_local(pat_id)?.into()).into(),\n                             expr_id.into(),\n                         );\n                         Ok(Some(current))\n@@ -823,7 +869,51 @@ impl MirLowerCtx<'_> {\n                 );\n                 Ok(Some(current))\n             },\n-            Expr::Closure { .. } => not_supported!(\"closure\"),\n+            Expr::Closure { .. } => {\n+                let ty = self.expr_ty(expr_id);\n+                let TyKind::Closure(id, _) = ty.kind(Interner) else {\n+                    not_supported!(\"closure with non closure type\");\n+                };\n+                self.result.closures.push(*id);\n+                let (captures, _) = self.infer.closure_info(id);\n+                let mut operands = vec![];\n+                for capture in captures.iter() {\n+                    let p = Place {\n+                        local: self.binding_local(capture.place.local)?,\n+                        projection: capture.place.projections.clone().into_iter().map(|x| {\n+                            match x {\n+                                ProjectionElem::Deref => ProjectionElem::Deref,\n+                                ProjectionElem::Field(x) => ProjectionElem::Field(x),\n+                                ProjectionElem::TupleOrClosureField(x) => ProjectionElem::TupleOrClosureField(x),\n+                                ProjectionElem::ConstantIndex { offset, min_length, from_end } => ProjectionElem::ConstantIndex { offset, min_length, from_end },\n+                                ProjectionElem::Subslice { from, to, from_end } => ProjectionElem::Subslice { from, to, from_end },\n+                                ProjectionElem::OpaqueCast(x) => ProjectionElem::OpaqueCast(x),\n+                                ProjectionElem::Index(x) => match x { },\n+                            }\n+                        }).collect(),\n+                    };\n+                    match &capture.kind {\n+                        CaptureKind::ByRef(bk) => {\n+                            let tmp: Place = self.temp(capture.ty.clone())?.into();\n+                            self.push_assignment(\n+                                current,\n+                                tmp.clone(),\n+                                Rvalue::Ref(bk.clone(), p),\n+                                expr_id.into(),\n+                            );\n+                            operands.push(Operand::Move(tmp));\n+                        },\n+                        CaptureKind::ByValue => operands.push(Operand::Move(p)),\n+                    }\n+                }\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::Aggregate(AggregateKind::Closure(ty), operands),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            },\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n                 let Some(values) = exprs\n                         .iter()\n@@ -893,7 +983,7 @@ impl MirLowerCtx<'_> {\n                 let index = name\n                     .as_tuple_index()\n                     .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n-                place.projection.push(ProjectionElem::TupleField(index))\n+                place.projection.push(ProjectionElem::TupleOrClosureField(index))\n             } else {\n                 let field =\n                     self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n@@ -1126,8 +1216,9 @@ impl MirLowerCtx<'_> {\n         };\n         self.set_goto(prev_block, begin);\n         f(self, begin)?;\n-        let my = mem::replace(&mut self.current_loop_blocks, prev)\n-            .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        let my = mem::replace(&mut self.current_loop_blocks, prev).ok_or(\n+            MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\".to_string()),\n+        )?;\n         if let Some(prev) = prev_label {\n             self.labeled_loop_blocks.insert(label.unwrap(), prev);\n         }\n@@ -1159,15 +1250,19 @@ impl MirLowerCtx<'_> {\n         let r = match self\n             .current_loop_blocks\n             .as_mut()\n-            .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+            .ok_or(MirLowerError::ImplementationError(\n+                \"Current loop access out of loop\".to_string(),\n+            ))?\n             .end\n         {\n             Some(x) => x,\n             None => {\n                 let s = self.new_basic_block();\n                 self.current_loop_blocks\n                     .as_mut()\n-                    .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+                    .ok_or(MirLowerError::ImplementationError(\n+                        \"Current loop access out of loop\".to_string(),\n+                    ))?\n                     .end = Some(s);\n                 s\n             }\n@@ -1181,7 +1276,7 @@ impl MirLowerCtx<'_> {\n \n     /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n     /// the appropriated places.\n-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) {\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1206,9 +1301,10 @@ impl MirLowerCtx<'_> {\n             .copied()\n             .map(MirSpan::PatId)\n             .unwrap_or(MirSpan::Unknown);\n-        let l = self.result.binding_locals[b];\n+        let l = self.binding_local(b)?;\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n+        Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n@@ -1256,9 +1352,15 @@ impl MirLowerCtx<'_> {\n                             }\n                         }\n                     } else {\n+                        let mut err = None;\n                         self.body.walk_bindings_in_pat(*pat, |b| {\n-                            self.push_storage_live(b, current);\n+                            if let Err(e) = self.push_storage_live(b, current) {\n+                                err = Some(e);\n+                            }\n                         });\n+                        if let Some(e) = err {\n+                            return Err(e);\n+                        }\n                     }\n                 }\n                 hir_def::hir::Statement::Expr { expr, has_semi: _ } => {\n@@ -1274,6 +1376,67 @@ impl MirLowerCtx<'_> {\n             None => Ok(Some(current)),\n         }\n     }\n+\n+    fn lower_params_and_bindings(\n+        &mut self,\n+        params: impl Iterator<Item = (PatId, Ty)> + Clone,\n+        pick_binding: impl Fn(BindingId) -> bool,\n+    ) -> Result<BasicBlockId> {\n+        let base_param_count = self.result.param_locals.len();\n+        self.result.param_locals.extend(params.clone().map(|(x, ty)| {\n+            let local_id = self.result.locals.alloc(Local { ty });\n+            if let Pat::Bind { id, subpat: None } = self.body[x] {\n+                if matches!(\n+                    self.body.bindings[id].mode,\n+                    BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n+                ) {\n+                    self.result.binding_locals.insert(id, local_id);\n+                }\n+            }\n+            local_id\n+        }));\n+        // and then rest of bindings\n+        for (id, _) in self.body.bindings.iter() {\n+            if !pick_binding(id) {\n+                continue;\n+            }\n+            if !self.result.binding_locals.contains_idx(id) {\n+                self.result\n+                    .binding_locals\n+                    .insert(id, self.result.locals.alloc(Local { ty: self.infer[id].clone() }));\n+            }\n+        }\n+        let mut current = self.result.start_block;\n+        for ((param, _), local) in\n+            params.zip(self.result.param_locals.clone().into_iter().skip(base_param_count))\n+        {\n+            if let Pat::Bind { id, .. } = self.body[param] {\n+                if local == self.binding_local(id)? {\n+                    continue;\n+                }\n+            }\n+            let r = self.pattern_match(\n+                current,\n+                None,\n+                local.into(),\n+                self.result.locals[local].ty.clone(),\n+                param,\n+                BindingAnnotation::Unannotated,\n+            )?;\n+            if let Some(b) = r.1 {\n+                self.set_terminator(b, Terminator::Unreachable);\n+            }\n+            current = r.0;\n+        }\n+        Ok(current)\n+    }\n+\n+    fn binding_local(&self, b: BindingId) -> Result<LocalId> {\n+        match self.result.binding_locals.get(b) {\n+            Some(x) => Ok(*x),\n+            None => Err(MirLowerError::UnaccessableLocal),\n+        }\n+    }\n }\n \n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n@@ -1297,6 +1460,87 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n     })\n }\n \n+pub fn mir_body_for_closure_query(\n+    db: &dyn HirDatabase,\n+    closure: ClosureId,\n+) -> Result<Arc<MirBody>> {\n+    let (owner, expr) = db.lookup_intern_closure(closure.into());\n+    let body = db.body(owner);\n+    let infer = db.infer(owner);\n+    let Expr::Closure { args, body: root, .. } = &body[expr] else {\n+        implementation_error!(\"closure expression is not closure\");\n+    };\n+    let TyKind::Closure(_, substs) = &infer[expr].kind(Interner) else {\n+        implementation_error!(\"closure expression is not closure\");\n+    };\n+    let (captures, _) = infer.closure_info(&closure);\n+    let mut ctx = MirLowerCtx::new(db, owner, &body, &infer);\n+    ctx.result.arg_count = args.len() + 1;\n+    // 0 is return local\n+    ctx.result.locals.alloc(Local { ty: infer[*root].clone() });\n+    ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n+    let Some(sig) = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db) else {\n+        implementation_error!(\"closure has not callable sig\");\n+    };\n+    let current = ctx.lower_params_and_bindings(\n+        args.iter().zip(sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n+        |_| true,\n+    )?;\n+    if let Some(b) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n+        ctx.set_terminator(b, Terminator::Return);\n+    }\n+    let mut upvar_map: FxHashMap<LocalId, Vec<(&CapturedItem, usize)>> = FxHashMap::default();\n+    for (i, capture) in captures.iter().enumerate() {\n+        let local = ctx.binding_local(capture.place.local)?;\n+        upvar_map.entry(local).or_default().push((capture, i));\n+    }\n+    let mut err = None;\n+    let closure_local = ctx.result.locals.iter().nth(1).unwrap().0;\n+    ctx.result.walk_places(|p| {\n+        if let Some(x) = upvar_map.get(&p.local) {\n+            let r = x.iter().find(|x| {\n+                if p.projection.len() < x.0.place.projections.len() {\n+                    return false;\n+                }\n+                for (x, y) in p.projection.iter().zip(x.0.place.projections.iter()) {\n+                    match (x, y) {\n+                        (ProjectionElem::Deref, ProjectionElem::Deref) => (),\n+                        (ProjectionElem::Field(x), ProjectionElem::Field(y)) if x == y => (),\n+                        (\n+                            ProjectionElem::TupleOrClosureField(x),\n+                            ProjectionElem::TupleOrClosureField(y),\n+                        ) if x == y => (),\n+                        _ => return false,\n+                    }\n+                }\n+                true\n+            });\n+            match r {\n+                Some(x) => {\n+                    p.local = closure_local;\n+                    let prev_projs =\n+                        mem::replace(&mut p.projection, vec![PlaceElem::TupleOrClosureField(x.1)]);\n+                    if x.0.kind != CaptureKind::ByValue {\n+                        p.projection.push(ProjectionElem::Deref);\n+                    }\n+                    p.projection.extend(prev_projs.into_iter().skip(x.0.place.projections.len()));\n+                }\n+                None => err = Some(p.clone()),\n+            }\n+        }\n+    });\n+    ctx.result.binding_locals = ctx\n+        .result\n+        .binding_locals\n+        .into_iter()\n+        .filter(|x| ctx.body[x.0].owner == Some(expr))\n+        .collect();\n+    if let Some(err) = err {\n+        return Err(MirLowerError::UnresolvedUpvar(err));\n+    }\n+    Ok(Arc::new(ctx.result))\n+}\n+\n pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n     let _p = profile::span(\"mir_body_query\").detail(|| match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n@@ -1334,86 +1578,29 @@ pub fn lower_to_mir(\n     if let Some((_, x)) = infer.type_mismatches().next() {\n         return Err(MirLowerError::TypeMismatch(x.clone()));\n     }\n-    let mut basic_blocks = Arena::new();\n-    let start_block =\n-        basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n-    let mut locals = Arena::new();\n+    let mut ctx = MirLowerCtx::new(db, owner, body, infer);\n     // 0 is return local\n-    locals.alloc(Local { ty: infer[root_expr].clone() });\n-    let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+    ctx.result.locals.alloc(Local { ty: infer[root_expr].clone() });\n+    let binding_picker = |b: BindingId| {\n+        if root_expr == body.body_expr {\n+            body[b].owner.is_none()\n+        } else {\n+            body[b].owner == Some(root_expr)\n+        }\n+    };\n     // 1 to param_len is for params\n-    let param_locals: Vec<LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+    let current = if let DefWithBodyId::FunctionId(fid) = owner {\n         let substs = TyBuilder::placeholder_subst(db, fid);\n         let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n-        body.params\n-            .iter()\n-            .zip(callable_sig.params().iter())\n-            .map(|(&x, ty)| {\n-                let local_id = locals.alloc(Local { ty: ty.clone() });\n-                if let Pat::Bind { id, subpat: None } = body[x] {\n-                    if matches!(\n-                        body.bindings[id].mode,\n-                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n-                    ) {\n-                        binding_locals.insert(id, local_id);\n-                    }\n-                }\n-                local_id\n-            })\n-            .collect()\n+        ctx.lower_params_and_bindings(\n+            body.params.iter().zip(callable_sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n+            binding_picker,\n+        )?\n     } else {\n-        if !body.params.is_empty() {\n-            return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n-        }\n-        vec![]\n+        ctx.lower_params_and_bindings([].into_iter(), binding_picker)?\n     };\n-    // and then rest of bindings\n-    for (id, _) in body.bindings.iter() {\n-        if !binding_locals.contains_idx(id) {\n-            binding_locals.insert(id, locals.alloc(Local { ty: infer[id].clone() }));\n-        }\n-    }\n-    let mir = MirBody {\n-        basic_blocks,\n-        locals,\n-        start_block,\n-        binding_locals,\n-        param_locals,\n-        owner,\n-        arg_count: body.params.len(),\n-    };\n-    let mut ctx = MirLowerCtx {\n-        result: mir,\n-        db,\n-        infer,\n-        body,\n-        owner,\n-        current_loop_blocks: None,\n-        labeled_loop_blocks: Default::default(),\n-        discr_temp: None,\n-    };\n-    let mut current = start_block;\n-    for (&param, local) in body.params.iter().zip(ctx.result.param_locals.clone().into_iter()) {\n-        if let Pat::Bind { id, .. } = body[param] {\n-            if local == ctx.result.binding_locals[id] {\n-                continue;\n-            }\n-        }\n-        let r = ctx.pattern_match(\n-            current,\n-            None,\n-            local.into(),\n-            ctx.result.locals[local].ty.clone(),\n-            param,\n-            BindingAnnotation::Unannotated,\n-        )?;\n-        if let Some(b) = r.1 {\n-            ctx.set_terminator(b, Terminator::Unreachable);\n-        }\n-        current = r.0;\n-    }\n     if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n-        ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+        ctx.set_terminator(b, Terminator::Return);\n     }\n     Ok(ctx.result)\n }"}, {"sha": "12a77715e9c676adeb1affd7b90f20652c63c50c", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1,5 +1,7 @@\n //! MIR lowering for patterns\n \n+use crate::utils::pattern_matching_dereference_count;\n+\n use super::*;\n \n macro_rules! not_supported {\n@@ -52,7 +54,7 @@ impl MirLowerCtx<'_> {\n                     args,\n                     *ellipsis,\n                     subst.iter(Interner).enumerate().map(|(i, x)| {\n-                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n+                        (PlaceElem::TupleOrClosureField(i), x.assert_ty_ref(Interner).clone())\n                     }),\n                     &cond_place,\n                     binding_mode,\n@@ -142,7 +144,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n-                self.push_storage_live(*id, current);\n+                self.push_storage_live(*id, current)?;\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -387,13 +389,6 @@ fn pattern_matching_dereference(\n     binding_mode: &mut BindingAnnotation,\n     cond_place: &mut Place,\n ) {\n-    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n-        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n-            *binding_mode = BindingAnnotation::RefMut;\n-        } else {\n-            *binding_mode = BindingAnnotation::Ref;\n-        }\n-        *cond_ty = ty.clone();\n-        cond_place.projection.push(ProjectionElem::Deref);\n-    }\n+    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n+    cond_place.projection.extend((0..cnt).map(|_| ProjectionElem::Deref));\n }"}, {"sha": "3e1f2ecef1b5bc3658a0eeecab4884bf9a03090e", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1,6 +1,9 @@\n //! A pretty-printer for MIR.\n \n-use std::fmt::{Debug, Display, Write};\n+use std::{\n+    fmt::{Debug, Display, Write},\n+    mem,\n+};\n \n use hir_def::{body::Body, hir::BindingId};\n use hir_expand::name::Name;\n@@ -20,7 +23,7 @@ impl MirBody {\n     pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n         let hir_body = db.body(self.owner);\n         let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n-        ctx.for_body();\n+        ctx.for_body(ctx.body.owner);\n         ctx.result\n     }\n \n@@ -42,7 +45,7 @@ struct MirPrettyCtx<'a> {\n     hir_body: &'a Body,\n     db: &'a dyn HirDatabase,\n     result: String,\n-    ident: String,\n+    indent: String,\n     local_to_binding: ArenaMap<LocalId, BindingId>,\n }\n \n@@ -88,22 +91,43 @@ impl Display for LocalName {\n }\n \n impl<'a> MirPrettyCtx<'a> {\n-    fn for_body(&mut self) {\n-        wln!(self, \"// {:?}\", self.body.owner);\n+    fn for_body(&mut self, name: impl Debug) {\n+        wln!(self, \"// {:?}\", name);\n         self.with_block(|this| {\n             this.locals();\n             wln!(this);\n             this.blocks();\n         });\n+        for &closure in &self.body.closures {\n+            let body = match self.db.mir_body_for_closure(closure) {\n+                Ok(x) => x,\n+                Err(e) => {\n+                    wln!(self, \"// error in {closure:?}: {e:?}\");\n+                    continue;\n+                }\n+            };\n+            let result = mem::take(&mut self.result);\n+            let indent = mem::take(&mut self.indent);\n+            let mut ctx = MirPrettyCtx {\n+                body: &body,\n+                local_to_binding: body.binding_locals.iter().map(|(x, y)| (*y, x)).collect(),\n+                result,\n+                indent,\n+                ..*self\n+            };\n+            ctx.for_body(closure);\n+            self.result = ctx.result;\n+            self.indent = ctx.indent;\n+        }\n     }\n \n     fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n-        self.ident += \"    \";\n+        self.indent += \"    \";\n         wln!(self, \"{{\");\n         f(self);\n         for _ in 0..4 {\n             self.result.pop();\n-            self.ident.pop();\n+            self.indent.pop();\n         }\n         wln!(self, \"}}\");\n     }\n@@ -114,15 +138,15 @@ impl<'a> MirPrettyCtx<'a> {\n             body,\n             db,\n             result: String::new(),\n-            ident: String::new(),\n+            indent: String::new(),\n             local_to_binding,\n             hir_body,\n         }\n     }\n \n     fn write_line(&mut self) {\n         self.result.push('\\n');\n-        self.result += &self.ident;\n+        self.result += &self.indent;\n     }\n \n     fn write(&mut self, line: &str) {\n@@ -247,7 +271,7 @@ impl<'a> MirPrettyCtx<'a> {\n                         }\n                     }\n                 }\n-                ProjectionElem::TupleField(x) => {\n+                ProjectionElem::TupleOrClosureField(x) => {\n                     f(this, local, head);\n                     w!(this, \".{}\", x);\n                 }\n@@ -302,6 +326,11 @@ impl<'a> MirPrettyCtx<'a> {\n                 self.operand_list(x);\n                 w!(self, \")\");\n             }\n+            Rvalue::Aggregate(AggregateKind::Closure(_), x) => {\n+                w!(self, \"Closure(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n             Rvalue::Aggregate(AggregateKind::Union(_, _), x) => {\n                 w!(self, \"Union(\");\n                 self.operand_list(x);"}, {"sha": "16e5ef85d09d5b6a1d32f19de271ae0745bc968b", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -575,7 +575,7 @@ fn two_closures_lub() {\n fn foo(c: i32) {\n     let add = |a: i32, b: i32| a + b;\n     let sub = |a, b| a - b;\n-            //^^^^^^^^^^^^ |i32, i32| -> i32\n+            //^^^^^^^^^^^^ impl Fn(i32, i32) -> i32\n     if c > 42 { add } else { sub };\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn(i32, i32) -> i32\n }\n@@ -875,6 +875,16 @@ fn test() {\n fn adjust_index() {\n     check_no_mismatches(\n         r\"\n+//- minicore: index, slice, coerce_unsized\n+fn test() {\n+    let x = [1, 2, 3];\n+    x[2] = 6;\n+ // ^ adjustments: Borrow(Ref(Mut))\n+}\n+    \",\n+    );\n+    check_no_mismatches(\n+        r\"\n //- minicore: index\n struct Struct;\n impl core::ops::Index<usize> for Struct {"}, {"sha": "d45edf730ad5fd3e2f1e945a2c566c6bb4fe65b2", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -198,7 +198,7 @@ fn expr_macro_def_expanded_in_various_places() {\n             100..119 'for _ ...!() {}': ()\n             104..105 '_': {unknown}\n             117..119 '{}': ()\n-            124..134 '|| spam!()': || -> isize\n+            124..134 '|| spam!()': impl Fn() -> isize\n             140..156 'while ...!() {}': ()\n             154..156 '{}': ()\n             161..174 'break spam!()': !\n@@ -279,7 +279,7 @@ fn expr_macro_rules_expanded_in_various_places() {\n             114..133 'for _ ...!() {}': ()\n             118..119 '_': {unknown}\n             131..133 '{}': ()\n-            138..148 '|| spam!()': || -> isize\n+            138..148 '|| spam!()': impl Fn() -> isize\n             154..170 'while ...!() {}': ()\n             168..170 '{}': ()\n             175..188 'break spam!()': !"}, {"sha": "c8c31bdea5cbfaa2c2d29c840ebb06eb1bc623de", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -70,8 +70,8 @@ fn infer_pattern() {\n             228..233 '&true': &bool\n             229..233 'true': bool\n             234..236 '{}': ()\n-            246..252 'lambda': |u64, u64, i32| -> i32\n-            255..287 '|a: u6...b; c }': |u64, u64, i32| -> i32\n+            246..252 'lambda': impl Fn(u64, u64, i32) -> i32\n+            255..287 '|a: u6...b; c }': impl Fn(u64, u64, i32) -> i32\n             256..257 'a': u64\n             264..265 'b': u64\n             267..268 'c': i32\n@@ -677,25 +677,25 @@ fn test() {\n             51..58 'loop {}': !\n             56..58 '{}': ()\n             72..171 '{     ... x); }': ()\n-            78..81 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n+            78..81 'foo': fn foo<&(i32, &str), i32, impl Fn(&(i32, &str)) -> i32>(&(i32, &str), impl Fn(&(i32, &str)) -> i32) -> i32\n             78..105 'foo(&(...y)| x)': i32\n             82..91 '&(1, \"a\")': &(i32, &str)\n             83..91 '(1, \"a\")': (i32, &str)\n             84..85 '1': i32\n             87..90 '\"a\"': &str\n-            93..104 '|&(x, y)| x': |&(i32, &str)| -> i32\n+            93..104 '|&(x, y)| x': impl Fn(&(i32, &str)) -> i32\n             94..101 '&(x, y)': &(i32, &str)\n             95..101 '(x, y)': (i32, &str)\n             96..97 'x': i32\n             99..100 'y': &str\n             103..104 'x': i32\n-            142..145 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n+            142..145 'foo': fn foo<&(i32, &str), &i32, impl Fn(&(i32, &str)) -> &i32>(&(i32, &str), impl Fn(&(i32, &str)) -> &i32) -> &i32\n             142..168 'foo(&(...y)| x)': &i32\n             146..155 '&(1, \"a\")': &(i32, &str)\n             147..155 '(1, \"a\")': (i32, &str)\n             148..149 '1': i32\n             151..154 '\"a\"': &str\n-            157..167 '|(x, y)| x': |&(i32, &str)| -> &i32\n+            157..167 '|(x, y)| x': impl Fn(&(i32, &str)) -> &i32\n             158..164 '(x, y)': (i32, &str)\n             159..160 'x': &i32\n             162..163 'y': &&str"}, {"sha": "d78d6eba7fb372806172da98afa0994b8200da72", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -805,19 +805,19 @@ fn issue_4966() {\n             225..229 'iter': T\n             244..246 '{}': Vec<A>\n             258..402 '{     ...r(); }': ()\n-            268..273 'inner': Map<|&f64| -> f64>\n-            276..300 'Map { ... 0.0 }': Map<|&f64| -> f64>\n-            285..298 '|_: &f64| 0.0': |&f64| -> f64\n+            268..273 'inner': Map<impl Fn(&f64) -> f64>\n+            276..300 'Map { ... 0.0 }': Map<impl Fn(&f64) -> f64>\n+            285..298 '|_: &f64| 0.0': impl Fn(&f64) -> f64\n             286..287 '_': &f64\n             295..298 '0.0': f64\n-            311..317 'repeat': Repeat<Map<|&f64| -> f64>>\n-            320..345 'Repeat...nner }': Repeat<Map<|&f64| -> f64>>\n-            338..343 'inner': Map<|&f64| -> f64>\n-            356..359 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            362..371 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>, Repeat<Map<|&f64| -> f64>>>(Repeat<Map<|&f64| -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            362..379 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            372..378 'repeat': Repeat<Map<|&f64| -> f64>>\n-            386..389 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            311..317 'repeat': Repeat<Map<impl Fn(&f64) -> f64>>\n+            320..345 'Repeat...nner }': Repeat<Map<impl Fn(&f64) -> f64>>\n+            338..343 'inner': Map<impl Fn(&f64) -> f64>\n+            356..359 'vec': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            362..371 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>, Repeat<Map<impl Fn(&f64) -> f64>>>(Repeat<Map<impl Fn(&f64) -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            362..379 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            372..378 'repeat': Repeat<Map<impl Fn(&f64) -> f64>>\n+            386..389 'vec': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n             386..399 'vec.foo_bar()': {unknown}\n         \"#]],\n     );\n@@ -852,7 +852,7 @@ fn main() {\n             123..126 'S()': S<i32>\n             132..133 's': S<i32>\n             132..144 's.g(|_x| {})': ()\n-            136..143 '|_x| {}': |&i32| -> ()\n+            136..143 '|_x| {}': impl Fn(&i32)\n             137..139 '_x': &i32\n             141..143 '{}': ()\n             150..151 's': S<i32>\n@@ -1759,13 +1759,14 @@ const C: usize = 2 + 2;\n \n #[test]\n fn regression_14456() {\n-    check_no_mismatches(\n+    check_types(\n         r#\"\n //- minicore: future\n async fn x() {}\n fn f() {\n     let fut = x();\n-    let t = [0u8; 2 + 2];\n+    let t = [0u8; { let a = 2 + 2; a }];\n+      //^ [u8; 4]\n }\n \"#,\n     );"}, {"sha": "2b14a28a67221f49f7e0546b5ba2013598858f3e", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 197, "deletions": 11, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1906,8 +1906,8 @@ fn closure_return() {\n         \"#,\n         expect![[r#\"\n             16..58 '{     ...; }; }': u32\n-            26..27 'x': || -> usize\n-            30..55 '|| -> ...n 1; }': || -> usize\n+            26..27 'x': impl Fn() -> usize\n+            30..55 '|| -> ...n 1; }': impl Fn() -> usize\n             42..55 '{ return 1; }': usize\n             44..52 'return 1': !\n             51..52 '1': usize\n@@ -1925,8 +1925,8 @@ fn closure_return_unit() {\n         \"#,\n         expect![[r#\"\n             16..47 '{     ...; }; }': u32\n-            26..27 'x': || -> ()\n-            30..44 '|| { return; }': || -> ()\n+            26..27 'x': impl Fn()\n+            30..44 '|| { return; }': impl Fn()\n             33..44 '{ return; }': ()\n             35..41 'return': !\n         \"#]],\n@@ -1943,8 +1943,8 @@ fn closure_return_inferred() {\n         \"#,\n         expect![[r#\"\n             16..46 '{     ...\" }; }': u32\n-            26..27 'x': || -> &str\n-            30..43 '|| { \"test\" }': || -> &str\n+            26..27 'x': impl Fn() -> &str\n+            30..43 '|| { \"test\" }': impl Fn() -> &str\n             33..43 '{ \"test\" }': &str\n             35..41 '\"test\"': &str\n         \"#]],\n@@ -2050,7 +2050,7 @@ fn fn_pointer_return() {\n             47..120 '{     ...hod; }': ()\n             57..63 'vtable': Vtable\n             66..90 'Vtable...| {} }': Vtable\n-            83..88 '|| {}': || -> ()\n+            83..88 '|| {}': impl Fn()\n             86..88 '{}': ()\n             100..101 'm': fn()\n             104..110 'vtable': Vtable\n@@ -2142,9 +2142,9 @@ fn main() {\n             149..151 'Ok': Ok<(), ()>(()) -> Result<(), ()>\n             149..155 'Ok(())': Result<(), ()>\n             152..154 '()': ()\n-            167..171 'test': fn test<(), (), || -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(|| -> impl Future<Output = Result<(), ()>>)\n+            167..171 'test': fn test<(), (), impl Fn() -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(impl Fn() -> impl Future<Output = Result<(), ()>>)\n             167..228 'test(|...    })': ()\n-            172..227 '|| asy...     }': || -> impl Future<Output = Result<(), ()>>\n+            172..227 '|| asy...     }': impl Fn() -> impl Future<Output = Result<(), ()>>\n             175..227 'async ...     }': impl Future<Output = Result<(), ()>>\n             191..205 'return Err(())': !\n             198..201 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -2270,8 +2270,8 @@ fn infer_labelled_break_with_val() {\n         \"#,\n         expect![[r#\"\n             9..335 '{     ...  }; }': ()\n-            19..21 '_x': || -> bool\n-            24..332 '|| 'ou...     }': || -> bool\n+            19..21 '_x': impl Fn() -> bool\n+            24..332 '|| 'ou...     }': impl Fn() -> bool\n             27..332 ''outer...     }': bool\n             40..332 '{     ...     }': ()\n             54..59 'inner': i8\n@@ -2695,6 +2695,179 @@ impl B for Astruct {}\n     )\n }\n \n+#[test]\n+fn capture_kinds_simple() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+impl S {\n+    fn read(&self) -> &S { self }\n+    fn write(&mut self) -> &mut S { self }\n+    fn consume(self) -> S { self }\n+}\n+\n+fn f() {\n+    let x = S;\n+    let c1 = || x.read();\n+      //^^ impl Fn() -> &S\n+    let c2 = || x.write();\n+      //^^ impl FnMut() -> &mut S\n+    let c3 = || x.consume();\n+      //^^ impl FnOnce() -> S\n+    let c3 = || x.consume().consume().consume();\n+      //^^ impl FnOnce() -> S\n+    let c3 = || x.consume().write().read();\n+      //^^ impl FnOnce() -> &S\n+    let x = &mut x;\n+    let c1 = || x.write();\n+      //^^ impl FnMut() -> &mut S\n+    let x = S;\n+    let c1 = || { let ref t = x; t };\n+      //^^ impl Fn() -> &S\n+    let c2 = || { let ref mut t = x; t };\n+      //^^ impl FnMut() -> &mut S\n+    let c3 = || { let t = x; t };\n+      //^^ impl FnOnce() -> S\n+}\n+    \"#,\n+    )\n+}\n+\n+#[test]\n+fn capture_kinds_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    let mut x = 2;\n+    x = 5;\n+    let mut c1 = || { x = 3; x };\n+      //^^^^^^ impl FnMut() -> i32\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl FnMut() -> i32\n+    let mut c1 = || { x };\n+      //^^^^^^ impl Fn() -> i32\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl Fn() -> i32\n+    struct X;\n+    let x = X;\n+    let mut c1 = || { x };\n+      //^^^^^^ impl FnOnce() -> X\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl FnOnce() -> X\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn capture_kinds_overloaded_deref() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, deref_mut\n+use core::ops::{Deref, DerefMut};\n+\n+struct Foo;\n+impl Deref for Foo {\n+    type Target = (i32, u8);\n+    fn deref(&self) -> &(i32, u8) {\n+        &(5, 2)\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut (i32, u8) {\n+        &mut (5, 2)\n+    }\n+}\n+fn test() {\n+    let mut x = Foo;\n+    let c1 = || *x;\n+      //^^ impl Fn() -> (i32, u8)\n+    let c2 = || { *x = (2, 5); };\n+      //^^ impl FnMut()\n+    let c3 = || { x.1 };\n+      //^^ impl Fn() -> u8\n+    let c4 = || { x.1 = 6; };\n+      //^^ impl FnMut()\n+}\n+       \"#,\n+    );\n+}\n+\n+#[test]\n+fn capture_kinds_with_copy_types() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, clone, derive\n+#[derive(Clone, Copy)]\n+struct Copy;\n+struct NotCopy;\n+#[derive(Clone, Copy)]\n+struct Generic<T>(T);\n+\n+trait Tr {\n+    type Assoc;\n+}\n+\n+impl Tr for Copy {\n+    type Assoc = NotCopy;\n+}\n+\n+#[derive(Clone, Copy)]\n+struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+fn f() {\n+    let a = Copy;\n+    let b = NotCopy;\n+    let c = Generic(Copy);\n+    let d = Generic(NotCopy);\n+    let e: AssocGeneric<Copy> = AssocGeneric(NotCopy);\n+    let c1 = || a;\n+      //^^ impl Fn() -> Copy\n+    let c2 = || b;\n+      //^^ impl FnOnce() -> NotCopy\n+    let c3 = || c;\n+      //^^ impl Fn() -> Generic<Copy>\n+    let c3 = || d;\n+      //^^ impl FnOnce() -> Generic<NotCopy>\n+    let c3 = || e;\n+      //^^ impl FnOnce() -> AssocGeneric<Copy>\n+}\n+    \"#,\n+    )\n+}\n+\n+#[test]\n+fn derive_macro_should_work_for_associated_type() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, clone, derive\n+#[derive(Clone)]\n+struct X;\n+#[derive(Clone)]\n+struct Y;\n+\n+trait Tr {\n+    type Assoc;\n+}\n+\n+impl Tr for X {\n+    type Assoc = Y;\n+}\n+\n+#[derive(Clone)]\n+struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+fn f() {\n+    let e: AssocGeneric<X> = AssocGeneric(Y);\n+    let e_clone = e.clone();\n+      //^^^^^^^ AssocGeneric<X>\n+}\n+    \"#,\n+    )\n+}\n+\n #[test]\n fn cfgd_out_assoc_items() {\n     check_types(\n@@ -3291,6 +3464,19 @@ fn f<T>(t: Ark<T>) {\n     );\n }\n \n+#[test]\n+fn const_dependent_on_local() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let s = 5;\n+    let t = [2; s];\n+      //^ [i32; _]\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn issue_14275() {\n     // FIXME: evaluate const generic"}, {"sha": "fdfae44c2d13ea19891684fb371d3331abc34afc", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -90,7 +90,7 @@ fn infer_async_closure() {\n async fn test() {\n     let f = async move |x: i32| x + 42;\n     f;\n-//  ^ |i32| -> impl Future<Output = i32>\n+//  ^ impl Fn(i32) -> impl Future<Output = i32>\n     let a = f(4);\n     a;\n //  ^ impl Future<Output = i32>\n@@ -99,7 +99,7 @@ async fn test() {\n //  ^ i32\n     let f = async move || 42;\n     f;\n-//  ^ || -> impl Future<Output = i32>\n+//  ^ impl Fn() -> impl Future<Output = i32>\n     let a = f();\n     a;\n //  ^ impl Future<Output = i32>\n@@ -116,7 +116,7 @@ async fn test() {\n     };\n     let _: Option<u64> = c().await;\n     c;\n-//  ^ || -> impl Future<Output = Option<u64>>\n+//  ^ impl Fn() -> impl Future<Output = Option<u64>>\n }\n \"#,\n     );\n@@ -550,7 +550,7 @@ fn test() -> u64 {\n             53..54 'a': S\n             57..58 'S': S(fn(u32) -> u64) -> S\n             57..74 'S(|i| ...s u64)': S\n-            59..73 '|i| 2*i as u64': |u32| -> u64\n+            59..73 '|i| 2*i as u64': impl Fn(u32) -> u64\n             60..61 'i': u32\n             63..64 '2': u64\n             63..73 '2*i as u64': u64\n@@ -1333,9 +1333,9 @@ fn foo<const C: u8, T>() -> (impl FnOnce(&str, T), impl Trait<u8>) {\n }\n \"#,\n         expect![[r#\"\n-            134..165 '{     ...(C)) }': (|&str, T| -> (), Bar<u8>)\n-            140..163 '(|inpu...ar(C))': (|&str, T| -> (), Bar<u8>)\n-            141..154 '|input, t| {}': |&str, T| -> ()\n+            134..165 '{     ...(C)) }': (impl Fn(&str, T), Bar<u8>)\n+            140..163 '(|inpu...ar(C))': (impl Fn(&str, T), Bar<u8>)\n+            141..154 '|input, t| {}': impl Fn(&str, T)\n             142..147 'input': &str\n             149..150 't': T\n             152..154 '{}': ()\n@@ -1506,8 +1506,8 @@ fn main() {\n             71..105 '{     ...()); }': ()\n             77..78 'f': fn f(&dyn Fn(S))\n             77..102 'f(&|nu...foo())': ()\n-            79..101 '&|numb....foo()': &|S| -> ()\n-            80..101 '|numbe....foo()': |S| -> ()\n+            79..101 '&|numb....foo()': &impl Fn(S)\n+            80..101 '|numbe....foo()': impl Fn(S)\n             81..87 'number': S\n             89..95 'number': S\n             89..101 'number.foo()': ()\n@@ -1912,13 +1912,13 @@ fn test() {\n             131..132 'f': F\n             151..153 '{}': Lazy<T, F>\n             251..497 '{     ...o(); }': ()\n-            261..266 'lazy1': Lazy<Foo, || -> Foo>\n-            283..292 'Lazy::new': fn new<Foo, || -> Foo>(|| -> Foo) -> Lazy<Foo, || -> Foo>\n-            283..300 'Lazy::...| Foo)': Lazy<Foo, || -> Foo>\n-            293..299 '|| Foo': || -> Foo\n+            261..266 'lazy1': Lazy<Foo, impl Fn() -> Foo>\n+            283..292 'Lazy::new': fn new<Foo, impl Fn() -> Foo>(impl Fn() -> Foo) -> Lazy<Foo, impl Fn() -> Foo>\n+            283..300 'Lazy::...| Foo)': Lazy<Foo, impl Fn() -> Foo>\n+            293..299 '|| Foo': impl Fn() -> Foo\n             296..299 'Foo': Foo\n             310..312 'r1': usize\n-            315..320 'lazy1': Lazy<Foo, || -> Foo>\n+            315..320 'lazy1': Lazy<Foo, impl Fn() -> Foo>\n             315..326 'lazy1.foo()': usize\n             368..383 'make_foo_fn_ptr': fn() -> Foo\n             399..410 'make_foo_fn': fn make_foo_fn() -> Foo\n@@ -1963,20 +1963,20 @@ fn test() {\n             163..167 '1u32': u32\n             174..175 'x': Option<u32>\n             174..190 'x.map(...v + 1)': Option<u32>\n-            180..189 '|v| v + 1': |u32| -> u32\n+            180..189 '|v| v + 1': impl Fn(u32) -> u32\n             181..182 'v': u32\n             184..185 'v': u32\n             184..189 'v + 1': u32\n             188..189 '1': u32\n             196..197 'x': Option<u32>\n             196..212 'x.map(... 1u64)': Option<u64>\n-            202..211 '|_v| 1u64': |u32| -> u64\n+            202..211 '|_v| 1u64': impl Fn(u32) -> u64\n             203..205 '_v': u32\n             207..211 '1u64': u64\n             222..223 'y': Option<i64>\n             239..240 'x': Option<u32>\n             239..252 'x.map(|_v| 1)': Option<i64>\n-            245..251 '|_v| 1': |u32| -> i64\n+            245..251 '|_v| 1': impl Fn(u32) -> i64\n             246..248 '_v': u32\n             250..251 '1': i64\n         \"#]],\n@@ -2005,11 +2005,11 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n   //^^^^ u64\n     let g = |v| v + 1;\n               //^^^^^ u64\n-          //^^^^^^^^^ |u64| -> u64\n+          //^^^^^^^^^ impl Fn(u64) -> u64\n     g(1u64);\n   //^^^^^^^ u64\n     let h = |v| 1u128 + v;\n-          //^^^^^^^^^^^^^ |u128| -> u128\n+          //^^^^^^^^^^^^^ impl Fn(u128) -> u128\n }\"#,\n     );\n }\n@@ -2062,17 +2062,17 @@ fn test() {\n             312..314 '{}': ()\n             330..489 '{     ... S); }': ()\n             340..342 'x1': u64\n-            345..349 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n+            345..349 'foo1': fn foo1<S, u64, impl Fn(S) -> u64>(S, impl Fn(S) -> u64) -> u64\n             345..368 'foo1(S...hod())': u64\n             350..351 'S': S\n-            353..367 '|s| s.method()': |S| -> u64\n+            353..367 '|s| s.method()': impl Fn(S) -> u64\n             354..355 's': S\n             357..358 's': S\n             357..367 's.method()': u64\n             378..380 'x2': u64\n-            383..387 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n+            383..387 'foo2': fn foo2<S, u64, impl Fn(S) -> u64>(impl Fn(S) -> u64, S) -> u64\n             383..406 'foo2(|...(), S)': u64\n-            388..402 '|s| s.method()': |S| -> u64\n+            388..402 '|s| s.method()': impl Fn(S) -> u64\n             389..390 's': S\n             392..393 's': S\n             392..402 's.method()': u64\n@@ -2081,14 +2081,14 @@ fn test() {\n             421..422 'S': S\n             421..446 'S.foo1...hod())': u64\n             428..429 'S': S\n-            431..445 '|s| s.method()': |S| -> u64\n+            431..445 '|s| s.method()': impl Fn(S) -> u64\n             432..433 's': S\n             435..436 's': S\n             435..445 's.method()': u64\n             456..458 'x4': u64\n             461..462 'S': S\n             461..486 'S.foo2...(), S)': u64\n-            468..482 '|s| s.method()': |S| -> u64\n+            468..482 '|s| s.method()': impl Fn(S) -> u64\n             469..470 's': S\n             472..473 's': S\n             472..482 's.method()': u64\n@@ -2562,9 +2562,9 @@ fn main() {\n             72..74 '_v': F\n             117..120 '{ }': ()\n             132..163 '{     ... }); }': ()\n-            138..148 'f::<(), _>': fn f<(), |&()| -> ()>(|&()| -> ())\n+            138..148 'f::<(), _>': fn f<(), impl Fn(&())>(impl Fn(&()))\n             138..160 'f::<()... z; })': ()\n-            149..159 '|z| { z; }': |&()| -> ()\n+            149..159 '|z| { z; }': impl Fn(&())\n             150..151 'z': &()\n             153..159 '{ z; }': ()\n             155..156 'z': &()\n@@ -2721,9 +2721,9 @@ fn main() {\n             983..998 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n             983..1000 'Vec::<...:new()': Vec<i32>\n             983..1012 'Vec::<...iter()': IntoIter<i32>\n-            983..1075 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n+            983..1075 'Vec::<...one })': FilterMap<IntoIter<i32>, impl Fn(i32) -> Option<u32>>\n             983..1101 'Vec::<... y; })': ()\n-            1029..1074 '|x| if...None }': |i32| -> Option<u32>\n+            1029..1074 '|x| if...None }': impl Fn(i32) -> Option<u32>\n             1030..1031 'x': i32\n             1033..1074 'if x >...None }': Option<u32>\n             1036..1037 'x': i32\n@@ -2736,7 +2736,7 @@ fn main() {\n             1049..1057 'x as u32': u32\n             1066..1074 '{ None }': Option<u32>\n             1068..1072 'None': Option<u32>\n-            1090..1100 '|y| { y; }': |u32| -> ()\n+            1090..1100 '|y| { y; }': impl Fn(u32)\n             1091..1092 'y': u32\n             1094..1100 '{ y; }': ()\n             1096..1097 'y': u32\n@@ -2979,13 +2979,13 @@ fn foo() {\n             52..126 '{     ...)(s) }': ()\n             62..63 's': Option<i32>\n             66..78 'Option::None': Option<i32>\n-            88..89 'f': |Option<i32>| -> ()\n-            92..111 '|x: Op...2>| {}': |Option<i32>| -> ()\n+            88..89 'f': impl Fn(Option<i32>)\n+            92..111 '|x: Op...2>| {}': impl Fn(Option<i32>)\n             93..94 'x': Option<i32>\n             109..111 '{}': ()\n             117..124 '(&f)(s)': ()\n-            118..120 '&f': &|Option<i32>| -> ()\n-            119..120 'f': |Option<i32>| -> ()\n+            118..120 '&f': &impl Fn(Option<i32>)\n+            119..120 'f': impl Fn(Option<i32>)\n             122..123 's': Option<i32>\n         \"#]],\n     );\n@@ -3072,15 +3072,15 @@ fn foo() {\n             228..229 's': Option<i32>\n             232..236 'None': Option<i32>\n             246..247 'f': Box<dyn FnOnce(&Option<i32>)>\n-            281..294 'box (|ps| {})': Box<|&Option<i32>| -> ()>\n-            286..293 '|ps| {}': |&Option<i32>| -> ()\n+            281..294 'box (|ps| {})': Box<impl Fn(&Option<i32>)>\n+            286..293 '|ps| {}': impl Fn(&Option<i32>)\n             287..289 'ps': &Option<i32>\n             291..293 '{}': ()\n             300..301 'f': Box<dyn FnOnce(&Option<i32>)>\n             300..305 'f(&s)': ()\n             302..304 '&s': &Option<i32>\n             303..304 's': Option<i32>\n-            281..294: expected Box<dyn FnOnce(&Option<i32>)>, got Box<|&Option<i32>| -> ()>\n+            281..294: expected Box<dyn FnOnce(&Option<i32>)>, got Box<impl Fn(&Option<i32>)>\n         \"#]],\n     );\n }"}, {"sha": "8bc38aca4722b459854378253675a54e5388e796", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -4,7 +4,7 @@ use std::{env::var, sync::Arc};\n \n use chalk_ir::GoalData;\n use chalk_recursive::Cache;\n-use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n+use chalk_solve::{logging_db::LoggingRustIrDatabase, rust_ir, Solver};\n \n use base_db::CrateId;\n use hir_def::{\n@@ -177,8 +177,10 @@ fn is_chalk_print() -> bool {\n     std::env::var(\"CHALK_PRINT\").is_ok()\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub enum FnTrait {\n+    // Warning: Order is important. If something implements `x` it should also implement\n+    // `y` if `y <= x`.\n     FnOnce,\n     FnMut,\n     Fn,\n@@ -193,6 +195,14 @@ impl FnTrait {\n         }\n     }\n \n+    pub const fn to_chalk_ir(self) -> rust_ir::ClosureKind {\n+        match self {\n+            FnTrait::FnOnce => rust_ir::ClosureKind::FnOnce,\n+            FnTrait::FnMut => rust_ir::ClosureKind::FnMut,\n+            FnTrait::Fn => rust_ir::ClosureKind::Fn,\n+        }\n+    }\n+\n     pub fn method_name(self) -> Name {\n         match self {\n             FnTrait::FnOnce => name!(call_once),"}, {"sha": "3b2a726688d01a2f56999d7b94c29acf03071db5", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -4,14 +4,15 @@\n use std::iter;\n \n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n+use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex, Mutability};\n use either::Either;\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n+    hir::BindingAnnotation,\n     lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n@@ -24,7 +25,8 @@ use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, Ty, TyExt,\n+    WhereClause,\n };\n \n pub(crate) fn fn_traits(\n@@ -352,3 +354,20 @@ pub fn is_fn_unsafe_to_call(db: &dyn HirDatabase, func: FunctionId) -> bool {\n         _ => false,\n     }\n }\n+\n+pub(crate) fn pattern_matching_dereference_count(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+) -> usize {\n+    let mut r = 0;\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        r += 1;\n+    }\n+    r\n+}"}, {"sha": "db923cb0fe23337c3464e5cc651813f5a9e215aa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -129,7 +129,7 @@ pub use {\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n     hir_ty::{\n-        display::{HirDisplay, HirDisplayError, HirWrite},\n+        display::{ClosureStyle, HirDisplay, HirDisplayError, HirWrite},\n         mir::MirEvalError,\n         PointerCast, Safety,\n     },\n@@ -1530,35 +1530,44 @@ impl DefWithBody {\n \n         let hir_body = db.body(self.into());\n \n-        if let Ok(borrowck_result) = db.borrowck(self.into()) {\n-            let mir_body = &borrowck_result.mir_body;\n-            let mol = &borrowck_result.mutability_of_locals;\n-            for (binding_id, _) in hir_body.bindings.iter() {\n-                let need_mut = &mol[mir_body.binding_locals[binding_id]];\n-                let local = Local { parent: self.into(), binding_id };\n-                match (need_mut, local.is_mut(db)) {\n-                    (mir::MutabilityReason::Mut { .. }, true)\n-                    | (mir::MutabilityReason::Not, false) => (),\n-                    (mir::MutabilityReason::Mut { spans }, false) => {\n-                        for span in spans {\n-                            let span: InFile<SyntaxNodePtr> = match span {\n-                                mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n-                                    Ok(s) => s.map(|x| x.into()),\n-                                    Err(_) => continue,\n-                                },\n-                                mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n-                                    Ok(s) => s.map(|x| match x {\n-                                        Either::Left(e) => e.into(),\n-                                        Either::Right(e) => e.into(),\n-                                    }),\n-                                    Err(_) => continue,\n-                                },\n-                                mir::MirSpan::Unknown => continue,\n-                            };\n-                            acc.push(NeedMut { local, span }.into());\n+        if let Ok(borrowck_results) = db.borrowck(self.into()) {\n+            for borrowck_result in borrowck_results.iter() {\n+                let mir_body = &borrowck_result.mir_body;\n+                let mol = &borrowck_result.mutability_of_locals;\n+                for (binding_id, _) in hir_body.bindings.iter() {\n+                    let Some(&local) = mir_body.binding_locals.get(binding_id) else {\n+                        continue;\n+                    };\n+                    let need_mut = &mol[local];\n+                    let local = Local { parent: self.into(), binding_id };\n+                    match (need_mut, local.is_mut(db)) {\n+                        (mir::MutabilityReason::Mut { .. }, true)\n+                        | (mir::MutabilityReason::Not, false) => (),\n+                        (mir::MutabilityReason::Mut { spans }, false) => {\n+                            for span in spans {\n+                                let span: InFile<SyntaxNodePtr> = match span {\n+                                    mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                        Ok(s) => s.map(|x| x.into()),\n+                                        Err(_) => continue,\n+                                    },\n+                                    mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                        Ok(s) => s.map(|x| match x {\n+                                            Either::Left(e) => e.into(),\n+                                            Either::Right(e) => e.into(),\n+                                        }),\n+                                        Err(_) => continue,\n+                                    },\n+                                    mir::MirSpan::Unknown => continue,\n+                                };\n+                                acc.push(NeedMut { local, span }.into());\n+                            }\n+                        }\n+                        (mir::MutabilityReason::Not, true) => {\n+                            if !infer.mutated_bindings_in_closure.contains(&binding_id) {\n+                                acc.push(UnusedMut { local }.into())\n+                            }\n                         }\n                     }\n-                    (mir::MutabilityReason::Not, true) => acc.push(UnusedMut { local }.into()),\n                 }\n             }\n         }\n@@ -3383,7 +3392,12 @@ impl Type {\n     }\n \n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let mut the_ty = &self.ty;\n         let callee = match self.ty.kind(Interner) {\n+            TyKind::Ref(_, _, ty) if ty.as_closure().is_some() => {\n+                the_ty = ty;\n+                Callee::Closure(ty.as_closure().unwrap())\n+            }\n             TyKind::Closure(id, _) => Callee::Closure(*id),\n             TyKind::Function(_) => Callee::FnPtr,\n             TyKind::FnDef(..) => Callee::Def(self.ty.callable_def(db)?),\n@@ -3398,7 +3412,7 @@ impl Type {\n             }\n         };\n \n-        let sig = self.ty.callable_sig(db)?;\n+        let sig = the_ty.callable_sig(db)?;\n         Some(Callable { ty: self.clone(), sig, callee, is_bound_method: false })\n     }\n "}, {"sha": "2372fe28e1974578b45507d691e47bd082f9b760", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1910,7 +1910,6 @@ fn bar(new: fn) ${0:-> _} {\n \n     #[test]\n     fn add_function_with_closure_arg() {\n-        // FIXME: The argument in `bar` is wrong.\n         check_assist(\n             generate_function,\n             r\"\n@@ -1925,7 +1924,7 @@ fn foo() {\n     bar(closure)\n }\n \n-fn bar(closure: _) {\n+fn bar(closure: impl Fn(i64) -> i64) {\n     ${0:todo!()}\n }\n \","}, {"sha": "8c4ca23e06e8d4ce33b20337cc8483538588e15e", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -771,6 +771,88 @@ fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n         );\n     }\n \n+    #[test]\n+    fn closure() {\n+        // FIXME: Diagnositc spans are too large\n+        check_diagnostics(\n+            r#\"\n+        //- minicore: copy, fn\n+        struct X;\n+\n+        impl X {\n+            fn mutate(&mut self) {}\n+        }\n+\n+        fn f() {\n+            let x = 5;\n+            let closure1 = || { x = 2; };\n+                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let closure2 = || { x = x; };\n+                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            let closure3 = || {\n+                let x = 2;\n+                x = 5;\n+              //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                x\n+            };\n+            let x = X;\n+            let closure4 = || { x.mutate(); };\n+                         //^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        }\n+                    \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+        //- minicore: copy, fn\n+        fn f() {\n+            let mut x = 5;\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let mut y = 2;\n+            y = 7;\n+            let closure = || {\n+                let mut z = 8;\n+                z = 3;\n+                let mut k = z;\n+                  //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            };\n+        }\n+                    \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    let closure = || {\n+        || {\n+            || {\n+                let x = 2;\n+                || { || { x = 5; } }\n+              //^^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            }\n+        }\n+    };\n+}\n+            \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    struct X;\n+    let mut x = X;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let c1 = || x;\n+    let mut x = X;\n+    let c2 = || { x = X; x };\n+    let mut x = X;\n+    let c2 = move || { x = X; };\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn respect_allow_unused_mut() {\n         // FIXME: respect"}, {"sha": "738339cfa6b5cd24ce24d944d28ed68579f03382", "filename": "crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -115,7 +115,7 @@ fn foo() {\n             r#\"\n //- minicore: iterators\n fn foo() {\n-    let m = core::iter::repeat(())\n+    let mut m = core::iter::repeat(())\n         .filter_map(|()| Some(92));\n     let n = m.next();\n }"}, {"sha": "c5fa1cb027e142376b58268fefe5ea26f0a137d6", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{db::ExpandDatabase, HirDisplay, InFile, Type};\n+use hir::{db::ExpandDatabase, ClosureStyle, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},\n@@ -32,8 +32,8 @@ pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch)\n         \"type-mismatch\",\n         format!(\n             \"expected {}, found {}\",\n-            d.expected.display(ctx.sema.db),\n-            d.actual.display(ctx.sema.db)\n+            d.expected.display(ctx.sema.db).with_closure_style(ClosureStyle::ClosureWithId),\n+            d.actual.display(ctx.sema.db).with_closure_style(ClosureStyle::ClosureWithId),\n         ),\n         display_range,\n     )\n@@ -596,6 +596,19 @@ fn test() -> String {\n         );\n     }\n \n+    #[test]\n+    fn closure_mismatch_show_different_type() {\n+        check_diagnostics(\n+            r#\"\n+fn f() {\n+    let mut x = (|| 1, 2);\n+    x = (|| 3, 4);\n+       //^^^^ error: expected {closure#0}, found {closure#1}\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn type_mismatch_on_block() {\n         cov_mark::check!(type_mismatch_on_block);"}, {"sha": "8a58fbeb860bb474b6be84023cab70ae3464ed83", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -225,7 +225,7 @@ fn main() {\n                 *iter*\n \n                 ```rust\n-                let mut iter: Iter<Scan<OtherStruct<OtherStruct<i32>>, |&mut u32, &u32, &mut u32| -> Option<u32>, u32>>\n+                let mut iter: Iter<Scan<OtherStruct<OtherStruct<i32>>, impl Fn(&mut u32, &u32, &mut u32) -> Option<u32>, u32>>\n                 ```\n             \"#]],\n     );"}, {"sha": "e6360bc6ec1c9f5d5bddfc51c387cf11ba5fdd0a", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -5,7 +5,8 @@ use std::{\n \n use either::Either;\n use hir::{\n-    known, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef, ModuleDefId, Semantics,\n+    known, ClosureStyle, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef,\n+    ModuleDefId, Semantics,\n };\n use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n@@ -45,6 +46,7 @@ pub struct InlayHintsConfig {\n     pub param_names_for_lifetime_elision_hints: bool,\n     pub hide_named_constructor_hints: bool,\n     pub hide_closure_initialization_hints: bool,\n+    pub closure_style: ClosureStyle,\n     pub max_length: Option<usize>,\n     pub closing_brace_hints_min_lines: Option<usize>,\n }\n@@ -291,6 +293,7 @@ fn label_of_ty(\n         mut max_length: Option<usize>,\n         ty: hir::Type,\n         label_builder: &mut InlayHintLabelBuilder<'_>,\n+        config: &InlayHintsConfig,\n     ) -> Result<(), HirDisplayError> {\n         let iter_item_type = hint_iterator(sema, famous_defs, &ty);\n         match iter_item_type {\n@@ -321,11 +324,14 @@ fn label_of_ty(\n                 label_builder.write_str(LABEL_ITEM)?;\n                 label_builder.end_location_link();\n                 label_builder.write_str(LABEL_MIDDLE2)?;\n-                rec(sema, famous_defs, max_length, ty, label_builder)?;\n+                rec(sema, famous_defs, max_length, ty, label_builder, config)?;\n                 label_builder.write_str(LABEL_END)?;\n                 Ok(())\n             }\n-            None => ty.display_truncated(sema.db, max_length).write_to(label_builder),\n+            None => ty\n+                .display_truncated(sema.db, max_length)\n+                .with_closure_style(config.closure_style)\n+                .write_to(label_builder),\n         }\n     }\n \n@@ -335,7 +341,7 @@ fn label_of_ty(\n         location: None,\n         result: InlayHintLabel::default(),\n     };\n-    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n+    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder, config);\n     let r = label_builder.finish();\n     Some(r)\n }\n@@ -481,6 +487,7 @@ fn closure_has_block_body(closure: &ast::ClosureExpr) -> bool {\n #[cfg(test)]\n mod tests {\n     use expect_test::Expect;\n+    use hir::ClosureStyle;\n     use itertools::Itertools;\n     use test_utils::extract_annotations;\n \n@@ -504,6 +511,7 @@ mod tests {\n         binding_mode_hints: false,\n         hide_named_constructor_hints: false,\n         hide_closure_initialization_hints: false,\n+        closure_style: ClosureStyle::ImplFn,\n         param_names_for_lifetime_elision_hints: false,\n         max_length: None,\n         closing_brace_hints_min_lines: None,"}, {"sha": "5f571d0448211a0610b805a01d0d86ba04b55b57", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -176,6 +176,7 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir\n mod tests {\n     // This module also contains tests for super::closure_ret\n \n+    use hir::ClosureStyle;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n@@ -235,7 +236,7 @@ fn main() {\n     let zz_ref = &zz;\n       //^^^^^^ &Test<i32>\n     let test = || zz;\n-      //^^^^ || -> Test<i32>\n+      //^^^^ impl FnOnce() -> Test<i32>\n }\"#,\n         );\n     }\n@@ -753,7 +754,7 @@ fn main() {\n     let func = times2;\n     //  ^^^^ fn times2(i32) -> i32\n     let closure = |x: i32| x * 2;\n-    //  ^^^^^^^ |i32| -> i32\n+    //  ^^^^^^^ impl Fn(i32) -> i32\n }\n \n fn fallible() -> ControlFlow<()> {\n@@ -821,7 +822,7 @@ fn main() {\n                    //^^^^^^^^^ i32\n \n     let multiply =\n-      //^^^^^^^^ |i32, i32| -> i32\n+      //^^^^^^^^ impl Fn(i32, i32) -> i32\n       | a,     b| a * b\n       //^ i32  ^ i32\n \n@@ -830,10 +831,10 @@ fn main() {\n     let _: i32 = multiply(1,  2);\n                         //^ a ^ b\n     let multiply_ref = &multiply;\n-      //^^^^^^^^^^^^ &|i32, i32| -> i32\n+      //^^^^^^^^^^^^ &impl Fn(i32, i32) -> i32\n \n     let return_42 = || 42;\n-      //^^^^^^^^^ || -> i32\n+      //^^^^^^^^^ impl Fn() -> i32\n       || { 42 };\n     //^^ i32\n }\"#,\n@@ -857,6 +858,94 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn closure_style() {\n+        check_with_config(\n+            InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ impl Fn() -> i32\n+    let y = |t: i32| x() + t;\n+      //^ impl Fn(i32) -> i32\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ impl FnMut(i32)\n+    let p = (y, z);\n+      //^ (impl Fn(i32) -> i32, impl FnMut(i32))\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::RANotation,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ || -> i32\n+    let y = |t: i32| x() + t;\n+      //^ |i32| -> i32\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ |i32| -> ()\n+    let p = (y, z);\n+      //^ (|i32| -> i32, |i32| -> ())\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::ClosureWithId,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ {closure#0}\n+    let y = |t: i32| x() + t;\n+      //^ {closure#1}\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ {closure#2}\n+    let p = (y, z);\n+      //^ ({closure#1}, {closure#2})\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::Hide,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ \u2026\n+    let y = |t: i32| x() + t;\n+      //^ \u2026\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ \u2026\n+    let p = (y, z);\n+      //^ (\u2026, \u2026)\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn skip_closure_type_hints() {\n         check_with_config(\n@@ -871,13 +960,13 @@ fn main() {\n     let multiple_2 = |x: i32| { x * 2 };\n \n     let multiple_2 = |x: i32| x * 2;\n-    //  ^^^^^^^^^^ |i32| -> i32\n+    //  ^^^^^^^^^^ impl Fn(i32) -> i32\n \n     let (not) = (|x: bool| { !x });\n-    //   ^^^ |bool| -> bool\n+    //   ^^^ impl Fn(bool) -> bool\n \n     let (is_zero, _b) = (|x: usize| { x == 0 }, false);\n-    //   ^^^^^^^ |usize| -> bool\n+    //   ^^^^^^^ impl Fn(usize) -> bool\n     //            ^^ bool\n \n     let plus_one = |x| { x + 1 };"}, {"sha": "cdee705cbfdaad403850f4710362602033def689", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1227,6 +1227,24 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn call_info_for_fn_def_over_reference() {\n+        check(\n+            r#\"\n+struct S;\n+fn foo(s: S) -> i32 { 92 }\n+fn main() {\n+    let bar = &&&&&foo;\n+    bar($0);\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn foo(s: S) -> i32\n+                       ^^^^\n+            \"#]],\n+        )\n+    }\n+\n     #[test]\n     fn call_info_for_fn_ptr() {\n         check("}, {"sha": "774b07775b9dc684c0c492251056ca6dbc6fd5e7", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -118,6 +118,7 @@ impl StaticIndex<'_> {\n                     adjustment_hints_hide_outside_unsafe: false,\n                     hide_named_constructor_hints: false,\n                     hide_closure_initialization_hints: false,\n+                    closure_style: hir::ClosureStyle::ImplFn,\n                     param_names_for_lifetime_elision_hints: false,\n                     binding_mode_hints: false,\n                     max_length: Some(25),"}, {"sha": "27445d1f712d832078c3fc39bcc9f71a7c9aeea0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -338,6 +338,8 @@ config_data! {\n         inlayHints_closingBraceHints_minLines: usize               = \"25\",\n         /// Whether to show inlay type hints for return types of closures.\n         inlayHints_closureReturnTypeHints_enable: ClosureReturnTypeHintsDef  = \"\\\"never\\\"\",\n+        /// Closure notation in type and chaining inaly hints.\n+        inlayHints_closureStyle: ClosureStyle                                = \"\\\"impl_fn\\\"\",\n         /// Whether to show enum variant discriminant hints.\n         inlayHints_discriminantHints_enable: DiscriminantHintsDef            = \"\\\"never\\\"\",\n         /// Whether to show inlay hints for type adjustments.\n@@ -1301,6 +1303,12 @@ impl Config {\n             hide_closure_initialization_hints: self\n                 .data\n                 .inlayHints_typeHints_hideClosureInitialization,\n+            closure_style: match self.data.inlayHints_closureStyle {\n+                ClosureStyle::ImplFn => hir::ClosureStyle::ImplFn,\n+                ClosureStyle::RustAnalyzer => hir::ClosureStyle::RANotation,\n+                ClosureStyle::WithId => hir::ClosureStyle::ClosureWithId,\n+                ClosureStyle::Hide => hir::ClosureStyle::Hide,\n+            },\n             adjustment_hints: match self.data.inlayHints_expressionAdjustmentHints_enable {\n                 AdjustmentHintsDef::Always => ide::AdjustmentHints::Always,\n                 AdjustmentHintsDef::Never => match self.data.inlayHints_reborrowHints_enable {\n@@ -1807,6 +1815,15 @@ enum ClosureReturnTypeHintsDef {\n     WithBlock,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum ClosureStyle {\n+    ImplFn,\n+    RustAnalyzer,\n+    WithId,\n+    Hide,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum ReborrowHintsDef {\n@@ -2288,6 +2305,16 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 },\n             ],\n         },\n+        \"ClosureStyle\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"impl_fn\", \"rust_analyzer\", \"with_id\", \"hide\"],\n+            \"enumDescriptions\": [\n+                \"`impl_fn`: `impl FnMut(i32, u64) -> i8`\",\n+                \"`rust_analyzer`: `|i32, u64| -> i8`\",\n+                \"`with_id`: `{closure#14352}`, where that id is the unique number of the closure in r-a internals\",\n+                \"`hide`: Shows `...` for every closure type\",\n+            ],\n+        },\n         _ => panic!(\"missing entry for {ty}: {default}\"),\n     }\n "}, {"sha": "e92e6ae92cce34a8e7c08983df48d618ad4d985d", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -474,6 +474,11 @@ to always show them).\n --\n Whether to show inlay type hints for return types of closures.\n --\n+[[rust-analyzer.inlayHints.closureStyle]]rust-analyzer.inlayHints.closureStyle (default: `\"impl_fn\"`)::\n++\n+--\n+Closure notation in type and chaining inaly hints.\n+--\n [[rust-analyzer.inlayHints.discriminantHints.enable]]rust-analyzer.inlayHints.discriminantHints.enable (default: `\"never\"`)::\n +\n --"}, {"sha": "087fd1296b3100060315a42620a7e6a566760023", "filename": "editors/code/package.json", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44cf8ef49ad3db5e82f18a89b20e925353389121/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/44cf8ef49ad3db5e82f18a89b20e925353389121/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=44cf8ef49ad3db5e82f18a89b20e925353389121", "patch": "@@ -1028,6 +1028,23 @@\n                         \"Only show type hints for return types of closures with blocks.\"\n                     ]\n                 },\n+                \"rust-analyzer.inlayHints.closureStyle\": {\n+                    \"markdownDescription\": \"Closure notation in type and chaining inaly hints.\",\n+                    \"default\": \"impl_fn\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"impl_fn\",\n+                        \"rust_analyzer\",\n+                        \"with_id\",\n+                        \"hide\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"`impl_fn`: `impl FnMut(i32, u64) -> i8`\",\n+                        \"`rust_analyzer`: `|i32, u64| -> i8`\",\n+                        \"`with_id`: `{closure#14352}`, where that id is the unique number of the closure in r-a internals\",\n+                        \"`hide`: Shows `...` for every closure type\"\n+                    ]\n+                },\n                 \"rust-analyzer.inlayHints.discriminantHints.enable\": {\n                     \"markdownDescription\": \"Whether to show enum variant discriminant hints.\",\n                     \"default\": \"never\","}]}