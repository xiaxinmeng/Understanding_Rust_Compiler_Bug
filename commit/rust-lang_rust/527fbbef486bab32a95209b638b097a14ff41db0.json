{"sha": "527fbbef486bab32a95209b638b097a14ff41db0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyN2ZiYmVmNDg2YmFiMzJhOTUyMDliNjM4YjA5N2ExNGZmNDFkYjA=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-12T15:42:43Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-31T15:05:42Z"}, "message": "Refactor excessive_for_each", "tree": {"sha": "624b80a997d7f63551a36e588b7535ad7de91589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/624b80a997d7f63551a36e588b7535ad7de91589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/527fbbef486bab32a95209b638b097a14ff41db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/527fbbef486bab32a95209b638b097a14ff41db0", "html_url": "https://github.com/rust-lang/rust/commit/527fbbef486bab32a95209b638b097a14ff41db0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/527fbbef486bab32a95209b638b097a14ff41db0/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5543c34699ea2723565c1d517b3d3d98cb9fd8d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5543c34699ea2723565c1d517b3d3d98cb9fd8d4", "html_url": "https://github.com/rust-lang/rust/commit/5543c34699ea2723565c1d517b3d3d98cb9fd8d4"}], "stats": {"total": 931, "additions": 525, "deletions": 406}, "files": [{"sha": "a2193f0eab9890e2ecc4278c6b7985199dae313d", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -2192,7 +2192,6 @@ Released 2018-09-13\n [`eq_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#eq_op\n [`erasing_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#erasing_op\n [`eval_order_dependence`]: https://rust-lang.github.io/rust-clippy/master/index.html#eval_order_dependence\n-[`excessive_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_for_each\n [`excessive_precision`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\n [`exhaustive_enums`]: https://rust-lang.github.io/rust-clippy/master/index.html#exhaustive_enums\n [`exhaustive_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#exhaustive_structs\n@@ -2370,6 +2369,7 @@ Released 2018-09-13\n [`needless_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect\n [`needless_continue`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_continue\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n+[`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "clippy_lints/src/iter_for_each.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/clippy_lints%2Fsrc%2Fiter_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/clippy_lints%2Fsrc%2Fiter_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fiter_for_each.rs?ref=5543c34699ea2723565c1d517b3d3d98cb9fd8d4"}, {"sha": "8c9247d978189d0782a76f12fc761c48bf6bf70d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -291,6 +291,7 @@ mod needless_bool;\n mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n+mod needless_for_each;\n mod needless_pass_by_value;\n mod needless_question_mark;\n mod needless_update;\n@@ -781,7 +782,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::CLONE_DOUBLE_REF,\n         &methods::CLONE_ON_COPY,\n         &methods::CLONE_ON_REF_PTR,\n-        &methods::EXCESSIVE_FOR_EACH,\n         &methods::EXPECT_FUN_CALL,\n         &methods::EXPECT_USED,\n         &methods::FILETYPE_IS_FILE,\n@@ -868,6 +868,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrow::NEEDLESS_BORROW,\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n+        &needless_for_each::NEEDLESS_FOR_EACH,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n         &needless_question_mark::NEEDLESS_QUESTION_MARK,\n         &needless_update::NEEDLESS_UPDATE,\n@@ -1046,6 +1047,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box ptr_eq::PtrEq);\n     store.register_late_pass(|| box needless_bool::NeedlessBool);\n     store.register_late_pass(|| box needless_bool::BoolComparison);\n+    store.register_late_pass(|| box needless_for_each::NeedlessForEach);\n     store.register_late_pass(|| box approx_const::ApproxConstant);\n     store.register_late_pass(|| box misc::MiscLints);\n     store.register_late_pass(|| box eta_reduction::EtaReduction);\n@@ -1314,7 +1316,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::WILDCARD_ENUM_MATCH_ARM),\n         LintId::of(&mem_forget::MEM_FORGET),\n         LintId::of(&methods::CLONE_ON_REF_PTR),\n-        LintId::of(&methods::EXCESSIVE_FOR_EACH),\n         LintId::of(&methods::EXPECT_USED),\n         LintId::of(&methods::FILETYPE_IS_FILE),\n         LintId::of(&methods::GET_UNWRAP),\n@@ -1325,6 +1326,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n         LintId::of(&missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n         LintId::of(&modulo_arithmetic::MODULO_ARITHMETIC),\n+        LintId::of(&needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(&panic_in_result_fn::PANIC_IN_RESULT_FN),\n         LintId::of(&panic_unimplemented::PANIC),\n         LintId::of(&panic_unimplemented::TODO),"}, {"sha": "bcb7cf1491fa6dbbcfe6ea33d7c720db6a92df19", "filename": "clippy_lints/src/methods/excessive_for_each.rs", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs?ref=5543c34699ea2723565c1d517b3d3d98cb9fd8d4", "patch": "@@ -1,122 +0,0 @@\n-use rustc_errors::Applicability;\n-use rustc_hir::{\n-    intravisit::{walk_expr, NestedVisitorMap, Visitor},\n-    Expr, ExprKind,\n-};\n-use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n-use rustc_span::source_map::Span;\n-\n-use if_chain::if_chain;\n-\n-use crate::utils::{has_iter_method, match_trait_method, paths, snippet, span_lint_and_then};\n-\n-use super::EXCESSIVE_FOR_EACH;\n-\n-pub(super) fn lint(cx: &LateContext<'_>, expr: &'tcx Expr<'_>, args: &[&[Expr<'_>]]) {\n-    if args.len() < 2 {\n-        return;\n-    }\n-\n-    let for_each_args = args[0];\n-    if for_each_args.len() < 2 {\n-        return;\n-    }\n-    let for_each_receiver = &for_each_args[0];\n-    let for_each_arg = &for_each_args[1];\n-    let iter_receiver = &args[1][0];\n-\n-    if_chain! {\n-        if has_iter_method(cx, cx.typeck_results().expr_ty(iter_receiver)).is_some();\n-        if match_trait_method(cx, expr, &paths::ITERATOR);\n-        if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;\n-        let body = cx.tcx.hir().body(body_id);\n-        if let ExprKind::Block(..) = body.value.kind;\n-        then {\n-            let mut ret_collector = RetCollector::new();\n-            ret_collector.visit_expr(&body.value);\n-\n-            // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n-            if ret_collector.ret_in_loop {\n-                return;\n-            }\n-\n-            let sugg = format!(\n-                \"for {} in {} {{ .. }}\",\n-                snippet(cx, body.params[0].pat.span, \"..\"),\n-                snippet(cx, for_each_receiver.span, \"..\")\n-            );\n-\n-            span_lint_and_then(\n-                cx,\n-                EXCESSIVE_FOR_EACH,\n-                expr.span,\n-                \"excessive use of `for_each`\",\n-                |diag| {\n-                    diag.span_suggestion(expr.span, \"try\", sugg, Applicability::HasPlaceholders);\n-                    for span in ret_collector.spans {\n-                        diag.span_note(span, \"change `return` to `continue` in the loop body\");\n-                    }\n-                }\n-            )\n-        }\n-    }\n-}\n-\n-/// This type plays two roles.\n-/// 1. Collect spans of `return` in the closure body.\n-/// 2. Detect use of `return` in `Loop` in the closure body.\n-///\n-/// NOTE: The functionality of this type is similar to\n-/// [`crate::utilts::visitors::find_all_ret_expressions`], but we can't use\n-/// `find_all_ret_expressions` instead of this type. The reasons are:\n-/// 1. `find_all_ret_expressions` passes the argument of `ExprKind::Ret` to a callback, but what we\n-///    need here is `ExprKind::Ret` itself.\n-/// 2. We can't trace current loop depth with `find_all_ret_expressions`.\n-struct RetCollector {\n-    spans: Vec<Span>,\n-    ret_in_loop: bool,\n-\n-    loop_depth: u16,\n-}\n-\n-impl RetCollector {\n-    fn new() -> Self {\n-        Self {\n-            spans: Vec::new(),\n-            ret_in_loop: false,\n-            loop_depth: 0,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for RetCollector {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::Ret(..) => {\n-                if self.loop_depth > 0 && !self.ret_in_loop {\n-                    self.ret_in_loop = true\n-                }\n-\n-                self.spans.push(expr.span)\n-            },\n-\n-            ExprKind::Loop(..) => {\n-                self.loop_depth += 1;\n-                walk_expr(self, expr);\n-                self.loop_depth -= 1;\n-                return;\n-            },\n-\n-            _ => {},\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "fccdee078778e523e3ce3af6fa78dca9b366a46f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -974,33 +974,6 @@ declare_clippy_lint! {\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for use of `.method(..).for_each(closure)` if the reciever of `.method(..)` doesn't\n-    /// implement `Iterator` and the return type of `.method(..)` implements `Iterator`.\n-    ///\n-    /// **Why is this bad?** Excessive use of `for_each` reduces redability, using `for` loop is\n-    /// clearer and more concise.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let v = vec![0, 1, 2];\n-    /// v.iter().for_each(|elem| println!(\"{}\", elem));\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let v = vec![0, 1, 2];\n-    /// for elem in v.iter() {\n-    ///     println!(\"{}\", elem);\n-    /// }\n-    /// ```\n-    pub EXCESSIVE_FOR_EACH,\n-    restriction,\n-    \"using `.iter().for_each(|x| {..})` when using `for` loop would work instead\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `.get().unwrap()` (or\n     /// `.get_mut().unwrap`) on a standard library type which implements `Index`\n@@ -1688,7 +1661,6 @@ impl_lint_pass!(Methods => [\n     ITER_NTH_ZERO,\n     BYTES_NTH,\n     ITER_SKIP_NEXT,\n-    EXCESSIVE_FOR_EACH,\n     GET_UNWRAP,\n     STRING_EXTEND_CHARS,\n     ITER_CLONED_COLLECT,\n@@ -1835,7 +1807,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"to_os_string\", ..] => implicit_clone::check(cx, expr, sym::OsStr),\n             [\"to_path_buf\", ..] => implicit_clone::check(cx, expr, sym::Path),\n             [\"to_vec\", ..] => implicit_clone::check(cx, expr, sym::slice),\n-            [\"for_each\", ..] => excessive_for_each::lint(cx, expr, &arg_lists),\n             _ => {},\n         }\n "}, {"sha": "a7b0a1ca08209ca4609852571377d20d8dd2cefc", "filename": "clippy_lints/src/needless_for_each.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,170 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{source_map::Span, sym, Symbol};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{\n+    has_iter_method, is_diagnostic_assoc_item, method_calls, snippet_with_applicability, span_lint_and_then,\n+};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `for_each` that would be more simply written as a\n+    /// `for` loop.\n+    ///\n+    /// **Why is this bad?** `for_each` may be used after applying iterator transformers like\n+    /// `filter` for better readability and performance. It may also be used to fit a simple\n+    /// operation on one line.\n+    /// But when none of these apply, a simple `for` loop is more idiomatic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// v.iter().for_each(|elem| {\n+    ///     println!(\"{}\", elem);\n+    /// })\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// for elem in v.iter() {\n+    ///     println!(\"{}\", elem);\n+    /// }\n+    /// ```\n+    pub NEEDLESS_FOR_EACH,\n+    restriction,\n+    \"using `for_each` where a `for` loop would be simpler\"\n+}\n+\n+declare_lint_pass!(NeedlessForEach => [NEEDLESS_FOR_EACH]);\n+\n+impl LateLintPass<'_> for NeedlessForEach {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        let expr = match stmt.kind {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n+            StmtKind::Local(local) if local.init.is_some() => local.init.unwrap(),\n+            _ => return,\n+        };\n+\n+        // Max depth is set to 3 because we need to check the method chain length is just two.\n+        let (method_names, arg_lists, _) = method_calls(expr, 3);\n+\n+        if_chain! {\n+            // This assures the length of this method chain is two.\n+            if let [for_each_args, iter_args] = arg_lists.as_slice();\n+            if let Some(for_each_sym) = method_names.first();\n+            if *for_each_sym == Symbol::intern(\"for_each\");\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+            if is_diagnostic_assoc_item(cx, did, sym::Iterator);\n+            // Checks the type of the first method receiver is NOT a user defined type.\n+            if has_iter_method(cx, cx.typeck_results().expr_ty(&iter_args[0])).is_some();\n+            if let ExprKind::Closure(_, _, body_id, ..) = for_each_args[1].kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            // Skip the lint if the body is not block because this is simpler than `for` loop.\n+            // e.g. `v.iter().for_each(f)` is simpler and clearer than using `for` loop.\n+            if let ExprKind::Block(..) = body.value.kind;\n+            then {\n+                let mut ret_collector = RetCollector::default();\n+                ret_collector.visit_expr(&body.value);\n+\n+                // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n+                if ret_collector.ret_in_loop {\n+                    return;\n+                }\n+\n+                // We can't use `Applicability::MachineApplicable` when the closure contains `return`\n+                // because `Diagnostic::multipart_suggestion` doesn't work with multiple overlapped\n+                // spans.\n+                let mut applicability = if ret_collector.spans.is_empty() {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+\n+                let mut suggs = vec![];\n+                suggs.push((stmt.span, format!(\n+                    \"for {} in {} {}\",\n+                    snippet_with_applicability(cx, body.params[0].pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, for_each_args[0].span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, body.value.span, \"..\", &mut applicability),\n+                )));\n+\n+                for span in &ret_collector.spans {\n+                    suggs.push((*span, \"return\".to_string()));\n+                }\n+\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_FOR_EACH,\n+                    stmt.span,\n+                    \"needless use of `for_each`\",\n+                    |diag| {\n+                        diag.multipart_suggestion(\"try\", suggs, applicability);\n+                        // `Diagnostic::multipart_suggestion` ignores the second and subsequent overlapped spans,\n+                        // so `span_note` is needed here even though `suggs` includes the replacements.\n+                        for span in ret_collector.spans {\n+                            diag.span_note(span, \"replace `return` with `continue`\");\n+                        }\n+                    }\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+/// This type plays two roles.\n+/// 1. Collect spans of `return` in the closure body.\n+/// 2. Detect use of `return` in `Loop` in the closure body.\n+///\n+/// NOTE: The functionality of this type is similar to\n+/// [`crate::utilts::visitors::find_all_ret_expressions`], but we can't use\n+/// `find_all_ret_expressions` instead of this type. The reasons are:\n+/// 1. `find_all_ret_expressions` passes the argument of `ExprKind::Ret` to a callback, but what we\n+///    need here is `ExprKind::Ret` itself.\n+/// 2. We can't trace current loop depth with `find_all_ret_expressions`.\n+#[derive(Default)]\n+struct RetCollector {\n+    spans: Vec<Span>,\n+    ret_in_loop: bool,\n+    loop_depth: u16,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RetCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        match expr.kind {\n+            ExprKind::Ret(..) => {\n+                if self.loop_depth > 0 && !self.ret_in_loop {\n+                    self.ret_in_loop = true\n+                }\n+\n+                self.spans.push(expr.span)\n+            },\n+\n+            ExprKind::Loop(..) => {\n+                self.loop_depth += 1;\n+                walk_expr(self, expr);\n+                self.loop_depth -= 1;\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "0800bef71e9c8f91c6d2022781cff7bea58d308f", "filename": "tests/ui/excessive_for_each.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/tests%2Fui%2Fexcessive_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/tests%2Fui%2Fexcessive_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_for_each.rs?ref=5543c34699ea2723565c1d517b3d3d98cb9fd8d4", "patch": "@@ -1,126 +0,0 @@\n-#![warn(clippy::excessive_for_each)]\n-#![allow(clippy::needless_return)]\n-\n-use std::collections::*;\n-\n-fn main() {\n-    // Should trigger this lint: Vec.\n-    let vec: Vec<i32> = Vec::new();\n-    let mut acc = 0;\n-    vec.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: &Vec.\n-    let vec_ref = &vec;\n-    vec_ref.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: VecDeque.\n-    let vec_deq: VecDeque<i32> = VecDeque::new();\n-    vec_deq.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: LinkedList.\n-    let list: LinkedList<i32> = LinkedList::new();\n-    list.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: HashMap.\n-    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n-    hash_map.iter().for_each(|(k, v)| {\n-        acc += k + v;\n-    });\n-    hash_map.iter_mut().for_each(|(k, v)| {\n-        acc += *k + *v;\n-    });\n-    hash_map.keys().for_each(|k| {\n-        acc += k;\n-    });\n-    hash_map.values().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: HashSet.\n-    let hash_set: HashSet<i32> = HashSet::new();\n-    hash_set.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: BTreeSet.\n-    let btree_set: BTreeSet<i32> = BTreeSet::new();\n-    btree_set.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: BinaryHeap.\n-    let binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n-    binary_heap.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint: Array.\n-    let s = [1, 2, 3];\n-    s.iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint. Slice.\n-    vec.as_slice().iter().for_each(|v| {\n-        acc += v;\n-    });\n-\n-    // Should trigger this lint with notes that say \"change `return` to `continue`\".\n-    vec.iter().for_each(|v| {\n-        if *v == 10 {\n-            return;\n-        } else {\n-            println!(\"{}\", v);\n-        }\n-    });\n-\n-    // Should NOT trigger this lint in case `return` is used in `Loop` of the closure.\n-    vec.iter().for_each(|v| {\n-        for i in 0..*v {\n-            if i == 10 {\n-                return;\n-            } else {\n-                println!(\"{}\", v);\n-            }\n-        }\n-        if *v == 20 {\n-            return;\n-        } else {\n-            println!(\"{}\", v);\n-        }\n-    });\n-\n-    // Should NOT trigger this lint in case `for_each` follows long iterator chain.\n-    vec.iter().chain(vec.iter()).for_each(|v| println!(\"{}\", v));\n-\n-    // Should NOT trigger this lint in case a `for_each` argument is not closure.\n-    fn print(x: &i32) {\n-        println!(\"{}\", x);\n-    }\n-    vec.iter().for_each(print);\n-\n-    // Should NOT trigger this lint in case the receiver of `iter` is a user defined type.\n-    let my_collection = MyCollection { v: vec![] };\n-    my_collection.iter().for_each(|v| println!(\"{}\", v));\n-\n-    // Should NOT trigger this lint in case the closure body is not a `ExprKind::Block`.\n-    vec.iter().for_each(|x| acc += x);\n-}\n-\n-struct MyCollection {\n-    v: Vec<i32>,\n-}\n-\n-impl MyCollection {\n-    fn iter(&self) -> impl Iterator<Item = &i32> {\n-        self.v.iter()\n-    }\n-}"}, {"sha": "f5799484e03472ea0ee2c8709c035d6b8628c817", "filename": "tests/ui/excessive_for_each.stderr", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/tests%2Fui%2Fexcessive_for_each.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5543c34699ea2723565c1d517b3d3d98cb9fd8d4/tests%2Fui%2Fexcessive_for_each.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_for_each.stderr?ref=5543c34699ea2723565c1d517b3d3d98cb9fd8d4", "patch": "@@ -1,126 +0,0 @@\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:10:5\n-   |\n-LL | /     vec.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in vec.iter() { .. }`\n-   |\n-   = note: `-D clippy::excessive-for-each` implied by `-D warnings`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:16:5\n-   |\n-LL | /     vec_ref.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in vec_ref.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:22:5\n-   |\n-LL | /     vec_deq.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in vec_deq.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:28:5\n-   |\n-LL | /     list.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in list.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:34:5\n-   |\n-LL | /     hash_map.iter().for_each(|(k, v)| {\n-LL | |         acc += k + v;\n-LL | |     });\n-   | |______^ help: try: `for (k, v) in hash_map.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:37:5\n-   |\n-LL | /     hash_map.iter_mut().for_each(|(k, v)| {\n-LL | |         acc += *k + *v;\n-LL | |     });\n-   | |______^ help: try: `for (k, v) in hash_map.iter_mut() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:40:5\n-   |\n-LL | /     hash_map.keys().for_each(|k| {\n-LL | |         acc += k;\n-LL | |     });\n-   | |______^ help: try: `for k in hash_map.keys() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:43:5\n-   |\n-LL | /     hash_map.values().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in hash_map.values() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:49:5\n-   |\n-LL | /     hash_set.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in hash_set.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:55:5\n-   |\n-LL | /     btree_set.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in btree_set.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:61:5\n-   |\n-LL | /     binary_heap.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in binary_heap.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:67:5\n-   |\n-LL | /     s.iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in s.iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:72:5\n-   |\n-LL | /     vec.as_slice().iter().for_each(|v| {\n-LL | |         acc += v;\n-LL | |     });\n-   | |______^ help: try: `for v in vec.as_slice().iter() { .. }`\n-\n-error: excessive use of `for_each`\n-  --> $DIR/excessive_for_each.rs:77:5\n-   |\n-LL | /     vec.iter().for_each(|v| {\n-LL | |         if *v == 10 {\n-LL | |             return;\n-LL | |         } else {\n-LL | |             println!(\"{}\", v);\n-LL | |         }\n-LL | |     });\n-   | |______^ help: try: `for v in vec.iter() { .. }`\n-   |\n-note: change `return` to `continue` in the loop body\n-  --> $DIR/excessive_for_each.rs:79:13\n-   |\n-LL |             return;\n-   |             ^^^^^^\n-\n-error: aborting due to 14 previous errors\n-"}, {"sha": "0caa95a9f53fc97bce00ea906b9b3060b07dc9c1", "filename": "tests/ui/needless_for_each_fixable.fixed", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.fixed?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,99 @@\n+// run-rustfix\n+#![warn(clippy::needless_for_each)]\n+#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+\n+use std::collections::HashMap;\n+\n+fn should_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+    for elem in v.iter() {\n+        acc += elem;\n+    }\n+    for elem in v.into_iter() {\n+        acc += elem;\n+    }\n+\n+    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n+    for (k, v) in hash_map.iter() {\n+        acc += k + v;\n+    }\n+    for (k, v) in hash_map.iter_mut() {\n+        acc += *k + *v;\n+    }\n+    for k in hash_map.keys() {\n+        acc += k;\n+    }\n+    for v in hash_map.values() {\n+        acc += v;\n+    }\n+\n+    fn my_vec() -> Vec<i32> {\n+        Vec::new()\n+    }\n+    for elem in my_vec().iter() {\n+        acc += elem;\n+    }\n+}\n+\n+fn should_not_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+\n+    // `for_each` argument is not closure.\n+    fn print(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+    v.iter().for_each(print);\n+\n+    // `for_each` follows long iterator chain.\n+    v.iter().chain(v.iter()).for_each(|v| println!(\"{}\", v));\n+    v.as_slice().iter().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    // `return` is used in `Loop` of the closure.\n+    v.iter().for_each(|v| {\n+        for i in 0..*v {\n+            if i == 10 {\n+                return;\n+            } else {\n+                println!(\"{}\", v);\n+            }\n+        }\n+        if *v == 20 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // User defined type.\n+    struct MyStruct {\n+        v: Vec<i32>,\n+    }\n+    impl MyStruct {\n+        fn iter(&self) -> impl Iterator<Item = &i32> {\n+            self.v.iter()\n+        }\n+    }\n+    let s = MyStruct { v: Vec::new() };\n+    s.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // Previously transformed iterator variable.\n+    let it = v.iter();\n+    it.chain(v.iter()).for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` is not directly in a statement.\n+    match 1 {\n+        _ => v.iter().for_each(|elem| {\n+            acc += elem;\n+        }),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a04243de27a0eb5a7ed2c84a515977c3053fc33f", "filename": "tests/ui/needless_for_each_fixable.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.rs?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,99 @@\n+// run-rustfix\n+#![warn(clippy::needless_for_each)]\n+#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+\n+use std::collections::HashMap;\n+\n+fn should_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+    v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+    v.into_iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n+    hash_map.iter().for_each(|(k, v)| {\n+        acc += k + v;\n+    });\n+    hash_map.iter_mut().for_each(|(k, v)| {\n+        acc += *k + *v;\n+    });\n+    hash_map.keys().for_each(|k| {\n+        acc += k;\n+    });\n+    hash_map.values().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    fn my_vec() -> Vec<i32> {\n+        Vec::new()\n+    }\n+    my_vec().iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+}\n+\n+fn should_not_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+\n+    // `for_each` argument is not closure.\n+    fn print(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+    v.iter().for_each(print);\n+\n+    // `for_each` follows long iterator chain.\n+    v.iter().chain(v.iter()).for_each(|v| println!(\"{}\", v));\n+    v.as_slice().iter().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    // `return` is used in `Loop` of the closure.\n+    v.iter().for_each(|v| {\n+        for i in 0..*v {\n+            if i == 10 {\n+                return;\n+            } else {\n+                println!(\"{}\", v);\n+            }\n+        }\n+        if *v == 20 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // User defined type.\n+    struct MyStruct {\n+        v: Vec<i32>,\n+    }\n+    impl MyStruct {\n+        fn iter(&self) -> impl Iterator<Item = &i32> {\n+            self.v.iter()\n+        }\n+    }\n+    let s = MyStruct { v: Vec::new() };\n+    s.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // Previously transformed iterator variable.\n+    let it = v.iter();\n+    it.chain(v.iter()).for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` is not directly in a statement.\n+    match 1 {\n+        _ => v.iter().for_each(|elem| {\n+            acc += elem;\n+        }),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "214e357a2080fb0d5626e39ccfc15ec9da0a709d", "filename": "tests/ui/needless_for_each_fixable.stderr", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.stderr?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,108 @@\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:10:5\n+   |\n+LL | /     v.iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+   = note: `-D clippy::needless-for-each` implied by `-D warnings`\n+help: try\n+   |\n+LL |     for elem in v.iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:13:5\n+   |\n+LL | /     v.into_iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for elem in v.into_iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:18:5\n+   |\n+LL | /     hash_map.iter().for_each(|(k, v)| {\n+LL | |         acc += k + v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for (k, v) in hash_map.iter() {\n+LL |         acc += k + v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:21:5\n+   |\n+LL | /     hash_map.iter_mut().for_each(|(k, v)| {\n+LL | |         acc += *k + *v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for (k, v) in hash_map.iter_mut() {\n+LL |         acc += *k + *v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:24:5\n+   |\n+LL | /     hash_map.keys().for_each(|k| {\n+LL | |         acc += k;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for k in hash_map.keys() {\n+LL |         acc += k;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:27:5\n+   |\n+LL | /     hash_map.values().for_each(|v| {\n+LL | |         acc += v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for v in hash_map.values() {\n+LL |         acc += v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:34:5\n+   |\n+LL | /     my_vec().iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for elem in my_vec().iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "d765d7dab65c90c26571df73ef9fac4743c1cbdf", "filename": "tests/ui/needless_for_each_unfixable.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_unfixable.rs?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,14 @@\n+#![warn(clippy::needless_for_each)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let v: Vec<i32> = Vec::new();\n+    // This is unfixable because the closure includes `return`.\n+    v.iter().for_each(|v| {\n+        if *v == 10 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+}"}, {"sha": "58d107062bcbd43e31b76f263b6b83d3354e523d", "filename": "tests/ui/needless_for_each_unfixable.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/527fbbef486bab32a95209b638b097a14ff41db0/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_unfixable.stderr?ref=527fbbef486bab32a95209b638b097a14ff41db0", "patch": "@@ -0,0 +1,30 @@\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_unfixable.rs:7:5\n+   |\n+LL | /     v.iter().for_each(|v| {\n+LL | |         if *v == 10 {\n+LL | |             return;\n+LL | |         } else {\n+LL | |             println!(\"{}\", v);\n+LL | |         }\n+LL | |     });\n+   | |_______^\n+   |\n+   = note: `-D clippy::needless-for-each` implied by `-D warnings`\n+note: replace `return` with `continue`\n+  --> $DIR/needless_for_each_unfixable.rs:9:13\n+   |\n+LL |             return;\n+   |             ^^^^^^\n+help: try\n+   |\n+LL |     for v in v.iter() {\n+LL |         if *v == 10 {\n+LL |             return;\n+LL |         } else {\n+LL |             println!(\"{}\", v);\n+LL |         }\n+ ...\n+\n+error: aborting due to previous error\n+"}]}