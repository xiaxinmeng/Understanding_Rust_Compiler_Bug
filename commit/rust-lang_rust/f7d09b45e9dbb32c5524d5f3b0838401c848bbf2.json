{"sha": "f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZDA5YjQ1ZTlkYmIzMmM1NTI0ZDVmM2IwODM4NDAxYzg0OGJiZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-10T05:20:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-10T05:20:56Z"}, "message": "Auto merge of #7333 - camsteffen:match-var, r=llogiq\n\nFactor out match_var and get_pat_name utils\n\n...because checking vars by name is bad, because of shadowing.\n\nchangelog: none", "tree": {"sha": "cab02750410bc1137a24f16407f98f9f81fd19d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cab02750410bc1137a24f16407f98f9f81fd19d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "html_url": "https://github.com/rust-lang/rust/commit/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce7b872341286b358b5c07106497735ce477f7e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce7b872341286b358b5c07106497735ce477f7e1", "html_url": "https://github.com/rust-lang/rust/commit/ce7b872341286b358b5c07106497735ce477f7e1"}, {"sha": "b792bb301c66e271d88d2e579ec79fec153b7b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/b792bb301c66e271d88d2e579ec79fec153b7b89", "html_url": "https://github.com/rust-lang/rust/commit/b792bb301c66e271d88d2e579ec79fec153b7b89"}], "stats": {"total": 236, "additions": 92, "deletions": 144}, "files": [{"sha": "4f7ffdcdfb499ac972c9dbd9eeced0153b492ddc", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "patch": "@@ -1,15 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{contains_name, get_pat_name, paths, single_segment_path};\n+use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n-use rustc_span::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for naive byte counts\n@@ -38,42 +38,43 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(count, _, count_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(count, _, [count_recv], _) = expr.kind;\n             if count.ident.name == sym!(count);\n-            if count_args.len() == 1;\n-            if let ExprKind::MethodCall(filter, _, filter_args, _) = count_args[0].kind;\n+            if let ExprKind::MethodCall(filter, _, [filter_recv, filter_arg], _) = count_recv.kind;\n             if filter.ident.name == sym!(filter);\n-            if filter_args.len() == 2;\n-            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_arg.kind;\n             let body = cx.tcx.hir().body(body_id);\n-            if body.params.len() == 1;\n-            if let Some(argname) = get_pat_name(body.params[0].pat);\n+            if let [param] = body.params;\n+            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n             if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n             if op.node == BinOpKind::Eq;\n             if match_type(cx,\n-                       cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n+                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n                        &paths::SLICE_ITER);\n+            let operand_is_arg = |expr| {\n+                let expr = peel_ref_operators(cx, remove_blocks(expr));\n+                path_to_local_id(expr, arg_id)\n+            };\n+            let needle = if operand_is_arg(l) {\n+                r\n+            } else if operand_is_arg(r) {\n+                l\n+            } else {\n+                return;\n+            };\n+            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n             then {\n-                let needle = match get_path_name(l) {\n-                    Some(name) if check_arg(name, argname, r) => r,\n-                    _ => match get_path_name(r) {\n-                        Some(name) if check_arg(name, argname, l) => l,\n-                        _ => { return; }\n-                    }\n-                };\n-                if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n-                    return;\n-                }\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n-                        filter_args[0].kind {\n+                        filter_recv.kind {\n                     let p = path.ident.name;\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                         &args[0]\n                     } else {\n-                        &filter_args[0]\n+                        &filter_recv\n                     }\n                 } else {\n-                    &filter_args[0]\n+                    &filter_recv\n                 };\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 span_lint_and_sugg(\n@@ -91,24 +92,3 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n         };\n     }\n }\n-\n-fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n-    name == arg && !contains_name(name, needle)\n-}\n-\n-fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n-    match expr.kind {\n-        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) | ExprKind::Unary(UnOp::Deref, e) => {\n-            get_path_name(e)\n-        },\n-        ExprKind::Block(b, _) => {\n-            if b.stmts.is_empty() {\n-                b.expr.as_ref().and_then(|p| get_path_name(p))\n-            } else {\n-                None\n-            }\n-        },\n-        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        _ => None,\n-    }\n-}"}, {"sha": "a6c3a5b0e83c466bc8b98f14e55ca7070a876da1", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{is_lang_ctor, path_to_local, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind, UnOp};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -73,7 +72,7 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         if arms_inner.iter().all(|arm| arm.guard.is_none());\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n         // one of the branches must be \"wild-like\"\n         if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n         let (wild_inner_arm, non_wild_inner_arm) =\n@@ -163,16 +162,3 @@ fn pat_contains_or(pat: &Pat<'_>) -> bool {\n     });\n     result\n }\n-\n-/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n-/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n-fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {\n-    loop {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, e) => expr = e,\n-            ExprKind::Unary(UnOp::Deref, e) if typeck_results.expr_ty(e).is_ref() => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}"}, {"sha": "97e4a983f32ea3ca4542d17cf63223d2aeca2303", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "patch": "@@ -3,19 +3,17 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, path_to_local_id,\n+    peel_hir_expr_refs,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{\n-    symbol::{sym, Ident},\n-    SyntaxContext,\n-};\n+use rustc_span::{sym, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n@@ -141,13 +139,13 @@ impl LateLintPass<'_> for ManualMap {\n                     scrutinee_str.into()\n                 };\n \n-            let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, some_binding, some_expr) {\n+            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+                match can_pass_as_func(cx, id, some_expr) {\n                     Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n                         snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n                     },\n                     _ => {\n-                        if match_var(some_expr, some_binding.name)\n+                        if path_to_local_id(some_expr, id)\n                             && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                             && binding_ref.is_some()\n                         {\n@@ -199,10 +197,10 @@ impl LateLintPass<'_> for ManualMap {\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if match_var(arg, binding.name) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },"}, {"sha": "66e75b0c20638e8d89f50c9495fb9b3b57793c23", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "patch": "@@ -72,7 +72,7 @@ use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n     ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -326,16 +326,6 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n         .map_or(false, |did| is_diag_trait_item(cx, did, diag_item))\n }\n \n-/// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n-        if let [p] = path.segments {\n-            return p.ident.name == var;\n-        }\n-    }\n-    false\n-}\n-\n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n@@ -707,16 +697,6 @@ pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     }\n }\n \n-/// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(p) | PatKind::Ref(p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n pub struct ContainsName {\n     pub name: Symbol,\n     pub result: bool,\n@@ -1404,47 +1384,42 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// Checks if an expression represents the identity function\n /// Only examines closures and `std::convert::identity`\n pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    /// Returns true if the expression is a binding to the given pattern\n-    fn is_expr_pat_binding(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n-        if let PatKind::Binding(_, _, ident, _) = pat.kind {\n-            if match_var(expr, ident.name) {\n-                return !(cx.typeck_results().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr));\n-            }\n-        }\n-\n-        false\n-    }\n-\n     /// Checks if a function's body represents the identity function. Looks for bodies of the form:\n     /// * `|x| x`\n     /// * `|x| return x`\n     /// * `|x| { return x }`\n     /// * `|x| { return x; }`\n     fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n-        let body = remove_blocks(&func.value);\n-\n-        let value_pat = if let [value_param] = func.params {\n-            value_param.pat\n-        } else {\n-            return false;\n+        let id = if_chain! {\n+            if let [param] = func.params;\n+            if let PatKind::Binding(_, id, _, _) = param.pat.kind;\n+            then {\n+                id\n+            } else {\n+                return false;\n+            }\n         };\n \n-        match body.kind {\n-            ExprKind::Path(QPath::Resolved(None, _)) => is_expr_pat_binding(cx, body, value_pat),\n-            ExprKind::Ret(Some(ret_val)) => is_expr_pat_binding(cx, ret_val, value_pat),\n-            ExprKind::Block(block, _) => {\n-                if_chain! {\n-                    if let &[block_stmt] = &block.stmts;\n-                    if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = block_stmt.kind;\n-                    if let ExprKind::Ret(Some(ret_val)) = expr.kind;\n-                    then {\n-                        is_expr_pat_binding(cx, ret_val, value_pat)\n-                    } else {\n-                        false\n+        let mut expr = &func.value;\n+        loop {\n+            match expr.kind {\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [], expr: Some(e), .. }, _, )\n+                | ExprKind::Ret(Some(e)) => expr = e,\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [stmt], expr: None, .. }, _) => {\n+                    if_chain! {\n+                        if let StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind;\n+                        if let ExprKind::Ret(Some(ret_val)) = e.kind;\n+                        then {\n+                            expr = ret_val;\n+                        } else {\n+                            return false;\n+                        }\n                     }\n-                }\n-            },\n-            _ => false,\n+                },\n+                _ => return path_to_local_id(expr, id) && cx.typeck_results().expr_adjustments(expr).is_empty(),\n+            }\n         }\n     }\n \n@@ -1710,6 +1685,19 @@ pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n+/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n+pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    loop {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, e) => expr = e,\n+            ExprKind::Unary(UnOp::Deref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "8adb691595213fd80cd036f1aa50fa20cadd97a1", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d09b45e9dbb32c5524d5f3b0838401c848bbf2/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=f7d09b45e9dbb32c5524d5f3b0838401c848bbf2", "patch": "@@ -1,10 +1,10 @@\n use crate::source::snippet;\n-use crate::{get_pat_name, match_var};\n+use crate::{path_to_local_id, strip_pat_refs};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n+use rustc_hir::{Body, BodyId, Expr, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use std::borrow::Cow;\n \n pub fn get_spans(\n@@ -14,24 +14,25 @@ pub fn get_spans(\n     replacements: &[(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     if let Some(body) = opt_body_id.map(|id| cx.tcx.hir().body(id)) {\n-        get_binding_name(&body.params[idx]).map_or_else(\n-            || Some(vec![]),\n-            |name| extract_clone_suggestions(cx, name, replacements, body),\n-        )\n+        if let PatKind::Binding(_, binding_id, _, _) = strip_pat_refs(body.params[idx].pat).kind {\n+            extract_clone_suggestions(cx, binding_id, replacements, body)\n+        } else {\n+            Some(vec![])\n+        }\n     } else {\n         Some(vec![])\n     }\n }\n \n fn extract_clone_suggestions<'tcx>(\n     cx: &LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     let mut visitor = PtrCloneVisitor {\n         cx,\n-        name,\n+        id,\n         replace,\n         spans: vec![],\n         abort: false,\n@@ -42,7 +43,7 @@ fn extract_clone_suggestions<'tcx>(\n \n struct PtrCloneVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &'a [(&'static str, &'static str)],\n     spans: Vec<(Span, Cow<'static, str>)>,\n     abort: bool,\n@@ -55,16 +56,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(seg, _, args, _) = expr.kind {\n-            if args.len() == 1 && match_var(&args[0], self.name) {\n+        if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n+            if path_to_local_id(recv, self.id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n                     return;\n                 }\n                 for &(fn_name, suffix) in self.replace {\n                     if seg.ident.name.as_str() == fn_name {\n-                        self.spans\n-                            .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n+                        self.spans.push((expr.span, snippet(self.cx, recv.span, \"_\") + suffix));\n                         return;\n                     }\n                 }\n@@ -77,7 +77,3 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-fn get_binding_name(arg: &Param<'_>) -> Option<Symbol> {\n-    get_pat_name(arg.pat)\n-}"}]}