{"sha": "4ecc85beb339aa8089d936e450b0d800bdf580ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlY2M4NWJlYjMzOWFhODA4OWQ5MzZlNDUwYjBkODAwYmRmNTgwYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-28T20:19:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-28T20:19:39Z"}, "message": "Auto merge of #38449 - eddyb:lazy-10, r=nikomatsakis\n\n[10/n] Split constants and functions' arguments into disjoint bodies.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/38053) | [next]()) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nFinishes the signature-body split started in #37918, namely:\n* `trait` items are separated just like `impl` items were, for uniformity, closing #37712\n* `static`s, `const`s (including associated ones), `enum` discriminants and array lengths get bodies\n  * even the count in \"repeat expressions\", i.e. `n` in `[x; n]`, which fixes #24414\n* arguments' patterns are moved to the bodies, with the types staying in `FnDecl`\n  * `&self` now desugars to `self: &Self` instead of `self: &_` (similarly for other `self` forms)\n  * `astconv`'s and metadata's (for rustdoc) informative uses are explicitly ignored for the purposes of the dep graph. this could be fixed in the future by hashing the exact information being extracted about the arguments as opposed to generating a dependency on *the whole body*", "tree": {"sha": "361b71fea58b9738649230009fe54f4643c9f188", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/361b71fea58b9738649230009fe54f4643c9f188"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ecc85beb339aa8089d936e450b0d800bdf580ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecc85beb339aa8089d936e450b0d800bdf580ae", "html_url": "https://github.com/rust-lang/rust/commit/4ecc85beb339aa8089d936e450b0d800bdf580ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ecc85beb339aa8089d936e450b0d800bdf580ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417", "html_url": "https://github.com/rust-lang/rust/commit/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417"}, {"sha": "ee0ea9534317466307c85e6a855e13370d37260d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0ea9534317466307c85e6a855e13370d37260d", "html_url": "https://github.com/rust-lang/rust/commit/ee0ea9534317466307c85e6a855e13370d37260d"}], "stats": {"total": 5037, "additions": 2280, "deletions": 2757}, "files": [{"sha": "4d66bba9f07ee6b135b33b57e63f08ec59cb6aa3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -327,10 +327,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.opt_expr(base, field_cfg)\n             }\n \n-            hir::ExprRepeat(ref elem, ref count) => {\n-                self.straightline(expr, pred, [elem, count].iter().map(|&e| &**e))\n-            }\n-\n             hir::ExprAssign(ref l, ref r) |\n             hir::ExprAssignOp(_, ref l, ref r) => {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n@@ -347,7 +343,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprType(ref e, _) |\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n-            hir::ExprTupField(ref e, _) => {\n+            hir::ExprTupField(ref e, _) |\n+            hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n "}, {"sha": "26e1dc7e0490c21f826b4657e67d13c04c4c8e81", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -51,6 +51,12 @@ impl DepGraph {\n         }\n     }\n \n+    /// True if we are actually building the full dep-graph.\n+    #[inline]\n+    pub fn is_fully_enabled(&self) -> bool {\n+        self.data.thread.is_fully_enabled()\n+    }\n+\n     pub fn query(&self) -> DepGraphQuery<DefId> {\n         self.data.thread.query()\n     }"}, {"sha": "1990574ca9a831d3232c95b282cb854e97333f59", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -45,6 +45,16 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             debug!(\"Ended task {:?}\", task_id);\n         }\n \n+        fn visit_trait_item(&mut self, i: &'tcx hir::TraitItem) {\n+            let trait_item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(trait_item_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n+            debug!(\"Started task {:?}\", task_id);\n+            self.tcx.dep_graph.read(DepNode::Hir(trait_item_def_id));\n+            self.visitor.visit_trait_item(i);\n+            debug!(\"Ended task {:?}\", task_id);\n+        }\n+\n         fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n             let impl_item_def_id = self.tcx.map.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(impl_item_def_id);"}, {"sha": "4b171193b4af17f54dddbd2807f06a561daf1175", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -177,6 +177,17 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n+    /// Like `visit_nested_item()`, but for trait items. See\n+    /// `visit_nested_item()` for advice on when to override this\n+    /// method.\n+    #[allow(unused_variables)]\n+    fn visit_nested_trait_item(&mut self, id: TraitItemId) {\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.trait_item(id));\n+        if let Some(item) = opt_item {\n+            self.visit_trait_item(item);\n+        }\n+    }\n+\n     /// Like `visit_nested_item()`, but for impl items. See\n     /// `visit_nested_item()` for advice on when to override this\n     /// method.\n@@ -192,10 +203,10 @@ pub trait Visitor<'v> : Sized {\n     /// visit_nested_item, does nothing by default unless you override\n     /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n     /// body.\n-    fn visit_body(&mut self, id: ExprId) {\n-        let opt_expr = self.nested_visit_map().intra().map(|map| map.expr(id));\n-        if let Some(expr) = opt_expr {\n-            self.visit_expr(expr);\n+    fn visit_nested_body(&mut self, id: BodyId) {\n+        let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n+        if let Some(body) = opt_body {\n+            self.visit_body(body);\n         }\n     }\n \n@@ -205,6 +216,10 @@ pub trait Visitor<'v> : Sized {\n         walk_item(self, i)\n     }\n \n+    fn visit_body(&mut self, b: &'v Body) {\n+        walk_body(self, b);\n+    }\n+\n     /// When invoking `visit_all_item_likes()`, you need to supply an\n     /// item-like visitor.  This method converts a \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n@@ -253,8 +268,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_expr(&mut self, ex: &'v Expr) {\n         walk_expr(self, ex)\n     }\n-    fn visit_expr_post(&mut self, _ex: &'v Expr) {\n-    }\n     fn visit_ty(&mut self, t: &'v Ty) {\n         walk_ty(self, t)\n     }\n@@ -267,12 +280,15 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: ExprId, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n         walk_trait_item(self, ti)\n     }\n+    fn visit_trait_item_ref(&mut self, ii: &'v TraitItemRef) {\n+        walk_trait_item_ref(self, ii)\n+    }\n     fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n         walk_impl_item(self, ii)\n     }\n@@ -378,6 +394,14 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_node_i\n     }\n }\n \n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n+    for argument in &body.arguments {\n+        visitor.visit_id(argument.id);\n+        visitor.visit_pat(&argument.pat);\n+    }\n+    visitor.visit_expr(&body.value);\n+}\n+\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n@@ -423,11 +447,11 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_path(path, item.id);\n         }\n-        ItemStatic(ref typ, _, ref expr) |\n-        ItemConst(ref typ, ref expr) => {\n+        ItemStatic(ref typ, _, body) |\n+        ItemConst(ref typ, body) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n@@ -469,21 +493,19 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n-            for impl_item_ref in impl_item_refs {\n-                visitor.visit_impl_item_ref(impl_item_ref);\n-            }\n+            walk_list!(visitor, visit_impl_item_ref, impl_item_refs);\n         }\n         ItemStruct(ref struct_definition, ref generics) |\n         ItemUnion(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n         }\n-        ItemTrait(_, ref generics, ref bounds, ref methods) => {\n+        ItemTrait(_, ref generics, ref bounds, ref trait_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n-            walk_list!(visitor, visit_trait_item, methods);\n+            walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n@@ -511,7 +533,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_nested_body, variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n@@ -544,18 +566,18 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyArray(ref ty, ref expression) => {\n+        TyArray(ref ty, length) => {\n             visitor.visit_ty(ty);\n-            visitor.visit_expr(expression)\n+            visitor.visit_nested_body(length)\n         }\n         TyPolyTraitRef(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyTypeof(ref expression) => {\n-            visitor.visit_expr(expression)\n+        TyTypeof(expression) => {\n+            visitor.visit_nested_body(expression)\n         }\n         TyInfer => {}\n     }\n@@ -662,9 +684,12 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n-        ForeignItemFn(ref function_declaration, ref generics) => {\n+        ForeignItemFn(ref function_declaration, ref names, ref generics) => {\n+            visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n-            visitor.visit_generics(generics)\n+            for name in names {\n+                visitor.visit_name(name.span, name.node);\n+            }\n         }\n         ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n     }\n@@ -732,18 +757,8 @@ pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionR\n }\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for argument in &function_declaration.inputs {\n-        visitor.visit_id(argument.id);\n-        visitor.visit_pat(&argument.pat);\n-        visitor.visit_ty(&argument.ty)\n-    }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n-}\n-\n-pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for argument in &function_declaration.inputs {\n-        visitor.visit_id(argument.id);\n-        visitor.visit_ty(&argument.ty)\n+    for ty in &function_declaration.inputs {\n+        visitor.visit_ty(ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n@@ -763,42 +778,33 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   body_id: ExprId,\n+                                   body_id: BodyId,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     visitor.visit_fn_decl(function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_body(body_id)\n-}\n-\n-pub fn walk_fn_with_body<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             function_kind: FnKind<'v>,\n-                                             function_declaration: &'v FnDecl,\n-                                             body: &'v Expr,\n-                                             _span: Span,\n-                                             id: NodeId) {\n-    visitor.visit_id(id);\n-    visitor.visit_fn_decl(function_declaration);\n-    walk_fn_kind(visitor, function_kind);\n-    visitor.visit_expr(body)\n+    visitor.visit_nested_body(body_id)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_name(trait_item.span, trait_item.name);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n-        ConstTraitItem(ref ty, ref default) => {\n+        TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(trait_item.id);\n             visitor.visit_ty(ty);\n-            walk_list!(visitor, visit_expr, default);\n+            walk_list!(visitor, visit_nested_body, default);\n         }\n-        MethodTraitItem(ref sig, None) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(ref names)) => {\n             visitor.visit_id(trait_item.id);\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_fn_decl(&sig.decl);\n+            for name in names {\n+                visitor.visit_name(name.span, name.node);\n+            }\n         }\n-        MethodTraitItem(ref sig, Some(body_id)) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Provided(body_id)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.name,\n                                             sig,\n                                             None,\n@@ -808,14 +814,23 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              trait_item.span,\n                              trait_item.id);\n         }\n-        TypeTraitItem(ref bounds, ref default) => {\n+        TraitItemKind::Type(ref bounds, ref default) => {\n             visitor.visit_id(trait_item.id);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n     }\n }\n \n+pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref: &'v TraitItemRef) {\n+    // NB: Deliberately force a compilation error if/when new fields are added.\n+    let TraitItemRef { id, name, ref kind, span, ref defaultness } = *trait_item_ref;\n+    visitor.visit_nested_trait_item(id);\n+    visitor.visit_name(span, name);\n+    visitor.visit_associated_item_kind(kind);\n+    visitor.visit_defaultness(defaultness);\n+}\n+\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n     let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n@@ -825,10 +840,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n     match *node {\n-        ImplItemKind::Const(ref ty, ref expr) => {\n+        ImplItemKind::Const(ref ty, body) => {\n             visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         }\n         ImplItemKind::Method(ref sig, body_id) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n@@ -907,9 +922,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprArray(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprRepeat(ref element, count) => {\n             visitor.visit_expr(element);\n-            visitor.visit_expr(count)\n+            visitor.visit_nested_body(count)\n         }\n         ExprStruct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n@@ -1016,8 +1031,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n         }\n     }\n-\n-    visitor.visit_expr_post(expression)\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n@@ -1100,16 +1113,3 @@ impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n         self.result.add(id);\n     }\n }\n-\n-/// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n-                                        decl: &'v FnDecl,\n-                                        body: &'v Expr,\n-                                        sp: Span,\n-                                        id: NodeId,\n-                                        map: &map::Map<'v>)\n-                                        -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new(map);\n-    walk_fn_with_body(&mut visitor, fk, decl, body, sp, id);\n-    visitor.result()\n-}"}, {"sha": "f359ca2016359ef85cf04f58d9ee2c1e7d67f3b4", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{Item, ImplItem};\n+use super::{Item, ImplItem, TraitItem};\n use super::intravisit::Visitor;\n \n /// The \"item-like visitor\" visitor defines only the top-level methods\n@@ -58,6 +58,7 @@ use super::intravisit::Visitor;\n /// needed.\n pub trait ItemLikeVisitor<'hir> {\n     fn visit_item(&mut self, item: &'hir Item);\n+    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem);\n     fn visit_impl_item(&mut self, impl_item: &'hir ImplItem);\n }\n \n@@ -80,6 +81,10 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n         self.visitor.visit_item(item);\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem) {\n+        self.visitor.visit_trait_item(trait_item);\n+    }\n+\n     fn visit_impl_item(&mut self, impl_item: &'hir ImplItem) {\n         self.visitor.visit_impl_item(impl_item);\n     }"}, {"sha": "9a2658f48f3d91f2cf7236120cd9b072c7febc3c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 122, "deletions": 59, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -46,12 +46,10 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::NodeMap;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use util::nodemap::{NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n-use std::mem;\n \n use syntax::ast::*;\n use syntax::errors;\n@@ -71,13 +69,14 @@ pub struct LoweringContext<'a> {\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n-    exprs: FnvHashMap<hir::ExprId, hir::Expr>,\n     resolver: &'a mut Resolver,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n \n+    trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n+    bodies: FxHashMap<hir::BodyId, hir::Body>,\n }\n \n pub trait Resolver {\n@@ -105,10 +104,11 @@ pub fn lower_crate(sess: &Session,\n         crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n-        exprs: FnvHashMap(),\n         resolver: resolver,\n         items: BTreeMap::new(),\n+        trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n+        bodies: FxHashMap(),\n     }.lower_crate(krate)\n }\n \n@@ -133,8 +133,9 @@ impl<'a> LoweringContext<'a> {\n             span: c.span,\n             exported_macros: exported_macros,\n             items: self.items,\n+            trait_items: self.trait_items,\n             impl_items: self.impl_items,\n-            exprs: mem::replace(&mut self.exprs, FnvHashMap()),\n+            bodies: self.bodies,\n         }\n     }\n \n@@ -150,8 +151,15 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_item(self, item);\n             }\n \n+            fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n+                let id = hir::TraitItemId { node_id: item.id };\n+                let hir_item = self.lctx.lower_trait_item(item);\n+                self.lctx.trait_items.insert(id, hir_item);\n+                visit::walk_trait_item(self, item);\n+            }\n+\n             fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n-                let id = self.lctx.lower_impl_item_ref(item).id;\n+                let id = hir::ImplItemId { node_id: item.id };\n                 let hir_item = self.lctx.lower_impl_item(item);\n                 self.lctx.impl_items.insert(id, hir_item);\n                 visit::walk_impl_item(self, item);\n@@ -162,9 +170,16 @@ impl<'a> LoweringContext<'a> {\n         visit::walk_crate(&mut item_lowerer, c);\n     }\n \n-    fn record_expr(&mut self, expr: hir::Expr) -> hir::ExprId {\n-        let id = hir::ExprId(expr.id);\n-        self.exprs.insert(id, expr);\n+    fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n+                   -> hir::BodyId {\n+        let body = hir::Body {\n+            arguments: decl.map_or(hir_vec![], |decl| {\n+                decl.inputs.iter().map(|x| self.lower_arg(x)).collect()\n+            }),\n+            value: value\n+        };\n+        let id = body.id();\n+        self.bodies.insert(id, body);\n         id\n     }\n \n@@ -259,7 +274,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                TyKind::Infer | TyKind::ImplicitSelf => hir::TyInfer,\n+                TyKind::Infer => hir::TyInfer,\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n@@ -283,14 +298,27 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Path(ref qself, ref path) => {\n                     hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n                 }\n+                TyKind::ImplicitSelf => {\n+                    hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n+                        def: self.expect_full_def(t.id),\n+                        segments: hir_vec![hir::PathSegment {\n+                            name: keywords::SelfType.name(),\n+                            parameters: hir::PathParameters::none()\n+                        }],\n+                        span: t.span,\n+                    })))\n+                }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n-                TyKind::Array(ref ty, ref e) => {\n-                    hir::TyArray(self.lower_ty(ty), P(self.lower_expr(e)))\n+                TyKind::Array(ref ty, ref length) => {\n+                    let length = self.lower_expr(length);\n+                    hir::TyArray(self.lower_ty(ty),\n+                                 self.record_body(length, None))\n                 }\n                 TyKind::Typeof(ref expr) => {\n-                    hir::TyTypeof(P(self.lower_expr(expr)))\n+                    let expr = self.lower_expr(expr);\n+                    hir::TyTypeof(self.record_body(expr, None))\n                 }\n                 TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n@@ -317,7 +345,10 @@ impl<'a> LoweringContext<'a> {\n                 name: v.node.name.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| P(self.lower_expr(e))),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| {\n+                    let e = self.lower_expr(e);\n+                    self.record_body(e, None)\n+                }),\n             },\n             span: v.span,\n         }\n@@ -505,13 +536,24 @@ impl<'a> LoweringContext<'a> {\n         hir::Arg {\n             id: arg.id,\n             pat: self.lower_pat(&arg.pat),\n-            ty: self.lower_ty(&arg.ty),\n         }\n     }\n \n+    fn lower_fn_args_to_names(&mut self, decl: &FnDecl)\n+                              -> hir::HirVec<Spanned<Name>> {\n+        decl.inputs.iter().map(|arg| {\n+            match arg.pat.node {\n+                PatKind::Ident(_, ident, None) => {\n+                    respan(ident.span, ident.node.name)\n+                }\n+                _ => respan(arg.pat.span, keywords::Invalid.name()),\n+            }\n+        }).collect()\n+    }\n+\n     fn lower_fn_decl(&mut self, decl: &FnDecl) -> P<hir::FnDecl> {\n         P(hir::FnDecl {\n-            inputs: decl.inputs.iter().map(|x| self.lower_arg(x)).collect(),\n+            inputs: decl.inputs.iter().map(|arg| self.lower_ty(&arg.ty)).collect(),\n             output: match decl.output {\n                 FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n@@ -839,17 +881,20 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n+                let value = self.lower_expr(e);\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                P(self.lower_expr(e)))\n+                                self.record_body(value, None))\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                hir::ItemConst(self.lower_ty(t), P(self.lower_expr(e)))\n+                let value = self.lower_expr(e);\n+                hir::ItemConst(self.lower_ty(t),\n+                               self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n                 let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_expr(body);\n+                let body_id = self.record_body(body, Some(decl));\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n@@ -897,7 +942,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Trait(unsafety, ref generics, ref bounds, ref items) => {\n                 let bounds = self.lower_bounds(bounds);\n-                let items = items.iter().map(|item| self.lower_trait_item(item)).collect();\n+                let items = items.iter().map(|item| self.lower_trait_item_ref(item)).collect();\n                 hir::ItemTrait(self.lower_unsafety(unsafety),\n                                self.lower_generics(generics),\n                                bounds,\n@@ -915,20 +960,27 @@ impl<'a> LoweringContext<'a> {\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n-                        hir::ConstTraitItem(this.lower_ty(ty),\n-                                            default.as_ref().map(|x| P(this.lower_expr(x))))\n-                    }\n-                    TraitItemKind::Method(ref sig, ref body) => {\n-                        hir::MethodTraitItem(this.lower_method_sig(sig),\n-                                             body.as_ref().map(|x| {\n-                            let body = this.lower_block(x);\n-                            let expr = this.expr_block(body, ThinVec::new());\n-                            this.record_expr(expr)\n+                        hir::TraitItemKind::Const(this.lower_ty(ty),\n+                                                  default.as_ref().map(|x| {\n+                            let value = this.lower_expr(x);\n+                            this.record_body(value, None)\n                         }))\n                     }\n+                    TraitItemKind::Method(ref sig, None) => {\n+                        let names = this.lower_fn_args_to_names(&sig.decl);\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                                                   hir::TraitMethod::Required(names))\n+                    }\n+                    TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                        let body = this.lower_block(body);\n+                        let expr = this.expr_block(body, ThinVec::new());\n+                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                                                   hir::TraitMethod::Provided(body_id))\n+                    }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n-                        hir::TypeTraitItem(this.lower_bounds(bounds),\n-                                           default.as_ref().map(|x| this.lower_ty(x)))\n+                        hir::TraitItemKind::Type(this.lower_bounds(bounds),\n+                                                 default.as_ref().map(|x| this.lower_ty(x)))\n                     }\n                     TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n@@ -937,6 +989,30 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n+        let (kind, has_default) = match i.node {\n+            TraitItemKind::Const(_, ref default) => {\n+                (hir::AssociatedItemKind::Const, default.is_some())\n+            }\n+            TraitItemKind::Type(_, ref default) => {\n+                (hir::AssociatedItemKind::Type, default.is_some())\n+            }\n+            TraitItemKind::Method(ref sig, ref default) => {\n+                (hir::AssociatedItemKind::Method {\n+                    has_self: sig.decl.has_self(),\n+                 }, default.is_some())\n+            }\n+            TraitItemKind::Macro(..) => unimplemented!(),\n+        };\n+        hir::TraitItemRef {\n+            id: hir::TraitItemId { node_id: i.id },\n+            name: i.ident.name,\n+            span: i.span,\n+            defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n+            kind: kind,\n+        }\n+    }\n+\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n@@ -947,13 +1023,15 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), P(this.lower_expr(expr)))\n+                        let value = this.lower_expr(expr);\n+                        let body_id = this.record_body(value, None);\n+                        hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n                         let expr = this.expr_block(body, ThinVec::new());\n-                        let expr_id = this.record_expr(expr);\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig), expr_id)\n+                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -976,7 +1054,7 @@ impl<'a> LoweringContext<'a> {\n                 ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n                 ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n                 ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n-                    has_self: sig.decl.get_self().is_some(),\n+                    has_self: sig.decl.has_self(),\n                 },\n                 ImplItemKind::Macro(..) => unimplemented!(),\n             },\n@@ -1038,7 +1116,9 @@ impl<'a> LoweringContext<'a> {\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        hir::ForeignItemFn(this.lower_fn_decl(fdec), this.lower_generics(generics))\n+                        hir::ForeignItemFn(this.lower_fn_decl(fdec),\n+                                           this.lower_fn_args_to_names(fdec),\n+                                           this.lower_generics(generics))\n                     }\n                     ForeignItemKind::Static(ref t, m) => {\n                         hir::ForeignItemStatic(this.lower_ty(t), m)\n@@ -1051,24 +1131,13 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n-        let hir_sig = hir::MethodSig {\n+        hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),\n-        };\n-        // Check for `self: _` and `self: &_`\n-        if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n-            match hir_sig.decl.get_self().map(|eself| eself.node) {\n-                Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n-                    self.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n-                        \"the type placeholder `_` is not allowed within types on item signatures\");\n-                }\n-                _ => {}\n-            }\n         }\n-        hir_sig\n     }\n \n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n@@ -1318,8 +1387,8 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Repeat(ref expr, ref count) => {\n                     let expr = P(self.lower_expr(expr));\n-                    let count = P(self.lower_expr(count));\n-                    hir::ExprRepeat(expr, count)\n+                    let count = self.lower_expr(count);\n+                    hir::ExprRepeat(expr, self.record_body(count, None))\n                 }\n                 ExprKind::Tup(ref elts) => {\n                     hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n@@ -1402,7 +1471,7 @@ impl<'a> LoweringContext<'a> {\n                         let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.record_expr(expr),\n+                                         this.record_body(expr, Some(decl)),\n                                          fn_decl_span)\n                     })\n                 }\n@@ -1686,13 +1755,7 @@ impl<'a> LoweringContext<'a> {\n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n                         let body_block = self.lower_block(body);\n-                        let body_span = body_block.span;\n-                        let body_expr = P(hir::Expr {\n-                            id: self.next_id(),\n-                            node: hir::ExprBlock(body_block),\n-                            span: body_span,\n-                            attrs: ThinVec::new(),\n-                        });\n+                        let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n "}, {"sha": "6e08b52f9a2490bf1b8c0a8471723f8c9bc7f0cf", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -48,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: ast::ExprId,\n+    pub body: ast::BodyId,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -62,7 +62,10 @@ impl MaybeFnLike for ast::Item {\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::MethodTraitItem(_, Some(_)) => true, _ => false, }\n+        match self.node {\n+            ast::TraitItemKind::Method(_, ast::TraitMethod::Provided(_)) => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -115,7 +118,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     ast::ExprId,\n+    body:     ast::BodyId,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -125,14 +128,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: ast::ExprId,\n+    body: ast::BodyId,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::ExprId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::BodyId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -172,9 +175,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> ast::ExprId {\n+    pub fn body(self) -> ast::BodyId {\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -227,7 +230,7 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  ast::ExprId,\n+                  ast::BodyId,\n                   Span,\n                   &'a [Attribute])\n                   -> A,\n@@ -252,7 +255,7 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n-                ast::MethodTraitItem(ref sig, Some(body)) => {\n+                ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),"}, {"sha": "a6ffe7cea5592e752ce7b66b09a8c6e80b700c08", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -11,7 +11,6 @@\n use super::*;\n \n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n@@ -21,7 +20,7 @@ pub struct NodeCollector<'ast> {\n     /// The crate\n     pub krate: &'ast Crate,\n     /// The node map\n-    pub map: Vec<MapEntry<'ast>>,\n+    pub(super) map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n     /// If true, completely ignore nested items. We set this when loading\n@@ -43,11 +42,11 @@ impl<'ast> NodeCollector<'ast> {\n         collector\n     }\n \n-    pub fn extend(krate: &'ast Crate,\n-                  parent: &'ast InlinedItem,\n-                  parent_node: NodeId,\n-                  map: Vec<MapEntry<'ast>>)\n-                  -> NodeCollector<'ast> {\n+    pub(super) fn extend(krate: &'ast Crate,\n+                         parent: &'ast InlinedItem,\n+                         parent_node: NodeId,\n+                         map: Vec<MapEntry<'ast>>)\n+                         -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: map,\n@@ -98,12 +97,22 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         }\n     }\n \n+    fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n+        if !self.ignore_nested_items {\n+            self.visit_trait_item(self.krate.trait_item(item_id))\n+        }\n+    }\n+\n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.visit_impl_item(self.krate.impl_item(item_id))\n+        if !self.ignore_nested_items {\n+            self.visit_impl_item(self.krate.impl_item(item_id))\n+        }\n     }\n \n-    fn visit_body(&mut self, id: ExprId) {\n-        self.visit_expr(self.krate.expr(id))\n+    fn visit_nested_body(&mut self, id: BodyId) {\n+        if !self.ignore_nested_items {\n+            self.visit_body(self.krate.body(id))\n+        }\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {\n@@ -113,11 +122,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         self.with_parent(i.id, |this| {\n             match i.node {\n-                ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        this.insert(v.node.data.id(), NodeVariant(v));\n-                    }\n-                }\n                 ItemStruct(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n@@ -209,7 +213,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: ExprId, s: Span, id: NodeId) {\n+                b: BodyId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n@@ -243,6 +247,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert_entry(macro_def.id, NotPresent);\n     }\n \n+    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n+        let id = v.node.data.id();\n+        self.insert(id, NodeVariant(v));\n+        self.with_parent(id, |this| {\n+            intravisit::walk_variant(this, v, g, item_id);\n+        });\n+    }\n+\n     fn visit_struct_field(&mut self, field: &'ast StructField) {\n         self.insert(field.id, NodeField(field));\n         self.with_parent(field.id, |this| {"}, {"sha": "be8780f39b10429d6aea31bbc28cc36c69e8cdc0", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -16,7 +16,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n-/// Creates def ids for nodes in the HIR.\n+/// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,"}, {"sha": "b28c5e80ea3c35bc4ddf41263ac89e4d272ce9fa", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -220,7 +220,6 @@ impl DefPath {\n     }\n }\n \n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n@@ -339,7 +338,7 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert!(parent.is_some() ^ (data == DefPathData::CrateRoot));\n+        assert_eq!(parent.is_some(), data != DefPathData::CrateRoot);\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match."}, {"sha": "27ebeea9ad91db21f18d477684a6288f5a699365", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 165, "deletions": 99, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -17,7 +17,6 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode};\n \n-use middle::cstore::InlinedItem;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n@@ -26,7 +25,8 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::print as pprust;\n+use hir::intravisit::Visitor;\n+use hir::print::Nested;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -38,6 +38,15 @@ mod collector;\n mod def_collector;\n pub mod definitions;\n \n+/// The data we save and restore about an inlined item or method.  This is not\n+/// part of the AST that we parse from a file, but it becomes part of the tree\n+/// that we trans.\n+#[derive(Debug)]\n+struct InlinedItem {\n+    def_id: DefId,\n+    body: Body,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -60,14 +69,12 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n     NodeTyParam(&'ast TyParam),\n     NodeVisibility(&'ast Visibility),\n-\n-    NodeInlinedItem(&'ast InlinedItem),\n }\n \n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-pub enum MapEntry<'ast> {\n+enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n@@ -121,8 +128,6 @@ impl<'ast> MapEntry<'ast> {\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n             NodeVisibility(n) => EntryVisibility(p, n),\n-\n-            NodeInlinedItem(n) => RootInlinedParent(n),\n         }\n     }\n \n@@ -171,10 +176,49 @@ impl<'ast> MapEntry<'ast> {\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n             EntryVisibility(_, n) => NodeVisibility(n),\n-            RootInlinedParent(n) => NodeInlinedItem(n),\n             _ => return None\n         })\n     }\n+\n+    fn is_body_owner(self, node_id: NodeId) -> bool {\n+        match self {\n+            EntryItem(_, item) => {\n+                match item.node {\n+                    ItemConst(_, body) |\n+                    ItemStatic(.., body) |\n+                    ItemFn(_, _, _, _, _, body) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            EntryTraitItem(_, item) => {\n+                match item.node {\n+                    TraitItemKind::Const(_, Some(body)) |\n+                    TraitItemKind::Method(_, TraitMethod::Provided(body)) => {\n+                        body.node_id == node_id\n+                    }\n+                    _ => false\n+                }\n+            }\n+\n+            EntryImplItem(_, item) => {\n+                match item.node {\n+                    ImplItemKind::Const(_, body) |\n+                    ImplItemKind::Method(_, body) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            EntryExpr(_, expr) => {\n+                match expr.node {\n+                    ExprClosure(.., body, _) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            _ => false\n+        }\n+    }\n }\n \n /// Stores a crate and any number of inlined items from other crates.\n@@ -250,38 +294,34 @@ impl<'ast> Map<'ast> {\n         if !self.is_inlined_node_id(id) {\n             let mut last_expr = None;\n             loop {\n-                match map[id.as_usize()] {\n-                    EntryItem(_, item) => {\n-                        assert_eq!(id, item.id);\n-                        let def_id = self.local_def_id(id);\n-\n+                let entry = map[id.as_usize()];\n+                match entry {\n+                    EntryItem(..) |\n+                    EntryTraitItem(..) |\n+                    EntryImplItem(..) => {\n                         if let Some(last_id) = last_expr {\n-                            // The body of the item may have a separate dep node\n-                            // (Note that trait items don't currently have\n-                            // their own dep node, so there's also just one\n-                            // HirBody node for all the items)\n-                            if self.is_body(last_id, item) {\n+                            // The body may have a separate dep node\n+                            if entry.is_body_owner(last_id) {\n+                                let def_id = self.local_def_id(id);\n                                 return DepNode::HirBody(def_id);\n                             }\n                         }\n-                        return DepNode::Hir(def_id);\n+                        return DepNode::Hir(self.local_def_id(id));\n                     }\n \n-                    EntryImplItem(_, item) => {\n-                        let def_id = self.local_def_id(id);\n+                    EntryVariant(p, v) => {\n+                        id = p;\n \n-                        if let Some(last_id) = last_expr {\n-                            // The body of the item may have a separate dep node\n-                            if self.is_impl_item_body(last_id, item) {\n+                        if last_expr.is_some() {\n+                            if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n+                                // The enum parent holds both Hir and HirBody nodes.\n+                                let def_id = self.local_def_id(id);\n                                 return DepNode::HirBody(def_id);\n                             }\n                         }\n-                        return DepNode::Hir(def_id);\n                     }\n \n                     EntryForeignItem(p, _) |\n-                    EntryTraitItem(p, _) |\n-                    EntryVariant(p, _) |\n                     EntryField(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n@@ -308,7 +348,7 @@ impl<'ast> Map<'ast> {\n                         bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n \n                     NotPresent =>\n-                        // Some nodes, notably struct fields, are not\n+                        // Some nodes, notably macro definitions, are not\n                         // present in the map for whatever reason, but\n                         // they *do* have def-ids. So if we encounter an\n                         // empty hole, check for that case.\n@@ -358,29 +398,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    fn is_body(&self, node_id: NodeId, item: &Item) -> bool {\n-        match item.node {\n-            ItemFn(_, _, _, _, _, body) => body.node_id() == node_id,\n-            // Since trait items currently don't get their own dep nodes,\n-            // we check here whether node_id is the body of any of the items.\n-            // If they get their own dep nodes, this can go away\n-            ItemTrait(_, _, _, ref trait_items) => {\n-                trait_items.iter().any(|trait_item| { match trait_item.node {\n-                    MethodTraitItem(_, Some(body)) => body.node_id() == node_id,\n-                    _ => false\n-                }})\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    fn is_impl_item_body(&self, node_id: NodeId, item: &ImplItem) -> bool {\n-        match item.node {\n-            ImplItemKind::Method(_, body) => body.node_id() == node_id,\n-            _ => false\n-        }\n-    }\n-\n     pub fn num_local_def_ids(&self) -> usize {\n         self.definitions.len()\n     }\n@@ -436,6 +453,14 @@ impl<'ast> Map<'ast> {\n         self.forest.krate()\n     }\n \n+    pub fn trait_item(&self, id: TraitItemId) -> &'ast TraitItem {\n+        self.read(id.node_id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.trait_item(id)\n+    }\n+\n     pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n         self.read(id.node_id);\n \n@@ -444,6 +469,31 @@ impl<'ast> Map<'ast> {\n         self.forest.krate.impl_item(id)\n     }\n \n+    pub fn body(&self, id: BodyId) -> &'ast Body {\n+        self.read(id.node_id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.body(id)\n+    }\n+\n+    /// Returns the `NodeId` that corresponds to the definition of\n+    /// which this is the body of, i.e. a `fn`, `const` or `static`\n+    /// item (possibly associated), or a closure, or the body itself\n+    /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n+    pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n+        let parent = self.get_parent_node(node_id);\n+        if self.map.borrow()[parent.as_usize()].is_body_owner(node_id) {\n+            parent\n+        } else {\n+            node_id\n+        }\n+    }\n+\n+    pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n+        self.local_def_id(self.body_owner(id))\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n@@ -687,17 +737,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_inlined_item(&self, id: NodeId) -> &'ast InlinedItem {\n+    pub fn expect_inlined_body(&self, id: NodeId) -> &'ast Body {\n         match self.find_entry(id) {\n-            Some(RootInlinedParent(inlined_item)) => inlined_item,\n+            Some(RootInlinedParent(inlined_item)) => &inlined_item.body,\n             _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expr(&self, id: ExprId) -> &'ast Expr {\n-        self.expect_expr(id.node_id())\n-    }\n-\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -778,7 +824,7 @@ impl<'ast> Map<'ast> {\n             Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n \n             Some(RootCrate) => self.forest.krate.span,\n-            Some(RootInlinedParent(parent)) => parent.body.span,\n+            Some(RootInlinedParent(parent)) => parent.body.value.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -796,6 +842,10 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n+\n+    pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n+        print::to_string(self, |s| s.print_node(self.get(id)))\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -934,33 +984,47 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n }\n \n-/// Used for items loaded from external crate that are being inlined into this\n+/// Used for bodies loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n-                              ii: InlinedItem,\n-                              ii_parent_id: NodeId)\n-                              -> &'ast InlinedItem {\n+pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n+                              def_id: DefId,\n+                              body: Body,\n+                              parent_id: NodeId)\n+                              -> &'ast Body {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n-    let ii = map.forest.inlined_items.alloc(ii);\n+    let ii = map.forest.inlined_items.alloc(InlinedItem {\n+        def_id: def_id,\n+        body: body\n+    });\n \n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,\n-                                              ii_parent_id,\n+                                              parent_id,\n                                               mem::replace(&mut *map.map.borrow_mut(), vec![]));\n-    ii.visit(&mut collector);\n+    collector.visit_body(&ii.body);\n     *map.map.borrow_mut() = collector.map;\n \n-    ii\n+    &ii.body\n }\n \n-pub trait NodePrinter {\n-    fn print_node(&mut self, node: &Node) -> io::Result<()>;\n+/// Identical to the `PpAnn` implementation for `hir::Crate`,\n+/// except it avoids creating a dependency on the whole crate.\n+impl<'ast> print::PpAnn for Map<'ast> {\n+    fn nested(&self, state: &mut print::State, nested: print::Nested) -> io::Result<()> {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+        }\n+    }\n }\n \n-impl<'a> NodePrinter for pprust::State<'a> {\n-    fn print_node(&mut self, node: &Node) -> io::Result<()> {\n-        match *node {\n+impl<'a> print::State<'a> {\n+    pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n+        match node {\n             NodeItem(a)        => self.print_item(&a),\n             NodeForeignItem(a) => self.print_foreign_item(&a),\n             NodeTraitItem(a)   => self.print_trait_item(a),\n@@ -970,19 +1034,25 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n             NodeTraitRef(a)    => self.print_trait_ref(&a),\n+            NodeLocal(a)       |\n             NodePat(a)         => self.print_pat(&a),\n-            NodeBlock(a)       => self.print_block(&a),\n+            NodeBlock(a)       => {\n+                use syntax::print::pprust::PrintState;\n+\n+                // containing cbox, will be closed by print-block at }\n+                self.cbox(print::indent_unit)?;\n+                // head-ibox, will be closed by print-block after {\n+                self.ibox(0)?;\n+                self.print_block(&a)\n+            }\n             NodeLifetime(a)    => self.print_lifetime(&a),\n             NodeVisibility(a)  => self.print_visibility(&a),\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n             NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n-\n-            NodeInlinedItem(_) => bug!(\"cannot print inlined item\"),\n         }\n     }\n }\n@@ -1045,9 +1115,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeTraitItem(ti)) => {\n             let kind = match ti.node {\n-                ConstTraitItem(..) => \"assoc constant\",\n-                MethodTraitItem(..) => \"trait method\",\n-                TypeTraitItem(..) => \"assoc type\",\n+                TraitItemKind::Const(..) => \"assoc constant\",\n+                TraitItemKind::Method(..) => \"trait method\",\n+                TraitItemKind::Type(..) => \"assoc type\",\n             };\n \n             format!(\"{} {} in {}{}\", kind, ti.name, path_str(), id_str)\n@@ -1062,43 +1132,39 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     field.name,\n                     path_str(), id_str)\n         }\n-        Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n+        Some(NodeExpr(_)) => {\n+            format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n+        Some(NodeStmt(_)) => {\n+            format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTy(ref ty)) => {\n-            format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n+        Some(NodeTy(_)) => {\n+            format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTraitRef(ref tr)) => {\n-            format!(\"trait_ref {}{}\", pprust::path_to_string(&tr.path), id_str)\n+        Some(NodeTraitRef(_)) => {\n+            format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeLocal(ref pat)) => {\n-            format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n+        Some(NodeLocal(_)) => {\n+            format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodePat(ref pat)) => {\n-            format!(\"pat {}{}\", pprust::pat_to_string(&pat), id_str)\n+        Some(NodePat(_)) => {\n+            format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBlock(ref block)) => {\n-            format!(\"block {}{}\", pprust::block_to_string(&block), id_str)\n+        Some(NodeBlock(_)) => {\n+            format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n-        Some(NodeLifetime(ref l)) => {\n-            format!(\"lifetime {}{}\",\n-                    pprust::lifetime_to_string(&l), id_str)\n+        Some(NodeLifetime(_)) => {\n+            format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)\n         }\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n-        Some(NodeInlinedItem(_)) => {\n-            format!(\"inlined item {}\", id_str)\n-        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "9149da459c26e85127ca50ed0bca90877fd42d7b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 92, "deletions": 104, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -22,7 +22,6 @@ pub use self::Item_::*;\n pub use self::Mutability::*;\n pub use self::PrimTy::*;\n pub use self::Stmt_::*;\n-pub use self::TraitItem_::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n@@ -32,11 +31,10 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FxHashSet};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n \n-use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n-use syntax::codemap::{self, respan, Spanned};\n+use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n@@ -87,7 +85,7 @@ impl fmt::Debug for Lifetime {\n         write!(f,\n                \"lifetime({}: {})\",\n                self.id,\n-               print::lifetime_to_string(self))\n+               print::to_string(print::NO_ANN, |s| s.print_lifetime(self)))\n     }\n }\n \n@@ -119,13 +117,8 @@ impl Path {\n \n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"path({})\", print::path_to_string(self))\n-    }\n-}\n-\n-impl fmt::Display for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", print::path_to_string(self))\n+        write!(f, \"path({})\",\n+               print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n     }\n }\n \n@@ -431,15 +424,20 @@ pub struct Crate {\n     // slightly different results.\n     pub items: BTreeMap<NodeId, Item>,\n \n+    pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n-    pub exprs: FnvHashMap<ExprId, Expr>,\n+    pub bodies: FxHashMap<BodyId, Body>,\n }\n \n impl Crate {\n     pub fn item(&self, id: NodeId) -> &Item {\n         &self.items[&id]\n     }\n \n+    pub fn trait_item(&self, id: TraitItemId) -> &TraitItem {\n+        &self.trait_items[&id]\n+    }\n+\n     pub fn impl_item(&self, id: ImplItemId) -> &ImplItem {\n         &self.impl_items[&id]\n     }\n@@ -459,13 +457,17 @@ impl Crate {\n             visitor.visit_item(item);\n         }\n \n+        for (_, trait_item) in &self.trait_items {\n+            visitor.visit_trait_item(trait_item);\n+        }\n+\n         for (_, impl_item) in &self.impl_items {\n             visitor.visit_impl_item(impl_item);\n         }\n     }\n \n-    pub fn expr(&self, id: ExprId) -> &Expr {\n-        &self.exprs[&id]\n+    pub fn body(&self, id: BodyId) -> &Body {\n+        &self.bodies[&id]\n     }\n }\n \n@@ -503,7 +505,8 @@ pub struct Pat {\n \n impl fmt::Debug for Pat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id, print::pat_to_string(self))\n+        write!(f, \"pat({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_pat(self)))\n     }\n }\n \n@@ -755,7 +758,7 @@ impl fmt::Debug for Stmt_ {\n         write!(f,\n                \"stmt({}: {})\",\n                spanned.node.id(),\n-               print::stmt_to_string(&spanned))\n+               print::to_string(print::NO_ANN, |s| s.print_stmt(&spanned)))\n     }\n }\n \n@@ -853,12 +856,23 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ExprId(NodeId);\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct BodyId {\n+    pub node_id: NodeId,\n+}\n \n-impl ExprId {\n-    pub fn node_id(self) -> NodeId {\n-        self.0\n+/// The body of a function or constant value.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Body {\n+    pub arguments: HirVec<Arg>,\n+    pub value: Expr\n+}\n+\n+impl Body {\n+    pub fn id(&self) -> BodyId {\n+        BodyId {\n+            node_id: self.value.id\n+        }\n     }\n }\n \n@@ -871,15 +885,10 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n-impl Expr {\n-    pub fn expr_id(&self) -> ExprId {\n-        ExprId(self.id)\n-    }\n-}\n-\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))\n+        write!(f, \"expr({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_expr(self)))\n     }\n }\n \n@@ -936,7 +945,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, ExprId, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -980,7 +989,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, P<Expr>),\n+    ExprRepeat(P<Expr>, BodyId),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n@@ -1003,12 +1012,6 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n-impl fmt::Display for QPath {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", print::qpath_to_string(self))\n-    }\n-}\n-\n /// Hints at the original code for a `match _ { .. }`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n@@ -1070,6 +1073,14 @@ pub struct MethodSig {\n     pub generics: Generics,\n }\n \n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TraitItemId {\n+    pub node_id: NodeId,\n+}\n+\n /// Represents an item declaration within a trait declaration,\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n@@ -1079,21 +1090,31 @@ pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n-    pub node: TraitItem_,\n+    pub node: TraitItemKind,\n     pub span: Span,\n }\n \n+/// A trait method's body (or just argument names).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitMethod {\n+    /// No default body in the trait, just a signature.\n+    Required(HirVec<Spanned<Name>>),\n+\n+    /// Both signature and body are provided in the trait.\n+    Provided(BodyId),\n+}\n+\n /// Represents a trait method or associated constant or type\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitItem_ {\n+pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n-    ConstTraitItem(P<Ty>, Option<P<Expr>>),\n+    Const(P<Ty>, Option<BodyId>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<ExprId>),\n+    Method(MethodSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n-    TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n+    Type(TyParamBounds, Option<P<Ty>>),\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1121,9 +1142,9 @@ pub struct ImplItem {\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n-    Const(P<Ty>, P<Expr>),\n+    Const(P<Ty>, BodyId),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, ExprId),\n+    Method(MethodSig, BodyId),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1147,7 +1168,8 @@ pub struct Ty {\n \n impl fmt::Debug for Ty {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"type({})\", print::ty_to_string(self))\n+        write!(f, \"type({})\",\n+               print::to_string(print::NO_ANN, |s| s.print_type(self)))\n     }\n }\n \n@@ -1176,7 +1198,7 @@ pub enum Ty_ {\n     /// A variable length slice (`[T]`)\n     TySlice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyArray(P<Ty>, P<Expr>),\n+    TyArray(P<Ty>, BodyId),\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n@@ -1200,7 +1222,7 @@ pub enum Ty_ {\n     /// An `impl TraitA+TraitB` type.\n     TyImplTrait(TyParamBounds),\n     /// Unused for now\n-    TyTypeof(P<Expr>),\n+    TyTypeof(BodyId),\n     /// TyInfer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -1229,67 +1251,18 @@ pub struct InlineAsm {\n /// represents an argument in a function header\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arg {\n-    pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n }\n \n-/// Alternative representation for `Arg`s describing `self` parameter of methods.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum SelfKind {\n-    /// `self`, `mut self`\n-    Value(Mutability),\n-    /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability),\n-    /// `self: TYPE`, `mut self: TYPE`\n-    Explicit(P<Ty>, Mutability),\n-}\n-\n-pub type ExplicitSelf = Spanned<SelfKind>;\n-\n-impl Arg {\n-    pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Binding(BindByValue(mutbl), _, name, _) = self.pat.node {\n-            if name.node == keywords::SelfValue.name() {\n-                return match self.ty.node {\n-                    TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyRptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyInfer => {\n-                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n-                    }\n-                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n-                                     SelfKind::Explicit(self.ty.clone(), mutbl)))\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn is_self(&self) -> bool {\n-        if let PatKind::Binding(_, _, name, _) = self.pat.node {\n-            name.node == keywords::SelfValue.name()\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: HirVec<Arg>,\n+    pub inputs: HirVec<P<Ty>>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n }\n \n-impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Arg::to_self)\n-    }\n-    pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n@@ -1403,7 +1376,7 @@ pub struct Variant_ {\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n-    pub disr_expr: Option<P<Expr>>,\n+    pub disr_expr: Option<BodyId>,\n }\n \n pub type Variant = Spanned<Variant_>;\n@@ -1562,11 +1535,11 @@ pub enum Item_ {\n     ItemUse(P<Path>, UseKind),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    ItemStatic(P<Ty>, Mutability, BodyId),\n     /// A `const` item\n-    ItemConst(P<Ty>, P<Expr>),\n+    ItemConst(P<Ty>, BodyId),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, ExprId),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, BodyId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module\n@@ -1580,7 +1553,7 @@ pub enum Item_ {\n     /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n     ItemUnion(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n+    ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItemRef>),\n \n     // Default trait implementations\n     ///\n@@ -1616,6 +1589,21 @@ impl Item_ {\n     }\n }\n \n+/// A reference from an trait to one of its associated items. This\n+/// contains the item's id, naturally, but also the item's name and\n+/// some other high-level details (like whether it is an associated\n+/// type or method, and whether it is public). This allows other\n+/// passes to find the impl they want without loading the id (which\n+/// means fewer edges in the incremental compilation graph).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TraitItemRef {\n+    pub id: TraitItemId,\n+    pub name: Name,\n+    pub kind: AssociatedItemKind,\n+    pub span: Span,\n+    pub defaultness: Defaultness,\n+}\n+\n /// A reference from an impl to one of its associated items. This\n /// contains the item's id, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n@@ -1653,7 +1641,7 @@ pub struct ForeignItem {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n     /// A foreign function\n-    ForeignItemFn(P<FnDecl>, Generics),\n+    ForeignItemFn(P<FnDecl>, HirVec<Spanned<Name>>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n     /// (the boolean is true when mutable)\n     ForeignItemStatic(P<Ty>, bool),"}, {"sha": "18fa6836b510827bfeb4e1c43d5e949bd09af7d7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 162, "deletions": 319, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -13,7 +13,6 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n@@ -25,7 +24,7 @@ use syntax_pos::{self, BytePos};\n use errors;\n \n use hir;\n-use hir::{Crate, PatKind, RegionTyParamBound, SelfKind, TraitTyParamBound, TraitBoundModifier};\n+use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -38,7 +37,18 @@ pub enum AnnNode<'a> {\n     NodePat(&'a hir::Pat),\n }\n \n+pub enum Nested {\n+    Item(hir::ItemId),\n+    TraitItem(hir::TraitItemId),\n+    ImplItem(hir::ImplItemId),\n+    Body(hir::BodyId),\n+    BodyArgPat(hir::BodyId, usize)\n+}\n+\n pub trait PpAnn {\n+    fn nested(&self, _state: &mut State, _nested: Nested) -> io::Result<()> {\n+        Ok(())\n+    }\n     fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> {\n         Ok(())\n     }\n@@ -47,14 +57,23 @@ pub trait PpAnn {\n     }\n }\n \n-#[derive(Copy, Clone)]\n pub struct NoAnn;\n-\n impl PpAnn for NoAnn {}\n+pub const NO_ANN: &'static PpAnn = &NoAnn;\n \n+impl PpAnn for hir::Crate {\n+    fn nested(&self, state: &mut State, nested: Nested) -> io::Result<()> {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+        }\n+    }\n+}\n \n pub struct State<'a> {\n-    krate: Option<&'a Crate>,\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment>>,\n@@ -86,30 +105,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write + 'a>, krate: Option<&'a Crate>) -> State<'a> {\n-    static NO_ANN: NoAnn = NoAnn;\n-    rust_printer_annotated(writer, &NO_ANN, krate)\n-}\n-\n-pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>,\n-                                  ann: &'a PpAnn,\n-                                  krate: Option<&'a Crate>)\n-                                  -> State<'a> {\n-    State {\n-        krate: krate,\n-        s: pp::mk_printer(writer, default_columns),\n-        cm: None,\n-        comments: None,\n-        literals: None,\n-        cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n-            cur_cmnt: 0,\n-            cur_lit: 0,\n-        },\n-        boxes: Vec::new(),\n-        ann: ann,\n-    }\n-}\n-\n #[allow(non_upper_case_globals)]\n pub const indent_unit: usize = 4;\n \n@@ -130,7 +125,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n     let mut s = State::new_from_input(cm, span_diagnostic, filename, input,\n-                                      out, ann, is_expanded, Some(krate));\n+                                      out, ann, is_expanded);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -147,8 +142,7 @@ impl<'a> State<'a> {\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n                           ann: &'a PpAnn,\n-                          is_expanded: bool,\n-                          krate: Option<&'a Crate>)\n+                          is_expanded: bool)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(span_diagnostic,\n                                                                    filename,\n@@ -165,19 +159,16 @@ impl<'a> State<'a> {\n                        None\n                    } else {\n                        Some(lits)\n-                   },\n-                   krate)\n+                   })\n     }\n \n     pub fn new(cm: &'a CodeMap,\n                out: Box<Write + 'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>,\n-               krate: Option<&'a Crate>)\n+               literals: Option<Vec<comments::Literal>>)\n                -> State<'a> {\n         State {\n-            krate: krate,\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n@@ -192,144 +183,36 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string<F>(f: F) -> String\n+pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n     where F: FnOnce(&mut State) -> io::Result<()>\n {\n     let mut wr = Vec::new();\n     {\n-        let mut printer = rust_printer(Box::new(&mut wr), None);\n+        let mut printer = State {\n+            s: pp::mk_printer(Box::new(&mut wr), default_columns),\n+            cm: None,\n+            comments: None,\n+            literals: None,\n+            cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n+                cur_cmnt: 0,\n+                cur_lit: 0,\n+            },\n+            boxes: Vec::new(),\n+            ann: ann,\n+        };\n         f(&mut printer).unwrap();\n         eof(&mut printer.s).unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n \n-pub fn binop_to_string(op: BinOpToken) -> &'static str {\n-    match op {\n-        token::Plus => \"+\",\n-        token::Minus => \"-\",\n-        token::Star => \"*\",\n-        token::Slash => \"/\",\n-        token::Percent => \"%\",\n-        token::Caret => \"^\",\n-        token::And => \"&\",\n-        token::Or => \"|\",\n-        token::Shl => \"<<\",\n-        token::Shr => \">>\",\n-    }\n-}\n-\n-pub fn ty_to_string(ty: &hir::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n-}\n-\n-pub fn bounds_to_string(bounds: &[hir::TyParamBound]) -> String {\n-    to_string(|s| s.print_bounds(\"\", bounds))\n-}\n-\n-pub fn pat_to_string(pat: &hir::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n-}\n-\n-pub fn arm_to_string(arm: &hir::Arm) -> String {\n-    to_string(|s| s.print_arm(arm))\n-}\n-\n-pub fn expr_to_string(e: &hir::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n-}\n-\n-pub fn lifetime_to_string(e: &hir::Lifetime) -> String {\n-    to_string(|s| s.print_lifetime(e))\n-}\n-\n-pub fn stmt_to_string(stmt: &hir::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n-}\n-\n-pub fn item_to_string(i: &hir::Item) -> String {\n-    to_string(|s| s.print_item(i))\n-}\n-\n-pub fn impl_item_to_string(i: &hir::ImplItem) -> String {\n-    to_string(|s| s.print_impl_item(i))\n-}\n-\n-pub fn trait_item_to_string(i: &hir::TraitItem) -> String {\n-    to_string(|s| s.print_trait_item(i))\n-}\n-\n-pub fn generics_to_string(generics: &hir::Generics) -> String {\n-    to_string(|s| s.print_generics(generics))\n-}\n-\n-pub fn where_clause_to_string(i: &hir::WhereClause) -> String {\n-    to_string(|s| s.print_where_clause(i))\n-}\n-\n-pub fn fn_block_to_string(p: &hir::FnDecl) -> String {\n-    to_string(|s| s.print_fn_block_args(p))\n-}\n-\n-pub fn path_to_string(p: &hir::Path) -> String {\n-    to_string(|s| s.print_path(p, false))\n-}\n-\n-pub fn qpath_to_string(p: &hir::QPath) -> String {\n-    to_string(|s| s.print_qpath(p, false))\n-}\n-\n-pub fn name_to_string(name: ast::Name) -> String {\n-    to_string(|s| s.print_name(name))\n-}\n-\n-pub fn fun_to_string(decl: &hir::FnDecl,\n-                     unsafety: hir::Unsafety,\n-                     constness: hir::Constness,\n-                     name: ast::Name,\n-                     generics: &hir::Generics)\n-                     -> String {\n-    to_string(|s| {\n-        s.head(\"\")?;\n-        s.print_fn(decl,\n-                   unsafety,\n-                   constness,\n-                   Abi::Rust,\n-                   Some(name),\n-                   generics,\n-                   &hir::Inherited)?;\n-        s.end()?; // Close the head box\n-        s.end() // Close the outer box\n+pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n+    to_string(NO_ANN, |s| {\n+        s.print_visibility(vis)?;\n+        word(&mut s.s, w)\n     })\n }\n \n-pub fn block_to_string(blk: &hir::Block) -> String {\n-    to_string(|s| {\n-        // containing cbox, will be closed by print-block at }\n-        s.cbox(indent_unit)?;\n-        // head-ibox, will be closed by print-block after {\n-        s.ibox(0)?;\n-        s.print_block(blk)\n-    })\n-}\n-\n-pub fn variant_to_string(var: &hir::Variant) -> String {\n-    to_string(|s| s.print_variant(var))\n-}\n-\n-pub fn arg_to_string(arg: &hir::Arg) -> String {\n-    to_string(|s| s.print_arg(arg, false))\n-}\n-\n-pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n-    match *vis {\n-        hir::Public => format!(\"pub {}\", s),\n-        hir::Visibility::Crate => format!(\"pub(crate) {}\", s),\n-        hir::Visibility::Restricted { ref path, .. } => format!(\"pub({}) {}\", path, s),\n-        hir::Inherited => s.to_string(),\n-    }\n-}\n-\n fn needs_parentheses(expr: &hir::Expr) -> bool {\n     match expr.node {\n         hir::ExprAssign(..) |\n@@ -462,8 +345,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n-        for item_id in &_mod.item_ids {\n-            self.print_item_id(item_id)?;\n+        for &item_id in &_mod.item_ids {\n+            self.ann.nested(self, Nested::Item(item_id))?;\n         }\n         Ok(())\n     }\n@@ -545,16 +428,16 @@ impl<'a> State<'a> {\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n-            hir::TyArray(ref ty, ref v) => {\n+            hir::TyArray(ref ty, v) => {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;\n                 word(&mut self.s, \"; \")?;\n-                self.print_expr(&v)?;\n+                self.ann.nested(self, Nested::Body(v))?;\n                 word(&mut self.s, \"]\")?;\n             }\n-            hir::TyTypeof(ref e) => {\n+            hir::TyTypeof(e) => {\n                 word(&mut self.s, \"typeof(\")?;\n-                self.print_expr(&e)?;\n+                self.ann.nested(self, Nested::Body(e))?;\n                 word(&mut self.s, \")\")?;\n             }\n             hir::TyInfer => {\n@@ -569,15 +452,17 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo)?;\n         self.print_outer_attributes(&item.attrs)?;\n         match item.node {\n-            hir::ForeignItemFn(ref decl, ref generics) => {\n+            hir::ForeignItemFn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               hir::Unsafety::Normal,\n                               hir::Constness::NotConst,\n                               Abi::Rust,\n                               Some(item.name),\n                               generics,\n-                              &item.vis)?;\n+                              &item.vis,\n+                              arg_names,\n+                              None)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n@@ -600,7 +485,7 @@ impl<'a> State<'a> {\n     fn print_associated_const(&mut self,\n                               name: ast::Name,\n                               ty: &hir::Ty,\n-                              default: Option<&hir::Expr>,\n+                              default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n@@ -611,7 +496,7 @@ impl<'a> State<'a> {\n         if let Some(expr) = default {\n             space(&mut self.s)?;\n             self.word_space(\"=\")?;\n-            self.print_expr(expr)?;\n+            self.ann.nested(self, Nested::Body(expr))?;\n         }\n         word(&mut self.s, \";\")\n     }\n@@ -634,25 +519,6 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n-    pub fn print_item_id(&mut self, item_id: &hir::ItemId) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            // skip nested items if krate context was not provided\n-            let item = &krate.items[&item_id.id];\n-            self.print_item(item)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn print_expr_id(&mut self, expr_id: &hir::ExprId) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            let expr = &krate.exprs[expr_id];\n-            self.print_expr(expr)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n@@ -697,7 +563,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemStatic(ref ty, m, ref expr) => {\n+            hir::ItemStatic(ref ty, m, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n@@ -709,11 +575,11 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.ann.nested(self, Nested::Body(expr))?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemConst(ref ty, ref expr) => {\n+            hir::ItemConst(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n@@ -722,23 +588,25 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.ann.nested(self, Nested::Body(expr))?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n+            hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               unsafety,\n                               constness,\n                               abi,\n                               Some(item.name),\n                               typarams,\n-                              &item.vis)?;\n+                              &item.vis,\n+                              &[],\n+                              Some(body))?;\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -832,7 +700,7 @@ impl<'a> State<'a> {\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n-                    self.print_impl_item_ref(impl_item)?;\n+                    self.ann.nested(self, Nested::ImplItem(impl_item.id))?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -858,7 +726,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n-                    self.print_trait_item(trait_item)?;\n+                    self.ann.nested(self, Nested::TraitItem(trait_item.id))?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -928,8 +796,11 @@ impl<'a> State<'a> {\n         match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n-            hir::Visibility::Restricted { ref path, .. } =>\n-                self.word_nbsp(&format!(\"pub({})\", path)),\n+            hir::Visibility::Restricted { ref path, .. } => {\n+                word(&mut self.s, \"pub(\")?;\n+                self.print_path(path, false)?;\n+                self.word_nbsp(\")\")\n+            }\n             hir::Inherited => Ok(()),\n         }\n     }\n@@ -985,27 +856,29 @@ impl<'a> State<'a> {\n         self.head(\"\")?;\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n-        match v.node.disr_expr {\n-            Some(ref d) => {\n-                space(&mut self.s)?;\n-                self.word_space(\"=\")?;\n-                self.print_expr(&d)\n-            }\n-            _ => Ok(()),\n+        if let Some(d) = v.node.disr_expr {\n+            space(&mut self.s)?;\n+            self.word_space(\"=\")?;\n+            self.ann.nested(self, Nested::Body(d))?;\n         }\n+        Ok(())\n     }\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n-                            vis: &hir::Visibility)\n+                            vis: &hir::Visibility,\n+                            arg_names: &[Spanned<ast::Name>],\n+                            body_id: Option<hir::BodyId>)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n                       m.constness,\n                       m.abi,\n                       Some(name),\n                       &m.generics,\n-                      vis)\n+                      vis,\n+                      arg_names,\n+                      body_id)\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n@@ -1014,27 +887,22 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ti.span.lo)?;\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n-            hir::ConstTraitItem(ref ty, ref default) => {\n-                self.print_associated_const(ti.name,\n-                                            &ty,\n-                                            default.as_ref().map(|expr| &**expr),\n-                                            &hir::Inherited)?;\n-            }\n-            hir::MethodTraitItem(ref sig, ref body) => {\n-                if body.is_some() {\n-                    self.head(\"\")?;\n-                }\n-                self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n-                if let Some(ref body) = *body {\n-                    self.nbsp()?;\n-                    self.end()?; // need to close a box\n-                    self.end()?; // need to close a box\n-                    self.print_expr_id(body)?;\n-                } else {\n-                    word(&mut self.s, \";\")?;\n-                }\n+            hir::TraitItemKind::Const(ref ty, default) => {\n+                self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n             }\n-            hir::TypeTraitItem(ref bounds, ref default) => {\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n+                self.print_method_sig(ti.name, sig, &hir::Inherited, arg_names, None)?;\n+                word(&mut self.s, \";\")?;\n+            }\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                self.head(\"\")?;\n+                self.print_method_sig(ti.name, sig, &hir::Inherited, &[], Some(body))?;\n+                self.nbsp()?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.ann.nested(self, Nested::Body(body))?;\n+            }\n+            hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 self.print_associated_type(ti.name,\n                                            Some(bounds),\n                                            default.as_ref().map(|ty| &**ty))?;\n@@ -1043,16 +911,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n-    pub fn print_impl_item_ref(&mut self, item_ref: &hir::ImplItemRef) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            // skip nested items if krate context was not provided\n-            let item = &krate.impl_item(item_ref.id);\n-            self.print_impl_item(item)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n@@ -1065,16 +923,16 @@ impl<'a> State<'a> {\n         }\n \n         match ii.node {\n-            hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(&expr), &ii.vis)?;\n+            hir::ImplItemKind::Const(ref ty, expr) => {\n+                self.print_associated_const(ii.name, &ty, Some(expr), &ii.vis)?;\n             }\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n+            hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, &ii.vis)?;\n+                self.print_method_sig(ii.name, sig, &ii.vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1246,12 +1104,12 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::Expr) -> io::Result<()> {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr, count: hir::BodyId) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         word(&mut self.s, \"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n-        self.print_expr(count)?;\n+        self.ann.nested(self, Nested::Body(count))?;\n         word(&mut self.s, \"]\")?;\n         self.end()\n     }\n@@ -1362,8 +1220,8 @@ impl<'a> State<'a> {\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n-                self.print_expr_repeat(&element, &count)?;\n+            hir::ExprRepeat(ref element, count) => {\n+                self.print_expr_repeat(&element, count)?;\n             }\n             hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n                 self.print_expr_struct(qpath, &fields[..], wth)?;\n@@ -1434,14 +1292,14 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, ref body, _fn_decl_span) => {\n+            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span) => {\n                 self.print_capture_clause(capture_clause)?;\n \n-                self.print_fn_block_args(&decl)?;\n+                self.print_closure_args(&decl, body)?;\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_expr_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n@@ -1615,8 +1473,8 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(ref item) => {\n-                self.print_item_id(item)\n+            hir::DeclItem(item) => {\n+                self.ann.nested(self, Nested::Item(item))\n             }\n         }\n     }\n@@ -1637,10 +1495,10 @@ impl<'a> State<'a> {\n         self.print_expr(coll)\n     }\n \n-    fn print_path(&mut self,\n-                  path: &hir::Path,\n-                  colons_before_params: bool)\n-                  -> io::Result<()> {\n+    pub fn print_path(&mut self,\n+                      path: &hir::Path,\n+                      colons_before_params: bool)\n+                      -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n         for (i, segment) in path.segments.iter().enumerate() {\n@@ -1656,10 +1514,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_qpath(&mut self,\n-                   qpath: &hir::QPath,\n-                   colons_before_params: bool)\n-                   -> io::Result<()> {\n+    pub fn print_qpath(&mut self,\n+                       qpath: &hir::QPath,\n+                       colons_before_params: bool)\n+                       -> io::Result<()> {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => {\n                 self.print_path(path, colons_before_params)\n@@ -1954,35 +1812,16 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    fn print_explicit_self(&mut self, explicit_self: &hir::ExplicitSelf) -> io::Result<()> {\n-        match explicit_self.node {\n-            SelfKind::Value(m) => {\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n-            }\n-            SelfKind::Region(ref lt, m) => {\n-                word(&mut self.s, \"&\")?;\n-                self.print_opt_lifetime(lt)?;\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n-            }\n-            SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n-                self.word_space(\":\")?;\n-                self.print_type(&typ)\n-            }\n-        }\n-    }\n-\n     pub fn print_fn(&mut self,\n                     decl: &hir::FnDecl,\n                     unsafety: hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: Abi,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n-                    vis: &hir::Visibility)\n+                    vis: &hir::Visibility,\n+                    arg_names: &[Spanned<ast::Name>],\n+                    body_id: Option<hir::BodyId>)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -1991,24 +1830,51 @@ impl<'a> State<'a> {\n             self.print_name(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl)?;\n-        self.print_where_clause(&generics.where_clause)\n-    }\n \n-    pub fn print_fn_args_and_ret(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         self.popen()?;\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n+        let mut i = 0;\n+        // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n+        assert!(arg_names.is_empty() || body_id.is_none());\n+        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+            s.ibox(indent_unit)?;\n+            if let Some(name) = arg_names.get(i) {\n+                word(&mut s.s, &name.node.as_str())?;\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+            } else if let Some(body_id) = body_id {\n+                s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+            }\n+            i += 1;\n+            s.print_type(ty)?;\n+            s.end()\n+        })?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n         self.pclose()?;\n \n-        self.print_fn_output(decl)\n+        self.print_fn_output(decl)?;\n+        self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_block_args(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n+    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n+        let mut i = 0;\n+        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+            s.ibox(indent_unit)?;\n+\n+            s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n+            i += 1;\n+\n+            if ty.node != hir::TyInfer {\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+                s.print_type(ty)?;\n+            }\n+            s.end()\n+        })?;\n         word(&mut self.s, \"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n@@ -2180,31 +2046,6 @@ impl<'a> State<'a> {\n         self.print_type(&mt.ty)\n     }\n \n-    pub fn print_arg(&mut self, input: &hir::Arg, is_closure: bool) -> io::Result<()> {\n-        self.ibox(indent_unit)?;\n-        match input.ty.node {\n-            hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n-            _ => {\n-                if let Some(eself) = input.to_self() {\n-                    self.print_explicit_self(&eself)?;\n-                } else {\n-                    let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n-                        name.node == keywords::Invalid.name()\n-                    } else {\n-                        false\n-                    };\n-                    if !invalid {\n-                        self.print_pat(&input.pat)?;\n-                        word(&mut self.s, \":\")?;\n-                        space(&mut self.s)?;\n-                    }\n-                    self.print_type(&input.ty)?;\n-                }\n-            }\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         if let hir::DefaultReturn(..) = decl.output {\n             return Ok(());\n@@ -2252,7 +2093,9 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      &hir::Inherited)?;\n+                      &hir::Inherited,\n+                      &[],\n+                      None)?;\n         self.end()\n     }\n "}, {"sha": "9ff7dcc7d58835beaface33b9cf59205fda0a0b6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -75,7 +75,6 @@ use std::collections::HashSet;\n \n use hir::map as ast_map;\n use hir;\n-use hir::print as pprust;\n \n use lint;\n use hir::def::Def;\n@@ -1051,8 +1050,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n-                            Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n+                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, body) => {\n+                            Some((fn_decl, gen, unsafety, constness, item.name, item.span, body))\n                         }\n                         _ => None,\n                     }\n@@ -1066,26 +1065,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             return;\n                         }\n                     }\n-                    if let hir::ImplItemKind::Method(ref sig, _) = item.node {\n+                    if let hir::ImplItemKind::Method(ref sig, body) = item.node {\n                         Some((&sig.decl,\n                               &sig.generics,\n                               sig.unsafety,\n                               sig.constness,\n                               item.name,\n-                              item.span))\n+                              item.span,\n+                              body))\n                     } else {\n                         None\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n                     match item.node {\n-                        hir::MethodTraitItem(ref sig, Some(_)) => {\n+                        hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  item.span))\n+                                  item.span,\n+                                  body))\n                         }\n                         _ => None,\n                     }\n@@ -1094,12 +1095,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             },\n             None => None,\n         };\n-        let (fn_decl, generics, unsafety, constness, name, span)\n+        let (fn_decl, generics, unsafety, constness, name, span, body)\n                                     = node_inner.expect(\"expect item fn\");\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n         let (fn_decl, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(\n-            err, &fn_decl, unsafety, constness, name, &generics, span);\n+            err, &fn_decl, unsafety, constness, name, &generics, span, body);\n     }\n \n     pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n@@ -1375,23 +1376,14 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n     }\n \n     fn rebuild_args_ty(&self,\n-                       inputs: &[hir::Arg],\n+                       inputs: &[P<hir::Ty>],\n                        lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> hir::HirVec<hir::Arg> {\n-        let mut new_inputs = Vec::new();\n-        for arg in inputs {\n-            let new_ty = self.rebuild_arg_ty_or_output(&arg.ty, lifetime,\n-                                                       anon_nums, region_names);\n-            let possibly_new_arg = hir::Arg {\n-                ty: new_ty,\n-                pat: arg.pat.clone(),\n-                id: arg.id\n-            };\n-            new_inputs.push(possibly_new_arg);\n-        }\n-        new_inputs.into()\n+                       -> hir::HirVec<P<hir::Ty>> {\n+        inputs.iter().map(|arg_ty| {\n+            self.rebuild_arg_ty_or_output(arg_ty, lifetime, anon_nums, region_names)\n+        }).collect()\n     }\n \n     fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n@@ -1634,10 +1626,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 constness: hir::Constness,\n                                 name: ast::Name,\n                                 generics: &hir::Generics,\n-                                span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name, generics);\n-        let msg = format!(\"consider using an explicit lifetime \\\n-                           parameter as shown: {}\", suggested_fn);\n+                                span: Span,\n+                                body: hir::BodyId) {\n+        let s = hir::print::to_string(&self.tcx.map, |s| {\n+            use syntax::abi::Abi;\n+            use syntax::print::pprust::PrintState;\n+\n+            s.head(\"\")?;\n+            s.print_fn(decl,\n+                       unsafety,\n+                       constness,\n+                       Abi::Rust,\n+                       Some(name),\n+                       generics,\n+                       &hir::Inherited,\n+                       &[],\n+                       Some(body))?;\n+            s.end()?; // Close the head box\n+            s.end()   // Close the outer box\n+        });\n+        let msg = format!(\"consider using an explicit lifetime parameter as shown: {}\", s);\n         err.span_help(span, &msg[..]);\n     }\n "}, {"sha": "ff508d2d8194a3b9d39de836e7448c1485bb74d1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -33,6 +33,7 @@\n #![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(libc)]\n #![feature(nonzero)]\n+#![feature(pub_restricted)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -80,9 +81,8 @@ pub mod lint;\n \n pub mod middle {\n     pub mod astconv_util;\n-    pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n+    pub mod expr_use_visitor;\n     pub mod const_val;\n-    pub mod const_qualif;\n     pub mod cstore;\n     pub mod dataflow;\n     pub mod dead;"}, {"sha": "cce79820ca8da5bea21811b57aca1cb4e50004e7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -821,6 +821,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n+            run_lints!(cx, check_expr_post, late_passes, e);\n         })\n     }\n \n@@ -835,8 +836,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n-        let body = self.tcx.map.expr(body_id);\n+                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.body(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -909,10 +910,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &'tcx hir::Expr) {\n-        run_lints!(self, check_expr_post, late_passes, e);\n-    }\n-\n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);"}, {"sha": "7e0da00694c4a4280aa5722d0122f6f9fe8286ea", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -162,14 +162,14 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n                 _: &LateContext<'a, 'tcx>,\n                 _: FnKind<'tcx>,\n                 _: &'tcx hir::FnDecl,\n-                _: &'tcx hir::Expr,\n+                _: &'tcx hir::Body,\n                 _: Span,\n                 _: ast::NodeId) { }\n     fn check_fn_post(&mut self,\n                      _: &LateContext<'a, 'tcx>,\n                      _: FnKind<'tcx>,\n                      _: &'tcx hir::FnDecl,\n-                     _: &'tcx hir::Expr,\n+                     _: &'tcx hir::Body,\n                      _: Span,\n                      _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }"}, {"sha": "ec98637922ee385d20bbc0f67277bb4ea3bd40f7", "filename": "src/librustc/middle/const_qualif.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs?ref=02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Const qualification, from partial to completely promotable.\n-bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable)]\n-    flags ConstQualif: u8 {\n-        // Inner mutability (can not be placed behind a reference) or behind\n-        // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM        = 1 << 0,\n-        // Constant value with a type that implements Drop. Can be copied\n-        // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP         = 1 << 1,\n-        // Even if the value can be placed in static memory, copying it from\n-        // there is more expensive than in-place instantiation, and/or it may\n-        // be too large. This applies to [T; N] and everything containing it.\n-        // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE    = 1 << 2,\n-        // May use more than 0 bytes of memory, doesn't impact the constness\n-        // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED     = 1 << 3,\n-        // Actually borrowed, has to always be in static memory. Does not\n-        // propagate, and requires the expression to behave like a 'static\n-        // lvalue. The set of expressions with this flag is the minimum\n-        // that have to be promoted.\n-        const HAS_STATIC_BORROWS = 1 << 4,\n-        // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST          = 1 << 5,\n-\n-        // Borrowing the expression won't produce &'static T if any of these\n-        // bits are set, though the value could be copied from static memory\n-        // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n-                                   ConstQualif::NEEDS_DROP.bits |\n-                                   ConstQualif::NOT_CONST.bits\n-    }\n-}"}, {"sha": "7151e5226cab0cb3f365d3b8a63d07af06706403", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 13, "deletions": 109, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -33,17 +33,17 @@ use mir::Mir;\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n+\n+use std::collections::BTreeMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::Visitor;\n use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -134,102 +134,6 @@ pub struct NativeLibrary {\n     pub foreign_items: Vec<DefIndex>,\n }\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct InlinedItem {\n-    pub def_id: DefId,\n-    pub body: P<hir::Expr>,\n-    pub const_fn_args: Vec<Option<DefId>>,\n-}\n-\n-/// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n-/// a crate; it then gets read as an InlinedItem.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub struct InlinedItemRef<'a> {\n-    pub def_id: DefId,\n-    pub body: &'a hir::Expr,\n-    pub const_fn_args: Vec<Option<DefId>>,\n-}\n-\n-fn get_fn_args(decl: &hir::FnDecl) -> Vec<Option<DefId>> {\n-    decl.inputs.iter().map(|arg| match arg.pat.node {\n-        hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n-        _ => None\n-    }).collect()\n-}\n-\n-impl<'a> InlinedItemRef<'a> {\n-    pub fn from_item<'b, 'tcx>(def_id: DefId,\n-                               item: &'a hir::Item,\n-                               tcx: TyCtxt<'b, 'a, 'tcx>)\n-                               -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n-            hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n-                (tcx.map.expr(body_id), get_fn_args(decl)),\n-            hir::ItemConst(_, ref body) => (&**body, Vec::new()),\n-            _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: body,\n-            const_fn_args: args\n-        }\n-    }\n-\n-    pub fn from_trait_item(def_id: DefId,\n-                           item: &'a hir::TraitItem,\n-                           _tcx: TyCtxt)\n-                           -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n-            hir::ConstTraitItem(_, Some(ref body)) =>\n-                (&**body, Vec::new()),\n-            hir::ConstTraitItem(_, None) => {\n-                bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n-            },\n-            _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: body,\n-            const_fn_args: args\n-        }\n-    }\n-\n-    pub fn from_impl_item<'b, 'tcx>(def_id: DefId,\n-                                    item: &'a hir::ImplItem,\n-                                    tcx: TyCtxt<'b, 'a, 'tcx>)\n-                                    -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n-            hir::ImplItemKind::Method(ref sig, body_id) =>\n-                (tcx.map.expr(body_id), get_fn_args(&sig.decl)),\n-            hir::ImplItemKind::Const(_, ref body) =>\n-                (&**body, Vec::new()),\n-            _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: body,\n-            const_fn_args: args\n-        }\n-    }\n-\n-    pub fn visit<V>(&self, visitor: &mut V)\n-        where V: Visitor<'a>\n-    {\n-        visitor.visit_expr(&self.body);\n-    }\n-}\n-\n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        visitor.visit_expr(&self.body);\n-    }\n-}\n-\n pub enum LoadedMacro {\n     MacroRules(ast::MacroDef),\n     ProcMacro(Rc<SyntaxExtension>),\n@@ -346,10 +250,10 @@ pub trait CrateStore<'tcx> {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)>;\n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n+    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                               -> Option<&'tcx hir::Body>;\n+    fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n@@ -516,15 +420,15 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)> {\n-        bug!(\"maybe_get_item_ast\")\n+    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                               -> Option<&'tcx hir::Body> {\n+        bug!(\"maybe_get_item_body\")\n     }\n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n-        bug!(\"local_node_for_inlined_defid\")\n+    fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n+        bug!(\"item_body_nested_bodies\")\n     }\n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n-        bug!(\"defid_for_inlined_node\")\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool {\n+        bug!(\"const_is_rvalue_promotable_to_static\")\n     }\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "dfcb5cb7b79fee81b4c21224ba1c0ed9c77f7c8d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -108,6 +108,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n+    fn nested(&self, state: &mut pprust::State, nested: pprust::Nested) -> io::Result<()> {\n+        pprust::PpAnn::nested(&self.tcx.map, state, nested)\n+    }\n     fn pre(&self,\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -160,16 +163,16 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n     }\n }\n \n-fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n+fn build_nodeid_to_index(body: Option<&hir::Body>,\n                          cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?\n-    if let Some(decl) = decl {\n-        add_entries_from_fn_decl(&mut index, decl, cfg.entry);\n+    if let Some(body) = body {\n+        add_entries_from_fn_body(&mut index, body, cfg.entry);\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n@@ -181,20 +184,24 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n \n     return index;\n \n-    fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n-                                decl: &hir::FnDecl,\n+    /// Add mappings from the ast nodes for the formal bindings to\n+    /// the entry-node in the graph.\n+    fn add_entries_from_fn_body(index: &mut NodeMap<Vec<CFGIndex>>,\n+                                body: &hir::Body,\n                                 entry: CFGIndex) {\n-        //! add mappings from the ast nodes for the formal bindings to\n-        //! the entry-node in the graph.\n+        use hir::intravisit::Visitor;\n+\n         struct Formals<'a> {\n             entry: CFGIndex,\n             index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        intravisit::walk_fn_decl(&mut formals, decl);\n-        impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n+        for arg in &body.arguments {\n+            formals.visit_pat(&arg.pat);\n+        }\n+        impl<'a, 'v> Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n-                panic!(\"should not encounter fn bodies or items\")\n+                intravisit::NestedVisitorMap::None\n             }\n \n             fn visit_pat(&mut self, p: &hir::Pat) {\n@@ -227,7 +234,7 @@ pub enum KillFrom {\n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n-               decl: Option<&hir::FnDecl>,\n+               body: Option<&hir::Body>,\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n@@ -250,7 +257,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills2 = zeroes;\n         let on_entry = vec![entry; num_nodes * words_per_id];\n \n-        let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n+        let nodeid_to_index = build_nodeid_to_index(body, cfg);\n \n         DataFlowContext {\n             tcx: tcx,\n@@ -502,7 +509,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Expr) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -526,20 +533,11 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n         }\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n-        debug!(\"{}\", {\n-            let mut v = Vec::new();\n-            self.pretty_print_to(box &mut v, body).unwrap();\n-            String::from_utf8(v).unwrap()\n-        });\n-    }\n-\n-    fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           body: &hir::Expr) -> io::Result<()> {\n-        let mut ps = pprust::rust_printer_annotated(wr, self, None);\n-        ps.cbox(pprust::indent_unit)?;\n-        ps.ibox(0)?;\n-        ps.print_expr(body)?;\n-        pp::eof(&mut ps.s)\n+        debug!(\"{}\", pprust::to_string(self, |s| {\n+            s.cbox(pprust::indent_unit)?;\n+            s.ibox(0)?;\n+            s.print_expr(&body.value)\n+        }));\n     }\n }\n "}, {"sha": "76adee4e00c15684ec411deddddf5daa2232cb45", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -328,11 +328,12 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                 self.worklist.extend(enum_def.variants.iter()\n                                                       .map(|variant| variant.node.data.id()));\n             }\n-            hir::ItemTrait(.., ref trait_items) => {\n-                for trait_item in trait_items {\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n+                for trait_item_ref in trait_item_refs {\n+                    let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.node {\n-                        hir::ConstTraitItem(_, Some(_)) |\n-                        hir::MethodTraitItem(_, Some(_)) => {\n+                        hir::TraitItemKind::Const(_, Some(_)) |\n+                        hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n@@ -354,6 +355,10 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _item: &hir::TraitItem) {\n+        // ignore: we are handling this in `visit_item` above\n+    }\n+\n     fn visit_impl_item(&mut self, _item: &hir::ImplItem) {\n         // ignore: we are handling this in `visit_item` above\n     }\n@@ -546,19 +551,19 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n-            hir::ImplItemKind::Const(_, ref expr) => {\n+            hir::ImplItemKind::Const(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"associated const\");\n                 }\n-                intravisit::walk_expr(self, expr)\n+                self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                self.visit_body(body_id)\n+                self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -567,15 +572,13 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref body)) => {\n-                intravisit::walk_expr(self, body)\n-            }\n-            hir::MethodTraitItem(_, Some(body_id)) => {\n-                self.visit_body(body_id)\n+            hir::TraitItemKind::Const(_, Some(body_id)) |\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {\n+                self.visit_nested_body(body_id)\n             }\n-            hir::ConstTraitItem(_, None) |\n-            hir::MethodTraitItem(_, None) |\n-            hir::TypeTraitItem(..) => {}\n+            hir::TraitItemKind::Const(_, None) |\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n+            hir::TraitItemKind::Type(..) => {}\n         }\n     }\n }"}, {"sha": "38b0b18b0129af7b7c6263505c85740c9d131eb3", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n+                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>"}, {"sha": "f2e46d4cbc96ba6c0831179db41b23e66e51fd29", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -17,7 +17,7 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn, ImplItem};\n+use hir::{Item, ItemFn, ImplItem, TraitItem};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n@@ -47,6 +47,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n         find_item(item, self, at_root);\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem) {\n+        // entry fn is never a trait item\n+    }\n \n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n         // entry fn is never an impl item"}, {"sha": "a3a49c916338e544a047bcd6b14f5fb819e2d066", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -287,20 +287,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn walk_fn(&mut self,\n-                   decl: &hir::FnDecl,\n-                   body: &hir::Expr) {\n-        self.walk_arg_patterns(decl, body);\n-        self.consume_expr(body);\n-    }\n-\n-    fn walk_arg_patterns(&mut self,\n-                         decl: &hir::FnDecl,\n-                         body: &hir::Expr) {\n-        for arg in &decl.inputs {\n+    pub fn consume_body(&mut self, body: &hir::Body) {\n+        for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n-            let fn_body_scope_r = self.tcx().node_scope_region(body.id);\n+            let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -309,6 +300,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n+\n+        self.consume_expr(&body.value);\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -537,9 +530,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprRepeat(ref base, ref count) => {\n+            hir::ExprRepeat(ref base, _) => {\n                 self.consume_expr(&base);\n-                self.consume_expr(&count);\n             }\n \n             hir::ExprClosure(.., fn_decl_span) => {"}, {"sha": "d932061d42d3db4984f56ee62c9373873398416d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -34,13 +34,13 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, expr: &'tcx hir::Expr) {\n+    fn visit_const(&mut self, item_id: ast::NodeId, body: hir::BodyId) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n         self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         });\n     }\n }\n@@ -122,33 +122,33 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     // const, static and N in [T; N].\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n-            visitor.visit_expr(expr);\n+            visitor.visit_body(body);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n-            self.visit_const(item.id, expr);\n+        if let hir::TraitItemKind::Const(_, Some(body)) = item.node {\n+            self.visit_const(item.id, body);\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n-            self.visit_const(item.id, expr);\n+        if let hir::ImplItemKind::Const(_, body) = item.node {\n+            self.visit_const(item.id, body);\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }"}, {"sha": "4cae5b370eb7eb77ee603a62c373ccf456dafe60", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -140,6 +140,10 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+        // at present, lang items are always items, not trait items\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n         // at present, lang items are always items, not impl items\n     }"}, {"sha": "745a94a5ddba31cd6cafc49f1d240872ef5d9511", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -127,7 +127,6 @@ use syntax_pos::Span;\n \n use hir::Expr;\n use hir;\n-use hir::print::{expr_to_string, block_to_string};\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n@@ -188,7 +187,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: NodeId) {\n+                b: hir::BodyId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n@@ -354,13 +353,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ir.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _: FnKind<'tcx>, _: &'tcx hir::FnDecl,\n-                _: hir::ExprId, _: Span, _: NodeId) {\n-        // do not check contents of nested fns\n-    }\n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n         check_local(self, l);\n     }\n@@ -375,7 +370,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n                           fk: FnKind<'tcx>,\n                           decl: &'tcx hir::FnDecl,\n-                          body_id: hir::ExprId,\n+                          body_id: hir::BodyId,\n                           sp: Span,\n                           id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -385,7 +380,9 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n-    for arg in &decl.inputs {\n+    let body = ir.tcx.map.body(body_id);\n+\n+    for arg in &body.arguments {\n         arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n@@ -408,16 +405,14 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n-    let body = ir.tcx.map.expr(body_id);\n-\n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n-    let entry_ln = lsets.compute(body);\n+    let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n-    lsets.visit_expr(body);\n+    lsets.visit_body(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n-    lsets.warn_about_unused_args(decl, entry_ln);\n+    lsets.warn_about_unused_args(body, entry_ln);\n }\n \n fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n@@ -823,7 +818,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for body, {}\", expr_to_string(body));\n+        debug!(\"compute: using id for body, {}\", self.ir.tcx.map.node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n@@ -916,7 +911,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", expr_to_string(expr));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.map.node_to_pretty_string(expr.id));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n@@ -935,14 +930,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n-                     expr_to_string(expr));\n+                     self.ir.tcx.map.node_to_pretty_string(expr.id));\n \n               /*\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk_id.node_id(), succ, node, |this| {\n+              self.with_loop_nodes(blk_id.node_id, succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n@@ -1088,11 +1083,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprRepeat(ref element, ref count) => {\n-            let succ = self.propagate_through_expr(&count, succ);\n-            self.propagate_through_expr(&element, succ)\n-          }\n-\n           hir::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n@@ -1149,7 +1139,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n-          hir::ExprUnary(_, ref e) => {\n+          hir::ExprUnary(_, ref e) |\n+          hir::ExprRepeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n \n@@ -1315,7 +1306,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, block_to_string(body));\n+               expr.id, self.ir.tcx.map.node_to_pretty_string(body.id));\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n@@ -1443,7 +1434,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &hir::Expr)\n+                 body: &hir::Body)\n     {\n         let fn_ty = if let FnKind::Closure(_) = fk {\n             self.ir.tcx.tables().node_id_to_type(id)\n@@ -1460,7 +1451,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                self.ir.tcx.region_maps.call_site_extent(id, body.id),\n+                self.ir.tcx.region_maps.call_site_extent(id, body.value.id),\n                 &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n@@ -1510,8 +1501,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n-        for arg in &decl.inputs {\n+    fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n+        for arg in &body.arguments {\n             arg.pat.each_binding(|_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "2d88567b8b873228d292229d057aa087a6ff872f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -73,7 +73,6 @@ use self::Aliasability::*;\n use hir::def_id::DefId;\n use hir::map as ast_map;\n use infer::InferCtxt;\n-use middle::const_qualif::ConstQualif;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n@@ -705,7 +704,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n+                hir::ExprClosure(.., body_id, _) => body_id.node_id,\n                 _ => bug!()\n             }\n         };\n@@ -773,23 +772,23 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(ConstQualif::NOT_CONST);\n+        let promotable = self.tcx().rvalue_promotable_to_static.borrow().get(&id).cloned()\n+                                   .unwrap_or(false);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n-        let qualif = match expr_ty.sty {\n-            ty::TyArray(_, 0) => qualif,\n-            _ => ConstQualif::NOT_CONST\n+        let promotable = match expr_ty.sty {\n+            ty::TyArray(_, 0) => true,\n+            _ => promotable & false\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-            self.temporary_scope(id)\n-        } else {\n+        let re = if promotable {\n             self.tcx().mk_region(ty::ReStatic)\n+        } else {\n+            self.temporary_scope(id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "ee841afc02169e96d0d5cf15eb1197a2f6ca650c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -166,9 +166,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n-                    hir::ConstTraitItem(_, ref default) => default.is_some(),\n-                    hir::MethodTraitItem(_, ref body) => body.is_some(),\n-                    hir::TypeTraitItem(..) => false,\n+                    hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n+                    hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n@@ -250,15 +251,15 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n-                            self.visit_body(body);\n+                            self.visit_nested_body(body);\n                         }\n                     }\n \n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n-                    hir::ItemConst(_, ref init) => {\n-                        self.visit_expr(&init);\n+                    hir::ItemConst(_, init) => {\n+                        self.visit_nested_body(init);\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -274,28 +275,26 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n-                    hir::ConstTraitItem(_, None) |\n-                    hir::MethodTraitItem(_, None) => {\n+                    hir::TraitItemKind::Const(_, None) |\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref body)) => {\n-                        self.visit_expr(body);\n+                    hir::TraitItemKind::Const(_, Some(body_id)) |\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {\n+                        self.visit_nested_body(body_id);\n                     }\n-                    hir::MethodTraitItem(_, Some(body_id)) => {\n-                        self.visit_body(body_id);\n-                    }\n-                    hir::TypeTraitItem(..) => {}\n+                    hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n-                    hir::ImplItemKind::Const(_, ref expr) => {\n-                        self.visit_expr(&expr);\n+                    hir::ImplItemKind::Const(_, body) => {\n+                        self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(ref sig, body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            self.visit_body(body)\n+                            self.visit_nested_body(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}\n@@ -358,6 +357,8 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {}\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n         // processed in visit_item above\n     }"}, {"sha": "faf4a448b7a84e5b20ea8d0ba53384044bc74a78", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1088,7 +1088,7 @@ fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a\n fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n                         kind: FnKind<'tcx>,\n                         decl: &'tcx hir::FnDecl,\n-                        body_id: hir::ExprId,\n+                        body_id: hir::BodyId,\n                         sp: Span,\n                         id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1101,22 +1101,22 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n            visitor.cx.parent);\n \n     visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n \n     let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id() });\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n \n     if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body_id.node_id(), root_id);\n+        visitor.region_maps.record_fn_parent(body_id.node_id, root_id);\n     }\n \n     let outer_cx = visitor.cx;\n     let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body_id.node_id());\n+    visitor.terminating_scopes.insert(body_id.node_id);\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n-        root_id: Some(body_id.node_id()),\n+        root_id: Some(body_id.node_id),\n         parent: ROOT_CODE_EXTENT,\n         var_parent: fn_decl_scope,\n     };\n@@ -1126,11 +1126,11 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n-        root_id: Some(body_id.node_id()),\n+        root_id: Some(body_id.node_id),\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_body(body_id);\n+    visitor.visit_nested_body(body_id);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n@@ -1195,7 +1195,7 @@ impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n-                b: hir::ExprId, s: Span, n: NodeId) {\n+                b: hir::BodyId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_arm(&mut self, a: &'ast Arm) {"}, {"sha": "c491af972acbce6120f926b2f66b13166d06fd69", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -33,7 +33,6 @@ use util::nodemap::NodeMap;\n \n use rustc_data_structures::fx::FxHashSet;\n use hir;\n-use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n@@ -190,7 +189,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                hir::ForeignItemFn(ref decl, ref generics) => {\n+                hir::ForeignItemFn(ref decl, _, ref generics) => {\n                     this.visit_early_late(item.id, decl, generics, |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n@@ -206,7 +205,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, fn_id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -266,7 +265,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n-        if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n+        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) =\n+                trait_item.node {\n             self.visit_early_late(\n                 trait_item.id,\n                 &sig.decl, &sig.generics,\n@@ -407,7 +407,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -419,7 +419,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_expr(ctxt.hir_map.expr(b));\n+    gather.visit_body(ctxt.hir_map.body(b));\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn(&mut self,\n                              fk: FnKind<'tcx>,\n                              fd: &'tcx hir::FnDecl,\n-                             fb: hir::ExprId,\n+                             fb: hir::BodyId,\n                              _span: Span,\n                              fn_id: ast::NodeId) {\n         match fk {\n@@ -522,8 +522,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id(), s: self.scope },\n-                  |_old_scope, this| this.visit_body(fb))\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n+                  |_old_scope, this| this.visit_nested_body(fb))\n     }\n \n     // FIXME(#37666) this works around a limitation in the region inferencer\n@@ -821,9 +821,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                        probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?} span={:?}\",\n-               lifetime_to_string(lifetime_ref),\n-               lifetime_ref.id,\n+        debug!(\"{} resolved to {:?} span={:?}\",\n+               self.hir_map.node_to_string(lifetime_ref.id),\n                def,\n                self.sess.codemap().span_to_string(lifetime_ref.span));\n         self.map.defs.insert(lifetime_ref.id, def);\n@@ -860,8 +859,8 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n     let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n-    for arg in &decl.inputs {\n-        constrained_by_input.visit_ty(&arg.ty);\n+    for arg_ty in &decl.inputs {\n+        constrained_by_input.visit_ty(arg_ty);\n     }\n \n     let mut appears_in_output = AllCollector {"}, {"sha": "3c5a91f4ff04c8dae35599a94bbf7d9964032d2e", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> MirSource {\n \n         match tcx.map.get(id) {\n             map::NodeItem(&Item { node: ItemConst(..), .. }) |\n-            map::NodeTraitItem(&TraitItem { node: ConstTraitItem(..), .. }) |\n+            map::NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             map::NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) => {\n                 MirSource::Const(id)\n             }"}, {"sha": "cb1fc15c5f68210c704352863b87a7f6a73229ad", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -508,14 +508,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// Cache used by const_eval when decoding external constants.\n-    /// Contains `None` when the constant has been fetched but doesn't exist.\n-    /// Constains `Some(expr_id, type)` otherwise.\n-    /// `type` is `None` in case it's not a primitive type\n-    pub extern_const_statics: RefCell<DefIdMap<Option<(NodeId, Option<Ty<'tcx>>)>>>,\n-    /// Cache used by const_eval when decoding extern const fns\n-    pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -537,8 +529,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Caches the representation hints for struct definitions.\n     repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n \n-    /// Maps Expr NodeId's to their constant qualification.\n-    pub const_qualif_map: RefCell<NodeMap<middle::const_qualif::ConstQualif>>,\n+    /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n+    pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n@@ -787,13 +779,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             used_trait_imports: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n-            extern_const_statics: RefCell::new(DefIdMap()),\n-            extern_const_fns: RefCell::new(DefIdMap()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            const_qualif_map: RefCell::new(NodeMap()),\n+            rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),"}, {"sha": "b03a432de413107a4c4a25f69c552ba3a1db7679", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1206,13 +1206,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.map.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.node_id()))\n+                            tcx.region_maps.call_site_extent(id, body.node_id))\n                     }\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    hir::TypeTraitItem(..) | hir::ConstTraitItem(..) => {\n+                    hir::TraitItemKind::Type(..) | hir::TraitItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = tcx.map.get_parent(id);\n@@ -1221,13 +1221,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             trait_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n-                    hir::MethodTraitItem(_, ref body) => {\n+                    hir::TraitItemKind::Method(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let extent = if let Some(body_id) = *body {\n+                        let extent = if let hir::TraitMethod::Provided(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id())\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id)\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n                             tcx.region_maps.item_extent(id)\n@@ -1248,7 +1248,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id()))\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1284,7 +1284,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        tcx.region_maps.call_site_extent(id, body.node_id()))\n+                        tcx.region_maps.call_site_extent(id, body.node_id))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -2100,10 +2100,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                hir::ItemTrait(.., ref trait_items) => {\n-                    for trait_item in trait_items {\n+                hir::ItemTrait(.., ref trait_item_refs) => {\n+                    for trait_item_ref in trait_item_refs {\n                         let assoc_item =\n-                            self.associated_item_from_trait_item_ref(parent_def_id, trait_item);\n+                            self.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n                         self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n@@ -2121,28 +2121,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n-                                           trait_item: &hir::TraitItem)\n+                                           trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.map.local_def_id(trait_item.id);\n-\n-        let (kind, has_self, has_value) = match trait_item.node {\n-            hir::MethodTraitItem(ref sig, ref body) => {\n-                (AssociatedKind::Method, sig.decl.get_self().is_some(),\n-                 body.is_some())\n-            }\n-            hir::ConstTraitItem(_, ref value) => {\n-                (AssociatedKind::Const, false, value.is_some())\n-            }\n-            hir::TypeTraitItem(_, ref ty) => {\n-                (AssociatedKind::Type, false, ty.is_some())\n+        let def_id = self.map.local_def_id(trait_item_ref.id.node_id);\n+        let (kind, has_self) = match trait_item_ref.kind {\n+            hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                (ty::AssociatedKind::Method, has_self)\n             }\n+            hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n         };\n \n         AssociatedItem {\n-            name: trait_item.name,\n+            name: trait_item_ref.name,\n             kind: kind,\n-            vis: Visibility::from_hir(&hir::Inherited, trait_item.id, self),\n-            defaultness: hir::Defaultness::Default { has_value: has_value },\n+            vis: Visibility::from_hir(&hir::Inherited, trait_item_ref.id.node_id, self),\n+            defaultness: trait_item_ref.defaultness,\n             def_id: def_id,\n             container: TraitContainer(parent_def_id),\n             method_has_self_argument: has_self\n@@ -2187,11 +2181,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let item = self.map.expect_item(id);\n             let vec: Vec<_> = match item.node {\n-                hir::ItemTrait(.., ref trait_items) => {\n-                    trait_items.iter()\n-                               .map(|trait_item| trait_item.id)\n-                               .map(|id| self.map.local_def_id(id))\n-                               .collect()\n+                hir::ItemTrait(.., ref trait_item_refs) => {\n+                    trait_item_refs.iter()\n+                                   .map(|trait_item_ref| trait_item_ref.id)\n+                                   .map(|id| self.map.local_def_id(id.node_id))\n+                                   .collect()\n                 }\n                 hir::ItemImpl(.., ref impl_item_refs) => {\n                     impl_item_refs.iter()"}, {"sha": "dc2214dd34e72141ae4f6a02d59599fcaef22afb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -189,9 +189,8 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n-                                     decl: &hir::FnDecl,\n-                                     body: &hir::Expr) {\n-    debug!(\"check_loans(body id={})\", body.id);\n+                                     body: &hir::Body) {\n+    debug!(\"check_loans(body id={})\", body.value.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n@@ -202,7 +201,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(decl, body);\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx).consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "34f1ad57c6211e8317a21fa15365030f8db23e1f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -41,21 +41,20 @@ mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n-                                    decl: &hir::FnDecl,\n-                                    body: &hir::Expr)\n+                                    body: &hir::Body)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps.node_extent(body.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.value.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(decl, body);\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -548,14 +547,14 @@ impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n \n pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n                                                     item_id: ast::NodeId,\n-                                                    expr: &'tcx hir::Expr) {\n+                                                    body: hir::BodyId) {\n \n-    debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n+    debug!(\"gather_loans_in_static_initializer(expr={:?})\", body);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx,\n         item_id: item_id\n     };\n \n-    sicx.visit_expr(expr);\n+    sicx.visit_nested_body(body);\n }"}, {"sha": "c7bd5b7ed0461c2c7bd0ef3340a4b7304ee5ba96", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -11,10 +11,7 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-use rustc::hir;\n-use rustc::hir::intravisit::{FnKind};\n+use syntax_pos::DUMMY_SP;\n \n use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n@@ -57,27 +54,14 @@ pub struct MoveDataParamEnv<'tcx> {\n }\n \n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n-                    fk: FnKind,\n-                    _decl: &hir::FnDecl,\n-                    body: &hir::Expr,\n-                    _sp: Span,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {\n-    match fk {\n-        FnKind::ItemFn(name, ..) |\n-        FnKind::Method(name, ..) => {\n-            debug!(\"borrowck_mir({}) UNIMPLEMENTED\", name);\n-        }\n-        FnKind::Closure(_) => {\n-            debug!(\"borrowck_mir closure (body.id={}) UNIMPLEMENTED\", body.id);\n-        }\n-    }\n-\n     let tcx = bcx.tcx;\n-    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-\n-    let mir = &tcx.item_mir(tcx.map.local_def_id(id));\n+    let def_id = tcx.map.local_def_id(id);\n+    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n \n+    let mir = &tcx.item_mir(def_id);\n+    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits ="}, {"sha": "1ba313015d59685c82af9830cd77a9923b20352d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -88,15 +88,15 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n+        if let hir::TraitItemKind::Const(_, Some(expr)) = ti.node {\n+            gather_loans::gather_loans_in_static_initializer(self, ti.id, expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n+        if let hir::ImplItemKind::Const(_, expr) = ii.node {\n+            gather_loans::gather_loans_in_static_initializer(self, ii.id, expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -141,9 +141,9 @@ fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::I\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        hir::ItemStatic(.., ref ex) |\n-        hir::ItemConst(_, ref ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, item.id, &ex);\n+        hir::ItemStatic(.., ex) |\n+        hir::ItemConst(_, ex) => {\n+            gather_loans::gather_loans_in_static_initializer(this, item.id, ex);\n         }\n         _ => { }\n     }\n@@ -161,25 +161,25 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                          fk: FnKind<'tcx>,\n                          decl: &'tcx hir::FnDecl,\n-                         body_id: hir::ExprId,\n+                         body_id: hir::BodyId,\n                          sp: Span,\n                          id: ast::NodeId,\n                          attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n-    let body = this.tcx.map.expr(body_id);\n+    let body = this.tcx.map.body(body_id);\n \n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n         this.with_temp_region_map(id, |this| {\n-            mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n+            mir::borrowck_mir(this, id, attributes)\n         });\n     }\n \n-    let cfg = cfg::CFG::new(this.tcx, body);\n+    let cfg = cfg::CFG::new(this.tcx, &body.value);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n+        build_borrowck_dataflow_data(this, &cfg, body, id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n                                                     this.tcx,\n@@ -194,31 +194,31 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              &flowed_moves,\n                              &all_loans[..],\n                              id,\n-                             decl,\n                              body);\n \n     intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                          fk: FnKind<'tcx>,\n-                                          decl: &'tcx hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &'tcx hir::Expr,\n-                                          sp: Span,\n+                                          body: &'tcx hir::Body,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id, &tcx.map);\n+    let id_range = {\n+        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.map);\n+        visitor.visit_body(body);\n+        visitor.result()\n+    };\n     let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, id, decl, body);\n+        gather_loans::gather_loans_in_fn(this, id, body);\n \n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n-                             Some(decl),\n+                             Some(body),\n                              cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n@@ -235,7 +235,6 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                                       this.tcx,\n                                                       cfg,\n                                                       id_range,\n-                                                      decl,\n                                                       body);\n \n     AnalysisData { all_loans: all_loans,\n@@ -263,14 +262,11 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n-    let body = tcx.map.expr(fn_parts.body);\n+    let body = tcx.map.body(fn_parts.body);\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n-                                                     fn_parts.kind,\n-                                                     &fn_parts.decl,\n                                                      cfg,\n                                                      body,\n-                                                     fn_parts.span,\n                                                      fn_parts.id);\n \n     (bccx, dataflow_data)\n@@ -416,7 +412,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _) => {\n-                body_id.node_id()\n+                body_id.node_id\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)\n@@ -1121,22 +1117,21 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n                     if let Categorization::Local(local_id) = inner_cmt.cat {\n                         let parent = self.tcx.map.get_parent_node(local_id);\n-                        let opt_fn_decl = FnLikeNode::from_node(self.tcx.map.get(parent))\n-                            .map(|fn_like| fn_like.decl());\n \n-                        if let Some(fn_decl) = opt_fn_decl {\n-                            if let Some(ref arg) = fn_decl.inputs.iter()\n-                                .find(|ref arg| arg.pat.id == local_id) {\n+                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.map.get(parent)) {\n+                            if let Some(i) = self.tcx.map.body(fn_like.body()).arguments.iter()\n+                                                     .position(|arg| arg.pat.id == local_id) {\n+                                let arg_ty = &fn_like.decl().inputs[i];\n                                 if let hir::TyRptr(\n                                     opt_lifetime,\n                                     hir::MutTy{mutbl: hir::Mutability::MutImmutable, ref ty}) =\n-                                    arg.ty.node {\n+                                    arg_ty.node {\n                                     if let Some(lifetime) = opt_lifetime {\n                                         if let Ok(snippet) = self.tcx.sess.codemap()\n                                             .span_to_snippet(ty.span) {\n                                             if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n                                                 .span_to_snippet(lifetime.span) {\n-                                                    db.span_label(arg.ty.span,\n+                                                    db.span_label(arg_ty.span,\n                                                                   &format!(\"use `&{} mut {}` \\\n                                                                             here to make mutable\",\n                                                                             lifetime_snippet,\n@@ -1145,9 +1140,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                         }\n                                     }\n                                     else if let Ok(snippet) = self.tcx.sess.codemap()\n-                                        .span_to_snippet(arg.ty.span) {\n+                                        .span_to_snippet(arg_ty.span) {\n                                         if snippet.starts_with(\"&\") {\n-                                            db.span_label(arg.ty.span,\n+                                            db.span_label(arg_ty.span,\n                                                           &format!(\"use `{}` here to make mutable\",\n                                                                    snippet.replace(\"&\", \"&mut \")));\n                                         }"}, {"sha": "a02aba7208c7fe4be3c6975eb1ac8d24a266e4d6", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -655,21 +655,20 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n-               decl: &hir::FnDecl,\n-               body: &hir::Expr)\n+               body: &hir::Body)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\",\n-                                 Some(decl),\n+                                 Some(body),\n                                  cfg,\n                                  MoveDataFlowOperator,\n                                  id_range,\n                                  move_data.moves.borrow().len());\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_assigns\",\n-                                 Some(decl),\n+                                 Some(body),\n                                  cfg,\n                                  AssignDataFlowOperator,\n                                  id_range,"}, {"sha": "01b19e1f53979d8dd563a9ed60873b47983fe98b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -30,7 +30,6 @@ use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-use rustc::hir::print::pat_to_string;\n use rustc::hir::{self, Pat, PatKind};\n \n use rustc_back::slice;\n@@ -43,39 +42,17 @@ struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, _expr: &'tcx hir::Expr) {\n-        return // const, static and N in [T; N] - shouldn't contain anything\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::ConstTraitItem(..) = item.node {\n-            return // nothing worth match checking in a constant\n-        } else {\n-            intravisit::walk_trait_item(self, item);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(..) = item.node {\n-            return // nothing worth match checking in a constant\n-        } else {\n-            intravisit::walk_impl_item(self, item);\n-        }\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n-        if let FnKind::Closure(..) = fk {\n-            span_bug!(s, \"check_match: closure outside of function\")\n-        }\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n+        intravisit::walk_fn(self, fk, fd, b, s, id);\n \n         MatchVisitor {\n             tcx: self.tcx,\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n-        }.visit_fn(fk, fd, b, s, id);\n+        }.visit_body(self.tcx.map.body(b));\n     }\n }\n \n@@ -96,7 +73,7 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n@@ -119,13 +96,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, n: ast::NodeId) {\n-        intravisit::walk_fn(self, fk, fd, b, s, n);\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+        intravisit::walk_body(self, body);\n \n-        for input in &fd.inputs {\n-            self.check_irrefutable(&input.pat, true);\n-            self.check_patterns(false, slice::ref_slice(&input.pat));\n+        for arg in &body.arguments {\n+            self.check_irrefutable(&arg.pat, true);\n+            self.check_patterns(false, slice::ref_slice(&arg.pat));\n         }\n     }\n }\n@@ -254,7 +230,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 Useful => bug!()\n             };\n \n-            let pattern_string = pat_to_string(witness[0].single_pattern());\n+            let pattern_string = hir::print::to_string(&self.tcx.map, |s| {\n+                s.print_pat(witness[0].single_pattern())\n+            });\n             let mut diag = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n                 \"refutable pattern in {}: `{}` not covered\",\n@@ -405,7 +383,9 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         },\n                         _ => bug!(),\n                     };\n-                    let pattern_string = pat_to_string(witness);\n+                    let pattern_string = hir::print::to_string(&cx.tcx.map, |s| {\n+                        s.print_pat(witness)\n+                    });\n                     struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n@@ -415,7 +395,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 },\n                 _ => {\n                     let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n-                        pat_to_string(w)\n+                        hir::print::to_string(&cx.tcx.map, |s| s.print_pat(w))\n                     }).collect();\n                     const LIMIT: usize = 3;\n                     let joined_patterns = match pattern_strings.len() {"}, {"sha": "b24cd261dd58474730ee98fc242ef15f222e803f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -576,18 +576,18 @@ https://doc.rust-lang.org/reference.html#ffi-attributes\n \n \n E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+In an array type `[T; N]`, `N` is the number of elements in the array. This\n must be an unsigned integer. Erroneous code example:\n \n ```compile_fail,E0306\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n+const X: [i32; true] = [0]; // error: expected `usize` for array length,\n+                            //        found boolean\n ```\n \n Working example:\n \n ```\n-let x = [0i32; 2];\n+const X: [i32; 1] = [0];\n ```\n \"##,\n }"}, {"sha": "e8e7a2eb7ede0919fb3c167aa0416312ee0350e5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 46, "deletions": 98, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -17,7 +17,6 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -56,15 +55,17 @@ macro_rules! math {\n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n                                   -> Option<&'tcx Expr> {\n-    fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n-                        -> Option<&'a Expr> {\n+    let variant_expr = |variants: &'tcx [hir::Variant], id: ast::NodeId |\n+                        -> Option<&'tcx Expr> {\n         for variant in variants {\n             if variant.node.data.id() == id {\n-                return variant.node.disr_expr.as_ref().map(|e| &**e);\n+                return variant.node.disr_expr.map(|e| {\n+                    &tcx.map.body(e).value\n+                });\n             }\n         }\n         None\n-    }\n+    };\n \n     if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.map.get_parent(variant_node_id);\n@@ -96,21 +97,24 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&const_expr, tcx.ast_ty_to_prim_ty(ty)))\n+                hir::ItemConst(ref ty, body) => {\n+                    Some((&tcx.map.body(body).value,\n+                          tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::ConstTraitItem(ref ty, ref expr_option) => {\n+                hir::TraitItemKind::Const(ref ty, default) => {\n                     if let Some(substs) = substs {\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         let trait_id = tcx.map.get_parent(node_id);\n                         let trait_id = tcx.map.local_def_id(trait_id);\n-                        let default_value = expr_option.as_ref()\n-                            .map(|expr| (&**expr, tcx.ast_ty_to_prim_ty(ty)));\n+                        let default_value = default.map(|body| {\n+                            (&tcx.map.body(body).value,\n+                             tcx.ast_ty_to_prim_ty(ty))\n+                        });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n@@ -125,38 +129,26 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&expr, tcx.ast_ty_to_prim_ty(ty)))\n+                hir::ImplItemKind::Const(ref ty, body) => {\n+                    Some((&tcx.map.body(body).value,\n+                          tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_statics.borrow().get(&def_id) {\n-            Some(&None) => return None,\n-            Some(&Some((expr_id, ty))) => {\n-                return Some((tcx.map.expect_expr(expr_id), ty));\n-            }\n-            None => {}\n-        }\n-        let mut used_substs = false;\n-        let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem { body: ref const_expr, .. }, _)) => {\n-                Some((&**const_expr, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n-            }\n-            _ => None\n-        };\n-        let expr_ty = match tcx.sess.cstore.describe_def(def_id) {\n+        let expr_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+        });\n+        match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n                 let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n                 // As mentioned in the comments above for in-crate\n                 // constants, we only try to find the expression for a\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n-                    used_substs = true;\n-\n                     if let Some(substs) = substs {\n                         resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n                     } else {\n@@ -168,70 +160,27 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             },\n             Some(Def::Const(..)) => expr_ty,\n             _ => None\n-        };\n-        // If we used the substitutions, particularly to choose an impl\n-        // of a trait-associated const, don't cache that, because the next\n-        // lookup with the same def_id may yield a different result.\n-        if !used_substs {\n-            tcx.extern_const_statics\n-               .borrow_mut()\n-               .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n         }\n-        expr_ty\n     }\n }\n \n-fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 def_id: DefId)\n-                                                 -> Option<ast::NodeId> {\n-    match tcx.extern_const_fns.borrow().get(&def_id) {\n-        Some(&ast::DUMMY_NODE_ID) => return None,\n-        Some(&fn_id) => return Some(fn_id),\n-        None => {}\n-    }\n-\n-    if !tcx.sess.cstore.is_const_fn(def_id) {\n-        tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n-        return None;\n-    }\n-\n-    let fn_id = tcx.sess.cstore.maybe_get_item_ast(tcx, def_id).map(|t| t.1);\n-    tcx.extern_const_fns.borrow_mut().insert(def_id,\n-                                             fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n-    fn_id\n-}\n-\n-pub enum ConstFnNode<'tcx> {\n-    Local(FnLikeNode<'tcx>),\n-    Inlined(&'tcx InlinedItem)\n-}\n-\n-pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                       -> Option<ConstFnNode<'tcx>>\n+fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                                   -> Option<&'tcx hir::Body>\n {\n-    let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        node_id\n-    } else {\n-        if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n-            if let ast_map::NodeInlinedItem(ii) = tcx.map.get(fn_id) {\n-                return Some(ConstFnNode::Inlined(ii));\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n+            if fn_like.constness() == hir::Constness::Const {\n+                Some(tcx.map.body(fn_like.body()))\n             } else {\n-                bug!(\"Got const fn from external crate, but it's not inlined\")\n+                None\n             }\n+        })\n+    } else {\n+        if tcx.sess.cstore.is_const_fn(def_id) {\n+            tcx.sess.cstore.maybe_get_item_body(tcx, def_id)\n         } else {\n-            return None;\n+            None\n         }\n-    };\n-\n-    let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n-        Some(fn_like) => fn_like,\n-        None => return None\n-    };\n-\n-    if fn_like.constness() == hir::Constness::Const {\n-        Some(ConstFnNode::Local(fn_like))\n-    } else {\n-        None\n     }\n }\n \n@@ -864,18 +813,15 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (arg_defs, body_id) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), ii.body.expr_id()),\n-              Some(ConstFnNode::Local(fn_like)) =>\n-                  (fn_like.decl().inputs.iter()\n-                   .map(|arg| match arg.pat.node {\n-                       hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n-                       _ => None\n-                   }).collect(),\n-                   fn_like.body()),\n+          let body = match lookup_const_fn_by_id(tcx, did) {\n+              Some(body) => body,\n               None => signal!(e, NonConstPath),\n           };\n-          let result = tcx.map.expr(body_id);\n+\n+          let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n+               hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+               _ => None\n+           }).collect::<Vec<_>>();\n           assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n@@ -893,7 +839,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n-          eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n+          eval_const_expr_partial(tcx, &body.value, ty_hint, Some(&call_args))?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n@@ -953,11 +899,12 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprArray(ref v) => Array(e.id, v.len() as u64),\n-      hir::ExprRepeat(_, ref n) => {\n+      hir::ExprRepeat(_, n) => {\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n+          let n = &tcx.map.body(n).value;\n           Repeat(\n               e.id,\n-              match eval_const_expr_partial(tcx, &n, len_hint, fn_args)? {\n+              match eval_const_expr_partial(tcx, n, len_hint, fn_args)? {\n                   Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n                   Integral(_) => signal!(e, RepeatCountNotNatural),\n                   _ => signal!(e, RepeatCountNotInt),\n@@ -1373,7 +1320,8 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n                 if let Def::Local(..) = path.def {\n-                    diag.note(&format!(\"`{}` is a variable\", path));\n+                    diag.note(&format!(\"`{}` is a variable\",\n+                                       tcx.map.node_to_pretty_string(count_expr.id)));\n                 }\n             }\n "}, {"sha": "6a884bafce752dcc0060cfc68247830c2800459c", "filename": "src/librustc_driver/derive_registrar.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -35,6 +35,9 @@ impl<'v> ItemLikeVisitor<'v> for Finder {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "5103a55fd71e1bd673df5b4e5b3533bbd89db23e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -47,7 +47,7 @@ use std::path::Path;\n use std::str::FromStr;\n \n use rustc::hir::map as hir_map;\n-use rustc::hir::map::{blocks, NodePrinter};\n+use rustc::hir::map::blocks;\n use rustc::hir;\n use rustc::hir::print as pprust_hir;\n \n@@ -320,7 +320,16 @@ impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n-impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n+impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        if let Some(ref map) = self.ast_map {\n+            pprust_hir::PpAnn::nested(map, state, nested)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n \n struct IdentifiedAnnotation<'ast> {\n     sess: &'ast Session,\n@@ -393,6 +402,14 @@ impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n }\n \n impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        if let Some(ref map) = self.ast_map {\n+            pprust_hir::PpAnn::nested(map, state, nested)\n+        } else {\n+            Ok(())\n+        }\n+    }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n@@ -488,6 +505,10 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)\n+    }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n@@ -702,8 +723,8 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = match code {\n         blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n         blocks::Code::FnLike(fn_like) => {\n-            let body = tcx.map.expr(fn_like.body());\n-            cfg::CFG::new(tcx, body)\n+            let body = tcx.map.body(fn_like.body());\n+            cfg::CFG::new(tcx, &body.value)\n         },\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n@@ -909,11 +930,10 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                                          &mut rdr,\n                                                                          box out,\n                                                                          annotation.pp_ann(),\n-                                                                         true,\n-                                                                         Some(ast_map.krate()));\n+                                                                         true);\n                     for node_id in uii.all_matching_node_ids(ast_map) {\n                         let node = ast_map.get(node_id);\n-                        pp_state.print_node(&node)?;\n+                        pp_state.print_node(node)?;\n                         pp::space(&mut pp_state.s)?;\n                         let path = annotation.node_path(node_id)\n                             .expect(\"--unpretty missing node paths\");"}, {"sha": "b5fe158f158cac7aead2d5fe5d8144a75243b3fa", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -171,6 +171,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n         self.process_attrs(item.id, &item.attrs);\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.process_attrs(trait_item.id, &trait_item.attrs);\n+    }\n+\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.process_attrs(impl_item.id, &impl_item.attrs);\n     }"}, {"sha": "49609fbc7984f937c84ea3ab51b227db64a7f45f", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -234,6 +234,11 @@ impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n         visit::walk_item(self, item);\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.calculate_node_id(trait_item.id, |v| v.visit_trait_item(trait_item));\n+        visit::walk_trait_item(self, trait_item);\n+    }\n+\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n         visit::walk_impl_item(self, impl_item);"}, {"sha": "4bb12667bbc147f861ed2583909c9758c89fcef0", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -188,7 +188,7 @@ enum SawAbiComponent<'a> {\n     SawTraitItem(SawTraitOrImplItemComponent),\n     SawImplItem(SawTraitOrImplItemComponent),\n     SawStructField,\n-    SawVariant,\n+    SawVariant(bool),\n     SawQPath,\n     SawPathSegment,\n     SawPathParameters,\n@@ -473,12 +473,14 @@ enum SawTraitOrImplItemComponent {\n     SawTraitOrImplItemType\n }\n \n-fn saw_trait_item(ti: &TraitItem_) -> SawTraitOrImplItemComponent {\n+fn saw_trait_item(ti: &TraitItemKind) -> SawTraitOrImplItemComponent {\n     match *ti {\n-        ConstTraitItem(..) => SawTraitOrImplItemConst,\n-        MethodTraitItem(ref sig, ref body) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, body.is_some()),\n-        TypeTraitItem(..) => SawTraitOrImplItemType\n+        TraitItemKind::Const(..) => SawTraitOrImplItemConst,\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(_)) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, false),\n+        TraitItemKind::Method(ref sig, TraitMethod::Provided(_)) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n+        TraitItemKind::Type(..) => SawTraitOrImplItemType\n     }\n }\n \n@@ -584,7 +586,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n                      g: &'tcx Generics,\n                      item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n-        SawVariant.hash(self.st);\n+        SawVariant(v.node.disr_expr.is_some()).hash(self.st);\n         hash_attrs!(self, &v.node.attrs);\n         visit::walk_variant(self, v, g, item_id)\n     }\n@@ -616,7 +618,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         // implicitly hashing the discriminant of SawExprComponent.\n         hash_span!(self, ex.span, force_span);\n         hash_attrs!(self, &ex.attrs);\n-        visit::walk_expr(self, ex)\n+\n+        // Always hash nested constant bodies (e.g. n in `[x; n]`).\n+        let hash_bodies = self.hash_bodies;\n+        self.hash_bodies = true;\n+        visit::walk_expr(self, ex);\n+        self.hash_bodies = hash_bodies;\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx Stmt) {\n@@ -686,7 +693,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_ty: st={:?}\", self.st);\n         SawTy(saw_ty(&t.node)).hash(self.st);\n         hash_span!(self, t.span);\n-        visit::walk_ty(self, t)\n+\n+        // Always hash nested constant bodies (e.g. N in `[T; N]`).\n+        let hash_bodies = self.hash_bodies;\n+        self.hash_bodies = true;\n+        visit::walk_ty(self, t);\n+        self.hash_bodies = hash_bodies;\n     }\n \n     fn visit_generics(&mut self, g: &'tcx Generics) {\n@@ -1157,8 +1169,9 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             // These fields are handled separately:\n             exported_macros: _,\n             items: _,\n+            trait_items: _,\n             impl_items: _,\n-            exprs: _,\n+            bodies: _,\n         } = *krate;\n \n         visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);"}, {"sha": "481462dff86e479289e36f363defdd3598877cd2", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -185,6 +185,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n@@ -229,6 +232,9 @@ impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx,\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "2baef47c214c28ae54b17906a0be338afc8e2253", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -243,7 +243,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::Body,\n                 span: Span,\n                 id: ast::NodeId) {\n         match fk {\n@@ -271,12 +271,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(_, None) = trait_item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(ref names)) = item.node {\n             self.check_snake_case(cx,\n                                   \"trait method\",\n-                                  &trait_item.name.as_str(),\n-                                  Some(trait_item.span));\n+                                  &item.name.as_str(),\n+                                  Some(item.span));\n+            for name in names {\n+                self.check_snake_case(cx, \"variable\", &name.node.as_str(), Some(name.span));\n+            }\n         }\n     }\n \n@@ -288,14 +291,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        // Exclude parameter names from foreign functions\n-        let parent_node = cx.tcx.map.get_parent_node(p.id);\n-        if let hir::map::NodeForeignItem(item) = cx.tcx.map.get(parent_node) {\n-            if let hir::ForeignItemFn(..) = item.node {\n-                return;\n-            }\n-        }\n-\n         if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n             self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n         }\n@@ -363,7 +358,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n \n     fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n-            hir::ConstTraitItem(..) => {\n+            hir::TraitItemKind::Const(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n             }\n             _ => {}"}, {"sha": "c021ffee81899002c9c6a4273fdec2c97df20d34", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n                 cx: &LateContext,\n                 fk: FnKind<'tcx>,\n                 _: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::Body,\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n@@ -240,11 +240,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) = item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE,\n-                             trait_item.span,\n+                             item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n         }\n@@ -374,12 +374,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemEnum(..) => \"an enum\",\n             hir::ItemStruct(..) => \"a struct\",\n             hir::ItemUnion(..) => \"a union\",\n-            hir::ItemTrait(.., ref items) => {\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if it.vis == hir::Visibility::Inherited {\n                     self.private_traits.insert(it.id);\n-                    for itm in items {\n-                        self.private_traits.insert(itm.id);\n+                    for trait_item_ref in trait_item_refs {\n+                        self.private_traits.insert(trait_item_ref.id.node_id);\n                     }\n                     return;\n                 }\n@@ -418,9 +418,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n \n         let desc = match trait_item.node {\n-            hir::ConstTraitItem(..) => \"an associated constant\",\n-            hir::MethodTraitItem(..) => \"a trait method\",\n-            hir::TypeTraitItem(..) => \"an associated type\",\n+            hir::TraitItemKind::Const(..) => \"an associated constant\",\n+            hir::TraitItemKind::Method(..) => \"a trait method\",\n+            hir::TraitItemKind::Type(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx,\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n                 _: &hir::FnDecl,\n-                blk: &hir::Expr,\n+                body: &hir::Body,\n                 sp: Span,\n                 id: ast::NodeId) {\n         let method = match fn_kind {\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // to have behaviour like the above, rather than\n         // e.g. accidentally recurring after an assert.\n \n-        let cfg = cfg::CFG::new(cx.tcx, blk);\n+        let cfg = cfg::CFG::new(cx.tcx, &body.value);\n \n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;"}, {"sha": "a3aa4af493aaf72bb1ffa2fc613980f2490f5d70", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -679,7 +679,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.ty.span, input_ty);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        hir::ForeignItemFn(ref decl, _) => {\n+                        hir::ForeignItemFn(ref decl, _, _) => {\n                             vis.check_foreign_fn(ni.id, decl);\n                         }\n                         hir::ForeignItemStatic(ref ty, _) => {"}, {"sha": "b7ee688117d93a07149632464d4eafcb6d1d2e9d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -97,11 +97,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n     fn check_fn(&mut self,\n                 cx: &LateContext,\n                 _: FnKind,\n-                decl: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::FnDecl,\n+                body: &hir::Body,\n                 _: Span,\n                 _: ast::NodeId) {\n-        for a in &decl.inputs {\n+        for a in &body.arguments {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }"}, {"sha": "b27b164bd47aaffec7910ac2f3ca775b22f0f119", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -16,8 +16,7 @@ use cstore::CrateMetadata;\n use encoder::EncodeContext;\n use schema::*;\n \n-use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n-use rustc::middle::const_qualif::ConstQualif;\n+use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt, Ty};\n@@ -29,8 +28,10 @@ use rustc_serialize::Encodable;\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n     id_range: IdRange,\n-    item: Lazy<InlinedItem>,\n+    body: Lazy<hir::Body>,\n     side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n+    pub nested_bodies: LazySeq<hir::Body>,\n+    pub rvalue_promotable_to_static: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -39,31 +40,47 @@ enum TableEntry<'tcx> {\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::Adjustment<'tcx>),\n-    ConstQualif(ConstQualif),\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef<'tcx>) -> Lazy<Ast<'tcx>> {\n+    pub fn encode_body(&mut self, body: hir::BodyId) -> Lazy<Ast<'tcx>> {\n+        let body = self.tcx.map.body(body);\n+\n         let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        ii.visit(&mut id_visitor);\n+        id_visitor.visit_body(body);\n \n-        let ii_pos = self.position();\n-        ii.encode(self).unwrap();\n+        let body_pos = self.position();\n+        body.encode(self).unwrap();\n \n         let tables_pos = self.position();\n         let tables_count = {\n             let mut visitor = SideTableEncodingIdVisitor {\n                 ecx: self,\n                 count: 0,\n             };\n-            ii.visit(&mut visitor);\n+            visitor.visit_body(body);\n             visitor.count\n         };\n \n+        let nested_pos = self.position();\n+        let nested_count = {\n+            let mut visitor = NestedBodyEncodingVisitor {\n+                ecx: self,\n+                count: 0,\n+            };\n+            visitor.visit_body(body);\n+            visitor.count\n+        };\n+\n+        let rvalue_promotable_to_static =\n+            self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n+\n         self.lazy(&Ast {\n             id_range: id_visitor.result(),\n-            item: Lazy::with_position(ii_pos),\n+            body: Lazy::with_position(body_pos),\n             side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n+            nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n+            rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n@@ -94,18 +111,36 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n         encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n         encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n         encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n-        encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }\n \n-/// Decodes an item from its AST in the cdata's metadata and adds it to the\n+struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    count: usize,\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let body = self.ecx.tcx.map.body(body);\n+        body.encode(self.ecx).unwrap();\n+        self.count += 1;\n+\n+        self.visit_body(body);\n+    }\n+}\n+\n+/// Decodes an item's body from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ast: Ast<'tcx>,\n-                                     orig_did: DefId)\n-                                     -> &'tcx InlinedItem {\n-    debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n+pub fn decode_body<'a, 'tcx>(cdata: &CrateMetadata,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId,\n+                             ast: Ast<'tcx>)\n+                             -> &'tcx hir::Body {\n+    debug!(\"> Decoding inlined fn: {}\", tcx.item_path_str(def_id));\n \n     let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n     let start = tcx.sess.reserve_node_ids(cnt);\n@@ -115,12 +150,6 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                          max: ast::NodeId::new(start.as_usize() + cnt),\n                      }];\n \n-    let ii = ast.item.decode((cdata, tcx, id_ranges));\n-    let item_node_id = tcx.sess.next_node_id();\n-    let ii = ast_map::map_decoded_item(&tcx.map,\n-                                       ii,\n-                                       item_node_id);\n-\n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::TypeRelativeDef(def) => {\n@@ -135,11 +164,9 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n             TableEntry::Adjustment(adj) => {\n                 tcx.tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-            TableEntry::ConstQualif(qualif) => {\n-                tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n-            }\n         }\n     }\n \n-    ii\n+    let body = ast.body.decode((cdata, tcx, id_ranges));\n+    ast_map::map_decoded_body(&tcx.map, def_id, body, tcx.sess.next_node_id())\n }"}, {"sha": "aab4034b7705aee99a5747a42d74bcc44a8e4e15", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -88,13 +88,6 @@ pub struct CrateMetadata {\n     pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n-pub struct CachedInlinedItem {\n-    /// The NodeId of the RootInlinedParent HIR map entry\n-    pub inlined_root: ast::NodeId,\n-    /// The local NodeId of the inlined entity\n-    pub item_id: ast::NodeId,\n-}\n-\n pub struct CStore {\n     pub dep_graph: DepGraph,\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n@@ -104,8 +97,7 @@ pub struct CStore {\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n-    pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n+    pub inlined_item_cache: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -121,7 +113,6 @@ impl CStore {\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n             inlined_item_cache: RefCell::new(FxHashMap()),\n-            defid_for_inlined_node: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "64513fa41b219d03938faa1328369aa54df3b1c6", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 31, "deletions": 77, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -13,7 +13,7 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n@@ -36,6 +36,8 @@ use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n \n+use std::collections::BTreeMap;\n+\n impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn describe_def(&self, def: DefId) -> Option<Def> {\n         self.dep_graph.read(DepNode::MetaData(def));\n@@ -128,7 +130,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n-        self.dep_graph.read(DepNode::MetaData(did));\n+        // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n+        // a `fn` when encoding, so the dep-tracking wouldn't work.\n+        // This is only used by rustdoc anyway, which shouldn't have\n+        // incremental recompilation ever enabled.\n+        assert!(!self.dep_graph.is_fully_enabled());\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n@@ -423,94 +429,42 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_ast<'a>(&'tcx self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)>\n+    fn maybe_get_item_body<'a>(&'tcx self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               def_id: DefId)\n+                               -> Option<&'tcx hir::Body>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n \n-        match self.inlined_item_cache.borrow().get(&def_id) {\n-            Some(&None) => {\n-                return None; // Not inlinable\n-            }\n-            Some(&Some(ref cached_inlined_item)) => {\n+        if let Some(&cached) = self.inlined_item_cache.borrow().get(&def_id) {\n+            return cached.map(|root_id| {\n                 // Already inline\n-                debug!(\"maybe_get_item_ast({}): already inline as node id {}\",\n-                          tcx.item_path_str(def_id), cached_inlined_item.item_id);\n-                return Some((tcx.map.expect_inlined_item(cached_inlined_item.inlined_root),\n-                             cached_inlined_item.item_id));\n-            }\n-            None => {\n-                // Not seen yet\n-            }\n+                debug!(\"maybe_get_item_body({}): already inline\", tcx.item_path_str(def_id));\n+                tcx.map.expect_inlined_body(root_id)\n+            });\n         }\n \n-        debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n+        debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_ast(tcx, def_id.index);\n-\n-        let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n-            let cache_entry = cstore::CachedInlinedItem {\n-                inlined_root: inlined_root_node_id,\n-                item_id: inlined_item_id,\n-            };\n-            self.inlined_item_cache\n-                .borrow_mut()\n-                .insert(original_def_id, Some(cache_entry));\n-            self.defid_for_inlined_node\n-                .borrow_mut()\n-                .insert(inlined_item_id, original_def_id);\n-        };\n-\n-        let find_inlined_item_root = |inlined_item_id| {\n-            let mut node = inlined_item_id;\n-\n-            // If we can't find the inline root after a thousand hops, we can\n-            // be pretty sure there's something wrong with the HIR map.\n-            for _ in 0 .. 1000 {\n-                let parent_node = tcx.map.get_parent_node(node);\n-                if parent_node == node {\n-                    return node;\n-                }\n-                node = parent_node;\n-            }\n-            bug!(\"cycle in HIR map parent chain\")\n-        };\n+        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index);\n \n-        match inlined {\n-            None => {\n-                self.inlined_item_cache\n-                    .borrow_mut()\n-                    .insert(def_id, None);\n-            }\n-            Some(&InlinedItem { ref body, .. }) => {\n-                let inlined_root_node_id = find_inlined_item_root(body.id);\n-                cache_inlined_item(def_id, inlined_root_node_id, inlined_root_node_id);\n-            }\n-        }\n+        self.inlined_item_cache.borrow_mut().insert(def_id, inlined.map(|body| {\n+            let root_id = tcx.map.get_parent_node(body.value.id);\n+            assert_eq!(tcx.map.get_parent_node(root_id), root_id);\n+            root_id\n+        }));\n \n-        // We can be sure to hit the cache now\n-        return self.maybe_get_item_ast(tcx, def_id);\n+        inlined\n     }\n \n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n-        assert!(!def_id.is_local());\n-        match self.inlined_item_cache.borrow().get(&def_id) {\n-            Some(&Some(ref cached_inlined_item)) => {\n-                Some(cached_inlined_item.item_id)\n-            }\n-            Some(&None) => {\n-                None\n-            }\n-            _ => {\n-                bug!(\"Trying to lookup inlined NodeId for unexpected item\");\n-            }\n-        }\n+    fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).item_body_nested_bodies(def.index)\n     }\n \n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n-        self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).const_is_rvalue_promotable_to_static(def.index)\n     }\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {"}, {"sha": "c27e06c50222be8e123094038dfba0b1424fd07b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -10,15 +10,15 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use astencode::decode_inlined_item;\n+use astencode::decode_body;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n@@ -32,6 +32,7 @@ use rustc::mir::Mir;\n \n use std::borrow::Cow;\n use std::cell::Ref;\n+use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n use std::str;\n@@ -819,20 +820,27 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_ast(&self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: DefIndex)\n-                              -> Option<&'tcx InlinedItem> {\n-        debug!(\"Looking up item: {:?}\", id);\n+    pub fn maybe_get_item_body(&self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               id: DefIndex)\n+                               -> Option<&'tcx hir::Body> {\n         if self.is_proc_macro(id) { return None; }\n-        let item_doc = self.entry(id);\n-        let item_did = self.local_def_id(id);\n-        item_doc.ast.map(|ast| {\n-            let ast = ast.decode(self);\n-            decode_inlined_item(self, tcx, ast, item_did)\n+        self.entry(id).ast.map(|ast| {\n+            decode_body(self, tcx, self.local_def_id(id), ast.decode(self))\n         })\n     }\n \n+    pub fn item_body_nested_bodies(&self, id: DefIndex) -> BTreeMap<hir::BodyId, hir::Body> {\n+        self.entry(id).ast.into_iter().flat_map(|ast| {\n+            ast.decode(self).nested_bodies.decode(self).map(|body| (body.id(), body))\n+        }).collect()\n+    }\n+\n+    pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {\n+        self.entry(id).ast.expect(\"const item missing `ast`\")\n+            .decode(self).rvalue_promotable_to_static\n+    }\n+\n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()"}, {"sha": "72dcb4ba9a3a8f3f1ab460f68b133cfc773c9ca4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -12,8 +12,7 @@ use cstore;\n use index::Index;\n use schema::*;\n \n-use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n-use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n+use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -34,6 +33,7 @@ use std::io::Cursor;\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n+use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n use syntax_pos;\n@@ -442,10 +442,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match trait_item.kind {\n             ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n             ty::AssociatedKind::Method => {\n-                let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n+                let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n+                    let arg_names = match *m {\n+                        hir::TraitMethod::Required(ref names) => {\n+                            self.encode_fn_arg_names(names)\n+                        }\n+                        hir::TraitMethod::Provided(body) => {\n+                            self.encode_fn_arg_names_for_body(body)\n+                        }\n+                    };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl),\n+                        arg_names: arg_names\n                     }\n                 } else {\n                     bug!()\n@@ -486,13 +494,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let hir::ConstTraitItem(_, Some(_)) = ast_item.node {\n-                // We only save the HIR for associated consts with bodies\n-                // (InlinedItemRef::from_trait_item panics otherwise)\n-                let trait_def_id = trait_item.container.id();\n-                Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_trait_item(trait_def_id, ast_item, tcx)\n-                ))\n+            ast: if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.node {\n+                Some(self.encode_body(body))\n             } else {\n                 None\n             },\n@@ -501,12 +504,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n-        let impl_def_id = impl_item.container.id();\n \n         let container = match impl_item.defaultness {\n             hir::Defaultness::Default { has_value: true } => AssociatedContainer::ImplDefault,\n@@ -518,10 +518,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match impl_item.kind {\n             ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n             ty::AssociatedKind::Method => {\n-                let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+                let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl),\n+                        arg_names: self.encode_fn_arg_names_for_body(body),\n                     }\n                 } else {\n                     bug!()\n@@ -535,17 +535,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n-            (true, true)\n-        } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+        let (ast, mir) = if let hir::ImplItemKind::Const(_, body) = ast_item.node {\n+            (Some(body), true)\n+        } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n             let generics = self.tcx.item_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n+            let ast = if is_const_fn { Some(body) } else { None };\n             let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-            (is_const_fn, needs_inline || is_const_fn || always_encode_mir)\n+            (ast, needs_inline || is_const_fn || always_encode_mir)\n         } else {\n-            (false, false)\n+            (None, false)\n         };\n \n         Entry {\n@@ -563,27 +564,28 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if ast {\n-                Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_impl_item(impl_def_id, ast_item, tcx)\n-                ))\n-            } else {\n-                None\n-            },\n+            ast: ast.map(|body| self.encode_body(body)),\n             mir: if mir { self.encode_mir(def_id) } else { None },\n         }\n     }\n \n-    fn encode_fn_arg_names(&mut self, decl: &hir::FnDecl) -> LazySeq<ast::Name> {\n-        self.lazy_seq(decl.inputs.iter().map(|arg| {\n-            if let PatKind::Binding(_, _, ref path1, _) = arg.pat.node {\n-                path1.node\n-            } else {\n-                Symbol::intern(\"\")\n+    fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n+                                    -> LazySeq<ast::Name> {\n+        let _ignore = self.tcx.dep_graph.in_ignore();\n+        let body = self.tcx.map.body(body_id);\n+        self.lazy_seq(body.arguments.iter().map(|arg| {\n+            match arg.pat.node {\n+                PatKind::Binding(_, _, name, _) => name.node,\n+                _ => Symbol::intern(\"\")\n             }\n         }))\n     }\n \n+    fn encode_fn_arg_names(&mut self, names: &[Spanned<ast::Name>])\n+                           -> LazySeq<ast::Name> {\n+        self.lazy_seq(names.iter().map(|name| name.node))\n+    }\n+\n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n         self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n@@ -619,10 +621,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemConst(..) => EntryKind::Const,\n-            hir::ItemFn(ref decl, _, constness, ..) => {\n+            hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n                     constness: constness,\n-                    arg_names: self.encode_fn_arg_names(&decl),\n+                    arg_names: self.encode_fn_arg_names_for_body(body),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -793,16 +795,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             },\n \n             ast: match item.node {\n-                hir::ItemConst(..) |\n-                hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n-                    Some(self.encode_inlined_item(\n-                        InlinedItemRef::from_item(def_id, item, tcx)\n-                    ))\n+                hir::ItemConst(_, body) |\n+                hir::ItemFn(_, _, hir::Constness::Const, _, _, body) => {\n+                    Some(self.encode_body(body))\n                 }\n                 _ => None,\n             },\n             mir: match item.node {\n-                hir::ItemStatic(..) |\n+                hir::ItemStatic(..) if self.tcx.sess.opts.debugging_opts.always_encode_mir => {\n+                    self.encode_mir(def_id)\n+                }\n                 hir::ItemConst(..) => self.encode_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();\n@@ -913,10 +915,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n \n         let kind = match nitem.node {\n-            hir::ForeignItemFn(ref fndecl, _) => {\n+            hir::ForeignItemFn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(&fndecl),\n+                    arg_names: self.encode_fn_arg_names(names),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n@@ -1162,6 +1164,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n+\n     fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n         // handled in `visit_item` above\n     }"}, {"sha": "63bb1bf20c06c41bccba9d59f7e7fb6f06017c44", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -729,7 +729,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             name: Some(name),\n             source_info: Some(source_info),\n         });\n-        let extent = self.extent_of_innermost_scope();\n+        let extent = self.hir.tcx().region_maps.var_scope(var_id);\n         self.schedule_drop(source_info.span, extent, &Lvalue::Local(var), var_ty);\n         self.var_indices.insert(var_id, var);\n "}, {"sha": "cfdc1bf27df35411c6f008ba6f4aff42c821980e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -126,7 +126,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        arguments: A,\n                                        abi: Abi,\n                                        return_ty: Ty<'gcx>,\n-                                       ast_body: &'gcx hir::Expr)\n+                                       body: &'gcx hir::Body)\n                                        -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -136,17 +136,16 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n-    let body_id = ast_body.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n+            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body.value.id });\n     let arg_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.value.id });\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, &arguments, arg_extent, ast_body)\n+            builder.args_and_body(block, &arguments, arg_extent, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -197,9 +196,10 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        item_id: ast::NodeId,\n-                                       ast_expr: &'tcx hir::Expr)\n+                                       body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let tcx = hir.tcx();\n+    let ast_expr = &tcx.map.body(body_id).value;\n     let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);"}, {"sha": "59a11782e08566744d1e027849a56e60e8506ce4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n-        let extent = self.extent_of_innermost_scope();\n+        let extent = self.scopes.last().map(|scope| scope.extent).unwrap();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n@@ -411,10 +411,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n-        self.scopes.last().map(|scope| scope.extent).unwrap()\n-    }\n-\n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n     pub fn extent_of_return_scope(&self) -> CodeExtent {"}, {"sha": "cc65fdede092ff042575c6b4dd388e0344c8abe7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -575,7 +575,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, ref c) => {\n+        hir::ExprRepeat(ref v, c) => {\n+            let c = &cx.tcx.map.body(c).value;\n             ExprKind::Repeat {\n                 value: v.to_ref(),\n                 count: TypedConstVal {\n@@ -585,7 +586,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         ConstVal::Integral(ConstInt::Usize(u)) => u,\n                         other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                     },\n-                },\n+                }\n             }\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n@@ -780,7 +781,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n                     match expr.node {\n-                        hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n+                        hir::ExprClosure(.., body, _) => body.node_id,\n                         _ => {\n                             span_bug!(expr.span, \"closure expr is not a closure expr\");\n                         }"}, {"sha": "cbc53ea3c51c747ae5e38399e6ace1c76d4ee0cf", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -129,16 +129,17 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n-    fn build_const_integer(&mut self, expr: &'gcx hir::Expr) {\n+    fn build_const_integer(&mut self, body: hir::BodyId) {\n+        let body = self.tcx.map.body(body);\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         // Type-checking should not let closures get\n         // this far in an integer constant position.\n-        if let hir::ExprClosure(..) = expr.node {\n+        if let hir::ExprClosure(..) = body.value.node {\n             return;\n         }\n-        self.cx(MirSource::Const(expr.id)).build(|cx| {\n-            build::construct_const(cx, expr.id, expr)\n+        self.cx(MirSource::Const(body.value.id)).build(|cx| {\n+            build::construct_const(cx, body.value.id, body.id())\n         });\n     }\n }\n@@ -151,12 +152,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Const and static items.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemConst(_, ref expr) => {\n+            hir::ItemConst(_, expr) => {\n                 self.cx(MirSource::Const(item.id)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n-            hir::ItemStatic(_, m, ref expr) => {\n+            hir::ItemStatic(_, m, expr) => {\n                 self.cx(MirSource::Static(item.id, m)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n@@ -168,7 +169,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Trait associated const defaults.\n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n+        if let hir::TraitItemKind::Const(_, Some(expr)) = item.node {\n             self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Impl associated const.\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+        if let hir::ImplItemKind::Const(_, expr) = item.node {\n             self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n@@ -188,15 +189,15 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Repeat counts, i.e. [expr; constant].\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n+        if let hir::ExprRepeat(_, count) = expr.node {\n             self.build_const_integer(count);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     // Array lengths, i.e. [T; constant].\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n+        if let hir::TyArray(_, length) = ty.node {\n             self.build_const_integer(length);\n         }\n         intravisit::walk_ty(self, ty);\n@@ -205,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Enum variant discriminant values.\n     fn visit_variant(&mut self, v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics, item_id: ast::NodeId) {\n-        if let Some(ref expr) = v.node.disr_expr {\n+        if let Some(expr) = v.node.disr_expr {\n             self.build_const_integer(expr);\n         }\n         intravisit::walk_variant(self, v, g, item_id);\n@@ -214,7 +215,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId,\n+                body_id: hir::BodyId,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n@@ -227,22 +228,21 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n         };\n \n         let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n-            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id()), None)))\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id), None)))\n         } else {\n             let def_id = self.tcx.map.local_def_id(id);\n             (self.tcx.item_type(def_id).fn_abi(), None)\n         };\n \n+        let body = self.tcx.map.body(body_id);\n         let explicit_arguments =\n-            decl.inputs\n+            body.arguments\n                 .iter()\n                 .enumerate()\n                 .map(|(index, arg)| {\n                     (fn_sig.inputs()[index], Some(&*arg.pat))\n                 });\n \n-        let body = self.tcx.map.expr(body_id);\n-\n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n             build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)"}, {"sha": "d1d9a201567bbc6ba022672d3134019f96e9f459", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 133, "deletions": 395, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -26,89 +26,45 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n-use rustc_const_eval::{ConstFnNode, eval_const_expr_partial, lookup_const_by_id};\n+use rustc_const_eval::{ConstEvalErr, compare_lit_exprs};\n+use rustc_const_eval::{eval_const_expr_partial};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n+use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n-use rustc::middle::const_qualif::ConstQualif;\n+use rustc::util::nodemap::NodeSet;\n use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind};\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-enum Mode {\n-    Const,\n-    ConstFn,\n-    Static,\n-    StaticMut,\n-\n-    // An expression that occurs outside of any constant context\n-    // (i.e. `const`, `static`, array lengths, etc.). The value\n-    // can be variable at runtime, but will be promotable to\n-    // static memory if we can prove it is actually constant.\n-    Var,\n-}\n+use std::mem;\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mode: Mode,\n-    qualif: ConstQualif,\n-    rvalue_borrows: NodeMap<hir::Mutability>,\n+    in_fn: bool,\n+    promotable: bool,\n+    mut_rvalue_borrows: NodeSet,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R\n-        where F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R\n-    {\n-        let (old_mode, old_qualif) = (self.mode, self.qualif);\n-        self.mode = mode;\n-        self.qualif = ConstQualif::empty();\n-        let r = f(self);\n-        self.mode = old_mode;\n-        self.qualif = old_qualif;\n-        r\n-    }\n-\n-    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R\n-        where F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R\n-    {\n-        let param_env = match item_id {\n-            Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => self.tcx.empty_parameter_environment(),\n-        };\n-\n-        self.tcx\n-            .infer_ctxt(None, Some(param_env), Reveal::NotSpecializable)\n-            .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n-    }\n-\n-    fn global_expr(&mut self, mode: Mode, expr: &'gcx hir::Expr) -> ConstQualif {\n-        assert!(mode != Mode::Var);\n-        match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n-            Entry::Occupied(entry) => return *entry.get(),\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(ConstQualif::empty());\n-            }\n-        }\n+    fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n         if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n@@ -124,184 +80,78 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 }\n             }\n         }\n-        self.with_mode(mode, |this| {\n-            this.with_euv(None, |euv| euv.consume_expr(expr));\n-            this.visit_expr(expr);\n-            this.qualif\n-        })\n     }\n \n-    fn fn_like(&mut self,\n-               fk: FnKind<'gcx>,\n-               fd: &'gcx hir::FnDecl,\n-               b: hir::ExprId,\n-               s: Span,\n-               fn_id: ast::NodeId)\n-               -> ConstQualif {\n-        match self.tcx.const_qualif_map.borrow_mut().entry(fn_id) {\n-            Entry::Occupied(entry) => return *entry.get(),\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(ConstQualif::empty());\n-            }\n+    // Adds the worst effect out of all the values of one type.\n+    fn add_type(&mut self, ty: Ty<'gcx>) {\n+        if ty.type_contents(self.tcx).interior_unsafe() {\n+            self.promotable = false;\n         }\n \n-        let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, ..)\n-                => Mode::ConstFn,\n-            FnKind::Method(_, m, ..) => {\n-                if m.constness == hir::Constness::Const {\n-                    Mode::ConstFn\n-                } else {\n-                    Mode::Var\n-                }\n-            }\n-            _ => Mode::Var,\n-        };\n-\n-        let qualif = self.with_mode(mode, |this| {\n-            let body = this.tcx.map.expr(b);\n-            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, body));\n-            intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n-            this.qualif\n-        });\n-\n-        // Keep only bits that aren't affected by function body (NON_ZERO_SIZED),\n-        // and bits that don't change semantics, just optimizations (PREFER_IN_PLACE).\n-        let qualif = qualif & (ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n-\n-        self.tcx.const_qualif_map.borrow_mut().insert(fn_id, qualif);\n-        qualif\n-    }\n-\n-    fn add_qualif(&mut self, qualif: ConstQualif) {\n-        self.qualif = self.qualif | qualif;\n-    }\n-\n-    /// Returns true if the call is to a const fn or method.\n-    fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n-        match lookup_const_fn_by_id(self.tcx, def_id) {\n-            Some(ConstFnNode::Local(fn_like)) => {\n-                let qualif = self.fn_like(fn_like.kind(),\n-                                          fn_like.decl(),\n-                                          fn_like.body(),\n-                                          fn_like.span(),\n-                                          fn_like.id());\n-\n-                self.add_qualif(qualif);\n-\n-                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                }\n-\n-                true\n-            },\n-            Some(ConstFnNode::Inlined(ii)) => {\n-                let node_id = ii.body.id;\n-\n-                let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n-                    Entry::Occupied(entry) => *entry.get(),\n-                    _ => bug!(\"const qualif entry missing for inlined item\")\n-                };\n-\n-                self.add_qualif(qualif);\n-\n-                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                }\n-\n-                true\n-            },\n-            None => false\n+        if self.tcx.type_needs_drop_given_env(ty, &self.param_env) {\n+            self.promotable = false;\n         }\n     }\n \n-    fn record_borrow(&mut self, id: ast::NodeId, mutbl: hir::Mutability) {\n-        match self.rvalue_borrows.entry(id) {\n-            Entry::Occupied(mut entry) => {\n-                // Merge the two borrows, taking the most demanding\n-                // one, mutability-wise.\n-                if mutbl == hir::MutMutable {\n-                    entry.insert(mutbl);\n-                }\n-            }\n-            Entry::Vacant(entry) => {\n-                entry.insert(mutbl);\n-            }\n-        }\n+    fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>) {\n+        self.add_type(ret_ty);\n+\n+        self.promotable &= if let Some(fn_id) = self.tcx.map.as_local_node_id(def_id) {\n+            FnLikeNode::from_node(self.tcx.map.get(fn_id)).map_or(false, |fn_like| {\n+                fn_like.constness() == hir::Constness::Const\n+            })\n+        } else {\n+            self.tcx.sess.cstore.is_const_fn(def_id)\n+        };\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n-        assert_eq!(self.mode, Mode::Var);\n-        match i.node {\n-            hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n-                self.global_expr(Mode::Static, &expr);\n-            }\n-            hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n-                self.global_expr(Mode::StaticMut, &expr);\n-            }\n-            hir::ItemConst(_, ref expr) => {\n-                self.global_expr(Mode::Const, &expr);\n-            }\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                for var in &enum_definition.variants {\n-                    if let Some(ref ex) = var.node.disr_expr {\n-                        self.global_expr(Mode::Const, &ex);\n-                    }\n-                }\n-            }\n-            _ => {\n-                intravisit::walk_item(self, i);\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body.node_id) {\n+            Entry::Occupied(_) => return,\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(false);\n             }\n         }\n-    }\n \n-    fn visit_trait_item(&mut self, t: &'tcx hir::TraitItem) {\n-        match t.node {\n-            hir::ConstTraitItem(_, ref default) => {\n-                if let Some(ref expr) = *default {\n-                    self.global_expr(Mode::Const, &expr);\n-                } else {\n-                    intravisit::walk_trait_item(self, t);\n-                }\n-            }\n-            _ => self.with_mode(Mode::Var, |v| intravisit::walk_trait_item(v, t)),\n-        }\n-    }\n+        let item_id = self.tcx.map.body_owner(body);\n \n-    fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-        match i.node {\n-            hir::ImplItemKind::Const(_, ref expr) => {\n-                self.global_expr(Mode::Const, &expr);\n-            }\n-            _ => self.with_mode(Mode::Var, |v| intravisit::walk_impl_item(v, i)),\n+        let outer_in_fn = self.in_fn;\n+        self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n+            MirSource::Fn(_) => true,\n+            _ => false\n+        };\n+\n+        let body = self.tcx.map.body(body);\n+        if !self.in_fn {\n+            self.check_const_eval(&body.value);\n         }\n-    }\n \n-    fn visit_fn(&mut self,\n-                fk: FnKind<'tcx>,\n-                fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId,\n-                s: Span,\n-                fn_id: ast::NodeId) {\n-        self.fn_like(fk, fd, b, s, fn_id);\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n+        let outer_param_env = mem::replace(&mut self.param_env, param_env);\n+        self.tcx.infer_ctxt(None, Some(self.param_env.clone()), Reveal::NotSpecializable)\n+            .enter(|infcx| euv::ExprUseVisitor::new(self, &infcx).consume_body(body));\n+\n+        self.visit_body(body);\n+\n+        self.param_env = outer_param_env;\n+        self.in_fn = outer_in_fn;\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         match p.node {\n             PatKind::Lit(ref lit) => {\n-                self.global_expr(Mode::Const, &lit);\n+                self.check_const_eval(lit);\n             }\n             PatKind::Range(ref start, ref end) => {\n-                self.global_expr(Mode::Const, &start);\n-                self.global_expr(Mode::Const, &end);\n+                self.check_const_eval(start);\n+                self.check_const_eval(end);\n \n                 match compare_lit_exprs(self.tcx, p.span, start, end) {\n                     Ok(Ordering::Less) |\n@@ -315,119 +165,60 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     Err(ErrorReported) => {}\n                 }\n             }\n-            _ => intravisit::walk_pat(self, p),\n+            _ => {}\n         }\n+        intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        // Check all statements in the block\n-        for stmt in &block.stmts {\n-            match stmt.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        hir::DeclLocal(_) => {}\n-                        // Item statements are allowed\n-                        hir::DeclItem(_) => continue,\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+        match stmt.node {\n+            hir::StmtDecl(ref decl, _) => {\n+                match decl.node {\n+                    hir::DeclLocal(_) => {\n+                        self.promotable = false;\n                     }\n+                    // Item statements are allowed\n+                    hir::DeclItem(_) => {}\n                 }\n-                hir::StmtExpr(..) => {}\n-                hir::StmtSemi(..) => {}\n             }\n-            self.add_qualif(ConstQualif::NOT_CONST);\n+            hir::StmtExpr(..) |\n+            hir::StmtSemi(..) => {\n+                self.promotable = false;\n+            }\n         }\n-        intravisit::walk_block(self, block);\n+        intravisit::walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        let mut outer = self.qualif;\n-        self.qualif = ConstQualif::empty();\n+        let outer = self.promotable;\n+        self.promotable = true;\n \n         let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n-        // Special-case some expressions to avoid certain flags bubbling up.\n-        match ex.node {\n-            hir::ExprCall(ref callee, ref args) => {\n-                for arg in args {\n-                    self.visit_expr(&arg)\n+        if let hir::ExprMatch(ref discr, ref arms, _) = ex.node {\n+            // Compute the most demanding borrow from all the arms'\n+            // patterns and set that on the discriminator.\n+            let mut mut_borrow = false;\n+            for pat in arms.iter().flat_map(|arm| &arm.pats) {\n+                if self.mut_rvalue_borrows.remove(&pat.id) {\n+                    mut_borrow = true;\n                 }\n-\n-                let inner = self.qualif;\n-                self.visit_expr(&callee);\n-                // The callee's size doesn't count in the call.\n-                let added = self.qualif - inner;\n-                self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n-            hir::ExprRepeat(ref element, _) => {\n-                self.visit_expr(&element);\n-                // The count is checked elsewhere (typeck).\n-                let count = match node_ty.sty {\n-                    ty::TyArray(_, n) => n,\n-                    _ => bug!(),\n-                };\n-                // [element; 0] is always zero-sized.\n-                if count == 0 {\n-                    self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n-                }\n+            if mut_borrow {\n+                self.mut_rvalue_borrows.insert(discr.id);\n             }\n-            hir::ExprMatch(ref discr, ref arms, _) => {\n-                // Compute the most demanding borrow from all the arms'\n-                // patterns and set that on the discriminator.\n-                let mut borrow = None;\n-                for pat in arms.iter().flat_map(|arm| &arm.pats) {\n-                    let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n-                    match (borrow, pat_borrow) {\n-                        (None, _) |\n-                        (_, Some(hir::MutMutable)) => {\n-                            borrow = pat_borrow;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                if let Some(mutbl) = borrow {\n-                    self.record_borrow(discr.id, mutbl);\n-                }\n-                intravisit::walk_expr(self, ex);\n-            }\n-            _ => intravisit::walk_expr(self, ex),\n         }\n \n+        intravisit::walk_expr(self, ex);\n+\n         // Handle borrows on (or inside the autorefs of) this expression.\n-        match self.rvalue_borrows.remove(&ex.id) {\n-            Some(hir::MutImmutable) => {\n-                // Constants cannot be borrowed if they contain interior mutability as\n-                // it means that our \"silent insertion of statics\" could change\n-                // initializer values (very bad).\n-                // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n-                // propagated from another error, so erroring again would be just noise.\n-                let tc = node_ty.type_contents(self.tcx);\n-                if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n-                    outer = outer | ConstQualif::NOT_CONST;\n-                }\n-                // If the reference has to be 'static, avoid in-place initialization\n-                // as that will end up pointing to the stack instead.\n-                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-                    self.qualif = self.qualif - ConstQualif::PREFER_IN_PLACE;\n-                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n-                }\n-            }\n-            Some(hir::MutMutable) => {\n-                // `&mut expr` means expr could be mutated, unless it's zero-sized.\n-                if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n-                    if self.mode == Mode::Var {\n-                        outer = outer | ConstQualif::NOT_CONST;\n-                        self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                    }\n-                }\n-                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n-                }\n-            }\n-            None => {}\n+        if self.mut_rvalue_borrows.remove(&ex.id) {\n+            self.promotable = false;\n         }\n \n-        if self.mode == Mode::Var && !self.qualif.intersects(ConstQualif::NOT_CONST) {\n+        if self.in_fn && self.promotable {\n             match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n@@ -448,9 +239,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n-        // Don't propagate certain flags.\n-        self.qualif = outer | (self.qualif - ConstQualif::HAS_STATIC_BORROWS);\n+        self.tcx.rvalue_promotable_to_static.borrow_mut().insert(ex.id, self.promotable);\n+        self.promotable &= outer;\n     }\n }\n \n@@ -463,7 +253,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyAdt(def, _) if def.has_dtor() => {\n-            v.add_qualif(ConstQualif::NEEDS_DROP);\n+            v.promotable = false;\n         }\n         _ => {}\n     }\n@@ -473,17 +263,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n         hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n             match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n@@ -495,7 +285,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n                             op.node == hir::BiGe || op.node == hir::BiGt);\n \n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n@@ -505,41 +295,32 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             match v.tcx.cast_kinds.borrow().get(&from.id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n             let def = v.tcx.tables().qpath_def(qpath, e.id);\n             match def {\n-                Def::VariantCtor(_, CtorKind::Const) => {\n-                    // Size is determined by the whole enum, may be non-zero.\n-                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                }\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n-                Def::Static(..) => {\n-                    match v.mode {\n-                        Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const | Mode::ConstFn => {}\n-                        Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n-                    }\n-                }\n-                Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n-                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n-                    if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n-                        let inner = v.global_expr(Mode::Const, expr);\n-                        v.add_qualif(inner);\n-                    }\n-                }\n-                Def::Local(..) if v.mode == Mode::ConstFn => {\n-                    // Sadly, we can't determine whether the types are zero-sized.\n-                    v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n+                Def::AssociatedConst(_) => v.add_type(node_ty),\n+                Def::Const(did) => {\n+                    v.promotable &= if let Some(node_id) = v.tcx.map.as_local_node_id(did) {\n+                        match v.tcx.map.expect_item(node_id).node {\n+                            hir::ItemConst(_, body) => {\n+                                v.visit_nested_body(body);\n+                                v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n+                            }\n+                            _ => false\n+                        }\n+                    } else {\n+                        v.tcx.sess.cstore.const_is_rvalue_promotable_to_static(did)\n+                    };\n                 }\n                 _ => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n             }\n         }\n@@ -560,65 +341,48 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             } else {\n                 Def::Err\n             };\n-            let is_const = match def {\n+            match def {\n                 Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) => {\n-                    // `NON_ZERO_SIZED` is about the call result, not about the ctor itself.\n-                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                    true\n-                }\n+                Def::VariantCtor(_, CtorKind::Fn) => {}\n                 Def::Fn(did) => {\n-                    v.handle_const_fn_call(e, did, node_ty)\n+                    v.handle_const_fn_call(did, node_ty)\n                 }\n                 Def::Method(did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n-                            v.handle_const_fn_call(e, did, node_ty)\n+                            v.handle_const_fn_call(did, node_ty)\n                         }\n-                        ty::TraitContainer(_) => false\n+                        ty::TraitContainer(_) => v.promotable = false\n                     }\n                 }\n-                _ => false\n-            };\n-            if !is_const {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                _ => v.promotable = false\n             }\n         }\n         hir::ExprMethodCall(..) => {\n             let method = v.tcx.tables().method_map[&method_call];\n-            let is_const = match v.tcx.associated_item(method.def_id).container {\n-                ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n-                ty::TraitContainer(_) => false\n-            };\n-            if !is_const {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+            match v.tcx.associated_item(method.def_id).container {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n+                ty::TraitContainer(_) => v.promotable = false\n             }\n         }\n         hir::ExprStruct(..) => {\n             if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n-                    v.add_qualif(ConstQualif::MUTABLE_MEM);\n+                    v.promotable = false;\n                 }\n             }\n         }\n \n         hir::ExprLit(_) |\n-        hir::ExprAddrOf(..) => {\n-            v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-        }\n-\n-        hir::ExprRepeat(..) => {\n-            v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n-        }\n+        hir::ExprAddrOf(..) |\n+        hir::ExprRepeat(..) => {}\n \n         hir::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n-                assert!(v.mode == Mode::Var,\n-                        \"global closures can't capture anything\");\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                v.promotable = false;\n             }\n         }\n \n@@ -647,7 +411,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |\n         hir::ExprInlineAsm(..) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n     }\n }\n@@ -666,7 +430,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n                 .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                v.promotable = false;\n             }\n         }\n     }\n@@ -676,9 +440,10 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n                                       &mut CheckCrateVisitor {\n                                           tcx: tcx,\n-                                          mode: Mode::Var,\n-                                          qualif: ConstQualif::NOT_CONST,\n-                                          rvalue_borrows: NodeMap(),\n+                                          in_fn: false,\n+                                          promotable: false,\n+                                          mut_rvalue_borrows: NodeSet(),\n+                                          param_env: tcx.empty_parameter_environment(),\n                                       }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n@@ -687,24 +452,9 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt,\n-               _mode: euv::ConsumeMode) {\n-        let mut cur = &cmt;\n-        loop {\n-            match cur.cat {\n-                Categorization::StaticItem => {\n-                    break;\n-                }\n-                Categorization::Deref(ref cmt, ..) |\n-                Categorization::Downcast(ref cmt, _) |\n-                Categorization::Interior(ref cmt, _) => cur = cmt,\n+               _cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {}\n \n-                Categorization::Rvalue(..) |\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) => break,\n-            }\n-        }\n-    }\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n@@ -731,21 +481,9 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                         // Ignore the dummy immutable borrow created by EUV.\n                         break;\n                     }\n-                    let mutbl = bk.to_mutbl_lossy();\n-                    if mutbl == hir::MutMutable && self.mode == Mode::StaticMut {\n-                        // Mutable slices are the only `&mut` allowed in\n-                        // globals, but only in `static mut`, nowhere else.\n-                        // FIXME: This exception is really weird... there isn't\n-                        // any fundamental reason to restrict this based on\n-                        // type of the expression.  `&mut [1]` has exactly the\n-                        // same representation as &mut 1.\n-                        match cmt.ty.sty {\n-                            ty::TyArray(..) |\n-                            ty::TySlice(_) => break,\n-                            _ => {}\n-                        }\n+                    if bk.to_mutbl_lossy() == hir::MutMutable {\n+                        self.mut_rvalue_borrows.insert(borrow_id);\n                     }\n-                    self.record_borrow(borrow_id, mutbl);\n                     break;\n                 }\n                 Categorization::StaticItem => {"}, {"sha": "65a60732fc8074e423790ba73597b0e387316d64", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -115,6 +115,11 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.visit_item(nested_item)\n     }\n \n+    fn visit_nested_trait_item(&mut self, trait_item_id: hir::TraitItemId) {\n+        let nested_trait_item = self.krate.unwrap().trait_item(trait_item_id);\n+        self.visit_trait_item(nested_trait_item)\n+    }\n+\n     fn visit_nested_impl_item(&mut self, impl_item_id: hir::ImplItemId) {\n         let nested_impl_item = self.krate.unwrap().impl_item(impl_item_id);\n         self.visit_impl_item(nested_impl_item)\n@@ -172,7 +177,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: hir_visit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: hir::ExprId,\n+                b: hir::BodyId,\n                 s: Span,\n                 id: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);"}, {"sha": "df9fe00e9a88e23d99f9e248d6843b0c12610a14", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'ast> Visitor<'ast> for CheckLoopVisitor<'a, 'ast> {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., b, _) => {\n-                self.with_context(Closure, |v| v.visit_body(b));\n+                self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {"}, {"sha": "3da4f24b6c2fe077243b34e0c25a60f9dd84f77e", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'tcx>,\n                 fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId,\n+                b: hir::BodyId,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context\n@@ -50,9 +50,9 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n                 tcx: infcx.tcx,\n                 param_env: &param_env\n             };\n-            let body = infcx.tcx.map.expr(b);\n+            let body = infcx.tcx.map.body(b);\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.walk_fn(fd, body);\n+            euv.consume_body(body);\n         });\n         intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n     }"}, {"sha": "ba4fc57276b2ce21a2709b118ef6098d7785676b", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -30,7 +30,7 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n     // variant definitions with the discriminant expression that applies to\n     // each one. If the variant uses the default values (starting from `0`),\n     // then `None` is stored.\n-    discriminant_map: NodeMap<Option<&'ast hir::Expr>>,\n+    discriminant_map: NodeMap<Option<hir::BodyId>>,\n     detected_recursive_ids: NodeSet,\n }\n \n@@ -66,7 +66,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n \n     fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         match ti.node {\n-            hir::ConstTraitItem(_, ref default) => {\n+            hir::TraitItemKind::Const(_, ref default) => {\n                 if let Some(_) = *default {\n                     let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ti.span);\n                     recursion_visitor.visit_trait_item(ti);\n@@ -108,7 +108,7 @@ struct CheckItemRecursionVisitor<'a, 'b: 'a, 'ast: 'b> {\n     root_span: &'b Span,\n     sess: &'b Session,\n     ast_map: &'b ast_map::Map<'ast>,\n-    discriminant_map: &'a mut NodeMap<Option<&'ast hir::Expr>>,\n+    discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n     idstack: Vec<ast::NodeId>,\n     detected_recursive_ids: &'a mut NodeSet,\n }\n@@ -189,7 +189,7 @@ impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n             variant_stack.push(variant.node.data.id());\n             // When we find an expression, every variant currently on the stack\n             // is affected by that expression.\n-            if let Some(ref expr) = variant.node.disr_expr {\n+            if let Some(expr) = variant.node.disr_expr {\n                 for id in &variant_stack {\n                     self.discriminant_map.insert(*id, Some(expr));\n                 }\n@@ -226,19 +226,15 @@ impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, '\n                      _: &'ast hir::Generics,\n                      _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n-        let maybe_expr;\n-        if let Some(get_expr) = self.discriminant_map.get(&variant_id) {\n-            // This is necessary because we need to let the `discriminant_map`\n-            // borrow fall out of scope, so that we can reborrow farther down.\n-            maybe_expr = (*get_expr).clone();\n-        } else {\n+        let maybe_expr = *self.discriminant_map.get(&variant_id).unwrap_or_else(|| {\n             span_bug!(variant.span,\n                       \"`check_static_recursion` attempted to visit \\\n                       variant with unknown discriminant\")\n-        }\n+        });\n         // If `maybe_expr` is `None`, that's because no discriminant is\n         // specified that affects this variant. Thus, no risk of recursion.\n         if let Some(expr) = maybe_expr {\n+            let expr = &self.ast_map.body(expr).value;\n             self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr), expr.span);\n         }\n     }"}, {"sha": "34ebd12de9c18fbc38b56baedf7ff4ddcbf50e1c", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -33,6 +33,9 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "81863a3fadfd36f69badeacf39ac631fe6905b38", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -160,21 +160,19 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                    if impl_item.vis == hir::Public {\n-                        self.update(impl_item.id, item_level);\n+                    if impl_item_ref.vis == hir::Public {\n+                        self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                    self.update(impl_item.id, item_level);\n+                    self.update(impl_item_ref.id.node_id, item_level);\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_items) => {\n-                for trait_item in trait_items {\n-                    self.update(trait_item.id, item_level);\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n+                for trait_item_ref in trait_item_refs {\n+                    self.update(trait_item_ref.id.node_id, item_level);\n                 }\n             }\n             hir::ItemStruct(ref def, _) | hir::ItemUnion(ref def, _) => {\n@@ -214,15 +212,16 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.reach(item.id).generics().predicates().item_type();\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_items) => {\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n \n-                    for trait_item in trait_items {\n-                        let mut reach = self.reach(trait_item.id);\n+                    for trait_item_ref in trait_item_refs {\n+                        let mut reach = self.reach(trait_item_ref.id.node_id);\n                         reach.generics().predicates();\n \n-                        if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                        if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n+                           !trait_item_ref.defaultness.has_value() {\n                             // No type to visit.\n                         } else {\n                             reach.item_type();\n@@ -231,12 +230,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_items) => {\n+            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().impl_trait_ref();\n \n-                    for impl_item in impl_items {\n-                        let id = impl_item.id.node_id;\n+                    for impl_item_ref in impl_item_refs {\n+                        let id = impl_item_ref.id.node_id;\n                         if trait_ref.is_some() || self.get(id).is_some() {\n                             self.reach(id).generics().predicates().item_type();\n                         }\n@@ -789,22 +788,19 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                        match impl_item.node {\n-                            hir::ImplItemKind::Const(..) => {\n-                                if self.item_is_public(&impl_item.id, &impl_item.vis) {\n+                        if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n+                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                            match impl_item_ref.kind {\n+                                hir::AssociatedItemKind::Const => {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n-                            }\n-                            hir::ImplItemKind::Method(ref sig, _) => {\n-                                if !sig.decl.has_self() &&\n-                                        self.item_is_public(&impl_item.id, &impl_item.vis) {\n+                                hir::AssociatedItemKind::Method { has_self: false } => {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n+                                _ => {}\n                             }\n-                            _ => {}\n                         }\n                     }\n                     if found_pub_static {\n@@ -1092,14 +1088,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.inner_visibility = item_visibility;\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemTrait(.., ref trait_items) => {\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n-                for trait_item in trait_items {\n-                    let mut check = self.check(trait_item.id, item_visibility);\n+                for trait_item_ref in trait_item_refs {\n+                    let mut check = self.check(trait_item_ref.id.node_id, item_visibility);\n                     check.generics().predicates();\n \n-                    if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                    if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n+                       !trait_item_ref.defaultness.has_value() {\n                         // No type to visit.\n                     } else {\n                         check.item_type();"}, {"sha": "865195d3db488e3914ae34ac82ec3a633c333d93", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -571,6 +571,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         if let TyKind::Path(ref qself, ref path) = ty.node {\n             self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+        } else if let TyKind::ImplicitSelf = ty.node {\n+            let self_ty = keywords::SelfType.ident();\n+            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n+                          .map_or(Def::Err, |d| d.def());\n+            self.record_def(ty.id, PathResolution::new(def));\n+        } else if let TyKind::Array(ref element, ref length) = ty.node {\n+            self.visit_ty(element);\n+            self.with_constant_rib(|this| {\n+                this.visit_expr(length);\n+            });\n+            return;\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -741,6 +752,13 @@ impl<'a> LexicalScopeBinding<'a> {\n             _ => None,\n         }\n     }\n+\n+    fn def(self) -> Def {\n+        match self {\n+            LexicalScopeBinding::Item(binding) => binding.def(),\n+            LexicalScopeBinding::Def(def) => def,\n+        }\n+    }\n }\n \n #[derive(Clone)]\n@@ -2721,6 +2739,13 @@ impl<'a> Resolver<'a> {\n                     self.visit_ty(ty);\n                 }\n             }\n+\n+            ExprKind::Repeat(ref element, ref count) => {\n+                self.visit_expr(element);\n+                self.with_constant_rib(|this| {\n+                    this.visit_expr(count);\n+                });\n+            }\n             ExprKind::Call(ref callee, ref arguments) => {\n                 self.resolve_expr(callee, Some(&expr.node));\n                 for argument in arguments {"}, {"sha": "43e3b1dd2b50a9d5e62d225da8f5c777698d5861", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -349,7 +349,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&rustc::hir::print::ty_to_string(&ty));\n+                            result.push_str(&self.tcx.map.node_to_pretty_string(ty.id));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;"}, {"sha": "2bc42a461528da2bfb28b779341c40ad1e8ec73c", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 16, "deletions": 66, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -202,8 +202,6 @@ use rustc::mir::{self, Location};\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use rustc_const_eval as const_eval;\n-\n use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n@@ -344,19 +342,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             recursion_depth_reset = None;\n \n-            // Scan the MIR in order to find function calls, closures, and\n-            // drop-glue\n-            let mir = scx.tcx().item_mir(def_id);\n-\n-            let empty_substs = scx.empty_substs_for_def_id(def_id);\n-            let visitor = MirNeighborCollector {\n-                scx: scx,\n-                mir: &mir,\n-                output: &mut neighbors,\n-                param_substs: empty_substs\n-            };\n-\n-            visit_mir_and_promoted(visitor, &mir);\n+            collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n@@ -365,18 +351,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                                recursion_depths));\n             check_type_length_limit(scx.tcx(), instance);\n \n-            // Scan the MIR in order to find function calls, closures, and\n-            // drop-glue\n-            let mir = scx.tcx().item_mir(instance.def);\n-\n-            let visitor = MirNeighborCollector {\n-                scx: scx,\n-                mir: &mir,\n-                output: &mut neighbors,\n-                param_substs: instance.substs\n-            };\n-\n-            visit_mir_and_promoted(visitor, &mir);\n+            collect_neighbours(scx, instance, &mut neighbors);\n         }\n     }\n \n@@ -563,33 +538,12 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // This is not a callee, but we still have to look for\n                     // references to `const` items\n                     if let mir::Literal::Item { def_id, substs } = constant.literal {\n-                        let tcx = self.scx.tcx();\n                         let substs = monomorphize::apply_param_substs(self.scx,\n                                                                       self.param_substs,\n                                                                       &substs);\n \n-                        // If the constant referred to here is an associated\n-                        // item of a trait, we need to resolve it to the actual\n-                        // constant in the corresponding impl. Luckily\n-                        // const_eval::lookup_const_by_id() does that for us.\n-                        if let Some((expr, _)) = const_eval::lookup_const_by_id(tcx,\n-                                                                                def_id,\n-                                                                                Some(substs)) {\n-                            // The hir::Expr we get here is the initializer of\n-                            // the constant, what we really want is the item\n-                            // DefId.\n-                            let const_node_id = tcx.map.get_parent(expr.id);\n-                            let def_id = if tcx.map.is_inlined_node_id(const_node_id) {\n-                                tcx.sess.cstore.defid_for_inlined_node(const_node_id).unwrap()\n-                            } else {\n-                                tcx.map.local_def_id(const_node_id)\n-                            };\n-\n-                            collect_const_item_neighbours(self.scx,\n-                                                          def_id,\n-                                                          substs,\n-                                                          self.output);\n-                        }\n+                        let instance = Instance::new(def_id, substs).resolve_const(self.scx);\n+                        collect_neighbours(self.scx, instance, self.output);\n                     }\n \n                     None\n@@ -1122,6 +1076,11 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _: &'v hir::TraitItem) {\n+        // Even if there's a default body with no explicit generics,\n+        // it's still generic over some `Self: Trait`, so not a root.\n+    }\n+\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig {\n@@ -1228,29 +1187,20 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n     }\n }\n \n-// There are no translation items for constants themselves but their\n-// initializers might still contain something that produces translation items,\n-// such as cast that introduce a new vtable.\n-fn collect_const_item_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                           def_id: DefId,\n-                                           substs: &'tcx Substs<'tcx>,\n-                                           output: &mut Vec<TransItem<'tcx>>)\n+/// Scan the MIR in order to find function calls, closures, and drop-glue\n+fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                instance: Instance<'tcx>,\n+                                output: &mut Vec<TransItem<'tcx>>)\n {\n-    // Scan the MIR in order to find function calls, closures, and\n-    // drop-glue\n-    let mir = scx.tcx().item_mir(def_id);\n+    let mir = scx.tcx().item_mir(instance.def);\n \n-    let visitor = MirNeighborCollector {\n+    let mut visitor = MirNeighborCollector {\n         scx: scx,\n         mir: &mir,\n         output: output,\n-        param_substs: substs\n+        param_substs: instance.substs\n     };\n \n-    visit_mir_and_promoted(visitor, &mir);\n-}\n-\n-fn visit_mir_and_promoted<'tcx, V: MirVisitor<'tcx>>(mut visitor: V, mir: &mir::Mir<'tcx>) {\n     visitor.visit_mir(&mir);\n     for promoted in &mir.promoted {\n         visitor.visit_mir(promoted);"}, {"sha": "d9179d6a6fa73888a7f9e4a5c4fad00562364518", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -737,14 +737,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().drop_glues\n     }\n \n-    pub fn local_node_for_inlined_defid<'a>(&'a self, def_id: DefId) -> Option<ast::NodeId> {\n-        self.sess().cstore.local_node_for_inlined_defid(def_id)\n-    }\n-\n-    pub fn defid_for_inlined_node<'a>(&'a self, node_id: ast::NodeId) -> Option<DefId> {\n-        self.sess().cstore.defid_for_inlined_node(node_id)\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }"}, {"sha": "1cedaa0a4e1a4ee68d9da82dd60fd881c41befff", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -18,7 +18,6 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n@@ -36,7 +35,7 @@ use type_::Type;\n use value::Value;\n \n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::ptr;\n@@ -238,24 +237,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n-                 mut instance: Instance<'tcx>,\n+                 instance: Instance<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr> {\n-        // Try to resolve associated constants.\n-        if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n-            let trait_ref = ty::TraitRef::new(trait_id, instance.substs);\n-            let trait_ref = ty::Binder(trait_ref);\n-            let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n-            if let traits::VtableImpl(vtable_impl) = vtable {\n-                let name = ccx.tcx().item_name(instance.def);\n-                let ac = ccx.tcx().associated_items(vtable_impl.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n-                if let Some(ac) = ac {\n-                    instance = Instance::new(ac.def_id, vtable_impl.substs);\n-                }\n-            }\n-        }\n-\n+        let instance = instance.resolve_const(ccx.shared());\n         let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "4b31d5b7f88de1ac9258351683a9c222e41e8c72", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -11,11 +11,15 @@\n use common::*;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::traits;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::ppaux;\n use rustc::util::common::MemoizationMap;\n+\n+use syntax::codemap::DUMMY_SP;\n+\n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -30,15 +34,35 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n     }\n }\n \n-impl<'tcx> Instance<'tcx> {\n+impl<'a, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n         assert!(substs.regions().all(|&r| r == ty::ReErased));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+\n+    pub fn mono(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n     }\n+\n+    /// For associated constants from traits, return the impl definition.\n+    pub fn resolve_const(&self, scx: &SharedCrateContext<'a, 'tcx>) -> Self {\n+        if let Some(trait_id) = scx.tcx().trait_of_item(self.def) {\n+            let trait_ref = ty::TraitRef::new(trait_id, self.substs);\n+            let trait_ref = ty::Binder(trait_ref);\n+            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n+            if let traits::VtableImpl(vtable_impl) = vtable {\n+                let name = scx.tcx().item_name(self.def);\n+                let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n+                if let Some(ac) = ac {\n+                    return Instance::new(ac.def_id, vtable_impl.substs);\n+                }\n+            }\n+        }\n+\n+        *self\n+    }\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "75c25a605af252cd6a57138c857d4cafe6d3b033", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 67, "deletions": 100, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -50,10 +50,9 @@\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use hir::{self, SelfKind};\n+use hir;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -227,6 +226,7 @@ pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n fn report_elision_failure(\n+    tcx: TyCtxt,\n     db: &mut DiagnosticBuilder,\n     params: Vec<ElisionFailureInfo>)\n {\n@@ -241,13 +241,14 @@ fn report_elision_failure(\n \n     for (i, info) in elided_params.into_iter().enumerate() {\n         let ElisionFailureInfo {\n-            name, lifetime_count: n, have_bound_regions\n+            parent, index, lifetime_count: n, have_bound_regions\n         } = info;\n \n-        let help_name = if name.is_empty() {\n-            format!(\"argument {}\", i + 1)\n+        let help_name = if let Some(body) = parent {\n+            let arg = &tcx.map.body(body).arguments[index];\n+            format!(\"`{}`\", tcx.map.node_to_pretty_string(arg.pat.id))\n         } else {\n-            format!(\"`{}`\", name)\n+            format!(\"argument {}\", index + 1)\n         };\n \n         m.push_str(&(if n == 1 {\n@@ -315,7 +316,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n \n                     if let Some(params) = params {\n-                        report_elision_failure(&mut err, params);\n+                        report_elision_failure(self.tcx(), &mut err, params);\n                     }\n                     err.emit();\n                     ty::ReStatic\n@@ -540,15 +541,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// corresponding to each input type/pattern.\n     fn find_implied_output_region<I>(&self,\n                                      input_tys: &[Ty<'tcx>],\n-                                     input_pats: I) -> ElidedLifetime\n-        where I: Iterator<Item=String>\n+                                     parent: Option<hir::BodyId>,\n+                                     input_indices: I) -> ElidedLifetime\n+        where I: Iterator<Item=usize>\n     {\n         let tcx = self.tcx();\n         let mut lifetimes_for_params = Vec::with_capacity(input_tys.len());\n         let mut possible_implied_output_region = None;\n         let mut lifetimes = 0;\n \n-        for input_type in input_tys.iter() {\n+        for (input_type, index) in input_tys.iter().zip(input_indices) {\n             let mut regions = FxHashSet();\n             let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n@@ -564,11 +566,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 possible_implied_output_region = regions.iter().cloned().next();\n             }\n \n-            // Use a placeholder for `name` because computing it can be\n-            // expensive and we don't want to do it until we know it's\n-            // necessary.\n             lifetimes_for_params.push(ElisionFailureInfo {\n-                name: String::new(),\n+                parent: parent,\n+                index: index,\n                 lifetime_count: regions.len(),\n                 have_bound_regions: have_bound_regions\n             });\n@@ -577,11 +577,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if lifetimes == 1 {\n             Ok(*possible_implied_output_region.unwrap())\n         } else {\n-            // Fill in the expensive `name` fields now that we know they're\n-            // needed.\n-            for (info, input_pat) in lifetimes_for_params.iter_mut().zip(input_pats) {\n-                info.name = input_pat;\n-            }\n             Err(Some(lifetimes_for_params))\n         }\n     }\n@@ -618,8 +613,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n             self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n         }));\n-        let input_params = iter::repeat(String::new()).take(inputs.len());\n-        let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n+        let input_params = 0..inputs.len();\n+        let implied_output_region = self.find_implied_output_region(&inputs, None, input_params);\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n@@ -689,7 +684,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             _ => {\n                 span_fatal!(self.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                            path);\n+                            self.tcx().map.node_to_pretty_string(trait_ref.ref_id));\n             }\n         }\n     }\n@@ -976,7 +971,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let mut err = struct_span_err!(tcx.sess, ty.span, E0178,\n                                                \"expected a path on the left-hand side \\\n                                                 of `+`, not `{}`\",\n-                                               pprust::ty_to_string(ty));\n+                                               tcx.map.node_to_pretty_string(ty.id));\n                 err.span_label(ty.span, &format!(\"expected a path\"));\n                 let hi = bounds.iter().map(|x| match *x {\n                     hir::TraitTyParamBound(ref tr, _) => tr.span.hi,\n@@ -988,22 +983,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     expn_id: ty.span.expn_id,\n                 });\n                 match (&ty.node, full_span) {\n-                    (&hir::TyRptr(None, ref mut_ty), Some(full_span)) => {\n-                        let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n+                    (&hir::TyRptr(ref lifetime, ref mut_ty), Some(full_span)) => {\n+                        let ty_str = hir::print::to_string(&tcx.map, |s| {\n+                            use syntax::print::pp::word;\n+                            use syntax::print::pprust::PrintState;\n+\n+                            word(&mut s.s, \"&\")?;\n+                            s.print_opt_lifetime(lifetime)?;\n+                            s.print_mutability(mut_ty.mutbl)?;\n+                            s.popen()?;\n+                            s.print_type(&mut_ty.ty)?;\n+                            s.print_bounds(\" +\", bounds)?;\n+                            s.pclose()\n+                        });\n                         err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                            format!(\"&{}({} +{})\",\n-                                                    mutbl_str,\n-                                                    pprust::ty_to_string(&mut_ty.ty),\n-                                                    pprust::bounds_to_string(bounds)));\n-                    }\n-                    (&hir::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n-                        let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n-                        err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                            format!(\"&{} {}({} +{})\",\n-                                                    pprust::lifetime_to_string(lt),\n-                                                    mutbl_str,\n-                                                    pprust::ty_to_string(&mut_ty.ty),\n-                                                    pprust::bounds_to_string(bounds)));\n+                                            ty_str);\n                     }\n \n                     _ => {\n@@ -1572,6 +1566,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                               bf.abi,\n                                                               None,\n                                                               &bf.decl,\n+                                                              None,\n                                                               anon_scope,\n                                                               anon_scope);\n \n@@ -1664,8 +1659,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n-            hir::TyArray(ref ty, ref e) => {\n-                if let Ok(length) = eval_length(tcx.global_tcx(), &e, \"array length\") {\n+            hir::TyArray(ref ty, length) => {\n+                let e = &tcx.map.body(length).value;\n+                if let Ok(length) = eval_length(tcx.global_tcx(), e, \"array length\") {\n                     tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n                 } else {\n                     self.tcx().types.err\n@@ -1695,26 +1691,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn ty_of_arg(&self,\n                      rscope: &RegionScope,\n-                     a: &hir::Arg,\n+                     ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n-        match a.ty.node {\n+        match ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(a.ty.span),\n-            _ => self.ast_ty_to_ty(rscope, &a.ty),\n+            hir::TyInfer => self.ty_infer(ty.span),\n+            _ => self.ast_ty_to_ty(rscope, ty),\n         }\n     }\n \n     pub fn ty_of_method(&self,\n                         sig: &hir::MethodSig,\n-                        untransformed_self_ty: Ty<'tcx>,\n+                        opt_self_value_ty: Option<Ty<'tcx>>,\n+                        body: Option<hir::BodyId>,\n                         anon_scope: Option<AnonTypeScope>)\n                         -> &'tcx ty::BareFnTy<'tcx> {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n-                                     Some(untransformed_self_ty),\n+                                     opt_self_value_ty,\n                                      &sig.decl,\n+                                     body,\n                                      None,\n                                      anon_scope)\n     }\n@@ -1723,16 +1721,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                          unsafety: hir::Unsafety,\n                          abi: abi::Abi,\n                          decl: &hir::FnDecl,\n+                         body: hir::BodyId,\n                          anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope)\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, Some(body), None, anon_scope)\n     }\n \n     fn ty_of_method_or_bare_fn(&self,\n                                unsafety: hir::Unsafety,\n                                abi: abi::Abi,\n-                               opt_untransformed_self_ty: Option<Ty<'tcx>>,\n+                               opt_self_value_ty: Option<Ty<'tcx>>,\n                                decl: &hir::FnDecl,\n+                               body: Option<hir::BodyId>,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n                                -> &'tcx ty::BareFnTy<'tcx>\n@@ -1743,38 +1743,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // declaration are bound to that function type.\n         let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n \n-        // `implied_output_region` is the region that will be assumed for any\n-        // region parameters in the return type. In accordance with the rules for\n-        // lifetime elision, we can determine it in two ways. First (determined\n-        // here), if self is by-reference, then the implied output region is the\n-        // region of the self parameter.\n-        let (self_ty, explicit_self) = match (opt_untransformed_self_ty, decl.get_self()) {\n-            (Some(untransformed_self_ty), Some(explicit_self)) => {\n-                let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n-                                                         &explicit_self);\n-                (Some(self_type), Some(ExplicitSelf::determine(untransformed_self_ty, self_type)))\n-            }\n-            _ => (None, None),\n-        };\n+        let input_tys: Vec<Ty> =\n+            decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n \n-        // HACK(eddyb) replace the fake self type in the AST with the actual type.\n-        let arg_params = if self_ty.is_some() {\n-            &decl.inputs[1..]\n-        } else {\n-            &decl.inputs[..]\n-        };\n-        let arg_tys: Vec<Ty> =\n-            arg_params.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n+        let has_self = opt_self_value_ty.is_some();\n+        let explicit_self = opt_self_value_ty.map(|self_value_ty| {\n+            ExplicitSelf::determine(self_value_ty, input_tys[0])\n+        });\n \n-        // Second, if there was exactly one lifetime (either a substitution or a\n-        // reference) in the arguments, then any anonymous regions in the output\n-        // have that lifetime.\n         let implied_output_region = match explicit_self {\n+            // `implied_output_region` is the region that will be assumed for any\n+            // region parameters in the return type. In accordance with the rules for\n+            // lifetime elision, we can determine it in two ways. First (determined\n+            // here), if self is by-reference, then the implied output region is the\n+            // region of the self parameter.\n             Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n+\n+            // Second, if there was exactly one lifetime (either a substitution or a\n+            // reference) in the arguments, then any anonymous regions in the output\n+            // have that lifetime.\n             _ => {\n-                self.find_implied_output_region(&arg_tys,\n-                                                arg_params.iter()\n-                                                    .map(|a| pprust::pat_to_string(&a.pat)))\n+                let arg_tys = &input_tys[has_self as usize..];\n+                let arg_params = has_self as usize..input_tys.len();\n+                self.find_implied_output_region(arg_tys, body, arg_params)\n \n             }\n         };\n@@ -1793,37 +1784,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             unsafety: unsafety,\n             abi: abi,\n             sig: ty::Binder(self.tcx().mk_fn_sig(\n-                self_ty.into_iter().chain(arg_tys),\n+                input_tys.into_iter(),\n                 output_ty,\n                 decl.variadic\n             )),\n         })\n     }\n \n-    fn determine_self_type<'a>(&self,\n-                               rscope: &RegionScope,\n-                               untransformed_self_ty: Ty<'tcx>,\n-                               explicit_self: &hir::ExplicitSelf)\n-                               -> Ty<'tcx>\n-    {\n-        match explicit_self.node {\n-            SelfKind::Value(..) => untransformed_self_ty,\n-            SelfKind::Region(ref lifetime, mutability) => {\n-                let region =\n-                    self.opt_ast_region_to_region(\n-                                             rscope,\n-                                             explicit_self.span,\n-                                             lifetime);\n-                self.tcx().mk_ref(region,\n-                    ty::TypeAndMut {\n-                        ty: untransformed_self_ty,\n-                        mutbl: mutability\n-                    })\n-            }\n-            SelfKind::Explicit(ref ast_type, _) => self.ast_ty_to_ty(rscope, &ast_type)\n-        }\n-    }\n-\n     pub fn ty_of_closure(&self,\n         unsafety: hir::Unsafety,\n         decl: &hir::FnDecl,"}, {"sha": "9b86196b3ece234b91eb760575bd23989362d14d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -527,7 +527,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let report_unexpected_def = |def: Def| {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(), qpath);\n+                      def.kind_name(),\n+                      hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -568,7 +569,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              def.kind_name(), qpath);\n+                              def.kind_name(),\n+                              hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n             on_error();"}, {"sha": "0b9cf38fa073316a3d1adffa112f545029a1a013", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -13,7 +13,6 @@ use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n use CrateCtxt;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::symbol::Symbol;\n@@ -203,7 +202,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let &ty::TyAdt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(print::expr_to_string(expr))\n+                            unit_variant = Some(self.tcx.map.node_to_pretty_string(expr.id))\n                         }\n                     }\n                 }"}, {"sha": "9412c9105c7aa572758785457f3ce5c366622efe", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body_id: hir::ExprId,\n+                              body_id: hir::BodyId,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -39,15 +39,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n-        let body = self.tcx.map.expr(body_id);\n+        let body = self.tcx.map.body(body_id);\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n     fn check_closure(&self,\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Expr,\n+                     body: &'gcx hir::Body,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n@@ -73,18 +73,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let fn_sig = self.tcx\n-            .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),\n-                                         &fn_ty.sig);\n-        let fn_sig = (**self).normalize_associated_types_in(body.span, body.id, &fn_sig);\n+        let extent = self.tcx.region_maps.call_site_extent(expr.id, body.value.id);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &fn_ty.sig);\n+        let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n+                                                            body.value.id, &fn_sig);\n \n         check_fn(self,\n                  hir::Unsafety::Normal,\n                  expr.id,\n                  &fn_sig,\n                  decl,\n                  expr.id,\n-                 &body);\n+                 body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "be10b77bd8b90c33ea0e5ea6c13c28945329a26e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n+use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n use rustc::util::common::ErrorReported;\n \n use syntax::ast;\n@@ -450,37 +449,24 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n         TypeError::Mutability => {\n             if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n                 let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                    TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                    TraitItemKind::Method(ref trait_m_sig, _) => {\n                         trait_m_sig.decl.inputs.iter()\n                     }\n-                    _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                    _ => bug!(\"{:?} is not a TraitItemKind::Method\", trait_m),\n                 };\n \n-                impl_m_iter.zip(trait_m_iter)\n-                           .find(|&(ref impl_arg, ref trait_arg)| {\n-                               match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                                   (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                                   (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n-                                       impl_mt.mutbl != trait_mt.mutbl\n-                                   }\n-                                   _ => false,\n-                               }\n-                           })\n-                           .map(|(ref impl_arg, ref trait_arg)| {\n-                               match (impl_arg.to_self(), trait_arg.to_self()) {\n-                                   (Some(impl_self), Some(trait_self)) => {\n-                                       (impl_self.span, Some(trait_self.span))\n-                                   }\n-                                   (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                                   _ => {\n-                                       bug!(\"impl and trait fns have different first args, impl: \\\n-                                             {:?}, trait: {:?}\",\n-                                            impl_arg,\n-                                            trait_arg)\n-                                   }\n-                               }\n-                           })\n-                           .unwrap_or((cause.span, tcx.map.span_if_local(trait_m.def_id)))\n+                impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n+                    match (&impl_arg.node, &trait_arg.node) {\n+                        (&hir::TyRptr(_, ref impl_mt), &hir::TyRptr(_, ref trait_mt)) |\n+                        (&hir::TyPtr(ref impl_mt), &hir::TyPtr(ref trait_mt)) => {\n+                            impl_mt.mutbl != trait_mt.mutbl\n+                        }\n+                        _ => false,\n+                    }\n+                }).map(|(ref impl_arg, ref trait_arg)| {\n+                    (impl_arg.span, Some(trait_arg.span))\n+                })\n+                .unwrap_or_else(|| (cause.span, tcx.map.span_if_local(trait_m.def_id)))\n             } else {\n                 (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }\n@@ -489,10 +475,10 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n             if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n                 let (trait_m_output, trait_m_iter) =\n                     match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                        TraitItemKind::Method(ref trait_m_sig, _) => {\n                             (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n                         }\n-                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                        _ => bug!(\"{:?} is not a TraitItemKind::Method\", trait_m),\n                     };\n \n                 let impl_iter = impl_sig.inputs().iter();\n@@ -503,7 +489,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n                              match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n-                                 Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n+                                 Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n                          })\n                          .next()\n@@ -688,13 +674,13 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n             match tcx.map.expect_trait_item(trait_id).node {\n-                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                TraitItemKind::Method(ref trait_m_sig, _) => {\n                     if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n                         trait_number_args - 1\n                     } else {\n                         0\n                     }) {\n-                        Some(arg.pat.span)\n+                        Some(arg.span)\n                     } else {\n                         trait_item_span\n                     }\n@@ -712,7 +698,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 } else {\n                     0\n                 }) {\n-                    arg.pat.span\n+                    arg.span\n                 } else {\n                     impl_m_span\n                 }\n@@ -839,7 +825,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // Add a label to the Span containing just the type of the item\n             let trait_c_node_id = tcx.map.as_local_node_id(trait_c.def_id).unwrap();\n             let trait_c_span = match tcx.map.expect_trait_item(trait_c_node_id).node {\n-                TraitItem_::ConstTraitItem(ref ty, _) => ty.span,\n+                TraitItemKind::Const(ref ty, _) => ty.span,\n                 _ => bug!(\"{:?} is not a trait const\", trait_c),\n             };\n "}, {"sha": "c733c0856c6da2d12ad75e949413eef0ff1bfa8a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -48,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n-            hir::ForeignItemFn(_, ref generics) => generics.span,\n+            hir::ForeignItemFn(_, _, ref generics) => generics.span,\n             hir::ForeignItemStatic(..) => it.span\n         };\n "}, {"sha": "04ec9292d1410ee727c3684ffe90b060adcb2df1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -26,7 +26,6 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-use rustc::hir::print as pprust;\n use rustc::hir;\n use rustc::infer::type_variable::TypeVariableOrigin;\n \n@@ -266,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = if let Some(callee) = rcvr_expr {\n                     format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                             msg,\n-                            pprust::expr_to_string(callee))\n+                            self.tcx.map.node_to_pretty_string(callee.id))\n                 } else {\n                     msg\n                 };\n@@ -463,6 +462,9 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                 }\n             }\n \n+            fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+            }\n+\n             fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n             }\n         }"}, {"sha": "7275fbd12036b308768b7fc53259bf3c8e28384b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 82, "deletions": 108, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -122,7 +122,6 @@ use syntax_pos::{self, BytePos, Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::print as pprust;\n use rustc::middle::lang_items;\n use rustc_back::slice;\n use rustc_const_eval::eval_length;\n@@ -550,21 +549,36 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n-            hir::TyArray(_, ref expr) => {\n-                check_const_with_type(self.ccx, &expr, self.ccx.tcx.types.usize, expr.id);\n+            hir::TyArray(_, length) => {\n+                check_const_with_type(self.ccx, length, self.ccx.tcx.types.usize, length.node_id);\n             }\n             _ => {}\n         }\n \n         intravisit::walk_ty(self, t);\n     }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+        match e.node {\n+            hir::ExprRepeat(_, count) => {\n+                check_const_with_type(self.ccx, count, self.ccx.tcx.types.usize, count.node_id);\n+            }\n+            _ => {}\n+        }\n+\n+        intravisit::walk_expr(self, e);\n+    }\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_body(self.ccx, i);\n     }\n \n+    fn visit_trait_item(&mut self, _item: &'tcx hir::TraitItem) {\n+        // done as part of `visit_item` above\n+    }\n+\n     fn visit_impl_item(&mut self, _item: &'tcx hir::ImplItem) {\n         // done as part of `visit_item` above\n     }\n@@ -635,28 +649,28 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body_id: hir::ExprId,\n+                           body_id: hir::BodyId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let body = ccx.tcx.map.expr(body_id);\n+    let body = ccx.tcx.map.body(body_id);\n \n     let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n-        _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n+        _ => span_bug!(body.value.span, \"check_bare_fn: function type expected\")\n     };\n \n     check_abi(ccx, span, fn_ty.abi);\n \n     ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id());\n+        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id);\n         let fn_sig =\n             fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n         let fn_sig =\n             inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n         let fn_sig =\n-            inh.normalize_associated_types_in(body.span, body_id.node_id(), &fn_sig);\n+            inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n@@ -666,8 +680,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, decl, body_id);\n-        fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n+        fcx.regionck_fn(fn_id, body);\n+        fcx.resolve_type_vars_in_body(body, fn_id);\n     });\n }\n \n@@ -736,32 +750,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        // non-obvious: the `blk` variable maps to region lb, so\n-        // we have to keep this up-to-date.  This\n-        // is... unfortunate.  It'd be nice to not need this.\n-        intravisit::walk_block(self, b);\n-    }\n-\n-    // Since an expr occurs as part of the type fixed size arrays we\n-    // need to record the type for that node\n-    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n-        match t.node {\n-            hir::TyArray(ref ty, ref count_expr) => {\n-                self.visit_ty(&ty);\n-                self.fcx.check_expr_with_hint(&count_expr, self.fcx.tcx.types.usize);\n-            }\n-            hir::TyBareFn(ref function_declaration) => {\n-                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n-                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n-            }\n-            _ => intravisit::walk_ty(self, t)\n-        }\n-    }\n-\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: hir::ExprId, _: Span, _: ast::NodeId) { }\n+                _: hir::BodyId, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -776,7 +767,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_sig: &ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n-                            body: &'gcx hir::Expr)\n+                            body: &'gcx hir::Body)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n     let mut fn_sig = fn_sig.clone();\n@@ -785,7 +776,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, None, body.id);\n+    let mut fcx = FnCtxt::new(inherited, None, body.value.id);\n     let ret_ty = fn_sig.output();\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n@@ -794,36 +785,26 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fn_sig = fcx.tcx.mk_fn_sig(fn_sig.inputs().iter().cloned(), &fcx.ret_ty.unwrap(),\n                                fn_sig.variadic);\n \n-    {\n-        let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n-\n-        // Add formal parameters.\n-        for (arg_ty, input) in fn_sig.inputs().iter().zip(&decl.inputs) {\n-            // The type of the argument must be well-formed.\n-            //\n-            // NB -- this is now checked in wfcheck, but that\n-            // currently only results in warnings, so we issue an\n-            // old-style WF obligation here so that we still get the\n-            // errors that we used to get.\n-            fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n-\n-            // Create type variables for each argument.\n-            input.pat.each_binding(|_bm, pat_id, sp, _path| {\n-                let var_ty = visit.assign(sp, pat_id, None);\n-                fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n-            });\n+    GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n \n-            // Check the pattern.\n-            fcx.check_pat(&input.pat, arg_ty);\n-            fcx.write_ty(input.id, arg_ty);\n-        }\n+    // Add formal parameters.\n+    for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n+        // The type of the argument must be well-formed.\n+        //\n+        // NB -- this is now checked in wfcheck, but that\n+        // currently only results in warnings, so we issue an\n+        // old-style WF obligation here so that we still get the\n+        // errors that we used to get.\n+        fcx.register_old_wf_obligation(arg_ty, arg.pat.span, traits::MiscObligation);\n \n-        visit.visit_expr(body);\n+        // Check the pattern.\n+        fcx.check_pat(&arg.pat, arg_ty);\n+        fcx.write_ty(arg.id, arg_ty);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    fcx.check_expr_coercable_to_type(body, fcx.ret_ty.unwrap());\n+    fcx.check_expr_coercable_to_type(&body.value, fcx.ret_ty.unwrap());\n \n     fcx\n }\n@@ -848,8 +829,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(.., ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, &e, it.id),\n+      hir::ItemStatic(.., e) |\n+      hir::ItemConst(_, e) => check_const(ccx, e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -908,7 +889,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                     err.emit();\n                 }\n \n-                if let hir::ForeignItemFn(ref fn_decl, _) = item.node {\n+                if let hir::ForeignItemFn(ref fn_decl, _, _) = item.node {\n                     require_c_abi_if_variadic(ccx.tcx, fn_decl, m.abi, item.span);\n                 }\n             }\n@@ -933,8 +914,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for impl_item_ref in impl_item_refs {\n             let impl_item = ccx.tcx.map.impl_item(impl_item_ref.id);\n             match impl_item.node {\n-                hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, &expr, impl_item.id)\n+                hir::ImplItemKind::Const(_, expr) => {\n+                    check_const(ccx, expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, body_id) => {\n                     check_bare_fn(ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n@@ -945,18 +926,19 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         }\n       }\n-      hir::ItemTrait(.., ref trait_items) => {\n-        for trait_item in trait_items {\n+      hir::ItemTrait(.., ref trait_item_refs) => {\n+        for trait_item_ref in trait_item_refs {\n+            let trait_item = ccx.tcx.map.trait_item(trait_item_ref.id);\n             match trait_item.node {\n-                hir::ConstTraitItem(_, Some(ref expr)) => {\n-                    check_const(ccx, &expr, trait_item.id)\n+                hir::TraitItemKind::Const(_, Some(expr)) => {\n+                    check_const(ccx, expr, trait_item.id)\n                 }\n-                hir::MethodTraitItem(ref sig, Some(body_id)) => {\n+                hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body_id)) => {\n                     check_bare_fn(ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n                 }\n-                hir::MethodTraitItem(_, None) |\n-                hir::ConstTraitItem(_, None) |\n-                hir::TypeTraitItem(..) => {\n+                hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n+                hir::TraitItemKind::Const(_, None) |\n+                hir::TraitItemKind::Type(..) => {\n                     // Nothing to do.\n                 }\n             }\n@@ -1122,7 +1104,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         compare_impl_method(ccx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body_id.node_id(),\n+                                            body_id.node_id,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1132,7 +1114,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             compare_impl_method(ccx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body_id.node_id(),\n+                                                body_id.node_id,\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,\n@@ -1243,37 +1225,38 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n /// Checks a constant with a given type.\n fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                                   expr: &'tcx hir::Expr,\n+                                   body: hir::BodyId,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n+    let body = ccx.tcx.map.body(body);\n     ccx.inherited(id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, None, expr.id);\n-        fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n+        let fcx = FnCtxt::new(&inh, None, body.value.id);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n         // Gather locals in statics (because of block expressions).\n         // This is technically unnecessary because locals in static items are forbidden,\n         // but prevents type checking from blowing up before const checking can properly\n         // emit an error.\n-        GatherLocalsVisitor { fcx: &fcx }.visit_expr(expr);\n+        GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n \n-        fcx.check_expr_coercable_to_type(expr, expected_type);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(expr);\n+        fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error();\n \n-        fcx.regionck_expr(expr);\n-        fcx.resolve_type_vars_in_expr(expr, id);\n+        fcx.regionck_expr(body);\n+        fcx.resolve_type_vars_in_body(body, id);\n     });\n }\n \n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                         expr: &'tcx hir::Expr,\n+                         body: hir::BodyId,\n                          id: ast::NodeId) {\n     let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n-    check_const_with_type(ccx, expr, decl_ty, id);\n+    check_const_with_type(ccx, body, decl_ty, id);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1348,8 +1331,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n     for v in vs {\n-        if let Some(ref e) = v.node.disr_expr {\n-            check_const_with_type(ccx, e, repr_type_ty, e.id);\n+        if let Some(e) = v.node.disr_expr {\n+            check_const_with_type(ccx, e, repr_type_ty, e.node_id);\n         }\n     }\n \n@@ -1365,11 +1348,11 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n             let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(ref expr) => expr.span,\n+                Some(expr) => ccx.tcx.map.span(expr.node_id),\n                 None => ccx.tcx.map.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(ref expr) => expr.span,\n+                Some(expr) => ccx.tcx.map.span(expr.node_id),\n                 None => v.span\n             };\n             struct_span_err!(ccx.tcx.sess, span, E0081,\n@@ -1643,12 +1626,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n-                struct_span_err!(self.tcx.sess, span, E0513,\n-                                 \"no type for local variable {}\",\n-                                 self.tcx.map.node_to_string(nid))\n-                    .span_label(span, &\"no type for variable\")\n-                    .emit();\n-                self.tcx.types.err\n+                span_bug!(span, \"no type for local variable {}\",\n+                          self.tcx.map.node_to_string(nid));\n             }\n         }\n     }\n@@ -3065,7 +3044,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ty::TyRawPtr(..) => {\n                     err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n-                                      `(*{0}).{1}`\", pprust::expr_to_string(base), field.node));\n+                                      `(*{0}).{1}`\",\n+                                      self.tcx.map.node_to_pretty_string(base.id),\n+                                      field.node));\n                 }\n                 _ => {}\n             }\n@@ -3479,11 +3460,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of expr({}) {} is...\", expr.id,\n-               pprust::expr_to_string(expr));\n-        debug!(\"... {:?}, expected is {:?}\",\n-               ty,\n-               expected);\n+        debug!(\"type of {} is...\", self.tcx.map.node_to_string(expr.id));\n+        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {\n@@ -3821,10 +3799,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               self.check_method_call(expr, name, args, &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n-            if let hir::TyArray(_, ref count_expr) = t.node {\n-                self.check_expr_with_hint(&count_expr, tcx.types.usize);\n-            }\n-\n             // Find the type of `e`. Supply hints based on the type we are casting to,\n             // if appropriate.\n             let t_cast = self.to_ty(t);\n@@ -3886,9 +3860,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             tcx.mk_array(unified, args.len())\n           }\n-          hir::ExprRepeat(ref element, ref count_expr) => {\n-            self.check_expr_has_type(&count_expr, tcx.types.usize);\n-            let count = eval_length(self.tcx.global_tcx(), &count_expr, \"repeat count\")\n+          hir::ExprRepeat(ref element, count) => {\n+            let count_expr = &tcx.map.body(count).value;\n+            let count = eval_length(self.tcx.global_tcx(), count_expr, \"repeat count\")\n                   .unwrap_or(0);\n \n             let uty = match expected {"}, {"sha": "bd63eb6ad25effeb2aa95536a598c8f5b48ba62d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -113,12 +113,13 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn regionck_expr(&self, e: &'gcx hir::Expr) {\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n+    pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n+        let id = body.value.id;\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(id));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_expr(e);\n-            rcx.visit_region_obligations(e.id);\n+            rcx.visit_body(body);\n+            rcx.visit_region_obligations(id);\n         }\n         rcx.resolve_regions_and_report_errors();\n     }\n@@ -140,15 +141,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n-                       decl: &hir::FnDecl,\n-                       body_id: hir::ExprId) {\n+                       body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let node_id = body_id.node_id();\n+        let node_id = body.value.id;\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, body_id, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -267,15 +267,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n-                     fn_decl: &hir::FnDecl,\n-                     body_id: hir::ExprId,\n+                     body: &'gcx hir::Body,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n+        let body_id = body.id();\n+\n         let call_site = self.tcx.region_maps.lookup_code_extent(\n-            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n+            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -298,20 +299,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n-        let old_body_id = self.set_body_id(body_id.node_id());\n-        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id(), span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id()),\n-                          &fn_decl.inputs[..]);\n-        let body = self.tcx.map.expr(body_id);\n-        self.visit_expr(body);\n-        self.visit_region_obligations(body_id.node_id());\n+        let old_body_id = self.set_body_id(body_id.node_id);\n+        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id), &body.arguments);\n+        self.visit_body(body);\n+        self.visit_region_obligations(body_id.node_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n-               body.id, call_site_scope);\n+        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n+               body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_id.node_id(),\n+                                       body_id.node_id,\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -478,12 +477,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, fd: &'gcx hir::FnDecl,\n-                b: hir::ExprId, span: Span, id: ast::NodeId) {\n-        self.visit_fn_body(id, fd, b, span)\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n+                b: hir::BodyId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.body(b);\n+        self.visit_fn_body(id, body, span)\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -826,8 +826,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_fn_block(&mut self,\n                            expr: &'gcx hir::Expr,\n-                           body_id: hir::ExprId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.node_id());\n+                           body_id: hir::BodyId) {\n+        let repeating_scope = self.set_repeating_scope(body_id.node_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }\n@@ -1113,7 +1113,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n+            let arg_cmt = mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty);\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n                    arg_cmt,"}, {"sha": "5d927a503a116036bbf092882e80dcd4b7b32d4b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -57,12 +57,12 @@ use rustc::util::nodemap::NodeMap;\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze(&self, body: &'gcx hir::Expr) {\n+    pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n         let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_expr(body);\n+        seed.visit_body(body);\n \n         let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_expr(body);\n+        adjust.visit_body(body);\n \n         // it's our job to process these.\n         assert!(self.deferred_call_resolutions.borrow().is_empty());\n@@ -79,13 +79,15 @@ struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, body_id, _) => {\n-                self.check_closure(expr, cc, body_id);\n+                let body = self.fcx.tcx.map.body(body_id);\n+                self.visit_body(body);\n+                self.check_closure(expr, cc);\n             }\n \n             _ => { }\n@@ -102,8 +104,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n-                     capture_clause: hir::CaptureClause,\n-                     _body_id: hir::ExprId)\n+                     capture_clause: hir::CaptureClause)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -156,23 +157,21 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&mut self,\n                        id: ast::NodeId,\n                        span: Span,\n-                       decl: &hir::FnDecl,\n-                       body_id: hir::ExprId) {\n+                       body: &hir::Body) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body_id);\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n-            let body = self.fcx.tcx.map.expr(body_id);\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true\n                                                   });\n-            euv.walk_fn(decl, body);\n+            euv.consume_body(body);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -491,18 +490,21 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'gcx>,\n                 decl: &'gcx hir::FnDecl,\n-                body: hir::ExprId,\n+                body: hir::BodyId,\n                 span: Span,\n                 id: ast::NodeId)\n     {\n         intravisit::walk_fn(self, fn_kind, decl, body, span, id);\n-        self.analyze_closure(id, span, decl, body);\n+\n+        let body = self.fcx.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.analyze_closure(id, span, body);\n     }\n }\n "}, {"sha": "c80db7fa4d0e02b47c5ab4b2b800f63f8065b886", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -159,10 +159,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&mut self,\n-                                item_id: ast::NodeId,\n-                                span: Span,\n-                                sig_if_method: Option<&hir::MethodSig>) {\n+    fn check_associated_item(&mut self,\n+                             item_id: ast::NodeId,\n+                             span: Span,\n+                             sig_if_method: Option<&hir::MethodSig>) {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -337,7 +337,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body_id: hir::ExprId)\n+                     body_id: hir::BodyId)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -354,7 +354,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id());\n+            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds\n@@ -478,7 +478,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             return;\n         }\n \n-        let span = method_sig.decl.inputs[0].pat.span;\n+        let span = method_sig.decl.inputs[0].span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n         let method_ty = fcx.tcx.item_type(method.def_id);\n@@ -607,10 +607,10 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         let method_sig = match trait_item.node {\n-            hir::TraitItem_::MethodTraitItem(ref sig, _) => Some(sig),\n+            hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n             _ => None\n         };\n-        self.check_trait_or_impl_item(trait_item.id, trait_item.span, method_sig);\n+        self.check_associated_item(trait_item.id, trait_item.span, method_sig);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n@@ -620,7 +620,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n             _ => None\n         };\n-        self.check_trait_or_impl_item(impl_item.id, impl_item.span, method_sig);\n+        self.check_associated_item(impl_item.id, impl_item.span, method_sig);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n }"}, {"sha": "9a2bfbf715af9785bb6432e24c9264dd63d65459", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -26,42 +26,22 @@ use std::cell::Cell;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, PatKind};\n+use rustc::hir;\n \n ///////////////////////////////////////////////////////////////////////////\n-// Entry point functions\n+// Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &'gcx hir::Expr, item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_body(&self,\n+                                     body: &'gcx hir::Body,\n+                                     item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_expr(e);\n-        wbcx.visit_upvar_borrow_map();\n-        wbcx.visit_closures();\n-        wbcx.visit_liberated_fn_sigs();\n-        wbcx.visit_fru_field_types();\n-        wbcx.visit_deferred_obligations(item_id);\n-        wbcx.visit_type_nodes();\n-    }\n-\n-    pub fn resolve_type_vars_in_fn(&self,\n-                                   decl: &'gcx hir::FnDecl,\n-                                   body: &'gcx hir::Expr,\n-                                   item_id: ast::NodeId) {\n-        assert_eq!(self.writeback_errors.get(), false);\n-        let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_expr(body);\n-        for arg in &decl.inputs {\n+        for arg in &body.arguments {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n-            wbcx.visit_pat(&arg.pat);\n-\n-            // Privacy needs the type for the whole pattern, not just each binding\n-            if let PatKind::Binding(..) = arg.pat.node {} else {\n-                wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.pat.id);\n-            }\n         }\n+        wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -188,7 +168,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n@@ -211,10 +191,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n \n-        if let hir::ExprClosure(_, ref decl, ..) = e.node {\n-            for input in &decl.inputs {\n-                self.visit_node_id(ResolvingExpr(e.span), input.id);\n+        if let hir::ExprClosure(_, _, body, _) = e.node {\n+            let body = self.fcx.tcx.map.body(body);\n+            for arg in &body.arguments {\n+                self.visit_node_id(ResolvingExpr(e.span), arg.id);\n             }\n+\n+            self.visit_body(body);\n         }\n \n         intravisit::walk_expr(self, e);\n@@ -237,7 +220,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n-               pat_to_string(p),\n+               self.tcx().map.node_to_pretty_string(p.id),\n                p.id,\n                self.tcx().tables().node_id_to_type(p.id));\n \n@@ -254,20 +237,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.write_ty_to_tcx(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n-\n-    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n-        match t.node {\n-            hir::TyArray(ref ty, ref count_expr) => {\n-                self.visit_ty(&ty);\n-                self.write_ty_to_tcx(count_expr.id, self.tcx().types.usize);\n-            }\n-            hir::TyBareFn(ref function_declaration) => {\n-                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n-                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n-            }\n-            _ => intravisit::walk_ty(self, t)\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "cd9453770a6ab28ff7a3e63af12db965a526fcec", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -50,6 +50,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "3bbe5aa1fef376272fd19e28e1f57ae5f4b741ae", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -58,6 +58,9 @@ impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx,\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "bc1ead07c0ea7f77a042135dab3fbff32825a3eb", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -67,13 +67,15 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n         }\n     }\n+}\n \n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions.  In this fn, it can happen that multiple errors\n     /// apply to a specific impl, so just return after reporting one\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n-    fn check_item(&self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemImpl(.., None, ref ty, _) => {\n@@ -368,7 +370,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                       the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n                                     &format!(\"`{}` trait not defined in this crate\",\n-                                             item_trait_ref.path))\n+                            self.tcx.map.node_to_pretty_string(item_trait_ref.ref_id)))\n                         .emit();\n                     return;\n                 }\n@@ -378,11 +380,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n         }\n     }\n-}\n \n-impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        self.check_item(item);\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {"}, {"sha": "a09bdf0533a151ecd7373192412932bcf0561d6f", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -205,6 +205,9 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "c4c7c699f65f62ba5c8a74524587d35e9de8e51d", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -107,6 +107,9 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "fd51b38e1b557464becb775ed9503b21ed415853", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 77, "deletions": 63, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -82,7 +82,7 @@ use syntax::{abi, ast, attr};\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n-use rustc::hir::{self, map as hir_map, print as pprust};\n+use rustc::hir::{self, map as hir_map};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -204,6 +204,13 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         intravisit::walk_ty(self, ty);\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.with_collect_item_sig(trait_item.id, || {\n+            convert_trait_item(self.ccx, trait_item)\n+        });\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_collect_item_sig(impl_item.id, || {\n             convert_impl_item(self.ccx, impl_item)\n@@ -633,7 +640,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+                            body: Option<hir::BodyId>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n     let def_id = ccx.tcx.map.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n@@ -644,8 +652,14 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n         TraitContainer(_) => None\n     };\n+    let assoc_item = ccx.tcx.associated_item(def_id);\n+    let self_value_ty = if assoc_item.method_has_self_argument {\n+        Some(untransformed_rcvr_ty)\n+    } else {\n+        None\n+    };\n     let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                    sig, untransformed_rcvr_ty, anon_scope);\n+                                    sig, self_value_ty, body, anon_scope);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n@@ -785,56 +799,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n         },\n-        hir::ItemTrait(.., ref trait_items) => {\n+        hir::ItemTrait(..) => {\n             generics_of_def_id(ccx, def_id);\n             trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.item_predicates(def_id);\n-\n-            debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n-\n-            // FIXME: is the ordering here important? I think it is.\n-            let container = TraitContainer(def_id);\n-\n-            // Convert all the associated constants.\n-            for trait_item in trait_items {\n-                if let hir::ConstTraitItem(ref ty, _) = trait_item.node {\n-                    let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                    generics_of_def_id(ccx, const_def_id);\n-                    let ty = ccx.icx(&trait_predicates)\n-                        .to_ty(&ExplicitRscope, ty);\n-                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n-                    convert_associated_const(ccx, container, trait_item.id, ty)\n-                }\n-            }\n-\n-            // Convert all the associated types.\n-            for trait_item in trait_items {\n-                if let hir::TypeTraitItem(_, ref opt_ty) = trait_item.node {\n-                    let type_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                    generics_of_def_id(ccx, type_def_id);\n-\n-                    let typ = opt_ty.as_ref().map({\n-                        |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n-                    });\n-\n-                    convert_associated_type(ccx, container, trait_item.id, typ);\n-                }\n-            }\n-\n-            // Convert all the methods\n-            for trait_item in trait_items {\n-                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n-                    convert_method(ccx,\n-                                   container,\n-                                   trait_item.id,\n-                                   sig,\n-                                   tcx.mk_self_type(),\n-                                   &trait_predicates);\n-                }\n-            }\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n@@ -866,6 +836,48 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     }\n }\n \n+fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n+    let tcx = ccx.tcx;\n+\n+    // we can lookup details about the trait because items are visited\n+    // before trait-items\n+    let trait_def_id = tcx.map.get_parent_did(trait_item.id);\n+    let trait_predicates = tcx.item_predicates(trait_def_id);\n+\n+    match trait_item.node {\n+        hir::TraitItemKind::Const(ref ty, _) => {\n+            let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+            generics_of_def_id(ccx, const_def_id);\n+            let ty = ccx.icx(&trait_predicates)\n+                        .to_ty(&ExplicitRscope, &ty);\n+            tcx.item_types.borrow_mut().insert(const_def_id, ty);\n+            convert_associated_const(ccx, TraitContainer(trait_def_id),\n+                                     trait_item.id, ty);\n+        }\n+\n+        hir::TraitItemKind::Type(_, ref opt_ty) => {\n+            let type_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+            generics_of_def_id(ccx, type_def_id);\n+\n+            let typ = opt_ty.as_ref().map({\n+                |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+            });\n+\n+            convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n+        }\n+\n+        hir::TraitItemKind::Method(ref sig, ref method) => {\n+            let body = match *method {\n+                hir::TraitMethod::Required(_) => None,\n+                hir::TraitMethod::Provided(body) => Some(body)\n+            };\n+            convert_method(ccx, TraitContainer(trait_def_id),\n+                           trait_item.id, sig, tcx.mk_self_type(),\n+                           body, &trait_predicates);\n+        }\n+    }\n+}\n+\n fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n     let tcx = ccx.tcx;\n \n@@ -901,10 +913,10 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n-        hir::ImplItemKind::Method(ref sig, _) => {\n+        hir::ImplItemKind::Method(ref sig, body) => {\n             convert_method(ccx, ImplContainer(impl_def_id),\n                            impl_item.id, sig, impl_self_ty,\n-                           &impl_predicates);\n+                           Some(body), &impl_predicates);\n         }\n     }\n }\n@@ -1029,7 +1041,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n                           -> Option<ty::Disr> {\n-        debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n+        debug!(\"disr expr, checking {}\", ccx.tcx.map.node_to_pretty_string(e.id));\n \n         let ty_hint = repr_ty.to_ty(ccx.tcx);\n         let print_err = |cv: ConstVal| {\n@@ -1088,7 +1100,8 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut prev_disr = None::<ty::Disr>;\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n-        let disr = if let Some(ref e) = v.node.disr_expr {\n+        let disr = if let Some(e) = v.node.disr_expr {\n+            let e = &tcx.map.body(e).value;\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n             Some(disr)\n@@ -1290,12 +1303,13 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                                  ast_generics: &hir::Generics,\n                                                  trait_predicates: &ty::GenericPredicates<'tcx>,\n                                                  self_trait_ref: ty::TraitRef<'tcx>,\n-                                                 trait_items: &[hir::TraitItem])\n+                                                 trait_item_refs: &[hir::TraitItemRef])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n-        trait_items.iter().flat_map(|trait_item| {\n+        trait_item_refs.iter().flat_map(|trait_item_ref| {\n+            let trait_item = ccx.tcx.map.trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n-                hir::TypeTraitItem(ref bounds, _) => bounds,\n+                hir::TraitItemKind::Type(ref bounds, _) => bounds,\n                 _ => {\n                     return vec![].into_iter();\n                 }\n@@ -1363,7 +1377,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let ast_generics = match node {\n             NodeTraitItem(item) => {\n                 match item.node {\n-                    MethodTraitItem(ref sig, _) => &sig.generics,\n+                    TraitItemKind::Method(ref sig, _) => &sig.generics,\n                     _ => &no_generics\n                 }\n             }\n@@ -1420,7 +1434,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeForeignItem(item) => {\n                 match item.node {\n                     ForeignItemStatic(..) => &no_generics,\n-                    ForeignItemFn(_, ref generics) => generics\n+                    ForeignItemFn(_, _, ref generics) => generics\n                 }\n             }\n \n@@ -1521,9 +1535,9 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n                         ccx.icx(&()).to_ty(&StaticRscope::new(&ccx.tcx), &t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, body) => {\n                         let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                          Some(AnonTypeScope::new(def_id)));\n+                                                          body, Some(AnonTypeScope::new(def_id)));\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n@@ -1563,7 +1577,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let abi = ccx.tcx.map.get_foreign_abi(node_id);\n \n                 match foreign_item.node {\n-                    ForeignItemFn(ref fn_decl, ref generics) => {\n+                    ForeignItemFn(ref fn_decl, _, ref generics) => {\n                         compute_type_of_foreign_fn_decl(\n                             ccx, ccx.tcx.map.local_def_id(foreign_item.id),\n                             fn_decl, generics, abi)\n@@ -1628,7 +1642,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n-        hir::ForeignItemFn(_, ref generics) => generics,\n+        hir::ForeignItemFn(_, _, ref generics) => generics,\n         hir::ForeignItemStatic(..) => &no_generics\n     };\n \n@@ -2058,13 +2072,13 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                 ccx.tcx.sess.struct_span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty)))\n+                                       ccx.tcx.map.node_to_pretty_string(ast_ty.id)))\n                     .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n         };\n         for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n-            check(&input.ty, ty)\n+            check(&input, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n             check(&ty, output)"}, {"sha": "d3b671f2a4d6e05ee026dd921176c9cbb4bf6ae8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -3866,45 +3866,6 @@ extern \"platform-intrinsic\" {\n ```\n \"##,\n \n-E0513: r##\"\n-The type of the variable couldn't be found out.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0513\n-use std::mem;\n-\n-unsafe {\n-    let size = mem::size_of::<u32>();\n-    mem::transmute_copy::<u32, [u8; size]>(&8_8);\n-    // error: no type for local variable\n-}\n-```\n-\n-To fix this error, please use a constant size instead of `size`. To make\n-this error more obvious, you could run:\n-\n-```compile_fail,E0080\n-use std::mem;\n-\n-unsafe {\n-    mem::transmute_copy::<u32, [u8; mem::size_of::<u32>()]>(&8_8);\n-    // error: constant evaluation error\n-}\n-```\n-\n-So now, you can fix your code by setting the size directly:\n-\n-```\n-use std::mem;\n-\n-unsafe {\n-    mem::transmute_copy::<u32, [u8; 4]>(&8_8);\n-    // `u32` is 4 bytes so we replace the `mem::size_of` call with its size\n-}\n-```\n-\"##,\n-\n E0516: r##\"\n The `typeof` keyword is currently reserved but unimplemented.\n Erroneous code example:"}, {"sha": "ce495e6fb4cd8a8cc689a4bcdb54e888e5cebf59", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -87,6 +87,8 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) { }\n+\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n "}, {"sha": "3f5e443a20a6854b575a7a57fdf197102483da43", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n@@ -19,7 +20,10 @@ use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct ElisionFailureInfo {\n-    pub name: String,\n+    /// Where we can find the argument pattern.\n+    pub parent: Option<hir::BodyId>,\n+    /// The index of the argument in the original definition.\n+    pub index: usize,\n     pub lifetime_count: usize,\n     pub have_bound_regions: bool\n }"}, {"sha": "507079a4f874cd93e017458416e75fd1c644695b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -120,6 +120,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "d4d3edbcb126e8732f82b03d5ef4e1718a2a758f", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -258,6 +258,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}, {"sha": "cba5e1ba6f3184b2f928ce29ed60d915ff5c4726", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -10,19 +10,18 @@\n \n //! Support for inlining external documentation into the current AST.\n \n+use std::collections::BTreeMap;\n+use std::io;\n use std::iter::once;\n \n use syntax::ast;\n use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::print as pprust;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n-use rustc_const_eval::lookup_const_by_id;\n-\n use core::{DocContext, DocAccessLevels};\n use doctree;\n use clean::{self, GetDefId};\n@@ -345,8 +344,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n                 let default = if item.defaultness.has_value() {\n-                    Some(pprust::expr_to_string(\n-                        lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n+                    Some(print_inlined_const(cx, item.def_id))\n                 } else {\n                     None\n                 };\n@@ -476,17 +474,33 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n     }\n }\n \n-fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n-    let (expr, ty) = lookup_const_by_id(cx.tcx, did, None).unwrap_or_else(|| {\n-        panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n-    });\n-    debug!(\"converting constant expr {:?} to snippet\", expr);\n-    let sn = pprust::expr_to_string(expr);\n-    debug!(\"got snippet {}\", sn);\n+struct InlinedConst {\n+    nested_bodies: BTreeMap<hir::BodyId, hir::Body>\n+}\n+\n+impl hir::print::PpAnn for InlinedConst {\n+    fn nested(&self, state: &mut hir::print::State, nested: hir::print::Nested)\n+              -> io::Result<()> {\n+        if let hir::print::Nested::Body(body) = nested {\n+            state.print_expr(&self.nested_bodies[&body].value)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n \n+fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n+    let body = cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap();\n+    let inlined = InlinedConst {\n+        nested_bodies: cx.tcx.sess.cstore.item_body_nested_bodies(did)\n+    };\n+    hir::print::to_string(&inlined, |s| s.print_expr(&body.value))\n+}\n+\n+fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| cx.tcx.item_type(did).clean(cx)),\n-        expr: sn\n+        type_: cx.tcx.item_type(did).clean(cx),\n+        expr: print_inlined_const(cx, did)\n     }\n }\n "}, {"sha": "3b8281980696d74db037d65b52d3238ec444a7c0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 94, "deletions": 81, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -32,7 +32,6 @@ use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n@@ -1030,22 +1029,14 @@ pub struct Method {\n     pub abi: Abi,\n }\n \n-impl Clean<Method> for hir::MethodSig {\n+impl<'a> Clean<Method> for (&'a hir::MethodSig, hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let decl = FnDecl {\n-            inputs: Arguments {\n-                values: self.decl.inputs.clean(cx),\n-            },\n-            output: self.decl.output.clean(cx),\n-            variadic: false,\n-            attrs: Attributes::default()\n-        };\n         Method {\n-            generics: self.generics.clean(cx),\n-            unsafety: self.unsafety,\n-            constness: self.constness,\n-            decl: decl,\n-            abi: self.abi\n+            generics: self.0.generics.clean(cx),\n+            unsafety: self.0.unsafety,\n+            constness: self.0.constness,\n+            decl: (&*self.0.decl, self.1).clean(cx),\n+            abi: self.0.abi\n         }\n     }\n }\n@@ -1058,25 +1049,6 @@ pub struct TyMethod {\n     pub abi: Abi,\n }\n \n-impl Clean<TyMethod> for hir::MethodSig {\n-    fn clean(&self, cx: &DocContext) -> TyMethod {\n-        let decl = FnDecl {\n-            inputs: Arguments {\n-                values: self.decl.inputs.clean(cx),\n-            },\n-            output: self.decl.output.clean(cx),\n-            variadic: false,\n-            attrs: Attributes::default()\n-        };\n-        TyMethod {\n-            unsafety: self.unsafety.clone(),\n-            decl: decl,\n-            generics: self.generics.clean(cx),\n-            abi: self.abi\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n@@ -1097,7 +1069,7 @@ impl Clean<Item> for doctree::Function {\n             deprecation: self.depr.clean(cx),\n             def_id: cx.tcx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n-                decl: self.decl.clean(cx),\n+                decl: (&self.decl, self.body).clean(cx),\n                 generics: self.generics.clean(cx),\n                 unsafety: self.unsafety,\n                 constness: self.constness,\n@@ -1130,14 +1102,47 @@ pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n \n-impl Clean<FnDecl> for hir::FnDecl {\n+impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], &'a [Spanned<ast::Name>]) {\n+    fn clean(&self, cx: &DocContext) -> Arguments {\n+        Arguments {\n+            values: self.0.iter().enumerate().map(|(i, ty)| {\n+                let mut name = self.1.get(i).map(|n| n.node.to_string())\n+                                            .unwrap_or(String::new());\n+                if name.is_empty() {\n+                    name = \"_\".to_string();\n+                }\n+                Argument {\n+                    name: name,\n+                    type_: ty.clean(cx),\n+                }\n+            }).collect()\n+        }\n+    }\n+}\n+\n+impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], hir::BodyId) {\n+    fn clean(&self, cx: &DocContext) -> Arguments {\n+        let body = cx.tcx.map.body(self.1);\n+\n+        Arguments {\n+            values: self.0.iter().enumerate().map(|(i, ty)| {\n+                Argument {\n+                    name: name_from_pat(&body.arguments[i].pat),\n+                    type_: ty.clean(cx),\n+                }\n+            }).collect()\n+        }\n+    }\n+}\n+\n+impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n+    where (&'a [P<hir::Ty>], A): Clean<Arguments>\n+{\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         FnDecl {\n-            inputs: Arguments {\n-                values: self.inputs.clean(cx),\n-            },\n-            output: self.output.clean(cx),\n-            variadic: self.variadic,\n+            inputs: (&self.0.inputs[..], self.1).clean(cx),\n+            output: self.0.output.clean(cx),\n+            variadic: self.0.variadic,\n             attrs: Attributes::default()\n         }\n     }\n@@ -1159,7 +1164,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n                 values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n-                        id: ast::CRATE_NODE_ID,\n                         name: names.next().map_or(\"\".to_string(), |name| name.to_string()),\n                     }\n                 }).collect(),\n@@ -1172,7 +1176,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n-    pub id: ast::NodeId,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n@@ -1184,26 +1187,17 @@ pub enum SelfTy {\n \n impl Argument {\n     pub fn to_self(&self) -> Option<SelfTy> {\n-        if self.name == \"self\" {\n-            match self.type_ {\n-                Infer => Some(SelfValue),\n-                BorrowedRef{ref lifetime, mutability, ref type_} if **type_ == Infer => {\n-                    Some(SelfBorrowed(lifetime.clone(), mutability))\n-                }\n-                _ => Some(SelfExplicit(self.type_.clone()))\n-            }\n-        } else {\n-            None\n+        if self.name != \"self\" {\n+            return None;\n         }\n-    }\n-}\n-\n-impl Clean<Argument> for hir::Arg {\n-    fn clean(&self, cx: &DocContext) -> Argument {\n-        Argument {\n-            name: name_from_pat(&*self.pat),\n-            type_: (self.ty.clean(cx)),\n-            id: self.id\n+        if self.type_.is_self_type() {\n+            return Some(SelfValue);\n+        }\n+        match self.type_ {\n+            BorrowedRef{ref lifetime, mutability, ref type_} if type_.is_self_type() => {\n+                Some(SelfBorrowed(lifetime.clone(), mutability))\n+            }\n+            _ => Some(SelfExplicit(self.type_.clone()))\n         }\n     }\n }\n@@ -1269,17 +1263,22 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n impl Clean<Item> for hir::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ConstTraitItem(ref ty, ref default) => {\n+            hir::TraitItemKind::Const(ref ty, default) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    default.as_ref().map(|e| pprust::expr_to_string(&e)))\n+                                    default.map(|e| print_const_expr(cx, e)))\n             }\n-            hir::MethodTraitItem(ref sig, Some(_)) => {\n-                MethodItem(sig.clean(cx))\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                MethodItem((sig, body).clean(cx))\n             }\n-            hir::MethodTraitItem(ref sig, None) => {\n-                TyMethodItem(sig.clean(cx))\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref names)) => {\n+                TyMethodItem(TyMethod {\n+                    unsafety: sig.unsafety.clone(),\n+                    decl: (&*sig.decl, &names[..]).clean(cx),\n+                    generics: sig.generics.clean(cx),\n+                    abi: sig.abi\n+                })\n             }\n-            hir::TypeTraitItem(ref bounds, ref default) => {\n+            hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n@@ -1299,12 +1298,12 @@ impl Clean<Item> for hir::TraitItem {\n impl Clean<Item> for hir::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ImplItemKind::Const(ref ty, ref expr) => {\n+            hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    Some(pprust::expr_to_string(expr)))\n+                                    Some(print_const_expr(cx, expr)))\n             }\n-            hir::ImplItemKind::Method(ref sig, _) => {\n-                MethodItem(sig.clean(cx))\n+            hir::ImplItemKind::Method(ref sig, body) => {\n+                MethodItem((sig, body).clean(cx))\n             }\n             hir::ImplItemKind::Type(ref ty) => TypedefItem(Typedef {\n                 type_: ty.clean(cx),\n@@ -1353,11 +1352,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     };\n                     let self_arg_ty = *fty.sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n-                        decl.inputs.values[0].type_ = Infer;\n+                        decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n                     } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n                         if mt.ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n-                                BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                                BorrowedRef{ref mut type_, ..} => {\n+                                    **type_ = Generic(String::from(\"Self\"))\n+                                }\n                                 _ => unreachable!(),\n                             }\n                         }\n@@ -1568,6 +1569,13 @@ impl Type {\n             _ => false,\n         }\n     }\n+\n+    pub fn is_self_type(&self) -> bool {\n+        match *self {\n+            Generic(ref name) => name == \"Self\",\n+            _ => false\n+        }\n+    }\n }\n \n impl GetDefId for Type {\n@@ -1677,11 +1685,12 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n-            TyArray(ref ty, ref e) => {\n+            TyArray(ref ty, e) => {\n                 use rustc_const_math::{ConstInt, ConstUsize};\n                 use rustc_const_eval::eval_const_expr;\n                 use rustc::middle::const_val::ConstVal;\n \n+                let e = &cx.tcx.map.body(e).value;\n                 let n = match eval_const_expr(cx.tcx, e) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => match u {\n                         ConstUsize::Us16(u) => u.to_string(),\n@@ -2332,7 +2341,7 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n                 type_params: Vec::new(),\n                 where_predicates: Vec::new()\n             },\n-            decl: self.decl.clean(cx),\n+            decl: (&*self.decl, &[][..]).clean(cx),\n             abi: self.abi,\n         }\n     }\n@@ -2362,7 +2371,7 @@ impl Clean<Item> for doctree::Static {\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability.clean(cx),\n-                expr: pprust::expr_to_string(&self.expr),\n+                expr: print_const_expr(cx, self.expr),\n             }),\n         }\n     }\n@@ -2386,7 +2395,7 @@ impl Clean<Item> for doctree::Constant {\n             deprecation: self.depr.clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n-                expr: pprust::expr_to_string(&self.expr),\n+                expr: print_const_expr(cx, self.expr),\n             }),\n         }\n     }\n@@ -2630,9 +2639,9 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n impl Clean<Item> for hir::ForeignItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ForeignItemFn(ref decl, ref generics) => {\n+            hir::ForeignItemFn(ref decl, ref names, ref generics) => {\n                 ForeignFunctionItem(Function {\n-                    decl: decl.clean(cx),\n+                    decl: (&**decl, &names[..]).clean(cx),\n                     generics: generics.clean(cx),\n                     unsafety: hir::Unsafety::Unsafe,\n                     abi: Abi::Rust,\n@@ -2714,6 +2723,10 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n+fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n+    cx.tcx.map.node_to_pretty_string(body.node_id)\n+}\n+\n /// Given a type Path, resolve it to a Type using the TyCtxt\n fn resolve_type(cx: &DocContext,\n                 path: Path,"}, {"sha": "d819268240badca941579c315ac882df1194bcd0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -156,6 +156,7 @@ pub struct Function {\n     pub whence: Span,\n     pub generics: hir::Generics,\n     pub abi: abi::Abi,\n+    pub body: hir::BodyId,\n }\n \n pub struct Typedef {\n@@ -174,7 +175,7 @@ pub struct Typedef {\n pub struct Static {\n     pub type_: P<hir::Ty>,\n     pub mutability: hir::Mutability,\n-    pub expr: P<hir::Expr>,\n+    pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n@@ -186,7 +187,7 @@ pub struct Static {\n \n pub struct Constant {\n     pub type_: P<hir::Ty>,\n-    pub expr: P<hir::Expr>,\n+    pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,"}, {"sha": "c242eea2362170206e7e33efeb84e2367d184e09", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -502,7 +502,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n         let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n-            hir::print::ty_to_string(ty)\n+            self.map.node_to_pretty_string(ty.id)\n         } else {\n             item.name.to_string()\n         };"}, {"sha": "b0afc3d63f47932a0bc805092e48eff4ab3af833", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -157,7 +157,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     unsafety: &hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: &abi::Abi,\n-                    gen: &hir::Generics) -> Function {\n+                    gen: &hir::Generics,\n+                    body: hir::BodyId) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n@@ -172,6 +173,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             unsafety: *unsafety,\n             constness: constness,\n             abi: *abi,\n+            body: body,\n         }\n     }\n \n@@ -410,9 +412,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n             hir::ItemUnion(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n-            hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, _) =>\n+            hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, body) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n-                                          constness, abi, gen)),\n+                                          constness, abi, gen, body)),\n             hir::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),\n@@ -456,11 +458,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.constants.push(s);\n             },\n-            hir::ItemTrait(unsafety, ref gen, ref b, ref items) => {\n+            hir::ItemTrait(unsafety, ref gen, ref b, ref item_ids) => {\n+                let items = item_ids.iter()\n+                                    .map(|ti| self.cx.tcx.map.trait_item(ti.id).clone())\n+                                    .collect();\n                 let t = Trait {\n                     unsafety: unsafety,\n                     name: name,\n-                    items: items.clone(),\n+                    items: items,\n                     generics: gen.clone(),\n                     bounds: b.iter().cloned().collect(),\n                     id: item.id,"}, {"sha": "f72985fd91a3ea1702e42221ccb864433522fc49", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1471,12 +1471,13 @@ impl Arg {\n     }\n \n     pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n+        let span = mk_sp(eself.span.lo, eself_ident.span.hi);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n-            span: DUMMY_SP,\n+            span: span,\n         });\n-        let arg = |mutbl, ty, span| Arg {\n+        let arg = |mutbl, ty| Arg {\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n@@ -1486,15 +1487,13 @@ impl Arg {\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => {\n-                arg(mutbl, ty, mk_sp(eself.span.lo, eself_ident.span.hi))\n-            }\n-            SelfKind::Value(mutbl) => arg(mutbl, infer_ty, eself.span),\n+            SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n+            SelfKind::Value(mutbl) => arg(mutbl, infer_ty),\n             SelfKind::Region(lt, mutbl) => arg(Mutability::Immutable, P(Ty {\n                 id: DUMMY_NODE_ID,\n                 node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n-                span: DUMMY_SP,\n-            }), eself.span),\n+                span: span,\n+            })),\n         }\n     }\n }"}, {"sha": "726e23265241dac4f6ac35e5c78113466dafffbb", "filename": "src/test/compile-fail/E0513.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417/src%2Ftest%2Fcompile-fail%2FE0513.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417/src%2Ftest%2Fcompile-fail%2FE0513.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0513.rs?ref=02b22ec7bd8fa542dd3b08a8497ad5cd3a20c417", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-\n-fn main() {\n-    unsafe {\n-        let size = mem::size_of::<u32>();\n-        mem::transmute_copy::<u32, [u8; size]>(&8_8); //~ ERROR E0513\n-                                                      //~| NOTE no type for variable\n-    }\n-}"}, {"sha": "7c3f7a1d574f99fea3df47f3b596ba8f4ad3a9e0", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -25,8 +25,10 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array = [4; <A as Foo>::Y]; //~ ERROR E0080\n-                                     //~| non-constant path in constant\n+    let _array = [4; <A as Foo>::Y];\n+    //~^ ERROR cannot use an outer type parameter in this context [E0402]\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "dcf87d5f0fc44b97585cd070cc9f54ceab7fa4e6", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -26,7 +26,9 @@ impl Foo for Def {\n \n pub fn test<A: Foo, B: Foo>() {\n     let _array: [u32; <A as Foo>::Y];\n-    //~^ ERROR the trait bound `A: Foo` is not satisfied\n+    //~^ ERROR cannot use an outer type parameter in this context [E0402]\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "36382e776ce281fe4f4182303e2f2e52e291270f", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -34,9 +34,11 @@ struct WontChange {\n mod signatures {\n     use WillChange;\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path\n     trait Bar {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n         fn do_something(x: WillChange);\n     }\n "}, {"sha": "4cc15e8b522ac7add81492663a36395c325d2c06", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -35,8 +35,9 @@ enum Enum {\n     Variant2(i32)\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n trait Trait {\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     fn method(&self, _: TypeAlias);\n }\n "}, {"sha": "eac134ff3cc7d6b287cf83a34ca4c67862897d20", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -14,8 +14,8 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    fn bar(\n-        self\n+    fn bar(self:\n+           Foo<'b,'a>\n     //~^ ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n@@ -24,7 +24,7 @@ impl<'a,'b> Foo<'a,'b> {\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n-            : Foo<'b,'a>) {}\n+           ) {}\n }\n \n fn main() {}"}, {"sha": "f80135848e0c10fe4f8de3139b715a58fd4f82c3", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -16,6 +16,4 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `S`\n     //~| expected usize, found struct `S`\n-    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n-    //~| expected `usize`\n }"}, {"sha": "691d8d31b412d1c3934d8cbf2f7da2cff49b1788", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -12,8 +12,8 @@\n \n fn main() {\n     fn bar(n: isize) {\n-        // FIXME (#24414): This error message needs improvement.\n         let _x: [isize; n];\n-        //~^ ERROR no type for local variable\n+        //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n+        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "f4769a78587280494ea4bab4f91ca3784317f148", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -13,8 +13,9 @@\n fn main() {\n     fn bar(n: usize) {\n         let _x = [0; n];\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n-        //~| NOTE `n` is a variable\n+        //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n+        //~| NOTE non-constant used with constant\n+        //~| NOTE unresolved path in constant expression\n+        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "a716f3e29d488ce62adf8503f769b5deb70f6361", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -13,43 +13,30 @@\n fn main() {\n     let n = 1;\n     let a = [0; n];\n-    //~^ ERROR constant evaluation error\n-    //~| non-constant path in constant expression\n+    //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n     let b = [0; ()];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `()`\n     //~| expected usize, found ()\n-    //~| ERROR expected `usize` for repeat count, found tuple [E0306]\n-    //~| expected `usize`\n     let c = [0; true];\n     //~^ ERROR mismatched types\n     //~| expected usize, found bool\n-    //~| ERROR expected `usize` for repeat count, found boolean [E0306]\n-    //~| expected `usize`\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `{float}`\n     //~| expected usize, found floating-point variable\n-    //~| ERROR expected `usize` for repeat count, found float [E0306]\n-    //~| expected `usize`\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `&'static str`\n     //~| expected usize, found reference\n-    //~| ERROR expected `usize` for repeat count, found string literal [E0306]\n-    //~| expected `usize`\n     let f = [0; -4_isize];\n-    //~^ ERROR constant evaluation error\n-    //~| expected usize, found isize\n-    //~| ERROR mismatched types\n+    //~^ ERROR mismatched types\n     //~| expected usize, found isize\n     let f = [0_usize; -1_isize];\n-    //~^ ERROR constant evaluation error\n-    //~| expected usize, found isize\n-    //~| ERROR mismatched types\n+    //~^ ERROR mismatched types\n     //~| expected usize, found isize\n     struct G {\n         g: (),\n@@ -59,6 +46,4 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `main::G`\n     //~| expected usize, found struct `main::G`\n-    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n-    //~| expected `usize`\n }"}, {"sha": "28e85c94b664ce47882d2559402eeea53f64f259", "filename": "src/test/incremental/hashes/consts.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -66,8 +66,10 @@ const CONST_CHANGE_TYPE_2: Option<u64> = None;\n const CONST_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_1: i16 = 2;\n@@ -78,8 +80,10 @@ const CONST_CHANGE_VALUE_1: i16 = 2;\n const CONST_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n@@ -89,8 +93,10 @@ const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n const CONST_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n@@ -100,8 +106,10 @@ const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 4;"}, {"sha": "da3a953d11eaa883367ebcdedcca038947c44a7f", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -108,8 +108,10 @@ enum EnumChangeValueCStyleVariant0 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant0 {\n@@ -126,6 +128,8 @@ enum EnumChangeValueCStyleVariant1 {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant1 {"}, {"sha": "7c6da3ba9fea6030f7d88d0628862c3f3c1be10e", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -119,9 +119,11 @@ static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n static STATIC_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_1: i16 = 2;\n \n@@ -131,9 +133,11 @@ static STATIC_CHANGE_VALUE_1: i16 = 2;\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n \n@@ -142,9 +146,11 @@ static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n static STATIC_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n \n@@ -153,9 +159,11 @@ static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n "}, {"sha": "bc401ae93404f0a45e099b022e781654715d5e2b", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 151, "deletions": 29, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -98,11 +98,15 @@ trait TraitAddReturnType {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddReturnType {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method() -> u32;\n }\n \n@@ -115,11 +119,15 @@ trait TraitChangeReturnType {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeReturnType {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method() -> u64;\n }\n \n@@ -132,11 +140,15 @@ trait TraitAddParameterToMethod {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddParameterToMethod {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(a: u32);\n }\n \n@@ -146,15 +158,29 @@ trait TraitAddParameterToMethod {\n #[cfg(cfail1)]\n trait TraitChangeMethodParameterName {\n     fn method(a: u32);\n+    fn with_default(x: i32) {}\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterName {\n+    // FIXME(#38501) This should preferably always be clean.\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(b: u32);\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn with_default(y: i32) {}\n }\n \n \n@@ -166,11 +192,15 @@ trait TraitChangeMethodParameterType {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterType {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(a: i64);\n }\n \n@@ -183,11 +213,15 @@ trait TraitChangeMethodParameterTypeRef {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterTypeRef {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(a: &mut i32);\n }\n \n@@ -200,11 +234,15 @@ trait TraitChangeMethodParametersOrder {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParametersOrder {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(b: i64, a: i32);\n }\n \n@@ -253,11 +291,15 @@ trait TraitChangeModeSelfRefToMut {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfRefToMut {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(&mut self);\n }\n \n@@ -269,11 +311,15 @@ trait TraitChangeModeSelfOwnToMut: Sized {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToMut: Sized {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(mut self) {}\n }\n \n@@ -285,11 +331,15 @@ trait TraitChangeModeSelfOwnToRef {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToRef {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(&self);\n }\n \n@@ -302,11 +352,15 @@ trait TraitAddUnsafeModifier {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddUnsafeModifier {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     unsafe fn method();\n }\n \n@@ -319,11 +373,15 @@ trait TraitAddExternModifier {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddExternModifier {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern fn method();\n }\n \n@@ -336,11 +394,15 @@ trait TraitChangeExternCToRustIntrinsic {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeExternCToRustIntrinsic {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern \"rust-intrinsic\" fn method();\n }\n \n@@ -353,11 +415,15 @@ trait TraitAddTypeParameterToMethod {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddTypeParameterToMethod {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<T>();\n }\n \n@@ -370,11 +436,15 @@ trait TraitAddLifetimeParameterToMethod {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddLifetimeParameterToMethod {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<'a>();\n }\n \n@@ -391,11 +461,15 @@ trait TraitAddTraitBoundToMethodTypeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddTraitBoundToMethodTypeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<T: ReferencedTrait0>();\n }\n \n@@ -408,11 +482,15 @@ trait TraitAddBuiltinBoundToMethodTypeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddBuiltinBoundToMethodTypeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<T: Sized>();\n }\n \n@@ -425,11 +503,15 @@ trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<'a, 'b: 'a>(a: &'a u32, b: &'b u32);\n }\n \n@@ -442,11 +524,15 @@ trait TraitAddSecondTraitBoundToMethodTypeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondTraitBoundToMethodTypeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<T: ReferencedTrait0 + ReferencedTrait1>();\n }\n \n@@ -459,11 +545,15 @@ trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<T: Sized + Sync>();\n }\n \n@@ -476,11 +566,15 @@ trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<'a, 'b, 'c: 'a + 'b>(a: &'a u32, b: &'b u32, c: &'c u32);\n }\n \n@@ -514,11 +608,15 @@ trait TraitAddTraitBoundToAssociatedType {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddTraitBoundToAssociatedType {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type Associated: ReferencedTrait0;\n \n     fn mathod();\n@@ -535,11 +633,15 @@ trait TraitAddLifetimeBoundToAssociatedType<'a> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddLifetimeBoundToAssociatedType<'a> {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type Associated: 'a;\n \n     fn mathod();\n@@ -617,11 +719,15 @@ trait TraitChangeTypeOfAssociatedConstant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeTypeOfAssociatedConstant {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     const Value: f64;\n \n     fn mathod();\n@@ -1013,11 +1119,15 @@ mod change_return_type_of_method_indirectly_use {\n     #[cfg(not(cfail1))]\n     use super::ReferenceType1 as ReturnType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeReturnType {\n+        #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+        #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         fn method() -> ReturnType;\n     }\n }\n@@ -1031,11 +1141,15 @@ mod change_method_parameter_type_indirectly_by_use {\n     #[cfg(not(cfail1))]\n     use super::ReferenceType1 as ArgType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeArgType {\n+        #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+        #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         fn method(a: ArgType);\n     }\n }\n@@ -1049,11 +1163,15 @@ mod change_method_parameter_type_bound_indirectly_by_use {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait1 as Bound;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeBoundOfMethodTypeParameter {\n+        #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+        #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         fn method<T: Bound>(a: T);\n     }\n }\n@@ -1068,11 +1186,15 @@ mod change_method_parameter_type_bound_indirectly_by_use_where {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait1 as Bound;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeBoundOfMethodTypeParameterWhere {\n+        #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+        #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         fn method<T>(a: T) where T: Bound;\n     }\n }"}, {"sha": "8651a67bae221e88a5d4e9a3e24347b259b27d6a", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -23,14 +23,14 @@ fn main() { }\n mod x {\n     #[cfg(rpass1)]\n     pub fn x() {\n-        println!(\"1\");\n+        println!(\"{}\", \"1\");\n     }\n \n     #[cfg(rpass2)]\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n     pub fn x() {\n-        println!(\"2\");\n+        println!(\"{}\", \"2\");\n     }\n }\n "}, {"sha": "b0491fe6e27fd44e7a1e01950641dcdfeb96ebaf", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1,15 +1,15 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt \"];\n+    N2[label=\"stmt fn inner(x: isize) -> isize { x + x }\"];\n     N3[label=\"expr inner\"];\n     N4[label=\"expr inner\"];\n     N5[label=\"expr 18\"];\n     N6[label=\"expr inner(18)\"];\n     N7[label=\"expr inner(inner(18))\"];\n     N8[label=\"stmt inner(inner(18));\"];\n-    N9[label=\"block { inner(inner(18)); }\"];\n-    N10[label=\"expr { inner(inner(18)); }\"];\n+    N9[label=\"block {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n+    N10[label=\"expr {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "223978c3d7634f7380960dc81d32f2c8eadda422", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1,8 +1,8 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt \"];\n-    N3[label=\"stmt \"];\n+    N2[label=\"stmt struct S19 {\\l    x: isize,\\l}\\l\"];\n+    N3[label=\"stmt impl S19 {\\l    fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l}\\l\"];\n     N4[label=\"expr 19\"];\n     N5[label=\"expr S19{x: 19,}\"];\n     N6[label=\"local s\"];\n@@ -11,8 +11,8 @@ digraph block {\n     N9[label=\"expr s.inner()\"];\n     N10[label=\"expr s.inner().inner()\"];\n     N11[label=\"stmt s.inner().inner();\"];\n-    N12[label=\"block { let s = S19{x: 19,}; s.inner().inner(); }\"];\n-    N13[label=\"expr { let s = S19{x: 19,}; s.inner().inner(); }\"];\n+    N12[label=\"block {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n+    N13[label=\"expr {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "fae134986872e06cac70ff4f8d22f1fb05e6bb01", "filename": "src/test/run-make/pretty-print-path-suffix/foo_method.pp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -12,5 +12,6 @@\n \n \n \n-fn foo_method(&self) -> &'static str { return \"i am very similar to foo.\"; }\n-/* nest::{{impl}}::foo_method */\n+fn foo_method(self: &Self)\n+ -> &'static str { return \"i am very similar to foo.\"; } /*\n+nest::{{impl}}::foo_method */"}, {"sha": "e1b1b441894b75eeeb087697d8e658a51b1a522c", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -41,12 +41,12 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_fn(&mut self, cx: &LateContext,\n-                              fk: FnKind, _: &hir::FnDecl, expr: &hir::Expr,\n+                              fk: FnKind, _: &hir::FnDecl, body: &hir::Body,\n                               span: Span, node: ast::NodeId)\n     {\n         if let FnKind::Closure(..) = fk { return }\n \n-        let mut extent = cx.tcx.region_maps.node_extent(expr.id);\n+        let mut extent = cx.tcx.region_maps.node_extent(body.value.id);\n         while let Some(parent) = cx.tcx.region_maps.opt_encl_scope(extent) {\n             extent = parent;\n         }"}, {"sha": "58f66c1358437132e9236fb7a0c6b3e677bcd297", "filename": "src/test/ui/span/mut-arg-hint.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ecc85beb339aa8089d936e450b0d800bdf580ae/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr?ref=4ecc85beb339aa8089d936e450b0d800bdf580ae", "patch": "@@ -1,11 +1,3 @@\n-error: cannot borrow immutable borrowed content `*a` as mutable\n-  --> $DIR/mut-arg-hint.rs:13:9\n-   |\n-12 |     fn foo(mut a: &String) {\n-   |                   ------- use `&mut String` here to make mutable\n-13 |         a.push_str(\"bar\");\n-   |         ^\n-\n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:18:5\n    |\n@@ -14,6 +6,14 @@ error: cannot borrow immutable borrowed content `*a` as mutable\n 18 |     a.push_str(\"foo\");\n    |     ^\n \n+error: cannot borrow immutable borrowed content `*a` as mutable\n+  --> $DIR/mut-arg-hint.rs:13:9\n+   |\n+12 |     fn foo(mut a: &String) {\n+   |                   ------- use `&mut String` here to make mutable\n+13 |         a.push_str(\"bar\");\n+   |         ^\n+\n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:25:9\n    |"}]}