{"sha": "b734abcbaeaec78828d00596c008d05d6c03c1b3", "node_id": "C_kwDOAAsO6NoAKGI3MzRhYmNiYWVhZWM3ODgyOGQwMDU5NmMwMDhkMDVkNmMwM2MxYjM", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2022-01-24T12:13:29Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2022-01-24T12:16:05Z"}, "message": "Handle unstability as well, including \"field typo suggestions\"", "tree": {"sha": "32b023169ccc0ab1793a97c234ea19b561a6bd07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32b023169ccc0ab1793a97c234ea19b561a6bd07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b734abcbaeaec78828d00596c008d05d6c03c1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b734abcbaeaec78828d00596c008d05d6c03c1b3", "html_url": "https://github.com/rust-lang/rust/commit/b734abcbaeaec78828d00596c008d05d6c03c1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b734abcbaeaec78828d00596c008d05d6c03c1b3/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32ab0b88f4248c612cb795d1f02d0030e30f57b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/32ab0b88f4248c612cb795d1f02d0030e30f57b5", "html_url": "https://github.com/rust-lang/rust/commit/32ab0b88f4248c612cb795d1f02d0030e30f57b5"}], "stats": {"total": 40, "additions": 31, "deletions": 9}, "files": [{"sha": "2cad8aab29ec9b48809cf56ffc379c7bca0eee56", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b734abcbaeaec78828d00596c008d05d6c03c1b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b734abcbaeaec78828d00596c008d05d6c03c1b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b734abcbaeaec78828d00596c008d05d6c03c1b3", "patch": "@@ -35,6 +35,7 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n+use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n@@ -1720,9 +1721,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => {\n                 // prevent all specified fields from being suggested\n                 let skip_fields = skip_fields.iter().map(|x| x.ident.name);\n-                if let Some(field_name) =\n-                    Self::suggest_field_name(variant, field.ident.name, skip_fields.collect())\n-                {\n+                if let Some(field_name) = self.suggest_field_name(\n+                    variant,\n+                    field.ident.name,\n+                    skip_fields.collect(),\n+                    expr_span,\n+                ) {\n                     err.span_suggestion(\n                         field.ident.span,\n                         \"a field with a similar name exists\",\n@@ -1743,7 +1747,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     format!(\"`{}` does not have this field\", ty),\n                                 );\n                             }\n-                            let available_field_names = self.available_field_names(variant);\n+                            let available_field_names =\n+                                self.available_field_names(variant, expr_span);\n                             if !available_field_names.is_empty() {\n                                 err.note(&format!(\n                                     \"available fields are: {}\",\n@@ -1759,19 +1764,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    // Return an hint about the closest match in field names\n+    // Return a hint about the closest match in field names\n     fn suggest_field_name(\n+        &self,\n         variant: &'tcx ty::VariantDef,\n         field: Symbol,\n         skip: Vec<Symbol>,\n+        // The span where stability will be checked\n+        span: Span,\n     ) -> Option<Symbol> {\n         let names = variant\n             .fields\n             .iter()\n             .filter_map(|field| {\n                 // ignore already set fields and private fields from non-local crates\n+                // and unstable fields.\n                 if skip.iter().any(|&x| x == field.name)\n                     || (!variant.def_id.is_local() && !field.vis.is_public())\n+                    || matches!(\n+                        self.tcx.eval_stability(field.did, None, span, None),\n+                        stability::EvalResult::Deny { .. }\n+                    )\n                 {\n                     None\n                 } else {\n@@ -1783,7 +1796,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         find_best_match_for_name(&names, field, None)\n     }\n \n-    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<Symbol> {\n+    fn available_field_names(\n+        &self,\n+        variant: &'tcx ty::VariantDef,\n+        access_span: Span,\n+    ) -> Vec<Symbol> {\n         variant\n             .fields\n             .iter()\n@@ -1793,6 +1810,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .adjust_ident_and_get_scope(field.ident(self.tcx), variant.def_id, self.body_id)\n                     .1;\n                 field.vis.is_accessible_from(def_scope, self.tcx)\n+                    && !matches!(\n+                        self.tcx.eval_stability(field.did, None, access_span, None),\n+                        stability::EvalResult::Deny { .. }\n+                    )\n             })\n             .filter(|field| !self.tcx.is_doc_hidden(field.did))\n             .map(|field| field.name)\n@@ -1959,7 +1980,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.suggest_first_deref_field(&mut err, expr, base, field);\n             }\n             ty::Adt(def, _) if !def.is_enum() => {\n-                self.suggest_fields_on_recordish(&mut err, def, field);\n+                self.suggest_fields_on_recordish(&mut err, def, field, expr.span);\n             }\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n@@ -2122,9 +2143,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         def: &'tcx ty::AdtDef,\n         field: Ident,\n+        access_span: Span,\n     ) {\n         if let Some(suggested_field_name) =\n-            Self::suggest_field_name(def.non_enum_variant(), field.name, vec![])\n+            self.suggest_field_name(def.non_enum_variant(), field.name, vec![], access_span)\n         {\n             err.span_suggestion(\n                 field.span,\n@@ -2135,7 +2157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             err.span_label(field.span, \"unknown field\");\n             let struct_variant_def = def.non_enum_variant();\n-            let field_names = self.available_field_names(struct_variant_def);\n+            let field_names = self.available_field_names(struct_variant_def, access_span);\n             if !field_names.is_empty() {\n                 err.note(&format!(\n                     \"available fields are: {}\","}]}