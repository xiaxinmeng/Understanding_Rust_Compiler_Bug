{"sha": "8b679551047da1f50574c8e377e46e5c511ee321", "node_id": "C_kwDOAAsO6NoAKDhiNjc5NTUxMDQ3ZGExZjUwNTc0YzhlMzc3ZTQ2ZTVjNTExZWUzMjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-11T11:55:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-11T11:55:44Z"}, "message": "Rollup merge of #108950 - cjgillot:inherit-less, r=compiler-errors\n\nDirectly construct Inherited in typeck.\n\nUsing `InheritedBuilder` + a closure does not seem necessary any more.\n\n+ a few opportunistic simplifications to typeck entry point.", "tree": {"sha": "5dcb162d42cc2ecd41197ec8b54fd2a2b6383022", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dcb162d42cc2ecd41197ec8b54fd2a2b6383022"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b679551047da1f50574c8e377e46e5c511ee321", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDGxACRBK7hj4Ov3rIwAA4RwIAI0beuuu1o0NdwULBrNht5G3\n/uPkewGEIE2dVU5Ux1oRXI89/eERcO9dBbbV2FJBCN74iPe7H36CFumhvzuy+m36\n+HwDS5KxYktls2adh/qxAF/ihgQdfHk6uAFp5lzD8NNRJMOT0NMqTop34kTpPh/c\n/H8dinIMHfQBXb5f96ZMhkBNHXv45aqAUQjF2+dBE3y/b/n0CIAuOfaPdPVmXRJL\n0nyeZRNFyxQu/eUB1RRBtsiOlOh+YvN9Fspnsn3/3zNL7dP7A27Aeku7CzI8Tign\n3lhn8eJjp8QMx2SxiKO2itKFMzVqqSSwJLupwbE3i4o8gQfiy3dJf6BggDBNI5k=\n=xtRr\n-----END PGP SIGNATURE-----\n", "payload": "tree 5dcb162d42cc2ecd41197ec8b54fd2a2b6383022\nparent d4754edc2802da85bf9ed269aae45dafca01de9d\nparent 391ef47d8a8322fab1aede78bed4b5e7493ff15e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678535744 +0100\ncommitter GitHub <noreply@github.com> 1678535744 +0100\n\nRollup merge of #108950 - cjgillot:inherit-less, r=compiler-errors\n\nDirectly construct Inherited in typeck.\n\nUsing `InheritedBuilder` + a closure does not seem necessary any more.\n\n+ a few opportunistic simplifications to typeck entry point.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b679551047da1f50574c8e377e46e5c511ee321", "html_url": "https://github.com/rust-lang/rust/commit/8b679551047da1f50574c8e377e46e5c511ee321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b679551047da1f50574c8e377e46e5c511ee321/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4754edc2802da85bf9ed269aae45dafca01de9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4754edc2802da85bf9ed269aae45dafca01de9d", "html_url": "https://github.com/rust-lang/rust/commit/d4754edc2802da85bf9ed269aae45dafca01de9d"}, {"sha": "391ef47d8a8322fab1aede78bed4b5e7493ff15e", "url": "https://api.github.com/repos/rust-lang/rust/commits/391ef47d8a8322fab1aede78bed4b5e7493ff15e", "html_url": "https://github.com/rust-lang/rust/commit/391ef47d8a8322fab1aede78bed4b5e7493ff15e"}], "stats": {"total": 338, "additions": 154, "deletions": 184}, "files": [{"sha": "4110b176b41b1f8f6bc8726abf81f6df98140bc2", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8b679551047da1f50574c8e377e46e5c511ee321/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b679551047da1f50574c8e377e46e5c511ee321/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=8b679551047da1f50574c8e377e46e5c511ee321", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -73,40 +72,16 @@ impl<'tcx> Deref for Inherited<'tcx> {\n     }\n }\n \n-/// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `typeck_results`\n-/// without using `Rc` or something similar.\n-pub struct InheritedBuilder<'tcx> {\n-    infcx: infer::InferCtxtBuilder<'tcx>,\n-    typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n-}\n-\n impl<'tcx> Inherited<'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n-        InheritedBuilder {\n-            infcx: tcx\n-                .infer_ctxt()\n-                .ignoring_regions()\n-                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)),\n-            typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(mut self, f: F) -> R\n-    where\n-        F: FnOnce(&Inherited<'tcx>) -> R,\n-    {\n-        f(&Inherited::new(self.infcx.build(), self.typeck_results))\n-    }\n-}\n-\n-impl<'tcx> Inherited<'tcx> {\n-    fn new(infcx: InferCtxt<'tcx>, typeck_results: RefCell<ty::TypeckResults<'tcx>>) -> Self {\n-        let tcx = infcx.tcx;\n+        let infcx = tcx\n+            .infer_ctxt()\n+            .ignoring_regions()\n+            .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n+            .build();\n+        let typeck_results = RefCell::new(ty::TypeckResults::new(hir_owner));\n \n         Inherited {\n             typeck_results,"}, {"sha": "70124a77364063cabdc588366b36135f1a7204ed", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 115, "deletions": 119, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/8b679551047da1f50574c8e377e46e5c511ee321/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b679551047da1f50574c8e377e46e5c511ee321/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=8b679551047da1f50574c8e377e46e5c511ee321", "patch": "@@ -45,13 +45,14 @@ mod rvalue_scopes;\n mod upvar;\n mod writeback;\n \n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use fn_ctxt::FnCtxt;\n+pub use inherited::Inherited;\n \n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n+use crate::diverges::Diverges;\n+use crate::expectation::Expectation;\n+use crate::fn_ctxt::RawTy;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{\n@@ -105,10 +106,9 @@ pub struct LocalTy<'tcx> {\n /// (notably closures), `typeck_results(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n+    node: Node<'_>,\n ) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n+    match node {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n                 Some((body, Some(ty), None))\n@@ -142,8 +142,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n \n     if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n+        primary_body_of(tcx.hir().get_by_def_id(def_id)).is_some()\n     } else {\n         false\n     }\n@@ -198,143 +197,140 @@ fn typeck_with_fallback<'tcx>(\n     }\n \n     let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+    let (body_id, body_ty, fn_sig) = primary_body_of(node).unwrap_or_else(|| {\n         span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n-            param_env.without_const()\n+    let param_env = tcx.param_env(def_id);\n+    let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+        param_env.without_const()\n+    } else {\n+        param_env\n+    };\n+    let inh = Inherited::new(tcx, def_id);\n+    let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n+\n+    if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+            fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n         } else {\n-            param_env\n+            tcx.fn_sig(def_id).subst_identity()\n         };\n-        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n-\n-        if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id).subst_identity()\n-            };\n \n-            check_abi(tcx, id, span, fn_sig.abi());\n+        check_abi(tcx, id, span, fn_sig.abi());\n \n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = fcx.normalize(body.value.span, fn_sig);\n+        // Compute the function signature from point of view of inside the fn.\n+        let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+        let fn_sig = fcx.normalize(body.value.span, fn_sig);\n \n-            check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n-        } else {\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty =\n-                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                });\n-                            operand_ty.unwrap_or_else(fallback)\n+        check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n+    } else {\n+        let expected_type = if let Some(&hir::Ty { kind: hir::TyKind::Infer, span, .. }) = body_ty {\n+            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            }))\n+        } else if let Node::AnonConst(_) = node {\n+            match tcx.hir().get(tcx.hir().parent_id(id)) {\n+                Node::Expr(&hir::Expr {\n+                    kind: hir::ExprKind::ConstBlock(ref anon_const), ..\n+                }) if anon_const.hir_id == id => Some(fcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                })),\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n+                    if anon_const.hir_id == id =>\n+                {\n+                    Some(fcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    }))\n+                }\n+                Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                    asm.operands.iter().find_map(|(op, _op_sp)| match op {\n+                        hir::InlineAsmOperand::Const { anon_const } if anon_const.hir_id == id => {\n+                            // Inline assembly constants must be integers.\n+                            Some(fcx.next_int_var())\n+                        }\n+                        hir::InlineAsmOperand::SymFn { anon_const } if anon_const.hir_id == id => {\n+                            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                kind: TypeVariableOriginKind::MiscVariable,\n+                                span,\n+                            }))\n                         }\n-                        _ => fallback(),\n-                    },\n-                    _ => fallback(),\n-                });\n+                        _ => None,\n+                    })\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        };\n+        let expected_type = expected_type.unwrap_or_else(fallback);\n \n-            let expected_type = fcx.normalize(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+        let expected_type = fcx.normalize(body.value.span, expected_type);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        // Gather locals in statics (because of block expressions).\n+        GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n \n-            fcx.write_ty(id, expected_type);\n-        };\n+        fcx.write_ty(id, expected_type);\n+    };\n \n-        fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(|_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n+    fcx.type_inference_fallback();\n+\n+    // Even though coercion casts provide type hints, we check casts after fallback for\n+    // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+    fcx.check_casts();\n+    fcx.select_obligations_where_possible(|_| {});\n+\n+    // Closure and generator analysis may run after fallback\n+    // because they don't constrain other type variables.\n+    // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+    let prev_constness = fcx.param_env.constness();\n+    fcx.param_env = fcx.param_env.without_const();\n+    fcx.closure_analyze(body);\n+    fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+    assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+    // Before the generator analysis, temporary scopes shall be marked to provide more\n+    // precise information on types to be captured.\n+    fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+\n+    for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+        let ty = fcx.normalize(span, ty);\n+        fcx.require_type_is_sized(ty, span, code);\n+    }\n \n-        fcx.select_obligations_where_possible(|_| {});\n+    fcx.select_obligations_where_possible(|_| {});\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        // This must be the last thing before `report_ambiguity_errors`.\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n+    // This must be the last thing before `report_ambiguity_errors`.\n+    fcx.resolve_generator_interiors(def_id.to_def_id());\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.report_ambiguity_errors();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.report_ambiguity_errors();\n+    }\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.check_transmutes();\n+    }\n \n-        fcx.check_asms();\n+    fcx.check_asms();\n \n-        fcx.infcx.skip_region_resolution();\n+    fcx.infcx.skip_region_resolution();\n \n-        fcx.resolve_type_vars_in_body(body)\n-    });\n+    let typeck_results = fcx.resolve_type_vars_in_body(body);\n \n     // Consistency check our TypeckResults instance can hold all ItemLocalIds\n     // it will need to hold."}, {"sha": "4c4c003ca469122825ba59a3500beed1a81aac25", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b679551047da1f50574c8e377e46e5c511ee321/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b679551047da1f50574c8e377e46e5c511ee321/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=8b679551047da1f50574c8e377e46e5c511ee321", "patch": "@@ -369,10 +369,10 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n             Node::Item(item) => {\n                 if let ItemKind::Fn(_, _, body_id) = &item.kind\n                 && let output_ty = return_ty(cx, item.owner_id)\n-                && Inherited::build(cx.tcx, item.owner_id.def_id).enter(|inherited| {\n-                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, item.owner_id.def_id);\n-                    fn_ctxt.can_coerce(ty, output_ty)\n-                }) {\n+                && let inherited = Inherited::new(cx.tcx, item.owner_id.def_id)\n+                && let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.owner_id.def_id)\n+                && fn_ctxt.can_coerce(ty, output_ty)\n+                {\n                     if has_lifetime(output_ty) && has_lifetime(ty) {\n                         return false;\n                     }"}, {"sha": "62efd13b8d909a072232c40757ccd6e9b91de0b4", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8b679551047da1f50574c8e377e46e5c511ee321/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b679551047da1f50574c8e377e46e5c511ee321/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=8b679551047da1f50574c8e377e46e5c511ee321", "patch": "@@ -33,38 +33,37 @@ pub(super) fn check_cast<'tcx>(\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner.def_id;\n \n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, local_def_id);\n+    let inherited = Inherited::new(cx.tcx, local_def_id);\n+    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, local_def_id);\n \n-        // If we already have errors, we can't be sure we can pointer cast.\n+    // If we already have errors, we can't be sure we can pointer cast.\n+    assert!(\n+        !fn_ctxt.errors_reported_since_creation(),\n+        \"Newly created FnCtxt contained errors\"\n+    );\n+\n+    if let Ok(check) = cast::CastCheck::new(\n+        &fn_ctxt,\n+        e,\n+        from_ty,\n+        to_ty,\n+        // We won't show any error to the user, so we don't care what the span is here.\n+        DUMMY_SP,\n+        DUMMY_SP,\n+        hir::Constness::NotConst,\n+    ) {\n+        let res = check.do_check(&fn_ctxt);\n+\n+        // do_check's documentation says that it might return Ok and create\n+        // errors in the fcx instead of returning Err in some cases. Those cases\n+        // should be filtered out before getting here.\n         assert!(\n             !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n+            \"`fn_ctxt` contained errors after cast check!\"\n         );\n \n-        if let Ok(check) = cast::CastCheck::new(\n-            &fn_ctxt,\n-            e,\n-            from_ty,\n-            to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP,\n-            DUMMY_SP,\n-            hir::Constness::NotConst,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returning Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n+        res.ok()\n+    } else {\n+        None\n+    }\n }"}]}