{"sha": "d46ed5d3333770ac490d587878d708c3be17f137", "node_id": "C_kwDOAAsO6NoAKGQ0NmVkNWQzMzMzNzcwYWM0OTBkNTg3ODc4ZDcwOGMzYmUxN2YxMzc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-01-21T02:25:26Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-01-21T03:38:43Z"}, "message": "Clarify some code relating to interning and types.\n\nI have found this code very confusing at times. This commit clarifies\nthings.\n\nIn particular, the commit explains the requirements that the `Borrow`\nimpls put on the `Eq` and `Hash` impls, which are non-obvious. And it\nputs the `Borrow` impls first, since they force `Eq` and `Hash` to have\nparticular forms.\n\nThe commit also notes `TyS`'s uniqueness requirements.", "tree": {"sha": "ca5a49864ef94b036dd8c482082ab447cb2d2251", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca5a49864ef94b036dd8c482082ab447cb2d2251"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46ed5d3333770ac490d587878d708c3be17f137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46ed5d3333770ac490d587878d708c3be17f137", "html_url": "https://github.com/rust-lang/rust/commit/d46ed5d3333770ac490d587878d708c3be17f137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46ed5d3333770ac490d587878d708c3be17f137/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c55819ae606046e2a7b6b92c3f0821bd171f34b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55819ae606046e2a7b6b92c3f0821bd171f34b0", "html_url": "https://github.com/rust-lang/rust/commit/c55819ae606046e2a7b6b92c3f0821bd171f34b0"}], "stats": {"total": 81, "additions": 57, "deletions": 24}, "files": [{"sha": "7b7c5fa2436ae0d0fc3192f30fee9198adab13c1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d46ed5d3333770ac490d587878d708c3be17f137/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46ed5d3333770ac490d587878d708c3be17f137/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d46ed5d3333770ac490d587878d708c3be17f137", "patch": "@@ -1946,24 +1946,37 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// An entry in an interner.\n+// This type holds a `T` in the interner. The `T` is stored in the arena and\n+// this type just holds a pointer to it, but it still effectively owns it. It\n+// impls `Borrow` so that it can be looked up using the original\n+// (non-arena-memory-owning) types.\n struct Interned<'tcx, T: ?Sized>(&'tcx T);\n \n impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n     fn clone(&self) -> Self {\n         Interned(self.0)\n     }\n }\n+\n impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n \n impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n     fn into_pointer(&self) -> *const () {\n         self.0 as *const _ as *const ()\n     }\n }\n-// N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n+        &self.0.kind()\n+    }\n+}\n+\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n+        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n+        // `x == y`.\n         self.0.kind() == other.0.kind()\n     }\n }\n@@ -1972,19 +1985,21 @@ impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n \n impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind().hash(s)\n     }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind()\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n+        &self.0.kind\n     }\n }\n-// N.B., an `Interned<PredicateInner>` compares and hashes as a `PredicateKind`.\n+\n impl<'tcx> PartialEq for Interned<'tcx, PredicateInner<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, PredicateInner<'tcx>>) -> bool {\n+        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n+        // `x == y`.\n         self.0.kind == other.0.kind\n     }\n }\n@@ -1993,19 +2008,21 @@ impl<'tcx> Eq for Interned<'tcx, PredicateInner<'tcx>> {}\n \n impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind.hash(s)\n     }\n }\n \n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n-        &self.0.kind\n+impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n+    fn borrow<'a>(&'a self) -> &'a [T] {\n+        &self.0[..]\n     }\n }\n \n-// N.B., an `Interned<List<T>>` compares and hashes as its elements.\n impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n     fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n+        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n+        // `x == y`.\n         self.0[..] == other.0[..]\n     }\n }\n@@ -2014,20 +2031,23 @@ impl<'tcx, T: Eq> Eq for Interned<'tcx, List<T>> {}\n \n impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0[..].hash(s)\n     }\n }\n \n-impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n-    fn borrow<'a>(&'a self) -> &'a [T] {\n-        &self.0[..]\n-    }\n-}\n-\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n-        $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n+        $(impl<'tcx> Borrow<$ty> for Interned<'tcx, $ty> {\n+            fn borrow<'a>(&'a self) -> &'a $ty {\n+                &self.0\n+            }\n+        }\n+\n+        impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n+                // The `Borrow` trait requires that `x.borrow() == y.borrow()`\n+                // equals `x == y`.\n                 self.0 == other.0\n             }\n         }\n@@ -2036,16 +2056,12 @@ macro_rules! direct_interners {\n \n         impl<'tcx> Hash for Interned<'tcx, $ty> {\n             fn hash<H: Hasher>(&self, s: &mut H) {\n+                // The `Borrow` trait requires that `x.borrow().hash(s) ==\n+                // x.hash(s)`.\n                 self.0.hash(s)\n             }\n         }\n \n-        impl<'tcx> Borrow<$ty> for Interned<'tcx, $ty> {\n-            fn borrow<'a>(&'a self) -> &'a $ty {\n-                &self.0\n-            }\n-        }\n-\n         impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: $ty) -> &'tcx $ty {\n                 self.interners.$name.intern(v, |v| {"}, {"sha": "00af16e79842cadfb550e9b1b216d75f6d515789", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d46ed5d3333770ac490d587878d708c3be17f137/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46ed5d3333770ac490d587878d708c3be17f137/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d46ed5d3333770ac490d587878d708c3be17f137", "patch": "@@ -376,15 +376,28 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n+/// Represents a type.\n+///\n+/// IMPORTANT: Every `TyS` is *required* to have unique contents. The type's\n+/// correctness relies on this, *but it does not enforce it*. Therefore, any\n+/// code that creates a `TyS` must ensure uniqueness itself. In practice this\n+/// is achieved by interning.\n #[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n     /// Use `TyS::kind()` instead.\n     kind: TyKind<'tcx>,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n     /// This field shouldn't be used directly and may be removed in the future.\n     /// Use `TyS::flags()` instead.\n     flags: TypeFlags,\n \n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n     /// This is a kind of confusing thing: it stores the smallest\n     /// binder such that\n     ///\n@@ -436,13 +449,17 @@ impl<'tcx> PartialOrd for TyS<'tcx> {\n impl<'tcx> PartialEq for TyS<'tcx> {\n     #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n+        // Pointer equality implies equality (due to the unique contents\n+        // assumption).\n         ptr::eq(self, other)\n     }\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n impl<'tcx> Hash for TyS<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient (due to the unique contents\n+        // assumption).\n         (self as *const TyS<'_>).hash(s)\n     }\n }"}]}