{"sha": "c623d21e388315df672951fcb8efb5000923ab3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MjNkMjFlMzg4MzE1ZGY2NzI5NTFmY2I4ZWZiNTAwMDkyM2FiM2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-15T05:50:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-28T00:42:09Z"}, "message": "Introduce lifetime declarations into the lists of type parameters.\n\nMajor changes are:\n- replace ~[ty_param] with Generics structure, which includes\n  both OptVec<TyParam> and OptVec<Lifetime>;\n- the use of syntax::opt_vec to avoid allocation for empty lists;\n\ncc #4846", "tree": {"sha": "8c7116e7df304166ccafcc30b21c19bf30788f75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c7116e7df304166ccafcc30b21c19bf30788f75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c623d21e388315df672951fcb8efb5000923ab3d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c623d21e388315df672951fcb8efb5000923ab3d", "html_url": "https://github.com/rust-lang/rust/commit/c623d21e388315df672951fcb8efb5000923ab3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c623d21e388315df672951fcb8efb5000923ab3d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "061a2237230d3abcdb30ecb8987e5de17e67a58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/061a2237230d3abcdb30ecb8987e5de17e67a58e", "html_url": "https://github.com/rust-lang/rust/commit/061a2237230d3abcdb30ecb8987e5de17e67a58e"}], "stats": {"total": 1786, "additions": 1067, "deletions": 719}, "files": [{"sha": "22333f236ed8ea7f450b19141a16a302e8cdc0cc", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -200,14 +200,14 @@ fn is_bench_fn(i: @ast::item) -> bool {\n         vec::len(attr::find_attrs_by_name(i.attrs, ~\"bench\")) > 0u;\n \n     fn has_test_signature(i: @ast::item) -> bool {\n-        match /*bad*/copy i.node {\n-            ast::item_fn(decl, _, tps, _) => {\n+        match i.node {\n+            ast::item_fn(ref decl, _, ref generics, _) => {\n                 let input_cnt = vec::len(decl.inputs);\n                 let no_output = match decl.output.node {\n                     ast::ty_nil => true,\n                     _ => false\n                 };\n-                let tparm_cnt = vec::len(tps);\n+                let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n                 input_cnt == 1u"}, {"sha": "95973aaaf90ada25a577b42a588c6c4c3980d113", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -49,6 +49,8 @@ use syntax::diagnostic::span_handler;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n use syntax;\n use writer = std::ebml::writer;\n \n@@ -187,10 +189,11 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                            params: &[ty_param]) {\n+fn encode_type_param_bounds(ebml_w: writer::Encoder,\n+                            ecx: @EncodeContext,\n+                            params: &OptVec<TyParam>) {\n     let ty_param_bounds =\n-        @params.map(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n+        @params.map_to_vec(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n@@ -265,7 +268,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                             id: node_id, variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n-                            ty_params: &[ty_param]) {\n+                            generics: &ast::Generics) {\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n@@ -281,7 +284,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                     node_id_to_type(ecx.tcx, variant.node.id));\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args)\n-                    if args.len() > 0 && ty_params.len() == 0 => {\n+                    if args.len() > 0 && generics.ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n             ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) |\n@@ -292,7 +295,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, ty_params);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_path(ecx, ebml_w, path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n@@ -465,14 +468,18 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @EncodeContext, ebml_w: writer::Encoder,\n-                        id: node_id, ident: ident, path: &[ast_map::path_elt],\n-                        item: Option<inlined_item>, tps: &[ty_param]) {\n+fn encode_info_for_ctor(ecx: @EncodeContext,\n+                        ebml_w: writer::Encoder,\n+                        id: node_id,\n+                        ident: ident,\n+                        path: &[ast_map::path_elt],\n+                        item: Option<inlined_item>,\n+                        generics: &ast::Generics) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n         encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n                *ecx.tcx.sess.str_of(ident),\n@@ -518,9 +525,12 @@ fn encode_info_for_method(ecx: @EncodeContext,\n                           should_inline: bool,\n                           parent_id: node_id,\n                           m: @method,\n-                          +all_tps: ~[ty_param]) {\n-    debug!(\"encode_info_for_method: %d %s %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident), all_tps.len());\n+                          owner_generics: &ast::Generics,\n+                          method_generics: &ast::Generics) {\n+    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n+           *ecx.tcx.sess.str_of(m.ident),\n+           owner_generics.ty_params.len(),\n+           method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     match m.self_ty.node {\n@@ -529,8 +539,13 @@ fn encode_info_for_method(ecx: @EncodeContext,\n         }\n         _ => encode_family(ebml_w, purity_fn_family(m.purity))\n     }\n-    let len = all_tps.len();\n-    encode_type_param_bounds(ebml_w, ecx, all_tps);\n+\n+    let mut combined_ty_params = opt_vec::Empty;\n+    combined_ty_params.push_all(&owner_generics.ty_params);\n+    combined_ty_params.push_all(&method_generics.ty_params);\n+    let len = combined_ty_params.len();\n+    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n@@ -604,13 +619,13 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_fn(_, purity, tps, _) => {\n+      item_fn(_, purity, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        let tps_len = tps.len();\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        let tps_len = generics.ty_params.len();\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n@@ -634,24 +649,24 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_ty(_, tps) => {\n+      item_ty(_, ref generics) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(ref enum_definition, ref tps) => {\n+      item_enum(ref enum_definition, ref generics) => {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, *tps);\n+            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ecx, ebml_w, item.ident);\n             for (*enum_definition).variants.each |v| {\n@@ -667,9 +682,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                  (*enum_definition).variants,\n                                  path,\n                                  index,\n-                                 *tps);\n+                                 generics);\n       }\n-      item_struct(struct_def, tps) => {\n+      item_struct(struct_def, ref generics) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -686,24 +701,25 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                    *ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n                                path,\n-                               if tps.len() > 0u {\n+                               if generics.ty_params.len() > 0u {\n                                    Some(ii_dtor(copy *dtor,\n                                                 item.ident,\n-                                                copy tps,\n+                                                copy *generics,\n                                                 local_def(item.id))) }\n                                else {\n                                    None\n                                },\n-                               tps);\n+                               generics);\n         }\n \n         /* Index the class*/\n         add_to_index();\n+\n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'S');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n \n         // If this is a tuple- or enum-like struct, encode the type of the\n@@ -759,13 +775,13 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, opt_trait, ty, methods) => {\n+      item_impl(ref generics, opt_trait, ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -797,18 +813,18 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                                    should_inline(m.attrs),\n                                    item.id, *m,\n-                                   vec::append(/*bad*/copy tps, m.tps));\n+                                   generics, &m.generics);\n         }\n       }\n-      item_trait(ref tps, ref traits, ref ms) => {\n+      item_trait(ref generics, ref traits, ref ms) => {\n         let provided_methods = dvec::DVec();\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, *tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -820,7 +836,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_def_id(ebml_w, local_def((*ty_m).id));\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx,\n-                                         (*ty_m).tps);\n+                                         &ty_m.generics.ty_params);\n                 encode_type(ecx, ebml_w,\n                             ty::mk_bare_fn(tcx, copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n@@ -834,7 +850,8 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, m.tps);\n+                encode_type_param_bounds(ebml_w, ecx,\n+                                         &m.generics.ty_params);\n                 encode_type(ecx, ebml_w,\n                             ty::mk_bare_fn(tcx, copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n@@ -880,8 +897,14 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         // Finally, output all the provided methods as items.\n         for provided_methods.each |m| {\n             index.push(entry { val: m.id, pos: ebml_w.writer.tell() });\n+\n+            // We do not concatenate the generics of the owning impl and that\n+            // of provided methods.  I am not sure why this is. -ndm\n+            let owner_generics = ast_util::empty_generics();\n+\n             encode_info_for_method(ecx, ebml_w, /*bad*/copy path,\n-                                   true, item.id, *m, /*bad*/copy m.tps);\n+                                   true, item.id, *m,\n+                                   &owner_generics, &m.generics);\n         }\n       }\n       item_mac(*) => fail!(~\"item macros unimplemented\")\n@@ -898,11 +921,11 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n-    match /*bad*/copy nitem.node {\n-      foreign_item_fn(_, purity, tps) => {\n+    match nitem.node {\n+      foreign_item_fn(_, purity, ref generics) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));"}, {"sha": "58433cec2725dd4d44f49619944df438c6019a14", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -371,10 +371,10 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n+      ast::ii_dtor(ref dtor, nm, ref generics, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n-        let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n-        let new_params = fold::fold_ty_params(/*bad*/copy *tps, fld);\n+        let dtor_attrs = fld.fold_attributes(copy dtor.node.attrs);\n+        let new_generics = fold::fold_generics(generics, fld);\n         let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n@@ -386,7 +386,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n                                           body: dtor_body },\n                 .. (/*bad*/copy *dtor)\n             },\n-            nm, new_params, new_parent)\n+            nm, new_generics, new_parent)\n       }\n      }\n }"}, {"sha": "eb418d0cd5acb1e3d5ba5cda0189057a50b36ee7", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -753,7 +753,7 @@ fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n-                       decl: ast::fn_decl) {\n+                        decl: ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -786,9 +786,9 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n       if attr::foreign_abi(it.attrs) !=\n             either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n-            match /*bad*/copy ni.node {\n-              ast::foreign_item_fn(decl, _, _) => {\n-                check_foreign_fn(cx, it.id, decl);\n+            match ni.node {\n+              ast::foreign_item_fn(ref decl, _, _) => {\n+                check_foreign_fn(cx, it.id, *decl);\n               }\n               // FIXME #4622: Not implemented.\n               ast::foreign_item_const(*) => {}"}, {"sha": "19accd25c12c31c2f8b2c238d310ff9a907efc11", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -621,7 +621,8 @@ pub fn determine_rp_in_fn(fk: visit::fn_kind,\n             }\n         }\n         (visitor.visit_ty)(decl.output, cx, visitor);\n-        (visitor.visit_ty_params)(visit::tps_of_fn(fk), cx, visitor);\n+        let generics = visit::generics_of_fn(fk);\n+        (visitor.visit_generics)(&generics, cx, visitor);\n         (visitor.visit_block)(body, cx, visitor);\n     }\n }"}, {"sha": "2b0263a47365a515c1606b19e72e155599009857", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 63, "deletions": 68, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -42,6 +42,7 @@ use syntax::ast::{enum_variant_kind, expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_fn_block, expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n+use syntax::ast::{Generics};\n use syntax::ast::{gt, ident, impure_fn, inherited, item, item_struct};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n@@ -53,9 +54,9 @@ use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_dtor, struct_field, struct_variant_kind, sty_by_ref};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n-use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param, ty_path};\n+use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, TyParam, ty_path};\n use syntax::ast::{ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8, ty_uint};\n-use syntax::ast::{type_value_ns, ty_param_bound, unnamed_field};\n+use syntax::ast::{type_value_ns, unnamed_field};\n use syntax::ast::{variant, view_item, view_item_extern_mod};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n@@ -73,6 +74,8 @@ use syntax::visit::{default_visitor, fk_method, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n use managed::ptr_eq;\n use dvec::DVec;\n@@ -216,9 +219,9 @@ pub impl<T> ResolveResult<T> {\n }\n \n pub enum TypeParameters/& {\n-    NoTypeParameters,               //< No type parameters.\n-    HasTypeParameters(&~[ty_param], //< Type parameters.\n-                      node_id,      //< ID of the enclosing item\n+    NoTypeParameters,              //< No type parameters.\n+    HasTypeParameters(&Generics,   //< Type parameters.\n+                      node_id,     //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n                       // This is zero if this is the outermost set of type\n@@ -231,7 +234,6 @@ pub enum TypeParameters/& {\n                       //\n                       // The index at the method site will be 1, because the\n                       // outer T had index 0.\n-\n                       uint,\n \n                       // The kind of the rib used for type parameters.\n@@ -1500,14 +1502,15 @@ pub impl Resolver {\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n-        match /*bad*/copy foreign_item.node {\n-            foreign_item_fn(_, _, type_parameters) => {\n+        match foreign_item.node {\n+            foreign_item_fn(_, _, ref generics) => {\n                 let def = def_fn(local_def(foreign_item.id), unsafe_fn);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, foreign_item.id,\n-                                           0, NormalRibKind)) {\n+                do self.with_type_parameter_rib(\n+                    HasTypeParameters(\n+                        generics, foreign_item.id, 0, NormalRibKind))\n+                {\n                     visit_foreign_item(foreign_item, new_parent, visitor);\n                 }\n             }\n@@ -3582,8 +3585,7 @@ pub impl Resolver {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n-            item_enum(ref enum_def, ref type_parameters) => {\n-\n+            item_enum(ref enum_def, ref generics) => {\n                 for (*enum_def).variants.each() |variant| {\n                     do variant.node.disr_expr.iter() |dis_expr| {\n                         // resolve the discriminator expr\n@@ -3599,35 +3601,35 @@ pub impl Resolver {\n                 // error if there is one? -- tjc\n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n-                        type_parameters, item.id, 0, NormalRibKind)) {\n+                        generics, item.id, 0, NormalRibKind)) {\n                     visit_item(item, (), visitor);\n                 }\n             }\n \n-            item_ty(_, type_parameters) => {\n+            item_ty(_, ref generics) => {\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0,\n+                        (HasTypeParameters(generics, item.id, 0,\n                                            NormalRibKind))\n                         || {\n \n                     visit_item(item, (), visitor);\n                 }\n             }\n \n-            item_impl(type_parameters,\n+            item_impl(ref generics,\n                       implemented_traits,\n                       self_type,\n-                      methods) => {\n+                      ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             item.span,\n-                                            type_parameters,\n+                                            generics,\n                                             implemented_traits,\n                                             self_type,\n-                                            methods,\n+                                            *methods,\n                                             visitor);\n             }\n \n-            item_trait(ref type_parameters, ref traits, ref methods) => {\n+            item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -3636,10 +3638,10 @@ pub impl Resolver {\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(type_parameters, item.id, 0,\n+                        (HasTypeParameters(generics, item.id, 0,\n                                            NormalRibKind)) {\n \n-                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                    self.resolve_type_parameters(&generics.ty_params,\n                                                  visitor);\n \n                     // Resolve derived traits.\n@@ -3672,18 +3674,18 @@ pub impl Resolver {\n                         match *method {\n                           required(ref ty_m) => {\n                             do self.with_type_parameter_rib\n-                                (HasTypeParameters(&(*ty_m).tps,\n+                                (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n-                                                   type_parameters.len(),\n+                                                   generics.ty_params.len(),\n                                         MethodRibKind(item.id, Required))) {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n                                 self.resolve_type_parameters(\n-                                    /*bad*/copy (*ty_m).tps,\n+                                    &ty_m.generics.ty_params,\n                                     visitor);\n \n-                                for (*ty_m).decl.inputs.each |argument| {\n+                                for ty_m.decl.inputs.each |argument| {\n                                     self.resolve_type(argument.ty, visitor);\n                                 }\n \n@@ -3694,7 +3696,7 @@ pub impl Resolver {\n                               self.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n                                                   m,\n-                                                  type_parameters.len(),\n+                                                  generics.ty_params.len(),\n                                                   visitor)\n                           }\n                         }\n@@ -3704,12 +3706,12 @@ pub impl Resolver {\n                 (*self.type_ribs).pop();\n             }\n \n-            item_struct(struct_def, ty_params) => {\n+            item_struct(struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n-                                   @copy ty_params,\n-                                   /*bad*/copy struct_def.fields,\n-                                   struct_def.dtor,\n-                                   visitor);\n+                                    generics,\n+                                    struct_def.fields,\n+                                    struct_def.dtor,\n+                                    visitor);\n             }\n \n             item_mod(module_) => {\n@@ -3722,18 +3724,14 @@ pub impl Resolver {\n             item_foreign_mod(foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n-                        match /*bad*/copy foreign_item.node {\n-                            foreign_item_fn(_, _, type_parameters) => {\n-                                do self.with_type_parameter_rib\n-                                    (HasTypeParameters(&type_parameters,\n-                                                       foreign_item.id,\n-                                                       0,\n-                                                       OpaqueFunctionRibKind))\n-                                        || {\n-\n-                                    visit_foreign_item(*foreign_item, (),\n-                                                       visitor);\n-                                }\n+                        match foreign_item.node {\n+                            foreign_item_fn(_, _, ref generics) => {\n+                                self.with_type_parameter_rib(\n+                                    HasTypeParameters(\n+                                        generics, foreign_item.id, 0,\n+                                        NormalRibKind),\n+                                    || visit_foreign_item(*foreign_item, (),\n+                                                          visitor));\n                             }\n                             foreign_item_const(_) => {\n                                 visit_foreign_item(*foreign_item, (),\n@@ -3744,7 +3742,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            item_fn(ref fn_decl, _, ref ty_params, ref block) => {\n+            item_fn(ref fn_decl, _, ref generics, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 // FIXME #4404 android JNI hacks\n@@ -3771,7 +3769,7 @@ pub impl Resolver {\n                 self.resolve_function(OpaqueFunctionRibKind,\n                                       Some(@/*bad*/copy *fn_decl),\n                                       HasTypeParameters\n-                                        (ty_params,\n+                                        (generics,\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n@@ -3798,13 +3796,13 @@ pub impl Resolver {\n                                type_parameters: TypeParameters,\n                                f: fn()) {\n         match type_parameters {\n-            HasTypeParameters(type_parameters, node_id, initial_index,\n+            HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n \n                 let function_type_rib = @Rib(rib_kind);\n-                (*self.type_ribs).push(function_type_rib);\n+                self.type_ribs.push(function_type_rib);\n \n-                for (*type_parameters).eachi |index, type_parameter| {\n+                for generics.ty_params.eachi |index, type_parameter| {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n@@ -3815,7 +3813,7 @@ pub impl Resolver {\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n                                     def_typaram_binder(node_id));\n-                    (*function_type_rib).bindings.insert(name, def_like);\n+                    function_type_rib.bindings.insert(name, def_like);\n                 }\n             }\n \n@@ -3828,7 +3826,7 @@ pub impl Resolver {\n \n         match type_parameters {\n             HasTypeParameters(*) => {\n-                (*self.type_ribs).pop();\n+                self.type_ribs.pop();\n             }\n \n             NoTypeParameters => {\n@@ -3871,8 +3869,8 @@ pub impl Resolver {\n                 NoTypeParameters => {\n                     // Continue.\n                 }\n-                HasTypeParameters(type_parameters, _, _, _) => {\n-                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                HasTypeParameters(ref generics, _, _, _) => {\n+                    self.resolve_type_parameters(&generics.ty_params,\n                                                  visitor);\n                 }\n             }\n@@ -3927,7 +3925,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_type_parameters(@mut self,\n-                               type_parameters: ~[ty_param],\n+                               type_parameters: &OptVec<TyParam>,\n                                visitor: ResolveVisitor) {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n@@ -3941,19 +3939,17 @@ pub impl Resolver {\n \n     fn resolve_struct(@mut self,\n                       id: node_id,\n-                      type_parameters: @~[ty_param],\n-                      fields: ~[@struct_field],\n+                      generics: &Generics,\n+                      fields: &[@struct_field],\n                       optional_destructor: Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n-        let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0,\n+                                        (generics, id, 0,\n                                          OpaqueFunctionRibKind)) {\n \n             // Resolve the type parameters.\n-            self.resolve_type_parameters(/*bad*/copy *type_parameters,\n-                                         visitor);\n+            self.resolve_type_parameters(&generics.ty_params, visitor);\n \n             // Resolve fields.\n             for fields.each |field| {\n@@ -3986,9 +3982,9 @@ pub impl Resolver {\n                       method: @method,\n                       outer_type_parameter_count: uint,\n                       visitor: ResolveVisitor) {\n-        let borrowed_method_type_parameters = &method.tps;\n+        let method_generics = &method.generics;\n         let type_parameters =\n-            HasTypeParameters(borrowed_method_type_parameters,\n+            HasTypeParameters(method_generics,\n                               method.id,\n                               outer_type_parameter_count,\n                               rib_kind);\n@@ -4010,19 +4006,18 @@ pub impl Resolver {\n     fn resolve_implementation(@mut self,\n                               id: node_id,\n                               span: span,\n-                              type_parameters: ~[ty_param],\n+                              generics: &Generics,\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n                               methods: ~[@method],\n                               visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n-        let outer_type_parameter_count = type_parameters.len();\n-        let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n+        let outer_type_parameter_count = generics.ty_params.len();\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0,\n+                                        (generics, id, 0,\n                                          NormalRibKind)) {\n             // Resolve the type parameters.\n-            self.resolve_type_parameters(/*bad*/copy type_parameters,\n+            self.resolve_type_parameters(&generics.ty_params,\n                                          visitor);\n \n             // Resolve the trait reference, if necessary."}, {"sha": "142c327855651003edb48a04e80233e13aa115d3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -2103,9 +2103,9 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms) => {\n-        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, ms, tps, None,\n-                         item.id);\n+      ast::item_impl(ref generics, _, _, ref ms) => {\n+        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, *ms,\n+                         generics, None, item.id);\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);"}, {"sha": "b352b078a473c5ad460221c3feaff45ae8eeff09", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -91,7 +91,9 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                 region_param: _,\n                 ty: _\n             } = ty::lookup_item_type(ccx.tcx, impl_did);\n-            if translate && (*impl_bnds).len() + mth.tps.len() == 0u {\n+            if translate &&\n+                impl_bnds.len() + mth.generics.ty_params.len() == 0u\n+            {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = vec::append(\n                     ty::item_path(ccx.tcx, impl_did),"}, {"sha": "777711889c7a8c901de6a83d8888c870b535ab06", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -46,13 +46,13 @@ be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n-                  methods: ~[@ast::method], tps: ~[ast::ty_param],\n+                  methods: ~[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n-    if tps.len() > 0u { return; }\n+    if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {\n-        if method.tps.len() == 0u {\n+        if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(/*bad*/copy sub_path,\n                                        path_name(method.ident));\n@@ -410,7 +410,7 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n         match ccx.tcx.items.find(&m_id.node) {\n-            Some(ast_map::node_method(m, _, _)) => m.tps.len(),\n+            Some(ast_map::node_method(m, _, _)) => m.generics.ty_params.len(),\n             None => {\n                 match ccx.tcx.provided_method_sources.find(&m_id) {\n                     Some(source) => {\n@@ -420,9 +420,9 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n                     None => fail!()\n                 }\n             }\n-            Some(ast_map::node_trait_method(@ast::provided(@ref m), _, _))\n-                => {\n-                m.tps.len()\n+            Some(ast_map::node_trait_method(@ast::provided(@ref m),\n+                                            _, _)) => {\n+                m.generics.ty_params.len()\n             }\n             copy e => fail!(fmt!(\"method_ty_param_count %?\", e))\n         }"}, {"sha": "a235322532b060992f84101754cc74b1e5b18e56", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -97,38 +97,41 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n-    match /*bad*/copy item.node {\n-      item_mod(m) => traverse_public_mod(cx, item.id, m),\n-      item_foreign_mod(nm) => {\n+    match item.node {\n+      item_mod(ref m) => traverse_public_mod(cx, item.id, *m),\n+      item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for vec::each(nm.items) |item| {\n                   cx.rmap.insert(item.id, ());\n               }\n           }\n       }\n-      item_fn(_, _, ref tps, ref blk) => {\n-        if tps.len() > 0u ||\n+      item_fn(_, _, ref generics, ref blk) => {\n+        if generics.ty_params.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n             traverse_inline_body(cx, (*blk));\n         }\n       }\n-      item_impl(tps, _, _, ms) => {\n-        for vec::each(ms) |m| {\n-            if tps.len() > 0u || m.tps.len() > 0u ||\n-               attr::find_inline_attr(m.attrs) != attr::ia_none {\n+      item_impl(ref generics, _, _, ref ms) => {\n+        for ms.each |m| {\n+            if generics.ty_params.len() > 0u ||\n+                m.generics.ty_params.len() > 0u ||\n+                attr::find_inline_attr(m.attrs) != attr::ia_none\n+            {\n                 cx.rmap.insert(m.id, ());\n                 traverse_inline_body(cx, m.body);\n             }\n         }\n       }\n-      item_struct(struct_def, tps) => {\n+      item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n             cx.rmap.insert(ctor_id, ());\n         }\n         do option::iter(&struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n-            if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n-                     != attr::ia_none {\n+            if generics.ty_params.len() > 0u ||\n+                attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n+            {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }"}, {"sha": "792d1fb4dfb1ddc3c4b50de29ebeece9bbd9fbac", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -4143,10 +4143,11 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     return tbl[tycat(ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n-    vec::from_fn(tps.len(), |i| {\n-                ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n-        })\n+pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n+    vec::from_fn(generics.ty_params.len(), |i| {\n+        let id = generics.ty_params.get(i).id;\n+        ty::mk_param(tcx, i, ast_util::local_def(id))\n+    })\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed."}, {"sha": "fe956162786d59601546b9470f72db88c6191e10", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -127,6 +127,8 @@ use syntax::codemap;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n use syntax;\n \n pub mod _match;\n@@ -592,9 +594,9 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_struct(struct_def, _) => {\n         check_struct(ccx, struct_def, it.id, it.span);\n       }\n-      ast::item_ty(t, tps) => {\n+      ast::item_ty(t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n-        check_bounds_are_used(ccx, t.span, tps, tpt_ty);\n+        check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n         // If this is a record ty, check for duplicate fields\n         match t.node {\n             ast::ty_rec(ref fields) => {\n@@ -1062,8 +1064,9 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n               }, _)) => {\n-            (ts.len(), region_param,\n-                vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n+            (ts.ty_params.len(),\n+             region_param,\n+             vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n           }\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_struct(_, ref ts),\n@@ -1074,12 +1077,13 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n-              (ts.len(), region_param,\n-                  ty::mk_struct(tcx, local_def(class_id),\n+              (ts.ty_params.len(),\n+               region_param,\n+               ty::mk_struct(tcx, local_def(class_id),\n                       substs {\n                         self_r: rscope::bound_self_region(region_param),\n                         self_ty: None,\n-                        tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)\n+                        tps: ty::ty_params_to_tys(tcx, ts)\n                       }))\n           }\n           _ => { tcx.sess.bug(~\"impl_self_ty: unbound item or item that \\\n@@ -1862,11 +1866,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.region_paramd_items.find(&class_id.node);\n             match tcx.items.find(&class_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n-                        node: ast::item_struct(_, ref type_parameters),\n+                        node: ast::item_struct(_, ref generics),\n                         _\n                     }, _)) => {\n \n-                    type_parameter_count = type_parameters.len();\n+                    type_parameter_count = generics.ty_params.len();\n \n                     let self_region =\n                         bound_self_region(region_parameterized);\n@@ -1876,7 +1880,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n                             tcx,\n-                            /*bad*/copy *type_parameters)\n+                            generics)\n                     });\n                 }\n                 _ => {\n@@ -1946,11 +1950,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.region_paramd_items.find(&enum_id.node);\n             match tcx.items.find(&enum_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n-                        node: ast::item_enum(_, ref type_parameters),\n+                        node: ast::item_enum(_, ref generics),\n                         _\n                     }, _)) => {\n \n-                    type_parameter_count = type_parameters.len();\n+                    type_parameter_count = generics.ty_params.len();\n \n                     let self_region =\n                         bound_self_region(region_parameterized);\n@@ -1960,7 +1964,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n                             tcx,\n-                            /*bad*/copy *type_parameters)\n+                            generics)\n                     });\n                 }\n                 _ => {\n@@ -3126,7 +3130,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n \n pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: span,\n-                             tps: ~[ast::ty_param],\n+                             tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n@@ -3153,7 +3157,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n-                           *ccx.tcx.sess.str_of(tps[i].ident)));\n+                           *ccx.tcx.sess.str_of(tps.get(i).ident)));\n         }\n     }\n }"}, {"sha": "5ab2bcd851912656255c51dfb4298b04d0770a2a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -147,7 +147,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     @MethodInfo {\n         did: local_def(ast_method.id),\n-        n_tps: ast_method.tps.len(),\n+        n_tps: ast_method.generics.ty_params.len(),\n         ident: ast_method.ident,\n         self_type: ast_method.self_ty.node\n     }"}, {"sha": "630ff46ccfbef7640b6f1f0cc665371e97a0d97e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 69, "deletions": 64, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -60,6 +60,8 @@ use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust::path_to_str;\n use syntax::visit;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n@@ -70,8 +72,8 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n         if crate_item.ident\n             == ::syntax::parse::token::special_idents::intrinsic {\n \n-            match /*bad*/copy crate_item.node {\n-              ast::item_mod(m) => {\n+            match crate_item.node {\n+              ast::item_mod(ref m) => {\n                 for m.items.each |intrinsic_item| {\n                     let def_id = ast::def_id { crate: ast::local_crate,\n                                                node: intrinsic_item.id };\n@@ -153,7 +155,7 @@ pub impl AstConv for CrateCtxt {\n pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n-                              +ty_params: ~[ast::ty_param],\n+                              generics: &ast::Generics,\n                               rp: Option<ty::region_variance>) {\n     let tcx = ccx.tcx;\n \n@@ -175,15 +177,15 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, ty_params),\n+                    bounds: ty_param_bounds(ccx, generics),\n                     region_param: rp,\n                     ty: enum_ty\n                 };\n \n                 convert_struct(ccx,\n                                rp,\n                                struct_def,\n-                               ty_params.to_vec(),\n+                               generics,\n                                tpt,\n                                variant.node.id);\n \n@@ -196,7 +198,7 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n                 get_enum_variant_types(ccx,\n                                        enum_ty,\n                                        enum_definition.variants,\n-                                       copy ty_params,\n+                                       generics,\n                                        rp);\n                 result_ty = None;\n             }\n@@ -206,7 +208,7 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n             None => {}\n             Some(result_ty) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, ty_params),\n+                    bounds: ty_param_bounds(ccx, generics),\n                     region_param: rp,\n                     ty: result_ty\n                 };\n@@ -276,7 +278,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n     let region_paramd = tcx.region_paramd_items.find(&id);\n     match tcx.items.get(&id) {\n       ast_map::node_item(@ast::item {\n-                node: ast::item_trait(ref params, _, ref ms),\n+                node: ast::item_trait(ref generics, _, ref ms),\n                 _\n             }, _) => {\n         store_methods::<ast::trait_method>(ccx, id, (/*bad*/copy *ms), |m| {\n@@ -288,7 +290,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n-            let trait_bounds = ty_param_bounds(ccx, *params);\n+            let trait_bounds = ty_param_bounds(ccx, generics);\n             let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n@@ -488,7 +490,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n }\n \n pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n-                                   tps: ~[ast::ty_param],\n+                                   generics: &ast::Generics,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n                                    a_trait_ty: @ast::trait_ref,\n@@ -522,8 +524,9 @@ pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n     for impl_ms.each |impl_m| {\n         match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(ref trait_m) => {\n+                let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n-                    ccx.tcx, tps.len(), impl_m, trait_m,\n+                    ccx.tcx, num_impl_tps, impl_m, trait_m,\n                     &tpt.substs, selfty);\n             }\n             None => {\n@@ -568,7 +571,7 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, m.tps);\n+        let bounds = ty_param_bounds(ccx, &m.generics);\n         let mty = ty_of_method(ccx, *m, rp);\n         let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n@@ -589,9 +592,9 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n \n pub fn ensure_no_ty_param_bounds(ccx: @mut CrateCtxt,\n                                  span: span,\n-                                 ty_params: &[ast::ty_param],\n+                                 generics: &ast::Generics,\n                                  thing: &static/str) {\n-    for ty_params.each |ty_param| {\n+    for generics.ty_params.each |ty_param| {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n@@ -606,21 +609,21 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n            *tcx.sess.str_of(it.ident), it.id, rp);\n-    match /*bad*/copy it.node {\n+    match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(ref enum_definition, ref ty_params) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"enumeration\");\n+      ast::item_enum(ref enum_definition, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         get_enum_variant_types(ccx,\n                                tpt.ty,\n                                enum_definition.variants,\n-                               copy *ty_params,\n+                               generics,\n                                rp);\n       }\n-      ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, *tps);\n+      ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n+        let i_bounds = ty_param_bounds(ccx, generics);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n@@ -632,11 +635,11 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n         // XXX: Bad copy of `ms` below.\n         let cms = convert_methods(ccx, /*bad*/copy *ms, rp, i_bounds);\n         for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, /*bad*/copy *tps, rp, selfty,\n+            check_methods_against_trait(ccx, generics, rp, selfty,\n                                         *t, /*bad*/copy cms);\n         }\n       }\n-      ast::item_trait(ref tps, ref supertraits, ref trait_methods) => {\n+      ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n         debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ppaux::ty_to_str(tcx, tpt.ty));\n@@ -646,21 +649,21 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n \n         let (_, provided_methods) =\n             split_trait_methods(/*bad*/copy *trait_methods);\n-        let (bounds, _) = mk_substs(ccx, /*bad*/copy *tps, rp);\n+        let (bounds, _) = mk_substs(ccx, generics, rp);\n         let _ = convert_methods(ccx, provided_methods, rp, bounds);\n       }\n-      ast::item_struct(struct_def, tps) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, tps, \"structure\");\n+      ast::item_struct(struct_def, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n \n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        convert_struct(ccx, rp, struct_def, tps, tpt, it.id);\n+        convert_struct(ccx, rp, struct_def, generics, tpt, it.id);\n       }\n-      ast::item_ty(_, ref ty_params) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"type\");\n+      ast::item_ty(_, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n       }\n@@ -677,7 +680,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n pub fn convert_struct(ccx: @mut CrateCtxt,\n                       rp: Option<ty::region_variance>,\n                       struct_def: @ast::struct_def,\n-                      +tps: ~[ast::ty_param],\n+                      generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::node_id) {\n     let tcx = ccx.tcx;\n@@ -702,7 +705,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, *f);\n     }\n-    let (_, substs) = mk_substs(ccx, tps, rp);\n+    let (_, substs) = mk_substs(ccx, generics, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -746,7 +749,7 @@ pub fn ty_of_method(ccx: @mut CrateCtxt,\n                     rp: Option<ty::region_variance>) -> ty::method {\n     ty::method {\n         ident: m.ident,\n-        tps: ty_param_bounds(ccx, m.tps),\n+        tps: ty_param_bounds(ccx, &m.generics),\n         fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n                                     ast::RustAbi, m.decl),\n         self_ty: m.self_ty.node,\n@@ -761,7 +764,7 @@ pub fn ty_of_ty_method(self: @mut CrateCtxt,\n                        id: ast::def_id) -> ty::method {\n     ty::method {\n         ident: m.ident,\n-        tps: ty_param_bounds(self, m.tps),\n+        tps: ty_param_bounds(self, &m.generics),\n         fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n                                     ast::RustAbi, m.decl),\n         // assume public, because this is only invoked on trait methods\n@@ -809,17 +812,17 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n       _ => {}\n     }\n     let rp = tcx.region_paramd_items.find(&it.id);\n-    match /*bad*/copy it.node {\n+    match it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_fn(decl, purity, tps, _) => {\n-        let bounds = ty_param_bounds(ccx, tps);\n+      ast::item_fn(ref decl, purity, ref generics, _) => {\n+        let bounds = ty_param_bounds(ccx, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n-                                          ast::RustAbi, decl);\n+                                          ast::RustAbi, *decl);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n             region_param: None,\n@@ -832,7 +835,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_ty(t, tps) => {\n+      ast::item_ty(t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n           Some(tpt) => return tpt,\n           None => { }\n@@ -846,12 +849,12 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n                 // reconstruct the value of X.\n-                if !vec::is_empty(tps) { t0 } else {\n+                if !generics.is_empty() { t0 } else {\n                     ty::mk_with_id(tcx, t0, def_id)\n                 }\n             };\n             ty_param_bounds_and_ty {\n-                bounds: ty_param_bounds(ccx, tps),\n+                bounds: ty_param_bounds(ccx, generics),\n                 region_param: rp,\n                 ty: ty\n             }\n@@ -860,9 +863,9 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_enum(_, tps) => {\n+      ast::item_enum(_, ref generics) => {\n         // Create a new generic polytype.\n-        let (bounds, substs) = mk_substs(ccx, tps, rp);\n+        let (bounds, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -872,8 +875,8 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_trait(tps, _, _) => {\n-        let (bounds, substs) = mk_substs(ccx, tps, rp);\n+      ast::item_trait(ref generics, _, _) => {\n+        let (bounds, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs, ty::vstore_box);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -883,8 +886,8 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_struct(_, tps) => {\n-          let (bounds, substs) = mk_substs(ccx, tps, rp);\n+      ast::item_struct(_, ref generics) => {\n+          let (bounds, substs) = mk_substs(ccx, generics, rp);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -902,9 +905,10 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n \n pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n-    match /*bad*/copy it.node {\n-      ast::foreign_item_fn(fn_decl, _, params) => {\n-        return ty_of_foreign_fn_decl(ccx, fn_decl, params, local_def(it.id));\n+    match it.node {\n+      ast::foreign_item_fn(ref fn_decl, _, ref generics) => {\n+        return ty_of_foreign_fn_decl(ccx, *fn_decl, local_def(it.id),\n+                                     generics);\n       }\n       ast::foreign_item_const(t) => {\n         let rb = in_binding_rscope(empty_rscope);\n@@ -922,9 +926,9 @@ pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n // either be user-defined traits, or one of the four built-in traits (formerly\n // known as kinds): Const, Copy, Durable, and Send.\n pub fn compute_bounds(ccx: @mut CrateCtxt,\n-                      ast_bounds: @~[ast::ty_param_bound])\n+                      ast_bounds: @OptVec<ast::TyParamBound>)\n                    -> ty::param_bounds {\n-    @do vec::flat_map(*ast_bounds) |b| {\n+    @ast_bounds.flat_map_to_vec(|b| {\n         match b {\n             &TraitTyParamBound(b) => {\n                 let li = &ccx.tcx.lang_items;\n@@ -954,13 +958,13 @@ pub fn compute_bounds(ccx: @mut CrateCtxt,\n             }\n             &RegionTyParamBound => ~[ty::bound_durable]\n         }\n-    }\n+    })\n }\n \n pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n-                       params: ~[ast::ty_param])\n+                       generics: &ast::Generics)\n                     -> @~[ty::param_bounds] {\n-    @do params.map |param| {\n+    @do generics.ty_params.map_to_vec |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n           Some(bs) => bs,\n           None => {\n@@ -974,10 +978,10 @@ pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n \n pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n                              decl: ast::fn_decl,\n-                             +ty_params: ~[ast::ty_param],\n-                             def_id: ast::def_id)\n+                             def_id: ast::def_id,\n+                             generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(ccx, ty_params);\n+    let bounds = ty_param_bounds(ccx, generics);\n     let rb = in_binding_rscope(empty_rscope);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n@@ -998,24 +1002,25 @@ pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n     return tpt;\n }\n \n-pub fn mk_ty_params(ccx: @mut CrateCtxt, atps: ~[ast::ty_param])\n-    -> (@~[ty::param_bounds], ~[ty::t]) {\n-\n+pub fn mk_generics(ccx: @mut CrateCtxt, generics: &ast::Generics)\n+    -> (@~[ty::param_bounds], ~[ty::t])\n+{\n     let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, atps);\n+    let bounds = ty_param_bounds(ccx, generics);\n     (bounds,\n-     vec::map(atps, |atp| {\n+     generics.ty_params.map_to_vec(|atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n      }))\n }\n \n pub fn mk_substs(ccx: @mut CrateCtxt,\n-                 +atps: ~[ast::ty_param],\n+                 generics: &ast::Generics,\n                  rp: Option<ty::region_variance>)\n-              -> (@~[ty::param_bounds], ty::substs) {\n-    let (bounds, params) = mk_ty_params(ccx, atps);\n+              -> (@~[ty::param_bounds], ty::substs)\n+{\n+    let (bounds, params) = mk_generics(ccx, generics);\n     let self_r = rscope::bound_self_region(rp);\n     (bounds, substs { self_r: self_r, self_ty: None, tps: params })\n }"}, {"sha": "bdfc2be7bd67327ddb7cb5e076f1def7c4786932", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -77,7 +77,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n             ident: ident,\n             node: ast::foreign_item_fn(ref decl, _, ref tys), _\n           }, _, _) => {\n-            Some(pprust::fun_to_str(*decl, ident, copy *tys,\n+            Some(pprust::fun_to_str(*decl, ident, tys,\n                                     extract::interner()))\n           }\n           _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n@@ -215,15 +215,15 @@ fn get_method_sig(\n                       Some(pprust::fun_to_str(\n                           ty_m.decl,\n                           ty_m.ident,\n-                          copy ty_m.tps,\n+                          &ty_m.generics,\n                           extract::interner()\n                       ))\n                     }\n                     ast::provided(m) => {\n                       Some(pprust::fun_to_str(\n                           m.decl,\n                           m.ident,\n-                          copy m.tps,\n+                          &m.generics,\n                           extract::interner()\n                       ))\n                     }\n@@ -242,7 +242,7 @@ fn get_method_sig(\n                     Some(pprust::fun_to_str(\n                         method.decl,\n                         method.ident,\n-                        copy method.tps,\n+                        &method.generics,\n                         extract::interner()\n                     ))\n                 }\n@@ -339,7 +339,7 @@ fn fold_type(\n                         Some(fmt!(\n                             \"type %s%s = %s\",\n                             to_str(ident),\n-                            pprust::typarams_to_str(*params,\n+                            pprust::generics_to_str(params,\n                                                     extract::interner()),\n                             pprust::ty_to_str(ty,\n                                               extract::interner())"}, {"sha": "5460584763eec1e5bc0030c6b1222024fd4f4ce8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -21,6 +21,8 @@ use core::to_bytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use opt_vec::OptVec;\n+\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n@@ -96,6 +98,9 @@ pub impl to_bytes::IterBytes for ident {\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n@@ -135,18 +140,32 @@ pub const crate_node_id: node_id = 0;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n-pub enum ty_param_bound {\n+pub enum TyParamBound {\n     TraitTyParamBound(@Ty),\n     RegionTyParamBound\n }\n \n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-pub struct ty_param {\n+pub struct TyParam {\n     ident: ident,\n     id: node_id,\n-    bounds: @~[ty_param_bound]\n+    bounds: @OptVec<TyParamBound>\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub struct Generics {\n+    lifetimes: OptVec<Lifetime>,\n+    ty_params: OptVec<TyParam>\n+}\n+\n+impl Generics {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.len() + self.ty_params.len() == 0\n+    }\n }\n \n #[auto_encode]\n@@ -273,8 +292,8 @@ pub enum pat_ {\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     pat_ident(binding_mode, @path, Option<@pat>),\n-    pat_enum(@path, Option<~[@pat]>), // \"none\" means a * pattern where\n-                                  // we don't bind the fields to names\n+    pat_enum(@path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+                                       * we don't bind the fields to names */\n     pat_rec(~[field_pat], bool),\n     pat_struct(@path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n@@ -749,7 +768,7 @@ pub struct ty_method {\n     attrs: ~[attribute],\n     purity: purity,\n     decl: fn_decl,\n-    tps: ~[ty_param],\n+    generics: Generics,\n     self_ty: self_ty,\n     id: node_id,\n     span: span,\n@@ -1012,7 +1031,7 @@ pub type self_ty = spanned<self_ty_>;\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n-    tps: ~[ty_param],\n+    generics: Generics,\n     self_ty: self_ty,\n     purity: purity,\n     decl: fn_decl,\n@@ -1248,14 +1267,14 @@ pub struct item {\n #[deriving_eq]\n pub enum item_ {\n     item_const(@Ty, @expr),\n-    item_fn(fn_decl, purity, ~[ty_param], blk),\n+    item_fn(fn_decl, purity, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@Ty, ~[ty_param]),\n-    item_enum(enum_def, ~[ty_param]),\n-    item_struct(@struct_def, ~[ty_param]),\n-    item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n-    item_impl(~[ty_param],\n+    item_ty(@Ty, Generics),\n+    item_enum(enum_def, Generics),\n+    item_struct(@struct_def, Generics),\n+    item_trait(Generics, ~[@trait_ref], ~[trait_method]),\n+    item_impl(Generics,\n               Option<@trait_ref>, // (optional) trait this impl implements\n               @Ty, // self\n               ~[@method]),\n@@ -1302,7 +1321,7 @@ pub struct foreign_item {\n #[auto_decode]\n #[deriving_eq]\n pub enum foreign_item_ {\n-    foreign_item_fn(fn_decl, purity, ~[ty_param]),\n+    foreign_item_fn(fn_decl, purity, Generics),\n     foreign_item_const(@Ty)\n }\n \n@@ -1316,7 +1335,7 @@ pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_dtor(struct_dtor, ident, ~[ty_param], def_id /* parent id */)\n+    ii_dtor(struct_dtor, ident, Generics, def_id /* parent id */)\n }\n \n #[cfg(test)]"}, {"sha": "ea34d5a2779bf616d89b20cc25929311812a3fcd", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -101,7 +101,7 @@ pub enum ast_node {\n     node_arg(arg, uint),\n     node_local(uint),\n     // Destructor for a struct\n-    node_dtor(~[ty_param], @struct_dtor, def_id, @path),\n+    node_dtor(Generics, @struct_dtor, def_id, @path),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n }"}, {"sha": "95f52fbea99aeb01fa7d0cafd2035867ec3c3083", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -16,6 +16,7 @@ use ast_util;\n use codemap::{span, BytePos, dummy_sp};\n use parse::token;\n use visit;\n+use opt_vec;\n \n use core::cmp;\n use core::int;\n@@ -263,13 +264,13 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     match method {\n         required(ref m) => (*m),\n-        provided(m) => {\n+        provided(ref m) => {\n             ty_method {\n                 ident: m.ident,\n                 attrs: m.attrs,\n                 purity: m.purity,\n                 decl: m.decl,\n-                tps: m.tps,\n+                generics: copy m.generics,\n                 self_ty: m.self_ty,\n                 id: m.id,\n                 span: m.span,\n@@ -327,8 +328,9 @@ pub impl inlined_item_utils for inlined_item {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n             ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-            ii_dtor(/*bad*/ copy dtor, _, /*bad*/ copy tps, parent_id) => {\n-                visit::visit_struct_dtor_helper(dtor, tps, parent_id, e, v);\n+            ii_dtor(/*bad*/ copy dtor, _, ref generics, parent_id) => {\n+                visit::visit_struct_dtor_helper(dtor, generics,\n+                                                parent_id, e, v);\n             }\n         }\n     }\n@@ -375,6 +377,11 @@ pub fn dtor_dec() -> fn_decl {\n     }\n }\n \n+pub fn empty_generics() -> Generics {\n+    Generics {lifetimes: opt_vec::Empty,\n+              ty_params: opt_vec::Empty}\n+}\n+\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n@@ -390,6 +397,14 @@ pub fn empty(range: id_range) -> bool {\n }\n \n pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n+    let visit_generics = fn@(generics: &Generics) {\n+        for generics.ty_params.each |p| {\n+            vfn(p.id);\n+        }\n+        for generics.lifetimes.each |p| {\n+            vfn(p.id);\n+        }\n+    };\n     visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_mod: |_m, _sp, id| vfn(id),\n \n@@ -457,29 +472,25 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_params: fn@(ps: ~[ty_param]) {\n-            for vec::each(ps) |p| {\n-                vfn(p.id);\n-            }\n-        },\n+        visit_generics: visit_generics,\n \n         visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             match fk {\n-                visit::fk_dtor(tps, _, self_id, parent_id) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                visit::fk_dtor(ref generics, _, self_id, parent_id) => {\n+                    visit_generics(generics);\n                     vfn(id);\n                     vfn(self_id);\n                     vfn(parent_id.node);\n                 }\n-                visit::fk_item_fn(_, tps, _) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                visit::fk_item_fn(_, ref generics, _) => {\n+                    visit_generics(generics);\n                 }\n-                visit::fk_method(_, tps, m) => {\n+                visit::fk_method(_, ref generics, m) => {\n                     vfn(m.self_id);\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                    visit_generics(generics);\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n@@ -497,7 +508,9 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_trait_method: fn@(_ty_m: trait_method) {\n         },\n \n-        visit_struct_def: fn@(_sd: @struct_def, _id: ident, _tps: ~[ty_param],\n+        visit_struct_def: fn@(_sd: @struct_def,\n+                              _id: ident,\n+                              _generics: &Generics,\n                               _id: node_id) {\n         },\n "}, {"sha": "6417707d8bb24043291d30c1aaa70e393a25b1b9", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n+/*!\n \n The compiler code necessary to implement the #[auto_encode] and\n #[auto_decode] extension.  The idea here is that type-defining items may\n@@ -96,6 +96,9 @@ use attr;\n use codemap::span;\n use ext::base::*;\n use parse;\n+use opt_vec;\n+use opt_vec::OptVec;\n+use ext::build;\n \n use core::vec;\n use std::oldmap;\n@@ -127,24 +130,24 @@ pub fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_struct(ref struct_def, ref tps) => {\n+                ast::item_struct(ref struct_def, ref generics) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         struct_def.fields,\n-                        *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_enum(ref enum_def, ref tps) => {\n+                ast::item_enum(ref enum_def, ref generics) => {\n                     let ser_impl = mk_enum_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         *enum_def,\n-                        *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n@@ -182,24 +185,24 @@ pub fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_struct(ref struct_def, ref tps) => {\n+                ast::item_struct(ref struct_def, ref generics) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         struct_def.fields,\n-                        *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_enum(ref enum_def, ref tps) => {\n+                ast::item_enum(ref enum_def, ref generics) => {\n                     let deser_impl = mk_enum_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         *enum_def,\n-                        *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -222,18 +225,18 @@ priv impl ext_ctxt {\n         span: span,\n         ident: ast::ident,\n         path: @ast::path,\n-        bounds: @~[ast::ty_param_bound]\n-    ) -> ast::ty_param {\n+        bounds: @OptVec<ast::TyParamBound>\n+    ) -> ast::TyParam {\n         let bound = ast::TraitTyParamBound(@ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),\n             span: span,\n         });\n \n-        ast::ty_param {\n+        ast::TyParam {\n             ident: ident,\n             id: self.next_id(),\n-            bounds: @vec::append(~[bound], *bounds)\n+            bounds: @bounds.prepend(bound)\n         }\n     }\n \n@@ -408,28 +411,45 @@ fn mk_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    ty_param: ast::ty_param,\n+    ty_param: ast::TyParam,\n     path: @ast::path,\n-    tps: &[ast::ty_param],\n+    generics: &ast::Generics,\n     f: fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n+    /*!\n+     *\n+     * Given that we are deriving auto-encode a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr, ..., Z:Tr> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where Tr is either Serializable and Deserialize.\n+     *\n+     * FIXME(#5090): Remove code duplication between this and the code\n+     * in deriving.rs\n+     */\n+\n+\n+    // Copy the lifetimes\n+    let impl_lifetimes = generics.lifetimes.map(|l| {\n+        build::mk_lifetime(cx, l.span, l.ident)\n+    });\n+\n     // All the type parameters need to bound to the trait.\n-    let mut trait_tps = vec::append(\n-        ~[ty_param],\n-         do tps.map |tp| {\n-            let t_bound = ast::TraitTyParamBound(@ast::Ty {\n-                id: cx.next_id(),\n-                node: ast::ty_path(path, cx.next_id()),\n-                span: span,\n-            });\n+    let mut impl_tps = opt_vec::with(ty_param);\n+    for generics.ty_params.each |tp| {\n+        let t_bound = ast::TraitTyParamBound(@ast::Ty {\n+            id: cx.next_id(),\n+            node: ast::ty_path(path, cx.next_id()),\n+            span: span,\n+        });\n \n-            ast::ty_param {\n-                ident: tp.ident,\n-                id: cx.next_id(),\n-                bounds: @vec::append(~[t_bound], *tp.bounds)\n-            }\n-        }\n-    );\n+        impl_tps.push(ast::TyParam {\n+            ident: tp.ident,\n+            id: cx.next_id(),\n+            bounds: @tp.bounds.prepend(t_bound)\n+        })\n+    }\n \n     let opt_trait = Some(@ast::trait_ref {\n         path: path,\n@@ -439,16 +459,22 @@ fn mk_impl(\n     let ty = cx.ty_path(\n         span,\n         ~[ident],\n-        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+        generics.ty_params.map(\n+            |tp| cx.ty_path(span, ~[tp.ident], ~[])).to_vec()\n     );\n \n+    let generics = ast::Generics {\n+        lifetimes: impl_lifetimes,\n+        ty_params: impl_tps\n+    };\n+\n     @ast::item {\n         // This is a new-style impl declaration.\n         // XXX: clownshoes\n         ident: parse::token::special_idents::clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        node: ast::item_impl(generics, opt_trait, ty, ~[f(ty)]),\n         vis: ast::public,\n         span: span,\n     }\n@@ -458,7 +484,7 @@ fn mk_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: &[ast::ty_param],\n+    generics: &ast::Generics,\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Encodable typaram.\n@@ -473,7 +499,7 @@ fn mk_ser_impl(\n                 cx.ident_of(~\"Encoder\"),\n             ]\n         ),\n-        @~[]\n+        @opt_vec::Empty\n     );\n \n     // Make a path to the std::serialize::Encodable trait.\n@@ -493,7 +519,7 @@ fn mk_ser_impl(\n         ident,\n         ty_param,\n         path,\n-        tps,\n+        generics,\n         |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n     )\n }\n@@ -502,7 +528,7 @@ fn mk_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: ~[ast::ty_param],\n+    generics: &ast::Generics,\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Decodable typaram.\n@@ -517,7 +543,7 @@ fn mk_deser_impl(\n                 cx.ident_of(~\"Decoder\"),\n             ]\n         ),\n-        @~[]\n+        @opt_vec::Empty\n     );\n \n     // Make a path to the std::serialize::Decodable trait.\n@@ -537,7 +563,7 @@ fn mk_deser_impl(\n         ident,\n         ty_param,\n         path,\n-        tps,\n+        generics,\n         |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n     )\n }\n@@ -592,7 +618,7 @@ fn mk_ser_method(\n     @ast::method {\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned { node: ast::sty_region(ast::m_imm),\n                                 span: span },\n         purity: ast::impure_fn,\n@@ -650,7 +676,7 @@ fn mk_deser_method(\n     @ast::method {\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n@@ -667,7 +693,7 @@ fn mk_struct_ser_impl(\n     span: span,\n     ident: ast::ident,\n     fields: &[@ast::struct_field],\n-    tps: &[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n@@ -720,15 +746,15 @@ fn mk_struct_ser_impl(\n         ]\n     );\n \n-    mk_ser_impl(cx, span, ident, tps, ser_body)\n+    mk_ser_impl(cx, span, ident, generics, ser_body)\n }\n \n fn mk_struct_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| std::serialize::decode(__d)`\n@@ -796,7 +822,7 @@ fn mk_struct_deser_impl(\n         ]\n     );\n \n-    mk_deser_impl(cx, span, ident, tps, body)\n+    mk_deser_impl(cx, span, ident, generics, body)\n }\n \n // Records and structs don't have the same fields types, but they share enough\n@@ -832,7 +858,7 @@ fn mk_enum_ser_impl(\n     span: span,\n     ident: ast::ident,\n     enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n         cx,\n@@ -841,15 +867,15 @@ fn mk_enum_ser_impl(\n         enum_def.variants\n     );\n \n-    mk_ser_impl(cx, span, ident, tps, body)\n+    mk_ser_impl(cx, span, ident, generics, body)\n }\n \n fn mk_enum_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n         cx,\n@@ -858,7 +884,7 @@ fn mk_enum_deser_impl(\n         enum_def.variants\n     );\n \n-    mk_deser_impl(cx, span, ident, tps, body)\n+    mk_deser_impl(cx, span, ident, generics, body)\n }\n \n fn ser_variant("}, {"sha": "fa21243df03679515aaddb9e9009642de51ac3ce", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -16,6 +16,9 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n \n+use opt_vec;\n+use opt_vec::OptVec;\n+\n use core::dvec;\n use core::option;\n \n@@ -354,8 +357,14 @@ pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n }\n pub fn mk_ty_param(cx: ext_ctxt,\n                    ident: ast::ident,\n-                   bounds: @~[ast::ty_param_bound])\n-                -> ast::ty_param {\n-    ast::ty_param { ident: ident, id: cx.next_id(), bounds: bounds }\n+                   bounds: @OptVec<ast::TyParamBound>)\n+                -> ast::TyParam {\n+    ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n+}\n+pub fn mk_lifetime(cx: ext_ctxt,\n+                   span: span,\n+                   ident: ast::ident) -> ast::Lifetime\n+{\n+    ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n }\n "}, {"sha": "0164f807f4b5f9f3ba01e6f06d43ab1e2d4b3ecc", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -16,15 +16,19 @@ use core::prelude::*;\n use ast;\n use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n use ast::{enum_variant_kind, expr, expr_match, ident, item, item_};\n-use ast::{item_enum, item_impl, item_struct, m_imm, meta_item, method};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n use ast::{re_anon, stmt, struct_def, struct_variant_kind};\n-use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, ty_param};\n-use ast::{ty_param_bound, ty_path, ty_rptr, unnamed_field, variant};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n use codemap::{span, spanned};\n use parse::token::special_idents::clownshoes_extensions;\n+use ast_util;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::dvec;\n use core::uint;\n@@ -47,13 +51,13 @@ type ExpandDerivingStructDefFn = &fn(ext_ctxt,\n                                      span,\n                                      x: &struct_def,\n                                      ident,\n-                                     +y: ~[ty_param])\n+                                     y: &Generics)\n                                   -> @item;\n type ExpandDerivingEnumDefFn = &fn(ext_ctxt,\n                                    span,\n                                    x: &enum_def,\n                                    ident,\n-                                   +y: ~[ty_param])\n+                                   y: &Generics)\n                                 -> @item;\n \n pub fn expand_deriving_eq(cx: ext_ctxt,\n@@ -90,19 +94,19 @@ fn expand_deriving(cx: ext_ctxt,\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n-            item_struct(struct_def, copy ty_params) => {\n+            item_struct(struct_def, ref generics) => {\n                 result.push(expand_deriving_struct_def(cx,\n                                                        span,\n                                                        struct_def,\n                                                        item.ident,\n-                                                       ty_params));\n+                                                       generics));\n             }\n-            item_enum(ref enum_definition, copy ty_params) => {\n+            item_enum(ref enum_definition, ref generics) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n                                                      item.ident,\n-                                                     ty_params));\n+                                                     generics));\n             }\n             _ => ()\n         }\n@@ -127,14 +131,14 @@ fn create_eq_method(cx: ext_ctxt,\n                     span: span,\n                     method_ident: ident,\n                     type_ident: ident,\n-                    ty_params: &[ty_param],\n+                    generics: &Generics,\n                     body: @expr)\n                  -> @method {\n     // Create the type of the `other` parameter.\n     let arg_path_type = create_self_type_with_params(cx,\n                                                      span,\n                                                      type_ident,\n-                                                     ty_params);\n+                                                     generics);\n     let arg_region = @ast::region { id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(\n         arg_region,\n@@ -171,7 +175,7 @@ fn create_eq_method(cx: ext_ctxt,\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n         purity: pure_fn,\n         decl: fn_decl,\n@@ -186,11 +190,11 @@ fn create_eq_method(cx: ext_ctxt,\n fn create_self_type_with_params(cx: ext_ctxt,\n                                 span: span,\n                                 type_ident: ident,\n-                                ty_params: &[ty_param])\n+                                generics: &Generics)\n                              -> @Ty {\n     // Create the type parameters on the `self` path.\n     let self_ty_params = dvec::DVec();\n-    for ty_params.each |ty_param| {\n+    for generics.ty_params.each |ty_param| {\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n@@ -209,21 +213,34 @@ fn create_self_type_with_params(cx: ext_ctxt,\n fn create_derived_impl(cx: ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n-                       +ty_params: ~[ty_param],\n+                       generics: &Generics,\n                        methods: &[@method],\n                        trait_path: &[ident])\n                     -> @item {\n+    /*!\n+     *\n+     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n+     *\n+     * FIXME(#5090): Remove code duplication between this and the\n+     * code in auto_encode.rs\n+     */\n+\n+    // Copy the lifetimes\n+    let impl_lifetimes = generics.lifetimes.map(|l| {\n+        build::mk_lifetime(cx, l.span, l.ident)\n+    });\n+\n     // Create the type parameters.\n-    let impl_ty_params = dvec::DVec();\n-    for ty_params.each |ty_param| {\n+    let impl_ty_params = generics.ty_params.map(|ty_param| {\n         let bound = build::mk_ty_path_global(cx,\n                                              span,\n                                              trait_path.map(|x| *x));\n-        let bounds = @~[ TraitTyParamBound(bound) ];\n-        let impl_ty_param = build::mk_ty_param(cx, ty_param.ident, bounds);\n-        impl_ty_params.push(impl_ty_param);\n-    }\n-    let impl_ty_params = dvec::unwrap(impl_ty_params);\n+        let bounds = @opt_vec::with(TraitTyParamBound(bound));\n+        build::mk_ty_param(cx, ty_param.ident, bounds)\n+    });\n \n     // Create the reference to the trait.\n     let trait_path = ast::path {\n@@ -244,10 +261,11 @@ fn create_derived_impl(cx: ext_ctxt,\n     let self_type = create_self_type_with_params(cx,\n                                                  span,\n                                                  type_ident,\n-                                                 ty_params);\n+                                                 generics);\n \n     // Create the impl item.\n-    let impl_item = item_impl(impl_ty_params,\n+    let impl_item = item_impl(Generics {lifetimes: impl_lifetimes,\n+                                        ty_params: impl_ty_params},\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n@@ -257,7 +275,7 @@ fn create_derived_impl(cx: ext_ctxt,\n fn create_derived_eq_impl(cx: ext_ctxt,\n                           span: span,\n                           type_ident: ident,\n-                          +ty_params: ~[ty_param],\n+                          generics: &Generics,\n                           eq_method: @method,\n                           ne_method: @method)\n                        -> @item {\n@@ -267,13 +285,13 @@ fn create_derived_eq_impl(cx: ext_ctxt,\n         cx.ident_of(~\"cmp\"),\n         cx.ident_of(~\"Eq\")\n     ];\n-    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n                                   span: span,\n                                   type_ident: ident,\n-                                  +ty_params: ~[ty_param],\n+                                  generics: &Generics,\n                                   method: @method)\n                                -> @item {\n     let methods = [ method ];\n@@ -282,7 +300,7 @@ fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n         cx.ident_of(~\"to_bytes\"),\n         cx.ident_of(~\"IterBytes\")\n     ];\n-    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -322,7 +340,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n         purity: pure_fn,\n         decl: fn_decl,\n@@ -484,7 +502,7 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n-                                 +ty_params: ~[ty_param])\n+                                 generics: &Generics)\n                               -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n@@ -510,21 +528,21 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                      struct_def,\n                                      eq_ident,\n                                      type_ident,\n-                                     ty_params,\n+                                     generics,\n                                      Conjunction);\n     let ne_method = derive_struct_fn(cx,\n                                      span,\n                                      struct_def,\n                                      ne_ident,\n                                      type_ident,\n-                                     ty_params,\n+                                     generics,\n                                      Disjunction);\n \n     // Create the implementation.\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  ty_params,\n+                                  generics,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -533,7 +551,7 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n                                span: span,\n                                enum_definition: &enum_def,\n                                type_ident: ident,\n-                               +ty_params: ~[ty_param])\n+                               generics: &Generics)\n                             -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n@@ -543,21 +561,21 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n                                                    enum_definition,\n                                                    eq_ident,\n                                                    type_ident,\n-                                                   ty_params,\n+                                                   generics,\n                                                    Conjunction);\n     let ne_method = expand_deriving_eq_enum_method(cx,\n                                                    span,\n                                                    enum_definition,\n                                                    ne_ident,\n                                                    type_ident,\n-                                                   ty_params,\n+                                                   generics,\n                                                    Disjunction);\n \n     // Create the implementation.\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  ty_params,\n+                                  generics,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -566,7 +584,7 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n                                          span: span,\n                                          struct_def: &struct_def,\n                                          type_ident: ident,\n-                                         +ty_params: ~[ty_param])\n+                                         generics: &Generics)\n                                       -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_struct_method(cx,\n@@ -577,15 +595,15 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          ty_params,\n+                                          generics,\n                                           method);\n }\n \n fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n                                        span: span,\n                                        enum_definition: &enum_def,\n                                        type_ident: ident,\n-                                       +ty_params: ~[ty_param])\n+                                       generics: &Generics)\n                                     -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_enum_method(cx,\n@@ -596,7 +614,7 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          ty_params,\n+                                          generics,\n                                           method);\n }\n \n@@ -605,7 +623,7 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                                     struct_def: &struct_def,\n                                     method_ident: ident,\n                                     type_ident: ident,\n-                                    ty_params: &[ty_param],\n+                                    generics: &Generics,\n                                     junction: Junction)\n                                  -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -652,7 +670,7 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                             span,\n                             method_ident,\n                             type_ident,\n-                            ty_params,\n+                            generics,\n                             body);\n }\n \n@@ -696,7 +714,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                   enum_definition: &enum_def,\n                                   method_ident: ident,\n                                   type_ident: ident,\n-                                  ty_params: &[ty_param],\n+                                  generics: &Generics,\n                                   junction: Junction)\n                                -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -823,7 +841,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                             span,\n                             method_ident,\n                             type_ident,\n-                            ty_params,\n+                            generics,\n                             self_match_expr);\n }\n \n@@ -832,7 +850,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n                                           struct_def: &struct_def,\n                                           method_ident: ident,\n                                           type_ident: ident,\n-                                          ty_params: &[ty_param],\n+                                          generics: &Generics,\n                                           junction: Junction)\n                                         -> @method {\n     let self_str = ~\"self\";\n@@ -883,7 +901,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n     let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n     create_eq_method(cx, span, method_ident,\n-        type_ident, ty_params, self_match_expr)\n+        type_ident, generics, self_match_expr)\n }\n \n fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,"}, {"sha": "6324379fc9a2cbeded51fd831814fe501163ff93", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -24,6 +24,8 @@ use codemap::{span, respan, dummy_sp};\n use codemap;\n use ext::base::{ext_ctxt, mk_ctxt};\n use ext::quote::rt::*;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::vec;\n \n@@ -67,16 +69,16 @@ pub impl append_types for @ast::path {\n }\n \n pub trait ext_ctxt_ast_builder {\n-    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n-        -> ast::ty_param;\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam;\n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n     fn expr_block(&self, e: @ast::expr) -> ast::blk;\n     fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n     fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n     fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +ty_params: ~[ast::ty_param],\n+                    +generics: Generics,\n                     +body: ast::blk) -> @ast::item;\n     fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n@@ -85,12 +87,12 @@ pub trait ext_ctxt_ast_builder {\n     fn item_enum_poly(&self, name: ident,\n                       span: span,\n                       +enum_definition: ast::enum_def,\n-                      +ty_params: ~[ast::ty_param]) -> @ast::item;\n+                      +generics: Generics) -> @ast::item;\n     fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n     fn item_struct_poly(&self, name: ident, span: span,\n                         struct_def: ast::struct_def,\n-                        ty_params: ~[ast::ty_param]) -> @ast::item;\n+                        +generics: Generics) -> @ast::item;\n     fn item_struct(&self, name: ident, span: span,\n                    struct_def: ast::struct_def) -> @ast::item;\n     fn struct_expr(&self, path: @ast::path,\n@@ -103,10 +105,10 @@ pub trait ext_ctxt_ast_builder {\n     fn item_ty_poly(&self, name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n-                    +params: ~[ast::ty_param]) -> @ast::item;\n+                    +generics: Generics) -> @ast::item;\n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n     fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n     fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n@@ -116,7 +118,7 @@ pub trait ext_ctxt_ast_builder {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer(&self) -> @ast::Ty;\n     fn ty_nil_ast_builder(&self) -> @ast::Ty;\n-    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n+    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n }\n \n pub impl ext_ctxt_ast_builder for ext_ctxt {\n@@ -172,10 +174,10 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n-        -> ast::ty_param\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam\n     {\n-        ast::ty_param { ident: id, id: self.next_id(), bounds: @bounds }\n+        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n \n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n@@ -247,43 +249,46 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n     fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +ty_params: ~[ast::ty_param],\n+                    +generics: Generics,\n                     +body: ast::blk) -> @ast::item {\n         self.item(name,\n                   dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n                                ast::impure_fn,\n-                               ty_params,\n+                               generics,\n                                body))\n     }\n \n     fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item {\n-        self.item_fn_poly(name, inputs, output, ~[], body)\n+        self.item_fn_poly(name, inputs, output,\n+                          ast_util::empty_generics(), body)\n     }\n \n     fn item_enum_poly(&self, name: ident, span: span,\n                       +enum_definition: ast::enum_def,\n-                      +ty_params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_enum(enum_definition, ty_params))\n+                      +generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item {\n-        self.item_enum_poly(name, span, enum_definition, ~[])\n+        self.item_enum_poly(name, span, enum_definition,\n+                            ast_util::empty_generics())\n     }\n \n     fn item_struct(&self, name: ident, span: span,\n                    struct_def: ast::struct_def) -> @ast::item {\n-        self.item_struct_poly(name, span, struct_def, ~[])\n+        self.item_struct_poly(name, span, struct_def,\n+                              ast_util::empty_generics())\n     }\n \n     fn item_struct_poly(&self, name: ident, span: span,\n                         struct_def: ast::struct_def,\n-                        ty_params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_struct(@struct_def, ty_params))\n+                        +generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n     fn struct_expr(&self, path: @ast::path,\n@@ -371,28 +376,31 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n-        do bounds.map |ty_param| {\n-            ast::ty_param { bounds: @~[], ..copy *ty_param }\n-        }\n+    fn strip_bounds(&self, generics: &Generics) -> Generics {\n+        let no_bounds = @opt_vec::Empty;\n+        let new_params = do generics.ty_params.map |ty_param| {\n+            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+        };\n+        Generics { ty_params: new_params, ..*generics }\n     }\n \n     fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    +params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_ty(ty, params))\n+                    +generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_ty(ty, generics))\n     }\n \n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n-        self.item_ty_poly(name, span, ty, ~[])\n+        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n     }\n \n-    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(~[p.ident], dummy_sp())))\n+            path(~[p.ident], dummy_sp()))).to_vec()\n     }\n \n-    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self,\n+                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(~[p.ident], dummy_sp())))\n+            path(~[p.ident], dummy_sp()))).to_vec()\n     }\n }"}, {"sha": "1d49b8c1be825c4a8b07f12982de06d9550ea3ee", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -67,13 +67,13 @@ pub impl proto::visitor<(), (), ()> for ext_ctxt {\n             else {\n                 let next = proto.get_state(next_state.state);\n \n-                if next.ty_params.len() != next_state.tys.len() {\n+                if next.generics.ty_params.len() != next_state.tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n                         fmt!(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              name, next.name,\n-                             next.ty_params.len(),\n+                             next.generics.ty_params.len(),\n                              next_state.tys.len()));\n                 }\n             }"}, {"sha": "ef7056529294a16d1d469a704e85cd9c5427bc9f", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -51,13 +51,13 @@ pub impl proto_parser for parser::Parser {\n           _ => fail!()\n         };\n \n-        let typarms = if *self.token == token::LT {\n-            self.parse_ty_params()\n+        let generics = if *self.token == token::LT {\n+            self.parse_generics()\n         } else {\n-            ~[]\n+            ast_util::empty_generics()\n         };\n \n-        let state = proto.add_state_poly(name, id, dir, typarms);\n+        let state = proto.add_state_poly(name, id, dir, generics);\n \n         // parse the messages\n         self.parse_unspanned_seq("}, {"sha": "6bb25e31f699321d13fad015ae7c36083a4ca8d3", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -19,6 +19,8 @@ use ext::pipes::proto::*;\n use ext::quote::rt::*;\n use parse::*;\n use util::interner;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::dvec::DVec;\n use core::prelude::*;\n@@ -50,20 +52,19 @@ pub impl gen_send for message {\n     fn gen_send(&mut self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n-        let params = self.get_params();\n \n         match *self {\n           message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next_state.state);\n-            assert next_state.tys.len() == next.ty_params.len();\n+            assert next_state.tys.len() == next.generics.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n             let args_ast = (arg_names, *tys).map(|n, t| cx.arg(*n, *t));\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars_global(this.ty_params)));\n+                .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n             let args_ast = vec::append(\n                 ~[cx.arg(cx.ident_of(~\"pipe\"),\n                               pipe_ty)],\n@@ -129,7 +130,7 @@ pub impl gen_send for message {\n             cx.item_fn_poly(name,\n                             args_ast,\n                             rty,\n-                            params,\n+                            self.get_generics(),\n                             cx.expr_block(body))\n           }\n \n@@ -143,10 +144,10 @@ pub impl gen_send for message {\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(cx.ident_of(~\"pipe\"),\n-                                  cx.ty_path_ast_builder(\n-                                      path(~[this.data_name()], span)\n-                                      .add_tys(cx.ty_vars_global(\n-                                        this.ty_params))))],\n+                             cx.ty_path_ast_builder(\n+                                 path(~[this.data_name()], span)\n+                                 .add_tys(cx.ty_vars_global(\n+                                     &this.generics.ty_params))))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -184,15 +185,15 @@ pub impl gen_send for message {\n                                 } else {\n                                     cx.ty_nil_ast_builder()\n                                 },\n-                                params,\n+                                self.get_generics(),\n                                 cx.expr_block(body))\n             }\n           }\n         }\n \n     fn to_ty(&mut self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars_global(self.get_params())))\n+          .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n     }\n }\n \n@@ -243,7 +244,7 @@ pub impl to_type_decls for state {\n                 ast::enum_def(enum_def_ {\n                     variants: items_msg,\n                     common: None }),\n-                cx.strip_bounds(self.ty_params)\n+                cx.strip_bounds(&self.generics)\n             )\n         ]\n     }\n@@ -281,8 +282,9 @@ pub impl to_type_decls for state {\n                             path(~[cx.ident_of(~\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n-                            .add_tys(cx.ty_vars_global(self.ty_params))))),\n-                    cx.strip_bounds(self.ty_params)));\n+                            .add_tys(cx.ty_vars_global(\n+                                &self.generics.ty_params))))),\n+                    cx.strip_bounds(&self.generics)));\n         }\n         else {\n             items.push(\n@@ -299,9 +301,10 @@ pub impl to_type_decls for state {\n                             path(~[cx.ident_of(~\"super\"),\n                                    self.data_name()],\n                                         dummy_sp())\n-                            .add_tys(cx.ty_vars_global(self.ty_params))),\n+                            .add_tys(cx.ty_vars_global(\n+                                &self.generics.ty_params))),\n                                    self.proto.buffer_ty_path(cx)])),\n-                    cx.strip_bounds(self.ty_params)));\n+                    cx.strip_bounds(&self.generics)));\n         };\n         items\n     }\n@@ -340,7 +343,7 @@ pub impl gen_init for protocol {\n \n         cx.parse_item(fmt!(\"pub fn init%s() -> (client::%s, server::%s)\\\n                             { use core::pipes::HasBuffer; %s }\",\n-                           start_state.ty_params.to_source(cx),\n+                           start_state.generics.to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            body.to_source(cx)))\n@@ -385,9 +388,9 @@ pub impl gen_init for protocol {\n     }\n \n     fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty {\n-        let mut params: ~[ast::ty_param] = ~[];\n+        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).each |s| {\n-            for s.ty_params.each |tp| {\n+            for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n@@ -398,19 +401,20 @@ pub impl gen_init for protocol {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(~\"super\"),\n                                       cx.ident_of(~\"__Buffer\")],\n                                     copy self.span)\n-                               .add_tys(cx.ty_vars_global(params)))\n+                               .add_tys(cx.ty_vars_global(&params)))\n     }\n \n     fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n-        let mut params: ~[ast::ty_param] = ~[];\n+        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).map_to_vec |s| {\n-            for s.ty_params.each |tp| {\n+            for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n                 }\n             }\n+\n             let ty = s.to_ty(cx);\n             let fty = quote_ty!( ::core::pipes::Packet<$ty> );\n \n@@ -427,6 +431,11 @@ pub impl gen_init for protocol {\n             }\n         };\n \n+        let generics = Generics {\n+            lifetimes: opt_vec::Empty,\n+            ty_params: params\n+        };\n+\n         cx.item_struct_poly(\n             cx.ident_of(~\"__Buffer\"),\n             dummy_sp(),\n@@ -435,7 +444,7 @@ pub impl gen_init for protocol {\n                 dtor: None,\n                 ctor_id: None\n             },\n-            cx.strip_bounds(params))\n+            cx.strip_bounds(&generics))\n     }\n \n     fn compile(&self, cx: ext_ctxt) -> @ast::item {"}, {"sha": "6052e20e6e9175f0d0f370b3624bde43da1232c1", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -61,9 +61,9 @@ pub impl message {\n     }\n \n     /// Return the type parameters actually used by this message\n-    fn get_params(&mut self) -> ~[ast::ty_param] {\n+    fn get_generics(&self) -> ast::Generics {\n         match *self {\n-          message(_, _, _, this, _) => this.ty_params\n+          message(_, _, _, this, _) => this.generics\n         }\n     }\n }\n@@ -76,7 +76,7 @@ pub struct state_ {\n     ident: ast::ident,\n     span: span,\n     dir: direction,\n-    ty_params: ~[ast::ty_param],\n+    generics: ast::Generics,\n     messages: @mut ~[message],\n     proto: protocol\n }\n@@ -100,7 +100,7 @@ pub impl state_ {\n     fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(self.ty_params)))\n+                cx.ty_vars(&self.generics.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n@@ -161,7 +161,7 @@ pub impl protocol_ {\n \n     fn has_ty_params(&mut self) -> bool {\n         for self.states.each |s| {\n-            if s.ty_params.len() > 0 {\n+            if s.generics.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n@@ -175,7 +175,7 @@ pub impl protocol_ {\n \n pub impl protocol {\n     fn add_state_poly(&self, name: ~str, ident: ast::ident, dir: direction,\n-                      +ty_params: ~[ast::ty_param]) -> state {\n+                      +generics: ast::Generics) -> state {\n         let messages = @mut ~[];\n \n         let state = @state_ {\n@@ -184,7 +184,7 @@ pub impl protocol {\n             ident: ident,\n             span: self.span,\n             dir: dir,\n-            ty_params: ty_params,\n+            generics: generics,\n             messages: messages,\n             proto: *self\n         };"}, {"sha": "b313d42e81260a06ad3a17b86861b518b450b327", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -50,12 +50,12 @@ pub mod rt {\n     use print::pprust::{item_to_str, ty_to_str};\n \n     trait ToTokens {\n-        pub fn to_tokens(_cx: ext_ctxt) -> ~[token_tree];\n+        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        pub fn to_tokens(_cx: ext_ctxt) -> ~[token_tree] {\n-            copy self\n+        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree] {\n+            copy *self\n         }\n     }\n \n@@ -75,91 +75,91 @@ pub mod rt {\n \n     trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: ext_ctxt) -> ~str;\n+        pub fn to_source(&self, cx: ext_ctxt) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            copy *cx.parse_sess().interner.get(self)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            copy *cx.parse_sess().interner.get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            item_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            item_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::item] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            ty_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            ty_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::Ty] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n         }\n     }\n \n-    impl ToSource for ~[ast::ty_param] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            pprust::typarams_to_str(self, cx.parse_sess().interner)\n+    impl ToSource for Generics {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            pprust::generics_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            pprust::expr_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            pprust::expr_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::item {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::item] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::Ty] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n-    impl ToTokens for ~[ast::ty_param] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+    impl ToTokens for Generics {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }"}, {"sha": "acc1054aa713e9ba1092c32b29c0ee89906ed559", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -130,21 +130,38 @@ pub fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     }\n }\n \n-fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n+fn fold_ty_param_bound(tpb: TyParamBound, fld: ast_fold) -> TyParamBound {\n     match tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    ast::ty_param { ident: /* FIXME (#2543) */ copy tp.ident,\n-                    id: fld.new_id(tp.id),\n-                    bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld) )}\n+pub fn fold_ty_param(tp: TyParam, fld: ast_fold) -> TyParam {\n+    TyParam {ident: tp.ident,\n+             id: fld.new_id(tp.id),\n+             bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld))}\n }\n \n-pub fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n-    tps.map(|x| fold_ty_param(*x, fld))\n+pub fn fold_ty_params(tps: &OptVec<TyParam>,\n+                      fld: ast_fold) -> OptVec<TyParam> {\n+    tps.map(|tp| fold_ty_param(*tp, fld))\n+}\n+\n+pub fn fold_lifetime(l: &Lifetime, fld: ast_fold) -> Lifetime {\n+    Lifetime {id: fld.new_id(l.id),\n+              span: fld.new_span(l.span),\n+              ident: l.ident}\n+}\n+\n+pub fn fold_lifetimes(lts: &OptVec<Lifetime>,\n+                      fld: ast_fold) -> OptVec<Lifetime> {\n+    lts.map(|l| fold_lifetime(l, fld))\n+}\n+\n+pub fn fold_generics(generics: &Generics, fld: ast_fold) -> Generics {\n+    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n+              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n pub fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n@@ -173,15 +190,15 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n         attrs: vec::map(ni.attrs, |x| fold_attribute(*x)),\n         node:\n             match ni.node {\n-                foreign_item_fn(fdec, purity, typms) => {\n+                foreign_item_fn(fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n                             inputs: fdec.inputs.map(|a| fold_arg(*a)),\n                             output: fld.fold_ty(fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n-                        fold_ty_params(typms, fld))\n+                        fold_generics(generics, fld))\n                 }\n                 foreign_item_const(t) => {\n                     foreign_item_const(fld.fold_ty(t))\n@@ -218,20 +235,20 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n         item_fn(ref decl, purity, ref typms, ref body) => {\n             item_fn(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                     purity,\n-                    fold_ty_params(/* FIXME (#2543) */ copy *typms, fld),\n+                    fold_generics(typms, fld),\n                     fld.fold_block(*body))\n         }\n         item_mod(m) => item_mod(fld.fold_mod(m)),\n         item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n-        item_ty(t, typms) => item_ty(fld.fold_ty(t),\n-                                     fold_ty_params(typms, fld)),\n+        item_ty(t, ref typms) => item_ty(fld.fold_ty(t),\n+                                     fold_generics(typms, fld)),\n         item_enum(ref enum_definition, ref typms) => {\n             item_enum(ast::enum_def(ast::enum_def_ {\n                 variants: enum_definition.variants.map(\n                     |x| fld.fold_variant(*x)),\n                 common: enum_definition.common.map(\n                     |x| fold_struct_def(*x, fld)),\n-            }), fold_ty_params(/* FIXME (#2543) */ copy *typms, fld))\n+            }), fold_generics(typms, fld))\n         }\n         item_struct(ref struct_def, ref typms) => {\n             let struct_def = fold_struct_def(\n@@ -240,7 +257,7 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_struct(struct_def, /* FIXME (#2543) */ copy *typms)\n         }\n         item_impl(ref tps, ifce, ty, ref methods) => {\n-            item_impl(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n+            item_impl(fold_generics(tps, fld),\n                       ifce.map(|p| fold_trait_ref(*p, fld)),\n                       fld.fold_ty(ty),\n                       methods.map(|x| fld.fold_method(*x)))\n@@ -252,7 +269,7 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n-            item_trait(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n+            item_trait(fold_generics(tps, fld),\n                        traits.map(|p| fold_trait_ref(*p, fld)),\n                        methods)\n         }\n@@ -298,7 +315,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n-        tps: fold_ty_params(m.tps, fld),\n+        generics: fold_generics(&m.generics, fld),\n         self_ty: m.self_ty,\n         purity: m.purity,\n         decl: fold_fn_decl(m.decl, fld),"}, {"sha": "22d69d89e8163d34ddd2c80d56a19b2ce772cbff", "filename": "src/libsyntax/opt_vec.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ *\n+ * Defines a type OptVec<T> that can be used in place of ~[T].\n+ * OptVec avoids the need for allocation for empty vectors.\n+ * OptVec implements the iterable interface as well as\n+ * other useful things like `push()` and `len()`.\n+ */\n+\n+use core::prelude::*;\n+use core::iter;\n+use core::iter::BaseIter;\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub enum OptVec<T> {\n+    Empty,\n+    Vec(~[T])\n+}\n+\n+pub fn with<T>(+t: T) -> OptVec<T> {\n+    Vec(~[t])\n+}\n+\n+impl<T> OptVec<T> {\n+    fn push(&mut self, +t: T) {\n+        match *self {\n+            Vec(ref mut v) => {\n+                v.push(t);\n+                return;\n+            }\n+            Empty => {}\n+        }\n+\n+        // FIXME(#5074): flow insensitive means we can't move\n+        // assignment inside `match`\n+        *self = Vec(~[t]);\n+    }\n+\n+    fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+        match *self {\n+            Empty => Empty,\n+            Vec(ref v) => Vec(v.map(op))\n+        }\n+    }\n+\n+    pure fn get(&self, i: uint) -> &self/T {\n+        match *self {\n+            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n+            Vec(ref v) => &v[i]\n+        }\n+    }\n+\n+    pure fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pure fn len(&self) -> uint {\n+        match *self {\n+            Empty => 0,\n+            Vec(ref v) => v.len()\n+        }\n+    }\n+\n+    pure fn to_vec(self) -> ~[T] {\n+        match self {\n+            Empty => ~[],\n+            Vec(v) => v\n+        }\n+    }\n+}\n+\n+impl<T:Copy> OptVec<T> {\n+    fn prepend(&self, +t: T) -> OptVec<T> {\n+        let mut v0 = ~[t];\n+        match *self {\n+            Empty => {}\n+            Vec(v1) => { v0.push_all(v1); }\n+        }\n+        return Vec(v0);\n+    }\n+\n+    fn push_all<I: BaseIter<T>>(&mut self, from: &I) {\n+        for from.each |e| {\n+            self.push(copy *e);\n+        }\n+    }\n+}\n+\n+impl<A:Eq> Eq for OptVec<A> {\n+    pure fn eq(&self, other: &OptVec<A>) -> bool {\n+        // Note: cannot use #[deriving_eq] here because\n+        // (Empty, Vec(~[])) ought to be equal.\n+        match (self, other) {\n+            (&Empty, &Empty) => true,\n+            (&Empty, &Vec(ref v)) => v.is_empty(),\n+            (&Vec(ref v), &Empty) => v.is_empty(),\n+            (&Vec(ref v1), &Vec(ref v2)) => *v1 == *v2\n+        }\n+    }\n+\n+    pure fn ne(&self, other: &OptVec<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl<A> BaseIter<A> for OptVec<A> {\n+    pure fn each(&self, blk: fn(v: &A) -> bool) {\n+        match *self {\n+            Empty => {}\n+            Vec(ref v) => v.each(blk)\n+        }\n+    }\n+\n+    pure fn size_hint(&self) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n+\n+impl<A> iter::ExtendedIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn eachi(&self, blk: fn(+v: uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn foldl<B>(&self, +b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    #[inline(always)]\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    #[inline(always)]\n+    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    #[inline(always)]\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n+    }\n+\n+}\n+\n+impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    #[inline(always)]\n+    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+}\n+\n+impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n+    }\n+    #[inline(always)]\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    #[inline(always)]\n+    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n+    }\n+}\n+\n+impl<A: Copy+Ord> iter::CopyableOrderedIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn min(&self) -> A { iter::min(self) }\n+    #[inline(always)]\n+    pure fn max(&self) -> A { iter::max(self) }\n+}"}, {"sha": "a92eb2db42aa259dd8357d871365b0b64eedee15", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -20,6 +20,9 @@ use core::option::{None, Option, Some};\n use core::option;\n use std::oldmap::HashMap;\n \n+use opt_vec;\n+use opt_vec::OptVec;\n+\n // SeqSep : a sequence separator (token)\n // and whether a trailing separator is allowed.\n pub struct SeqSep {\n@@ -221,10 +224,10 @@ pub impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    fn parse_seq_to_before_gt<T:Copy>(sep: Option<token::Token>,\n-                                       f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n+                                       f: fn(Parser) -> T) -> OptVec<T> {\n         let mut first = true;\n-        let mut v = ~[];\n+        let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n             && *self.token != token::BINOP(token::SHR) {\n             match sep {\n@@ -236,29 +239,16 @@ pub impl Parser {\n             }\n             v.push(f(self));\n         }\n-\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T:Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_gt<T: Copy>(sep: Option<token::Token>,\n+                                f: fn(Parser) -> T) -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n-\n         return v;\n     }\n \n-    // parse a sequence bracketed by '<' and '>'\n-    fn parse_seq_lt_gt<T:Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> spanned<~[T]> {\n-        let lo = self.span.lo;\n-        self.expect(token::LT);\n-        let result = self.parse_seq_to_before_gt::<T>(sep, f);\n-        let hi = self.span.hi;\n-        self.expect_gt();\n-        return spanned(lo, hi, result);\n-    }\n-\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket."}, {"sha": "d4b7f2ae5b4e31eecafce2ad31643495a11367b5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 117, "deletions": 140, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -51,7 +51,7 @@ use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n use ast::{ty_infer, ty_mac, ty_method};\n-use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr};\n+use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rec, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n use ast::{view_item_, view_item_extern_mod, view_item_use};\n@@ -83,6 +83,8 @@ use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use print::pprust::expr_to_str;\n use util::interner::Interner;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::cmp;\n use core::either::{Either, Left, Right};\n@@ -438,7 +440,7 @@ pub impl Parser {\n             // could change.\n             let ident = p.parse_method_name();\n \n-            let tps = p.parse_ty_params();\n+            let generics = p.parse_generics();\n \n             let (self_ty, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n@@ -463,7 +465,7 @@ pub impl Parser {\n                     attrs: attrs,\n                     purity: pur,\n                     decl: d,\n-                    tps: tps,\n+                    generics: generics,\n                     self_ty: self_ty,\n                     id: p.get_id(),\n                     span: mk_sp(lo, hi)\n@@ -477,7 +479,7 @@ pub impl Parser {\n                 provided(@ast::method {\n                     ident: ident,\n                     attrs: attrs,\n-                    tps: tps,\n+                    generics: generics,\n                     self_ty: self_ty,\n                     purity: pur,\n                     decl: d,\n@@ -917,19 +919,7 @@ pub impl Parser {\n         };\n \n         // Parse any lifetime or type parameters which may appear:\n-        let tps = {\n-            if !self.eat(token::LT) {\n-                ~[]\n-            } else {\n-                // First consume lifetimes.\n-                let _lifetimes = self.parse_lifetimes();\n-                let result = self.parse_seq_to_gt(\n-                    Some(token::COMMA),\n-                    |p| p.parse_ty(false));\n-                result\n-            }\n-        };\n-\n+        let tps = self.parse_generic_values();\n         let hi = self.span.lo;\n \n         @ast::path { span: mk_sp(lo, hi),\n@@ -975,7 +965,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_lifetimes() -> ~[ast::Lifetime] {\n+    fn parse_lifetimes() -> OptVec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -984,7 +974,7 @@ pub impl Parser {\n          * lists, where we expect something like `<'a, 'b, T>`.\n          */\n \n-        let mut res = ~[];\n+        let mut res = opt_vec::Empty;\n         loop {\n             match *self.token {\n                 token::LIFETIME(_) => {\n@@ -1155,7 +1145,7 @@ pub impl Parser {\n                     let remaining_exprs =\n                         self.parse_seq_to_end(token::RBRACKET,\n                             seq_sep_trailing_allowed(token::COMMA),\n-                            |p| p.parse_expr());\n+                            |p| p.parse_expr()).to_vec();\n                     ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n@@ -1287,8 +1277,7 @@ pub impl Parser {\n                     self.bump();\n                     let tys = if self.eat(token::MOD_SEP) {\n                         self.expect(token::LT);\n-                        self.parse_seq_to_gt(Some(token::COMMA),\n-                                             |p| p.parse_ty(false))\n+                        self.parse_generic_values_after_lt()\n                     } else {\n                         ~[]\n                     };\n@@ -1418,7 +1407,7 @@ pub impl Parser {\n                 vec::append(\n                     self.parse_seq_to_before_end(\n                         ket, seq_sep_none(),\n-                        |p| p.parse_token_tree()),\n+                        |p| p.parse_token_tree()).to_vec(),\n                     // the close delimiter:\n                     ~[parse_any_tt_tok(self)])))\n           }\n@@ -2624,81 +2613,105 @@ pub impl Parser {\n         if self.eat_keyword(~\"once\") { ast::Once } else { ast::Many }\n     }\n \n-    fn parse_optional_ty_param_bounds() -> @~[ty_param_bound] {\n-        let mut bounds = ~[];\n-        if self.eat(token::COLON) {\n-            loop {\n-                if self.eat(token::BINOP(token::AND)) {\n-                    if self.eat_keyword(~\"static\") {\n-                        bounds.push(RegionTyParamBound);\n-                    } else {\n-                        self.span_err(*self.span,\n-                                      ~\"`&static` is the only permissible \\\n-                                        region bound here\");\n-                    }\n-                } else if is_ident(*self.token) {\n-                    let maybe_bound = match *self.token {\n-                      token::IDENT(copy sid, _) => {\n+    fn parse_optional_ty_param_bounds() -> @OptVec<TyParamBound> {\n+        if !self.eat(token::COLON) {\n+            return @opt_vec::Empty;\n+        }\n+\n+        let mut result = opt_vec::Empty;\n+        loop {\n+            if self.eat(token::BINOP(token::AND)) {\n+                if self.eat_keyword(~\"static\") {\n+                    result.push(RegionTyParamBound);\n+                } else {\n+                    self.span_err(*self.span,\n+                                  ~\"`&static` is the only permissible \\\n+                                    region bound here\");\n+                }\n+            } else if is_ident(*self.token) {\n+                let maybe_bound = match *self.token {\n+                    token::IDENT(sid, _) => {\n                         match *self.id_to_str(sid) {\n+                            ~\"send\" |\n+                            ~\"copy\" |\n+                            ~\"const\" |\n+                            ~\"owned\" => {\n+                                self.obsolete(\n+                                    *self.span,\n+                                    ObsoleteLowerCaseKindBounds);\n+\n+                                // Bogus value, but doesn't matter, since\n+                                // is an error\n+                                Some(TraitTyParamBound(\n+                                    self.mk_ty_path(sid)))\n+                            }\n \n-                          ~\"send\"\n-                          | ~\"copy\"\n-                          | ~\"const\"\n-                          | ~\"owned\" => {\n-                            self.obsolete(*self.span,\n-                                          ObsoleteLowerCaseKindBounds);\n-                            // Bogus value, but doesn't matter, since\n-                            // is an error\n-                            Some(TraitTyParamBound(self.mk_ty_path(sid)))\n-                          }\n-\n-                          _ => None\n+                            _ => None\n                         }\n-                      }\n-                      _ => self.bug(\n-                          ~\"is_ident() said this would be an identifier\")\n-                    };\n+                    }\n+                    _ => fail!()\n+                };\n \n-                    match maybe_bound {\n-                        Some(bound) => {\n-                            self.bump();\n-                            bounds.push(bound);\n-                        }\n-                        None => {\n-                            let ty = self.parse_ty(false);\n-                            bounds.push(TraitTyParamBound(ty));\n-                        }\n+                match maybe_bound {\n+                    Some(bound) => {\n+                        self.bump();\n+                        result.push(bound);\n+                    }\n+                    None => {\n+                        let ty = self.parse_ty(false);\n+                        result.push(TraitTyParamBound(ty));\n                     }\n-                } else {\n-                    break;\n                 }\n+            } else {\n+                break;\n+            }\n \n-                if self.eat(token::BINOP(token::PLUS)) {\n-                    loop;\n-                }\n+            if self.eat(token::BINOP(token::PLUS)) {\n+                loop;\n+            }\n \n-                if is_ident_or_path(*self.token) {\n-                    self.obsolete(*self.span,\n-                                  ObsoleteTraitBoundSeparator);\n-                }\n+            if is_ident_or_path(*self.token) {\n+                self.obsolete(*self.span,\n+                              ObsoleteTraitBoundSeparator);\n             }\n         }\n-        return @bounds;\n+\n+        return @result;\n     }\n \n-    fn parse_ty_param() -> ty_param {\n+    fn parse_ty_param() -> TyParam {\n         let ident = self.parse_ident();\n         let bounds = self.parse_optional_ty_param_bounds();\n-        ast::ty_param { ident: ident, id: self.get_id(), bounds: bounds }\n+        ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n-    fn parse_ty_params() -> ~[ty_param] {\n+    fn parse_generics() -> ast::Generics {\n         if self.eat(token::LT) {\n-            let _lifetimes = self.parse_lifetimes();\n-            self.parse_seq_to_gt(\n+            let lifetimes = self.parse_lifetimes();\n+            let ty_params = self.parse_seq_to_gt(\n                 Some(token::COMMA),\n-                |p| p.parse_ty_param())\n-        } else { ~[] }\n+                |p| p.parse_ty_param());\n+            return ast::Generics {lifetimes: lifetimes,\n+                                  ty_params: ty_params};\n+        } else {\n+            return ast_util::empty_generics();\n+        }\n+    }\n+\n+    fn parse_generic_values() -> ~[@Ty] {\n+        if !self.eat(token::LT) {\n+            ~[]\n+        } else {\n+            self.parse_generic_values_after_lt()\n+        }\n+    }\n+\n+    fn parse_generic_values_after_lt() -> ~[@Ty] {\n+        let _lifetimes = self.parse_lifetimes();\n+        let result = self.parse_seq_to_gt(\n+            Some(token::COMMA),\n+            |p| p.parse_ty(false));\n+        result.to_vec()\n     }\n \n     fn parse_fn_decl(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n@@ -2790,7 +2803,7 @@ pub impl Parser {\n                     args_or_capture_items =\n                         self.parse_seq_to_before_end(token::RPAREN,\n                                                      sep,\n-                                                     parse_arg_fn);\n+                                                     parse_arg_fn).to_vec();\n                 }\n                 token::RPAREN => {\n                     args_or_capture_items = ~[];\n@@ -2806,7 +2819,7 @@ pub impl Parser {\n             args_or_capture_items =\n                 self.parse_seq_to_before_end(token::RPAREN,\n                                              sep,\n-                                             parse_arg_fn);\n+                                             parse_arg_fn).to_vec();\n         }\n \n         self.expect(token::RPAREN);\n@@ -2849,10 +2862,10 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_fn_header() -> (ident, ~[ty_param]) {\n+    fn parse_fn_header() -> (ident, ast::Generics) {\n         let id = self.parse_value_ident();\n-        let ty_params = self.parse_ty_params();\n-        (id, ty_params)\n+        let generics = self.parse_generics();\n+        (id, generics)\n     }\n \n     fn mk_item(+lo: BytePos, +hi: BytePos, +ident: ident,\n@@ -2867,10 +2880,10 @@ pub impl Parser {\n     }\n \n     fn parse_item_fn(purity: purity) -> item_info {\n-        let (ident, tps) = self.parse_fn_header();\n+        let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (ident, item_fn(decl, purity, tps, body), Some(inner_attrs))\n+        (ident, item_fn(decl, purity, generics, body), Some(inner_attrs))\n     }\n \n     fn parse_method_name() -> ident {\n@@ -2887,7 +2900,7 @@ pub impl Parser {\n         let visa = self.parse_visibility();\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n-        let tps = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         let (self_ty, decl) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n@@ -2899,7 +2912,7 @@ pub impl Parser {\n         @ast::method {\n             ident: ident,\n             attrs: attrs,\n-            tps: tps,\n+            generics: generics,\n             self_ty: self_ty,\n             purity: pur,\n             decl: decl,\n@@ -2914,7 +2927,7 @@ pub impl Parser {\n     fn parse_item_trait() -> item_info {\n         let ident = self.parse_ident();\n         self.parse_region_param();\n-        let tps = self.parse_ty_params();\n+        let tps = self.parse_generics();\n \n         // Parse traits, if necessary.\n         let traits;\n@@ -2942,12 +2955,7 @@ pub impl Parser {\n         }\n \n         // First, parse type parameters if necessary.\n-        let mut tps;\n-        if *self.token == token::LT {\n-            tps = self.parse_ty_params();\n-        } else {\n-            tps = ~[];\n-        }\n+        let generics = self.parse_generics();\n \n         // This is a new-style impl declaration.\n         // XXX: clownshoes\n@@ -2989,37 +2997,7 @@ pub impl Parser {\n             }\n         }\n \n-        (ident, item_impl(tps, opt_trait, ty, meths), None)\n-    }\n-\n-    // Instantiates ident <i> with references to <typarams> as arguments.\n-    // Used to create a path that refers to a class which will be defined as\n-    // the return type of the ctor function.\n-    fn ident_to_path_tys(i: ident,\n-                         typarams: ~[ty_param]) -> @path {\n-        let s = *self.last_span;\n-\n-        @ast::path {\n-             span: s,\n-             global: false,\n-             idents: ~[i],\n-             rp: None,\n-             types: do typarams.map |tp| {\n-                @Ty {\n-                    id: self.get_id(),\n-                    node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n-                    span: s\n-                }\n-            }\n-         }\n-    }\n-\n-    fn ident_to_path(i: ident) -> @path {\n-        @ast::path { span: *self.last_span,\n-                     global: false,\n-                     idents: ~[i],\n-                     rp: None,\n-                     types: ~[] }\n+        (ident, item_impl(generics, opt_trait, ty, meths), None)\n     }\n \n     fn parse_trait_ref() -> @trait_ref {\n@@ -3032,13 +3010,13 @@ pub impl Parser {\n     fn parse_trait_ref_list(ket: token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             ket, seq_sep_none(),\n-            |p| p.parse_trait_ref())\n+            |p| p.parse_trait_ref()).to_vec()\n     }\n \n     fn parse_item_struct() -> item_info {\n         let class_name = self.parse_value_ident();\n         self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         if self.eat(token::COLON) {\n             self.obsolete(*self.span, ObsoleteClassTraits);\n             let _ = self.parse_trait_ref_list(token::LBRACE);\n@@ -3115,7 +3093,7 @@ pub impl Parser {\n              fields: fields,\n              dtor: actual_dtor,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None }\n-         }, ty_params),\n+         }, generics),\n          None)\n     }\n \n@@ -3379,13 +3357,13 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n-        let (ident, tps) = self.parse_fn_header();\n+        let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n-                             node: foreign_item_fn(decl, purity, tps),\n+                             node: foreign_item_fn(decl, purity, generics),\n                              id: self.get_id(),\n                              span: mk_sp(lo, hi),\n                              vis: vis }\n@@ -3548,7 +3526,7 @@ pub impl Parser {\n     fn parse_item_type() -> item_info {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n-        let tps = self.parse_ty_params();\n+        let tps = self.parse_generics();\n         self.expect(token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(token::SEMI);\n@@ -3604,8 +3582,7 @@ pub impl Parser {\n         };\n     }\n \n-    fn parse_enum_def(ty_params: ~[ast::ty_param])\n-                   -> enum_def {\n+    fn parse_enum_def(+generics: ast::Generics) -> enum_def {\n         let mut variants: ~[variant] = ~[];\n         let mut all_nullary = true, have_disr = false;\n         let mut common_fields = None;\n@@ -3632,7 +3609,7 @@ pub impl Parser {\n             if self.eat_keyword(~\"enum\") {\n                 ident = self.parse_ident();\n                 self.expect(token::LBRACE);\n-                let nested_enum_def = self.parse_enum_def(ty_params);\n+                let nested_enum_def = self.parse_enum_def(generics);\n                 kind = enum_variant_kind(nested_enum_def);\n                 needs_comma = false;\n             } else {\n@@ -3688,7 +3665,7 @@ pub impl Parser {\n     fn parse_item_enum() -> item_info {\n         let id = self.parse_ident();\n         self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         // Newtype syntax\n         if *self.token == token::EQ {\n             self.bump();\n@@ -3711,14 +3688,14 @@ pub impl Parser {\n                     enum_def(\n                         ast::enum_def_ { variants: ~[variant], common: None }\n                     ),\n-                    ty_params),\n+                    generics),\n                 None\n             );\n         }\n         self.expect(token::LBRACE);\n \n-        let enum_definition = self.parse_enum_def(ty_params);\n-        (id, item_enum(enum_definition, ty_params), None)\n+        let enum_definition = self.parse_enum_def(generics);\n+        (id, item_enum(enum_definition, generics), None)\n     }\n \n     fn parse_fn_ty_sigil() -> Option<Sigil> {"}, {"sha": "5eb40626437ea7ee894b518df455038c05593828", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -14,6 +14,8 @@ use ast::{RegionTyParamBound, TraitTyParamBound, required, provided};\n use ast;\n use ast_util;\n use ast_util::{operator_prec};\n+use opt_vec;\n+use opt_vec::OptVec;\n use attr;\n use codemap::{CodeMap, BytePos};\n use codemap;\n@@ -164,19 +166,20 @@ pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n-pub fn typarams_to_str(tps: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n-    to_str(tps, print_type_params, intr)\n+pub fn generics_to_str(generics: &ast::Generics,\n+                       intr: @ident_interner) -> ~str {\n+    to_str(generics, print_generics, intr)\n }\n \n pub fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n-                  params: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n+                  generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        print_fn(s, decl, None, name, params, None, ast::inherited);\n+        print_fn(s, decl, None, name, generics, None, ast::inherited);\n         end(s); // Close the head box\n         end(s); // Close the outer box\n         eof(s.s);\n@@ -300,7 +303,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN)) {\n+pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -459,8 +462,8 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n-      ast::foreign_item_fn(decl, purity, typarams) => {\n-        print_fn(s, decl, Some(purity), item.ident, typarams, None,\n+      ast::foreign_item_fn(decl, purity, ref generics) => {\n+        print_fn(s, decl, Some(purity), item.ident, generics, None,\n                  ast::inherited);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n@@ -505,7 +508,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             /* FIXME (#2543) */ copy *decl,\n             Some(purity),\n             item.ident,\n-            /* FIXME (#2543) */ copy *typarams,\n+            typarams,\n             None,\n             item.vis\n         );\n@@ -536,12 +539,12 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, params) => {\n+      ast::item_ty(ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, ~\"type\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, params);\n+        print_generics(s, params);\n         end(s); // end the inner ibox\n \n         space(s.s);\n@@ -554,21 +557,21 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         print_enum_def(\n             s,\n             *enum_definition,\n-            /* FIXME (#2543) */ copy *params,\n+            params,\n             item.ident,\n             item.span,\n             item.vis\n         );\n       }\n-      ast::item_struct(struct_def, tps) => {\n+      ast::item_struct(struct_def, ref generics) => {\n           head(s, visibility_qualified(item.vis, ~\"struct\"));\n-          print_struct(s, struct_def, tps, item.ident, item.span);\n+          print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(tps, opt_trait, ty, methods) => {\n+      ast::item_impl(ref generics, opt_trait, ty, methods) => {\n         head(s, visibility_qualified(item.vis, ~\"impl\"));\n-        if !tps.is_empty() {\n-            print_type_params(s, tps);\n+        if !generics.is_empty() {\n+            print_generics(s, generics);\n             space(s.s);\n         }\n \n@@ -594,10 +597,10 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_trait(ref tps, ref traits, ref methods) => {\n+      ast::item_trait(ref generics, ref traits, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, /* FIXME (#2543) */ copy *tps);\n+        print_generics(s, generics);\n         if traits.len() != 0u {\n             word(s.s, ~\":\");\n             for traits.each |trait_| {\n@@ -629,7 +632,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n-                      params: ~[ast::ty_param], ident: ast::ident,\n+                      generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n     let mut newtype =\n         vec::len(enum_definition.variants) == 1u &&\n@@ -648,7 +651,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n     }\n \n     print_ident(s, ident);\n-    print_type_params(s, params);\n+    print_generics(s, generics);\n     space(s.s);\n     if newtype {\n         word_space(s, ~\"=\");\n@@ -706,12 +709,12 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n \n pub fn print_struct(s: @ps,\n                     struct_def: @ast::struct_def,\n-                    tps: ~[ast::ty_param],\n+                    generics: &ast::Generics,\n                     ident: ast::ident,\n                     span: codemap::span) {\n     print_ident(s, ident);\n     nbsp(s);\n-    print_type_params(s, tps);\n+    print_generics(s, generics);\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         popen(s);\n         let mut first = true;\n@@ -823,7 +826,8 @@ pub fn print_variant(s: @ps, v: ast::variant) {\n         }\n         ast::struct_variant_kind(struct_def) => {\n             head(s, ~\"\");\n-            print_struct(s, struct_def, ~[], v.node.name, v.span);\n+            let generics = ast_util::empty_generics();\n+            print_struct(s, struct_def, &generics, v.node.name, v.span);\n         }\n         ast::enum_variant_kind(ref enum_definition) => {\n             print_variants(s, (*enum_definition).variants, v.span);\n@@ -844,7 +848,7 @@ pub fn print_ty_method(s: @ps, m: ast::ty_method) {\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n-                m.decl, Some(m.ident), Some(m.tps),\n+                m.decl, Some(m.ident), Some(&m.generics),\n                 Some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n@@ -861,7 +865,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n     print_fn(s, meth.decl, Some(meth.purity),\n-             meth.ident, meth.tps, Some(meth.self_ty.node),\n+             meth.ident, &meth.generics, Some(meth.self_ty.node),\n              meth.vis);\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n@@ -1714,14 +1718,14 @@ pub fn print_fn(s: @ps,\n                 decl: ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 name: ast::ident,\n-                typarams: ~[ast::ty_param],\n+                generics: &ast::Generics,\n                 opt_self_ty: Option<ast::self_ty_>,\n                 vis: ast::visibility) {\n     head(s, ~\"\");\n     print_fn_header_info(s, opt_self_ty, purity, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n-    print_type_params(s, typarams);\n+    print_generics(s, generics);\n     print_fn_args_and_ret(s, decl, opt_self_ty);\n }\n \n@@ -1791,34 +1795,53 @@ pub fn print_arg_mode(s: @ps, m: ast::mode) {\n     if ms != ~\"\" { word(s.s, ms); }\n }\n \n-pub fn print_bounds(s: @ps, bounds: @~[ast::ty_param_bound]) {\n+pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n         let mut first = true;\n-        for vec::each(*bounds) |&bound| {\n+        for bounds.each |bound| {\n             nbsp(s);\n             if first {\n                 first = false;\n             } else {\n                 word_space(s, ~\"+\");\n             }\n \n-            match bound {\n+            match *bound {\n                 TraitTyParamBound(ty) => print_type(s, ty),\n                 RegionTyParamBound => word(s.s, ~\"&static\"),\n             }\n         }\n     }\n }\n \n-pub fn print_type_params(s: @ps, &&params: ~[ast::ty_param]) {\n-    if vec::len(params) > 0u {\n+pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n+    word(s.s, ~\"'\");\n+    print_ident(s, lifetime.ident);\n+}\n+\n+pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n+    let total = generics.lifetimes.len() + generics.ty_params.len();\n+    if total > 0 {\n         word(s.s, ~\"<\");\n-        fn printParam(s: @ps, param: ast::ty_param) {\n-            print_ident(s, param.ident);\n-            print_bounds(s, param.bounds);\n+        fn print_item(s: @ps, generics: &ast::Generics, idx: uint) {\n+            if idx < generics.lifetimes.len() {\n+                let lifetime = generics.lifetimes.get(idx);\n+                print_lifetime(s, lifetime);\n+            } else {\n+                let param = generics.ty_params.get(idx);\n+                print_ident(s, param.ident);\n+                print_bounds(s, param.bounds);\n+            }\n         }\n-        commasep(s, inconsistent, params, printParam);\n+\n+        let mut ints = ~[];\n+        for uint::range(0, total) |i| {\n+            ints.push(i);\n+        }\n+\n+        commasep(s, inconsistent, ints,\n+                 |s, i| print_item(s, generics, i));\n         word(s.s, ~\">\");\n     }\n }\n@@ -1954,7 +1977,7 @@ pub fn print_ty_fn(s: @ps,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: ast::fn_decl, id: Option<ast::ident>,\n-                   tps: Option<~[ast::ty_param]>,\n+                   generics: Option<&ast::Generics>,\n                    opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n \n@@ -1968,7 +1991,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match tps { Some(tps) => print_type_params(s, tps), _ => () }\n+    match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n@@ -2301,7 +2324,8 @@ pub mod test {\n                               span: codemap::dummy_sp()},\n             cf: ast::return_val\n         };\n-        check_equal (&fun_to_str(decl, abba_ident, ~[],mock_interner),\n+        let generics = ast_util::empty_generics();\n+        check_equal (&fun_to_str(decl, abba_ident, &generics, mock_interner),\n                      &~\"fn abba()\");\n     }\n "}, {"sha": "9eb7507f3d0d71827c926da2e2b80ffac2ee8368", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -35,6 +35,7 @@ pub mod syntax {\n     pub use parse;\n }\n \n+pub mod opt_vec;\n pub mod attr;\n pub mod diagnostic;\n pub mod codemap;"}, {"sha": "95a6500955dd9f75e20debf86cb7d5490c8a4149", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c623d21e388315df672951fcb8efb5000923ab3d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c623d21e388315df672951fcb8efb5000923ab3d", "patch": "@@ -15,6 +15,7 @@ use ast;\n use ast_util;\n use codemap::span;\n use parse;\n+use opt_vec;\n \n use core::option;\n use core::vec;\n@@ -30,11 +31,11 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, ~[ty_param], purity), // fn foo()\n-    fk_method(ident, ~[ty_param], @method), // fn foo(&self)\n+    fk_item_fn(ident, Generics, purity), // fn foo()\n+    fk_method(ident, Generics, @method), // fn foo(&self)\n     fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n     fk_fn_block,                            // |x, y| ...\n-    fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n+    fk_dtor(Generics, ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n }\n@@ -49,13 +50,17 @@ pub fn name_of_fn(fk: fn_kind) -> ident {\n     }\n }\n \n-pub fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n+pub fn generics_of_fn(fk: fn_kind) -> Generics {\n     match fk {\n-        fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n+        fk_item_fn(_, tps, _) |\n+        fk_method(_, tps, _) |\n         fk_dtor(tps, _, _, _) => {\n-            /* FIXME (#2543) */ copy tps\n+            copy tps\n+        }\n+        fk_anon(*) | fk_fn_block(*) => {\n+            Generics {lifetimes: opt_vec::Empty,\n+                      ty_params: opt_vec::Empty}\n         }\n-        fk_anon(*) | fk_fn_block(*) => ~[]\n     }\n }\n \n@@ -73,11 +78,11 @@ pub struct Visitor<E> {\n     visit_expr: fn@(@expr, E, vt<E>),\n     visit_expr_post: fn@(@expr, E, vt<E>),\n     visit_ty: fn@(@Ty, E, vt<E>),\n-    visit_ty_params: fn@(~[ty_param], E, vt<E>),\n+    visit_generics: fn@(&Generics, E, vt<E>),\n     visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n     visit_ty_method: fn@(ty_method, E, vt<E>),\n     visit_trait_method: fn@(trait_method, E, vt<E>),\n-    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id, E,\n+    visit_struct_def: fn@(@struct_def, ident, &Generics, node_id, E,\n                           vt<E>),\n     visit_struct_field: fn@(@struct_field, E, vt<E>),\n     visit_struct_method: fn@(@method, E, vt<E>)\n@@ -100,7 +105,7 @@ pub fn default_visitor<E>() -> visitor<E> {\n         visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n         visit_expr_post: |_a,_b,_c| (),\n         visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n-        visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n+        visit_generics: |a,b,c|visit_generics::<E>(a, b, c),\n         visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n         visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n         visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n@@ -157,21 +162,21 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n         for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n       }\n-      item_ty(t, tps) => {\n+      item_ty(t, ref tps) => {\n         (v.visit_ty)(t, e, v);\n-        (v.visit_ty_params)(tps, e, v);\n+        (v.visit_generics)(tps, e, v);\n       }\n       item_enum(ref enum_definition, ref tps) => {\n-        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n+        (v.visit_generics)(tps, e, v);\n         visit_enum_def(\n             *enum_definition,\n-            /* FIXME (#2543) */ copy *tps,\n+            tps,\n             e,\n             v\n         );\n       }\n-      item_impl(tps, traits, ty, methods) => {\n-        (v.visit_ty_params)(tps, e, v);\n+      item_impl(ref tps, traits, ty, methods) => {\n+        (v.visit_generics)(tps, e, v);\n         for traits.each |p| {\n             visit_path(p.path, e, v);\n         }\n@@ -180,12 +185,12 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(*m, e, v)\n         }\n       }\n-      item_struct(struct_def, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n+      item_struct(struct_def, ref tps) => {\n+        (v.visit_generics)(tps, e, v);\n         (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n       item_trait(ref tps, ref traits, ref methods) => {\n-        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n+        (v.visit_generics)(tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for (*methods).each |m| {\n             (v.visit_trait_method)(*m, e, v);\n@@ -196,7 +201,7 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n }\n \n pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n-                         tps: ~[ast::ty_param],\n+                         tps: &Generics,\n                          e: E,\n                          v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n@@ -296,27 +301,28 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n \n pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-      foreign_item_fn(fd, _, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n+      foreign_item_fn(fd, _, ref generics) => {\n         visit_fn_decl(fd, e, v);\n+        (v.visit_generics)(generics, e, v);\n       }\n       foreign_item_const(t) => {\n         (v.visit_ty)(t, e, v);\n       }\n     }\n }\n \n-pub fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n-    for bounds.each |&bound| {\n-        match bound {\n+pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n+                                e: E, v: vt<E>) {\n+    for bounds.each |bound| {\n+        match *bound {\n             TraitTyParamBound(ty) => (v.visit_ty)(ty, e, v),\n             RegionTyParamBound => ()\n         }\n     }\n }\n \n-pub fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n-    for tps.each |tp| {\n+pub fn visit_generics<E>(generics: &Generics, e: E, v: vt<E>) {\n+    for generics.ty_params.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n }\n@@ -334,29 +340,33 @@ pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n pub fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_method(/* FIXME (#2543) */ copy m.ident,\n-                         /* FIXME (#2543) */ copy m.tps, m),\n-               m.decl, m.body, m.span, m.id, e, v);\n+    (v.visit_fn)(fk_method(m.ident, /* FIXME (#2543) */ copy m.generics, m),\n+                 m.decl, m.body, m.span, m.id, e, v);\n }\n \n-pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: ~[ty_param],\n+pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n                                    parent_id: def_id, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n-                       dtor.node.self_id, parent_id), ast_util::dtor_dec(),\n-               dtor.node.body, dtor.span, dtor.node.id, e, v)\n+    (v.visit_fn)(fk_dtor(copy *generics, dtor.node.attrs,\n+                         dtor.node.self_id, parent_id),\n+                 ast_util::dtor_dec(),\n+                 dtor.node.body,\n+                 dtor.span,\n+                 dtor.node.id,\n+                 e, v)\n \n }\n \n pub fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n                    _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n-    (v.visit_ty_params)(tps_of_fn(fk), e, v);\n+    let generics = generics_of_fn(fk);\n+    (v.visit_generics)(&generics, e, v);\n     (v.visit_block)(body, e, v);\n }\n \n pub fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-    (v.visit_ty_params)(m.tps, e, v);\n+    (v.visit_generics)(&m.generics, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n@@ -367,13 +377,16 @@ pub fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n-                           id: node_id, e: E, v: vt<E>) {\n+pub fn visit_struct_def<E>(sd: @struct_def,\n+                           _nm: ast::ident,\n+                           generics: &Generics,\n+                           id: node_id,\n+                           e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n     do option::iter(&sd.dtor) |dtor| {\n-      visit_struct_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n+      visit_struct_dtor_helper(*dtor, generics, ast_util::local_def(id), e, v)\n     };\n }\n \n@@ -552,11 +565,11 @@ pub struct SimpleVisitor {\n     visit_expr: fn@(@expr),\n     visit_expr_post: fn@(@expr),\n     visit_ty: fn@(@Ty),\n-    visit_ty_params: fn@(~[ty_param]),\n+    visit_generics: fn@(&Generics),\n     visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n     visit_ty_method: fn@(ty_method),\n     visit_trait_method: fn@(trait_method),\n-    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id),\n+    visit_struct_def: fn@(@struct_def, ident, &Generics, node_id),\n     visit_struct_field: fn@(@struct_field),\n     visit_struct_method: fn@(@method)\n }\n@@ -579,13 +592,13 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n           visit_expr: |_e: @expr| { },\n           visit_expr_post: |_e: @expr| { },\n           visit_ty: simple_ignore_ty,\n-          visit_ty_params: fn@(_ps: ~[ty_param]) {},\n+          visit_generics: fn@(_ps: &Generics) {},\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                         _id: node_id) { },\n           visit_ty_method: fn@(_m: ty_method) { },\n           visit_trait_method: fn@(_m: trait_method) { },\n           visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n-                                _tps: ~[ty_param], _id: node_id) { },\n+                                _generics: &Generics, _id: node_id) { },\n           visit_struct_field: fn@(_f: @struct_field) { },\n           visit_struct_method: fn@(_m: @method) { }\n          };\n@@ -654,17 +667,20 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m);\n         visit_trait_method(m, e, v);\n     }\n-    fn v_struct_def(f: fn@(@struct_def, ident, ~[ty_param], node_id),\n-                    sd: @struct_def, nm: ident, tps: ~[ty_param], id: node_id,\n+    fn v_struct_def(f: fn@(@struct_def, ident, &Generics, node_id),\n+                    sd: @struct_def,\n+                    nm: ident,\n+                    generics: &Generics,\n+                    id: node_id,\n                     &&e: (), v: vt<()>) {\n-        f(sd, nm, tps, id);\n-        visit_struct_def(sd, nm, tps, id, e, v);\n+        f(sd, nm, generics, id);\n+        visit_struct_def(sd, nm, generics, id, e, v);\n     }\n-    fn v_ty_params(f: fn@(~[ty_param]),\n-                   ps: ~[ty_param],\n-                   &&e: (), v: vt<()>) {\n+    fn v_generics(f: fn@(&Generics),\n+                  ps: &Generics,\n+                  &&e: (), v: vt<()>) {\n         f(ps);\n-        visit_ty_params(ps, e, v);\n+        visit_generics(ps, e, v);\n     }\n     fn v_fn(f: fn@(fn_kind, fn_decl, blk, span, node_id),\n             fk: fn_kind, decl: fn_decl, body: blk, sp: span,\n@@ -699,8 +715,8 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n                                              a, b, c),\n         visit_ty: visit_ty,\n-        visit_ty_params: |a,b,c|\n-            v_ty_params(v.visit_ty_params, a, b, c),\n+        visit_generics: |a,b,c|\n+            v_generics(v.visit_generics, a, b, c),\n         visit_fn: |a,b,c,d,e,f,g|\n             v_fn(v.visit_fn, a, b, c, d, e, f, g),\n         visit_ty_method: |a,b,c|"}]}