{"sha": "80d939fd22361cc8652cd4d7006fd1964d9ab699", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZDkzOWZkMjIzNjFjYzg2NTJjZDRkNzAwNmZkMTk2NGQ5YWI2OTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T10:36:39Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:52Z"}, "message": "trans: Handle ignored arguments/returns uniformly.", "tree": {"sha": "a2da7b1e96e7eb4fc26c9c3891c579fd2c5cb363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2da7b1e96e7eb4fc26c9c3891c579fd2c5cb363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80d939fd22361cc8652cd4d7006fd1964d9ab699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80d939fd22361cc8652cd4d7006fd1964d9ab699", "html_url": "https://github.com/rust-lang/rust/commit/80d939fd22361cc8652cd4d7006fd1964d9ab699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80d939fd22361cc8652cd4d7006fd1964d9ab699/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7454b5c61de7e4eb6ac0079d38d9a42d9f0d8539", "url": "https://api.github.com/repos/rust-lang/rust/commits/7454b5c61de7e4eb6ac0079d38d9a42d9f0d8539", "html_url": "https://github.com/rust-lang/rust/commit/7454b5c61de7e4eb6ac0079d38d9a42d9f0d8539"}], "stats": {"total": 122, "additions": 66, "deletions": 56}, "files": [{"sha": "bd5de8efc195ea64150212e44d9e744059cc6845", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use trans::common::{return_type_is_void, type_is_fat_ptr};\n+use trans::common::{type_is_fat_ptr, Block};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n use trans::cabi_x86_64;\n@@ -20,7 +20,7 @@ use trans::cabi_powerpc;\n use trans::cabi_powerpc64;\n use trans::cabi_mips;\n use trans::cabi_asmjs;\n-use trans::machine::{llsize_of_alloc, llsize_of_real};\n+use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use trans::type_::Type;\n use trans::type_of;\n \n@@ -97,6 +97,8 @@ impl ArgType {\n     }\n \n     pub fn make_indirect(&mut self, ccx: &CrateContext) {\n+        assert_eq!(self.kind, ArgKind::Direct);\n+\n         // Wipe old attributes, likely not valid through indirection.\n         self.attrs = llvm::Attributes::default();\n \n@@ -113,6 +115,7 @@ impl ArgType {\n     }\n \n     pub fn ignore(&mut self) {\n+        assert_eq!(self.kind, ArgKind::Direct);\n         self.kind = ArgKind::Ignore;\n     }\n \n@@ -200,39 +203,40 @@ impl FnType {\n                 arg.attrs.set(llvm::Attribute::ZExt);\n                 arg\n             } else {\n-                ArgType::new(type_of::type_of(ccx, ty),\n-                             type_of::sizing_type_of(ccx, ty))\n+                let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n+                                           type_of::sizing_type_of(ccx, ty));\n+                if llsize_of_real(ccx, arg.ty) == 0 {\n+                    arg.ignore();\n+                }\n+                arg\n             }\n         };\n \n-        let mut ret = match sig.output {\n-            ty::FnConverging(ret_ty) if !return_type_is_void(ccx, ret_ty) => {\n-                arg_of(ret_ty)\n-            }\n-            _ => ArgType::new(Type::void(ccx), Type::void(ccx))\n+        let ret_ty = match sig.output {\n+            ty::FnConverging(ret_ty) => ret_ty,\n+            ty::FnDiverging => ccx.tcx().mk_nil()\n         };\n+        let mut ret = arg_of(ret_ty);\n+\n+        if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n+            // The `noalias` attribute on the return value is useful to a\n+            // function ptr caller.\n+            if let ty::TyBox(_) = ret_ty.sty {\n+                // `Box` pointer return values never alias because ownership\n+                // is transferred\n+                ret.attrs.set(llvm::Attribute::NoAlias);\n+            }\n \n-        if let ty::FnConverging(ret_ty) = sig.output {\n-            if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n-                // The `noalias` attribute on the return value is useful to a\n-                // function ptr caller.\n-                if let ty::TyBox(_) = ret_ty.sty {\n-                    // `Box` pointer return values never alias because ownership\n-                    // is transferred\n-                    ret.attrs.set(llvm::Attribute::NoAlias);\n-                }\n-\n-                // We can also mark the return value as `dereferenceable` in certain cases\n-                match ret_ty.sty {\n-                    // These are not really pointers but pairs, (pointer, len)\n-                    ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-                    ty::TyBox(ty) => {\n-                        let llty = type_of::sizing_type_of(ccx, ty);\n-                        let llsz = llsize_of_real(ccx, llty);\n-                        ret.attrs.set_dereferenceable(llsz);\n-                    }\n-                    _ => {}\n+            // We can also mark the return value as `dereferenceable` in certain cases\n+            match ret_ty.sty {\n+                // These are not really pointers but pairs, (pointer, len)\n+                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                ty::TyBox(ty) => {\n+                    let llty = type_of::sizing_type_of(ccx, ty);\n+                    let llsz = llsize_of_real(ccx, llty);\n+                    ret.attrs.set_dereferenceable(llsz);\n                 }\n+                _ => {}\n             }\n         }\n \n@@ -318,8 +322,8 @@ impl FnType {\n                     // Scalars and vectors, always immediate.\n                     return;\n                 }\n-                let size = llsize_of_alloc(ccx, arg.ty);\n-                if size > llsize_of_alloc(ccx, ccx.int_type()) {\n+                let size = llsize_of_real(ccx, arg.ty);\n+                if size > llsize_of_real(ccx, ccx.int_type()) {\n                     arg.make_indirect(ccx);\n                 } else if size > 0 {\n                     // We want to pass small aggregates as immediates, but using\n@@ -376,7 +380,9 @@ impl FnType {\n     pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         let mut llargument_tys = Vec::new();\n \n-        let llreturn_ty = if self.ret.is_indirect() {\n+        let llreturn_ty = if self.ret.is_ignore() {\n+            Type::void(ccx)\n+        } else if self.ret.is_indirect() {\n             llargument_tys.push(self.ret.original_ty.ptr_to());\n             Type::void(ccx)\n         } else {\n@@ -410,7 +416,9 @@ impl FnType {\n \n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        self.ret.attrs.apply_llfn(i, llfn);\n+        if !self.ret.is_ignore() {\n+            self.ret.attrs.apply_llfn(i, llfn);\n+        }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n@@ -423,7 +431,9 @@ impl FnType {\n \n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        self.ret.attrs.apply_callsite(i, callsite);\n+        if !self.ret.is_ignore() {\n+            self.ret.attrs.apply_callsite(i, callsite);\n+        }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {"}, {"sha": "6eea8d472ba554adb73a4c4d6c3696c6739205e3", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -229,11 +229,12 @@ fn is_reg_ty(ty: Type) -> bool {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "14ca77836c28f4f9d06a2358028a47715a7d3dda", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -179,11 +179,12 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n         Flavor::Ios => ios_ty_align as TyAlignFn,\n     };\n \n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret, align_fn);\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, align_fn);\n     }\n }"}, {"sha": "c901442f4854898129d9d605f50861f27ba27310", "filename": "src/librustc_trans/trans/cabi_asmjs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -13,7 +13,6 @@\n use llvm::{Struct, Array, Attribute};\n use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n-use trans::type_::Type;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n@@ -45,11 +44,12 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "0d5e81be92142745c977bca82e83f1616f08abfc", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -146,14 +146,13 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty != Type::void(ccx) {\n-        if !is_reg_ty(fty.ret.ty) {\n-            fty.ret.make_indirect(ccx);\n-        }\n+    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n+        fty.ret.make_indirect(ccx);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);\n     }\n }"}, {"sha": "9aa89a04d0a9ad02f0781eb8ade142c7c170f5d0", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -141,14 +141,13 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty != Type::void(ccx) {\n-        if !is_reg_ty(fty.ret.ty) {\n-            fty.ret.make_indirect(ccx);\n-        }\n+    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n+        fty.ret.make_indirect(ccx);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);\n     }\n }"}, {"sha": "340de235732f920498fc8bca01ae0d19385eae37", "filename": "src/librustc_trans/trans/cabi_powerpc64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -232,11 +232,12 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "9e6c4d9af42ee4446873a32414a053368cb9de35", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -15,7 +15,7 @@ use super::common::*;\n use super::machine::*;\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if fty.ret.ty.kind() == Struct {\n+    if !fty.ret.is_ignore() && fty.ret.ty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n         // small structs are returned as integers.\n@@ -38,13 +38,10 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         if arg.ty.kind() == Struct {\n-            if llsize_of_alloc(ccx, arg.ty) == 0 {\n-                arg.ignore();\n-            } else {\n-                arg.make_indirect(ccx);\n-                arg.attrs.set(Attribute::ByVal);\n-            }\n+            arg.make_indirect(ccx);\n+            arg.attrs.set(Attribute::ByVal);\n         }\n     }\n }"}, {"sha": "47d373f90431ec515101712f0811105478d8aa1e", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -406,7 +406,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         x86_64_ty(ccx, &mut fty.ret, |cls| {\n             if cls.is_ret_bysret() {\n                 // `sret` parameter thus one less register available\n@@ -419,6 +419,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     }\n \n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         x86_64_ty(ccx, arg, |cls| {\n             let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n             let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;"}, {"sha": "43f72c454cf02fb625cc8e08522285821c651839", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d939fd22361cc8652cd4d7006fd1964d9ab699/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=80d939fd22361cc8652cd4d7006fd1964d9ab699", "patch": "@@ -29,10 +29,11 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         }\n     };\n \n-    if fty.ret.ty != Type::void(ccx) {\n+    if !fty.ret.is_ignore() {\n         fixup(&mut fty.ret);\n     }\n     for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n         fixup(arg);\n     }\n }"}]}