{"sha": "b0bd5f236d9bea38b8c9048f379fec179b09984c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYmQ1ZjIzNmQ5YmVhMzhiOGM5MDQ4ZjM3OWZlYzE3OWIwOTk4NGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T21:47:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T21:47:45Z"}, "message": "Auto merge of #62452 - Centril:rollup-5jww3h7, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #60081 (Refactor unicode.py script)\n - #61862 (Make the Weak::{into,as}_raw methods)\n - #62243 (Improve documentation for built-in macros)\n - #62422 (Remove some uses of mem::uninitialized)\n - #62436 (normalize use of backticks/lowercase in compiler messages for librustc_mir)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4361af5c2be0fc980a75611e33190057f582bde7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4361af5c2be0fc980a75611e33190057f582bde7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0bd5f236d9bea38b8c9048f379fec179b09984c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0bd5f236d9bea38b8c9048f379fec179b09984c", "html_url": "https://github.com/rust-lang/rust/commit/b0bd5f236d9bea38b8c9048f379fec179b09984c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0bd5f236d9bea38b8c9048f379fec179b09984c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfd52ba6ac2262c6b61c59ec86bfd23e4e53d3de", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd52ba6ac2262c6b61c59ec86bfd23e4e53d3de", "html_url": "https://github.com/rust-lang/rust/commit/dfd52ba6ac2262c6b61c59ec86bfd23e4e53d3de"}, {"sha": "7ef02dcf6735a1168caabb0493d7576f12c99baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef02dcf6735a1168caabb0493d7576f12c99baf", "html_url": "https://github.com/rust-lang/rust/commit/7ef02dcf6735a1168caabb0493d7576f12c99baf"}], "stats": {"total": 2447, "additions": 1745, "deletions": 702}, "files": [{"sha": "87fec41415272bace9824cb2ab04697754a928d3", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -36,6 +36,7 @@ __pycache__/\n /src/libcore/unicode/Scripts.txt\n /src/libcore/unicode/SpecialCasing.txt\n /src/libcore/unicode/UnicodeData.txt\n+/src/libcore/unicode/downloaded\n /stage[0-9]+/\n /target\n target/"}, {"sha": "45a8b4a25c8a80edb17e7c3cd299dada38c5e93d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1291,26 +1291,26 @@ impl<T> Weak<T> {\n     /// ```\n     /// #![feature(weak_into_raw)]\n     ///\n-    /// use std::rc::{Rc, Weak};\n+    /// use std::rc::Rc;\n     /// use std::ptr;\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(this: &Self) -> *const T {\n-        match this.inner() {\n+    pub fn as_raw(&self) -> *const T {\n+        match self.inner() {\n             None => ptr::null(),\n             Some(inner) => {\n                 let offset = data_offset_sized::<T>();\n@@ -1341,7 +1341,7 @@ impl<T> Weak<T> {\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n-    /// let raw = Weak::into_raw(weak);\n+    /// let raw = weak.into_raw();\n     ///\n     /// assert_eq!(1, Rc::weak_count(&strong));\n     /// assert_eq!(\"hello\", unsafe { &*raw });\n@@ -1353,9 +1353,9 @@ impl<T> Weak<T> {\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_raw`]: struct.Weak.html#method.as_raw\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn into_raw(this: Self) -> *const T {\n-        let result = Self::as_raw(&this);\n-        mem::forget(this);\n+    pub fn into_raw(self) -> *const T {\n+        let result = self.as_raw();\n+        mem::forget(self);\n         result\n     }\n \n@@ -1382,18 +1382,18 @@ impl<T> Weak<T> {\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n     ///\n-    /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n-    /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n+    /// let raw_1 = Rc::downgrade(&strong).into_raw();\n+    /// let raw_2 = Rc::downgrade(&strong).into_raw();\n     ///\n     /// assert_eq!(2, Rc::weak_count(&strong));\n     ///\n-    /// assert_eq!(\"hello\", &*Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(\"hello\", &*unsafe { Weak::from_raw(raw_1) }.upgrade().unwrap());\n     /// assert_eq!(1, Rc::weak_count(&strong));\n     ///\n     /// drop(strong);\n     ///\n     /// // Decrement the last weak count.\n-    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html"}, {"sha": "126169b5c8206bd0324a394c6a45c7db3188181c", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1080,26 +1080,26 @@ impl<T> Weak<T> {\n     /// ```\n     /// #![feature(weak_into_raw)]\n     ///\n-    /// use std::sync::{Arc, Weak};\n+    /// use std::sync::Arc;\n     /// use std::ptr;\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*Weak::as_raw(&weak) });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(this: &Self) -> *const T {\n-        match this.inner() {\n+    pub fn as_raw(&self) -> *const T {\n+        match self.inner() {\n             None => ptr::null(),\n             Some(inner) => {\n                 let offset = data_offset_sized::<T>();\n@@ -1130,7 +1130,7 @@ impl<T> Weak<T> {\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n-    /// let raw = Weak::into_raw(weak);\n+    /// let raw = weak.into_raw();\n     ///\n     /// assert_eq!(1, Arc::weak_count(&strong));\n     /// assert_eq!(\"hello\", unsafe { &*raw });\n@@ -1142,9 +1142,9 @@ impl<T> Weak<T> {\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_raw`]: struct.Weak.html#method.as_raw\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn into_raw(this: Self) -> *const T {\n-        let result = Self::as_raw(&this);\n-        mem::forget(this);\n+    pub fn into_raw(self) -> *const T {\n+        let result = self.as_raw();\n+        mem::forget(self);\n         result\n     }\n \n@@ -1172,18 +1172,18 @@ impl<T> Weak<T> {\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n     ///\n-    /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n-    /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n+    /// let raw_1 = Arc::downgrade(&strong).into_raw();\n+    /// let raw_2 = Arc::downgrade(&strong).into_raw();\n     ///\n     /// assert_eq!(2, Arc::weak_count(&strong));\n     ///\n-    /// assert_eq!(\"hello\", &*Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(\"hello\", &*unsafe { Weak::from_raw(raw_1) }.upgrade().unwrap());\n     /// assert_eq!(1, Arc::weak_count(&strong));\n     ///\n     /// drop(strong);\n     ///\n     /// // Decrement the last weak count.\n-    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html"}, {"sha": "782627431cb567dc4058e205f4e4374ae76c11e0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -75,6 +75,7 @@\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n #![feature(custom_inner_attributes)]\n+#![feature(decl_macro)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(extern_types)]"}, {"sha": "33ffd84e521f297acfac98449c41aad78cde1b3b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 628, "deletions": 91, "changes": 719, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -642,183 +642,720 @@ macro_rules! uninitialized_array {\n /// These macros do not have any corresponding definition with a `macro_rules!`\n /// macro, but are documented here. Their implementations can be found hardcoded\n /// into libsyntax itself.\n-///\n-/// For more information, see documentation for `std`'s macros.\n #[cfg(rustdoc)]\n mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n     ///\n-    /// For more information, see the documentation for [`std::compile_error!`].\n+    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n+    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n+    /// which emits an error at *runtime*, rather than during compilation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Two such examples are macros and `#[cfg]` environments.\n+    ///\n+    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n+    /// the compiler would still emit an error, but the error's message would not mention the two\n+    /// valid values.\n+    ///\n+    /// ```compile_fail\n+    /// macro_rules! give_me_foo_or_bar {\n+    ///     (foo) => {};\n+    ///     (bar) => {};\n+    ///     ($x:ident) => {\n+    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n+    ///     }\n+    /// }\n+    ///\n+    /// give_me_foo_or_bar!(neither);\n+    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n+    /// ```\n+    ///\n+    /// Emit compiler error if one of a number of features isn't available.\n+    ///\n+    /// ```compile_fail\n+    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n+    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n+    /// ```\n     ///\n-    /// [`std::compile_error!`]: ../std/macro.compile_error.html\n+    /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ }),\n+        ($msg:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n     ///\n-    /// For more information, see the documentation for [`std::format_args!`].\n+    /// This macro functions by taking a formatting string literal containing\n+    /// `{}` for each additional argument passed. `format_args!` prepares the\n+    /// additional parameters to ensure the output can be interpreted as a string\n+    /// and canonicalizes the arguments into a single type. Any value that implements\n+    /// the [`Display`] trait can be passed to `format_args!`, as can any\n+    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n+    ///\n+    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n+    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n+    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n+    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n+    /// heap allocations.\n+    ///\n+    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n+    /// in `Debug` and `Display` contexts as seen below. The example also shows\n+    /// that `Debug` and `Display` format to the same thing: the interpolated\n+    /// format string in `format_args!`.\n+    ///\n+    /// ```rust\n+    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// assert_eq!(\"1 foo 2\", display);\n+    /// assert_eq!(display, debug);\n+    /// ```\n+    ///\n+    /// For more information, see the documentation in [`std::fmt`].\n+    ///\n+    /// [`Display`]: ../std/fmt/trait.Display.html\n+    /// [`Debug`]: ../std/fmt/trait.Debug.html\n+    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    /// [`format!`]: ../std/macro.format.html\n+    /// [`write!`]: ../std/macro.write.html\n+    /// [`println!`]: ../std/macro.println.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n     ///\n-    /// [`std::format_args!`]: ../std/macro.format_args.html\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n+    #[allow_internal_unstable(fmt_internals)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Same as `format_args`, but adds a newline in the end.\n+    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n+               reason = \"`format_args_nl` is only for internal \\\n+                         language use and is subject to change\")]\n+    #[allow_internal_unstable(fmt_internals)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args_nl {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::env!`].\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n+    /// macro instead.\n+    ///\n+    /// [`option_env!`]: ../std/macro.option_env.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    ///\n+    /// You can customize the error message by passing a string as the second\n+    /// parameter:\n+    ///\n+    /// ```compile_fail\n+    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n+    /// ```\n     ///\n-    /// [`std::env!`]: ../std/macro.env.html\n+    /// If the `documentation` environment variable is not defined, you'll get\n+    /// the following error:\n+    ///\n+    /// ```text\n+    /// error: what's that?!\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::option_env!`].\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`. See\n+    /// [`Option<T>`][option] for more information on this type.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// [option]: ../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n     ///\n-    /// [`std::option_env!`]: ../std/macro.option_env.html\n+    /// ```\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {:?}\", key);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro option_env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates identifiers into one identifier.\n     ///\n-    /// For more information, see the documentation for [`std::concat_idents!`].\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables. Also, as a general rule, macros are only\n+    /// allowed in item, statement or expression position. That means while\n+    /// you may use this macro for referring to existing variables, functions or\n+    /// modules etc, you cannot define a new one with it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> u32 { 23 }\n     ///\n-    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n-    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ });\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    ///\n+    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n+               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat_idents {\n+        ($($e:ident),+) => ({ /* compiler built-in */ }),\n+        ($($e:ident,)+) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates literals into a static string slice.\n     ///\n-    /// For more information, see the documentation for [`std::concat!`].\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n     ///\n-    /// [`std::concat!`]: ../std/macro.concat.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat {\n+        ($($e:expr),*) => ({ /* compiler built-in */ }),\n+        ($($e:expr,)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to the line number on which it was invoked.\n     ///\n-    /// For more information, see the documentation for [`std::line!`].\n+    /// With [`column!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first line\n+    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `line!` macro.\n     ///\n-    /// [`std::line!`]: ../std/macro.line.html\n+    /// [`column!`]: macro.column.html\n+    /// [`file!`]: macro.file.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro line() { /* compiler built-in */ }\n \n-    /// Expands to the column number on which it was invoked.\n+    /// Expands to the column number at which it was invoked.\n+    ///\n+    /// With [`line!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first column\n+    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `column!` macro.\n     ///\n-    /// For more information, see the documentation for [`std::column!`].\n+    /// [`line!`]: macro.line.html\n+    /// [`file!`]: macro.file.html\n     ///\n-    /// [`std::column!`]: ../std/macro.column.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro column() { /* compiler built-in */ }\n+\n+    /// Same as `column`, but less likely to be shadowed.\n+    #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n+               reason = \"internal implementation detail of the `column` macro\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro __rust_unstable_column() { /* compiler built-in */ }\n \n-    /// Expands to the file name from which it was invoked.\n+    /// Expands to the file name in which it was invoked.\n+    ///\n+    /// With [`line!`] and [`column!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     ///\n-    /// For more information, see the documentation for [`std::file!`].\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!`\n+    /// macro.\n     ///\n-    /// [`std::file!`]: ../std/macro.file.html\n+    /// [`line!`]: macro.line.html\n+    /// [`column!`]: macro.column.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro file() { /* compiler built-in */ }\n \n     /// Stringifies its arguments.\n     ///\n-    /// For more information, see the documentation for [`std::stringify!`].\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// Note that the expanded results of the input tokens may change in the\n+    /// future. You should be careful if you rely on the output.\n     ///\n-    /// [`std::stringify!`]: ../std/macro.stringify.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n-    /// For more information, see the documentation for [`std::include_str!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_str = include_str!(\"spanish.in\");\n+    ///     assert_eq!(my_str, \"adi\u00f3s\\n\");\n+    ///     print!(\"{}\", my_str);\n+    /// }\n+    /// ```\n     ///\n-    /// [`std::include_str!`]: ../std/macro.include_str.html\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_str {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n-    /// For more information, see the documentation for [`std::include_bytes!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8; N]` which is\n+    /// the contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let bytes = include_bytes!(\"spanish.in\");\n+    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n+    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n+    /// }\n+    /// ```\n     ///\n-    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to a string that represents the current module path.\n     ///\n-    /// For more information, see the documentation for [`std::module_path!`].\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n     ///\n-    /// [`std::module_path!`]: ../std/macro.module_path.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro module_path() { /* compiler built-in */ }\n \n-    /// Evaluates boolean combinations of configuration flags, at compile-time.\n+    /// Evaluates boolean combinations of configuration flags at compile-time.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the [`cfg`]\n+    /// attribute.\n     ///\n-    /// For more information, see the documentation for [`std::cfg!`].\n+    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n     ///\n-    /// [`std::cfg!`]: ../std/macro.cfg.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro cfg($($cfg:tt)*) { /* compiler built-in */ }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n-    /// For more information, see the documentation for [`std::include!`].\n+    /// The file is located relative to the current file (similarly to how\n+    /// modules are found).\n+    ///\n+    /// Using this macro is often a bad idea, because if the file is\n+    /// parsed as an expression, it is going to be placed in the\n+    /// surrounding code unhygienically. This could result in variables\n+    /// or functions being different from what the file expected if\n+    /// there are variables or functions that have the same name in\n+    /// the current file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n     ///\n-    /// [`std::include!`]: ../std/macro.include.html\n+    /// File 'monkeys.in':\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// ['\ud83d\ude48', '\ud83d\ude4a', '\ud83d\ude49']\n+    ///     .iter()\n+    ///     .cycle()\n+    ///     .take(6)\n+    ///     .collect::<String>()\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_string = include!(\"monkeys.in\");\n+    ///     assert_eq!(\"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\", my_string);\n+    ///     println!(\"{}\", my_string);\n+    /// }\n+    /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print\n+    /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n     ///\n-    /// For more information, see the documentation for [`std::assert!`].\n+    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n+    /// evaluated to `true` at runtime.\n+    ///\n+    /// # Uses\n+    ///\n+    /// Assertions are always checked in both debug and release builds, and cannot\n+    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n+    /// release builds by default.\n+    ///\n+    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+    /// violated could lead to unsafety.\n     ///\n-    /// [`std::assert!`]: ../std/macro.assert.html\n-    #[rustc_doc_only_macro]\n+    /// Other use-cases of `assert!` include testing and enforcing run-time\n+    /// invariants in safe code (whose violation cannot result in unsafety).\n+    ///\n+    /// # Custom Messages\n+    ///\n+    /// This macro has a second form, where a custom panic message can\n+    /// be provided with or without arguments for formatting. See [`std::fmt`]\n+    /// for syntax for this form.\n+    ///\n+    /// [`panic!`]: macro.panic.html\n+    /// [`debug_assert!`]: macro.debug_assert.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // the panic message for these assertions is the stringified value of the\n+    /// // expression given.\n+    /// assert!(true);\n+    ///\n+    /// fn some_computation() -> bool { true } // a very simple function\n+    ///\n+    /// assert!(some_computation());\n+    ///\n+    /// // assert with a custom message\n+    /// let x = true;\n+    /// assert!(x, \"x wasn't true!\");\n+    ///\n+    /// let a = 3; let b = 27;\n+    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro assert {\n+        ($cond:expr) => ({ /* compiler built-in */ }),\n+        ($cond:expr,) => ({ /* compiler built-in */ }),\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n     }\n+\n+    /// Inline assembly.\n+    #[unstable(feature = \"asm\", issue = \"29722\",\n+               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro asm(\"assembly template\"\n+                  : $(\"output\"(operand),)*\n+                  : $(\"input\"(operand),)*\n+                  : $(\"clobbers\",)*\n+                  : $(\"options\",)*) { /* compiler built-in */ }\n+\n+    /// Module-level inline assembly.\n+    #[unstable(feature = \"global_asm\", issue = \"35119\",\n+               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_asm(\"assembly\") { /* compiler built-in */ }\n+\n+    /// Prints passed tokens into the standard output.\n+    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n+               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro log_syntax($($arg:tt)*) { /* compiler built-in */ }\n+\n+    /// Enables or disables tracing functionality used for debugging other macros.\n+    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n+               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro trace_macros {\n+        (true) => ({ /* compiler built-in */ }),\n+        (false) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Attribute macro applied to a function to turn it into a unit test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test($item:item) { /* compiler built-in */ }\n+\n+    /// Attribute macro applied to a function to turn it into a benchmark test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro bench($item:item) { /* compiler built-in */ }\n+\n+    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n+    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n+               reason = \"custom test frameworks are an unstable feature\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test_case($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Clone`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Clone($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Copy`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Copy($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Debug`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Debug($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Decodable) is deprecated in favor of derive(RustcDecodable)\",\n+        suggestion = \"RustcDecodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro Decodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Default`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Default($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Encodable) is deprecated in favor of derive(RustcEncodable)\",\n+        suggestion = \"RustcEncodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Encodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Eq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_eq)]\n+    pub macro Eq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Hash`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Hash($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Ord`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Ord($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialEq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialEq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialOrd`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialOrd($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n }"}, {"sha": "a0539cd9ca9b6ee1bb641b83127e407b04ca2053", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 740, "deletions": 352, "changes": 1092, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1,147 +1,350 @@\n #!/usr/bin/env python\n \n-# This script uses the following Unicode tables:\n-# - DerivedCoreProperties.txt\n-# - DerivedNormalizationProps.txt\n-# - EastAsianWidth.txt\n-# - auxiliary/GraphemeBreakProperty.txt\n-# - PropList.txt\n-# - ReadMe.txt\n-# - Scripts.txt\n-# - UnicodeData.txt\n-#\n-# Since this should not require frequent updates, we just store this\n-# out-of-line and check the tables.rs file into git.\n+\"\"\"\n+Regenerate Unicode tables (tables.rs).\n+\"\"\"\n \n-import fileinput, re, os, sys, operator, math, datetime\n+# This script uses the Unicode tables as defined\n+# in the UnicodeFiles class.\n \n-# The directory in which this file resides.\n-fdir = os.path.dirname(os.path.realpath(__file__)) + \"/\"\n+# Since this should not require frequent updates, we just store this\n+# out-of-line and check the tables.rs file into git.\n \n-preamble = '''\n+# Note that the \"curl\" program is required for operation.\n+# This script is compatible with Python 2.7 and 3.x.\n+\n+import argparse\n+import datetime\n+import fileinput\n+import itertools\n+import os\n+import re\n+import textwrap\n+import subprocess\n+\n+from collections import defaultdict, namedtuple\n+\n+try:\n+    # Python 3\n+    from itertools import zip_longest\n+    from io import StringIO\n+except ImportError:\n+    # Python 2 compatibility\n+    zip_longest = itertools.izip_longest\n+    from StringIO import StringIO\n+\n+try:\n+    # Completely optional type hinting\n+    # (Python 2 compatible using comments,\n+    # see: https://mypy.readthedocs.io/en/latest/python2.html)\n+    # This is very helpful in typing-aware IDE like PyCharm.\n+    from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Set, Tuple\n+except ImportError:\n+    pass\n+\n+\n+# We don't use enum.Enum because of Python 2.7 compatibility.\n+class UnicodeFiles(object):\n+    # ReadMe does not contain any Unicode data, we\n+    # only use it to extract versions.\n+    README = \"ReadMe.txt\"\n+\n+    DERIVED_CORE_PROPERTIES = \"DerivedCoreProperties.txt\"\n+    DERIVED_NORMALIZATION_PROPS = \"DerivedNormalizationProps.txt\"\n+    PROPS = \"PropList.txt\"\n+    SCRIPTS = \"Scripts.txt\"\n+    SPECIAL_CASING = \"SpecialCasing.txt\"\n+    UNICODE_DATA = \"UnicodeData.txt\"\n+\n+\n+# The order doesn't really matter (Python < 3.6 won't preserve it),\n+# we only want to aggregate all the file names.\n+ALL_UNICODE_FILES = tuple(\n+    value for name, value in UnicodeFiles.__dict__.items()\n+    if not name.startswith(\"_\")\n+)\n+\n+assert len(ALL_UNICODE_FILES) == 7, \"Unexpected number of unicode files\"\n+\n+# The directory this file is located in.\n+THIS_DIR = os.path.dirname(os.path.realpath(__file__))\n+\n+# Where to download the Unicode data.  The downloaded files\n+# will be placed in sub-directories named after Unicode version.\n+FETCH_DIR = os.path.join(THIS_DIR, \"downloaded\")\n+\n+FETCH_URL_LATEST = \"ftp://ftp.unicode.org/Public/UNIDATA/{filename}\"\n+FETCH_URL_VERSION = \"ftp://ftp.unicode.org/Public/{version}/ucd/{filename}\"\n+\n+PREAMBLE = \"\"\"\\\n // NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n use unicode::version::UnicodeVersion;\n use unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};\n-'''.format(year = datetime.datetime.now().year)\n+\"\"\".format(year=datetime.datetime.now().year)\n \n # Mapping taken from Table 12 from:\n # http://www.unicode.org/reports/tr44/#General_Category_Values\n-expanded_categories = {\n-    'Lu': ['LC', 'L'], 'Ll': ['LC', 'L'], 'Lt': ['LC', 'L'],\n-    'Lm': ['L'], 'Lo': ['L'],\n-    'Mn': ['M'], 'Mc': ['M'], 'Me': ['M'],\n-    'Nd': ['N'], 'Nl': ['N'], 'No': ['N'],\n-    'Pc': ['P'], 'Pd': ['P'], 'Ps': ['P'], 'Pe': ['P'],\n-    'Pi': ['P'], 'Pf': ['P'], 'Po': ['P'],\n-    'Sm': ['S'], 'Sc': ['S'], 'Sk': ['S'], 'So': ['S'],\n-    'Zs': ['Z'], 'Zl': ['Z'], 'Zp': ['Z'],\n-    'Cc': ['C'], 'Cf': ['C'], 'Cs': ['C'], 'Co': ['C'], 'Cn': ['C'],\n+EXPANDED_CATEGORIES = {\n+    \"Lu\": [\"LC\", \"L\"], \"Ll\": [\"LC\", \"L\"], \"Lt\": [\"LC\", \"L\"],\n+    \"Lm\": [\"L\"], \"Lo\": [\"L\"],\n+    \"Mn\": [\"M\"], \"Mc\": [\"M\"], \"Me\": [\"M\"],\n+    \"Nd\": [\"N\"], \"Nl\": [\"N\"], \"No\": [\"N\"],\n+    \"Pc\": [\"P\"], \"Pd\": [\"P\"], \"Ps\": [\"P\"], \"Pe\": [\"P\"],\n+    \"Pi\": [\"P\"], \"Pf\": [\"P\"], \"Po\": [\"P\"],\n+    \"Sm\": [\"S\"], \"Sc\": [\"S\"], \"Sk\": [\"S\"], \"So\": [\"S\"],\n+    \"Zs\": [\"Z\"], \"Zl\": [\"Z\"], \"Zp\": [\"Z\"],\n+    \"Cc\": [\"C\"], \"Cf\": [\"C\"], \"Cs\": [\"C\"], \"Co\": [\"C\"], \"Cn\": [\"C\"],\n }\n \n-# these are the surrogate codepoints, which are not valid rust characters\n-surrogate_codepoints = (0xd800, 0xdfff)\n+# This is the (inclusive) range of surrogate codepoints.\n+# These are not valid Rust characters.\n+SURROGATE_CODEPOINTS_RANGE = (0xd800, 0xdfff)\n+\n+UnicodeData = namedtuple(\n+    \"UnicodeData\", (\n+        # Conversions:\n+        \"to_upper\", \"to_lower\", \"to_title\",\n+\n+        # Decompositions: canonical decompositions, compatibility decomp\n+        \"canon_decomp\", \"compat_decomp\",\n+\n+        # Grouped: general categories and combining characters\n+        \"general_categories\", \"combines\",\n+    )\n+)\n+\n+UnicodeVersion = namedtuple(\n+    \"UnicodeVersion\", (\"major\", \"minor\", \"micro\", \"as_str\")\n+)\n+\n+\n+def fetch_files(version=None):\n+    # type: (str) -> UnicodeVersion\n+    \"\"\"\n+    Fetch all the Unicode files from unicode.org.\n+\n+    This will use cached files (stored in `FETCH_DIR`) if they exist,\n+    creating them if they don't.  In any case, the Unicode version\n+    is always returned.\n+\n+    :param version: The desired Unicode version, as string.\n+        (If None, defaults to latest final release available,\n+         querying the unicode.org service).\n+    \"\"\"\n+    have_version = check_stored_version(version)\n+    if have_version:\n+        return have_version\n+\n+    if version:\n+        # Check if the desired version exists on the server.\n+        get_fetch_url = lambda name: FETCH_URL_VERSION.format(version=version, filename=name)\n+    else:\n+        # Extract the latest version.\n+        get_fetch_url = lambda name: FETCH_URL_LATEST.format(filename=name)\n+\n+    readme_url = get_fetch_url(UnicodeFiles.README)\n+\n+    print(\"Fetching: {}\".format(readme_url))\n+    readme_content = subprocess.check_output((\"curl\", readme_url))\n+\n+    unicode_version = parse_readme_unicode_version(\n+        readme_content.decode(\"utf8\")\n+    )\n+\n+    download_dir = get_unicode_dir(unicode_version)\n+    if not os.path.exists(download_dir):\n+        # For 2.7 compat, we don't use `exist_ok=True`.\n+        os.makedirs(download_dir)\n+\n+    for filename in ALL_UNICODE_FILES:\n+        file_path = get_unicode_file_path(unicode_version, filename)\n+\n+        if os.path.exists(file_path):\n+            # Assume file on the server didn't change if it's been saved before.\n+            continue\n+\n+        if filename == UnicodeFiles.README:\n+            with open(file_path, \"wb\") as fd:\n+                fd.write(readme_content)\n+        else:\n+            url = get_fetch_url(filename)\n+            print(\"Fetching: {}\".format(url))\n+            subprocess.check_call((\"curl\", \"-o\", file_path, url))\n+\n+    return unicode_version\n+\n+\n+def check_stored_version(version):\n+    # type: (Optional[str]) -> Optional[UnicodeVersion]\n+    \"\"\"\n+    Given desired Unicode version, return the version\n+    if stored files are all present, and `None` otherwise.\n+    \"\"\"\n+    if not version:\n+        # If no desired version specified, we should check what's the latest\n+        # version, skipping stored version checks.\n+        return None\n+\n+    fetch_dir = os.path.join(FETCH_DIR, version)\n \n-def fetch(f):\n-    path = fdir + os.path.basename(f)\n-    if not os.path.exists(path):\n-        os.system(\"curl -o {0}{1} ftp://ftp.unicode.org/Public/UNIDATA/{1}\".format(fdir, f))\n+    for filename in ALL_UNICODE_FILES:\n+        file_path = os.path.join(fetch_dir, filename)\n+\n+        if not os.path.exists(file_path):\n+            return None\n+\n+    with open(os.path.join(fetch_dir, UnicodeFiles.README)) as fd:\n+        return parse_readme_unicode_version(fd.read())\n+\n+\n+def parse_readme_unicode_version(readme_content):\n+    # type: (str) -> UnicodeVersion\n+    \"\"\"\n+    Parse the Unicode version contained in their `ReadMe.txt` file.\n+    \"\"\"\n+    # \"Raw string\" is necessary for \\d not being treated as escape char\n+    # (for the sake of compat with future Python versions).\n+    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n+    pattern = r\"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n+    groups = re.search(pattern, readme_content).groups()\n+\n+    return UnicodeVersion(*map(int, groups), as_str=\".\".join(groups))\n+\n+\n+def get_unicode_dir(unicode_version):\n+    # type: (UnicodeVersion) -> str\n+    \"\"\"\n+    Indicate in which parent dir the Unicode data files should be stored.\n+\n+    This returns a full, absolute path.\n+    \"\"\"\n+    return os.path.join(FETCH_DIR, unicode_version.as_str)\n+\n+\n+def get_unicode_file_path(unicode_version, filename):\n+    # type: (UnicodeVersion, str) -> str\n+    \"\"\"\n+    Indicate where the Unicode data file should be stored.\n+    \"\"\"\n+    return os.path.join(get_unicode_dir(unicode_version), filename)\n \n-    if not os.path.exists(path):\n-        sys.stderr.write(\"cannot load %s\" % f)\n-        exit(1)\n \n def is_surrogate(n):\n-    return surrogate_codepoints[0] <= n <= surrogate_codepoints[1]\n-\n-def load_unicode_data(f):\n-    fetch(f)\n-    gencats = {}\n-    to_lower = {}\n-    to_upper = {}\n-    to_title = {}\n-    combines = {}\n-    canon_decomp = {}\n-    compat_decomp = {}\n-\n-    udict = {}\n+    # type: (int) -> bool\n+    \"\"\"\n+    Tell if given codepoint is a surrogate (not a valid Rust character).\n+    \"\"\"\n+    return SURROGATE_CODEPOINTS_RANGE[0] <= n <= SURROGATE_CODEPOINTS_RANGE[1]\n+\n+\n+def load_unicode_data(file_path):\n+    # type: (str) -> UnicodeData\n+    \"\"\"\n+    Load main Unicode data.\n+    \"\"\"\n+    # Conversions\n+    to_lower = {}   # type: Dict[int, Tuple[int, int, int]]\n+    to_upper = {}   # type: Dict[int, Tuple[int, int, int]]\n+    to_title = {}   # type: Dict[int, Tuple[int, int, int]]\n+\n+    # Decompositions\n+    compat_decomp = {}   # type: Dict[int, List[int]]\n+    canon_decomp = {}    # type: Dict[int, List[int]]\n+\n+    # Combining characters\n+    # FIXME: combines are not used\n+    combines = defaultdict(set)   # type: Dict[str, Set[int]]\n+\n+    # Categories\n+    general_categories = defaultdict(set)   # type: Dict[str, Set[int]]\n+    category_assigned_codepoints = set()    # type: Set[int]\n+\n+    all_codepoints = {}\n+\n     range_start = -1\n-    for line in fileinput.input(fdir + f):\n-        data = line.split(';')\n+\n+    for line in fileinput.input(file_path):\n+        data = line.split(\";\")\n         if len(data) != 15:\n             continue\n-        cp = int(data[0], 16)\n-        if is_surrogate(cp):\n+        codepoint = int(data[0], 16)\n+        if is_surrogate(codepoint):\n             continue\n         if range_start >= 0:\n-            for i in range(range_start, cp):\n-                udict[i] = data\n+            for i in range(range_start, codepoint):\n+                all_codepoints[i] = data\n             range_start = -1\n         if data[1].endswith(\", First>\"):\n-            range_start = cp\n+            range_start = codepoint\n             continue\n-        udict[cp] = data\n+        all_codepoints[codepoint] = data\n \n-    for code in udict:\n+    for code, data in all_codepoints.items():\n         (code_org, name, gencat, combine, bidi,\n          decomp, deci, digit, num, mirror,\n-         old, iso, upcase, lowcase, titlecase) = udict[code]\n+         old, iso, upcase, lowcase, titlecase) = data\n+\n+        # Generate char to char direct common and simple conversions:\n \n-        # generate char to char direct common and simple conversions\n-        # uppercase to lowercase\n+        # Uppercase to lowercase\n         if lowcase != \"\" and code_org != lowcase:\n             to_lower[code] = (int(lowcase, 16), 0, 0)\n \n-        # lowercase to uppercase\n+        # Lowercase to uppercase\n         if upcase != \"\" and code_org != upcase:\n             to_upper[code] = (int(upcase, 16), 0, 0)\n \n-        # title case\n+        # Title case\n         if titlecase.strip() != \"\" and code_org != titlecase:\n             to_title[code] = (int(titlecase, 16), 0, 0)\n \n-        # store decomposition, if given\n-        if decomp != \"\":\n-            if decomp.startswith('<'):\n-                seq = []\n-                for i in decomp.split()[1:]:\n-                    seq.append(int(i, 16))\n-                compat_decomp[code] = seq\n+        # Store decomposition, if given\n+        if decomp:\n+            decompositions = decomp.split()[1:]\n+            decomp_code_points = [int(i, 16) for i in decompositions]\n+\n+            if decomp.startswith(\"<\"):\n+                # Compatibility decomposition\n+                compat_decomp[code] = decomp_code_points\n             else:\n-                seq = []\n-                for i in decomp.split():\n-                    seq.append(int(i, 16))\n-                canon_decomp[code] = seq\n-\n-        # place letter in categories as appropriate\n-        for cat in [gencat, \"Assigned\"] + expanded_categories.get(gencat, []):\n-            if cat not in gencats:\n-                gencats[cat] = []\n-            gencats[cat].append(code)\n-\n-        # record combining class, if any\n+                # Canonical decomposition\n+                canon_decomp[code] = decomp_code_points\n+\n+        # Place letter in categories as appropriate.\n+        for cat in itertools.chain((gencat, ), EXPANDED_CATEGORIES.get(gencat, [])):\n+            general_categories[cat].add(code)\n+            category_assigned_codepoints.add(code)\n+\n+        # Record combining class, if any.\n         if combine != \"0\":\n-            if combine not in combines:\n-                combines[combine] = []\n-            combines[combine].append(code)\n-\n-    # generate Not_Assigned from Assigned\n-    gencats[\"Cn\"] = gen_unassigned(gencats[\"Assigned\"])\n-    # Assigned is not a real category\n-    del(gencats[\"Assigned\"])\n+            combines[combine].add(code)\n+\n+    # Generate Not_Assigned from Assigned.\n+    general_categories[\"Cn\"] = get_unassigned_codepoints(category_assigned_codepoints)\n+\n     # Other contains Not_Assigned\n-    gencats[\"C\"].extend(gencats[\"Cn\"])\n-    gencats = group_cats(gencats)\n-    combines = to_combines(group_cats(combines))\n+    general_categories[\"C\"].update(general_categories[\"Cn\"])\n+\n+    grouped_categories = group_categories(general_categories)\n \n-    return (canon_decomp, compat_decomp, gencats, combines, to_upper, to_lower, to_title)\n+    # FIXME: combines are not used\n+    return UnicodeData(\n+        to_lower=to_lower, to_upper=to_upper, to_title=to_title,\n+        compat_decomp=compat_decomp, canon_decomp=canon_decomp,\n+        general_categories=grouped_categories, combines=combines,\n+    )\n \n-def load_special_casing(f, to_upper, to_lower, to_title):\n-    fetch(f)\n-    for line in fileinput.input(fdir + f):\n-        data = line.split('#')[0].split(';')\n+\n+def load_special_casing(file_path, unicode_data):\n+    # type: (str, UnicodeData) -> None\n+    \"\"\"\n+    Load special casing data and enrich given Unicode data.\n+    \"\"\"\n+    for line in fileinput.input(file_path):\n+        data = line.split(\"#\")[0].split(\";\")\n         if len(data) == 5:\n             code, lower, title, upper, _comment = data\n         elif len(data) == 6:\n@@ -155,243 +358,399 @@ def load_special_casing(f, to_upper, to_lower, to_title):\n         title = title.strip()\n         upper = upper.strip()\n         key = int(code, 16)\n-        for (map_, values) in [(to_lower, lower), (to_upper, upper), (to_title, title)]:\n+        for (map_, values) in ((unicode_data.to_lower, lower),\n+                               (unicode_data.to_upper, upper),\n+                               (unicode_data.to_title, title)):\n             if values != code:\n-                values = [int(i, 16) for i in values.split()]\n-                for _ in range(len(values), 3):\n-                    values.append(0)\n-                assert len(values) == 3\n-                map_[key] = values\n-\n-def group_cats(cats):\n-    cats_out = {}\n-    for cat in cats:\n-        cats_out[cat] = group_cat(cats[cat])\n-    return cats_out\n-\n-def group_cat(cat):\n-    cat_out = []\n-    letters = sorted(set(cat))\n-    cur_start = letters.pop(0)\n-    cur_end = cur_start\n-    for letter in letters:\n-        assert letter > cur_end, \\\n-            \"cur_end: %s, letter: %s\" % (hex(cur_end), hex(letter))\n-        if letter == cur_end + 1:\n-            cur_end = letter\n-        else:\n-            cat_out.append((cur_start, cur_end))\n-            cur_start = cur_end = letter\n-    cat_out.append((cur_start, cur_end))\n-    return cat_out\n-\n-def ungroup_cat(cat):\n-    cat_out = []\n-    for (lo, hi) in cat:\n-        while lo <= hi:\n-            cat_out.append(lo)\n-            lo += 1\n-    return cat_out\n-\n-def gen_unassigned(assigned):\n-    assigned = set(assigned)\n-    return ([i for i in range(0, 0xd800) if i not in assigned] +\n-            [i for i in range(0xe000, 0x110000) if i not in assigned])\n-\n-def to_combines(combs):\n-    combs_out = []\n-    for comb in combs:\n-        for (lo, hi) in combs[comb]:\n-            combs_out.append((lo, hi, comb))\n-    combs_out.sort(key=lambda comb: comb[0])\n-    return combs_out\n-\n-def format_table_content(f, content, indent):\n-    line = \" \"*indent\n+                split = values.split()\n+\n+                codepoints = list(itertools.chain(\n+                    (int(i, 16) for i in split),\n+                    (0 for _ in range(len(split), 3))\n+                ))\n+\n+                assert len(codepoints) == 3\n+                map_[key] = codepoints\n+\n+\n+def group_categories(mapping):\n+    # type: (Dict[Any, Iterable[int]]) -> Dict[str, List[Tuple[int, int]]]\n+    \"\"\"\n+    Group codepoints mapped in \"categories\".\n+    \"\"\"\n+    return {category: group_codepoints(codepoints)\n+            for category, codepoints in mapping.items()}\n+\n+\n+def group_codepoints(codepoints):\n+    # type: (Iterable[int]) -> List[Tuple[int, int]]\n+    \"\"\"\n+    Group integral values into continuous, disjoint value ranges.\n+\n+    Performs value deduplication.\n+\n+    :return: sorted list of pairs denoting start and end of codepoint\n+        group values, both ends inclusive.\n+\n+    >>> group_codepoints([1, 2, 10, 11, 12, 3, 4])\n+    [(1, 4), (10, 12)]\n+    >>> group_codepoints([1])\n+    [(1, 1)]\n+    >>> group_codepoints([1, 5, 6])\n+    [(1, 1), (5, 6)]\n+    >>> group_codepoints([])\n+    []\n+    \"\"\"\n+    sorted_codes = sorted(set(codepoints))\n+    result = []     # type: List[Tuple[int, int]]\n+\n+    if not sorted_codes:\n+        return result\n+\n+    next_codes = sorted_codes[1:]\n+    start_code = sorted_codes[0]\n+\n+    for code, next_code in zip_longest(sorted_codes, next_codes, fillvalue=None):\n+        if next_code is None or next_code - code != 1:\n+            result.append((start_code, code))\n+            start_code = next_code\n+\n+    return result\n+\n+\n+def ungroup_codepoints(codepoint_pairs):\n+    # type: (Iterable[Tuple[int, int]]) -> List[int]\n+    \"\"\"\n+    The inverse of group_codepoints -- produce a flat list of values\n+    from value range pairs.\n+\n+    >>> ungroup_codepoints([(1, 4), (10, 12)])\n+    [1, 2, 3, 4, 10, 11, 12]\n+    >>> ungroup_codepoints([(1, 1), (5, 6)])\n+    [1, 5, 6]\n+    >>> ungroup_codepoints(group_codepoints([1, 2, 7, 8]))\n+    [1, 2, 7, 8]\n+    >>> ungroup_codepoints([])\n+    []\n+    \"\"\"\n+    return list(itertools.chain.from_iterable(\n+        range(lo, hi + 1) for lo, hi in codepoint_pairs\n+    ))\n+\n+\n+def get_unassigned_codepoints(assigned_codepoints):\n+    # type: (Set[int]) -> Set[int]\n+    \"\"\"\n+    Given a set of \"assigned\" codepoints, return a set\n+    of these that are not in assigned and not surrogate.\n+    \"\"\"\n+    return {i for i in range(0, 0x110000)\n+            if i not in assigned_codepoints and not is_surrogate(i)}\n+\n+\n+def generate_table_lines(items, indent, wrap=98):\n+    # type: (Iterable[str], int, int) -> Iterator[str]\n+    \"\"\"\n+    Given table items, generate wrapped lines of text with comma-separated items.\n+\n+    This is a generator function.\n+\n+    :param wrap: soft wrap limit (characters per line), integer.\n+    \"\"\"\n+    line = \" \" * indent\n     first = True\n-    for chunk in content.split(\",\"):\n-        if len(line) + len(chunk) < 98:\n+    for item in items:\n+        if len(line) + len(item) < wrap:\n             if first:\n-                line += chunk\n+                line += item\n             else:\n-                line += \", \" + chunk\n+                line += \", \" + item\n             first = False\n         else:\n-            f.write(line + \",\\n\")\n-            line = \" \"*indent + chunk\n-    f.write(line)\n-\n-def load_properties(f, interestingprops):\n-    fetch(f)\n-    props = {}\n-    re1 = re.compile(\"^ *([0-9A-F]+) *; *(\\w+)\")\n-    re2 = re.compile(\"^ *([0-9A-F]+)\\.\\.([0-9A-F]+) *; *(\\w+)\")\n-\n-    for line in fileinput.input(fdir + os.path.basename(f)):\n-        prop = None\n-        d_lo = 0\n-        d_hi = 0\n-        m = re1.match(line)\n-        if m:\n-            d_lo = m.group(1)\n-            d_hi = m.group(1)\n-            prop = m.group(2)\n-        else:\n-            m = re2.match(line)\n-            if m:\n-                d_lo = m.group(1)\n-                d_hi = m.group(2)\n-                prop = m.group(3)\n+            yield line + \",\\n\"\n+            line = \" \" * indent + item\n+\n+    yield line\n+\n+\n+def load_properties(file_path, interesting_props):\n+    # type: (str, Iterable[str]) -> Dict[str, List[Tuple[int, int]]]\n+    \"\"\"\n+    Load properties data and return in grouped form.\n+    \"\"\"\n+    props = defaultdict(list)   # type: Dict[str, List[Tuple[int, int]]]\n+    # \"Raw string\" is necessary for `\\.` and `\\w` not to be treated as escape chars\n+    # (for the sake of compat with future Python versions).\n+    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n+    re1 = re.compile(r\"^ *([0-9A-F]+) *; *(\\w+)\")\n+    re2 = re.compile(r\"^ *([0-9A-F]+)\\.\\.([0-9A-F]+) *; *(\\w+)\")\n+\n+    for line in fileinput.input(file_path):\n+        match = re1.match(line) or re2.match(line)\n+        if match:\n+            groups = match.groups()\n+\n+            if len(groups) == 2:\n+                # `re1` matched (2 groups).\n+                d_lo, prop = groups\n+                d_hi = d_lo\n             else:\n-                continue\n-        if interestingprops and prop not in interestingprops:\n+                d_lo, d_hi, prop = groups\n+        else:\n+            continue\n+\n+        if interesting_props and prop not in interesting_props:\n             continue\n-        d_lo = int(d_lo, 16)\n-        d_hi = int(d_hi, 16)\n-        if prop not in props:\n-            props[prop] = []\n-        props[prop].append((d_lo, d_hi))\n \n-    # optimize if possible\n+        lo_value = int(d_lo, 16)\n+        hi_value = int(d_hi, 16)\n+\n+        props[prop].append((lo_value, hi_value))\n+\n+    # Optimize if possible.\n     for prop in props:\n-        props[prop] = group_cat(ungroup_cat(props[prop]))\n+        props[prop] = group_codepoints(ungroup_codepoints(props[prop]))\n \n     return props\n \n-def escape_char(c):\n-    return \"'\\\\u{%x}'\" % c if c != 0 else \"'\\\\0'\"\n \n-def emit_table(f, name, t_data, t_type = \"&[(char, char)]\", is_pub=True,\n-        pfun=lambda x: \"(%s,%s)\" % (escape_char(x[0]), escape_char(x[1]))):\n+def escape_char(c):\n+    # type: (int) -> str\n+    r\"\"\"\n+    Escape a codepoint for use as Rust char literal.\n+\n+    Outputs are OK to use as Rust source code as char literals\n+    and they also include necessary quotes.\n+\n+    >>> escape_char(97)\n+    \"'\\\\u{61}'\"\n+    >>> escape_char(0)\n+    \"'\\\\0'\"\n+    \"\"\"\n+    return r\"'\\u{%x}'\" % c if c != 0 else r\"'\\0'\"\n+\n+\n+def format_char_pair(pair):\n+    # type: (Tuple[int, int]) -> str\n+    \"\"\"\n+    Format a pair of two Rust chars.\n+    \"\"\"\n+    return \"(%s,%s)\" % (escape_char(pair[0]), escape_char(pair[1]))\n+\n+\n+def generate_table(\n+    name,   # type: str\n+    items,  # type: List[Tuple[int, int]]\n+    decl_type=\"&[(char, char)]\",    # type: str\n+    is_pub=True,                    # type: bool\n+    format_item=format_char_pair,   # type: Callable[[Tuple[int, int]], str]\n+):\n+    # type: (...) -> Iterator[str]\n+    \"\"\"\n+    Generate a nicely formatted Rust constant \"table\" array.\n+\n+    This generates actual Rust code.\n+    \"\"\"\n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n-    f.write(\"    %sconst %s: %s = &[\\n\" % (pub_string, name, t_type))\n-    data = \"\"\n+\n+    yield \"    %sconst %s: %s = &[\\n\" % (pub_string, name, decl_type)\n+\n+    data = []\n     first = True\n-    for dat in t_data:\n+    for item in items:\n         if not first:\n-            data += \",\"\n+            data.append(\",\")\n         first = False\n-        data += pfun(dat)\n-    format_table_content(f, data, 8)\n-    f.write(\"\\n    ];\\n\\n\")\n+        data.extend(format_item(item))\n \n-def compute_trie(rawdata, chunksize):\n+    for table_line in generate_table_lines(\"\".join(data).split(\",\"), 8):\n+        yield table_line\n+\n+    yield \"\\n    ];\\n\\n\"\n+\n+\n+def compute_trie(raw_data, chunk_size):\n+    # type: (List[int], int) -> Tuple[List[int], List[int]]\n+    \"\"\"\n+    Compute postfix-compressed trie.\n+\n+    See: bool_trie.rs for more details.\n+\n+    >>> compute_trie([1, 2, 3, 1, 2, 3, 4, 5, 6], 3)\n+    ([0, 0, 1], [1, 2, 3, 4, 5, 6])\n+    >>> compute_trie([1, 2, 3, 1, 2, 4, 4, 5, 6], 3)\n+    ([0, 1, 2], [1, 2, 3, 1, 2, 4, 4, 5, 6])\n+    \"\"\"\n     root = []\n-    childmap = {}\n+    childmap = {}       # type: Dict[Tuple[int, ...], int]\n     child_data = []\n-    for i in range(len(rawdata) // chunksize):\n-        data = rawdata[i * chunksize: (i + 1) * chunksize]\n-        child = '|'.join(map(str, data))\n+\n+    assert len(raw_data) % chunk_size == 0, \"Chunks must be equally sized\"\n+\n+    for i in range(len(raw_data) // chunk_size):\n+        data = raw_data[i * chunk_size : (i + 1) * chunk_size]\n+\n+        # Postfix compression of child nodes (data chunks)\n+        # (identical child nodes are shared).\n+\n+        # Make a tuple out of the list so it's hashable.\n+        child = tuple(data)\n         if child not in childmap:\n             childmap[child] = len(childmap)\n             child_data.extend(data)\n+\n         root.append(childmap[child])\n-    return (root, child_data)\n \n-def emit_bool_trie(f, name, t_data, is_pub=True):\n-    CHUNK = 64\n+    return root, child_data\n+\n+\n+def generate_bool_trie(name, codepoint_ranges, is_pub=True):\n+    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n+    \"\"\"\n+    Generate Rust code for BoolTrie struct.\n+\n+    This yields string fragments that should be joined to produce\n+    the final string.\n+\n+    See: `bool_trie.rs`.\n+    \"\"\"\n+    chunk_size = 64\n     rawdata = [False] * 0x110000\n-    for (lo, hi) in t_data:\n+    for (lo, hi) in codepoint_ranges:\n         for cp in range(lo, hi + 1):\n             rawdata[cp] = True\n \n-    # convert to bitmap chunks of 64 bits each\n+    # Convert to bitmap chunks of `chunk_size` bits each.\n     chunks = []\n-    for i in range(0x110000 // CHUNK):\n+    for i in range(0x110000 // chunk_size):\n         chunk = 0\n-        for j in range(64):\n-            if rawdata[i * 64 + j]:\n+        for j in range(chunk_size):\n+            if rawdata[i * chunk_size + j]:\n                 chunk |= 1 << j\n         chunks.append(chunk)\n \n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n-    f.write(\"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name))\n-    f.write(\"        r1: [\\n\")\n-    data = ','.join('0x%016x' % chunk for chunk in chunks[0:0x800 // CHUNK])\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n+    yield \"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name)\n+    yield \"        r1: [\\n\"\n+    data = (\"0x%016x\" % chunk for chunk in chunks[:0x800 // chunk_size])\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n \n     # 0x800..0x10000 trie\n-    (r2, r3) = compute_trie(chunks[0x800 // CHUNK : 0x10000 // CHUNK], 64 // CHUNK)\n-    f.write(\"        r2: [\\n\")\n-    data = ','.join(str(node) for node in r2)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-    f.write(\"        r3: &[\\n\")\n-    data = ','.join('0x%016x' % chunk for chunk in r3)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n+    (r2, r3) = compute_trie(chunks[0x800 // chunk_size : 0x10000 // chunk_size], 64 // chunk_size)\n+    yield \"        r2: [\\n\"\n+    data = map(str, r2)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"        r3: &[\\n\"\n+    data = (\"0x%016x\" % node for node in r3)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n \n     # 0x10000..0x110000 trie\n-    (mid, r6) = compute_trie(chunks[0x10000 // CHUNK : 0x110000 // CHUNK], 64 // CHUNK)\n+    (mid, r6) = compute_trie(chunks[0x10000 // chunk_size : 0x110000 // chunk_size],\n+                             64 // chunk_size)\n     (r4, r5) = compute_trie(mid, 64)\n-    f.write(\"        r4: [\\n\")\n-    data = ','.join(str(node) for node in r4)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-    f.write(\"        r5: &[\\n\")\n-    data = ','.join(str(node) for node in r5)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-    f.write(\"        r6: &[\\n\")\n-    data = ','.join('0x%016x' % chunk for chunk in r6)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-\n-    f.write(\"    };\\n\\n\")\n-\n-def emit_small_bool_trie(f, name, t_data, is_pub=True):\n-    last_chunk = max(hi // 64 for (lo, hi) in t_data)\n+\n+    yield \"        r4: [\\n\"\n+    data = map(str, r4)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"        r5: &[\\n\"\n+    data = map(str, r5)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"        r6: &[\\n\"\n+    data = (\"0x%016x\" % node for node in r6)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"    };\\n\\n\"\n+\n+\n+def generate_small_bool_trie(name, codepoint_ranges, is_pub=True):\n+    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n+    \"\"\"\n+    Generate Rust code for `SmallBoolTrie` struct.\n+\n+    See: `bool_trie.rs`.\n+    \"\"\"\n+    last_chunk = max(hi // 64 for (lo, hi) in codepoint_ranges)\n     n_chunks = last_chunk + 1\n     chunks = [0] * n_chunks\n-    for (lo, hi) in t_data:\n+    for (lo, hi) in codepoint_ranges:\n         for cp in range(lo, hi + 1):\n-            if cp // 64 >= len(chunks):\n-                print(cp, cp // 64, len(chunks), lo, hi)\n+            assert cp // 64 < len(chunks)\n             chunks[cp // 64] |= 1 << (cp & 63)\n \n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n-    f.write(\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n-            % (pub_string, name))\n+\n+    yield (\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n+           % (pub_string, name))\n \n     (r1, r2) = compute_trie(chunks, 1)\n \n-    f.write(\"        r1: &[\\n\")\n-    data = ','.join(str(node) for node in r1)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-\n-    f.write(\"        r2: &[\\n\")\n-    data = ','.join('0x%016x' % node for node in r2)\n-    format_table_content(f, data, 12)\n-    f.write(\"\\n        ],\\n\")\n-\n-    f.write(\"    };\\n\\n\")\n-\n-def emit_property_module(f, mod, tbl, emit):\n-    f.write(\"pub mod %s {\\n\" % mod)\n-    for cat in sorted(emit):\n-        if cat in [\"Cc\", \"White_Space\", \"Pattern_White_Space\"]:\n-            emit_small_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n-            f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-            f.write(\"        %s_table.lookup(c)\\n\" % cat)\n-            f.write(\"    }\\n\\n\")\n+    yield \"        r1: &[\\n\"\n+    data = (str(node) for node in r1)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"        r2: &[\\n\"\n+    data = (\"0x%016x\" % node for node in r2)\n+    for fragment in generate_table_lines(data, 12):\n+        yield fragment\n+    yield \"\\n        ],\\n\"\n+\n+    yield \"    };\\n\\n\"\n+\n+\n+def generate_property_module(mod, grouped_categories, category_subset):\n+    # type: (str, Dict[str, List[Tuple[int, int]]], Iterable[str]) -> Iterator[str]\n+    \"\"\"\n+    Generate Rust code for module defining properties.\n+    \"\"\"\n+\n+    yield \"pub mod %s {\\n\" % mod\n+    for cat in sorted(category_subset):\n+        if cat in (\"Cc\", \"White_Space\", \"Pattern_White_Space\"):\n+            generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n         else:\n-            emit_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n-            f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-            f.write(\"        %s_table.lookup(c)\\n\" % cat)\n-            f.write(\"    }\\n\\n\")\n-    f.write(\"}\\n\\n\")\n-\n-def emit_conversions_module(f, to_upper, to_lower, to_title):\n-    f.write(\"pub mod conversions {\")\n-    f.write(\"\"\"\n+            generator = generate_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n+\n+        for fragment in generator:\n+            yield fragment\n+\n+        yield \"    pub fn %s(c: char) -> bool {\\n\" % cat\n+        yield \"        %s_table.lookup(c)\\n\" % cat\n+        yield \"    }\\n\\n\"\n+\n+    yield \"}\\n\\n\"\n+\n+\n+def generate_conversions_module(unicode_data):\n+    # type: (UnicodeData) -> Iterator[str]\n+    \"\"\"\n+    Generate Rust code for module defining conversions.\n+    \"\"\"\n+\n+    yield \"pub mod conversions {\"\n+    yield \"\"\"\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n             None        => [c, '\\\\0', '\\\\0'],\n@@ -408,80 +767,109 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n \n     fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-    }\n+    }\\n\\n\"\"\"\n+\n+    decl_type = \"&[(char, [char; 3])]\"\n+    format_conversion = lambda x: \"({},[{},{},{}])\".format(*(\n+        escape_char(c) for c in (x[0], x[1][0], x[1][1], x[1][2])\n+    ))\n+\n+    for fragment in generate_table(\n+        name=\"to_lowercase_table\",\n+        items=sorted(unicode_data.to_lower.items(), key=lambda x: x[0]),\n+        decl_type=decl_type,\n+        is_pub=False,\n+        format_item=format_conversion\n+    ):\n+        yield fragment\n+\n+    for fragment in generate_table(\n+        name=\"to_uppercase_table\",\n+        items=sorted(unicode_data.to_upper.items(), key=lambda x: x[0]),\n+        decl_type=decl_type,\n+        is_pub=False,\n+        format_item=format_conversion\n+    ):\n+        yield fragment\n+\n+    yield \"}\\n\"\n+\n+\n+def parse_args():\n+    # type: () -> argparse.Namespace\n+    \"\"\"\n+    Parse command line arguments.\n+    \"\"\"\n+    parser = argparse.ArgumentParser(description=__doc__)\n+    parser.add_argument(\"-v\", \"--version\", default=None, type=str,\n+                        help=\"Unicode version to use (if not specified,\"\n+                             \" defaults to latest release).\")\n+\n+    return parser.parse_args()\n+\n+\n+def main():\n+    # type: () -> None\n+    \"\"\"\n+    Script entry point.\n+    \"\"\"\n+    args = parse_args()\n+\n+    unicode_version = fetch_files(args.version)\n+    print(\"Using Unicode version: {}\".format(unicode_version.as_str))\n+\n+    # All the writing happens entirely in memory, we only write to file\n+    # once we have generated the file content (it's not very large, <1 MB).\n+    buf = StringIO()\n+    buf.write(PREAMBLE)\n+\n+    unicode_version_notice = textwrap.dedent(\"\"\"\n+    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+    /// `char` and `str` methods are based on.\n+    #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+    pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {{\n+        major: {version.major},\n+        minor: {version.minor},\n+        micro: {version.micro},\n+        _priv: (),\n+    }};\n+    \"\"\").format(version=unicode_version)\n+    buf.write(unicode_version_notice)\n+\n+    get_path = lambda f: get_unicode_file_path(unicode_version, f)\n+\n+    unicode_data = load_unicode_data(get_path(UnicodeFiles.UNICODE_DATA))\n+    load_special_casing(get_path(UnicodeFiles.SPECIAL_CASING), unicode_data)\n+\n+    want_derived = {\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\",\n+                    \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"}\n+    derived = load_properties(get_path(UnicodeFiles.DERIVED_CORE_PROPERTIES), want_derived)\n+\n+    props = load_properties(get_path(UnicodeFiles.PROPS),\n+                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\",\n+                             \"Pattern_White_Space\"})\n+\n+    # Category tables\n+    for (name, categories, category_subset) in (\n+            (\"general_category\", unicode_data.general_categories, [\"N\", \"Cc\"]),\n+            (\"derived_property\", derived, want_derived),\n+            (\"property\", props, [\"White_Space\", \"Pattern_White_Space\"])\n+    ):\n+        for fragment in generate_property_module(name, categories, category_subset):\n+            buf.write(fragment)\n+\n+    for fragment in generate_conversions_module(unicode_data):\n+        buf.write(fragment)\n+\n+    tables_rs_path = os.path.join(THIS_DIR, \"tables.rs\")\n+\n+    # Actually write out the file content.\n+    # Will overwrite the file if it exists.\n+    with open(tables_rs_path, \"w\") as fd:\n+        fd.write(buf.getvalue())\n+\n+    print(\"Regenerated tables.rs.\")\n \n-\"\"\")\n-    t_type = \"&[(char, [char; 3])]\"\n-    pfun = lambda x: \"(%s,[%s,%s,%s])\" % (\n-        escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2]))\n-    emit_table(f, \"to_lowercase_table\",\n-        sorted(to_lower.items(), key=operator.itemgetter(0)),\n-        is_pub=False, t_type = t_type, pfun=pfun)\n-    emit_table(f, \"to_uppercase_table\",\n-        sorted(to_upper.items(), key=operator.itemgetter(0)),\n-        is_pub=False, t_type = t_type, pfun=pfun)\n-    f.write(\"}\\n\\n\")\n-\n-def emit_norm_module(f, canon, compat, combine, norm_props):\n-    canon_keys = sorted(canon.keys())\n-\n-    compat_keys = sorted(compat.keys())\n-\n-    canon_comp = {}\n-    comp_exclusions = norm_props[\"Full_Composition_Exclusion\"]\n-    for char in canon_keys:\n-        if any(lo <= char <= hi for lo, hi in comp_exclusions):\n-            continue\n-        decomp = canon[char]\n-        if len(decomp) == 2:\n-            if decomp[0] not in canon_comp:\n-                canon_comp[decomp[0]] = []\n-            canon_comp[decomp[0]].append( (decomp[1], char) )\n-    canon_comp_keys = sorted(canon_comp.keys())\n \n if __name__ == \"__main__\":\n-    r = fdir + \"tables.rs\"\n-    if os.path.exists(r):\n-        os.remove(r)\n-    with open(r, \"w\") as rf:\n-        # write the file's preamble\n-        rf.write(preamble)\n-\n-        # download and parse all the data\n-        fetch(\"ReadMe.txt\")\n-        with open(fdir + \"ReadMe.txt\") as readme:\n-            pattern = \"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n-            unicode_version = re.search(pattern, readme.read()).groups()\n-        rf.write(\"\"\"\n-/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n-/// `char` and `str` methods are based on.\n-#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n-    major: %s,\n-    minor: %s,\n-    micro: %s,\n-    _priv: (),\n-};\n-\"\"\" % unicode_version)\n-        (canon_decomp, compat_decomp, gencats, combines,\n-                to_upper, to_lower, to_title) = load_unicode_data(\"UnicodeData.txt\")\n-        load_special_casing(\"SpecialCasing.txt\", to_upper, to_lower, to_title)\n-        want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\",\n-                        \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"]\n-        derived = load_properties(\"DerivedCoreProperties.txt\", want_derived)\n-        scripts = load_properties(\"Scripts.txt\", [])\n-        props = load_properties(\"PropList.txt\",\n-                [\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\", \"Pattern_White_Space\"])\n-        norm_props = load_properties(\"DerivedNormalizationProps.txt\",\n-                     [\"Full_Composition_Exclusion\"])\n-\n-        # category tables\n-        for (name, cat, pfuns) in (\"general_category\", gencats, [\"N\", \"Cc\"]), \\\n-                                  (\"derived_property\", derived, want_derived), \\\n-                                  (\"property\", props, [\"White_Space\", \"Pattern_White_Space\"]):\n-            emit_property_module(rf, name, cat, pfuns)\n-\n-        # normalizations and conversions module\n-        emit_norm_module(rf, canon_decomp, compat_decomp, combines, norm_props)\n-        emit_conversions_module(rf, to_upper, to_lower, to_title)\n-    print(\"Regenerated tables.rs.\")\n+    main()"}, {"sha": "271fac544a4d253892889203e3c37e4a9cb04443", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -4010,7 +4010,7 @@ impl<'a> LoweringContext<'a> {\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n-                              attr::contains_name(&i.attrs, sym::rustc_doc_only_macro) {\n+                              attr::contains_name(&i.attrs, sym::rustc_builtin_macro) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "3b2701b893bb11818e9b56d6f4aabe084631cd04", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -170,8 +170,7 @@ impl CodegenCx<'ll, 'tcx> {\n     pub fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n         unsafe {\n             if self.is_const_real(v) {\n-                #[allow(deprecated)]\n-                let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+                let mut loses_info: llvm::Bool = 0;\n                 let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n                 let loses_info = if loses_info == 1 { true } else { false };\n                 Some((r, loses_info))"}, {"sha": "dafb8c5f8f706a80325a1faced2ac1ba5a5a8ab0", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1465,7 +1465,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n                     .collect(),\n             };\n-            debug!(\"Entering guard building context: {:?}\", guard_frame);\n+            debug!(\"entering guard building context: {:?}\", guard_frame);\n             self.guard_context.push(guard_frame);\n \n             let re_erased = tcx.lifetimes.re_erased;"}, {"sha": "42bbe88283b78d9520dc8568fcec445c165e0a62", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -577,7 +577,7 @@ fn check_legality_of_move_bindings(\n                                            \"cannot bind by-move into a pattern guard\");\n             err.span_label(p.span, \"moves value into pattern guard\");\n             if cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n-                err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\\n+                err.help(\"add `#![feature(bind_by_move_pattern_guards)]` to the \\\n                           crate attributes to enable\");\n             }\n             err.emit();\n@@ -664,7 +664,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n                           \"cannot mutably borrow in a pattern guard\");\n                 err.span_label(span, \"borrowed mutably in pattern guard\");\n                 if self.cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n-                    err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\\n+                    err.help(\"add `#![feature(bind_by_move_pattern_guards)]` to the \\\n                               crate attributes to enable\");\n                 }\n                 err.emit();"}, {"sha": "3dee02989c9f93a865751bc3ffa7ffce8477b573", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -351,7 +351,7 @@ where\n                 if field >= len {\n                     // This can be violated because this runs during promotion on code where the\n                     // type system has not yet ensured that such things don't happen.\n-                    debug!(\"Tried to access element {} of array/slice with length {}\", field, len);\n+                    debug!(\"tried to access element {} of array/slice with length {}\", field, len);\n                     return err!(BoundsCheck { len, index: field });\n                 }\n                 stride * field"}, {"sha": "bcc6ad4eac29f9b6feb16f832d41c976190bdf0a", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -289,7 +289,7 @@ pub fn collect_crate_mono_items(\n         collect_roots(tcx, mode)\n     });\n \n-    debug!(\"Building mono item graph, beginning at roots\");\n+    debug!(\"building mono item graph, beginning at roots\");\n \n     let mut visited = MTLock::new(FxHashSet::default());\n     let mut inlining_map = MTLock::new(InliningMap::new());\n@@ -316,7 +316,7 @@ pub fn collect_crate_mono_items(\n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n-    debug!(\"Collecting roots\");\n+    debug!(\"collecting roots\");\n     let mut roots = Vec::new();\n \n     {"}, {"sha": "0c48531e345217f852711bb1d878153997b7e90b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -552,10 +552,10 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n     // FIXME: when we make this a hard error, this should have its\n     // own error code.\n     let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-        \"#[derive] can't be used on a #[repr(packed)] struct with \\\n+        \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n          type or const parameters (error E0133)\".to_string()\n     } else {\n-        \"#[derive] can't be used on a #[repr(packed)] struct that \\\n+        \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n          does not derive Copy (error E0133)\".to_string()\n     };\n     tcx.lint_hir(SAFE_PACKED_BORROWS,"}, {"sha": "88a46b1012b6169950c1894bf229adce43bb194a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -47,7 +47,7 @@ impl MirPass for CopyPropagation {\n \n             let mut changed = false;\n             for dest_local in body.local_decls.indices() {\n-                debug!(\"Considering destination local: {:?}\", dest_local);\n+                debug!(\"considering destination local: {:?}\", dest_local);\n \n                 let action;\n                 let location;\n@@ -159,7 +159,7 @@ fn eliminate_self_assignments(\n             } else {\n                 continue;\n             }\n-            debug!(\"Deleting a self-assignment for {:?}\", dest_local);\n+            debug!(\"deleting a self-assignment for {:?}\", dest_local);\n             body.make_statement_nop(location);\n             changed = true;\n         }"}, {"sha": "04ee14f5f59bea8091eff3cbf3b89511b0c1d2d9", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -159,7 +159,7 @@ impl Inliner<'tcx> {\n \n         // Simplify if we inlined anything.\n         if changed {\n-            debug!(\"Running simplify cfg on {:?}\", self.source);\n+            debug!(\"running simplify cfg on {:?}\", self.source);\n             CfgSimplifier::new(caller_body).simplify();\n             remove_dead_blocks(caller_body);\n         }\n@@ -247,7 +247,7 @@ impl Inliner<'tcx> {\n             // need to check for first.\n             attr::InlineAttr::Always => true,\n             attr::InlineAttr::Never => {\n-                debug!(\"#[inline(never)] present - not inlining\");\n+                debug!(\"`#[inline(never)]` present - not inlining\");\n                 return false\n             }\n             attr::InlineAttr::Hint => true,\n@@ -397,7 +397,7 @@ impl Inliner<'tcx> {\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-                debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n+                debug!(\"inlined {:?} into {:?}\", callsite.callee, self.source);\n \n                 let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n@@ -456,7 +456,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {\n-                    debug!(\"Creating temp for return destination\");\n+                    debug!(\"creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n                         self.tcx.lifetimes.re_erased,\n                         BorrowKind::Mut { allow_two_phase_borrow: false },\n@@ -610,7 +610,7 @@ impl Inliner<'tcx> {\n             }\n         }\n \n-        debug!(\"Creating temp for argument {:?}\", arg);\n+        debug!(\"creating temp for argument {:?}\", arg);\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n@@ -659,7 +659,7 @@ struct Integrator<'a, 'tcx> {\n impl<'a, 'tcx> Integrator<'a, 'tcx> {\n     fn update_target(&self, tgt: BasicBlock) -> BasicBlock {\n         let new = BasicBlock::new(tgt.index() + self.block_idx);\n-        debug!(\"Updating target `{:?}`, new: `{:?}`\", tgt, new);\n+        debug!(\"updating target `{:?}`, new: `{:?}`\", tgt, new);\n         new\n     }\n }"}, {"sha": "40563ad4167d5c206e1b5e45faba8e66cd909d31", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -39,7 +39,7 @@ pub struct InstCombineVisitor<'tcx> {\n impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n-            debug!(\"Replacing `&*`: {:?}\", rvalue);\n+            debug!(\"replacing `&*`: {:?}\", rvalue);\n             let new_place = match *rvalue {\n                 Rvalue::Ref(_, _, Place::Projection(ref mut projection)) => {\n                     // Replace with dummy\n@@ -51,7 +51,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n         }\n \n         if let Some(constant) = self.optimizations.arrays_lengths.remove(&location) {\n-            debug!(\"Replacing `Len([_; N])`: {:?}\", rvalue);\n+            debug!(\"replacing `Len([_; N])`: {:?}\", rvalue);\n             *rvalue = Rvalue::Use(Operand::Constant(box constant));\n         }\n "}, {"sha": "2dffafd6e54c0b07131eb8b24b3b36b1b001b669", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1545,7 +1545,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                             diag.note(\"for more information, see issue \\\n                                        https://github.com/rust-lang/rust/issues/57563\");\n                             diag.help(\n-                                \"add #![feature(const_fn)] to the crate attributes to enable\",\n+                                \"add `#![feature(const_fn)]` to the crate attributes to enable\",\n                             );\n                             diag.emit();\n                         } else {"}, {"sha": "05df3a6f6bc2eeba279a37fb4c84a517b491b6cd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -28,6 +28,7 @@ use rustc_data_structures::fx::FxHashSet;\n use syntax::ast::Ident;\n use syntax::attr;\n use syntax::symbol::{kw, sym};\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -743,7 +744,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.legacy {\n+        if attr::find_transparency(&md.attrs, md.legacy).0 != Transparency::Opaque {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return\n         }"}, {"sha": "3921bd30df25ce5caae147597b52dfa13830dc83", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -770,27 +770,33 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n+        self.opt_get_macro(res).expect(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\")\n+    }\n+\n+    crate fn opt_get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         let def_id = match res {\n+            Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) =>\n+                return Some(self.non_macro_attr(true)), // some dummy extension\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n             Res::NonMacroAttr(attr_kind) =>\n-                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n-            _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n+                return Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => return None,\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n-            return ext.clone();\n+            return Some(ext.clone());\n         }\n \n         let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return ext,\n+            LoadedMacro::ProcMacro(ext) => return Some(ext),\n         };\n \n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                &macro_def,\n                                                self.cstore.crate_edition_untracked(def_id.krate)));\n         self.macro_map.insert(def_id, ext.clone());\n-        ext\n+        Some(ext)\n     }\n \n     /// Ensures that the reduced graph rooted at the given external module"}, {"sha": "0955c425f2f7da821a0e37752c257702bbcc31a1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1106,6 +1106,19 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n+    crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n+        // Reserve some names that are not quite covered by the general check\n+        // performed on `Resolver::builtin_attrs`.\n+        if ident.name == sym::cfg || ident.name == sym::cfg_attr || ident.name == sym::derive {\n+            let macro_kind = self.opt_get_macro(res).map(|ext| ext.macro_kind());\n+            if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n+                self.session.span_err(\n+                    ident.span, &format!(\"name `{}` is reserved in attribute namespace\", ident)\n+                );\n+            }\n+        }\n+    }\n+\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: Mark,\n@@ -1117,13 +1130,14 @@ impl<'a> Resolver<'a> {\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                item, self.session.edition()));\n+        let macro_kind = ext.macro_kind();\n+        let res = Res::Def(DefKind::Macro(macro_kind), def_id);\n         self.macro_map.insert(def_id, ext);\n \n         let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n@@ -1142,14 +1156,11 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, sym::rustc_doc_only_macro) {\n-                    self.check_reserved_macro_name(ident, MacroNS);\n-                }\n+                self.check_reserved_macro_name(ident, res);\n                 self.unused_macros.insert(def_id);\n             }\n         } else {\n             let module = self.current_module;\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(def_id);"}, {"sha": "7de1cd29a9ca84aea1a00764c0f4dc65baba8163", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -492,35 +492,25 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    crate fn check_reserved_macro_name(&self, ident: Ident, ns: Namespace) {\n-        // Reserve some names that are not quite covered by the general check\n-        // performed on `Resolver::builtin_attrs`.\n-        if ns == MacroNS &&\n-           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n-            ident.name == sym::derive) {\n-            self.session.span_err(ident.span,\n-                                  &format!(\"name `{}` is reserved in macro namespace\", ident));\n-        }\n-    }\n-\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define(&mut self,\n                       module: Module<'a>,\n                       ident: Ident,\n                       ns: Namespace,\n                       binding: &'a NameBinding<'a>)\n                       -> Result<(), &'a NameBinding<'a>> {\n-        self.check_reserved_macro_name(ident, ns);\n+        let res = binding.res();\n+        self.check_reserved_macro_name(ident, res);\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.res() == Res::Err {\n+                if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n                     return Ok(());\n                 }\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n-                        if binding.res() != old_binding.res() {\n+                        if res != old_binding.res() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n                                                                      old_binding, binding));\n                         } else if !old_binding.vis.is_at_least(binding.vis, &*this) {"}, {"sha": "b3e09d6974229d7108bdd0af4b4678f0f282154b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -410,7 +410,7 @@ mod builtin {\n     ///\n     /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! compile_error {\n         ($msg:expr) => ({ /* compiler built-in */ });\n         ($msg:expr,) => ({ /* compiler built-in */ });\n@@ -462,7 +462,7 @@ mod builtin {\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n@@ -500,7 +500,7 @@ mod builtin {\n     /// error: what's that?!\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! env {\n         ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ });\n@@ -526,7 +526,7 @@ mod builtin {\n     /// println!(\"the secret key might be: {:?}\", key);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! option_env {\n         ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ });\n@@ -557,7 +557,7 @@ mod builtin {\n     /// # }\n     /// ```\n     #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! concat_idents {\n         ($($e:ident),+) => ({ /* compiler built-in */ });\n         ($($e:ident,)+) => ({ /* compiler built-in */ });\n@@ -579,7 +579,7 @@ mod builtin {\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! concat {\n         ($($e:expr),*) => ({ /* compiler built-in */ });\n         ($($e:expr,)*) => ({ /* compiler built-in */ });\n@@ -607,7 +607,7 @@ mod builtin {\n     /// println!(\"defined on line: {}\", current_line);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n     /// Expands to the column number at which it was invoked.\n@@ -632,7 +632,7 @@ mod builtin {\n     /// println!(\"defined on column: {}\", current_col);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n     /// Expands to the file name in which it was invoked.\n@@ -656,7 +656,7 @@ mod builtin {\n     /// println!(\"defined in file: {}\", this_file);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n     /// Stringifies its arguments.\n@@ -675,7 +675,7 @@ mod builtin {\n     /// assert_eq!(one_plus_one, \"1 + 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n@@ -709,7 +709,7 @@ mod builtin {\n     ///\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include_str {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -746,7 +746,7 @@ mod builtin {\n     ///\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include_bytes {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -770,7 +770,7 @@ mod builtin {\n     /// test::foo();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n@@ -794,7 +794,7 @@ mod builtin {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Parses a file as an expression or an item according to the context.\n@@ -837,7 +837,7 @@ mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print\n     /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -889,7 +889,7 @@ mod builtin {\n     /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! assert {\n         ($cond:expr) => ({ /* compiler built-in */ });\n         ($cond:expr,) => ({ /* compiler built-in */ });"}, {"sha": "752ab5d474dffe55042d8054c45ef4d07fcffb6a", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,6 +5,7 @@ use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n use errors::{Applicability, Handler};\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::{symbol::Symbol, symbol::sym, Span};\n \n use super::{mark_used, MetaItemKind};\n@@ -854,3 +855,35 @@ fn int_type_of_word(s: Symbol) -> Option<IntType> {\n         _ => None\n     }\n }\n+\n+pub enum TransparencyError {\n+    UnknownTransparency(Symbol, Span),\n+    MultipleTransparencyAttrs(Span, Span),\n+}\n+\n+pub fn find_transparency(\n+    attrs: &[Attribute], is_legacy: bool\n+) -> (Transparency, Option<TransparencyError>) {\n+    let mut transparency = None;\n+    let mut error = None;\n+    for attr in attrs {\n+        if attr.check_name(sym::rustc_macro_transparency) {\n+            if let Some((_, old_span)) = transparency {\n+                error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n+                break;\n+            } else if let Some(value) = attr.value_str() {\n+                transparency = Some((match &*value.as_str() {\n+                    \"transparent\" => Transparency::Transparent,\n+                    \"semitransparent\" => Transparency::SemiTransparent,\n+                    \"opaque\" => Transparency::Opaque,\n+                    _ => {\n+                        error = Some(TransparencyError::UnknownTransparency(value, attr.span));\n+                        continue;\n+                    }\n+                }, attr.span));\n+            }\n+        }\n+    }\n+    let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    (transparency.map_or(fallback, |t| t.0), error)\n+}"}, {"sha": "a9f2429560ad288ff68901812df07c5ad3e04737", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -2,11 +2,7 @@\n \n mod builtin;\n \n-pub use builtin::{\n-    cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n-    find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, OptimizeAttr,\n-    IntType, ReprAttr, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n-};\n+pub use builtin::*;\n pub use IntType::*;\n pub use ReprAttr::*;\n pub use StabilityLevel::*;"}, {"sha": "cf3c748cd8206f39f2f08fd27ddb6b36ad8d292c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -2,7 +2,6 @@ use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n use crate::ext::tt::macro_parser::{Error, Failure, Success};\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq};\n@@ -15,7 +14,7 @@ use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n-use crate::{ast, attr};\n+use crate::{ast, attr, attr::TransparencyError};\n \n use errors::FatalError;\n use log::debug;\n@@ -380,13 +379,19 @@ pub fn compile(\n     let expander: Box<_> =\n         Box::new(MacroRulesMacroExpander { name: def.ident, lhses, rhses, valid });\n \n-    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n-        Transparency::Transparent\n-    } else if body.legacy {\n-        Transparency::SemiTransparent\n-    } else {\n-        Transparency::Opaque\n-    };\n+    let (default_transparency, transparency_error) =\n+        attr::find_transparency(&def.attrs, body.legacy);\n+    match transparency_error {\n+        Some(TransparencyError::UnknownTransparency(value, span)) =>\n+            sess.span_diagnostic.span_err(\n+                span, &format!(\"unknown macro transparency: `{}`\", value)\n+            ),\n+        Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) =>\n+            sess.span_diagnostic.span_err(\n+                vec![old_span, new_span], \"multiple macro transparency attributes\"\n+            ),\n+        None => {}\n+    }\n \n     let allow_internal_unstable =\n         attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {"}, {"sha": "2b242a71ad4ccae9bcb0cb001ef8ced9d64da6d5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -245,7 +245,7 @@ declare_features! (\n     (active, allocator_internals, \"1.20.0\", None, None),\n \n     // Allows using the `format_args_nl` macro.\n-    (active, format_args_nl, \"1.29.0\", None, None),\n+    (active, format_args_nl, \"1.29.0\", Some(0), None),\n \n     // no-tracking-issue-end\n \n@@ -1313,7 +1313,9 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                     \"the `#[rustc_test_marker]` attribute \\\n                                     is used internally to track tests\",\n                                     cfg_fn!(rustc_attrs))),\n-    (sym::rustc_transparent_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (sym::rustc_macro_transparency, Whitelisted, template!(NameValueStr:\n+                                                           \"transparent|semitransparent|opaque\"),\n+                                                Gated(Stability::Unstable,\n                                                 sym::rustc_attrs,\n                                                 \"used internally for testing macro hygiene\",\n                                                     cfg_fn!(rustc_attrs))),\n@@ -1374,7 +1376,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),\n \n-    (sym::rustc_doc_only_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (sym::rustc_builtin_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                                 sym::rustc_attrs,\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),"}, {"sha": "410f4b36b67f29c1976ddf890df586237873a40e", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -537,6 +537,7 @@ symbols! {\n         rustc_allow_const_fn_ptr,\n         rustc_args_required_const,\n         rustc_attrs,\n+        rustc_builtin_macro,\n         rustc_clean,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,\n@@ -545,7 +546,6 @@ symbols! {\n         rustc_deprecated,\n         rustc_diagnostic_macros,\n         rustc_dirty,\n-        rustc_doc_only_macro,\n         rustc_dummy,\n         rustc_dump_env_program_clauses,\n         rustc_dump_program_clauses,\n@@ -557,6 +557,7 @@ symbols! {\n         rustc_layout,\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n+        rustc_macro_transparency,\n         rustc_mir,\n         rustc_nonnull_optimization_guaranteed,\n         rustc_object_lifetime_default,\n@@ -579,7 +580,6 @@ symbols! {\n         rustc_synthetic,\n         rustc_test_marker,\n         rustc_then_this_would_need,\n-        rustc_transparent_macro,\n         rustc_variance,\n         rustdoc,\n         rust_eh_personality,"}, {"sha": "e5911de8396c13bbec4374ff52d9de19629931a7", "filename": "src/libterm/win.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -2,8 +2,6 @@\n \n // FIXME (#13400): this is only a tiny fraction of the Windows console api\n \n-extern crate libc;\n-\n use std::io;\n use std::io::prelude::*;\n \n@@ -20,19 +18,36 @@ pub struct WinConsole<T> {\n     background: color::Color,\n }\n \n+type SHORT = i16;\n type WORD = u16;\n type DWORD = u32;\n type BOOL = i32;\n type HANDLE = *mut u8;\n \n+#[allow(non_snake_case)]\n+#[repr(C)]\n+struct SMALL_RECT {\n+    Left: SHORT,\n+    Top: SHORT,\n+    Right: SHORT,\n+    Bottom: SHORT,\n+}\n+\n+#[allow(non_snake_case)]\n+#[repr(C)]\n+struct COORD {\n+    X: SHORT,\n+    Y: SHORT,\n+}\n+\n #[allow(non_snake_case)]\n #[repr(C)]\n struct CONSOLE_SCREEN_BUFFER_INFO {\n-    dwSize: [libc::c_short; 2],\n-    dwCursorPosition: [libc::c_short; 2],\n+    dwSize: COORD,\n+    dwCursorPosition: COORD,\n     wAttributes: WORD,\n-    srWindow: [libc::c_short; 4],\n-    dwMaximumWindowSize: [libc::c_short; 2],\n+    srWindow: SMALL_RECT,\n+    dwMaximumWindowSize: COORD,\n }\n \n #[allow(non_snake_case)]\n@@ -105,12 +120,17 @@ impl<T: Write + Send + 'static> WinConsole<T> {\n \n     /// Returns `None` whenever the terminal cannot be created for some reason.\n     pub fn new(out: T) -> io::Result<WinConsole<T>> {\n+        use std::mem::MaybeUninit;\n+\n         let fg;\n         let bg;\n         unsafe {\n-            #[allow(deprecated)]\n-            let mut buffer_info = ::std::mem::uninitialized();\n-            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD), &mut buffer_info) != 0 {\n+            let mut buffer_info = MaybeUninit::<CONSOLE_SCREEN_BUFFER_INFO>::uninit();\n+            if GetConsoleScreenBufferInfo(\n+                GetStdHandle(-11i32 as DWORD),\n+                buffer_info.as_mut_ptr()\n+            ) != 0 {\n+                let buffer_info = buffer_info.assume_init() ;\n                 fg = bits_to_color(buffer_info.wAttributes);\n                 bg = bits_to_color(buffer_info.wAttributes >> 4);\n             } else {"}, {"sha": "c5f0256c2c92f5b10ce791bbe912f45ad2b3a5d3", "filename": "src/test/ui/bind-by-move/bind-by-move-no-guards.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-no-guards.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-no-guards.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-no-guards.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -4,7 +4,7 @@ error[E0008]: cannot bind by-move into a pattern guard\n LL |         Some(z) if z.recv().unwrap() => { panic!() },\n    |              ^ moves value into pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "43b578e9f1eafff439d47ca4ab816522f34e271c", "filename": "src/test/ui/borrowck/borrowck-mutate-in-guard.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.nll.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -10,7 +10,7 @@ error[E0301]: cannot mutably borrow in a pattern guard\n LL |         Enum::A(_) if { let y = &mut x; *y = Enum::B(false); false } => 1,\n    |                                      ^ borrowed mutably in pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error[E0302]: cannot assign in a pattern guard\n   --> $DIR/borrowck-mutate-in-guard.rs:15:41"}, {"sha": "d39f535d8e2f76f7af502543df2f8ef1a8ff5520", "filename": "src/test/ui/borrowck/borrowck-mutate-in-guard.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -10,7 +10,7 @@ error[E0301]: cannot mutably borrow in a pattern guard\n LL |         Enum::A(_) if { let y = &mut x; *y = Enum::B(false); false } => 1,\n    |                                      ^ borrowed mutably in pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error[E0302]: cannot assign in a pattern guard\n   --> $DIR/borrowck-mutate-in-guard.rs:15:41"}, {"sha": "a61c9b0c9fef9995daa1542852cf39603ac42417", "filename": "src/test/ui/consts/const_let_refutable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -11,7 +11,7 @@ LL |     a + b\n    |     ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0381]: use of possibly uninitialized variable: `a`\n   --> $DIR/const_let_refutable.rs:4:5"}, {"sha": "a848b20ed98f5876d1761fdbfa1c1e2449f63756", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -11,7 +11,7 @@ LL |     a + b\n    |     ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n warning[E0381]: use of possibly uninitialized variable: `a`\n   --> $DIR/const_let_refutable.rs:4:5"}, {"sha": "6228b012dde38760096204cb8691d243fbd3dca0", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const fn error(_: fn()) {}\n    |                ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "ecfd30e7b443944958b84b25ae7cb31c72dda139", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     vec![1, 2, 3]\n    |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "9919c17a04208152e502f6a23b0c587214c41d50", "filename": "src/test/ui/consts/min_const_fn/cast_errors.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const fn unsize(x: &[u8; 3]) -> &[u8] { x }\n    |                                         ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/cast_errors.rs:5:23\n@@ -14,7 +14,7 @@ LL | const fn closure() -> fn() { || {} }\n    |                       ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/cast_errors.rs:8:5\n@@ -23,7 +23,7 @@ LL |     (|| {}) as fn();\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/cast_errors.rs:11:28\n@@ -32,7 +32,7 @@ LL | const fn reify(f: fn()) -> unsafe fn() { f }\n    |                            ^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/cast_errors.rs:13:21\n@@ -41,7 +41,7 @@ LL | const fn reify2() { main as unsafe fn(); }\n    |                     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 5 previous errors\n "}, {"sha": "82ed1d45226fa9d59a02c738a421d3d6352c7341", "filename": "src/test/ui/consts/min_const_fn/cmp_fn_pointers.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const fn cmp(x: fn(), y: fn()) -> bool {\n    |              ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "edf983fc56b1101c87403b3cfcaa799668642537", "filename": "src/test/ui/consts/min_const_fn/loop_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     loop {}\n    |     ^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "4b43a0d0a1a1b3c910bcbd9f7d150d49c73953d3", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -11,7 +11,7 @@ LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n    |                                    ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:44:28\n@@ -26,7 +26,7 @@ LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n    |                                          ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:51:27\n@@ -41,7 +41,7 @@ LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n    |                                      ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:58:39\n@@ -50,7 +50,7 @@ LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n    |                                       ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:76:16\n@@ -59,7 +59,7 @@ LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n    |                ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:78:18\n@@ -68,7 +68,7 @@ LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n    |                  ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:80:33\n@@ -77,7 +77,7 @@ LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n    |                                 ^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:82:35\n@@ -86,7 +86,7 @@ LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n    |                                   ^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int and `bool` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:84:35\n@@ -95,7 +95,7 @@ LL | const fn foo19_3(f: f32) -> f32 { -f }\n    |                                   ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:86:43\n@@ -104,7 +104,7 @@ LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n    |                                           ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n   --> $DIR/min_const_fn.rs:90:27\n@@ -113,7 +113,7 @@ LL | const fn foo25() -> u32 { BAR }\n    |                           ^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n   --> $DIR/min_const_fn.rs:91:36\n@@ -122,7 +122,7 @@ LL | const fn foo26() -> &'static u32 { &BAR }\n    |                                    ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:92:42\n@@ -131,7 +131,7 @@ LL | const fn foo30(x: *const u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:94:63\n@@ -140,7 +140,7 @@ LL | const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize }\n    |                                                               ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:96:42\n@@ -149,7 +149,7 @@ LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:98:63\n@@ -158,7 +158,7 @@ LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize }\n    |                                                               ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:100:38\n@@ -167,7 +167,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops are not allowed in const fn\n   --> $DIR/min_const_fn.rs:102:29\n@@ -176,7 +176,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    |                             ^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:105:44\n@@ -185,7 +185,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:107:44\n@@ -194,7 +194,7 @@ LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:109:14\n@@ -203,7 +203,7 @@ LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:114:6\n@@ -212,7 +212,7 @@ LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:119:6\n@@ -221,7 +221,7 @@ LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:124:6\n@@ -230,7 +230,7 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n   --> $DIR/min_const_fn.rs:130:24\n@@ -239,7 +239,7 @@ LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:132:34\n@@ -248,7 +248,7 @@ LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:134:22\n@@ -257,7 +257,7 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n   --> $DIR/min_const_fn.rs:135:23\n@@ -266,7 +266,7 @@ LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    |                       ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:136:23\n@@ -275,7 +275,7 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    |                       ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:137:32\n@@ -284,7 +284,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0515]: cannot return reference to temporary value\n   --> $DIR/min_const_fn.rs:137:63\n@@ -302,7 +302,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/min_const_fn.rs:148:21\n@@ -311,7 +311,7 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/min_const_fn.rs:150:27\n@@ -320,7 +320,7 @@ LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 37 previous errors\n "}, {"sha": "211902b687b1b23d5c7d66c68fb85fe44a527368", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -11,7 +11,7 @@ LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n    |                                    ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:44:28\n@@ -26,7 +26,7 @@ LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n    |                                          ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:51:27\n@@ -41,7 +41,7 @@ LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n    |                                      ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:58:39\n@@ -50,7 +50,7 @@ LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n    |                                       ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:76:16\n@@ -59,7 +59,7 @@ LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n    |                ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:78:18\n@@ -68,7 +68,7 @@ LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n    |                  ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:80:33\n@@ -77,7 +77,7 @@ LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n    |                                 ^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:82:35\n@@ -86,7 +86,7 @@ LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n    |                                   ^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int and `bool` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:84:35\n@@ -95,7 +95,7 @@ LL | const fn foo19_3(f: f32) -> f32 { -f }\n    |                                   ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn.rs:86:43\n@@ -104,7 +104,7 @@ LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n    |                                           ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n   --> $DIR/min_const_fn.rs:90:27\n@@ -113,7 +113,7 @@ LL | const fn foo25() -> u32 { BAR }\n    |                           ^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n   --> $DIR/min_const_fn.rs:91:36\n@@ -122,7 +122,7 @@ LL | const fn foo26() -> &'static u32 { &BAR }\n    |                                    ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:92:42\n@@ -131,7 +131,7 @@ LL | const fn foo30(x: *const u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:94:63\n@@ -140,7 +140,7 @@ LL | const fn foo30_with_unsafe(x: *const u32) -> usize { unsafe { x as usize }\n    |                                                               ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:96:42\n@@ -149,7 +149,7 @@ LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n    |                                          ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: casting pointers to ints is unstable in const fn\n   --> $DIR/min_const_fn.rs:98:63\n@@ -158,7 +158,7 @@ LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize }\n    |                                                               ^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:100:38\n@@ -167,7 +167,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops are not allowed in const fn\n   --> $DIR/min_const_fn.rs:102:29\n@@ -176,7 +176,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    |                             ^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:105:44\n@@ -185,7 +185,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:107:44\n@@ -194,7 +194,7 @@ LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:109:14\n@@ -203,7 +203,7 @@ LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:114:6\n@@ -212,7 +212,7 @@ LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:119:6\n@@ -221,7 +221,7 @@ LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:124:6\n@@ -230,7 +230,7 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n   --> $DIR/min_const_fn.rs:130:24\n@@ -239,7 +239,7 @@ LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:132:34\n@@ -248,7 +248,7 @@ LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:134:22\n@@ -257,7 +257,7 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n   --> $DIR/min_const_fn.rs:135:23\n@@ -266,7 +266,7 @@ LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    |                       ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:136:23\n@@ -275,7 +275,7 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    |                       ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:137:32\n@@ -284,7 +284,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n warning[E0515]: cannot return reference to temporary value\n   --> $DIR/min_const_fn.rs:137:63\n@@ -306,7 +306,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/min_const_fn.rs:148:21\n@@ -315,7 +315,7 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/min_const_fn.rs:150:27\n@@ -324,7 +324,7 @@ LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 36 previous errors\n "}, {"sha": "0ea950d678f8784d364d4593b5f42e7665973ca2", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     x.0.field;\n    |     ^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn_dyn.rs:12:66\n@@ -14,7 +14,7 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    |                                                                  ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/min_const_fn_dyn.rs:12:67"}, {"sha": "02ddb0395296ce41e0a7ab8445f35d3b377d11d5", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     x.0.field;\n    |     ^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn_dyn.rs:12:66\n@@ -14,7 +14,7 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    |                                                                  ^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n warning[E0716]: temporary value dropped while borrowed\n   --> $DIR/min_const_fn_dyn.rs:12:67"}, {"sha": "085ad1aad3a9500b97f1211cd929d6ede4426dc4", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_fn_ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     x.0.field;\n    |     ^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n   --> $DIR/min_const_fn_fn_ptr.rs:14:59\n@@ -14,7 +14,7 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasPtr { field }) }\n    |                                                           ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0af5bdca815f9974791ff845e31d4251504a6f51", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const fn bar() -> u32 { foo() }\n    |                         ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn`\n   --> $DIR/min_const_fn_libstd_stability.rs:22:26\n@@ -14,7 +14,7 @@ LL | const fn bar2() -> u32 { foo2() }\n    |                          ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_fn_libstd_stability.rs:26:26\n@@ -23,7 +23,7 @@ LL | const fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |                          ^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn`\n   --> $DIR/min_const_fn_libstd_stability.rs:34:32\n@@ -32,7 +32,7 @@ LL | const fn bar2_gated() -> u32 { foo2_gated() }\n    |                                ^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "bc6f8c596060fb8612c00fc62c3f1eaf902126b9", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const unsafe fn bar() -> u32 { unsafe { foo() } }\n    |                                         ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn`\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:22:42\n@@ -14,7 +14,7 @@ LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } }\n    |                                          ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: only int, `bool` and `char` operations are stable in const fn\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:26:33\n@@ -23,7 +23,7 @@ LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |                                 ^^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn`\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:34:48\n@@ -32,7 +32,7 @@ LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } }\n    |                                                ^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a14fd740c670a0572570d27903968150d4a98f3e", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL | const unsafe fn bar() -> u32 { foo() }\n    |                                ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn`\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:22:33\n@@ -14,7 +14,7 @@ LL | const unsafe fn bar2() -> u32 { foo2() }\n    |                                 ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn`\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:30:39\n@@ -23,7 +23,7 @@ LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() }\n    |                                       ^^^^^^^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7c121be0d552d338692a3d4b2ca6082eb19b1b05", "filename": "src/test/ui/consts/min_const_fn/mutable_borrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     let b = &mut a;\n    |         ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/mutable_borrow.rs:12:13\n@@ -14,7 +14,7 @@ LL |         let b = &mut a;\n    |             ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3f37a6c64505649719e96c63ca93db15db6ce107", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -17,7 +17,7 @@ LL |         match *self {\n    |               ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "d354cef66bc06cfbc2af8a4d14bcdab6379b0bfc", "filename": "src/test/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -6,15 +6,15 @@\n // not be aligned.\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n-//~^ ERROR #[derive] can't be used\n+//~^ ERROR `#[derive]` can't be used\n //~| hard error\n-//~^^^ ERROR #[derive] can't be used\n+//~^^^ ERROR `#[derive]` can't be used\n //~| hard error\n #[repr(packed)]\n pub struct Foo<T>(T, T, T);\n \n #[derive(PartialEq, Eq)]\n-//~^ ERROR #[derive] can't be used\n+//~^ ERROR `#[derive]` can't be used\n //~| hard error\n #[repr(packed)]\n pub struct Bar(u32, u32, u32);\n@@ -23,7 +23,7 @@ pub struct Bar(u32, u32, u32);\n struct Y(usize);\n \n #[derive(PartialEq)]\n-//~^ ERROR #[derive] can't be used\n+//~^ ERROR `#[derive]` can't be used\n //~| hard error\n #[repr(packed)]\n struct X(Y);"}, {"sha": "8093c58a67e4207fae3188ed8b2ab73a740e7165", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1,4 +1,4 @@\n-error: #[derive] can't be used on a #[repr(packed)] struct with type or const parameters (error E0133)\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:8:16\n    |\n LL | #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -12,7 +12,7 @@ LL | #![deny(safe_packed_borrows)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a #[repr(packed)] struct with type or const parameters (error E0133)\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:8:23\n    |\n LL | #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -21,7 +21,7 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a #[repr(packed)] struct that does not derive Copy (error E0133)\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:16:10\n    |\n LL | #[derive(PartialEq, Eq)]\n@@ -30,7 +30,7 @@ LL | #[derive(PartialEq, Eq)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a #[repr(packed)] struct that does not derive Copy (error E0133)\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:25:10\n    |\n LL | #[derive(PartialEq)]"}, {"sha": "6b45439c4b5877ceadbc7c9cdb715da89ad50241", "filename": "src/test/ui/error-codes/E0008.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Ferror-codes%2FE0008.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Ferror-codes%2FE0008.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0008.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -4,7 +4,7 @@ error[E0008]: cannot bind by-move into a pattern guard\n LL |         Some(s) if s.len() == 0 => {},\n    |              ^ moves value into pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "4f12fd3850e3395a5f45c80c28349b8b56795000", "filename": "src/test/ui/error-codes/E0301.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Ferror-codes%2FE0301.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Ferror-codes%2FE0301.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0301.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -4,7 +4,7 @@ error[E0301]: cannot mutably borrow in a pattern guard\n LL |         option if option.take().is_none() => {},\n    |                   ^^^^^^ borrowed mutably in pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error[E0596]: cannot borrow `option` as mutable, as it is immutable for the pattern guard\n   --> $DIR/E0301.rs:4:19"}, {"sha": "37de27ee8005da3a26f9b59cbb3ddeec4e338f7d", "filename": "src/test/ui/hygiene/auxiliary/transparent-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1,6 +1,6 @@\n #![feature(decl_macro, rustc_attrs)]\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n pub macro dollar_crate() {\n     let s = $crate::S;\n }"}, {"sha": "8826293542c9736e0b5944885ee56a2eb58b623a", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -11,7 +11,7 @@ macro genmod($FromOutside: ident, $Outer: ident) {\n     }\n }\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro genmod_transparent() {\n     type A = FromOutside;\n     struct Outer;"}, {"sha": "a0a3d411d28b26b55907281b18e93f261fbb76d6", "filename": "src/test/ui/hygiene/rustc-macro-transparency.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -0,0 +1,31 @@\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro transparent() {\n+    struct Transparent;\n+    let transparent = 0;\n+}\n+#[rustc_macro_transparency = \"semitransparent\"]\n+macro semitransparent() {\n+    struct SemiTransparent;\n+    let semitransparent = 0;\n+}\n+#[rustc_macro_transparency = \"opaque\"]\n+macro opaque() {\n+    struct Opaque;\n+    let opaque = 0;\n+}\n+\n+fn main() {\n+    transparent!();\n+    semitransparent!();\n+    opaque!();\n+\n+    Transparent; // OK\n+    SemiTransparent; // OK\n+    Opaque; //~ ERROR cannot find value `Opaque` in this scope\n+\n+    transparent; // OK\n+    semitransparent; //~ ERROR cannot find value `semitransparent` in this scope\n+    opaque; //~ ERROR cannot find value `opaque` in this scope\n+}"}, {"sha": "2a9df221e2c87e115190dd23b25c265ba1f615a7", "filename": "src/test/ui/hygiene/rustc-macro-transparency.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find value `Opaque` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:26:5\n+   |\n+LL |     Opaque;\n+   |     ^^^^^^ help: a local variable with a similar name exists: `opaque`\n+\n+error[E0425]: cannot find value `semitransparent` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:29:5\n+   |\n+LL |     semitransparent;\n+   |     ^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `opaque` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:30:5\n+   |\n+LL |     opaque;\n+   |     ^^^^^^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "69dfc524989a44c98c50a5f3f33ecb18a1262dd0", "filename": "src/test/ui/hygiene/transparent-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,12 +5,12 @@\n \n extern crate transparent_basic;\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro binding() {\n     let x = 10;\n }\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro label() {\n     break 'label\n }"}, {"sha": "c1523e911fd2bdee35b1e8e29f9eacdb18329590", "filename": "src/test/ui/issues/issue-37550.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     let x = || t;\n    |         ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "a8818507d75d21cf07737c97410b5cdb7e6fd0ca", "filename": "src/test/ui/macros/restricted-shadowing-modern.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -80,17 +80,17 @@\n struct Right;\n // struct Wrong; // not defined\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro include() {\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_outer() {\n         macro m() { Wrong }\n     }\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_inner() {\n         macro m() { Right }\n     }\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_invoc() {\n         m!()\n     }\n@@ -100,7 +100,7 @@ macro include() {\n     fn check1() {\n         macro m() {}\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_gen_inner_invoc() {\n                 gen_inner!();\n                 m!(); //~ ERROR `m` is ambiguous\n@@ -112,7 +112,7 @@ macro include() {\n     fn check5() {\n         macro m() { Wrong }\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_invoc() {\n                 macro m() { Right }\n                 m!(); // OK\n@@ -124,7 +124,7 @@ macro include() {\n     fn check9() {\n         macro m() { Wrong }\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_gen_invoc() {\n                 macro m() { Right }\n                 gen_invoc!(); // OK\n@@ -145,7 +145,7 @@ macro include() {\n         macro m() {}\n         {\n             gen_inner!();\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n             gen_invoc!();\n         }\n@@ -186,7 +186,7 @@ macro include() {\n     fn check52() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_gen_inner_invoc() {\n                 gen_inner!();\n                 m!(); //~ ERROR `m` is ambiguous\n@@ -198,7 +198,7 @@ macro include() {\n     fn check56() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_invoc() {\n                 macro m() { Right }\n                 m!(); // OK\n@@ -218,7 +218,7 @@ macro include() {\n     fn check60() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_gen_invoc() {\n                 macro m() { Right }\n                 gen_invoc!(); // OK\n@@ -231,7 +231,7 @@ macro include() {\n         gen_outer!();\n         {\n             gen_inner!();\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n             gen_invoc!();\n         }"}, {"sha": "9f56eccb7a61c1f26d7ab059cf71f01796a1c781", "filename": "src/test/ui/proc-macro/reserved-macro-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -8,18 +8,18 @@ use proc_macro::*;\n \n #[proc_macro_attribute]\n pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg` is reserved in macro namespace\n+    //~^ ERROR name `cfg` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg_attr` is reserved in macro namespace\n+    //~^ ERROR name `cfg_attr` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `derive` is reserved in macro namespace\n+    //~^ ERROR name `derive` is reserved in attribute namespace\n     input\n }"}, {"sha": "f871e43ce51df80b25eca0c6dfdd55bb54dfc10d", "filename": "src/test/ui/proc-macro/reserved-macro-names.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -1,16 +1,16 @@\n-error: name `cfg` is reserved in macro namespace\n+error: name `cfg` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:10:8\n    |\n LL | pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^\n \n-error: name `cfg_attr` is reserved in macro namespace\n+error: name `cfg_attr` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:16:8\n    |\n LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^^^^^^\n \n-error: name `derive` is reserved in macro namespace\n+error: name `derive` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:22:8\n    |\n LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {"}, {"sha": "c2f6edee05fa6bf40073bad3cf199b9f856bc451", "filename": "src/test/ui/rfc-0107-bind-by-move-pattern-guards/feature-gate.no_gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Frfc-0107-bind-by-move-pattern-guards%2Ffeature-gate.no_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Frfc-0107-bind-by-move-pattern-guards%2Ffeature-gate.no_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-0107-bind-by-move-pattern-guards%2Ffeature-gate.no_gate.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -4,7 +4,7 @@ error[E0008]: cannot bind by-move into a pattern guard\n LL |         A { a: v } if *v == 42 => v,\n    |                ^ moves value into pattern guard\n    |\n-   = help: add #![feature(bind_by_move_pattern_guards)] to the crate attributes to enable\n+   = help: add `#![feature(bind_by_move_pattern_guards)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "e99155ee1016256530804effd095d2c76c87b155", "filename": "src/test/ui/unsafe/ranged_ints2_const.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -5,7 +5,7 @@ LL |     let y = &mut x.0;\n    |         ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/ranged_ints2_const.rs:18:9\n@@ -14,7 +14,7 @@ LL |     let y = unsafe { &mut x.0 };\n    |         ^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n   --> $DIR/ranged_ints2_const.rs:11:13"}, {"sha": "58c6aa12dc48db2580e1dbdb4b45d778f8e9d920", "filename": "src/tools/tidy/src/libcoretest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bd5f236d9bea38b8c9048f379fec179b09984c/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs?ref=b0bd5f236d9bea38b8c9048f379fec179b09984c", "patch": "@@ -13,7 +13,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n         &mut |entry, contents| {\n             let subpath = entry.path();\n             if let Some(\"rs\") = subpath.extension().and_then(|e| e.to_str()) {\n-                if contents.contains(\"#[test]\") {\n+                let contents = contents.trim();\n+                if !contents.starts_with(\"//\") && contents.contains(\"#[test]\") {\n                     tidy_error!(\n                         bad,\n                         \"{} contains #[test]; libcore tests must be placed inside \\"}]}