{"sha": "40f91341595508833d39eb6d97e4ec2ac7f685cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZjkxMzQxNTk1NTA4ODMzZDM5ZWI2ZDk3ZTRlYzJhYzdmNjg1Y2I=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-09T12:54:02Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-09T12:54:02Z"}, "message": "Make macro scope a real name scope\nFix some details about module scoping", "tree": {"sha": "3022252410b228efb6501e9e8ff6268c910c87cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3022252410b228efb6501e9e8ff6268c910c87cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40f91341595508833d39eb6d97e4ec2ac7f685cb", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl12S2oACgkQztOS3gxI\nPQALyQ/9HTXmq927w8yTn/saMTMQZEZFs5c6xJKKSmxtpyZhVDyqUAfLnrlSoXuw\nhkD/9i9nwCL2PClTAUf75qMLNgAZ2B4WRpKMkUp30QZFqaayUtPrx9FgD/RMtuQa\nW3X6lkb49bIgs0YSvAU/dSzvLGuCcqGYI8TkgeXshN0XrATYt12mEd8BVTeCBjnD\n7tkoVOyevAcEQoRR8ic5FkdUbCULmpRoXtCGJ+iXRgFIYIf4kq5C6L4Kz4hELXMk\nyT3DuY7BfmLw8qzjkCicTEHywkKY9Tu4ldHKMip/kRhH5zUZ7o69nlMWpG7FteI7\n9TwXoM2hyPD6DUDg8ZUpGVc9aUWISkY2WHgJ4V6z+pQILYAModhW+5W6siphMHOI\npW9k33ld3jPbDqgAMAw/76HLC7RHfGb4wCYwvAEsT1iWIsdtwvts3vd+Kb/XZAEt\n7oK7PMvMPbczaqn2yQSRTVGkaruZ9dcR+9Sd41L1JcVHOHCoSFeM3Aymdnx0Tysa\nF0NnYdjFxo4yA68CpJ5IhbQx1LbTLnPPVPUY/woi3I4KmhhrdwofYeE4eS2b3xWr\nUK6KgEbm9if6bnWN+itXgPdsr859gMMVbFPIcIG6uTHv4yq2EKJsxkolft1MGjqq\n6hhSQL4Gte80CP8Z88Id3ODFts/ObUx9g5HLx4AweOWs7hmP/wI=\n=FFLz\n-----END PGP SIGNATURE-----", "payload": "tree 3022252410b228efb6501e9e8ff6268c910c87cb\nparent 734a43e95afc97773c234956a95b78caed88f2a3\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1568033642 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1568033642 +0800\n\nMake macro scope a real name scope\nFix some details about module scoping\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40f91341595508833d39eb6d97e4ec2ac7f685cb", "html_url": "https://github.com/rust-lang/rust/commit/40f91341595508833d39eb6d97e4ec2ac7f685cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40f91341595508833d39eb6d97e4ec2ac7f685cb/comments", "author": null, "committer": null, "parents": [{"sha": "734a43e95afc97773c234956a95b78caed88f2a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/734a43e95afc97773c234956a95b78caed88f2a3", "html_url": "https://github.com/rust-lang/rust/commit/734a43e95afc97773c234956a95b78caed88f2a3"}], "stats": {"total": 635, "additions": 399, "deletions": 236}, "files": [{"sha": "7488d75a53a99f20ace2abbc3b09bd6d72408e1c", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 65, "deletions": 93, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -67,7 +67,6 @@ use test_utils::tested_by;\n use crate::{\n     db::{AstDatabase, DefDatabase},\n     diagnostics::DiagnosticSink,\n-    either::Either,\n     ids::MacroDefId,\n     nameres::diagnostics::DefDiagnostic,\n     AstId, BuiltinType, Crate, HirFileId, MacroDef, Module, ModuleDef, Name, Path, PathKind, Trait,\n@@ -105,8 +104,6 @@ pub struct CrateDefMap {\n     /// However, do we want to put it as a global variable?\n     poison_macros: FxHashSet<MacroDefId>,\n \n-    exported_macros: FxHashMap<Name, MacroDefId>,\n-\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -138,12 +135,6 @@ pub(crate) struct ModuleData {\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n-    /// Macros in current module scoped\n-    ///\n-    /// This scope works exactly the same way that item scoping does.\n-    /// Macro invocation with quantified path will search in it.\n-    /// See details below.\n-    macros: FxHashMap<Name, MacroDef>,\n     /// Macros visable in current module in legacy textual scope\n     ///\n     /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n@@ -152,6 +143,10 @@ pub struct ModuleScope {\n     /// and only normal scoped `macros` will be searched in.\n     ///\n     /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n     legacy_macros: FxHashMap<Name, MacroDef>,\n }\n \n@@ -164,35 +159,43 @@ static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n         .collect()\n });\n \n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n impl ModuleScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n         //FIXME: shadowing\n         self.items.iter().chain(BUILTIN_SCOPE.iter())\n     }\n+\n+    /// Iterate over all module scoped macros\n+    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n+        self.items\n+            .iter()\n+            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visable at the end of the module\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n     pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n     }\n+\n     pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n         self.items.values().filter_map(|r| match r.def.take_types() {\n             Some(ModuleDef::Trait(t)) => Some(t),\n             _ => None,\n         })\n     }\n-    /// It resolves in module scope. Textual scoped macros are ignored here.\n-    fn get_item_or_macro(&self, name: &Name) -> Option<ItemOrMacro> {\n-        match (self.get(name), self.macros.get(name)) {\n-            (Some(item), _) if !item.def.is_none() => Some(Either::A(item.def)),\n-            (_, Some(macro_)) => Some(Either::B(*macro_)),\n-            _ => None,\n-        }\n-    }\n+\n     fn get_legacy_macro(&self, name: &Name) -> Option<MacroDef> {\n         self.legacy_macros.get(name).copied()\n     }\n }\n \n-type ItemOrMacro = Either<PerNs<ModuleDef>, MacroDef>;\n-\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n@@ -201,20 +204,26 @@ pub struct Resolution {\n     pub import: Option<ImportId>,\n }\n \n+impl Resolution {\n+    pub(crate) fn from_macro(macro_: MacroDef) -> Self {\n+        Resolution { def: PerNs::macros(macro_), import: None }\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n struct ResolvePathResult {\n-    resolved_def: ItemOrMacro,\n+    resolved_def: PerNs<ModuleDef>,\n     segment_index: Option<usize>,\n     reached_fixedpoint: ReachedFixedPoint,\n }\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(Either::A(PerNs::none()), reached_fixedpoint, None)\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n     }\n \n     fn with(\n-        resolved_def: ItemOrMacro,\n+        resolved_def: PerNs<ModuleDef>,\n         reached_fixedpoint: ReachedFixedPoint,\n         segment_index: Option<usize>,\n     ) -> ResolvePathResult {\n@@ -234,21 +243,6 @@ enum ReachedFixedPoint {\n     No,\n }\n \n-/// helper function for select item or macro to use\n-fn or(left: ItemOrMacro, right: ItemOrMacro) -> ItemOrMacro {\n-    match (left, right) {\n-        (Either::A(s), Either::A(o)) => Either::A(s.or(o)),\n-        (Either::B(s), _) => Either::B(s),\n-        (Either::A(s), Either::B(o)) => {\n-            if !s.is_none() {\n-                Either::A(s)\n-            } else {\n-                Either::B(o)\n-            }\n-        }\n-    }\n-}\n-\n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(\n         // Note that this doesn't have `+ AstDatabase`!\n@@ -269,7 +263,6 @@ impl CrateDefMap {\n                 root,\n                 modules,\n                 poison_macros: FxHashSet::default(),\n-                exported_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -327,16 +320,6 @@ impl CrateDefMap {\n         original_module: CrateModuleId,\n         path: &Path,\n     ) -> (PerNs<ModuleDef>, Option<usize>) {\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def.a().unwrap_or_else(PerNs::none), res.segment_index)\n-    }\n-\n-    pub(crate) fn resolve_path_with_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> (ItemOrMacro, Option<usize>) {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n@@ -351,13 +334,13 @@ impl CrateDefMap {\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: ItemOrMacro = match path.kind {\n+        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n             PathKind::Crate => {\n-                Either::A(PerNs::types(Module { krate: self.krate, module_id: self.root }.into()))\n+                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n             }\n-            PathKind::Self_ => Either::A(PerNs::types(\n-                Module { krate: self.krate, module_id: original_module }.into(),\n-            )),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -379,11 +362,11 @@ impl CrateDefMap {\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module_with_macro(db, original_module, &segment.name)\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    Either::A(PerNs::types(Module { krate: self.krate, module_id: p }.into()))\n+                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -397,15 +380,15 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment.name) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    Either::A(PerNs::types(*def))\n+                    PerNs::types(*def)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().a().and_then(|m| m.as_ref().take_types()) {\n+            let curr = match curr_per_ns.as_ref().take_types() {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -425,17 +408,17 @@ impl CrateDefMap {\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) =\n-                            defp_map.resolve_path_with_macro(db, module.module_id, &path);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n                         );\n                     }\n \n-                    match self[module.module_id].scope.get_item_or_macro(&segment.name) {\n-                        Some(res) => res,\n+                    // Since it is a quantified path here, it should not contains legacy macros\n+                    match self[module.module_id].scope.get(&segment.name) {\n+                        Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n                             return ResolvePathResult::empty(ReachedFixedPoint::No);\n@@ -446,10 +429,10 @@ impl CrateDefMap {\n                     // enum variant\n                     tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n-                        Some(variant) => Either::A(PerNs::both(variant.into(), variant.into())),\n+                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n                         None => {\n                             return ResolvePathResult::with(\n-                                Either::A(PerNs::types((*e).into())),\n+                                PerNs::types((*e).into()),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                             );\n@@ -466,7 +449,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        Either::A(PerNs::types(*s)),\n+                        PerNs::types(*s),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                     );\n@@ -476,14 +459,12 @@ impl CrateDefMap {\n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> ItemOrMacro {\n-        let from_crate_root = self[self.root]\n-            .scope\n-            .get_item_or_macro(name)\n-            .unwrap_or_else(|| Either::A(PerNs::none()));\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        let from_crate_root =\n+            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n-        or(from_crate_root, Either::A(from_extern_prelude))\n+        from_crate_root.or(from_extern_prelude)\n     }\n \n     pub(crate) fn resolve_name_in_module(\n@@ -492,47 +473,38 @@ impl CrateDefMap {\n         module: CrateModuleId,\n         name: &Name,\n     ) -> PerNs<ModuleDef> {\n-        self.resolve_name_in_module_with_macro(db, module, name).a().unwrap_or_else(PerNs::none)\n-    }\n-\n-    fn resolve_name_in_module_with_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        module: CrateModuleId,\n-        name: &Name,\n-    ) -> ItemOrMacro {\n         // Resolve in:\n-        //  - legacy scope\n+        //  - legacy scope of macro\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_legacy_macro = self[module]\n-            .scope\n-            .get_legacy_macro(name)\n-            .map_or_else(|| Either::A(PerNs::none()), Either::B);\n-        let from_scope =\n-            self[module].scope.get_item_or_macro(name).unwrap_or_else(|| Either::A(PerNs::none()));\n+        let from_legacy_macro =\n+            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n \n-        or(from_legacy_macro, or(from_scope, or(Either::A(from_extern_prelude), from_prelude)))\n+        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n     }\n \n     fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n         self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> ItemOrMacro {\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs<ModuleDef> {\n         if let Some(prelude) = self.prelude {\n-            let resolution = if prelude.krate == self.krate {\n-                self[prelude.module_id].scope.get_item_or_macro(name)\n+            let keep;\n+            let def_map = if prelude.krate == self.krate {\n+                self\n             } else {\n-                db.crate_def_map(prelude.krate)[prelude.module_id].scope.get_item_or_macro(name)\n+                // Extend lifetime\n+                keep = db.crate_def_map(prelude.krate);\n+                &keep\n             };\n-            resolution.unwrap_or_else(|| Either::A(PerNs::none()))\n+            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n         } else {\n-            Either::A(PerNs::none())\n+            PerNs::none()\n         }\n     }\n }"}, {"sha": "03fbbd33f8bb997361aea50acf26024bfa3d3c25", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 95, "deletions": 83, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -5,14 +5,13 @@ use test_utils::tested_by;\n \n use crate::{\n     db::DefDatabase,\n-    either::Either,\n     ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n     name::MACRO_RULES,\n     nameres::{\n         diagnostics::DefDiagnostic,\n         mod_resolution::{resolve_submodule, ParentModule},\n-        raw, CrateDefMap, CrateModuleId, ItemOrMacro, ModuleData, ModuleDef, PerNs,\n-        ReachedFixedPoint, Resolution, ResolveMode,\n+        raw, Crate, CrateDefMap, CrateModuleId, ModuleData, ModuleDef, PerNs, ReachedFixedPoint,\n+        Resolution, ResolveMode,\n     },\n     AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n     Struct, Trait, TypeAlias, Union,\n@@ -123,30 +122,51 @@ where\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n         for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(module_id, Either::A(PerNs::none()), import, &import_data)\n+            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n         }\n     }\n \n+    /// Define a macro with `macro_rules`.\n+    ///\n+    /// It will define the macro in legacy textual scope, and if it has `#[macro_export]`,\n+    /// then it is also defined in the root module scope.\n+    /// You can `use` or invoke it by `crate::macro_name` anywhere, before or after the definition.\n+    ///\n+    /// It is surprising that the macro will never be in the current module scope.\n+    /// These code fails with \"unresolved import/macro\",\n+    /// ```rust,compile_fail\n+    /// mod m { macro_rules! foo { () => {} } }\n+    /// use m::foo as bar;\n+    /// ```\n+    ///\n+    /// ```rust,compile_fail\n+    /// macro_rules! foo { () => {} }\n+    /// self::foo!();\n+    /// crate::foo!();\n+    /// ```\n+    ///\n+    /// Well, this code compiles, bacause the plain path `foo` in `use` is searched\n+    /// in the legacy textual scope only.\n+    /// ```rust\n+    /// macro_rules! foo { () => {} }\n+    /// use foo as bar;\n+    /// ```\n     fn define_macro(\n         &mut self,\n         module_id: CrateModuleId,\n         name: Name,\n-        macro_id: MacroDefId,\n+        macro_: MacroDef,\n         export: bool,\n     ) {\n-        let def = Either::B(MacroDef { id: macro_id });\n+        // Textual scoping\n+        self.define_legacy_macro(module_id, name.clone(), macro_);\n \n+        // Module scoping\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(self.def_map.root, None, &[(name.clone(), def.clone())]);\n-\n-            // Exported macros are collected in crate level ready for\n-            // glob import with `#[macro_use]`.\n-            self.def_map.exported_macros.insert(name.clone(), macro_id);\n+            self.update(self.def_map.root, None, &[(name.clone(), Resolution::from_macro(macro_))]);\n         }\n-        self.update(module_id, None, &[(name.clone(), def)]);\n-        self.define_legacy_macro(module_id, name.clone(), macro_id);\n     }\n \n     /// Define a legacy textual scoped macro in module\n@@ -156,14 +176,12 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_id: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDef) {\n         // Always shadowing\n-        self.def_map.modules[module_id].scope.legacy_macros.insert(name, MacroDef { id: macro_id });\n+        self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n-    ///\n-    /// They are non-scoped, and will only be inserted into mutable `global_macro_scope`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n         current_module_id: CrateModuleId,\n@@ -184,14 +202,20 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m);\n+            self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n \n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, module: Module) {\n-        let item_map = self.db.crate_def_map(module.krate);\n-        for (name, &macro_id) in &item_map.exported_macros {\n-            self.define_legacy_macro(current_module_id, name.clone(), macro_id);\n+    /// Import all exported macros from another crate\n+    ///\n+    /// Exported macros are just all macros in the root module scope.\n+    /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n+    /// created by `use` in the root module, ignoring the visibility of `use`.\n+    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: Crate) {\n+        let def_map = self.db.crate_def_map(krate);\n+        for (name, def) in def_map[def_map.root].scope.macros() {\n+            // `macro_use` only bring things into legacy scope.\n+            self.define_legacy_macro(current_module_id, name.clone(), def);\n         }\n     }\n \n@@ -219,7 +243,7 @@ where\n         &self,\n         module_id: CrateModuleId,\n         import: &raw::ImportData,\n-    ) -> (ItemOrMacro, ReachedFixedPoint) {\n+    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -228,7 +252,7 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (Either::A(res), ReachedFixedPoint::Yes)\n+            (res, ReachedFixedPoint::Yes)\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n@@ -244,13 +268,13 @@ where\n     fn record_resolved_import(\n         &mut self,\n         module_id: CrateModuleId,\n-        def: ItemOrMacro,\n+        def: PerNs<ModuleDef>,\n         import_id: raw::ImportId,\n         import: &raw::ImportData,\n     ) {\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n-            match def.a().and_then(|item| item.take_types()) {\n+            match def.take_types() {\n                 Some(ModuleDef::Module(m)) => {\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n@@ -260,30 +284,29 @@ where\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.crate_def_map(m.krate);\n                         let scope = &item_map[m.module_id].scope;\n+\n+                        // Module scoped macros is included\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::A(res.clone())));\n-                        let macros =\n-                            scope.macros.iter().map(|(name, res)| (name.clone(), Either::B(*res)));\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n \n-                        let all = items.chain(macros).collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &all);\n+                        self.update(module_id, Some(import_id), &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n                         let scope = &self.def_map[m.module_id].scope;\n+\n+                        // Module scoped macros is included\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::A(res.clone())));\n-                        let macros =\n-                            scope.macros.iter().map(|(name, res)| (name.clone(), Either::B(*res)));\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n \n-                        let all = items.chain(macros).collect::<Vec<_>>();\n-\n-                        self.update(module_id, Some(import_id), &all);\n+                        self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n                             .entry(m.module_id)\n@@ -303,7 +326,7 @@ where\n                                 import: Some(import_id),\n                             };\n                             let name = variant.name(self.db)?;\n-                            Some((name, Either::A(res)))\n+                            Some((name, res))\n                         })\n                         .collect::<Vec<_>>();\n                     self.update(module_id, Some(import_id), &resolutions);\n@@ -323,18 +346,12 @@ where\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                     if import.is_extern_crate && module_id == self.def_map.root {\n-                        if let Some(def) = def.a().and_then(|item| item.take_types()) {\n+                        if let Some(def) = def.take_types() {\n                             self.def_map.extern_prelude.insert(name.clone(), def);\n                         }\n                     }\n \n-                    let resolution = match def {\n-                        Either::A(item) => {\n-                            Either::A(Resolution { def: item, import: Some(import_id) })\n-                        }\n-                        Either::B(macro_) => Either::B(macro_),\n-                    };\n-\n+                    let resolution = Resolution { def, import: Some(import_id) };\n                     self.update(module_id, Some(import_id), &[(name, resolution)]);\n                 }\n                 None => tested_by!(bogus_paths),\n@@ -346,7 +363,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         import: Option<raw::ImportId>,\n-        resolutions: &[(Name, Either<Resolution, MacroDef>)],\n+        resolutions: &[(Name, Resolution)],\n     ) {\n         self.update_recursive(module_id, import, resolutions, 0)\n     }\n@@ -355,7 +372,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         import: Option<raw::ImportId>,\n-        resolutions: &[(Name, Either<Resolution, MacroDef>)],\n+        resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -365,35 +382,30 @@ where\n         let module_items = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            match res {\n-                // item\n-                Either::A(res) => {\n-                    let existing = module_items.items.entry(name.clone()).or_default();\n-\n-                    if existing.def.types.is_none() && res.def.types.is_some() {\n-                        existing.def.types = res.def.types;\n-                        existing.import = import.or(res.import);\n-                        changed = true;\n-                    }\n-                    if existing.def.values.is_none() && res.def.values.is_some() {\n-                        existing.def.values = res.def.values;\n-                        existing.import = import.or(res.import);\n-                        changed = true;\n-                    }\n+            let existing = module_items.items.entry(name.clone()).or_default();\n \n-                    if existing.def.is_none()\n-                        && res.def.is_none()\n-                        && existing.import.is_none()\n-                        && res.import.is_some()\n-                    {\n-                        existing.import = res.import;\n-                    }\n-                }\n-                // macro\n-                Either::B(res) => {\n-                    // Always shadowing\n-                    module_items.macros.insert(name.clone(), *res);\n-                }\n+            if existing.def.types.is_none() && res.def.types.is_some() {\n+                existing.def.types = res.def.types;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.values.is_none() && res.def.values.is_some() {\n+                existing.def.values = res.def.values;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.macros.is_none() && res.def.macros.is_some() {\n+                existing.def.macros = res.def.macros;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+\n+            if existing.def.is_none()\n+                && res.def.is_none()\n+                && existing.import.is_none()\n+                && res.import.is_some()\n+            {\n+                existing.import = res.import;\n             }\n         }\n \n@@ -425,7 +437,7 @@ where\n                 path,\n             );\n \n-            if let Some(def) = resolved_res.resolved_def.b() {\n+            if let Some(def) = resolved_res.resolved_def.get_macros() {\n                 let call_id = MacroCallLoc { def: def.id, ast_id: *ast_id }.id(self.db);\n                 resolved.push((*module_id, call_id, def.id));\n                 res = ReachedFixedPoint::No;\n@@ -528,7 +540,7 @@ where\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module);\n+                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }\n \n@@ -636,7 +648,7 @@ where\n             ),\n             import: None,\n         };\n-        self.def_collector.update(self.module_id, None, &[(name, Either::A(resolution))]);\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n@@ -667,15 +679,16 @@ where\n             raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, Either::A(resolution))])\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n                 let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n-                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export)\n+                let macro_ = MacroDef { id: macro_id };\n+                self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n             }\n             return;\n         }\n@@ -706,7 +719,7 @@ where\n     fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n         let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n         for (name, macro_) in macros {\n-            self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_.id);\n+            self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }\n     }\n }\n@@ -758,7 +771,6 @@ mod tests {\n                 root,\n                 modules,\n                 poison_macros: FxHashSet::default(),\n-                exported_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "6a50e05c199042672fd0a7e3ebf5cef3476d58b9", "filename": "crates/ra_hir/src/nameres/per_ns.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -1,78 +1,93 @@\n+use crate::MacroDef;\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum Namespace {\n     Types,\n     Values,\n+    Macro,\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct PerNs<T> {\n     pub types: Option<T>,\n     pub values: Option<T>,\n+    /// Since macros has different type, many methods simply ignore it.\n+    /// We can only use special method like `get_macros` to access it.\n+    pub macros: Option<MacroDef>,\n }\n \n impl<T> Default for PerNs<T> {\n     fn default() -> Self {\n-        PerNs { types: None, values: None }\n+        PerNs { types: None, values: None, macros: None }\n     }\n }\n \n impl<T> PerNs<T> {\n     pub fn none() -> PerNs<T> {\n-        PerNs { types: None, values: None }\n+        PerNs { types: None, values: None, macros: None }\n     }\n \n     pub fn values(t: T) -> PerNs<T> {\n-        PerNs { types: None, values: Some(t) }\n+        PerNs { types: None, values: Some(t), macros: None }\n     }\n \n     pub fn types(t: T) -> PerNs<T> {\n-        PerNs { types: Some(t), values: None }\n+        PerNs { types: Some(t), values: None, macros: None }\n     }\n \n     pub fn both(types: T, values: T) -> PerNs<T> {\n-        PerNs { types: Some(types), values: Some(values) }\n+        PerNs { types: Some(types), values: Some(values), macros: None }\n     }\n \n-    pub fn is_none(&self) -> bool {\n-        self.types.is_none() && self.values.is_none()\n+    pub fn macros(macro_: MacroDef) -> PerNs<T> {\n+        PerNs { types: None, values: None, macros: Some(macro_) }\n     }\n \n-    pub fn is_both(&self) -> bool {\n-        self.types.is_some() && self.values.is_some()\n+    pub fn is_none(&self) -> bool {\n+        self.types.is_none() && self.values.is_none() && self.macros.is_none()\n     }\n \n-    pub fn take(self, namespace: Namespace) -> Option<T> {\n-        match namespace {\n-            Namespace::Types => self.types,\n-            Namespace::Values => self.values,\n-        }\n+    pub fn is_all(&self) -> bool {\n+        self.types.is_some() && self.values.is_some() && self.macros.is_some()\n     }\n \n     pub fn take_types(self) -> Option<T> {\n-        self.take(Namespace::Types)\n+        self.types\n     }\n \n     pub fn take_values(self) -> Option<T> {\n-        self.take(Namespace::Values)\n+        self.values\n     }\n \n-    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n-        self.as_ref().take(namespace)\n+    pub fn get_macros(&self) -> Option<MacroDef> {\n+        self.macros\n+    }\n+\n+    pub fn only_macros(&self) -> PerNs<T> {\n+        PerNs { types: None, values: None, macros: self.macros }\n     }\n \n     pub fn as_ref(&self) -> PerNs<&T> {\n-        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n+        PerNs { types: self.types.as_ref(), values: self.values.as_ref(), macros: self.macros }\n     }\n \n     pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n-        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n+        PerNs {\n+            types: self.types.or(other.types),\n+            values: self.values.or(other.values),\n+            macros: self.macros.or(other.macros),\n+        }\n     }\n \n     pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n-        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n+        PerNs {\n+            types: self.types.and_then(&f),\n+            values: self.values.and_then(&f),\n+            macros: self.macros,\n+        }\n     }\n \n     pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n-        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n+        PerNs { types: self.types.map(&f), values: self.values.map(&f), macros: self.macros }\n     }\n }"}, {"sha": "bc4b47b704cd0fad5396f75eb80eb4c2b52c1fd7", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -12,8 +12,7 @@ use test_utils::covers;\n \n use crate::{\n     mock::{CrateGraphFixture, MockDatabase},\n-    nameres::Resolution,\n-    Crate, Either,\n+    Crate,\n };\n \n use super::*;\n@@ -37,35 +36,38 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let items = map.modules[module].scope.items.iter().map(|(name, it)| (name, Either::A(it)));\n-        let macros = map.modules[module].scope.macros.iter().map(|(name, m)| (name, Either::B(m)));\n-        let mut entries = items.chain(macros).collect::<Vec<_>>();\n-\n+        let mut entries = map.modules[module]\n+            .scope\n+            .items\n+            .iter()\n+            .map(|(name, res)| (name, res.def))\n+            .collect::<Vec<_>>();\n         entries.sort_by_key(|(name, _)| *name);\n+\n         for (name, res) in entries {\n-            match res {\n-                Either::A(it) => {\n-                    *buf += &format!(\"{}: {}\\n\", name, dump_resolution(it));\n-                }\n-                Either::B(_) => {\n-                    *buf += &format!(\"{}: m\\n\", name);\n-                }\n+            *buf += &format!(\"{}:\", name);\n+\n+            if res.types.is_some() {\n+                *buf += \" t\";\n+            }\n+            if res.values.is_some() {\n+                *buf += \" v\";\n+            }\n+            if res.macros.is_some() {\n+                *buf += \" m\";\n+            }\n+            if res.is_none() {\n+                *buf += \" _\";\n             }\n+\n+            *buf += \"\\n\";\n         }\n+\n         for (name, child) in map.modules[module].children.iter() {\n             let path = path.to_string() + &format!(\"::{}\", name);\n             go(buf, map, &path, *child);\n         }\n     }\n-\n-    fn dump_resolution(resolution: &Resolution) -> &'static str {\n-        match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n-            (true, true) => \"t v\",\n-            (true, false) => \"t\",\n-            (false, true) => \"v\",\n-            (false, false) => \"_\",\n-        }\n-    }\n }\n \n fn def_map(fixtute: &str) -> String {"}, {"sha": "20ee63c677523ca7286c07e6949712a520479f53", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 109, "deletions": 10, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -21,7 +21,6 @@ fn macro_rules_are_globally_visible() {\n    \u22eecrate\n    \u22eeFoo: t v\n    \u22eenested: t\n-   \u22eestructs: m\n    \u22ee\n    \u22eecrate::nested\n    \u22eeBar: t v\n@@ -47,7 +46,6 @@ fn macro_rules_can_define_modules() {\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n-   \u22eem: m\n    \u22een1: t\n    \u22ee\n    \u22eecrate::n1\n@@ -133,7 +131,6 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n    \u22eecrate\n    \u22eeFoo: t v\n    \u22eebar: m\n-   \u22eebaz: m\n    \u22eefoo: m\n     \"###);\n }\n@@ -271,7 +268,6 @@ fn prelude_cycle() {\n         \u22eeprelude: t\n         \u22ee\n         \u22eecrate::prelude\n-        \u22eedeclare_mod: m\n     \"###);\n }\n \n@@ -345,7 +341,6 @@ fn plain_macros_are_legacy_textual_scoped() {\n    \u22eeOk: t v\n    \u22eeOkAfter: t v\n    \u22eeOkShadowStop: t v\n-   \u22eefoo: m\n    \u22eem1: t\n    \u22eem2: t\n    \u22eem3: t\n@@ -354,28 +349,132 @@ fn plain_macros_are_legacy_textual_scoped() {\n    \u22eeok_double_macro_use_shadow: v\n    \u22ee\n    \u22eecrate::m7\n-   \u22eebaz: m\n    \u22ee\n    \u22eecrate::m1\n-   \u22eebar: m\n    \u22ee\n    \u22eecrate::m5\n    \u22eem6: t\n    \u22ee\n    \u22eecrate::m5::m6\n-   \u22eefoo: m\n    \u22ee\n    \u22eecrate::m2\n    \u22ee\n    \u22eecrate::m3\n    \u22eeOkAfterInside: t v\n    \u22eeOkMacroUse: t v\n-   \u22eefoo: m\n    \u22eem4: t\n    \u22eeok_shadow: v\n    \u22ee\n    \u22eecrate::m3::m4\n-   \u22eebar: m\n    \u22eeok_shadow_deep: v\n     \"###);\n }\n+\n+#[test]\n+fn type_value_macro_live_in_different_scopes() {\n+    let map = def_map(\n+        \"\n+        //- /main.rs\n+        #[macro_export]\n+        macro_rules! foo {\n+            ($x:ident) => { type $x = (); }\n+        }\n+\n+        foo!(foo);\n+        use foo as bar;\n+\n+        use self::foo as baz;\n+        fn baz() {}\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eebar: t m\n+        \u22eebaz: t v m\n+        \u22eefoo: t m\n+    \"###);\n+}\n+\n+#[test]\n+fn macro_use_can_be_aliased() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        #[macro_use]\n+        extern crate foo;\n+\n+        foo!(Direct);\n+        bar!(Alias);\n+\n+        //- /lib.rs\n+        use crate::foo as bar;\n+\n+        mod m {\n+            #[macro_export]\n+            macro_rules! foo {\n+                ($x:ident) => { struct $x; }\n+            }\n+        }\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeAlias: t v\n+        \u22eeDirect: t v\n+        \u22eefoo: t\n+    \"###);\n+}\n+\n+#[test]\n+fn path_quantified_macros() {\n+    let map = def_map(\n+        \"\n+        //- /main.rs\n+        macro_rules! foo {\n+            ($x:ident) => { struct $x; }\n+        }\n+\n+        crate::foo!(NotResolved);\n+\n+        crate::bar!(OkCrate);\n+        bar!(OkPlain);\n+        alias1!(NotHere);\n+        m::alias1!(OkAliasPlain);\n+        m::alias2!(OkAliasSuper);\n+        m::alias3!(OkAliasCrate);\n+        not_found!(NotFound);\n+\n+        mod m {\n+            #[macro_export]\n+            macro_rules! bar {\n+                ($x:ident) => { struct $x; }\n+            }\n+\n+            pub use bar as alias1;\n+            pub use super::bar as alias2;\n+            pub use crate::bar as alias3;\n+            pub use self::bar as not_found;\n+        }\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeOkAliasCrate: t v\n+        \u22eeOkAliasPlain: t v\n+        \u22eeOkAliasSuper: t v\n+        \u22eeOkCrate: t v\n+        \u22eeOkPlain: t v\n+        \u22eebar: m\n+        \u22eem: t\n+        \u22ee\n+        \u22eecrate::m\n+        \u22eealias1: m\n+        \u22eealias2: m\n+        \u22eealias3: m\n+        \u22eenot_found: _\n+    \"###);\n+}"}, {"sha": "d9bdd0e224b05bc3bc5425653f9c54be94b782d3", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -6,7 +6,6 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use crate::{\n     code_model::Crate,\n     db::HirDatabase,\n-    either::Either,\n     expr::{\n         scope::{ExprScopes, ScopeId},\n         PatId,\n@@ -126,7 +125,7 @@ impl Resolver {\n         let mut resolution = PerNs::none();\n         for scope in self.scopes.iter().rev() {\n             resolution = resolution.or(scope.resolve_name(db, name));\n-            if resolution.is_both() {\n+            if resolution.is_all() {\n                 return resolution;\n             }\n         }\n@@ -139,10 +138,7 @@ impl Resolver {\n         path: &Path,\n     ) -> Option<MacroDef> {\n         let (item_map, module) = self.module()?;\n-        match item_map.resolve_path_with_macro(db, module, path) {\n-            (Either::B(macro_def), None) => Some(macro_def),\n-            _ => None,\n-        }\n+        item_map.resolve_path(db, module, path).0.get_macros()\n     }\n \n     /// Returns the resolved path segments\n@@ -191,6 +187,9 @@ impl Resolver {\n                 if current.values.is_none() {\n                     current.values = res.values;\n                 }\n+                if current.macros.is_none() {\n+                    current.macros = res.macros;\n+                }\n             });\n         }\n         names\n@@ -313,6 +312,9 @@ impl Scope {\n                 m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n                     f(name.clone(), res.def.map(Resolution::Def));\n                 });\n+                m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n+                    f(name.clone(), PerNs::macros(macro_));\n+                });\n                 m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n                     f(name.clone(), PerNs::types(Resolution::Def(*def)));\n                 });"}, {"sha": "a2adbc4b8a27c80e4434fc81b4ebbfa6aa42169c", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -429,6 +429,9 @@ pub(crate) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace\n         (TypableDef::Const(_), Namespace::Types) => Ty::Unknown,\n         (TypableDef::Static(_), Namespace::Types) => Ty::Unknown,\n         (TypableDef::BuiltinType(_), Namespace::Values) => Ty::Unknown,\n+\n+        // Macro is not typeable\n+        (_, Namespace::Macro) => Ty::Unknown,\n     }\n }\n "}, {"sha": "38fe622795560bba4cdde5d65bc893a11edb52b1", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f91341595508833d39eb6d97e4ec2ac7f685cb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=40f91341595508833d39eb6d97e4ec2ac7f685cb", "patch": "@@ -2838,6 +2838,64 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn infer_path_quantified_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => { 42i32 }\n+}\n+\n+mod m {\n+    pub use super::foo as bar;\n+}\n+\n+fn main() {\n+    let x = crate::foo!();\n+    let y = m::bar!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    ![0; 5) '42i32': i32\n+    [111; 164) '{     ...!(); }': ()\n+    [121; 122) 'x': i32\n+    [148; 149) 'y': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_type_value_macro_having_same_name() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        mod foo {\n+            pub use super::foo;\n+        }\n+    };\n+    ($x:tt) => {\n+        $x\n+    };\n+}\n+\n+foo!();\n+\n+fn foo() {\n+    let foo = foo::foo!(42i32);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    [171; 206) '{     ...32); }': ()\n+    [181; 184) 'foo': i32\n+    \"###\n+    );\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {"}]}