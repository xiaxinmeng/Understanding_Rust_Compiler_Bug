{"sha": "ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYjFhNDhiNDE1YzFiNTg2YmI2NTJkNThmM2QyMDc4ZDg3ZjQ0ZGQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2018-11-23T19:09:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-23T19:09:08Z"}, "message": "Merge branch 'master' into frewsxcv-dyn", "tree": {"sha": "f7338faaa66791a15338a938f6a2bf94107de0d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7338faaa66791a15338a938f6a2bf94107de0d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb+FBUCRBK7hj4Ov3rIwAAdHIIAILGfs2qBTYtbkEFTsdTAAAa\nyc5USB5lHeLHKb3jxsDM2BtngWiPEiU53TZUHF/BQXbZifMD/ydYGsfVi9xYNlEi\no90SIG3nblBaS51woNYGrs0ZQ2XPsJhFzOwoT8zFaXmpTVJeYlKqu8u8yTEG7kuS\nFzKk8NI9ajwuRhZyv0DLEG/FvlaaRB4mM+dbu91UsQyr6gloFrjsgyGkP4d9jGIu\n6paeCUFT92REFxgkIjItfYHU/kAmdkEIqexwcqGd4tWAbJogGubUrHyaHAIuASrb\nL4pm9CerPvQ9MlwyovEHAsLkrrcWEMnGkUfDhx2uxUO7tpvcOOxj7oBlfal5cfc=\n=Faxk\n-----END PGP SIGNATURE-----\n", "payload": "tree f7338faaa66791a15338a938f6a2bf94107de0d1\nparent 033cbfec4d3bb23948a99379f8d63b7cfe5eed45\nparent 821bad3a5b13862e9fbfae35b446ab91a976a75e\nauthor Corey Farwell <coreyf@rwell.org> 1543000148 -0500\ncommitter GitHub <noreply@github.com> 1543000148 -0500\n\nMerge branch 'master' into frewsxcv-dyn"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "html_url": "https://github.com/rust-lang/rust/commit/ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "033cbfec4d3bb23948a99379f8d63b7cfe5eed45", "url": "https://api.github.com/repos/rust-lang/rust/commits/033cbfec4d3bb23948a99379f8d63b7cfe5eed45", "html_url": "https://github.com/rust-lang/rust/commit/033cbfec4d3bb23948a99379f8d63b7cfe5eed45"}, {"sha": "821bad3a5b13862e9fbfae35b446ab91a976a75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/821bad3a5b13862e9fbfae35b446ab91a976a75e", "html_url": "https://github.com/rust-lang/rust/commit/821bad3a5b13862e9fbfae35b446ab91a976a75e"}], "stats": {"total": 3252, "additions": 2034, "deletions": 1218}, "files": [{"sha": "e04b1bdfefdd8e6f59e1ee621338483fd4bee538", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -494,16 +494,11 @@ the version in `Cargo.lock`, so the build can no longer continue.\n To resolve this, we need to update `Cargo.lock`. Luckily, cargo provides a\n command to do this easily.\n \n-First, go into the `src/` directory since that is where `Cargo.toml` is in\n-the rust repository. Then run, `cargo update -p rustfmt-nightly` to solve\n-the problem.\n-\n ```\n-$ cd src\n $ cargo update -p rustfmt-nightly\n ```\n \n-This should change the version listed in `src/Cargo.lock` to the new version you updated\n+This should change the version listed in `Cargo.lock` to the new version you updated\n the submodule to. Running `./x.py build` should work now.\n \n ## Writing Documentation"}, {"sha": "6a2b1bc41eff0a9916d04877d42d0d4294976da3", "filename": "Cargo.lock", "status": "renamed", "additions": 108, "deletions": 68, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -341,7 +341,7 @@ dependencies = [\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -605,12 +605,13 @@ dependencies = [\n \n [[package]]\n name = \"derive_more\"\n-version = \"0.11.0\"\n+version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.13.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -658,6 +659,14 @@ dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.5.12\"\n@@ -724,7 +733,7 @@ name = \"failure_derive\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"synstructure 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1331,7 +1340,7 @@ version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-traits 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1581,7 +1590,7 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"0.4.13\"\n+version = \"0.4.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1632,6 +1641,15 @@ dependencies = [\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"quick-error\"\n version = \"1.2.2\"\n@@ -1660,23 +1678,23 @@ name = \"quote\"\n version = \"0.6.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.9\"\n+version = \"2.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"derive_more 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"derive_more 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1798,7 +1816,7 @@ dependencies = [\n \n [[package]]\n name = \"rls\"\n-version = \"0.130.5\"\n+version = \"1.31.6\"\n dependencies = [\n  \"cargo 0.33.0\",\n  \"cargo_metadata 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1813,20 +1831,20 @@ dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.16.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-blacklist 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.16.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.18.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-rustc 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-vfs 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-vfs 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n  \"rustc_tools_util 0.1.0\",\n- \"rustfmt-nightly 0.99.6\",\n+ \"rustfmt-nightly 1.0.0\",\n  \"serde 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1837,7 +1855,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.16.1\"\n+version = \"0.16.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1852,7 +1870,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-blacklist\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1883,9 +1901,10 @@ dependencies = [\n \n [[package]]\n name = \"rls-vfs\"\n-version = \"0.4.6\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1932,15 +1951,20 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-graphviz\"\n+version = \"297.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-ap-rustc_cratesio_shim\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1950,16 +1974,17 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-graphviz 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1969,63 +1994,64 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"274.0.0\"\n+version = \"297.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-arena 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-arena 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2187,7 +2213,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ena 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2526,7 +2552,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.99.6\"\n+version = \"1.0.0\"\n dependencies = [\n  \"assert_cli 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2541,9 +2567,9 @@ dependencies = [\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n  \"serde 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2620,7 +2646,7 @@ name = \"serde_derive\"\n version = \"1.0.75\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2762,7 +2788,7 @@ name = \"strum_macros\"\n version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2792,7 +2818,17 @@ name = \"syn\"\n version = \"0.14.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"0.15.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2810,7 +2846,7 @@ name = \"synstructure\"\n version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3237,11 +3273,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"721c204978be2143fab0a84b708c49d79d1f6100b8785610f456043a90708870\"\n \"checksum datafrog 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"16d724bf4ffe77cdceeecd461009b5f8d9e23c5d645d68bedb4586bf43e7e142\"\n \"checksum derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ceed73957c449214f8440eec8ad7fa282b67dc9eacbb24a3085b15d60397a17a\"\n-\"checksum derive_more 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46c7f14685a20f5dd08e7f754f2ea8cc064d8f4214ae21116c106a2768ba7b9b\"\n+\"checksum derive_more 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n \"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n \"checksum difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum elasticlunr-rs 2.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4837d77a1e157489a3933b743fd774ae75074e0e390b2b7f071530048a0d87ee\"\n+\"checksum ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25b4e5febb25f08c49f1b07dc33a182729a6b21edfb562b5aef95f78e0dbe5bb\"\n \"checksum ena 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88dc8393b3c7352f94092497f6b52019643e493b6b890eb417cdb7c46117e621\"\n \"checksum env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f4d7e69c283751083d53d01eac767407343b8b69c4bd70058e08adc2637cb257\"\n \"checksum env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n@@ -3342,15 +3379,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum proc-macro2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1b06e2f335f48d24442b35a19df506a835fb3547bc3c06ef27340da9acf5cae7\"\n-\"checksum proc-macro2 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee5697238f0d893c7f0ecc59c0999f18d2af85e424de441178bcacc9f9e6cf67\"\n+\"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n \"checksum proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"926d0604475349f463fe44130aae73f2294b5309ab2ca0310b998bd334ef191f\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n+\"checksum pulldown-cmark 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eef52fac62d0ea7b9b4dc7da092aa64ea7ec3d90af6679422d3d7e0e14b6ee15\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9949cfe66888ffe1d53e6ec9d9f3b70714083854be20fd5e271b232a017401e8\"\n \"checksum quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd636425967c33af890042c483632d33fa7a18f19ad1d7ea72e8998c6ef8dea5\"\n-\"checksum racer 2.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5eeddfffd44c83eb03eedf5eb336e9c75303534fe28728a9f6b39a6e6f07ccff\"\n+\"checksum racer 2.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"344a53b68d889ab5f44d0617f2bbe1f696abe6a730bd41fa619cfc6fa83a6078\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n \"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n \"checksum rand_core 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"edecf0f94da5551fc9b492093e30b041a891657db7940ee221f9d2f66e82eef2\"\n@@ -3363,20 +3401,21 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex-syntax 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d707a4fa2637f2dca2ef9fd02225ec7661fe01a53623c1e6515b6916511f7a7\"\n \"checksum regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"747ba3b235651f6e2f67dfa8bcdcd073ddb7c243cb21c442fc12395dfcac212d\"\n \"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n-\"checksum rls-analysis 0.16.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a625690e3bf1204ce27b50f71e508ee788214b2d51e26e4e5db884a83627673\"\n-\"checksum rls-blacklist 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e4a9cc2545ccb7e05b355bfe047b8039a6ec12270d5f3c996b766b340a50f7d2\"\n+\"checksum rls-analysis 0.16.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2a1d3a2a8c03e380331aefb8b5e3e06f3065602fbaa6657ba0ac649dc99d8537\"\n+\"checksum rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ce1fdac03e138c4617ff87b194e1ff57a39bb985a044ccbd8673d30701e411\"\n \"checksum rls-data 0.18.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a209ce46bb52813cbe0786a7baadc0c1a3f5543ef93f179eda3b841ed72cf2e\"\n \"checksum rls-rustc 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9dba7390427aefa953608429701e3665192ca810ba8ae09301e001b7c7bed0\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n-\"checksum rls-vfs 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ecbc8541b4c341d6271eae10f869dd9d36db871afe184f5b6f9bffbd6ed0373f\"\n-\"checksum rustc-ap-arena 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"866fda692855b38f9d6562f0e952c75c6ebe4032d7dd63c608a88e7c4d3f8087\"\n-\"checksum rustc-ap-rustc_cratesio_shim 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6c2343e11a97b4eb3bee29cd5f9314ea409a87baee5d3fec8d1516d1633412e\"\n-\"checksum rustc-ap-rustc_data_structures 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b88f905f7ab99bf14220a3a87eff60ec143af8136fd0ca8573641c78be532ec8\"\n-\"checksum rustc-ap-rustc_errors 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c86fda6cf42e0355b7ecf40f14888340c20b7b864c9d37f6ffca85fe87200652\"\n-\"checksum rustc-ap-rustc_target 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8fa8622299beac8c40270e8536a7b0509ca80f227a2b56550019a325fa5a60c0\"\n-\"checksum rustc-ap-serialize 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d16cc3d014af9a524c0bed6ca806c3170e39d5987180f0f8ce8fb7df5113576c\"\n-\"checksum rustc-ap-syntax 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2a29f280f04f4f45e1bdd773ab5e667b36e757bfbbd01193c330815b9e76d05a\"\n-\"checksum rustc-ap-syntax_pos 274.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c2ea27b65311571c7614deb393691eb18c5e41fd4fd9d8490304e128e1358646\"\n+\"checksum rls-vfs 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72d56425bd5aa86d9d4372b76f0381d3b4bda9c0220e71956c9fcc929f45c1f1\"\n+\"checksum rustc-ap-arena 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b69fd4a0e8a3ecd99b497965d05f6f04dd2e4601a6146a841dbe4c8e77c2b30c\"\n+\"checksum rustc-ap-graphviz 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8136418dbc491bab74aa0565eaa2086754a7a81a5e74a1d84d6168d18e889e7\"\n+\"checksum rustc-ap-rustc_cratesio_shim 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a972feda82332d1d05b1ba5a097e915cd9c9c8f1af2bd7b08af09fb88c753d5f\"\n+\"checksum rustc-ap-rustc_data_structures 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"582584c6c48b0ece4b8aef3f9bb59d94d17c5665612bc87a71f509e45a3113b5\"\n+\"checksum rustc-ap-rustc_errors 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd852096944d0ac6af1aefa9639a2ae6dede217606ce97f88ff0dcc8c86d6ff6\"\n+\"checksum rustc-ap-rustc_target 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"98301a272ecfeec29d2d4e97b07238707c2b89d86fc3a4a5f31a00728f14e288\"\n+\"checksum rustc-ap-serialize 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8f13510e617e2e322e3297038fd6a7346f2297124af9e10e33a627c5d544e9d\"\n+\"checksum rustc-ap-syntax 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0792f5a9ccfc5ec13bb5b0472fa49e145481029c39f6bf5b1a36decc99c3328f\"\n+\"checksum rustc-ap-syntax_pos 297.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df9f97f41650d23b14f92f7267f8c61089655efb4533d82bf8991f99245198d\"\n \"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c6d5a683c6ba4ed37959097e88d71c9e8e26659a3cb5be8b389078e7ad45306\"\n@@ -3412,6 +3451,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n \"checksum syn 0.13.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14f9bf6292f3a61d2c716723fdb789a41bbe104168e6f496dc6497e531ea1b9b\"\n \"checksum syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"261ae9ecaa397c42b960649561949d69311f08eeaea86a65696e6e46517cf741\"\n+\"checksum syn 0.15.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"816b7af21405b011a23554ea2dc3f6576dc86ca557047c34098c1d741f10f823\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n \"checksum synstructure 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"85bb9b7550d063ea184027c9b8c20ac167cd36d3e06b3a40bceb9d746dc1a7b7\"\n \"checksum tar 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69e16840a1e0a1f1a880b739ef1cc6a4b85496c99b8aa786ccffce6e0c15624c\"", "previous_filename": "src/Cargo.lock"}, {"sha": "1e1d7a40967b34f629eb60e5f0d2f978b272aebd", "filename": "Cargo.toml", "status": "renamed", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,31 +1,31 @@\n [workspace]\n members = [\n-  \"bootstrap\",\n-  \"rustc\",\n-  \"libstd\",\n-  \"libtest\",\n-  \"librustc_codegen_llvm\",\n-  \"tools/cargotest\",\n-  \"tools/clippy\",\n-  \"tools/compiletest\",\n-  \"tools/error_index_generator\",\n-  \"tools/linkchecker\",\n-  \"tools/rustbook\",\n-  \"tools/unstable-book-gen\",\n-  \"tools/tidy\",\n-  \"tools/build-manifest\",\n-  \"tools/remote-test-client\",\n-  \"tools/remote-test-server\",\n-  \"tools/rust-installer\",\n-  \"tools/cargo\",\n-  \"tools/rustdoc\",\n-  \"tools/rls\",\n-  \"tools/rustfmt\",\n-  \"tools/miri\",\n-  \"tools/rustdoc-themes\",\n+  \"src/bootstrap\",\n+  \"src/rustc\",\n+  \"src/libstd\",\n+  \"src/libtest\",\n+  \"src/librustc_codegen_llvm\",\n+  \"src/tools/cargotest\",\n+  \"src/tools/clippy\",\n+  \"src/tools/compiletest\",\n+  \"src/tools/error_index_generator\",\n+  \"src/tools/linkchecker\",\n+  \"src/tools/rustbook\",\n+  \"src/tools/unstable-book-gen\",\n+  \"src/tools/tidy\",\n+  \"src/tools/build-manifest\",\n+  \"src/tools/remote-test-client\",\n+  \"src/tools/remote-test-server\",\n+  \"src/tools/rust-installer\",\n+  \"src/tools/cargo\",\n+  \"src/tools/rustdoc\",\n+  \"src/tools/rls\",\n+  \"src/tools/rustfmt\",\n+  \"src/tools/miri\",\n+  \"src/tools/rustdoc-themes\",\n ]\n exclude = [\n-  \"tools/rls/test_data\",\n+  \"src/tools/rls/test_data\",\n ]\n \n # Curiously, LLVM 7.0 will segfault if compiled with opt-level=3\n@@ -50,18 +50,18 @@ debug-assertions = false\n # so we use a `[patch]` here to override the github repository with our local\n # vendored copy.\n [patch.\"https://github.com/rust-lang/cargo\"]\n-cargo = { path = \"tools/cargo\" }\n+cargo = { path = \"src/tools/cargo\" }\n \n [patch.crates-io]\n # Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n # that we're shipping as well (to ensure that the rustfmt in RLS and the\n # `rustfmt` executable are the same exact version).\n-rustfmt-nightly = { path = \"tools/rustfmt\" }\n+rustfmt-nightly = { path = \"src/tools/rustfmt\" }\n \n-# See comments in `tools/rustc-workspace-hack/README.md` for what's going on\n+# See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n # here\n-rustc-workspace-hack = { path = 'tools/rustc-workspace-hack' }\n+rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n \n [patch.\"https://github.com/rust-lang-nursery/rust-clippy\"]\n-clippy_lints = { path = \"tools/clippy/clippy_lints\" }\n-rustc_tools_util = { path = \"tools/clippy/rustc_tools_util\" }\n+clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n+rustc_tools_util = { path = \"src/tools/clippy/rustc_tools_util\" }", "previous_filename": "src/Cargo.toml"}, {"sha": "a455186859f863eff229390ce0542fc18ed5fca1", "filename": "RELEASES.md", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,3 +1,80 @@\n+Version 1.31.0 (2018-12-06)\n+==========================\n+\n+Language\n+--------\n+- \ud83c\udf89 [This version marks the release of the 2018 edition of Rust.][54057] \ud83c\udf89 \n+- [New lifetime elision rules now allow for eliding lifetimes in functions and\n+  impl headers.][54778] E.g. `impl<'a> Reader for BufReader<'a> {}` can now be\n+  `impl Reader for BufReader<'_> {}`. Lifetimes are still required to be defined\n+  in structs.\n+- [You can now define and use `const` functions.][54835] These are currently\n+  a strict minimal subset of the [const fn RFC][RFC-911]. Refer to the\n+  [language reference][const-reference] for what exactly is available.\n+- [You can now use tool lints, which allow you to scope lints from external\n+  tools using attributes.][54870] E.g. `#[allow(clippy::filter_map)]`.\n+- [`#[no_mangle]` and `#[export_name]` attributes can now be located anywhere in\n+  a crate, not just in exported functions.][54451]\n+- [You can now use parentheses in pattern matches.][54497]\n+\n+Compiler\n+--------\n+- [Updated musl to 1.1.20][54430]\n+\n+Libraries\n+---------\n+- [You can now convert `num::NonZero*` types to their raw equivalvents using the\n+  `From` trait.][54240] E.g. `u8` now implements `From<NonZeroU8>`.\n+- [You can now convert a `&Option<T>` into `Option<&T>` and `&mut Option<T>`\n+  into `Option<&mut T>` using the `From` trait.][53218]\n+- [You can now multiply (`*`) a `time::Duration` by a `u32`.][52813]\n+\n+\n+Stabilized APIs\n+---------------\n+- [`slice::align_to`]\n+- [`slice::align_to_mut`]\n+- [`slice::chunks_exact`]\n+- [`slice::chunks_exact_mut`]\n+- [`slice::rchunks`]\n+- [`slice::rchunks_mut`]\n+- [`slice::rchunks_exact`]\n+- [`slice::rchunks_exact_mut`]\n+- [`Option::replace`]\n+\n+Cargo\n+-----\n+- [Cargo will now download crates in parallel using HTTP/2.][cargo/6005]\n+- [You can now rename packages in your Cargo.toml][cargo/6319] We have a guide\n+  on [how to use the `package` key in your dependencies.][cargo-rename-reference]\n+\n+[52813]: https://github.com/rust-lang/rust/pull/52813/\n+[53218]: https://github.com/rust-lang/rust/pull/53218/\n+[53555]: https://github.com/rust-lang/rust/issues/53555/\n+[54057]: https://github.com/rust-lang/rust/pull/54057/\n+[54240]: https://github.com/rust-lang/rust/pull/54240/\n+[54430]: https://github.com/rust-lang/rust/pull/54430/\n+[54451]: https://github.com/rust-lang/rust/pull/54451/\n+[54497]: https://github.com/rust-lang/rust/pull/54497/\n+[54778]: https://github.com/rust-lang/rust/pull/54778/\n+[54835]: https://github.com/rust-lang/rust/pull/54835/\n+[54870]: https://github.com/rust-lang/rust/pull/54870/\n+[RFC-911]: https://github.com/rust-lang/rfcs/pull/911\n+[`Option::replace`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.replace\n+[`slice::align_to_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut\n+[`slice::align_to`]: https://doc.rust-lang.org/std/primitive.slice.html#method.align_to\n+[`slice::chunks_exact_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut\n+[`slice::chunks_exact`]: https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact\n+[`slice::rchunks_exact_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut\n+[`slice::rchunks_exact`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact\n+[`slice::rchunks_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut\n+[`slice::rchunks`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks\n+[cargo/6005]: https://github.com/rust-lang/cargo/pull/6005/\n+[cargo/6319]: https://github.com/rust-lang/cargo/pull/6319/\n+[cargo-rename-reference]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml\n+[const-reference]: https://doc.rust-lang.org/reference/items/functions.html#const-functions\n+\n+\n Version 1.30.0 (2018-10-25)\n ==========================\n "}, {"sha": "d143dffb24be5239d59b47f08ec58c78119830a7", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -801,7 +801,7 @@ def bootstrap(help_triggered):\n                 registry = 'https://example.com'\n \n                 [source.vendored-sources]\n-                directory = '{}/src/vendor'\n+                directory = '{}/vendor'\n             \"\"\".format(build.rust_root))\n     else:\n         if os.path.exists('.cargo'):"}, {"sha": "cd8d5642b25707a261b1dad4f277a5db4414bedf", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -851,7 +851,7 @@ impl Step for Src {\n         t!(fs::create_dir_all(&dst_src));\n \n         let src_files = [\n-            \"src/Cargo.lock\",\n+            \"Cargo.lock\",\n         ];\n         // This is the reduced set of paths which will become the rust-src component\n         // (essentially libstd and all of its path dependencies)\n@@ -949,6 +949,8 @@ impl Step for PlainSourceTarball {\n             \"configure\",\n             \"x.py\",\n             \"config.toml.example\",\n+            \"Cargo.toml\",\n+            \"Cargo.lock\",\n         ];\n         let src_dirs = [\n             \"src\",\n@@ -992,7 +994,7 @@ impl Step for PlainSourceTarball {\n             // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&builder.initial_cargo);\n             cmd.arg(\"vendor\")\n-               .current_dir(&plain_dst_src.join(\"src\"));\n+               .current_dir(&plain_dst_src);\n             builder.run(&mut cmd);\n         }\n "}, {"sha": "f9b19ffb10d69bfe2454e7184fddb5588bf68b8b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -260,22 +260,31 @@ impl Step for TheBook {\n         let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n-        // build book first edition\n+\n+        // build book\n         builder.ensure(Rustbook {\n             target,\n-            name: INTERNER.intern_string(format!(\"{}/first-edition\", name)),\n+            name: INTERNER.intern_string(name.to_string()),\n         });\n \n-        // build book second edition\n+        // building older edition redirects\n+\n+        let source_name = format!(\"{}/first-edition\", name);\n         builder.ensure(Rustbook {\n             target,\n-            name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n+            name: INTERNER.intern_string(source_name),\n         });\n \n-        // build book 2018 edition\n+        let source_name = format!(\"{}/second-edition\", name);\n         builder.ensure(Rustbook {\n             target,\n-            name: INTERNER.intern_string(format!(\"{}/2018-edition\", name)),\n+            name: INTERNER.intern_string(source_name),\n+        });\n+\n+        let source_name = format!(\"{}/2018-edition\", name);\n+        builder.ensure(Rustbook {\n+            target,\n+            name: INTERNER.intern_string(source_name),\n         });\n \n         // build the version info page and CSS\n@@ -284,11 +293,6 @@ impl Step for TheBook {\n             target,\n         });\n \n-        // build the index page\n-        let index = format!(\"{}/index.md\", name);\n-        builder.info(&format!(\"Documenting book index ({})\", target));\n-        invoke_rustdoc(builder, compiler, target, &index);\n-\n         // build the redirect pages\n         builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n         for file in t!(fs::read_dir(builder.src.join(\"src/doc/book/redirects\"))) {"}, {"sha": "c50e6a270339f8354b63eaf6a8eef748e7e70bbb", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1934,6 +1934,7 @@ impl Step for Distcheck {\n                 .arg(\"generate-lockfile\")\n                 .arg(\"--manifest-path\")\n                 .arg(&toml)\n+                .env(\"__CARGO_TEST_ROOT\", &dir)\n                 .current_dir(&dir),\n         );\n     }"}, {"sha": "4acc739db57bf1d020685bfcebbd3a45c0d0d75f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -22,6 +22,7 @@ use util::{exe, add_lib_path};\n use compile;\n use native;\n use channel::GitInfo;\n+use channel;\n use cache::Interned;\n use toolstate::ToolState;\n \n@@ -240,6 +241,7 @@ pub fn prepare_tool_cargo(\n \n     cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n     cargo.env(\"CFG_VERSION\", builder.rust_version());\n+    cargo.env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM);\n \n     let info = GitInfo::new(&builder.config, &dir);\n     if let Some(sha) = info.sha() {\n@@ -258,8 +260,13 @@ pub fn prepare_tool_cargo(\n }\n \n macro_rules! tool {\n-    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr\n-        $(,llvm_tools = $llvm:expr)* $(,is_external_tool = $external:expr)*;)+) => {\n+    ($(\n+        $name:ident, $path:expr, $tool_name:expr, $mode:expr\n+        $(,llvm_tools = $llvm:expr)*\n+        $(,is_external_tool = $external:expr)*\n+        $(,cargo_test_root = $cargo_test_root:expr)*\n+        ;\n+    )+) => {\n         #[derive(Copy, PartialEq, Eq, Clone)]\n         pub enum Tool {\n             $(\n@@ -281,6 +288,15 @@ macro_rules! tool {\n                     $(Tool::$name => false $(|| $llvm)*,)+\n                 }\n             }\n+\n+            /// Whether this tool requires may run Cargo for test crates,\n+            /// which currently needs setting the environment variable\n+            /// `__CARGO_TEST_ROOT` to separate it from the workspace.\n+            pub fn needs_cargo_test_root(&self) -> bool {\n+                match self {\n+                    $(Tool::$name => false $(|| $cargo_test_root)*,)+\n+                }\n+            }\n         }\n \n         impl<'a> Builder<'a> {\n@@ -356,8 +372,9 @@ tool!(\n     UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::ToolBootstrap;\n     Tidy, \"src/tools/tidy\", \"tidy\", Mode::ToolBootstrap;\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::ToolBootstrap;\n-    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::ToolBootstrap;\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::ToolBootstrap, llvm_tools = true;\n+    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::ToolBootstrap, cargo_test_root = true;\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::ToolBootstrap,\n+        llvm_tools = true, cargo_test_root = true;\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::ToolBootstrap;\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::ToolBootstrap;\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::ToolBootstrap,\n@@ -676,6 +693,11 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n+        // Set `__CARGO_TEST_ROOT` to the build directory if needed.\n+        if tool.needs_cargo_test_root() {\n+            cmd.env(\"__CARGO_TEST_ROOT\", &self.config.out);\n+        }\n+\n         add_lib_path(lib_paths, cmd);\n     }\n "}, {"sha": "616fe4172b688393aeee5f34935cc25733c9c062", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit e871c4598925594421d63e929fee292e6e071f97\n+Subproject commit 616fe4172b688393aeee5f34935cc25733c9c062"}, {"sha": "f8a4e96feb2e5a6ed1ef170ad40e3509a7755cb4", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit 7f7a597b47ed6c35c2a0f0ee6a69050fe2d5e013\n+Subproject commit f8a4e96feb2e5a6ed1ef170ad40e3509a7755cb4"}, {"sha": "60077efda319c95a89fe39609803c5433567adbf", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit b9fb838054b8441223c22eeae5b6d8e498071cd0\n+Subproject commit 60077efda319c95a89fe39609803c5433567adbf"}, {"sha": "2ce92beabb912d417a7314d6da83ac9b50dc2afb", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit bc342a475c09b6df8004d518382e6d5b6bcb49f7\n+Subproject commit 2ce92beabb912d417a7314d6da83ac9b50dc2afb"}, {"sha": "870158200dee90aa9c2787bed74d71e60cff9365", "filename": "src/doc/unstable-book/src/language-features/macro-literal-matcher.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -4,14 +4,14 @@ The tracking issue for this feature is: [#35625]\n \n The RFC is: [rfc#1576].\n \n-With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n+With this feature gate enabled, the [list of designators] gains one more entry:\n \n * `literal`: a literal. Examples: 2, \"string\", 'c'\n \n A `literal` may be followed by anything, similarly to the `ident` specifier.\n \n [rfc#1576]: http://rust-lang.github.io/rfcs/1576-macros-literal-matcher.html\n [#35625]: https://github.com/rust-lang/rust/issues/35625\n-[frags]: ../book/first-edition/macros.html#syntactic-requirements\n+[list of designators]: ../reference/macros-by-example.html\n \n ------------------------"}, {"sha": "74bdd4dc3b5993e4e06d5c2765af977c6fa71538", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -137,8 +137,6 @@ of extensions.  See `Registry::register_syntax_extension` and the\n \n ## Tips and tricks\n \n-Some of the [macro debugging tips](../book/first-edition/macros.html#debugging-macro-code) are applicable.\n-\n You can use `syntax::parse` to turn token trees into\n higher-level syntax elements like expressions:\n "}, {"sha": "27275ba37957e1e93fe6cdd2c0b60be277e43963", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -293,15 +293,23 @@ def display_hint():\n     def to_string(self):\n         (tail, head, data_ptr, cap) = \\\n             rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n+        if head >= tail:\n+            size = head - tail\n+        else:\n+            size = cap + head - tail\n         return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (head - tail, cap)))\n+                (\"(len: %i, cap: %i)\" % (size, cap)))\n \n     def children(self):\n         (tail, head, data_ptr, cap) = \\\n             rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n         gdb_ptr = data_ptr.get_wrapped_value()\n-        for index in xrange(tail, head):\n-            yield (str(index), (gdb_ptr + index).dereference())\n+        if head >= tail:\n+            size = head - tail\n+        else:\n+            size = cap + head - tail\n+        for index in xrange(0, size):\n+            yield (str(index), (gdb_ptr + ((tail + index) % cap)).dereference())\n \n \n class RustStdBTreeSetPrinter(object):"}, {"sha": "3ca6de191de2d03542adadca579931e4c1dbdd39", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -43,8 +43,8 @@\n //!\n //! `Rc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n //! so you can call `T`'s methods on a value of type [`Rc<T>`][`Rc`]. To avoid name\n-//! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are [associated\n-//! functions][assoc], called using function-like syntax:\n+//! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are associated\n+//! functions, called using function-like syntax:\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -234,7 +234,6 @@\n //! [downgrade]: struct.Rc.html#method.downgrade\n //! [upgrade]: struct.Weak.html#method.upgrade\n //! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n //! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "22da9dd6e9619804beece5a0487977d82288a15a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -213,6 +213,22 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// The comparator function must define a total ordering for the elements in the slice. If\n+    /// the ordering is not total, the order of the elements is unspecified. An order is a\n+    /// total order if it is (for all a, b and c):\n+    ///\n+    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n+    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    ///\n+    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n+    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n+    ///\n+    /// ```\n+    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n+    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n+    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n+    /// ```\n+    ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n     /// See [`sort_unstable_by`](#method.sort_unstable_by)."}, {"sha": "4f4031e3c4e32a120f86f02fb950a0c36c2f107b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -120,8 +120,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n /// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n-/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n-/// functions][assoc], called using function-like syntax:\n+/// clashes with `T`'s methods, the methods of `Arc<T>` itself are associated\n+/// functions, called using function-like syntax:\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -146,7 +146,6 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n /// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n /// [`std::sync`]: ../../std/sync/index.html\n /// [`Arc::clone(&from)`]: #method.clone"}, {"sha": "c2113dfd2a06714e5224dc58a59585b4a9d5b74c", "filename": "src/libcore/any.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -39,7 +39,7 @@\n //!\n //! // Logger function for any type that implements Debug.\n //! fn log<T: Any + Debug>(value: &T) {\n-//!     let value_any = value as &Any;\n+//!     let value_any = value as &dyn Any;\n //!\n //!     // try to convert our value to a String.  If successful, we want to\n //!     // output the String's length as well as its value.  If not, it's a\n@@ -95,7 +95,7 @@ pub trait Any: 'static {\n     ///\n     /// use std::any::{Any, TypeId};\n     ///\n-    /// fn is_string(s: &Any) -> bool {\n+    /// fn is_string(s: &dyn Any) -> bool {\n     ///     TypeId::of::<String>() == s.get_type_id()\n     /// }\n     ///\n@@ -151,7 +151,7 @@ impl dyn Any {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn is_string(s: &Any) {\n+    /// fn is_string(s: &dyn Any) {\n     ///     if s.is::<String>() {\n     ///         println!(\"It's a string!\");\n     ///     } else {\n@@ -185,7 +185,7 @@ impl dyn Any {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn print_if_string(s: &Any) {\n+    /// fn print_if_string(s: &dyn Any) {\n     ///     if let Some(string) = s.downcast_ref::<String>() {\n     ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n     ///     } else {\n@@ -218,7 +218,7 @@ impl dyn Any {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn modify_if_u32(s: &mut Any) {\n+    /// fn modify_if_u32(s: &mut dyn Any) {\n     ///     if let Some(num) = s.downcast_mut::<u32>() {\n     ///         *num = 42;\n     ///     }\n@@ -256,7 +256,7 @@ impl dyn Any+Send {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn is_string(s: &(Any + Send)) {\n+    /// fn is_string(s: &(dyn Any + Send)) {\n     ///     if s.is::<String>() {\n     ///         println!(\"It's a string!\");\n     ///     } else {\n@@ -282,7 +282,7 @@ impl dyn Any+Send {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn print_if_string(s: &(Any + Send)) {\n+    /// fn print_if_string(s: &(dyn Any + Send)) {\n     ///     if let Some(string) = s.downcast_ref::<String>() {\n     ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n     ///     } else {\n@@ -308,7 +308,7 @@ impl dyn Any+Send {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn modify_if_u32(s: &mut (Any + Send)) {\n+    /// fn modify_if_u32(s: &mut (dyn Any + Send)) {\n     ///     if let Some(num) = s.downcast_mut::<u32>() {\n     ///         *num = 42;\n     ///     }\n@@ -340,7 +340,7 @@ impl dyn Any+Send+Sync {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn is_string(s: &(Any + Send + Sync)) {\n+    /// fn is_string(s: &(dyn Any + Send + Sync)) {\n     ///     if s.is::<String>() {\n     ///         println!(\"It's a string!\");\n     ///     } else {\n@@ -366,7 +366,7 @@ impl dyn Any+Send+Sync {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn print_if_string(s: &(Any + Send + Sync)) {\n+    /// fn print_if_string(s: &(dyn Any + Send + Sync)) {\n     ///     if let Some(string) = s.downcast_ref::<String>() {\n     ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n     ///     } else {\n@@ -392,7 +392,7 @@ impl dyn Any+Send+Sync {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn modify_if_u32(s: &mut (Any + Send + Sync)) {\n+    /// fn modify_if_u32(s: &mut (dyn Any + Send + Sync)) {\n     ///     if let Some(num) = s.downcast_mut::<u32>() {\n     ///         *num = 42;\n     ///     }"}, {"sha": "b57e167b05d9eb1af9e2b58e516e23620ac738f3", "filename": "src/libcore/benches/num/mod.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -10,3 +10,108 @@\n \n mod flt2dec;\n mod dec2flt;\n+\n+use test::Bencher;\n+use std::str::FromStr;\n+\n+const ASCII_NUMBERS: [&str; 19] = [\n+    \"0\",\n+    \"1\",\n+    \"2\",\n+    \"43\",\n+    \"765\",\n+    \"76567\",\n+    \"987245987\",\n+    \"-4aa32\",\n+    \"1786235\",\n+    \"8723095\",\n+    \"f##5s\",\n+    \"83638730\",\n+    \"-2345\",\n+    \"562aa43\",\n+    \"-1\",\n+    \"-0\",\n+    \"abc\",\n+    \"xyz\",\n+    \"c0ffee\",\n+];\n+\n+macro_rules! from_str_bench {\n+    ($mac:ident, $t:ty) => (\n+        #[bench]\n+        fn $mac(b: &mut Bencher) {\n+            b.iter(|| {\n+                ASCII_NUMBERS\n+                    .iter()\n+                    .cycle()\n+                    .take(5_000)\n+                    .filter_map(|s| <($t)>::from_str(s).ok())\n+                    .max()\n+            })\n+        }\n+    )\n+}\n+\n+macro_rules! from_str_radix_bench {\n+    ($mac:ident, $t:ty, $radix:expr) => (\n+        #[bench]\n+        fn $mac(b: &mut Bencher) {\n+            b.iter(|| {\n+                ASCII_NUMBERS\n+                    .iter()\n+                    .cycle()\n+                    .take(5_000)\n+                    .filter_map(|s| <($t)>::from_str_radix(s, $radix).ok())\n+                    .max()\n+            })\n+        }\n+    )\n+}\n+\n+from_str_bench!(bench_u8_from_str, u8);\n+from_str_radix_bench!(bench_u8_from_str_radix_2, u8, 2);\n+from_str_radix_bench!(bench_u8_from_str_radix_10, u8, 10);\n+from_str_radix_bench!(bench_u8_from_str_radix_16, u8, 16);\n+from_str_radix_bench!(bench_u8_from_str_radix_36, u8, 36);\n+\n+from_str_bench!(bench_u16_from_str, u16);\n+from_str_radix_bench!(bench_u16_from_str_radix_2, u16, 2);\n+from_str_radix_bench!(bench_u16_from_str_radix_10, u16, 10);\n+from_str_radix_bench!(bench_u16_from_str_radix_16, u16, 16);\n+from_str_radix_bench!(bench_u16_from_str_radix_36, u16, 36);\n+\n+from_str_bench!(bench_u32_from_str, u32);\n+from_str_radix_bench!(bench_u32_from_str_radix_2, u32, 2);\n+from_str_radix_bench!(bench_u32_from_str_radix_10, u32, 10);\n+from_str_radix_bench!(bench_u32_from_str_radix_16, u32, 16);\n+from_str_radix_bench!(bench_u32_from_str_radix_36, u32, 36);\n+\n+from_str_bench!(bench_u64_from_str, u64);\n+from_str_radix_bench!(bench_u64_from_str_radix_2, u64, 2);\n+from_str_radix_bench!(bench_u64_from_str_radix_10, u64, 10);\n+from_str_radix_bench!(bench_u64_from_str_radix_16, u64, 16);\n+from_str_radix_bench!(bench_u64_from_str_radix_36, u64, 36);\n+\n+from_str_bench!(bench_i8_from_str, i8);\n+from_str_radix_bench!(bench_i8_from_str_radix_2, i8, 2);\n+from_str_radix_bench!(bench_i8_from_str_radix_10, i8, 10);\n+from_str_radix_bench!(bench_i8_from_str_radix_16, i8, 16);\n+from_str_radix_bench!(bench_i8_from_str_radix_36, i8, 36);\n+\n+from_str_bench!(bench_i16_from_str, i16);\n+from_str_radix_bench!(bench_i16_from_str_radix_2, i16, 2);\n+from_str_radix_bench!(bench_i16_from_str_radix_10, i16, 10);\n+from_str_radix_bench!(bench_i16_from_str_radix_16, i16, 16);\n+from_str_radix_bench!(bench_i16_from_str_radix_36, i16, 36);\n+\n+from_str_bench!(bench_i32_from_str, i32);\n+from_str_radix_bench!(bench_i32_from_str_radix_2, i32, 2);\n+from_str_radix_bench!(bench_i32_from_str_radix_10, i32, 10);\n+from_str_radix_bench!(bench_i32_from_str_radix_16, i32, 16);\n+from_str_radix_bench!(bench_i32_from_str_radix_36, i32, 36);\n+\n+from_str_bench!(bench_i64_from_str, i64);\n+from_str_radix_bench!(bench_i64_from_str_radix_2, i64, 2);\n+from_str_radix_bench!(bench_i64_from_str_radix_10, i64, 10);\n+from_str_radix_bench!(bench_i64_from_str_radix_16, i64, 16);\n+from_str_radix_bench!(bench_i64_from_str_radix_36, i64, 36);"}, {"sha": "160728f923dbcbac4fa5a65b67121c504c4119d7", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -19,7 +19,7 @@ use super::MAX;\n /// Converts a `u32` to a `char`.\n ///\n /// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n+/// `as`:\n ///\n /// ```\n /// let c = '\ud83d\udcaf';\n@@ -34,7 +34,6 @@ use super::MAX;\n ///\n /// [`char`]: ../../std/primitive.char.html\n /// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n ///\n /// For an unsafe version of this function which ignores these checks, see\n /// [`from_u32_unchecked`].\n@@ -71,7 +70,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Converts a `u32` to a `char`, ignoring validity.\n ///\n /// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n+/// `as`:\n ///\n /// ```\n /// let c = '\ud83d\udcaf';\n@@ -86,7 +85,6 @@ pub fn from_u32(i: u32) -> Option<char> {\n ///\n /// [`char`]: ../../std/primitive.char.html\n /// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n ///\n /// # Safety\n ///"}, {"sha": "fd4189ef50df54a9466ca3aa159f5692cd05506f", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -532,7 +532,7 @@ pub trait Iterator {\n     /// If you're doing some sort of looping for a side effect, it's considered\n     /// more idiomatic to use [`for`] than `map()`.\n     ///\n-    /// [`for`]: ../../book/first-edition/loops.html#for\n+    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n     ///\n     /// # Examples\n     ///\n@@ -580,7 +580,7 @@ pub trait Iterator {\n     /// cases `for_each` may also be faster than a loop, because it will use\n     /// internal iteration on adaptors like `Chain`.\n     ///\n-    /// [`for`]: ../../book/first-edition/loops.html#for\n+    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n     ///\n     /// # Examples\n     ///\n@@ -1669,7 +1669,7 @@ pub trait Iterator {\n     /// use a `for` loop with a list of things to build up a result. Those\n     /// can be turned into `fold()`s:\n     ///\n-    /// [`for`]: ../../book/first-edition/loops.html#for\n+    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n     ///\n     /// ```\n     /// let numbers = [1, 2, 3, 4, 5];"}, {"sha": "56ba10c49f41f7d01c84ef509f904d481bd71eab", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -132,7 +132,6 @@ pub use intrinsics::transmute;\n /// [uninit]: fn.uninitialized.html\n /// [clone]: ../clone/trait.Clone.html\n /// [swap]: fn.swap.html\n-/// [FFI]: ../../book/first-edition/ffi.html\n /// [box]: ../../std/boxed/struct.Box.html\n /// [leak]: ../../std/boxed/struct.Box.html#method.leak\n /// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n@@ -479,7 +478,7 @@ pub const fn needs_drop<T>() -> bool {\n ///\n /// This has the same effect as allocating space with\n /// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n-/// [FFI] sometimes, but should generally be avoided.\n+/// FFI sometimes, but should generally be avoided.\n ///\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n /// some type `T`. If `T` has a destructor and the value is destroyed (due to\n@@ -490,7 +489,6 @@ pub const fn needs_drop<T>() -> bool {\n /// many of the same caveats.\n ///\n /// [uninit]: fn.uninitialized.html\n-/// [FFI]: ../../book/first-edition/ffi.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n@@ -514,11 +512,9 @@ pub unsafe fn zeroed<T>() -> T {\n /// **This is incredibly dangerous and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n-/// This is useful for [FFI] functions and initializing arrays sometimes,\n+/// This is useful for FFI functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// [FFI]: ../../book/first-edition/ffi.html\n-///\n /// # Undefined behavior\n ///\n /// It is [undefined behavior][ub] to read uninitialized memory, even just an\n@@ -689,10 +685,9 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// While this does call the argument's implementation of [`Drop`][drop],\n /// it will not release any borrows, as borrows are based on lexical scope.\n ///\n-/// This effectively does nothing for\n-/// [types which implement `Copy`](../../book/first-edition/ownership.html#copy-types),\n-/// e.g. integers. Such values are copied and _then_ moved into the function,\n-/// so the value persists after this function call.\n+/// This effectively does nothing for types which implement `Copy`, e.g.\n+/// integers. Such values are copied and _then_ moved into the function, so the\n+/// value persists after this function call.\n ///\n /// This function is not magic; it is literally defined as\n ///\n@@ -1021,15 +1016,15 @@ impl<T: ?Sized> ManuallyDrop<T> {\n impl<T: ?Sized> Deref for ManuallyDrop<T> {\n     type Target = T;\n     #[inline]\n-    fn deref(&self) -> &Self::Target {\n+    fn deref(&self) -> &T {\n         &self.value\n     }\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     #[inline]\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n+    fn deref_mut(&mut self) -> &mut T {\n         &mut self.value\n     }\n }"}, {"sha": "e9cf11424cae1bd6a24f3ea9875c73e9de70e211", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -58,7 +58,7 @@\n //! [`NonNull::dangling`] in such cases.\n //!\n //! [aliasing]: ../../nomicon/aliasing.html\n-//! [book]: ../../book/second-edition/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n+//! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n //! [null]: ./fn.null.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts"}, {"sha": "3d4bccb4f9d654ebc049cb95588cda36fc245b09", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -21,11 +21,7 @@\n /// The representation of a trait object like `&SomeTrait`.\n ///\n /// This struct has the same layout as types like `&SomeTrait` and\n-/// `Box<dyn AnotherTrait>`. The [Trait Objects chapter of the\n-/// Book][moreinfo] contains more details about the precise nature of\n-/// these internals.\n-///\n-/// [moreinfo]: ../../book/first-edition/trait-objects.html#representation\n+/// `Box<dyn AnotherTrait>`.\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g. the fields are not directly accessible"}, {"sha": "8c55a16f3c8888d289d8257818fbceae0ae1dc50", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1510,6 +1510,22 @@ impl<T> [T] {\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n     /// and `O(n log n)` worst-case.\n     ///\n+    /// The comparator function must define a total ordering for the elements in the slice. If\n+    /// the ordering is not total, the order of the elements is unspecified. An order is a\n+    /// total order if it is (for all a, b and c):\n+    ///\n+    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n+    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    ///\n+    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n+    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n+    ///\n+    /// ```\n+    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n+    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n+    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n+    /// ```\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,"}, {"sha": "63b749c548e2419157f53b19d5b6d5819c09f56c", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -101,11 +101,11 @@ impl DepGraph {\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n-                dep_node_debug: Lock::new(Default::default()),\n+                dep_node_debug: Default::default(),\n                 current: Lock::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n                 colors: Lock::new(DepNodeColorMap::new(prev_graph_node_count)),\n-                loaded_from_cache: Lock::new(Default::default()),\n+                loaded_from_cache: Default::default(),\n             })),\n             fingerprints: Lrc::new(Lock::new(fingerprints)),\n         }"}, {"sha": "b3ba2968c9f51b769a79a78818d65cb378538b17", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 79, "deletions": 19, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -244,9 +244,9 @@ pub fn lower_crate(\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n-        type_def_lifetime_params: DefIdMap(),\n+        type_def_lifetime_params: Default::default(),\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n-        item_local_id_counters: NodeMap(),\n+        item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_in_trait_impl: false,\n@@ -1168,7 +1168,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::TyKind::BareFn(P(hir::BareFnTy {\n                                 generic_params: this.lower_generic_params(\n                                     &f.generic_params,\n-                                    &NodeMap(),\n+                                    &NodeMap::default(),\n                                     ImplTraitContext::disallowed(),\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n@@ -1866,6 +1866,10 @@ impl<'a> LoweringContext<'a> {\n         } else {\n             self.lower_node_id(segment.id)\n         };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n \n         hir::PathSegment::new(\n             segment.ident,\n@@ -2467,7 +2471,7 @@ impl<'a> LoweringContext<'a> {\n         // FIXME: This could probably be done with less rightward drift. Also looks like two control\n         //        paths where report_error is called are also the only paths that advance to after\n         //        the match statement, so the error reporting could probably just be moved there.\n-        let mut add_bounds: NodeMap<Vec<_>> = NodeMap();\n+        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n@@ -2552,7 +2556,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                             bound_generic_params: this.lower_generic_params(\n                                 bound_generic_params,\n-                                &NodeMap(),\n+                                &NodeMap::default(),\n                                 ImplTraitContext::disallowed(),\n                             ),\n                             bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n@@ -2636,8 +2640,11 @@ impl<'a> LoweringContext<'a> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_>,\n     ) -> hir::PolyTraitRef {\n-        let bound_generic_params =\n-            self.lower_generic_params(&p.bound_generic_params, &NodeMap(), itctx.reborrow());\n+        let bound_generic_params = self.lower_generic_params(\n+            &p.bound_generic_params,\n+            &NodeMap::default(),\n+            itctx.reborrow(),\n+        );\n         let trait_ref = self.with_parent_impl_lifetime_defs(\n             &bound_generic_params,\n             |this| this.lower_trait_ref(&p.trait_ref, itctx),\n@@ -2952,6 +2959,9 @@ impl<'a> LoweringContext<'a> {\n         name: &mut Name,\n         attrs: &hir::HirVec<Attribute>,\n     ) -> hir::ItemKind {\n+        debug!(\"lower_use_tree(tree={:?})\", tree);\n+        debug!(\"lower_use_tree: vis = {:?}\", vis);\n+\n         let path = &tree.prefix;\n         let segments = prefix\n             .segments\n@@ -3019,12 +3029,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n                             hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n                                 let id = this.next_id();\n-                                let mut path = path.clone();\n-                                for seg in path.segments.iter_mut() {\n-                                    if seg.id.is_some() {\n-                                        seg.id = Some(this.next_id().node_id);\n-                                    }\n-                                }\n+                                let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path,\n                                     id: id.node_id,\n@@ -3065,7 +3070,29 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n-                // Nested imports are desugared into simple imports.\n+                // Nested imports are desugared into simple\n+                // imports. So if we start with\n+                //\n+                // ```\n+                // pub(x) use foo::{a, b};\n+                // ```\n+                //\n+                // we will create three items:\n+                //\n+                // ```\n+                // pub(x) use foo::a;\n+                // pub(x) use foo::b;\n+                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n+                // ```\n+                //\n+                // The first two are produced by recursively invoking\n+                // `lower_use_tree` (and indeed there may be things\n+                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // wind up being directly added to\n+                // `self.items`. However, the structure of this\n+                // function also requires us to return one item, and\n+                // for that we return the `{}` import (called the\n+                // \"`ListStem`\").\n \n                 let prefix = Path {\n                     segments,\n@@ -3109,8 +3136,9 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n                             hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n                                 let id = this.next_id();\n+                                let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n-                                    path: path.clone(),\n+                                    path: path,\n                                     id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n@@ -3133,17 +3161,48 @@ impl<'a> LoweringContext<'a> {\n                     });\n                 }\n \n-                // Privatize the degenerate import base, used only to check\n-                // the stability of `use a::{};`, to avoid it showing up as\n-                // a re-export by accident when `pub`, e.g. in documentation.\n+                // Subtle and a bit hacky: we lower the privacy level\n+                // of the list stem to \"private\" most of the time, but\n+                // not for \"restricted\" paths. The key thing is that\n+                // we don't want it to stay as `pub` (with no caveats)\n+                // because that affects rustdoc and also the lints\n+                // about `pub` items. But we can't *always* make it\n+                // private -- particularly not for restricted paths --\n+                // because it contains node-ids that would then be\n+                // unused, failing the check that HirIds are \"densely\n+                // assigned\".\n+                match vis.node {\n+                    hir::VisibilityKind::Public |\n+                    hir::VisibilityKind::Crate(_) |\n+                    hir::VisibilityKind::Inherited => {\n+                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n+                    }\n+                    hir::VisibilityKind::Restricted { .. } => {\n+                        // do nothing here, as described in the comment on the match\n+                    }\n+                }\n+\n                 let def = self.expect_full_def_from_use(id).next().unwrap_or(Def::Err);\n                 let path = P(self.lower_path_extra(def, &prefix, ParamMode::Explicit, None));\n-                *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n     }\n \n+    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n+    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n+    /// node-ids. (See e.g. #56128.)\n+    fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n+        debug!(\"renumber_segment_ids(path = {:?})\", path);\n+        let mut path = path.clone();\n+        for seg in path.segments.iter_mut() {\n+            if seg.id.is_some() {\n+                seg.id = Some(self.next_id().node_id);\n+            }\n+        }\n+        path\n+    }\n+\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n         let trait_item_def_id = self.resolver.definitions().local_def_id(node_id);\n@@ -4537,6 +4596,7 @@ impl<'a> LoweringContext<'a> {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n             VisibilityKind::Restricted { ref path, id } => {\n+                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n                 let lowered_id = if let Some(owner) = explicit_owner {\n                     self.lower_node_id_with_owner(id, owner)\n                 } else {"}, {"sha": "2917fd7457acf364ca3f44a473ec1f99503d55da", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -28,6 +28,10 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHashe\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n+\n+    /// Source map\n+    source_map: &'a SourceMap,\n+\n     /// The node map\n     map: Vec<Option<Entry<'hir>>>,\n     /// The parent of this node\n@@ -54,7 +58,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n-                       hcx: StableHashingContext<'a>)\n+                       hcx: StableHashingContext<'a>,\n+                       source_map: &'a SourceMap)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n \n@@ -102,6 +107,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut collector = NodeCollector {\n             krate,\n+            source_map,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n@@ -125,7 +131,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n-                                                  source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<Option<Entry<'hir>>>, Svh)\n     {\n@@ -154,7 +159,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // If we included the full mapping in the SVH, we could only have\n         // reproducible builds by compiling from the same directory. So we just\n         // hash the result of the mapping instead of the mapping itself.\n-        let mut source_file_names: Vec<_> = source_map\n+        let mut source_file_names: Vec<_> = self\n+            .source_map\n             .files()\n             .iter()\n             .filter(|source_file| CrateNum::from_u32(source_file.crate_of_origin) == LOCAL_CRATE)\n@@ -186,7 +192,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = Some(entry);\n     }\n \n-    fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n+    fn insert(&mut self, span: Span, id: NodeId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n             dep_node: if self.currently_in_body {\n@@ -216,16 +222,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     String::new()\n                 };\n \n-                bug!(\"inconsistent DepNode for `{}`: \\\n-                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}){}\",\n+                span_bug!(\n+                    span,\n+                    \"inconsistent DepNode at `{:?}` for `{}`: \\\n+                     current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}){}\",\n+                    self.source_map.span_to_string(span),\n                     node_str,\n                     self.definitions\n                         .def_path(self.current_dep_node_owner)\n                         .to_string_no_crate(),\n                     self.current_dep_node_owner,\n                     self.definitions.def_path(hir_id.owner).to_string_no_crate(),\n                     hir_id.owner,\n-                    forgot_str)\n+                    forgot_str,\n+                )\n             }\n         }\n \n@@ -309,12 +319,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.id, Node::Item(i));\n+            this.insert(i.span, i.id, Node::Item(i));\n             this.with_parent(i.id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n-                        this.insert(struct_def.id(), Node::StructCtor(struct_def));\n+                        this.insert(i.span, struct_def.id(), Node::StructCtor(struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -323,23 +333,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.id, Node::ForeignItem(foreign_item));\n+        self.insert(foreign_item.span, foreign_item.id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.id, Node::GenericParam(param));\n+        self.insert(param.span, param.id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.id, Node::TraitItem(ti));\n+            this.insert(ti.span, ti.id, Node::TraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -351,7 +361,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.id, Node::ImplItem(ii));\n+            this.insert(ii.span, ii.id, Node::ImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -365,23 +375,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         } else {\n             Node::Pat(pat)\n         };\n-        self.insert(pat.id, node);\n+        self.insert(pat.span, pat.id, node);\n \n         self.with_parent(pat.id, |this| {\n             intravisit::walk_pat(this, pat);\n         });\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(constant.id, Node::AnonConst(constant));\n+        self.insert(DUMMY_SP, constant.id, Node::AnonConst(constant));\n \n         self.with_parent(constant.id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.id, Node::Expr(expr));\n+        self.insert(expr.span, expr.id, Node::Expr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n@@ -390,7 +400,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n-        self.insert(id, Node::Stmt(stmt));\n+        self.insert(stmt.span, id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {\n             intravisit::walk_stmt(this, stmt);\n@@ -399,21 +409,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n         if let Some(id) = path_segment.id {\n-            self.insert(id, Node::PathSegment(path_segment));\n+            self.insert(path_span, id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.id, Node::Ty(ty));\n+        self.insert(ty.span, ty.id, Node::Ty(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.ref_id, Node::TraitRef(tr));\n+        self.insert(tr.path.span, tr.ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -427,21 +437,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.id, Node::Block(block));\n+        self.insert(block.span, block.id, Node::Block(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.id, Node::Local(l));\n+        self.insert(l.span, l.id, Node::Local(l));\n         self.with_parent(l.id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.span, lifetime.id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -450,7 +460,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, .. } => {\n-                self.insert(id, Node::Visibility(visibility));\n+                self.insert(visibility.span, id, Node::Visibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -462,20 +472,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.id, Node::MacroDef(macro_def));\n+            this.insert(macro_def.span, macro_def.id, Node::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n-        self.insert(id, Node::Variant(v));\n+        self.insert(v.span, id, Node::Variant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.id, Node::Field(field));\n+        self.insert(field.span, field.id, Node::Field(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "eb9bd183fd939a12d8defaa5240d64f4f3d716eb", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -36,6 +36,7 @@ use util::nodemap::NodeMap;\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n /// stores the DefIndex of its parent.\n /// There is one DefPathTable for each crate.\n+#[derive(Default)]\n pub struct DefPathTable {\n     index_to_key: [Vec<DefKey>; 2],\n     def_path_hashes: [Vec<DefPathHash>; 2],\n@@ -153,7 +154,7 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n@@ -412,20 +413,8 @@ impl Definitions {\n     ///     ascending order.\n     ///\n     /// FIXME: there is probably a better place to put this comment.\n-    pub fn new() -> Definitions {\n-        Definitions {\n-            table: DefPathTable {\n-                index_to_key: [vec![], vec![]],\n-                def_path_hashes: [vec![], vec![]],\n-            },\n-            node_to_def_index: NodeMap(),\n-            def_index_to_node: [vec![], vec![]],\n-            node_to_hir_id: IndexVec::new(),\n-            parent_modules_of_macro_defs: Default::default(),\n-            expansions_that_defined: Default::default(),\n-            next_disambiguator: Default::default(),\n-            def_index_to_span: Default::default(),\n-        }\n+    pub fn new() -> Self {\n+        Self::default()\n     }\n \n     pub fn def_path_table(&self) -> &DefPathTable {"}, {"sha": "ef777abfbc41aa1780d132895682adef63b06b82", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1032,14 +1032,14 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let mut collector = NodeCollector::root(&forest.krate,\n                                                 &forest.dep_graph,\n                                                 &definitions,\n-                                                hcx);\n+                                                hcx,\n+                                                sess.source_map());\n         intravisit::walk_crate(&mut collector, &forest.krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n-                                                  sess.source_map(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "7c623a1874e7b4cc7bbf51b05d19eab57294652c", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -369,8 +369,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n             // times, we cache a stable hash of it and hash that instead of\n             // recursing every time.\n             thread_local! {\n-                static CACHE: RefCell<FxHashMap<hygiene::Mark, u64>> =\n-                    RefCell::new(Default::default());\n+                static CACHE: RefCell<FxHashMap<hygiene::Mark, u64>> = Default::default();\n             }\n \n             let sub_hash: u64 = CACHE.with(|cache| {"}, {"sha": "679107160a6fc4a4785d6aea8639d401363cdd4a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -317,6 +317,10 @@ impl_stable_hash_for!(\n         ByRef(id, alloc, offset),\n     }\n );\n+impl_stable_hash_for!(struct ::mir::interpret::RawConst<'tcx> {\n+    alloc_id,\n+    ty,\n+});\n \n impl_stable_hash_for! {\n     impl<Tag> for struct mir::interpret::Pointer<Tag> {"}, {"sha": "fda9817cc88ae0c621b681b844b15ccade8e6062", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             parent_def_id,\n             body_id,\n             param_env,\n-            opaque_types: DefIdMap(),\n+            opaque_types: Default::default(),\n             obligations: vec![],\n         };\n         let value = instantiator.instantiate_opaque_types_in_map(value);"}, {"sha": "391bfc428c3bb49696f288a30456ee7a1e1627f6", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -29,6 +29,7 @@ use std::{cmp, fmt, mem, u32};\n \n mod taint;\n \n+#[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n     var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n@@ -341,17 +342,8 @@ impl TaintDirections {\n }\n \n impl<'tcx> RegionConstraintCollector<'tcx> {\n-    pub fn new() -> RegionConstraintCollector<'tcx> {\n-        RegionConstraintCollector {\n-            var_infos: VarInfos::default(),\n-            data: RegionConstraintData::default(),\n-            lubs: Default::default(),\n-            glbs: Default::default(),\n-            bound_count: 0,\n-            undo_log: Vec::new(),\n-            unification_table: ut::UnificationTable::new(),\n-            any_unifications: false,\n-        }\n+    pub fn new() -> Self {\n+        Self::default()\n     }\n \n     pub fn num_region_vars(&self) -> usize {"}, {"sha": "22f2023eefbd874693121105c5deefbe6a9c39e8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -318,6 +318,12 @@ declare_lint! {\n     \"warn about missing code example in an item's documentation\"\n }\n \n+declare_lint! {\n+    pub PRIVATE_DOC_TESTS,\n+    Allow,\n+    \"warn about doc test in private item\"\n+}\n+\n declare_lint! {\n     pub WHERE_CLAUSES_OBJECT_SAFETY,\n     Warn,\n@@ -415,6 +421,7 @@ impl LintPass for HardwiredLints {\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             MISSING_DOC_CODE_EXAMPLES,\n+            PRIVATE_DOC_TESTS,\n             WHERE_CLAUSES_OBJECT_SAFETY,\n             PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n             MACRO_USE_EXTERN_CRATE,"}, {"sha": "469d77403a3d82ae45faf16115eea847b7422bce", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1233,7 +1233,7 @@ pub fn check_ast_crate(\n     let (passes, buffered) = if pre_expansion {\n         (\n             sess.lint_store.borrow_mut().pre_expansion_passes.take(),\n-            LintBuffer::new(),\n+            LintBuffer::default(),\n         )\n     } else {\n         ("}, {"sha": "4b878b862526bde194af600cec2bfacc542cbcf7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -490,15 +490,12 @@ mod levels;\n \n pub use self::levels::{LintLevelSets, LintLevelMap};\n \n+#[derive(Default)]\n pub struct LintBuffer {\n     map: NodeMap<Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {\n-    pub fn new() -> LintBuffer {\n-        LintBuffer { map: NodeMap() }\n-    }\n-\n     pub fn add_lint(&mut self,\n                     lint: &'static Lint,\n                     id: ast::NodeId,"}, {"sha": "633c58413780644ddf52d90ba6b7e55759cc5480", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -18,9 +18,15 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum SignalledError { SawSomeError, NoErrorsSeen }\n \n+impl Default for SignalledError {\n+    fn default() -> SignalledError {\n+        SignalledError::NoErrorsSeen\n+    }\n+}\n+\n impl_stable_hash_for!(enum self::SignalledError { SawSomeError, NoErrorsSeen });\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct BorrowCheckResult {\n     pub used_mut_nodes: FxHashSet<HirId>,\n     pub signalled_any_error: SignalledError,"}, {"sha": "54a0192d2e8a541376026c670de2d240ff04c01b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -272,9 +272,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             tcx,\n             num_live_nodes: 0,\n             num_vars: 0,\n-            live_node_map: HirIdMap(),\n-            variable_map: HirIdMap(),\n-            capture_info_map: NodeMap(),\n+            live_node_map: HirIdMap::default(),\n+            variable_map: HirIdMap::default(),\n+            capture_info_map: Default::default(),\n             var_kinds: Vec::new(),\n             lnks: Vec::new(),\n         }\n@@ -397,7 +397,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n-    let mut shorthand_field_ids = HirIdSet();\n+    let mut shorthand_field_ids = HirIdSet::default();\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n@@ -691,8 +691,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n-            break_ln: NodeMap(),\n-            cont_ln: NodeMap(),\n+            break_ln: Default::default(),\n+            cont_ln: Default::default(),\n         }\n     }\n "}, {"sha": "0009a517dd1dba50232f940e451c42ed32c879b9", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -408,7 +408,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     let mut reachable_context = ReachableContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n-        reachable_symbols: NodeSet(),\n+        reachable_symbols: Default::default(),\n         worklist: Vec::new(),\n         any_library,\n     };"}, {"sha": "6ff450508d13641a36d9de750e882e3de55c83ba", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -425,8 +425,8 @@ fn resolve_lifetimes<'tcx>(\n fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n     let krate = tcx.hir.krate();\n     let mut map = NamedRegionMap {\n-        defs: NodeMap(),\n-        late_bound: NodeSet(),\n+        defs: Default::default(),\n+        late_bound: Default::default(),\n         object_lifetime_defaults: compute_object_lifetime_defaults(tcx),\n     };\n     {\n@@ -437,8 +437,8 @@ fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n             trait_ref_hack: false,\n             is_in_fn_syntax: false,\n             labels_in_fn: vec![],\n-            xcrate_object_lifetime_defaults: DefIdMap(),\n-            lifetime_uses: &mut DefIdMap(),\n+            xcrate_object_lifetime_defaults: Default::default(),\n+            lifetime_uses: &mut Default::default(),\n         };\n         for (_, item) in &krate.items {\n             visitor.visit_item(item);\n@@ -1278,7 +1278,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n fn compute_object_lifetime_defaults(\n     tcx: TyCtxt<'_, '_, '_>,\n ) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n-    let mut map = NodeMap();\n+    let mut map = NodeMap::default();\n     for item in tcx.hir.krate().items.values() {\n         match item.node {\n             hir::ItemKind::Struct(_, ref generics)\n@@ -1432,7 +1432,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         } = self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let xcrate_object_lifetime_defaults =\n-            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n+            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap::default());\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map: map,\n@@ -2741,9 +2741,7 @@ fn insert_late_bound_lifetimes(\n         constrained_by_input.visit_ty(arg_ty);\n     }\n \n-    let mut appears_in_output = AllCollector {\n-        regions: Default::default(),\n-    };\n+    let mut appears_in_output = AllCollector::default();\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n     debug!(\n@@ -2755,9 +2753,7 @@ fn insert_late_bound_lifetimes(\n     //\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n-    let mut appears_in_where_clause = AllCollector {\n-        regions: Default::default(),\n-    };\n+    let mut appears_in_where_clause = AllCollector::default();\n     appears_in_where_clause.visit_generics(generics);\n \n     for param in &generics.params {\n@@ -2854,6 +2850,7 @@ fn insert_late_bound_lifetimes(\n         }\n     }\n \n+    #[derive(Default)]\n     struct AllCollector {\n         regions: FxHashSet<hir::LifetimeName>,\n     }"}, {"sha": "3250ea266a5872310ff75fc5e2f3845bb2156549", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -104,7 +104,7 @@ impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n     }\n \n     pub fn from_byte_aligned_bytes(slice: &[u8]) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1, 1).unwrap())\n+        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n     }\n \n     pub fn undef(size: Size, align: Align) -> Self {"}, {"sha": "7477343891e205abe1a58368e6d0416539268370", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::{Pointer, InboundsCheck, ScalarMaybeUndef};\n+use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n@@ -46,6 +46,7 @@ impl ErrorHandled {\n     }\n }\n \n+pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n@@ -526,7 +527,7 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             AlignmentCheckFailed { required, has } =>\n                write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n-                      has.abi(), required.abi()),\n+                      has.bytes(), required.bytes()),\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n             Layout(ref err) =>\n@@ -536,8 +537,9 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n             MachineError(ref inner) =>\n                 write!(f, \"{}\", inner),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n-                write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and \\\n-                       align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n+                write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n+                           got size {} and align {}\",\n+                    size.bytes(), align.bytes(), size2.bytes(), align2.bytes()),\n             Panic { ref msg, line, col, ref file } =>\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col),\n             InvalidDiscriminant(val) =>"}, {"sha": "9369b6e56f1d018f3992c096ccc648da1dedcc62", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -22,10 +22,10 @@ mod pointer;\n \n pub use self::error::{\n     EvalError, EvalResult, EvalErrorKind, AssertMessage, ConstEvalErr, struct_error,\n-    FrameInfo, ConstEvalResult, ErrorHandled,\n+    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n };\n \n-pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n+pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};\n \n pub use self::allocation::{\n     InboundsCheck, Allocation, AllocationExtra,"}, {"sha": "4bcba9d54674e3f7f610b59ab4bfaa2c26170b01", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -10,19 +10,28 @@\n \n use std::fmt;\n \n-use ty::layout::{HasDataLayout, Size};\n-use ty::subst::Substs;\n-use hir::def_id::DefId;\n+use crate::ty::{Ty, subst::Substs, layout::{HasDataLayout, Size}};\n+use crate::hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n+/// Represents the result of a raw const operation, pre-validation.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct RawConst<'tcx> {\n+    // the value lives here, at offset 0, and that allocation definitely is a `AllocType::Memory`\n+    // (so you can use `AllocMap::unwrap_memory`).\n+    pub alloc_id: AllocId,\n+    pub ty: Ty<'tcx>,\n+}\n+\n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Never returned from the `const_eval` query, but the HIR contains these frequently in order\n     /// to allow HIR creation to happen for everything before needing to be able to run constant\n     /// evaluation\n+    /// FIXME: The query should then return a type that does not even have this variant.\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n \n     /// Used only for types with layout::abi::Scalar ABI and ZSTs"}, {"sha": "b8f5ce3cdbc7c924f259bb1102c1446bc064a65e", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -71,7 +71,7 @@ impl CodeStats {\n         let info = TypeSizeInfo {\n             kind,\n             type_description: type_desc.to_string(),\n-            align: align.abi(),\n+            align: align.bytes(),\n             overall_size: overall_size.bytes(),\n             packed: packed,\n             opt_discr_size: opt_discr_size.map(|s| s.bytes()),"}, {"sha": "c620e092f36ca20e11976f793dae0c75b2abb122", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -802,7 +802,7 @@ macro_rules! options {\n         pub const parse_opt_uint: Option<&'static str> =\n             Some(\"a number\");\n         pub const parse_panic_strategy: Option<&'static str> =\n-            Some(\"either `panic` or `abort`\");\n+            Some(\"either `unwind` or `abort`\");\n         pub const parse_relro_level: Option<&'static str> =\n             Some(\"one of: `full`, `partial`, or `off`\");\n         pub const parse_sanitizer: Option<&'static str> ="}, {"sha": "d688d93b80842c6734841c7b4951b2bb7db6460a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1149,7 +1149,7 @@ pub fn build_session_(\n         local_crate_source_file,\n         working_dir,\n         lint_store: RwLock::new(lint::LintStore::new()),\n-        buffered_lints: Lock::new(Some(lint::LintBuffer::new())),\n+        buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n         plugin_attributes: OneThread::new(RefCell::new(Vec::new())),"}, {"sha": "48b2b25d6adf917d54a244cf70c24dfbb1dcd254", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1092,13 +1092,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if let Some(found_span) = found_span {\n             err.span_label(found_span, format!(\"takes {}\", found_str));\n \n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span = if let Some(span) = found_span.trim_start(prefix_span) {\n+                span\n+            } else {\n+                found_span\n+            };\n+\n             // Suggest to take and ignore the arguments with expected_args_length `_`s if\n             // found arguments is empty (assume the user just wants to ignore args in this case).\n             // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n             if found_args.is_empty() && is_closure {\n                 let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n                 err.span_suggestion_with_applicability(\n-                    found_span,\n+                    pipe_span,\n                     &format!(\n                         \"consider changing the closure to take and ignore the expected argument{}\",\n                         if expected_args.len() < 2 {"}, {"sha": "a8ce52a8e156ce676a49edb458295536eda9ec4e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -446,22 +446,22 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn empty(local_id_root: Option<DefId>) -> TypeckTables<'tcx> {\n         TypeckTables {\n             local_id_root,\n-            type_dependent_defs: ItemLocalMap(),\n-            field_indices: ItemLocalMap(),\n-            user_provided_tys: ItemLocalMap(),\n+            type_dependent_defs: Default::default(),\n+            field_indices: Default::default(),\n+            user_provided_tys: Default::default(),\n             user_provided_sigs: Default::default(),\n-            node_types: ItemLocalMap(),\n-            node_substs: ItemLocalMap(),\n-            user_substs: ItemLocalMap(),\n-            adjustments: ItemLocalMap(),\n-            pat_binding_modes: ItemLocalMap(),\n-            pat_adjustments: ItemLocalMap(),\n+            node_types: Default::default(),\n+            node_substs: Default::default(),\n+            user_substs: Default::default(),\n+            adjustments: Default::default(),\n+            pat_binding_modes: Default::default(),\n+            pat_adjustments: Default::default(),\n             upvar_capture_map: Default::default(),\n-            closure_kind_origins: ItemLocalMap(),\n-            liberated_fn_sigs: ItemLocalMap(),\n-            fru_field_types: ItemLocalMap(),\n-            cast_kinds: ItemLocalMap(),\n-            used_trait_imports: Lrc::new(DefIdSet()),\n+            closure_kind_origins: Default::default(),\n+            liberated_fn_sigs: Default::default(),\n+            fru_field_types: Default::default(),\n+            cast_kinds: Default::default(),\n+            used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: false,\n             free_region_map: Default::default(),\n             concrete_existential_types: Default::default(),"}, {"sha": "da0a9acede20e690f7ce6227b96186b86f8ab37a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -226,9 +226,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             tcx.intern_layout(LayoutDetails::scalar(self, scalar_unit(value)))\n         };\n         let scalar_pair = |a: Scalar, b: Scalar| {\n-            let align = a.value.align(dl).max(b.value.align(dl)).max(dl.aggregate_align);\n-            let b_offset = a.value.size(dl).abi_align(b.value.align(dl));\n-            let size = (b_offset + b.value.size(dl)).abi_align(align);\n+            let b_align = b.value.align(dl);\n+            let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n+            let b_offset = a.value.size(dl).align_to(b_align.abi);\n+            let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n             LayoutDetails {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldPlacement::Arbitrary {\n@@ -257,10 +258,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 bug!(\"struct cannot be packed and aligned\");\n             }\n \n-            let pack = {\n-                let pack = repr.pack as u64;\n-                Align::from_bytes(pack, pack).unwrap()\n-            };\n+            let pack = Align::from_bytes(repr.pack as u64).unwrap();\n \n             let mut align = if packed {\n                 dl.i8_align\n@@ -274,7 +272,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n             if let StructKind::Prefixed(_, align) = kind {\n-                optimize &= align.abi() == 1;\n+                optimize &= align.bytes() == 1;\n             }\n \n             if optimize {\n@@ -285,7 +283,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 };\n                 let optimizing = &mut inverse_memory_index[..end];\n                 let field_align = |f: &TyLayout<'_>| {\n-                    if packed { f.align.min(pack).abi() } else { f.align.abi() }\n+                    if packed { f.align.abi.min(pack) } else { f.align.abi }\n                 };\n                 match kind {\n                     StructKind::AlwaysSized |\n@@ -312,13 +310,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let mut offset = Size::ZERO;\n \n             if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-                if packed {\n-                    let prefix_align = prefix_align.min(pack);\n-                    align = align.max(prefix_align);\n+                let prefix_align = if packed {\n+                    prefix_align.min(pack)\n                 } else {\n-                    align = align.max(prefix_align);\n-                }\n-                offset = prefix_size.abi_align(prefix_align);\n+                    prefix_align\n+                };\n+                align = align.max(AbiAndPrefAlign::new(prefix_align));\n+                offset = prefix_size.align_to(prefix_align);\n             }\n \n             for &i in &inverse_memory_index {\n@@ -333,15 +331,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-                if packed {\n-                    let field_pack = field.align.min(pack);\n-                    offset = offset.abi_align(field_pack);\n-                    align = align.max(field_pack);\n-                }\n-                else {\n-                    offset = offset.abi_align(field.align);\n-                    align = align.max(field.align);\n-                }\n+                let field_align = if packed {\n+                    field.align.min(AbiAndPrefAlign::new(pack))\n+                } else {\n+                    field.align\n+                };\n+                offset = offset.align_to(field_align.abi);\n+                align = align.max(field_align);\n \n                 debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n                 offsets[i as usize] = offset;\n@@ -352,7 +348,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             if repr.align > 0 {\n                 let repr_align = repr.align as u64;\n-                align = align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+                align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n                 debug!(\"univariant repr_align: {:?}\", repr_align);\n             }\n \n@@ -377,7 +373,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 memory_index = inverse_memory_index;\n             }\n \n-            let size = min_size.abi_align(align);\n+            let size = min_size.align_to(align.abi);\n             let mut abi = Abi::Aggregate { sized };\n \n             // Unpack newtype ABIs and find scalar pairs.\n@@ -394,7 +390,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         (Some((i, field)), None, None) => {\n                             // Field fills the struct and it has a scalar or scalar pair ABI.\n                             if offsets[i].bytes() == 0 &&\n-                               align.abi() == field.align.abi() &&\n+                               align.abi == field.align.abi &&\n                                size == field.size {\n                                 match field.abi {\n                                     // For plain scalars, or vectors of them, we can't unpack\n@@ -648,7 +644,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n                 let align = dl.vector_align(size);\n-                let size = size.abi_align(align);\n+                let size = size.align_to(align.abi);\n \n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n@@ -680,10 +676,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         bug!(\"Union cannot be packed and aligned\");\n                     }\n \n-                    let pack = {\n-                        let pack = def.repr.pack as u64;\n-                        Align::from_bytes(pack, pack).unwrap()\n-                    };\n+                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n \n                     let mut align = if packed {\n                         dl.i8_align\n@@ -694,7 +687,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if def.repr.align > 0 {\n                         let repr_align = def.repr.align as u64;\n                         align = align.max(\n-                            Align::from_bytes(repr_align, repr_align).unwrap());\n+                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -704,12 +697,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n \n-                        if packed {\n-                            let field_pack = field.align.min(pack);\n-                            align = align.max(field_pack);\n+                        let field_align = if packed {\n+                            field.align.min(AbiAndPrefAlign::new(pack))\n                         } else {\n-                            align = align.max(field.align);\n-                        }\n+                            field.align\n+                        };\n+                        align = align.max(field_align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -749,7 +742,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         fields: FieldPlacement::Union(variants[index].len()),\n                         abi,\n                         align,\n-                        size: size.abi_align(align)\n+                        size: size.align_to(align.abi)\n                     }));\n                 }\n \n@@ -964,19 +957,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let mut size = Size::ZERO;\n \n                 // We're interested in the smallest alignment, so start large.\n-                let mut start_align = Align::from_bytes(256, 256).unwrap();\n-                assert_eq!(Integer::for_abi_align(dl, start_align), None);\n+                let mut start_align = Align::from_bytes(256).unwrap();\n+                assert_eq!(Integer::for_align(dl, start_align), None);\n \n                 // repr(C) on an enum tells us to make a (tag, union) layout,\n                 // so we need to grow the prefix alignment to be at least\n                 // the alignment of the union. (This value is used both for\n                 // determining the alignment of the overall enum, and the\n                 // determining the alignment of the payload after the tag.)\n-                let mut prefix_align = min_ity.align(dl);\n+                let mut prefix_align = min_ity.align(dl).abi;\n                 if def.repr.c() {\n                     for fields in &variants {\n                         for field in fields {\n-                            prefix_align = prefix_align.max(field.align);\n+                            prefix_align = prefix_align.max(field.align.abi);\n                         }\n                     }\n                 }\n@@ -989,8 +982,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     for field in st.fields.index_by_increasing_offset().map(|j| field_layouts[j]) {\n-                        if !field.is_zst() || field.align.abi() != 1 {\n-                            start_align = start_align.min(field.align);\n+                        if !field.is_zst() || field.align.abi.bytes() != 1 {\n+                            start_align = start_align.min(field.align.abi);\n                             break;\n                         }\n                     }\n@@ -1000,7 +993,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 // Align the maximum variant size to the largest alignment.\n-                size = size.abi_align(align);\n+                size = size.align_to(align.abi);\n \n                 if size.bytes() >= dl.obj_size_bound() {\n                     return Err(LayoutError::SizeOverflow(ty));\n@@ -1036,7 +1029,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let mut ity = if def.repr.c() || def.repr.int.is_some() {\n                     min_ity\n                 } else {\n-                    Integer::for_abi_align(dl, start_align).unwrap_or(min_ity)\n+                    Integer::for_align(dl, start_align).unwrap_or(min_ity)\n                 };\n \n                 // If the alignment is not larger than the chosen discriminant size,\n@@ -1204,7 +1197,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let type_desc = format!(\"{:?}\", layout.ty);\n             self.tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n                                                                    type_desc,\n-                                                                   layout.align,\n+                                                                   layout.align.abi,\n                                                                    layout.size,\n                                                                    packed,\n                                                                    opt_discr_size,\n@@ -1251,7 +1244,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             name: name.to_string(),\n                             offset: offset.bytes(),\n                             size: field_layout.size.bytes(),\n-                            align: field_layout.align.abi(),\n+                            align: field_layout.align.abi.bytes(),\n                         }\n                     }\n                 }\n@@ -1264,7 +1257,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 } else {\n                     session::SizeKind::Exact\n                 },\n-                align: layout.align.abi(),\n+                align: layout.align.abi.bytes(),\n                 size: if min_size.bytes() == 0 {\n                     layout.size.bytes()\n                 } else {\n@@ -1823,7 +1816,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             Abi::ScalarPair(ref a, ref b) => {\n                 // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n                 // returns the last maximum.\n-                let niche = iter::once((b, a.value.size(self).abi_align(b.value.align(self))))\n+                let niche = iter::once(\n+                    (b, a.value.size(self).align_to(b.value.align(self).abi))\n+                )\n                     .chain(iter::once((a, Size::ZERO)))\n                     .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n                     .max_by_key(|niche| niche.available);\n@@ -1994,12 +1989,16 @@ impl_stable_hash_for!(enum ::ty::layout::Primitive {\n     Pointer\n });\n \n+impl_stable_hash_for!(struct ::ty::layout::AbiAndPrefAlign {\n+    abi,\n+    pref\n+});\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for Align {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        self.abi().hash_stable(hcx, hasher);\n-        self.pref().hash_stable(hcx, hasher);\n+        self.bytes().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "ad200449f8907dda9adb00be03bb31e0b7044499", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -3183,7 +3183,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// rather, you should request the vector for a specific type via\n /// `tcx.inherent_impls(def_id)` so as to minimize your dependencies\n /// (constructing this map requires touching the entire crate).\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Default)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }"}, {"sha": "22bd1e26ba3eea36d86e2e30da850cbd1c44b178", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -27,7 +27,7 @@ use middle::stability::{self, DeprecationEntry};\n use middle::lib_features::LibFeatures;\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n-use mir::interpret::ConstEvalResult;\n+use mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n use mir::mono::CodegenUnit;\n use mir;\n use mir::interpret::GlobalId;\n@@ -309,7 +309,7 @@ define_queries! { <'tcx>\n         /// validation. Please add a comment to every use site explaining why using `const_eval`\n         /// isn't sufficient\n         [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalResult<'tcx>,\n+            -> ConstEvalRawResult<'tcx>,\n \n         /// Results of evaluating const items or constants embedded in\n         /// other items (such as enum variant explicit discriminants)."}, {"sha": "6adfe2cde6c3b227078102eb45733f01046863a8", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -10,8 +10,6 @@\n \n //! An efficient hash map for node IDs\n \n-#![allow(non_snake_case)]\n-\n use hir::def_id::DefId;\n use hir::{HirId, ItemLocalId};\n use syntax::ast;\n@@ -22,9 +20,7 @@ pub use rustc_data_structures::fx::FxHashSet;\n macro_rules! define_id_collections {\n     ($map_name:ident, $set_name:ident, $key:ty) => {\n         pub type $map_name<T> = FxHashMap<$key, T>;\n-        pub fn $map_name<T>() -> $map_name<T> { Default::default() }\n         pub type $set_name = FxHashSet<$key>;\n-        pub fn $set_name() -> $set_name { Default::default() }\n     }\n }\n "}, {"sha": "3470d6fd0e72a57fc76b2bc374cfef2241c9506e", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -73,7 +73,7 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentAttr(llfn,\n                                                idx.as_uint(),\n-                                               align.abi() as u32);\n+                                               align.bytes() as u32);\n             }\n             regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n         }\n@@ -98,7 +98,7 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentCallSiteAttr(callsite,\n                                                        idx.as_uint(),\n-                                                       align.abi() as u32);\n+                                                       align.bytes() as u32);\n             }\n             regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n         }\n@@ -204,7 +204,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             return;\n         }\n         if self.is_sized_indirect() {\n-            OperandValue::Ref(val, None, self.layout.align).store(bx, dst)\n+            OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized ArgType must be handled through store_fn_arg\");\n         } else if let PassMode::Cast(cast) = self.mode {\n@@ -214,7 +214,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             if can_store_through_cast_ptr {\n                 let cast_ptr_llty = bx.cx().type_ptr_to(cast.llvm_type(bx.cx()));\n                 let cast_dst = bx.pointercast(dst.llval, cast_ptr_llty);\n-                bx.store(val, cast_dst, self.layout.align);\n+                bx.store(val, cast_dst, self.layout.align.abi);\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -242,7 +242,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // ...and then memcpy it to the intended destination.\n                 bx.memcpy(\n                     dst.llval,\n-                    self.layout.align,\n+                    self.layout.align.abi,\n                     llscratch,\n                     scratch_align,\n                     bx.cx().const_usize(self.layout.size.bytes()),\n@@ -273,7 +273,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n             PassMode::Indirect(_, Some(_)) => {\n-                OperandValue::Ref(next(), Some(next()), self.layout.align).store(bx, dst);\n+                OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             }\n             PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n                 self.store(bx, next(), dst);\n@@ -545,7 +545,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     adjust_for_rust_scalar(&mut b_attrs,\n                                            b,\n                                            arg.layout,\n-                                           a.value.size(cx).abi_align(b.value.align(cx)),\n+                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n                                            false);\n                     arg.mode = PassMode::Pair(a_attrs, b_attrs);\n                     return arg;"}, {"sha": "d2a99eae3406f969bfe705636f96daeb4b892131", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -475,7 +475,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty,\n                                       name.as_ptr())\n             };\n-            llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n+            llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n     }\n@@ -494,7 +494,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n                                            name.as_ptr())\n             };\n-            llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n+            llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n     }\n@@ -503,7 +503,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n+            llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n             load\n         }\n     }\n@@ -658,7 +658,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let align = if flags.contains(MemFlags::UNALIGNED) {\n                 1\n             } else {\n-                align.abi() as c_uint\n+                align.bytes() as c_uint\n             };\n             llvm::LLVMSetAlignment(store, align);\n             if flags.contains(MemFlags::VOLATILE) {\n@@ -893,8 +893,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let dst = self.pointercast(dst, self.cx().type_i8p());\n         let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align.abi() as c_uint,\n-                                      src, src_align.abi() as c_uint, size, is_volatile);\n+            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align.bytes() as c_uint,\n+                                      src, src_align.bytes() as c_uint, size, is_volatile);\n         }\n     }\n \n@@ -913,8 +913,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let dst = self.pointercast(dst, self.cx().type_i8p());\n         let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align.abi() as c_uint,\n-                                      src, src_align.abi() as c_uint, size, is_volatile);\n+            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align.bytes() as c_uint,\n+                                      src, src_align.bytes() as c_uint, size, is_volatile);\n         }\n     }\n \n@@ -930,7 +930,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n         let llintrinsicfn = self.cx().get_intrinsic(&intrinsic_key);\n         let ptr = self.pointercast(ptr, self.cx().type_i8p());\n-        let align = self.cx().const_u32(align.abi() as u32);\n+        let align = self.cx().const_u32(align.bytes() as u32);\n         let volatile = self.cx().const_bool(flags.contains(MemFlags::VOLATILE));\n         self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n     }"}, {"sha": "cd74a5854a926e5a8c024c8155cf1c0ce195ac13", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -357,7 +357,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, layout.align, None);\n+        let base_addr = self.static_addr_of(init, layout.align.abi, None);\n \n         let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n             self.static_bitcast(base_addr, self.type_i8p()),"}, {"sha": "07dde2d0301fe72ee1691fd958660d650525f234", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -94,15 +94,15 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n     if let Some(min) = cx.sess().target.target.options.min_global_align {\n-        match ty::layout::Align::from_bits(min, min) {\n+        match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n                 cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n             }\n         }\n     }\n     unsafe {\n-        llvm::LLVMSetAlignment(gv, align.abi() as u32);\n+        llvm::LLVMSetAlignment(gv, align.bytes() as u32);\n     }\n }\n \n@@ -219,7 +219,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             unsafe {\n                 // Upgrade the alignment in cases where the same constant is used with different\n                 // alignment requirements\n-                let llalign = align.abi() as u32;\n+                let llalign = align.bytes() as u32;\n                 if llalign > llvm::LLVMGetAlignment(gv) {\n                     llvm::LLVMSetAlignment(gv, llalign);\n                 }"}, {"sha": "81f2769800d2f190a96a4d7d8ceb4594fcccbf91", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -323,7 +323,7 @@ fn fixed_vec_metadata(\n         llvm::LLVMRustDIBuilderCreateArrayType(\n             DIB(cx),\n             size.bits(),\n-            align.abi_bits() as u32,\n+            align.bits() as u32,\n             element_type_metadata,\n             subscripts)\n     };\n@@ -465,7 +465,7 @@ fn trait_pointer_metadata(\n                 syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n-            align: data_ptr_field.align,\n+            align: data_ptr_field.align.abi,\n             flags: DIFlags::FlagArtificial,\n             discriminant: None,\n         },\n@@ -474,7 +474,7 @@ fn trait_pointer_metadata(\n             type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(1),\n             size: vtable_field.size,\n-            align: vtable_field.align,\n+            align: vtable_field.align.abi,\n             flags: DIFlags::FlagArtificial,\n             discriminant: None,\n         },\n@@ -787,7 +787,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n             DIB(cx),\n             name.as_ptr(),\n             size.bits(),\n-            align.abi_bits() as u32,\n+            align.bits() as u32,\n             encoding)\n     };\n \n@@ -818,7 +818,7 @@ fn pointer_type_metadata(\n             DIB(cx),\n             pointee_type_metadata,\n             pointer_size.bits(),\n-            pointer_align.abi_bits() as u32,\n+            pointer_align.bits() as u32,\n             name.as_ptr())\n     }\n }\n@@ -985,13 +985,12 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 f.ident.to_string()\n             };\n             let field = layout.field(cx, i);\n-            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name,\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: layout.fields.offset(i),\n-                size,\n-                align,\n+                size: field.size,\n+                align: field.align.abi,\n                 flags: DIFlags::FlagZero,\n                 discriminant: None,\n             }\n@@ -1109,13 +1108,12 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                                   -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n-            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name: f.ident.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: Size::ZERO,\n-                size,\n-                align,\n+                size: field.size,\n+                align: field.align.abi,\n                 flags: DIFlags::FlagZero,\n                 discriminant: None,\n             }\n@@ -1228,7 +1226,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n-                        align: self.layout.align,\n+                        align: self.layout.align.abi,\n                         flags: DIFlags::FlagZero,\n                         discriminant: None,\n                     }\n@@ -1267,7 +1265,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n-                        align: self.layout.align,\n+                        align: self.layout.align.abi,\n                         flags: DIFlags::FlagZero,\n                         discriminant: Some(self.layout.ty.ty_adt_def().unwrap()\n                                            .discriminant_for_variant(cx.tcx, i)\n@@ -1336,7 +1334,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             type_metadata: variant_type_metadata,\n                             offset: Size::ZERO,\n                             size: variant.size,\n-                            align: variant.align,\n+                            align: variant.align.abi,\n                             flags: DIFlags::FlagZero,\n                             discriminant: None,\n                         }\n@@ -1374,7 +1372,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             type_metadata: variant_type_metadata,\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n-                            align: self.layout.align,\n+                            align: self.layout.align.abi,\n                             flags: DIFlags::FlagZero,\n                             discriminant: niche_value,\n                         }\n@@ -1565,7 +1563,7 @@ fn prepare_enum_metadata(\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         discriminant_size.bits(),\n-                        discriminant_align.abi_bits() as u32,\n+                        discriminant_align.abi.bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n                         discriminant_base_type_metadata, true)\n                 };\n@@ -1587,8 +1585,6 @@ fn prepare_enum_metadata(\n         _ => {}\n     }\n \n-    let (enum_type_size, enum_type_align) = layout.size_and_align();\n-\n     let enum_name = SmallCStr::new(&enum_name);\n     let unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n@@ -1610,8 +1606,8 @@ fn prepare_enum_metadata(\n                 enum_name.as_ptr(),\n                 file_metadata,\n                 UNKNOWN_LINE_NUMBER,\n-                enum_type_size.bits(),\n-                enum_type_align.abi_bits() as u32,\n+                layout.size.bits(),\n+                layout.align.abi.bits() as u32,\n                 DIFlags::FlagZero,\n                 None,\n                 0, // RuntimeLang\n@@ -1659,7 +1655,7 @@ fn prepare_enum_metadata(\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n-                    align.abi_bits() as u32,\n+                    align.abi.bits() as u32,\n                     layout.fields.offset(0).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata))\n@@ -1679,7 +1675,7 @@ fn prepare_enum_metadata(\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n-                    align.abi_bits() as u32,\n+                    align.bits() as u32,\n                     layout.fields.offset(0).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata))\n@@ -1695,8 +1691,8 @@ fn prepare_enum_metadata(\n             ptr::null_mut(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n-            enum_type_size.bits(),\n-            enum_type_align.abi_bits() as u32,\n+            layout.size.bits(),\n+            layout.align.abi.bits() as u32,\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n@@ -1712,8 +1708,8 @@ fn prepare_enum_metadata(\n             enum_name.as_ptr(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n-            enum_type_size.bits(),\n-            enum_type_align.abi_bits() as u32,\n+            layout.size.bits(),\n+            layout.align.abi.bits() as u32,\n             DIFlags::FlagZero,\n             None,\n             type_array,\n@@ -1807,7 +1803,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     unknown_file_metadata(cx),\n                     UNKNOWN_LINE_NUMBER,\n                     member_description.size.bits(),\n-                    member_description.align.abi_bits() as u32,\n+                    member_description.align.bits() as u32,\n                     member_description.offset.bits(),\n                     match member_description.discriminant {\n                         None => None,\n@@ -1855,7 +1851,7 @@ fn create_struct_stub(\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             struct_size.bits(),\n-            struct_align.abi_bits() as u32,\n+            struct_align.bits() as u32,\n             DIFlags::FlagZero,\n             None,\n             empty_array,\n@@ -1893,7 +1889,7 @@ fn create_union_stub(\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             union_size.bits(),\n-            union_align.abi_bits() as u32,\n+            union_align.bits() as u32,\n             DIFlags::FlagZero,\n             Some(empty_array),\n             0, // RuntimeLang\n@@ -1962,7 +1958,7 @@ pub fn create_global_var_metadata(\n                                                     is_local_to_unit,\n                                                     global,\n                                                     None,\n-                                                    global_align.abi() as u32,\n+                                                    global_align.bytes() as u32,\n         );\n     }\n }\n@@ -2000,7 +1996,7 @@ pub fn create_vtable_metadata(\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             Size::ZERO.bits(),\n-            cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n+            cx.tcx.data_layout.pointer_align.abi.bits() as u32,\n             DIFlags::FlagArtificial,\n             None,\n             empty_array,"}, {"sha": "78bdf678f67078d2411c42fbe1c10bab4b84b070", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n             created_files: Default::default(),\n             created_enum_disr_types: Default::default(),\n             type_map: Default::default(),\n-            namespace_map: RefCell::new(DefIdMap()),\n+            namespace_map: RefCell::new(Default::default()),\n             composite_types_completed: Default::default(),\n         }\n     }\n@@ -201,7 +201,7 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         cx.sess().opts.optimize != config::OptLevel::No,\n                         DIFlags::FlagZero,\n                         argument_index,\n-                        align.abi() as u32,\n+                        align.bytes() as u32,\n                     )\n                 };\n                 source_loc::set_debug_location(self,"}, {"sha": "3548ccfd5a53701eb500d49458d32ed1de7b4532", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -110,7 +110,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let name = &*tcx.item_name(def_id).as_str();\n \n         let llret_ty = self.cx().layout_of(ret_ty).llvm_type(self.cx());\n-        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n+        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align.abi);\n \n         let simple = get_simple_intrinsic(self.cx(), name);\n         let llval = match name {\n@@ -158,7 +158,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             \"min_align_of\" => {\n                 let tp_ty = substs.type_at(0);\n-                self.cx().const_usize(self.cx().align_of(tp_ty).abi())\n+                self.cx().const_usize(self.cx().align_of(tp_ty).bytes())\n             }\n             \"min_align_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n@@ -167,12 +167,12 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n                     llalign\n                 } else {\n-                    self.cx().const_usize(self.cx().align_of(tp_ty).abi())\n+                    self.cx().const_usize(self.cx().align_of(tp_ty).bytes())\n                 }\n             }\n             \"pref_align_of\" => {\n                 let tp_ty = substs.type_at(0);\n-                self.cx().const_usize(self.cx().align_of(tp_ty).pref())\n+                self.cx().const_usize(self.cx().layout_of(tp_ty).align.pref.bytes())\n             }\n             \"type_name\" => {\n                 let tp_ty = substs.type_at(0);\n@@ -261,7 +261,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let align = if name == \"unaligned_volatile_load\" {\n                     1\n                 } else {\n-                    self.cx().align_of(tp_ty).abi() as u32\n+                    self.cx().align_of(tp_ty).bytes() as u32\n                 };\n                 unsafe {\n                     llvm::LLVMSetAlignment(load, align);\n@@ -815,7 +815,7 @@ fn try_intrinsic(\n ) {\n     if bx.cx().sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n-        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         bx.store(bx.cx().const_null(bx.cx().type_i8p()), dest, ptr_align);\n     } else if wants_msvc_seh(bx.cx().sess()) {\n         codegen_msvc_try(bx, func, data, local_ptr, dest);\n@@ -890,7 +890,7 @@ fn codegen_msvc_try(\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = bx.cx().type_ptr_to(bx.cx().type_i64());\n-        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n@@ -906,7 +906,7 @@ fn codegen_msvc_try(\n         let funclet = catchpad.catch_pad(cs, &[tydesc, bx.cx().const_i32(0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n-        let i64_align = bx.tcx().data_layout.i64_align;\n+        let i64_align = bx.tcx().data_layout.i64_align.abi;\n         let arg1 = catchpad.load(addr, i64_align);\n         let val1 = bx.cx().const_i32(1);\n         let gep1 = catchpad.inbounds_gep(addr, &[val1]);\n@@ -923,7 +923,7 @@ fn codegen_msvc_try(\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bx.call(llfn, &[func, data, local_ptr], None);\n-    let i32_align = bx.tcx().data_layout.i32_align;\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n \n@@ -982,7 +982,7 @@ fn codegen_gnu_try(\n         let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n         catch.add_clause(vals, bx.cx().const_null(bx.cx().type_i8p()));\n         let ptr = catch.extract_value(vals, 0);\n-        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let bitcast = catch.bitcast(local_ptr, bx.cx().type_ptr_to(bx.cx().type_i8p()));\n         catch.store(ptr, bitcast, ptr_align);\n         catch.ret(bx.cx().const_i32(1));\n@@ -991,7 +991,7 @@ fn codegen_gnu_try(\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bx.call(llfn, &[func, data, local_ptr], None);\n-    let i32_align = bx.tcx().data_layout.i32_align;\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n \n@@ -1436,7 +1436,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = bx.cx().type_i32();\n-        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).bytes() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1536,7 +1536,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = bx.cx().type_i32();\n-        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).bytes() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {"}, {"sha": "15b5bdeb44d60f63490ae1f989a02d2d83237868", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -80,7 +80,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = cx.type_padding_filler( layout.size, layout.align);\n+            let fill = cx.type_padding_filler(layout.size, layout.align.abi);\n             let packed = false;\n             match name {\n                 None => {\n@@ -120,23 +120,23 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let mut packed = false;\n     let mut offset = Size::ZERO;\n-    let mut prev_effective_align = layout.align;\n+    let mut prev_effective_align = layout.align.abi;\n     let mut result: Vec<_> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let target_offset = layout.fields.offset(i as usize);\n         let field = layout.field(cx, i);\n-        let effective_field_align = layout.align\n-            .min(field.align)\n+        let effective_field_align = layout.align.abi\n+            .min(field.align.abi)\n             .restrict_for_offset(target_offset);\n-        packed |= effective_field_align.abi() < field.align.abi();\n+        packed |= effective_field_align < field.align.abi;\n \n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?} \\\n                 effective_field_align: {}\",\n-               i, field, offset, target_offset, effective_field_align.abi());\n+               i, field, offset, target_offset, effective_field_align.bytes());\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n         let padding_align = prev_effective_align.min(effective_field_align);\n-        assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n+        assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler( padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n@@ -151,7 +151,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         let padding = layout.size - offset;\n         let padding_align = prev_effective_align;\n-        assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n+        assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n         result.push(cx.type_padding_filler(padding, padding_align));\n@@ -166,15 +166,16 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n-        self.layout_of(ty).align\n+        self.layout_of(ty).align.abi\n     }\n \n     pub fn size_of(&self, ty: Ty<'tcx>) -> Size {\n         self.layout_of(ty).size\n     }\n \n     pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, Align) {\n-        self.layout_of(ty).size_and_align()\n+        let layout = self.layout_of(ty);\n+        (layout.size, layout.align.abi)\n     }\n }\n \n@@ -332,7 +333,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                    cx.type_pointee_for_abi_align( pointee.align)\n+                    cx.type_pointee_for_align(pointee.align)\n                 } else {\n                     cx.type_i8()\n                 };\n@@ -376,7 +377,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         let offset = if index == 0 {\n             Size::ZERO\n         } else {\n-            a.value.size(cx).abi_align(b.value.align(cx))\n+            a.value.size(cx).align_to(b.value.align(cx).abi)\n         };\n         self.scalar_llvm_type_at(cx, scalar, offset)\n     }"}, {"sha": "ec5ca5801049eebe45b8d74bfcf98bb0c6b06f3b", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1050,6 +1050,10 @@ impl<'a> Linker for WasmLd<'a> {\n }\n \n fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n+    if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n+        return exports.clone()\n+    }\n+\n     let mut symbols = Vec::new();\n \n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);"}, {"sha": "0463da00c89d98d9134952f7bd560c427ee58001", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -64,7 +64,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n-        return Lrc::new(DefIdMap())\n+        return Default::default();\n     }\n \n     // Check to see if this crate is a \"special runtime crate\". These\n@@ -299,7 +299,7 @@ fn upstream_monomorphizations_provider<'a, 'tcx>(\n \n     let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n \n-    let mut instances: DefIdMap<FxHashMap<_, _>> = DefIdMap();\n+    let mut instances: DefIdMap<FxHashMap<_, _>> = Default::default();\n \n     let cnum_stable_ids: IndexVec<CrateNum, Fingerprint> = {\n         let mut cnum_stable_ids = IndexVec::from_elem_n(Fingerprint::ZERO,"}, {"sha": "bb28ea74dc0025f8cb767e23e9146b7eff268226", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -25,14 +25,12 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     t: Ty<'tcx>,\n     info: Option<Bx::Value>\n ) -> (Bx::Value, Bx::Value) {\n-    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n-           t, info);\n-    if bx.cx().type_is_sized(t) {\n-        let (size, align) = bx.cx().layout_of(t).size_and_align();\n-        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n-               t, info, size, align);\n-        let size = bx.cx().const_usize(size.bytes());\n-        let align = bx.cx().const_usize(align.abi());\n+    let layout = bx.cx().layout_of(t);\n+    debug!(\"size_and_align_of_dst(ty={}, info={:?}): layout: {:?}\",\n+           t, info, layout);\n+    if !layout.is_unsized() {\n+        let size = bx.cx().const_usize(layout.size.bytes());\n+        let align = bx.cx().const_usize(layout.align.abi.bytes());\n         return (size, align);\n     }\n     match t.sty {\n@@ -42,24 +40,22 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n         ty::Slice(_) | ty::Str => {\n-            let unit = t.sequence_element_type(bx.tcx());\n+            let unit = layout.field(bx.cx(), 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bx.cx().layout_of(unit).size_and_align();\n-            (bx.mul(info.unwrap(), bx.cx().const_usize(size.bytes())),\n-             bx.cx().const_usize(align.abi()))\n+            (bx.mul(info.unwrap(), bx.cx().const_usize(unit.size.bytes())),\n+             bx.cx().const_usize(unit.align.abi.bytes()))\n         }\n         _ => {\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let layout = bx.cx().layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n-            let sized_align = layout.align.abi();\n+            let sized_align = layout.align.abi.bytes();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = bx.cx().const_usize(sized_size);"}, {"sha": "d70fcf60fdf35009d18041a06e31864e3ceeeb03", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx: 'a> VirtualIndex {\n             llvtable,\n             bx.cx().type_ptr_to(bx.cx().fn_ptr_backend_type(fn_ty))\n         );\n-        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]);\n         let ptr = bx.load(gep, ptr_align);\n         bx.nonnull_metadata(ptr);\n@@ -59,7 +59,7 @@ impl<'a, 'tcx: 'a> VirtualIndex {\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(llvtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n-        let usize_align = bx.tcx().data_layout.pointer_align;\n+        let usize_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]);\n         let ptr = bx.load(gep, usize_align);\n         // Vtable loads are invariant\n@@ -100,19 +100,19 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         })\n     });\n \n-    let (size, align) = cx.layout_of(ty).size_and_align();\n+    let layout = cx.layout_of(ty);\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     // If you touch this code, be sure to also make the corresponding changes to\n     // `get_vtable` in rust_mir/interpret/traits.rs\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         cx.get_fn(monomorphize::resolve_drop_in_place(cx.tcx(), ty)),\n-        cx.const_usize(size.bytes()),\n-        cx.const_usize(align.abi())\n+        cx.const_usize(layout.size.bytes()),\n+        cx.const_usize(layout.align.abi.bytes())\n     ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = cx.const_struct(&components, false);\n-    let align = cx.data_layout().pointer_align;\n+    let align = cx.data_layout().pointer_align.abi;\n     let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n     cx.create_vtable_metadata(ty, vtable);"}, {"sha": "75a6f07124ae72c58bee0999fdb743fdd720e191", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -280,15 +280,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 scratch.llval\n                             }\n                             Ref(llval, _, align) => {\n-                                assert_eq!(align.abi(), op.layout.align.abi(),\n+                                assert_eq!(align, op.layout.align.abi,\n                                            \"return place is unaligned!\");\n                                 llval\n                             }\n                         };\n                         let addr = bx.pointercast(llslot, bx.cx().type_ptr_to(\n                             bx.cx().cast_backend_type(&cast_ty)\n                         ));\n-                        bx.load(addr, self.fn_ty.ret.layout.align)\n+                        bx.load(addr, self.fn_ty.ret.layout.align.abi)\n                     }\n                 };\n                 bx.ret(llval);\n@@ -386,9 +386,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let filename = bx.cx().const_str_slice(filename);\n                 let line = bx.cx().const_u32(loc.line as u32);\n                 let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n-                let align = tcx.data_layout.aggregate_align\n-                    .max(tcx.data_layout.i32_align)\n-                    .max(tcx.data_layout.pointer_align);\n+                let align = tcx.data_layout.aggregate_align.abi\n+                    .max(tcx.data_layout.i32_align.abi)\n+                    .max(tcx.data_layout.pointer_align.abi);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args) = match *msg {\n@@ -522,9 +522,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let filename = bx.cx().const_str_slice(filename);\n                     let line = bx.cx().const_u32(loc.line as u32);\n                     let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n-                    let align = tcx.data_layout.aggregate_align\n-                        .max(tcx.data_layout.i32_align)\n-                        .max(tcx.data_layout.pointer_align);\n+                    let align = tcx.data_layout.aggregate_align.abi\n+                        .max(tcx.data_layout.i32_align.abi)\n+                        .max(tcx.data_layout.pointer_align.abi);\n \n                     let str = format!(\n                         \"Attempted to instantiate uninhabited type {} using mem::{}\",\n@@ -800,12 +800,12 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (scratch.llval, scratch.align, true)\n                     }\n                     _ => {\n-                        (op.immediate_or_packed_pair(bx), arg.layout.align, false)\n+                        (op.immediate_or_packed_pair(bx), arg.layout.align.abi, false)\n                     }\n                 }\n             }\n             Ref(llval, _, align) => {\n-                if arg.is_indirect() && align.abi() < arg.layout.align.abi() {\n+                if arg.is_indirect() && align < arg.layout.align.abi {\n                     // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n@@ -826,7 +826,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let addr = bx.pointercast(llval, bx.cx().type_ptr_to(\n                     bx.cx().cast_backend_type(&ty))\n                 );\n-                llval = bx.load(addr, align.min(arg.layout.align));\n+                llval = bx.load(addr, align.min(arg.layout.align.abi));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -1006,7 +1006,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.codegen_place(bx, dest)\n         };\n         if fn_ret.is_indirect() {\n-            if dest.align.abi() < dest.layout.align.abi() {\n+            if dest.align < dest.layout.align.abi {\n                 // Currently, MIR code generation does not create calls\n                 // that store directly to fields of packed structs (in\n                 // fact, the calls it creates write only to temps),\n@@ -1062,7 +1062,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let src = self.codegen_operand(bx, src);\n         let llty = bx.cx().backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.cx().type_ptr_to(llty));\n-        let align = src.layout.align.min(dst.layout.align);\n+        let align = src.layout.align.abi.min(dst.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n "}, {"sha": "fdc9a37a9eb3f7e72afbb5218bc245285e1e213d", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -304,7 +304,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = fx.cx.get_param(llfn, 0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n+                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align.abi))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n@@ -555,7 +555,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n+            PlaceRef::new_sized(llarg, arg.layout, arg.layout.align.abi)\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer."}, {"sha": "f6917906d4a8aeff1c8ab7e3ff29c3ae7d8336b5", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n             llval: llptr,\n             llextra,\n             layout,\n-            align: layout.align,\n+            align: layout.align.abi,\n         }\n     }\n \n@@ -228,7 +228,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                     OperandValue::Immediate(a_llval)\n                 } else {\n                     assert_eq!(offset, a.value.size(bx.cx())\n-                        .abi_align(b.value.align(bx.cx())));\n+                        .align_to(b.value.align(bx.cx()).abi));\n                     assert_eq!(field.size, b.value.size(bx.cx()));\n                     OperandValue::Immediate(b_llval)\n                 }\n@@ -348,8 +348,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n             };\n \n         // FIXME: choose an appropriate alignment, or use dynamic align somehow\n-        let max_align = Align::from_bits(128, 128).unwrap();\n-        let min_align = Align::from_bits(8, 8).unwrap();\n+        let max_align = Align::from_bits(128).unwrap();\n+        let min_align = Align::from_bits(8).unwrap();\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n@@ -470,7 +470,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.load_operand(PlaceRef::new_sized(\n                             bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),\n                             layout,\n-                            layout.align,\n+                            layout.align.abi,\n                         ))\n                     })\n             }"}, {"sha": "e6fd6dfca736bfe07ed831f1a289d19f338a02b0", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -58,8 +58,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     ) -> Self {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align);\n-        Self::new_sized(tmp, layout, layout.align)\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n+        Self::new_sized(tmp, layout, layout.align.abi)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n@@ -109,7 +109,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 self.llval\n             } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n                 // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(bx.cx()).abi_align(b.value.align(bx.cx())));\n+                assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n                 bx.struct_gep(self.llval, 1)\n             } else {\n                 bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n@@ -143,7 +143,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 if def.repr.packed() {\n                     // FIXME(eddyb) generalize the adjustment when we\n                     // start supporting packing to larger alignments.\n-                    assert_eq!(self.layout.align.abi(), 1);\n+                    assert_eq!(self.layout.align.abi.bytes(), 1);\n                     return simple();\n                 }\n             }\n@@ -308,9 +308,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n-                        let (size, align) = self.layout.size_and_align();\n-                        let size = bx.cx().const_usize(size.bytes());\n-                        bx.memset(self.llval, fill_byte, size, align, MemFlags::empty());\n+                        let size = bx.cx().const_usize(self.layout.size.bytes());\n+                        bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n                     let niche = self.project_field(bx, 0);\n@@ -419,13 +418,13 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n                         );\n-                        PlaceRef::new_sized(llval, layout, layout.align)\n+                        PlaceRef::new_sized(llval, layout, layout.align.abi)\n                     }\n                 }\n             }\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n-                PlaceRef::new_sized(cx.get_static(def_id), layout, layout.align)\n+                PlaceRef::new_sized(cx.get_static(def_id), layout, layout.align.abi)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,"}, {"sha": "805c1a343d0444e9e7ce5d164e5fe87b39546146", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -496,10 +496,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n-                let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bx.cx().layout_of(content_ty).size_and_align();\n-                let llsize = bx.cx().const_usize(size.bytes());\n-                let llalign = bx.cx().const_usize(align.abi());\n+                let content_ty = self.monomorphize(&content_ty);\n+                let content_layout = bx.cx().layout_of(content_ty);\n+                let llsize = bx.cx().const_usize(content_layout.size.bytes());\n+                let llalign = bx.cx().const_usize(content_layout.align.abi.bytes());\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = bx.cx().backend_type(box_layout);\n "}, {"sha": "8fe89791969048a24969c70f0a8ec0942902e149", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n-//! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n-//! paths etc in all kinds of annoying scenarios.\n-\n use base;\n use rustc::hir;\n use rustc::hir::def::Def;"}, {"sha": "0b3066f561cce9e296bf60a9da955324f4e2278a", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -15,10 +15,10 @@ use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgTypeMethods;\n use super::HasCodegen;\n use common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n-use std::ffi::CStr;\n use mir::operand::OperandRef;\n use mir::place::PlaceRef;\n use rustc::ty::layout::{Align, Size};\n+use std::ffi::CStr;\n use MemFlags;\n \n use std::borrow::Cow;"}, {"sha": "15976ac516dc62c4882464bbefafc878cbcec710", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -120,16 +120,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_pointee_for_abi_align(&self, align: Align) -> Self::Type {\n+    fn type_pointee_for_align(&self, align: Align) -> Self::Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(self, align);\n+        let ity = layout::Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n     fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type {\n-        let unit = layout::Integer::approximate_abi_align(self, align);\n+        let unit = layout::Integer::approximate_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);"}, {"sha": "5b3dd38adf23f98a8eb8eb16a3f2e84e89d3bc8f", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -9,7 +9,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-ena = \"0.9.3\"\n+ena = \"0.10.1\"\n log = \"0.4\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "7c7fc3a934620e15f216a2de8f5c8b87b9efa02b", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use rustc_hash::FxHashMap;\n-pub use rustc_hash::FxHashSet;\n-pub use rustc_hash::FxHasher;\n+pub use rustc_hash::{FxHasher, FxHashMap, FxHashSet};"}, {"sha": "0b42cb1edddecc23eb9fde51fa32ec09e940f1f8", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -23,6 +23,18 @@ pub struct SnapshotMap<K, V>\n     undo_log: Vec<UndoLog<K, V>>,\n }\n \n+// HACK(eddyb) manual impl avoids `Default` bounds on `K` and `V`.\n+impl<K, V> Default for SnapshotMap<K, V>\n+    where K: Hash + Clone + Eq\n+{\n+    fn default() -> Self {\n+        SnapshotMap {\n+            map: Default::default(),\n+            undo_log: Default::default(),\n+        }\n+    }\n+}\n+\n pub struct Snapshot {\n     len: usize,\n }\n@@ -35,17 +47,6 @@ enum UndoLog<K, V> {\n     Noop,\n }\n \n-impl<K, V> Default for SnapshotMap<K, V>\n-    where K: Hash + Clone + Eq\n-{\n-    fn default() -> Self {\n-        SnapshotMap {\n-            map: FxHashMap::default(),\n-            undo_log: vec![],\n-        }\n-    }\n-}\n-\n impl<K, V> SnapshotMap<K, V>\n     where K: Hash + Clone + Eq\n {"}, {"sha": "fd5dfab9e61be6702d36a264810f8657e41cbe04", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -42,6 +42,18 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n     closure: Lock<Option<BitMatrix<usize, usize>>>,\n }\n \n+// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n+impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n+    fn default() -> Self {\n+        TransitiveRelation {\n+            elements: Default::default(),\n+            map: Default::default(),\n+            edges: Default::default(),\n+            closure: Default::default(),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n struct Index(usize);\n \n@@ -51,17 +63,6 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n-    fn default() -> TransitiveRelation<T> {\n-        TransitiveRelation {\n-            elements: vec![],\n-            map: FxHashMap::default(),\n-            edges: vec![],\n-            closure: Lock::new(None),\n-        }\n-    }\n-}\n-\n impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()"}, {"sha": "7dd1ca3493e9d12b9a656376b050c7c6e6861b97", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -603,7 +603,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let mut impls = NodeSet();\n+            let mut impls = NodeSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                     if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def.did) {"}, {"sha": "fab618d9c8ec843b23763a95188db35dca20fba2", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -60,18 +60,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         let t = cx.tables.expr_ty(&expr);\n-        // FIXME(varkor): replace with `t.is_unit() || t.conservative_is_uninhabited()`.\n-        let type_permits_no_use = match t.sty {\n-            ty::Tuple(ref tys) if tys.is_empty() => true,\n-            ty::Never => true,\n-            ty::Adt(def, _) => {\n-                if def.variants.is_empty() {\n-                    true\n-                } else {\n-                    check_must_use(cx, def.did, s.span, \"\")\n+        let type_permits_lack_of_use = if t.is_unit()\n+            || cx.tcx.is_ty_uninhabited_from(cx.tcx.hir.get_module_parent(expr.id), t) {\n+            true\n+        } else {\n+            match t.sty {\n+                ty::Adt(def, _) => check_must_use(cx, def.did, s.span, \"\", \"\"),\n+                ty::Opaque(def, _) => {\n+                    let mut must_use = false;\n+                    for (predicate, _) in &cx.tcx.predicates_of(def).predicates {\n+                        if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n+                            let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n+                            if check_must_use(cx, trait_ref.def_id, s.span, \"implementer of \", \"\") {\n+                                must_use = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    must_use\n+                }\n+                ty::Dynamic(binder, _) => {\n+                    let mut must_use = false;\n+                    for predicate in binder.skip_binder().iter() {\n+                        if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n+                            if check_must_use(cx, trait_ref.def_id, s.span, \"\", \" trait object\") {\n+                                must_use = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    must_use\n                 }\n+                _ => false,\n             }\n-            _ => false,\n         };\n \n         let mut fn_warned = false;\n@@ -98,8 +119,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n         if let Some(def) = maybe_def {\n             let def_id = def.def_id();\n-            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n-        } else if type_permits_no_use {\n+            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \", \"\");\n+        } else if type_permits_lack_of_use {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n             return;\n@@ -148,15 +169,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             op_warned = true;\n         }\n \n-        if !(type_permits_no_use || fn_warned || op_warned) {\n+        if !(type_permits_lack_of_use || fn_warned || op_warned) {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &LateContext, def_id: DefId, sp: Span, describe_path: &str) -> bool {\n+        fn check_must_use(\n+            cx: &LateContext,\n+            def_id: DefId,\n+            sp: Span,\n+            descr_pre_path: &str,\n+            descr_post_path: &str,\n+        ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(\"must_use\") {\n-                    let msg = format!(\"unused {}`{}` that must be used\",\n-                                          describe_path, cx.tcx.item_path_str(def_id));\n+                    let msg = format!(\"unused {}`{}`{} that must be used\",\n+                        descr_pre_path, cx.tcx.item_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {"}, {"sha": "c7bd1744a3d6d53dfea9f4282c02bb8bf41f074d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -316,7 +316,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n             use std::collections::hash_map::Entry;\n \n             assert_eq!(cnum, LOCAL_CRATE);\n-            let mut visible_parent_map: DefIdMap<DefId> = DefIdMap();\n+            let mut visible_parent_map: DefIdMap<DefId> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we"}, {"sha": "d95a74be77696018fffe42c381b30c9885af4e69", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -829,7 +829,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 1,\n             ),\n             upvar_decls,\n-            var_indices: NodeMap(),\n+            var_indices: Default::default(),\n             unit_temp: None,\n             cached_resume_block: None,\n             cached_return_block: None,"}, {"sha": "1bc3b322717e5215daec29b2b443f4697e9d9665", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -31,8 +31,8 @@ use rustc::util::common::ErrorReported;\n use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n-use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, ConstValue, Pointer,\n+use crate::interpret::{self,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, RawConst, ConstValue, Pointer,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -94,11 +94,12 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n+) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n+// FIXME: These two conversion functions are bad hacks.  We should just always use allocations.\n pub fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n@@ -128,7 +129,7 @@ pub fn op_to_const<'tcx>(\n             assert!(meta.is_none());\n             let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n-            assert!(alloc.align.abi() >= align.abi());\n+            assert!(alloc.align >= align);\n             assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n@@ -144,13 +145,20 @@ pub fn op_to_const<'tcx>(\n     };\n     Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n }\n+pub fn const_to_op<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    cnst: &ty::Const<'tcx>,\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    let op = ecx.const_value_to_op(cnst.val)?;\n+    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n+}\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, OpTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n+) -> (EvalResult<'tcx, MPlaceTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n@@ -166,7 +174,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n+) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -206,7 +214,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n-    Ok(ret.into())\n+    Ok(ret)\n }\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n@@ -494,7 +502,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         // get the operand again\n-        let op = ecx.const_to_op(value)?;\n+        let op = const_to_op(&ecx, value)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -521,7 +529,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let op = ecx.const_to_op(val)?;\n+    let op = const_to_op(&ecx, val)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n@@ -534,15 +542,17 @@ pub fn error_to_const_error<'a, 'mir, 'tcx>(\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n-fn validate_const<'a, 'tcx>(\n+fn validate_and_turn_into_const<'a, 'tcx>(\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    constant: &'tcx ty::Const<'tcx>,\n+    constant: RawConst<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n     let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n     let val = (|| {\n-        let op = ecx.const_to_op(constant)?;\n+        let op = ecx.raw_const_to_mplace(constant)?.into();\n+        // FIXME: Once the visitor infrastructure landed, change validation to\n+        // work directly on `MPlaceTy`.\n         let mut ref_tracking = RefTracking::new(op);\n         while let Some((op, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n@@ -552,7 +562,10 @@ fn validate_const<'a, 'tcx>(\n                 /* const_mode */ true,\n             )?;\n         }\n-        Ok(constant)\n+        // Now that we validated, turn this into a proper constant\n+        let def_id = cid.instance.def.def_id();\n+        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n+        op_to_const(&ecx, op, normalize)\n     })();\n \n     val.map_err(|error| {\n@@ -591,14 +604,14 @@ pub fn const_eval_provider<'a, 'tcx>(\n         }\n     }\n     tcx.const_eval_raw(key).and_then(|val| {\n-        validate_const(tcx, val, key)\n+        validate_and_turn_into_const(tcx, val, key)\n     })\n }\n \n pub fn const_eval_raw_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n     // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n     // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n@@ -648,16 +661,11 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|op| {\n-        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n-        if !normalize {\n-            // Sanity check: These must always be a MemPlace\n-            match op.op {\n-                Operand::Indirect(_) => { /* all is good */ },\n-                Operand::Immediate(_) => bug!(\"const eval gave us an Immediate\"),\n-            }\n-        }\n-        op_to_const(&ecx, op, normalize)\n+    res.and_then(|place| {\n+        Ok(RawConst {\n+            alloc_id: place.to_ptr().expect(\"we allocated this ptr!\").alloc_id,\n+            ty: place.layout.ty\n+        })\n     }).map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors"}, {"sha": "936b476df39b9713e430971600a8e23598d94f72", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n-            return Ok(Some(layout.size_and_align()));\n+            return Ok(Some((layout.size, layout.align.abi)));\n         }\n         match layout.ty.sty {\n             ty::Adt(..) | ty::Tuple(..) => {\n@@ -328,7 +328,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 trace!(\"DST layout: {:?}\", layout);\n \n                 let sized_size = layout.fields.offset(layout.fields.count() - 1);\n-                let sized_align = layout.align;\n+                let sized_align = layout.align.abi;\n                 trace!(\n                     \"DST {} statically sized prefix size: {:?} align: {:?}\",\n                     layout.ty,\n@@ -381,7 +381,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 //\n                 //   `(size + (align-1)) & -align`\n \n-                Ok(Some((size.abi_align(align), align)))\n+                Ok(Some((size.align_to(align), align)))\n             }\n             ty::Dynamic(..) => {\n                 let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\").to_ptr()?;\n@@ -391,8 +391,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n             ty::Slice(_) | ty::Str => {\n                 let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n-                let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                Ok(Some((elem_size * len, align)))\n+                let elem = layout.field(self, 0)?;\n+                Ok(Some((elem.size * len, elem.align.abi)))\n             }\n \n             ty::Foreign(_) => {\n@@ -588,18 +588,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         Ok(())\n     }\n \n-    pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    pub fn const_eval_raw(\n+        &self,\n+        gid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             ty::ParamEnv::reveal_all()\n         } else {\n             self.param_env\n         };\n-        self.tcx.const_eval(param_env.and(gid)).map_err(|err| {\n+        // We use `const_eval_raw` here, and get an unvalidated result.  That is okay:\n+        // Our result will later be validated anyway, and there seems no good reason\n+        // to have to fail early here.  This is also more consistent with\n+        // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n+        let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n-                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant.into(),\n-                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric.into(),\n+                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant,\n+                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric,\n             }\n-        })\n+        })?;\n+        self.raw_const_to_mplace(val)\n     }\n \n     pub fn dump_place(&self, place: Place<M::PointerTag>) {\n@@ -628,7 +636,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                         let (ptr, align) = mplace.to_scalar_ptr_align();\n                         match ptr {\n                             Scalar::Ptr(ptr) => {\n-                                write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n+                                write!(msg, \" by align({}) ref:\", align.bytes()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n@@ -657,7 +665,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             Place::Ptr(mplace) => {\n                 match mplace.ptr {\n                     Scalar::Ptr(ptr) => {\n-                        trace!(\"by align({}) ref:\", mplace.align.abi());\n+                        trace!(\"by align({}) ref:\", mplace.align.bytes());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),"}, {"sha": "bbee6e0b49ae0b3d5a1a080b503203b77392f076", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         match intrinsic_name {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_align = self.layout_of(elem_ty)?.align.abi();\n+                let elem_align = self.layout_of(elem_ty)?.align.abi.bytes();\n                 let align_val = Scalar::from_uint(elem_align, dest.layout.size);\n                 self.write_scalar(align_val, dest)?;\n             }"}, {"sha": "898600d8322d23a0350b8399b26554952801fb10", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::ast::Mutability;\n \n use super::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra, InboundsCheck,\n+    Pointer, AllocId, Allocation, GlobalId, AllocationExtra, InboundsCheck,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n };\n@@ -268,18 +268,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         };\n         // Check alignment\n-        if alloc_align.abi() < required_align.abi() {\n+        if alloc_align.bytes() < required_align.bytes() {\n             return err!(AlignmentCheckFailed {\n                 has: alloc_align,\n                 required: required_align,\n             });\n         }\n-        if offset % required_align.abi() == 0 {\n+        if offset % required_align.bytes() == 0 {\n             Ok(())\n         } else {\n-            let has = offset % required_align.abi();\n+            let has = offset % required_align.bytes();\n             err!(AlignmentCheckFailed {\n-                has: Align::from_bytes(has, has).unwrap(),\n+                has: Align::from_bytes(has).unwrap(),\n                 required: required_align,\n             })\n         }\n@@ -374,14 +374,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 ErrorHandled::Reported => EvalErrorKind::ReferencedConstant.into(),\n                 ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric.into(),\n             }\n-        }).map(|const_val| {\n-            if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n-                // We got tcx memory. Let the machine figure out whether and how to\n-                // turn that into memory with the right pointer tag.\n-                M::adjust_static_allocation(allocation)\n-            } else {\n-                bug!(\"Matching on non-ByRef static\")\n-            }\n+        }).map(|raw_const| {\n+            let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n+            // We got tcx memory. Let the machine figure out whether and how to\n+            // turn that into memory with the right pointer tag.\n+            M::adjust_static_allocation(allocation)\n         })\n     }\n \n@@ -452,14 +449,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1, 1).unwrap()),\n+            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n             Some(AllocType::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                (layout.size, layout.align)\n+                (layout.size, layout.align.abi)\n             }\n             _ => {\n                 // Must be a deallocated pointer\n@@ -524,7 +521,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             \"{}({} bytes, alignment {}){}\",\n             msg,\n             alloc.bytes.len(),\n-            alloc.align.abi(),\n+            alloc.align.bytes(),\n             extra\n         );\n \n@@ -866,7 +863,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = Align::from_bytes(1).unwrap();\n         if size.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -884,7 +881,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = Align::from_bytes(1).unwrap();\n         if size.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(&[]);\n@@ -894,7 +891,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn write_bytes(&mut self, ptr: Scalar<M::PointerTag>, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = Align::from_bytes(1).unwrap();\n         if src.is_empty() {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -911,7 +908,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         count: Size\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = Align::from_bytes(1).unwrap();\n         if count.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -1038,7 +1035,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             16 => layout::I128,\n             _ => bug!(\"bad integer size: {}\", size.bytes()),\n         };\n-        ity.align(self)\n+        ity.align(self).abi\n     }\n }\n "}, {"sha": "8238d580022a8bc9c641d9bbb064e4597f593d58", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -13,7 +13,7 @@\n \n use std::convert::TryInto;\n \n-use rustc::{mir, ty};\n+use rustc::mir;\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n@@ -285,7 +285,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n-                let b_offset = a_size.abi_align(b.align(self));\n+                let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n                 let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n@@ -535,19 +535,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Also used e.g. when miri runs into a constant.\n-    pub(super) fn const_value_to_op(\n+    // Used when miri runs into a constant, and by CTFE.\n+    // FIXME: CTFE should use allocations, then we can make this private (embed it into\n+    // `eval_operand`, ideally).\n+    pub(crate) fn const_value_to_op(\n         &self,\n         val: ConstValue<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         trace!(\"const_value_to_op: {:?}\", val);\n         match val {\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                self.global_to_op(GlobalId {\n+                Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n-                })\n+                })?))\n             }\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n@@ -565,21 +567,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 Ok(Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag()),\n         }\n     }\n-    pub fn const_to_op(\n-        &self,\n-        cnst: &ty::Const<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = self.const_value_to_op(cnst.val)?;\n-        Ok(OpTy { op, layout: self.layout_of(cnst.ty)? })\n-    }\n-\n-    pub(super) fn global_to_op(\n-        &self,\n-        gid: GlobalId<'tcx>\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        let cv = self.const_eval(gid)?;\n-        self.const_value_to_op(cv.val)\n-    }\n \n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant("}, {"sha": "7ef3dd5f7201e261264e2fa799c8349319b9c9e9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -20,12 +20,10 @@ use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n \n-use rustc::mir::interpret::{\n-    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic\n-};\n use super::{\n+    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n     EvalContext, Machine, AllocMap, AllocationExtra,\n-    Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -129,7 +127,7 @@ impl<Tag> MemPlace<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n     pub fn null(cx: &impl HasDataLayout) -> Self {\n-        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n+        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1).unwrap())\n     }\n \n     #[inline(always)]\n@@ -169,16 +167,16 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n         MPlaceTy {\n             mplace: MemPlace::from_scalar_ptr(\n-                Scalar::from_uint(layout.align.abi(), cx.pointer_size()),\n-                layout.align\n+                Scalar::from_uint(layout.align.abi.bytes(), cx.pointer_size()),\n+                layout.align.abi\n             ),\n             layout\n         }\n     }\n \n     #[inline]\n     fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyLayout<'tcx>) -> Self {\n-        MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align), layout }\n+        MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n     }\n \n     #[inline]\n@@ -289,7 +287,7 @@ where\n \n         let mplace = MemPlace {\n             ptr: val.to_scalar_ptr()?,\n-            align: layout.align,\n+            align: layout.align.abi,\n             meta: val.to_meta()?,\n         };\n         Ok(MPlaceTy { mplace, layout })\n@@ -358,11 +356,11 @@ where\n                     // FIXME: Once we have made decisions for how to handle size and alignment\n                     // of `extern type`, this should be adapted.  It is just a temporary hack\n                     // to get some code to work that probably ought to work.\n-                    field_layout.align,\n+                    field_layout.align.abi,\n                 None =>\n                     bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n             };\n-            (base.meta, offset.abi_align(align))\n+            (base.meta, offset.align_to(align))\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n@@ -555,16 +553,10 @@ where\n         Ok(match *mir_place {\n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n-                let op = self.global_to_op(GlobalId {\n+                self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n-                })?;\n-                let mplace = op.to_mem_place(); // these are always in memory\n-                let ty = self.monomorphize(promoted.1, self.substs());\n-                MPlaceTy {\n-                    mplace,\n-                    layout: self.layout_of(ty)?,\n-                }\n+                })?\n             }\n \n             Static(ref static_) => {\n@@ -738,7 +730,7 @@ where\n                 }\n \n                 self.memory.write_scalar(\n-                    ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n+                    ptr, ptr_align.min(dest.layout.align.abi), scalar, dest.layout.size\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n@@ -748,8 +740,8 @@ where\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n-                let (a_align, b_align) = (a.align(self), b.align(self));\n-                let b_offset = a_size.abi_align(b_align);\n+                let (a_align, b_align) = (a.align(self).abi, b.align(self).abi);\n+                let b_offset = a_size.align_to(b_align);\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n@@ -907,7 +899,7 @@ where\n             // FIXME: What should we do here? We should definitely also tag!\n             Ok(MPlaceTy::dangling(layout, self))\n         } else {\n-            let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n+            let ptr = self.memory.allocate(layout.size, layout.align.abi, kind)?;\n             let ptr = M::tag_new_allocation(self, ptr, kind)?;\n             Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n         }\n@@ -981,6 +973,19 @@ where\n         Ok(OpTy { op, layout: place.layout })\n     }\n \n+    pub fn raw_const_to_mplace(\n+        &self,\n+        raw: RawConst<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // This must be an allocation in `tcx`\n+        assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let layout = self.layout_of(raw.ty)?;\n+        Ok(MPlaceTy::from_aligned_ptr(\n+            Pointer::new(raw.alloc_id, Size::ZERO).with_default_tag(),\n+            layout,\n+        ))\n+    }\n+\n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n@@ -993,7 +998,8 @@ where\n         if cfg!(debug_assertions) {\n             let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n             assert_eq!(size, layout.size);\n-            assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+            // only ABI alignment is preserved\n+            assert_eq!(align, layout.align.abi);\n         }\n \n         let mplace = MPlaceTy {"}, {"sha": "fd17a4a71295befd1ae30b4da8437b631cdf3315", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n-                let ptr_align = self.tcx.data_layout.pointer_align;\n+                let ptr_align = self.tcx.data_layout.pointer_align.abi;\n                 let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized("}, {"sha": "f11fd45b753fcc65d49a97badd10581e70a51489", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -42,10 +42,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n         let size = layout.size.bytes();\n-        let align = layout.align.abi();\n+        let align = layout.align.abi.bytes();\n \n         let ptr_size = self.pointer_size();\n-        let ptr_align = self.tcx.data_layout.pointer_align;\n+        let ptr_align = self.tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in rust_codegen_llvm/meth.rs\n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n-        let pointer_align = self.tcx.data_layout.pointer_align;\n+        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n         let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n         let drop_instance = self.memory.get_fn(drop_fn)?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n@@ -103,13 +103,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        let pointer_align = self.tcx.data_layout.pointer_align;\n+        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n         let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n             .to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bits(pointer_size)? as u64;\n-        Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n+        Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n     }\n }"}, {"sha": "6d1cacfa1479c0587272179b15d5f86c1244f8b1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -355,7 +355,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| layout.size_and_align());\n+                    .unwrap_or_else(|| (layout.size, layout.align.abi));\n                 match self.ecx.memory.check_align(ptr, align) {\n                     Ok(_) => {},\n                     Err(err) => {\n@@ -463,7 +463,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // for function pointers.\n                     let non_null =\n                         self.ecx.memory.check_align(\n-                            Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n+                            Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n                         ).is_ok() ||\n                         self.ecx.memory.get_fn(ptr).is_ok();\n                     if !non_null {"}, {"sha": "b4ffb39a2ebd6ae48b599c7ff2c0c03388233eca", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -314,7 +314,7 @@ pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         time(tcx.sess, \"collecting mono items\", || {\n             par_iter(roots).for_each(|root| {\n-                let mut recursion_depths = DefIdMap();\n+                let mut recursion_depths = DefIdMap::default();\n                 collect_items_rec(tcx,\n                                 root,\n                                 visited,"}, {"sha": "9c90e5ffd3c78fc193fcb266e61449dd4a5f9f0c", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n-//! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n-//! paths etc in all kinds of annoying scenarios.\n-\n use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;"}, {"sha": "661ca4773b4a91939d0d3eade2d3ab2f3e9a9fa4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -29,7 +29,9 @@ use rustc::ty::layout::{\n };\n \n use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n-use const_eval::{CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx};\n+use const_eval::{\n+    CompileTimeInterpreter, const_to_op, error_to_const_error, eval_promoted, mk_borrowck_eval_cx\n+};\n use transform::{MirPass, MirSource};\n \n pub struct ConstProp;\n@@ -262,7 +264,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_to_op(c.literal) {\n+        match const_to_op(&self.ecx, c.literal) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },\n@@ -309,7 +311,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     eval_promoted(this.tcx, cid, this.mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some((res, source_info.span))\n+                Some((res.into(), source_info.span))\n             },\n             _ => None,\n         }"}, {"sha": "8d3a04f9f3c2c52b9866b31f054bf3709d72f9ef", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -72,7 +72,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n                       -> Lrc<DefIdSet> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n-    let mut set = DefIdSet();\n+    let mut set = DefIdSet::default();\n \n     // All body-owners have MIR associated with them.\n     set.extend(tcx.body_owners());"}, {"sha": "958e5efe3ec74e9b3ffde0f33324917fdd1d38ff", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -365,10 +365,8 @@ fn check_terminator(\n             cleanup: _,\n         } => check_operand(tcx, mir, cond, span),\n \n-        | TerminatorKind::FalseUnwind { .. } => span_bug!(\n-            terminator.source_info.span,\n-            \"min_const_fn encountered `{:#?}`\",\n-            terminator\n-        ),\n+        TerminatorKind::FalseUnwind { .. } => {\n+            Err((span, \"loops are not allowed in const fn\".into()))\n+        },\n     }\n }"}, {"sha": "a96c5dd687069e24306a258b33d6c9fb0f76024b", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -30,7 +30,7 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let ty = place.ty(local_decls, tcx).to_ty(tcx);\n     match tcx.layout_raw(param_env.and(ty)) {\n-        Ok(layout) if layout.align.abi() == 1 => {\n+        Ok(layout) if layout.align.abi.bytes() == 1 => {\n             // if the alignment is 1, the type can't be further\n             // disaligned.\n             debug!(\"is_disaligned({:?}) - align = 1\", place);"}, {"sha": "099c6df32ad18cc55e47d81e98b9cbc2863683a2", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -84,10 +84,10 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tables: &ty::TypeckTables::empty(None),\n         in_fn: false,\n         in_static: false,\n-        mut_rvalue_borrows: NodeSet(),\n+        mut_rvalue_borrows: Default::default(),\n         param_env: ty::ParamEnv::empty(),\n         identity_substs: Substs::empty(),\n-        result: ItemLocalSet(),\n+        result: ItemLocalSet::default(),\n     };\n \n     // `def_id` should be a `Body` owner"}, {"sha": "fbd6f6edd31c5af4bc6b1589e6e3a7c79b42fdd1", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1761,7 +1761,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx,\n             access_levels: &visitor.access_levels,\n             in_variant: false,\n-            old_error_set: NodeSet(),\n+            old_error_set: Default::default(),\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "659ca1f5b9f3123e4dadfb9373a2c18d92401415", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -162,7 +162,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n \n     let mut visitor = UnusedImportCheckVisitor {\n         resolver,\n-        unused_imports: NodeMap(),\n+        unused_imports: Default::default(),\n         base_id: ast::DUMMY_NODE_ID,\n         item_span: DUMMY_SP,\n     };"}, {"sha": "12dabd2a31da18b94d541d7c9b27a41482049d2a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -58,7 +58,6 @@ use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -1862,22 +1861,22 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            def_map: NodeMap(),\n-            import_map: NodeMap(),\n-            freevars: NodeMap(),\n-            freevars_seen: NodeMap(),\n+            def_map: Default::default(),\n+            import_map: Default::default(),\n+            freevars: Default::default(),\n+            freevars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n-            trait_map: NodeMap(),\n+            trait_map: Default::default(),\n             module_map,\n-            block_map: NodeMap(),\n+            block_map: Default::default(),\n             extern_module_map: FxHashMap::default(),\n             binding_parent_modules: FxHashMap::default(),\n \n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n-            glob_map: NodeMap(),\n+            glob_map: Default::default(),\n \n             used_imports: FxHashSet::default(),\n-            maybe_unused_trait_imports: NodeSet(),\n+            maybe_unused_trait_imports: Default::default(),\n             maybe_unused_extern_crates: Vec::new(),\n \n             unused_labels: FxHashMap::default(),\n@@ -1907,7 +1906,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             name_already_seen: FxHashMap::default(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n             potentially_unused_imports: Vec::new(),\n-            struct_constructors: DefIdMap(),\n+            struct_constructors: Default::default(),\n             found_unresolved_macro: false,\n             unused_macros: FxHashSet::default(),\n             current_type_ascription: Vec::new(),\n@@ -2115,7 +2114,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         if !module.no_implicit_prelude {\n             if ns == TypeNS {\n-                if let Some(binding) = self.extern_prelude_get(ident, !record_used, false) {\n+                if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n@@ -5022,21 +5021,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         self.name_already_seen.insert(name, span);\n     }\n \n-    fn extern_prelude_get(&mut self, ident: Ident, speculative: bool, skip_feature_gate: bool)\n+    fn extern_prelude_get(&mut self, ident: Ident, speculative: bool)\n                           -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n         self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n-                if !speculative && !skip_feature_gate && entry.introduced_by_item &&\n-                   !self.session.features_untracked().extern_crate_item_prelude {\n-                    emit_feature_err(&self.session.parse_sess, \"extern_crate_item_prelude\",\n-                                     ident.span, GateIssue::Language,\n-                                     \"use of extern prelude names introduced \\\n-                                      with `extern crate` items is unstable\");\n-                }\n                 Some(binding)\n             } else {\n                 let crate_id = if !speculative {"}, {"sha": "581756dc6bf0b32b250a5203e2e6f92690aab78d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -738,8 +738,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n                 WhereToResolve::ExternPrelude => {\n                     if use_prelude {\n-                        match self.extern_prelude_get(ident, !record_used,\n-                                                      innermost_result.is_some()) {\n+                        match self.extern_prelude_get(ident, !record_used) {\n                             Some(binding) => Ok((binding, Flags::PRELUDE)),\n                             None => Err(Determinacy::determined(\n                                 self.graph_root.unresolved_invocations.borrow().is_empty()\n@@ -906,7 +905,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 // but its `Def` should coincide with a crate passed with `--extern`\n                 // (otherwise there would be ambiguity) and we can skip feature error in this case.\n                 if ns != TypeNS || !use_prelude ||\n-                   self.extern_prelude_get(ident, true, false).is_none() {\n+                   self.extern_prelude_get(ident, true).is_none() {\n                     let msg = \"imports can only refer to extern crate names \\\n                                passed with `--extern` on stable channel\";\n                     let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\","}, {"sha": "616cc9d2fc51b992d4c97adb2d7373395e99827d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -166,8 +166,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 assert!(!restricted_shadowing);\n                 match uniform_root_kind {\n                     UniformRootKind::ExternPrelude => {\n-                        return if let Some(binding) =\n-                                self.extern_prelude_get(ident, !record_used, false) {\n+                        return if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                             Ok(binding)\n                         } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n                             // Macro-expanded `extern crate` items can add names to extern prelude.\n@@ -843,12 +842,14 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 module\n             }\n             PathResult::Failed(span, msg, false) => {\n-                assert!(directive.imported_module.get().is_none());\n+                assert!(!self.ambiguity_errors.is_empty() ||\n+                        directive.imported_module.get().is_none());\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n             PathResult::Failed(span, msg, true) => {\n-                assert!(directive.imported_module.get().is_none());\n+                assert!(!self.ambiguity_errors.is_empty() ||\n+                        directive.imported_module.get().is_none());\n                 return if let Some((suggested_path, note)) = self.make_path_suggestion(\n                     span, directive.module_path.clone(), &directive.parent_scope\n                 ) {\n@@ -1164,7 +1165,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 None => continue,\n             };\n \n-            if binding.is_import() || binding.is_macro_def() {\n+            // Filter away \"empty import canaries\".\n+            let is_non_canary_import =\n+                binding.is_import() && binding.vis != ty::Visibility::Invisible;\n+            if is_non_canary_import || binding.is_macro_def() {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if let Some(def_id) = def.opt_def_id() {"}, {"sha": "bf497c09bdc719a109f58ee2004c973ae10e4fae", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -93,7 +93,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n         }\n     }\n \n-    let align = arg.layout.align.abi();\n+    let align = arg.layout.align.abi.bytes();\n     let total = arg.layout.size;\n     arg.cast_to(Uniform {\n         unit: if align <= 4 { Reg::i32() } else { Reg::i64() },"}, {"sha": "abe0bd07892d90be5714c6727e9b733e91ea3bb1", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -27,21 +27,21 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n {\n     let dl = cx.data_layout();\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if !offset.is_abi_aligned(align) {\n+        if !offset.is_aligned(align) {\n             arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)"}, {"sha": "d375b163164de9f8cb045982cbe30bfb1d9fca1c", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -118,9 +118,9 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n                 // We only care about aligned doubles\n                 if let abi::Abi::Scalar(ref scalar) = field.abi {\n                     if let abi::Float(abi::FloatTy::F64) = scalar.value {\n-                        if offset.is_abi_aligned(dl.f64_align) {\n+                        if offset.is_aligned(dl.f64_align.abi) {\n                             // Insert enough integers to cover [last_offset, offset)\n-                            assert!(last_offset.is_abi_aligned(dl.f64_align));\n+                            assert!(last_offset.is_aligned(dl.f64_align.abi));\n                             for _ in 0..((offset - last_offset).bits() / 64)\n                                 .min((prefix.len() - prefix_index) as u64) {\n "}, {"sha": "489bb37fc26ff9ac8393a41262261a51c621cb9d", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -142,23 +142,23 @@ impl Reg {\n         match self.kind {\n             RegKind::Integer => {\n                 match self.size.bits() {\n-                    1 => dl.i1_align,\n-                    2..=8 => dl.i8_align,\n-                    9..=16 => dl.i16_align,\n-                    17..=32 => dl.i32_align,\n-                    33..=64 => dl.i64_align,\n-                    65..=128 => dl.i128_align,\n+                    1 => dl.i1_align.abi,\n+                    2..=8 => dl.i8_align.abi,\n+                    9..=16 => dl.i16_align.abi,\n+                    17..=32 => dl.i32_align.abi,\n+                    33..=64 => dl.i64_align.abi,\n+                    65..=128 => dl.i128_align.abi,\n                     _ => panic!(\"unsupported integer: {:?}\", self)\n                 }\n             }\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => dl.f32_align,\n-                    64 => dl.f64_align,\n+                    32 => dl.f32_align.abi,\n+                    64 => dl.f64_align.abi,\n                     _ => panic!(\"unsupported float: {:?}\", self)\n                 }\n             }\n-            RegKind::Vector => dl.vector_align(self.size)\n+            RegKind::Vector => dl.vector_align(self.size).abi,\n         }\n     }\n }\n@@ -227,13 +227,13 @@ impl CastTarget {\n \n     pub fn size<C: HasDataLayout>(&self, cx: &C) -> Size {\n         (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n-             .abi_align(self.rest.align(cx)) + self.rest.total\n+             .align_to(self.rest.align(cx)) + self.rest.total\n     }\n \n     pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.prefix.iter()\n             .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n-            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+            .fold(cx.data_layout().aggregate_align.abi.max(self.rest.align(cx)),\n                 |acc, align| acc.max(align))\n     }\n }\n@@ -369,7 +369,7 @@ impl<'a, Ty> ArgType<'a, Ty> {\n         attrs.pointee_size = self.layout.size;\n         // FIXME(eddyb) We should be doing this, but at least on\n         // i686-pc-windows-msvc, it results in wrong stack offsets.\n-        // attrs.pointee_align = Some(self.layout.align);\n+        // attrs.pointee_align = Some(self.layout.align.abi);\n \n         let extra_attrs = if self.layout.is_unsized() {\n             Some(ArgAttributes::new())"}, {"sha": "a71f3226320888e6d2faeb619596354a742fc722", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -27,21 +27,21 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n {\n     let dl = cx.data_layout();\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if !offset.is_abi_aligned(align) {\n+        if !offset.is_aligned(align) {\n             arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)"}, {"sha": "99f07c5702a8f21cc1b172091c06216dc13f6938", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -13,7 +13,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n-use abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::{Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -120,8 +120,8 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     } else {\n         // Aggregates larger than a doubleword should be padded\n         // at the tail to fill out a whole number of doublewords.\n-        let align = Align::from_bits(64, 64).unwrap();\n-        (Reg::i64(), size.abi_align(align))\n+        let reg_i64 = Reg::i64();\n+        (reg_i64, size.align_to(reg_i64.align(cx)))\n     };\n \n     arg.cast_to(Uniform {"}, {"sha": "abe0bd07892d90be5714c6727e9b733e91ea3bb1", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -27,21 +27,21 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n {\n     let dl = cx.data_layout();\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if !offset.is_abi_aligned(align) {\n+        if !offset.is_aligned(align) {\n             arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)"}, {"sha": "f091f80924d5937d3e32e10fd82f13ddc2b66da3", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -41,7 +41,7 @@ fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgType<'a, Ty>)\n         where Ty: TyLayoutMethods<'a, C> + Copy,\n             C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n     {\n-        if !off.is_abi_aligned(layout.align) {\n+        if !off.is_aligned(layout.align.abi) {\n             if !layout.is_zst() {\n                 return Err(Memory);\n             }"}, {"sha": "50ce0ad6915da3c9916c1c99ad1d754932590048", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 106, "deletions": 110, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -13,7 +13,7 @@ pub use self::Primitive::*;\n \n use spec::Target;\n \n-use std::{cmp, fmt};\n+use std::fmt;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -24,42 +24,44 @@ pub mod call;\n /// for a target, which contains everything needed to compute layouts.\n pub struct TargetDataLayout {\n     pub endian: Endian,\n-    pub i1_align: Align,\n-    pub i8_align: Align,\n-    pub i16_align: Align,\n-    pub i32_align: Align,\n-    pub i64_align: Align,\n-    pub i128_align: Align,\n-    pub f32_align: Align,\n-    pub f64_align: Align,\n+    pub i1_align: AbiAndPrefAlign,\n+    pub i8_align: AbiAndPrefAlign,\n+    pub i16_align: AbiAndPrefAlign,\n+    pub i32_align: AbiAndPrefAlign,\n+    pub i64_align: AbiAndPrefAlign,\n+    pub i128_align: AbiAndPrefAlign,\n+    pub f32_align: AbiAndPrefAlign,\n+    pub f64_align: AbiAndPrefAlign,\n     pub pointer_size: Size,\n-    pub pointer_align: Align,\n-    pub aggregate_align: Align,\n+    pub pointer_align: AbiAndPrefAlign,\n+    pub aggregate_align: AbiAndPrefAlign,\n \n     /// Alignments for vector types.\n-    pub vector_align: Vec<(Size, Align)>,\n+    pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n+\n     pub instruction_address_space: u32,\n }\n \n impl Default for TargetDataLayout {\n     /// Creates an instance of `TargetDataLayout`.\n     fn default() -> TargetDataLayout {\n+        let align = |bits| Align::from_bits(bits).unwrap();\n         TargetDataLayout {\n             endian: Endian::Big,\n-            i1_align: Align::from_bits(8, 8).unwrap(),\n-            i8_align: Align::from_bits(8, 8).unwrap(),\n-            i16_align: Align::from_bits(16, 16).unwrap(),\n-            i32_align: Align::from_bits(32, 32).unwrap(),\n-            i64_align: Align::from_bits(32, 64).unwrap(),\n-            i128_align: Align::from_bits(32, 64).unwrap(),\n-            f32_align: Align::from_bits(32, 32).unwrap(),\n-            f64_align: Align::from_bits(64, 64).unwrap(),\n+            i1_align: AbiAndPrefAlign::new(align(8)),\n+            i8_align: AbiAndPrefAlign::new(align(8)),\n+            i16_align: AbiAndPrefAlign::new(align(16)),\n+            i32_align: AbiAndPrefAlign::new(align(32)),\n+            i64_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            i128_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            f32_align: AbiAndPrefAlign::new(align(32)),\n+            f64_align: AbiAndPrefAlign::new(align(64)),\n             pointer_size: Size::from_bits(64),\n-            pointer_align: Align::from_bits(64, 64).unwrap(),\n-            aggregate_align: Align::from_bits(0, 64).unwrap(),\n+            pointer_align: AbiAndPrefAlign::new(align(64)),\n+            aggregate_align: AbiAndPrefAlign { abi: align(0), pref: align(64) },\n             vector_align: vec![\n-                (Size::from_bits(64), Align::from_bits(64, 64).unwrap()),\n-                (Size::from_bits(128), Align::from_bits(128, 128).unwrap())\n+                (Size::from_bits(64), AbiAndPrefAlign::new(align(64))),\n+                (Size::from_bits(128), AbiAndPrefAlign::new(align(128))),\n             ],\n             instruction_address_space: 0,\n         }\n@@ -94,11 +96,17 @@ impl TargetDataLayout {\n             if s.is_empty() {\n                 return Err(format!(\"missing alignment for `{}` in \\\"data-layout\\\"\", cause));\n             }\n+            let align_from_bits = |bits| {\n+                Align::from_bits(bits).map_err(|err| {\n+                    format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\",\n+                            cause, err)\n+                })\n+            };\n             let abi = parse_bits(s[0], \"alignment\", cause)?;\n             let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n-            Align::from_bits(abi, pref).map_err(|err| {\n-                format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\",\n-                        cause, err)\n+            Ok(AbiAndPrefAlign {\n+                abi: align_from_bits(abi)?,\n+                pref: align_from_bits(pref)?,\n             })\n         };\n \n@@ -205,16 +213,15 @@ impl TargetDataLayout {\n         }\n     }\n \n-    pub fn vector_align(&self, vec_size: Size) -> Align {\n+    pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n         for &(size, align) in &self.vector_align {\n             if size == vec_size {\n                 return align;\n             }\n         }\n         // Default to natural alignment, which is what LLVM does.\n         // That is, use the size, rounded up to a power of 2.\n-        let align = vec_size.bytes().next_power_of_two();\n-        Align::from_bytes(align, align).unwrap()\n+        AbiAndPrefAlign::new(Align::from_bytes(vec_size.bytes().next_power_of_two()).unwrap())\n     }\n }\n \n@@ -270,14 +277,14 @@ impl Size {\n     }\n \n     #[inline]\n-    pub fn abi_align(self, align: Align) -> Size {\n-        let mask = align.abi() - 1;\n+    pub fn align_to(self, align: Align) -> Size {\n+        let mask = align.bytes() - 1;\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n     #[inline]\n-    pub fn is_abi_aligned(self, align: Align) -> bool {\n-        let mask = align.abi() - 1;\n+    pub fn is_aligned(self, align: Align) -> bool {\n+        let mask = align.bytes() - 1;\n         self.bytes() & mask == 0\n     }\n \n@@ -358,89 +365,54 @@ impl AddAssign for Size {\n     }\n }\n \n-/// Alignment of a type in bytes, both ABI-mandated and preferred.\n-/// Each field is a power of two, giving the alignment a maximum value\n-/// of 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a\n-/// maximum capacity of 2<sup>29</sup> or 536870912.\n-#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n+/// Alignment of a type in bytes (always a power of two).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Align {\n-    abi_pow2: u8,\n-    pref_pow2: u8,\n+    pow2: u8,\n }\n \n impl Align {\n-    pub fn from_bits(abi: u64, pref: u64) -> Result<Align, String> {\n-        Align::from_bytes(Size::from_bits(abi).bytes(),\n-                          Size::from_bits(pref).bytes())\n-    }\n-\n-    pub fn from_bytes(abi: u64, pref: u64) -> Result<Align, String> {\n-        let log2 = |align: u64| {\n-            // Treat an alignment of 0 bytes like 1-byte alignment.\n-            if align == 0 {\n-                return Ok(0);\n-            }\n-\n-            let mut bytes = align;\n-            let mut pow: u8 = 0;\n-            while (bytes & 1) == 0 {\n-                pow += 1;\n-                bytes >>= 1;\n-            }\n-            if bytes != 1 {\n-                Err(format!(\"`{}` is not a power of 2\", align))\n-            } else if pow > 29 {\n-                Err(format!(\"`{}` is too large\", align))\n-            } else {\n-                Ok(pow)\n-            }\n-        };\n-\n-        Ok(Align {\n-            abi_pow2: log2(abi)?,\n-            pref_pow2: log2(pref)?,\n-        })\n+    pub fn from_bits(bits: u64) -> Result<Align, String> {\n+        Align::from_bytes(Size::from_bits(bits).bytes())\n     }\n \n-    pub fn abi(self) -> u64 {\n-        1 << self.abi_pow2\n-    }\n-\n-    pub fn pref(self) -> u64 {\n-        1 << self.pref_pow2\n-    }\n+    pub fn from_bytes(align: u64) -> Result<Align, String> {\n+        // Treat an alignment of 0 bytes like 1-byte alignment.\n+        if align == 0 {\n+            return Ok(Align { pow2: 0 });\n+        }\n \n-    pub fn abi_bits(self) -> u64 {\n-        self.abi() * 8\n-    }\n+        let mut bytes = align;\n+        let mut pow2: u8 = 0;\n+        while (bytes & 1) == 0 {\n+            pow2 += 1;\n+            bytes >>= 1;\n+        }\n+        if bytes != 1 {\n+            return Err(format!(\"`{}` is not a power of 2\", align));\n+        }\n+        if pow2 > 29 {\n+            return Err(format!(\"`{}` is too large\", align));\n+        }\n \n-    pub fn pref_bits(self) -> u64 {\n-        self.pref() * 8\n+        Ok(Align { pow2 })\n     }\n \n-    pub fn min(self, other: Align) -> Align {\n-        Align {\n-            abi_pow2: cmp::min(self.abi_pow2, other.abi_pow2),\n-            pref_pow2: cmp::min(self.pref_pow2, other.pref_pow2),\n-        }\n+    pub fn bytes(self) -> u64 {\n+        1 << self.pow2\n     }\n \n-    pub fn max(self, other: Align) -> Align {\n-        Align {\n-            abi_pow2: cmp::max(self.abi_pow2, other.abi_pow2),\n-            pref_pow2: cmp::max(self.pref_pow2, other.pref_pow2),\n-        }\n+    pub fn bits(self) -> u64 {\n+        self.bytes() * 8\n     }\n \n     /// Compute the best alignment possible for the given offset\n     /// (the largest power of two that the offset is a multiple of).\n     ///\n     /// NB: for an offset of `0`, this happens to return `2^64`.\n     pub fn max_for_offset(offset: Size) -> Align {\n-        let pow2 = offset.bytes().trailing_zeros() as u8;\n         Align {\n-            abi_pow2: pow2,\n-            pref_pow2: pow2,\n+            pow2: offset.bytes().trailing_zeros() as u8,\n         }\n     }\n \n@@ -451,6 +423,36 @@ impl Align {\n     }\n }\n \n+/// A pair of aligments, ABI-mandated and preferred.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct AbiAndPrefAlign {\n+    pub abi: Align,\n+    pub pref: Align,\n+}\n+\n+impl AbiAndPrefAlign {\n+    pub fn new(align: Align) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign {\n+            abi: align,\n+            pref: align,\n+        }\n+    }\n+\n+    pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign {\n+            abi: self.abi.min(other.abi),\n+            pref: self.pref.min(other.pref),\n+        }\n+    }\n+\n+    pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign {\n+            abi: self.abi.max(other.abi),\n+            pref: self.pref.max(other.pref),\n+        }\n+    }\n+}\n+\n /// Integers, also used for enum discriminants.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Integer {\n@@ -472,7 +474,7 @@ impl Integer {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -507,26 +509,24 @@ impl Integer {\n     }\n \n     /// Find the smallest integer with the given alignment.\n-    pub fn for_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Option<Integer> {\n+    pub fn for_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Option<Integer> {\n         let dl = cx.data_layout();\n \n-        let wanted = align.abi();\n         for &candidate in &[I8, I16, I32, I64, I128] {\n-            if wanted == candidate.align(dl).abi() && wanted == candidate.size().bytes() {\n+            if wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes() {\n                 return Some(candidate);\n             }\n         }\n         None\n     }\n \n     /// Find the largest integer with the given alignment or less.\n-    pub fn approximate_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Integer {\n+    pub fn approximate_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Integer {\n         let dl = cx.data_layout();\n \n-        let wanted = align.abi();\n         // FIXME(eddyb) maybe include I128 in the future, when it works everywhere.\n         for &candidate in &[I64, I32, I16] {\n-            if wanted >= candidate.align(dl).abi() && wanted >= candidate.size().bytes() {\n+            if wanted >= candidate.align(dl).abi && wanted.bytes() >= candidate.size().bytes() {\n                 return candidate;\n             }\n         }\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> Primitive {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -868,7 +868,7 @@ pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n     pub size: Size\n }\n \n@@ -949,8 +949,4 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n             Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n         }\n     }\n-\n-    pub fn size_and_align(&self) -> (Size, Align) {\n-        (self.size, self.align)\n-    }\n }"}, {"sha": "75ba4d9bd1105dbe6a2f1dd0a10cc9d6a80cdf7c", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -414,6 +414,8 @@ supported_targets! {\n     (\"riscv32imac-unknown-none-elf\", riscv32imac_unknown_none_elf),\n \n     (\"aarch64-unknown-none\", aarch64_unknown_none),\n+\n+    (\"x86_64-fortanix-unknown-sgx\", x86_64_fortanix_unknown_sgx),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target.\n@@ -685,6 +687,10 @@ pub struct TargetOptions {\n     /// target features. This is `true` by default, and `false` for targets like\n     /// wasm32 where the whole program either has simd or not.\n     pub simd_types_indirect: bool,\n+\n+    /// If set, have the linker export exactly these symbols, instead of using\n+    /// the usual logic to figure this out from the crate itself.\n+    pub override_export_symbols: Option<Vec<String>>\n }\n \n impl Default for TargetOptions {\n@@ -765,6 +771,7 @@ impl Default for TargetOptions {\n             emit_debug_gdb_scripts: true,\n             requires_uwtable: false,\n             simd_types_indirect: true,\n+            override_export_symbols: None,\n         }\n     }\n }\n@@ -900,6 +907,14 @@ impl Target {\n                         )\n                     );\n             } );\n+            ($key_name:ident, opt_list) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name[..]).map(|o| o.as_array()\n+                    .map(|v| base.options.$key_name = Some(v.iter()\n+                        .map(|a| a.as_string().unwrap().to_string()).collect())\n+                        )\n+                    );\n+            } );\n             ($key_name:ident, optional) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(o) = obj.find(&name[..]) {\n@@ -1046,6 +1061,7 @@ impl Target {\n         key!(emit_debug_gdb_scripts, bool);\n         key!(requires_uwtable, bool);\n         key!(simd_types_indirect, bool);\n+        key!(override_export_symbols, opt_list);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -1255,6 +1271,7 @@ impl ToJson for Target {\n         target_option_val!(emit_debug_gdb_scripts);\n         target_option_val!(requires_uwtable);\n         target_option_val!(simd_types_indirect);\n+        target_option_val!(override_export_symbols);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "07383b3d64862430b332413b5490cad227025756", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter;\n+\n+use super::{LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+\n+pub fn target() -> Result<Target, String> {\n+    const PRE_LINK_ARGS: &[&str] = &[\n+        \"-Wl,--as-needed\",\n+        \"-Wl,-z,noexecstack\",\n+        \"-m64\",\n+         \"-fuse-ld=gold\",\n+         \"-nostdlib\",\n+         \"-shared\",\n+         \"-Wl,-e,sgx_entry\",\n+         \"-Wl,-Bstatic\",\n+         \"-Wl,--gc-sections\",\n+         \"-Wl,-z,text\",\n+         \"-Wl,-z,norelro\",\n+         \"-Wl,--rosegment\",\n+         \"-Wl,--no-undefined\",\n+         \"-Wl,--error-unresolved-symbols\",\n+         \"-Wl,--no-undefined-version\",\n+         \"-Wl,-Bsymbolic\",\n+         \"-Wl,--export-dynamic\",\n+    ];\n+    const EXPORT_SYMBOLS: &[&str] = &[\n+        \"sgx_entry\",\n+        \"HEAP_BASE\",\n+        \"HEAP_SIZE\",\n+        \"RELA\",\n+        \"RELACOUNT\",\n+        \"ENCLAVE_SIZE\",\n+        \"CFGDATA_BASE\",\n+        \"DEBUG\",\n+    ];\n+    let opts = TargetOptions {\n+        dynamic_linking: false,\n+        executables: true,\n+        linker_is_gnu: true,\n+        max_atomic_width: Some(64),\n+        panic_strategy: PanicStrategy::Abort,\n+        cpu: \"x86-64\".into(),\n+        position_independent_executables: true,\n+        pre_link_args: iter::once(\n+                (LinkerFlavor::Gcc, PRE_LINK_ARGS.iter().cloned().map(String::from).collect())\n+        ).collect(),\n+        override_export_symbols: Some(EXPORT_SYMBOLS.iter().cloned().map(String::from).collect()),\n+        ..Default::default()\n+    };\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-linux-gnu\".into(),\n+        target_endian: \"little\".into(),\n+        target_pointer_width: \"64\".into(),\n+        target_c_int_width: \"32\".into(),\n+        target_os: \"unknown\".into(),\n+        target_env: \"sgx\".into(),\n+        target_vendor: \"fortanix\".into(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".into(),\n+        arch: \"x86_64\".into(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: opts,\n+    })\n+}"}, {"sha": "a8164c85e821deb3d8596e8fd0b0d5561dd3cb15", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 121, "deletions": 60, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -182,7 +182,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n-        let (substs, assoc_bindings) = item_segment.with_generic_args(|generic_args| {\n+        let (substs, assoc_bindings, _) = item_segment.with_generic_args(|generic_args| {\n             self.create_substs_for_ast_path(\n                 span,\n                 def_id,\n@@ -256,7 +256,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             },\n             def.parent.is_none() && def.has_self, // `has_self`\n             seg.infer_types || suppress_mismatch, // `infer_types`\n-        )\n+        ).0\n     }\n \n     /// Check that the correct number of generic arguments have been provided.\n@@ -269,7 +269,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_types: bool,\n-    ) -> bool {\n+    ) -> (bool, Option<Vec<Span>>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -303,13 +303,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     let mut err = tcx.sess.struct_span_err(span, msg);\n                     err.span_note(span_late, note);\n                     err.emit();\n-                    return true;\n+                    return (true, None);\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n                     tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n                                   args.args[0].id(), multispan, msg);\n-                    return false;\n+                    return (false, None);\n                 }\n             }\n         }\n@@ -323,7 +323,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n             // For other kinds (i.e. types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n-                return false;\n+                return (false, None);\n             }\n \n             // Unfortunately lifetime and type parameter mismatches are typically styled\n@@ -338,33 +338,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 (required, \"\")\n             };\n \n-            let mut span = span;\n-            let label = if required == permitted && provided > permitted {\n-                let diff = provided - permitted;\n-                if diff == 1 {\n-                    // In the case when the user has provided too many arguments,\n-                    // we want to point to the first unexpected argument.\n-                    let first_superfluous_arg: &GenericArg = &args.args[offset + permitted];\n-                    span = first_superfluous_arg.span();\n-                }\n-                format!(\n-                    \"{}unexpected {} argument{}\",\n-                    if diff != 1 { format!(\"{} \", diff) } else { String::new() },\n-                    kind,\n-                    if diff != 1 { \"s\" } else { \"\" },\n-                )\n+            let mut potential_assoc_types: Option<Vec<Span>> = None;\n+            let (spans, label) = if required == permitted && provided > permitted {\n+                // In the case when the user has provided too many arguments,\n+                // we want to point to the unexpected arguments.\n+                let spans: Vec<Span> = args.args[offset+permitted .. offset+provided]\n+                        .iter()\n+                        .map(|arg| arg.span())\n+                        .collect();\n+                potential_assoc_types = Some(spans.clone());\n+                (spans, format!( \"unexpected {} argument\", kind))\n             } else {\n-                format!(\n+                (vec![span], format!(\n                     \"expected {}{} {} argument{}\",\n                     quantifier,\n                     bound,\n                     kind,\n                     if bound != 1 { \"s\" } else { \"\" },\n-                )\n+                ))\n             };\n \n-            tcx.sess.struct_span_err_with_code(\n-                span,\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                spans.clone(),\n                 &format!(\n                     \"wrong number of {} arguments: expected {}{}, found {}\",\n                     kind,\n@@ -373,9 +368,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     provided,\n                 ),\n                 DiagnosticId::Error(\"E0107\".into())\n-            ).span_label(span, label).emit();\n+            );\n+            for span in spans {\n+                err.span_label(span, label.as_str());\n+            }\n+            err.emit();\n \n-            provided > required // `suppress_error`\n+            (provided > required, // `suppress_error`\n+             potential_assoc_types)\n         };\n \n         if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n@@ -397,7 +397,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 arg_counts.lifetimes,\n             )\n         } else {\n-            false\n+            (false, None)\n         }\n     }\n \n@@ -555,7 +555,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         generic_args: &hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n-        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n     {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -571,7 +571,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(generic_params.has_self, self_ty.is_some());\n \n         let has_self = generic_params.has_self;\n-        Self::check_generic_arg_count(\n+        let (_, potential_assoc_types) = Self::check_generic_arg_count(\n             self.tcx(),\n             span,\n             &generic_params,\n@@ -676,7 +676,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n                generic_params, self_ty, substs);\n \n-        (substs, assoc_bindings)\n+        (substs, assoc_bindings, potential_assoc_types)\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n@@ -718,19 +718,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n         speculative: bool)\n-        -> ty::PolyTraitRef<'tcx>\n+        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n-                                                 trait_def_id,\n-                                                 self_ty,\n-                                                 trait_ref.path.segments.last().unwrap());\n+        let (substs, assoc_bindings, potential_assoc_types) = self.create_substs_for_ast_trait_ref(\n+            trait_ref.path.span,\n+            trait_def_id,\n+            self_ty,\n+            trait_ref.path.segments.last().unwrap(),\n+        );\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -745,14 +746,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n                trait_ref, poly_projections, poly_trait_ref);\n-        poly_trait_ref\n+        (poly_trait_ref, potential_assoc_types)\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n-        -> ty::PolyTraitRef<'tcx>\n+        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n                                               poly_projections, false)\n@@ -765,7 +766,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n-        let (substs, assoc_bindings) =\n+        let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span,\n                                                  trait_def_id,\n                                                  self_ty,\n@@ -774,13 +775,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref(&self,\n-                                       span: Span,\n-                                       trait_def_id: DefId,\n-                                       self_ty: Ty<'tcx>,\n-                                       trait_segment: &hir::PathSegment)\n-                                       -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n-    {\n+    fn create_substs_for_ast_trait_ref(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &hir::PathSegment,\n+    ) -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n@@ -970,9 +971,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n-                                                        dummy_self,\n-                                                        &mut projection_bounds);\n+        let (principal, potential_assoc_types) = self.instantiate_poly_trait_ref(\n+            &trait_bounds[0],\n+            dummy_self,\n+            &mut projection_bounds,\n+        );\n         debug!(\"principal: {:?}\", principal);\n \n         for trait_bound in trait_bounds[1..].iter() {\n@@ -1027,16 +1030,74 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n-        for item_def_id in associated_types {\n-            let assoc_item = tcx.associated_item(item_def_id);\n-            let trait_def_id = assoc_item.container.id();\n-            struct_span_err!(tcx.sess, span, E0191, \"the value of the associated type `{}` \\\n-                                                     (from the trait `{}`) must be specified\",\n-                                                    assoc_item.ident,\n-                                                    tcx.item_path_str(trait_def_id))\n-                .span_label(span, format!(\"missing associated type `{}` value\",\n-                                          assoc_item.ident))\n-                .emit();\n+        if !associated_types.is_empty() {\n+            let names = associated_types.iter().map(|item_def_id| {\n+                let assoc_item = tcx.associated_item(*item_def_id);\n+                let trait_def_id = assoc_item.container.id();\n+                format!(\n+                    \"`{}` (from the trait `{}`)\",\n+                    assoc_item.ident,\n+                    tcx.item_path_str(trait_def_id),\n+                )\n+            }).collect::<Vec<_>>().join(\", \");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0191,\n+                \"the value of the associated type{} {} must be specified\",\n+                if associated_types.len() == 1 { \"\" } else { \"s\" },\n+                names,\n+            );\n+            let mut suggest = false;\n+            let mut potential_assoc_types_spans = vec![];\n+            if let Some(potential_assoc_types) = potential_assoc_types {\n+                if potential_assoc_types.len() == associated_types.len() {\n+                    // Only suggest when the amount of missing associated types is equals to the\n+                    // extra type arguments present, as that gives us a relatively high confidence\n+                    // that the user forgot to give the associtated type's name. The canonical\n+                    // example would be trying to use `Iterator<isize>` instead of\n+                    // `Iterator<Item=isize>`.\n+                    suggest = true;\n+                    potential_assoc_types_spans = potential_assoc_types;\n+                }\n+            }\n+            let mut suggestions = vec![];\n+            for (i, item_def_id) in associated_types.iter().enumerate() {\n+                let assoc_item = tcx.associated_item(*item_def_id);\n+                err.span_label(\n+                    span,\n+                    format!(\"associated type `{}` must be specified\", assoc_item.ident),\n+                );\n+                if item_def_id.is_local() {\n+                    err.span_label(\n+                        tcx.def_span(*item_def_id),\n+                        format!(\"`{}` defined here\", assoc_item.ident),\n+                    );\n+                }\n+                if suggest {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(\n+                        potential_assoc_types_spans[i],\n+                    ) {\n+                        suggestions.push((\n+                            potential_assoc_types_spans[i],\n+                            format!(\"{} = {}\", assoc_item.ident, snippet),\n+                        ));\n+                    }\n+                }\n+            }\n+            if !suggestions.is_empty() {\n+                let msg = if suggestions.len() == 1 {\n+                    \"if you meant to specify the associated type, write\"\n+                } else {\n+                    \"if you meant to specify the associated types, write\"\n+                };\n+                err.multipart_suggestion_with_applicability(\n+                    msg,\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            err.emit();\n         }\n \n         // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above."}, {"sha": "e36c0ae2a1902270b9e57c6f060e9a2b025e1abc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -643,11 +643,11 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             },\n             infcx,\n             fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n-            locals: RefCell::new(NodeMap()),\n-            deferred_call_resolutions: RefCell::new(DefIdMap()),\n+            locals: RefCell::new(Default::default()),\n+            deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n-            opaque_types: RefCell::new(DefIdMap()),\n+            opaque_types: RefCell::new(Default::default()),\n             implicit_region_bound,\n             body_id,\n         }\n@@ -1779,7 +1779,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n         // We are currently checking the type this field came from, so it must be local\n         let span = tcx.hir.span_if_local(field.did).unwrap();\n         let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n-        let align1 = layout.map(|layout| layout.align.abi() == 1).unwrap_or(false);\n+        let align1 = layout.map(|layout| layout.align.abi.bytes() == 1).unwrap_or(false);\n         (span, zst, align1)\n     });\n \n@@ -1986,7 +1986,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),\n-                by_id: NodeMap(),\n+                by_id: Default::default(),\n             }),\n             inh,\n         }"}, {"sha": "50f54bba3fd208a75f3be6314ccb84c8098dce84", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let used_trait_imports = mem::replace(\n             &mut self.tables.borrow_mut().used_trait_imports,\n-            Lrc::new(DefIdSet()),\n+            Lrc::new(DefIdSet::default()),\n         );\n         debug!(\n             \"used_trait_imports({:?}) = {:?}\","}, {"sha": "22a96d4e908cae6f4e4a9e781d8e3364ad942b40", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::fx::FxHashMap;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut used_trait_imports = DefIdSet();\n+    let mut used_trait_imports = DefIdSet::default();\n     for &body_id in tcx.hir.krate().bodies.keys() {\n         let item_def_id = tcx.hir.body_owner_def_id(body_id);\n         let imports = tcx.used_trait_imports(item_def_id);"}, {"sha": "d9dff1441296d210d4b0a9bbb0990085fb53a772", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n-use rustc::util::nodemap::DefIdMap;\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n@@ -37,9 +36,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.hir.krate();\n     let mut collect = InherentCollect {\n         tcx,\n-        impls_map: CrateInherentImpls {\n-            inherent_impls: DefIdMap()\n-        }\n+        impls_map: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut collect);\n     Lrc::new(collect.impls_map)"}, {"sha": "a1bb0b53f1fce38a0d5f4275c0f067a5dd9631dc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1892,7 +1892,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n-                            let trait_ref = AstConv::instantiate_poly_trait_ref(\n+                            let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n@@ -2016,7 +2016,12 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     let mut projection_bounds = Vec::new();\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)\n+        let (poly_trait_ref, _) = astconv.instantiate_poly_trait_ref(\n+            bound,\n+            param_ty,\n+            &mut projection_bounds,\n+        );\n+        (poly_trait_ref, bound.span)\n     }).collect();\n \n     let region_bounds = region_bounds\n@@ -2057,7 +2062,7 @@ fn predicates_from_bound<'tcx>(\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n+            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n             iter::once((pred.to_predicate(), tr.span)).chain(\n                 projections\n                     .into_iter()"}, {"sha": "0fba311d7f7d5ea49255865419b25c2fea9f58f5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -389,7 +389,7 @@ pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait:\n     let env_def_id = tcx.hir.local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut projections = Vec::new();\n-    let principal = astconv::AstConv::instantiate_poly_trait_ref_inner(\n+    let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner(\n         &item_cx, hir_trait, tcx.types.err, &mut projections, true\n     );\n "}, {"sha": "087d53b92d4965d12f72586f86cd204ff15c2d2a", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -81,7 +81,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     let mut terms_cx = TermsContext {\n         tcx,\n         arena,\n-        inferred_starts: NodeMap(),\n+        inferred_starts: Default::default(),\n         inferred_terms: vec![],\n \n         lang_items: lang_items(tcx),"}, {"sha": "aac0f9f94e32933ee7dafb0e97c05f594d2e0b2d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -351,13 +351,15 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n+    let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n     let mut whitelisted_lints = vec![warnings_lint_name.to_owned(),\n                                      intra_link_resolution_failure_name.to_owned(),\n                                      missing_docs.to_owned(),\n-                                     missing_doc_example.to_owned()];\n+                                     missing_doc_example.to_owned(),\n+                                     private_doc_tests.to_owned()];\n \n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n "}, {"sha": "7183cfe5711929e19c594124f08b4624f07d5f70", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -24,9 +24,9 @@ use std::ops::Range;\n \n use core::DocContext;\n use fold::DocFolder;\n-use html::markdown::{find_testable_code, markdown_links, ErrorCodes, LangString};\n+use html::markdown::markdown_links;\n \n-use passes::Pass;\n+use passes::{look_for_tests, Pass};\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass =\n     Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n@@ -214,43 +214,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n     }\n }\n \n-fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx>(\n-    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n-    dox: &str,\n-    item: &Item,\n-) {\n-    if (item.is_mod() && cx.tcx.hir.as_local_node_id(item.def_id).is_none()) ||\n-       cx.as_local_node_id(item.def_id).is_none() {\n-        // If non-local, no need to check anything.\n-        return;\n-    }\n-\n-    struct Tests {\n-        found_tests: usize,\n-    }\n-\n-    impl ::test::Tester for Tests {\n-        fn add_test(&mut self, _: String, _: LangString, _: usize) {\n-            self.found_tests += 1;\n-        }\n-    }\n-\n-    let mut tests = Tests {\n-        found_tests: 0,\n-    };\n-\n-    if find_testable_code(&dox, &mut tests, ErrorCodes::No).is_ok() {\n-        if tests.found_tests == 0 {\n-            let mut diag = cx.tcx.struct_span_lint_node(\n-                lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-                NodeId::from_u32(0),\n-                span_of_attrs(&item.attrs),\n-                \"Missing code example in this documentation\");\n-            diag.emit();\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_node_id = if item.is_mod() {\n@@ -313,7 +276,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n         let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n \n-        look_for_tests(&cx, &dox, &item);\n+        look_for_tests(&cx, &dox, &item, true);\n \n         if !self.is_nightly_build {\n             return None;\n@@ -488,7 +451,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     None\n }\n \n-fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n+pub fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n     if attrs.doc_strings.is_empty() {\n         return DUMMY_SP;\n     }"}, {"sha": "eee7278e4f0a910e2819a16a3a920d54dfa9cd4f", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -12,16 +12,22 @@\n //! process.\n \n use rustc::hir::def_id::DefId;\n+use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n use std::fmt;\n+use syntax::ast::NodeId;\n \n use clean::{self, GetDefId, Item};\n-use core::DocContext;\n+use core::{DocContext, DocAccessLevels};\n use fold;\n use fold::StripItem;\n \n+use html::markdown::{find_testable_code, ErrorCodes, LangString};\n+\n+use self::collect_intra_doc_links::span_of_attrs;\n+\n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n \n@@ -43,6 +49,9 @@ pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n mod collect_intra_doc_links;\n pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n+mod private_items_doc_tests;\n+pub use self::private_items_doc_tests::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n+\n mod collect_trait_impls;\n pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n@@ -128,6 +137,7 @@ impl Pass {\n \n /// The full list of passes.\n pub const PASSES: &'static [Pass] = &[\n+    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n     COLLAPSE_DOCS,\n@@ -141,6 +151,7 @@ pub const PASSES: &'static [Pass] = &[\n /// The list of passes run by default.\n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"collect-trait-impls\",\n+    \"check-private-items-doc-tests\",\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collect-intra-doc-links\",\n@@ -152,6 +163,7 @@ pub const DEFAULT_PASSES: &'static [&'static str] = &[\n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n     \"collect-trait-impls\",\n+    \"check-private-items-doc-tests\",\n     \"strip-priv-imports\",\n     \"collect-intra-doc-links\",\n     \"collapse-docs\",\n@@ -348,3 +360,49 @@ impl fold::DocFolder for ImportStripper {\n         }\n     }\n }\n+\n+pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx>(\n+    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+    dox: &str,\n+    item: &Item,\n+    check_missing_code: bool,\n+) {\n+    if cx.as_local_node_id(item.def_id).is_none() {\n+        // If non-local, no need to check anything.\n+        return;\n+    }\n+\n+    struct Tests {\n+        found_tests: usize,\n+    }\n+\n+    impl ::test::Tester for Tests {\n+        fn add_test(&mut self, _: String, _: LangString, _: usize) {\n+            self.found_tests += 1;\n+        }\n+    }\n+\n+    let mut tests = Tests {\n+        found_tests: 0,\n+    };\n+\n+    if find_testable_code(&dox, &mut tests, ErrorCodes::No).is_ok() {\n+        if check_missing_code == true && tests.found_tests == 0 {\n+            let mut diag = cx.tcx.struct_span_lint_node(\n+                lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n+                NodeId::from_u32(0),\n+                span_of_attrs(&item.attrs),\n+                \"Missing code example in this documentation\");\n+            diag.emit();\n+        } else if check_missing_code == false &&\n+                  tests.found_tests > 0 &&\n+                  !cx.renderinfo.borrow().access_levels.is_doc_reachable(item.def_id) {\n+            let mut diag = cx.tcx.struct_span_lint_node(\n+                lint::builtin::PRIVATE_DOC_TESTS,\n+                NodeId::from_u32(0),\n+                span_of_attrs(&item.attrs),\n+                \"Documentation test in private item\");\n+            diag.emit();\n+        }\n+    }\n+}"}, {"sha": "7c5ce8894b1065c6305c1144092be145555626ee", "filename": "src/librustdoc/passes/private_items_doc_tests.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean::*;\n+\n+use core::DocContext;\n+use fold::DocFolder;\n+\n+use passes::{look_for_tests, Pass};\n+\n+pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass =\n+    Pass::early(\"check-private-items-doc-tests\", check_private_items_doc_tests,\n+                \"check private items doc tests\");\n+\n+struct PrivateItemDocTestLinter<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n+    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> PrivateItemDocTestLinter<'a, 'tcx, 'rcx, 'cstore> {\n+    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>) -> Self {\n+        PrivateItemDocTestLinter {\n+            cx,\n+        }\n+    }\n+}\n+\n+pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext) -> Crate {\n+    let mut coll = PrivateItemDocTestLinter::new(cx);\n+\n+    coll.fold_crate(krate)\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for PrivateItemDocTestLinter<'a, 'tcx, 'rcx, 'cstore> {\n+    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+        let cx = self.cx;\n+        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+\n+        look_for_tests(&cx, &dox, &item, false);\n+\n+        self.fold_item_recur(item)\n+    }\n+}"}, {"sha": "946c5c5fa9bc2de4ce0e4c31cd3f6ba7cafb8662", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -25,7 +25,7 @@ pub const STRIP_HIDDEN: Pass =\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate, _: &DocContext) -> clean::Crate {\n-    let mut retained = DefIdSet();\n+    let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items\n     let krate = {"}, {"sha": "e9d927398e44bd90bca4cb34fabcde852e2c57d1", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -24,7 +24,7 @@ pub const STRIP_PRIVATE: Pass =\n /// crate, specified by the `xcrate` flag.\n pub fn strip_private(mut krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n-    let mut retained = DefIdSet();\n+    let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();\n \n     // strip all private items"}, {"sha": "d4650bd68d637de38bd3994601ec5a7b3db0d585", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -2026,12 +2026,12 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 3);\n+    /// assert_eq!(map[\"poneyland\"], 3);\n     ///\n-    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12).1 += 10;\n-    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n+    /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n     #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n@@ -2648,12 +2648,12 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// map.entry(\"poneyland\").or_insert(3);\n+    /// assert_eq!(map[\"poneyland\"], 3);\n     ///\n-    /// *map.entry(\"poneyland\").or_insert(12) += 10;\n-    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// *map.entry(\"poneyland\").or_insert(10) *= 2;\n+    /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {"}, {"sha": "575903d576a23552b09d592fbb0301e6ffac1917", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -185,7 +185,7 @@\n //! [slice]: primitive.slice.html\n //! [`atomic`]: sync/atomic/index.html\n //! [`collections`]: collections/index.html\n-//! [`for`]: ../book/first-edition/loops.html#for\n+//! [`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n //! [`format!`]: macro.format.html\n //! [`fs`]: fs/index.html\n //! [`io`]: io/index.html\n@@ -200,14 +200,14 @@\n //! [`sync`]: sync/index.html\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n-//! [`use`]: ../book/first-edition/crates-and-modules.html#importing-modules-with-use\n-//! [crate root]: ../book/first-edition/crates-and-modules.html#basic-terminology-crates-and-modules\n+//! [`use`]: ../book/ch07-02-modules-and-use-to-control-scope-and-privacy.html#the-use-keyword-to-bring-paths-into-a-scope\n+//! [crate root]: ../book/ch07-01-packages-and-crates-for-making-libraries-and-executables.html\n //! [crates.io]: https://crates.io\n-//! [deref-coercions]: ../book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n+//! [deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n //! [files]: fs/struct.File.html\n //! [multithreading]: thread/index.html\n //! [other]: #what-is-in-the-standard-library-documentation\n-//! [primitive types]: ../book/first-edition/primitive-types.html\n+//! [primitive types]: ../book/ch03-02-data-types.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "0995ab3c373ca19fc84b82db8b2950de194e78b2", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -32,7 +32,7 @@\n ///\n /// [`Result`] enum is often a better solution for recovering from errors than\n /// using the `panic!` macro.  This macro should be used to avoid proceeding using\n-/// incorrect values, such as from external sources.  Detailed information about\n+/// incorrect values, such as from external sources. Detailed information about\n /// error handling is found in the [book].\n ///\n /// The multi-argument form of this macro panics with a string and has the\n@@ -45,7 +45,7 @@\n /// [`Result`]: ../std/result/enum.Result.html\n /// [`format!`]: ../std/macro.format.html\n /// [`compile_error!`]: ../std/macro.compile_error.html\n-/// [book]: ../book/second-edition/ch09-01-unrecoverable-errors-with-panic.html\n+/// [book]: ../book/ch09-00-error-handling.html\n ///\n /// # Current implementation\n ///\n@@ -839,8 +839,8 @@ mod builtin {\n     /// boolean expression evaluation of configuration flags. This frequently\n     /// leads to less duplicated code.\n     ///\n-    /// The syntax given to this macro is the same syntax as [the `cfg`\n-    /// attribute](../book/first-edition/conditional-compilation.html).\n+    /// The syntax given to this macro is the same syntax as the `cfg`\n+    /// attribute.\n     ///\n     /// # Examples\n     ///\n@@ -915,7 +915,7 @@ mod builtin {\n     /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n     /// violated could lead to unsafety.\n     ///\n-    /// Other use-cases of `assert!` include [testing] and enforcing run-time\n+    /// Other use-cases of `assert!` include testing and enforcing run-time\n     /// invariants in safe code (whose violation cannot result in unsafety).\n     ///\n     /// # Custom Messages\n@@ -926,7 +926,6 @@ mod builtin {\n     ///\n     /// [`panic!`]: macro.panic.html\n     /// [`debug_assert!`]: macro.debug_assert.html\n-    /// [testing]: ../book/second-edition/ch11-01-writing-tests.html#checking-results-with-the-assert-macro\n     /// [`std::fmt`]: ../std/fmt/index.html\n     ///\n     /// # Examples"}, {"sha": "48acc1096a6811494b721d3931e0cfd857fda393", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -22,7 +22,7 @@\n /// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n /// which allow us to perform boolean operations using `&`, `|` and `!`.\n ///\n-/// [`if`] always demands a `bool` value. [`assert!`], being an important macro in testing,\n+/// `if` always demands a `bool` value. [`assert!`], being an important macro in testing,\n /// checks whether an expression returns `true`.\n ///\n /// ```\n@@ -31,7 +31,6 @@\n /// ```\n ///\n /// [`assert!`]: macro.assert.html\n-/// [`if`]: ../book/first-edition/if.html\n /// [`BitAnd`]: ops/trait.BitAnd.html\n /// [`BitOr`]: ops/trait.BitOr.html\n /// [`Not`]: ops/trait.Not.html\n@@ -695,7 +694,7 @@ mod prim_str { }\n /// assert_eq!(tuple.2, 'c');\n /// ```\n ///\n-/// For more about tuples, see [the book](../book/first-edition/primitive-types.html#tuples).\n+/// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n ///\n /// # Trait implementations\n ///"}, {"sha": "2f5db9bd0815535b2eb6850a7076cf4786010ad8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -499,9 +499,6 @@ declare_features! (\n     // Allows `const _: TYPE = VALUE`\n     (active, underscore_const_names, \"1.31.0\", Some(54912), None),\n \n-    // `extern crate foo as bar;` puts `bar` into extern prelude.\n-    (active, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n-\n     // `reason = ` in lint attributes and `expect` lint attribute\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),\n );\n@@ -691,6 +688,8 @@ declare_features! (\n     // impl<I:Iterator> Iterator for &mut Iterator\n     // impl Debug for Foo<'_>\n     (accepted, impl_header_lifetime_elision, \"1.31.0\", Some(15872), None),\n+    // `extern crate foo as bar;` puts `bar` into extern prelude.\n+    (accepted, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must"}, {"sha": "e2f09affd4fea5cd823b6a9d3552aee36b1a06f9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1824,6 +1824,14 @@ impl<'a> Parser<'a> {\n     fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> {\n         maybe_whole!(self, NtArg, |x| x);\n \n+        if let Ok(Some(_)) = self.parse_self_arg() {\n+            let mut err = self.struct_span_err(self.prev_span,\n+                \"unexpected `self` argument in function\");\n+            err.span_label(self.prev_span,\n+                \"`self` is only valid as the first argument of an associated function\");\n+            return Err(err);\n+        }\n+\n         let (pat, ty) = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{})\",\n                    require_name);\n@@ -5385,11 +5393,12 @@ impl<'a> Parser<'a> {\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+\n         let sp = self.span;\n         let mut variadic = false;\n         let args: Vec<Option<Arg>> =\n-            self.parse_unspanned_seq(\n-                &token::OpenDelim(token::Paren),\n+            self.parse_seq_to_before_end(\n                 &token::CloseDelim(token::Paren),\n                 SeqSep::trailing_allowed(token::Comma),\n                 |p| {\n@@ -5436,6 +5445,8 @@ impl<'a> Parser<'a> {\n                 }\n             )?;\n \n+        self.eat(&token::CloseDelim(token::Paren));\n+\n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n         if variadic && args.is_empty() {"}, {"sha": "1e615c4c0db80e9eb20a07365066c09d7d47710e", "filename": "src/test/compile-fail/issue-23595-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -16,9 +16,7 @@ trait Hierarchy {\n     type Value;\n     type ChildKey;\n     type Children = Index<Self::ChildKey, Output=Hierarchy>;\n-    //~^ ERROR: the value of the associated type `ChildKey`\n-    //~^^ ERROR: the value of the associated type `Children`\n-    //~^^^ ERROR: the value of the associated type `Value`\n+    //~^ ERROR: the value of the associated types `Value` (from the trait `Hierarchy`), `ChildKey`\n \n     fn data(&self) -> Option<(Self::Value, Self::Children)>;\n }"}, {"sha": "0d3f4b90f23ed82e34dc2b6dc6bda4f6d8fd94ff", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -28,6 +28,9 @@\n // gdb-command: print vec_deque\n // gdb-check:$3 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n \n+// gdb-command: print vec_deque2\n+// gdb-check:$4 = VecDeque<i32>(len: 7, cap: 8) = {2, 3, 4, 5, 6, 7, 8}\n+\n #![allow(unused_variables)]\n use std::collections::BTreeSet;\n use std::collections::BTreeMap;\n@@ -54,6 +57,14 @@ fn main() {\n     vec_deque.push_back(3);\n     vec_deque.push_back(7);\n \n+    // VecDeque where an element was popped.\n+    let mut vec_deque2 = VecDeque::new();\n+    for i in 1..8 {\n+        vec_deque2.push_back(i)\n+    }\n+    vec_deque2.pop_front();\n+    vec_deque2.push_back(8);\n+\n     zzz(); // #break\n }\n "}, {"sha": "cab7bda6c672153313c07ef41289ba6aec287a16", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', librustdoc/test.rs:323:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:323:13\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 21) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 21)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n-', librustdoc/test.rs:358:17\n+', src/librustdoc/test.rs:358:17\n \n \n failures:"}, {"sha": "5a13fe359f5270869907d13e3755c11bc24295ec", "filename": "src/test/rustdoc-ui/private-item-doc-test.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(private_doc_tests)]\n+\n+mod foo {\n+    /// private doc test\n+    ///\n+    /// ```\n+    /// assert!(false);\n+    /// ```\n+    fn bar() {}\n+}"}, {"sha": "b43add7ea505f24569bfe210a6e97764291963eb", "filename": "src/test/rustdoc-ui/private-item-doc-test.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,16 @@\n+error: Documentation test in private item\n+  --> $DIR/private-item-doc-test.rs:14:5\n+   |\n+LL | /     /// private doc test\n+LL | |     ///\n+LL | |     /// ```\n+LL | |     /// assert!(false);\n+LL | |     /// ```\n+   | |___________^\n+   |\n+note: lint level defined here\n+  --> $DIR/private-item-doc-test.rs:11:9\n+   |\n+LL | #![deny(private_doc_tests)]\n+   |         ^^^^^^^^^^^^^^^^^\n+"}, {"sha": "25a2a37614778e4f4c62b843659154bf79123c61", "filename": "src/test/ui-fulldeps/proc-macro/extern-prelude-extern-crate-proc-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fextern-prelude-extern-crate-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fextern-prelude-extern-crate-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fextern-prelude-extern-crate-proc-macro.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,6 @@\n // compile-pass\n // edition:2018\n \n-#![feature(extern_crate_item_prelude)]\n-\n extern crate proc_macro;\n use proc_macro::TokenStream; // OK\n "}, {"sha": "b4285c0de29d5b09d4bf109ceba08ed7a8c5177a", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -25,8 +25,11 @@ LL | fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n error[E0191]: the value of the associated type `Color` (from the trait `Vehicle`) must be specified\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:33:26\n    |\n+LL |     type Color;\n+   |     ----------- `Color` defined here\n+...\n LL | fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n-   |                          ^^^^^^^^^^^^^^^^^^^ missing associated type `Color` value\n+   |                          ^^^^^^^^^^^^^^^^^^^ associated type `Color` must be specified\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:38:29"}, {"sha": "e575fd695b2db2bcf50b6f703d6df2083f42022a", "filename": "src/test/ui/associated-types/associated-types-incomplete-object.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -37,6 +37,5 @@ pub fn main() {\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n \n     let d = &42isize as &Foo;\n-    //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n-    //~| ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n+    //~^ ERROR the value of the associated types `A` (from the trait `Foo`), `B` (from the trait\n }"}, {"sha": "eb8e6f998a534c84c58834107e54665158b26aea", "filename": "src/test/ui/associated-types/associated-types-incomplete-object.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,27 +1,35 @@\n error[E0191]: the value of the associated type `B` (from the trait `Foo`) must be specified\n   --> $DIR/associated-types-incomplete-object.rs:33:26\n    |\n+LL |     type B;\n+   |     ------- `B` defined here\n+...\n LL |     let b = &42isize as &Foo<A=usize>;\n-   |                          ^^^^^^^^^^^^ missing associated type `B` value\n+   |                          ^^^^^^^^^^^^ associated type `B` must be specified\n \n error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n   --> $DIR/associated-types-incomplete-object.rs:36:26\n    |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n LL |     let c = &42isize as &Foo<B=char>;\n-   |                          ^^^^^^^^^^^ missing associated type `A` value\n+   |                          ^^^^^^^^^^^ associated type `A` must be specified\n \n-error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n-  --> $DIR/associated-types-incomplete-object.rs:39:26\n-   |\n-LL |     let d = &42isize as &Foo;\n-   |                          ^^^ missing associated type `A` value\n-\n-error[E0191]: the value of the associated type `B` (from the trait `Foo`) must be specified\n+error[E0191]: the value of the associated types `A` (from the trait `Foo`), `B` (from the trait `Foo`) must be specified\n   --> $DIR/associated-types-incomplete-object.rs:39:26\n    |\n+LL |     type A;\n+   |     ------- `A` defined here\n+LL |     type B;\n+   |     ------- `B` defined here\n+...\n LL |     let d = &42isize as &Foo;\n-   |                          ^^^ missing associated type `B` value\n+   |                          ^^^\n+   |                          |\n+   |                          associated type `A` must be specified\n+   |                          associated type `B` must be specified\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0191`."}, {"sha": "129177e9a1ae92b550c3f3e87e791797ef3a378e", "filename": "src/test/ui/consts/const-err4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -16,7 +16,7 @@ union Foo {\n \n enum Bar {\n     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-    //~^ ERROR evaluation of constant value failed\n+    //~^ ERROR it is undefined behavior to use this value\n }\n \n fn main() {"}, {"sha": "38a8f75a5c20853b75e7ecd7546c5758cb89a80e", "filename": "src/test/ui/consts/const-err4.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,10 @@\n-error[E0080]: evaluation of constant value failed\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-err4.rs:18:11\n    |\n LL |     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "cc5ddb4401644b8f7ad407070d43a9b4fea07d83", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-    //~^ ERROR any use of this value will cause an error\n+    //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n     //~^ ERROR any use of this value will cause an error\n@@ -52,7 +52,7 @@ fn main() {\n     //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-    //~^ ERROR any use of this value will cause an error\n+    //~^ ERROR it is undefined behavior to use this value\n \n     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n     //~^ ERROR any use of this value will cause an error"}, {"sha": "786338222e3ba8c36149776b5e24251343bb88b7", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -40,11 +40,13 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:39:5\n    |\n LL |     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:42:5\n@@ -78,11 +80,13 @@ LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:54:5\n    |\n LL |     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:57:5"}, {"sha": "2bf85e25a21a1d6f7419fcb2ce683609de9e4301", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -16,12 +16,12 @@ enum Enum {\n     A = 0,\n }\n union TransmuteEnum {\n-    a: &'static u8,\n-    out: Enum,\n+    in1: &'static u8,\n+    out1: Enum,\n }\n \n // A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n //~^ ERROR is undefined behavior\n \n // (Potentially) invalid enum discriminant\n@@ -48,8 +48,8 @@ const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n //~^ ERROR is undefined behavior\n \n-// Undef enum discriminant. In an arry to avoid `Scalar` layout.\n-const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n+// Undef enum discriminant.\n+const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n //~^ ERROR is undefined behavior\n \n // Pointer value in an enum with a niche that is not just 0."}, {"sha": "509faaa46f811aa4f0d517ba6b2895120059e3b6", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,8 @@\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:24:1\n    |\n-LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -33,8 +33,8 @@ LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:52:1\n    |\n-LL | const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at [0], but expected a valid enum discriminant\n+LL | const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "2bdad3af889dcf0f3a1bb409c959dc5d1e382b33", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -34,7 +34,8 @@ const fn read_field2() -> Field2 {\n }\n \n const fn read_field3() -> Field3 {\n-    const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR any use of this value\n+    const FIELD3: Field3 = unsafe { UNION.field3 };\n+    //~^ ERROR it is undefined behavior to use this value\n     FIELD3\n }\n "}, {"sha": "ca7cf2b028ce7e9c21e4c59a8b1d82b0dec5ad06", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,10 +1,11 @@\n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-const-eval-field.rs:37:5\n    |\n-LL |     const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR any use of this value\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+LL |     const FIELD3: Field3 = unsafe { UNION.field3 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n    |\n-   = note: #[deny(const_err)] on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "6bd63472b212a287805c5426772825c2c8f21c70", "filename": "src/test/ui/consts/const-eval/union-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -20,7 +20,7 @@ union DummyUnion {\n \n const UNION: DummyUnion = DummyUnion { field1: 1065353216 };\n \n-const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR will cause an error\n+const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR it is undefined behavior to use this value\n \n const FIELD_PATH: Struct = Struct { //~ ERROR it is undefined behavior to use this value\n     a: 42,"}, {"sha": "7cadef246177a557892fee0bc3c7cf6009d3dd06", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,10 +1,10 @@\n-error: any use of this value will cause an error\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ice.rs:23:1\n    |\n-LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR will cause an error\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR it is undefined behavior to use this value\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\n    |\n-   = note: #[deny(const_err)] on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ice.rs:25:1"}, {"sha": "4278a8e2d0036b51271c3e5111895d148ab5af55", "filename": "src/test/ui/consts/min_const_fn/loop_ice.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,5 @@\n+const fn foo() {\n+    loop {} //~ ERROR loops are not allowed in const fn\n+}\n+\n+fn main() {}"}, {"sha": "1424cea65afd55dd11ac835a708fbac534212c71", "filename": "src/test/ui/consts/min_const_fn/loop_ice.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Floop_ice.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,8 @@\n+error: loops are not allowed in const fn\n+  --> $DIR/loop_ice.rs:2:5\n+   |\n+LL |     loop {} //~ ERROR loops are not allowed in const fn\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "87ac9e37853c01ce518c65a1f7233bea661afec4", "filename": "src/test/ui/error-codes/E0107.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -26,7 +26,8 @@ struct Baz<'a, 'b, 'c> {\n     //~| unexpected lifetime argument\n     foo2: Foo<'a, 'b, 'c>,\n     //~^ ERROR E0107\n-    //~| 2 unexpected lifetime arguments\n+    //~| unexpected lifetime argument\n+    //~| unexpected lifetime argument\n }\n \n fn main() {}"}, {"sha": "a07c92cf26afb06c174a6b381d2b9005c889ed25", "filename": "src/test/ui/error-codes/E0107.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -11,10 +11,12 @@ LL |     bar: Bar<'a>,\n    |              ^^ unexpected lifetime argument\n \n error[E0107]: wrong number of lifetime arguments: expected 1, found 3\n-  --> $DIR/E0107.rs:27:11\n+  --> $DIR/E0107.rs:27:19\n    |\n LL |     foo2: Foo<'a, 'b, 'c>,\n-   |           ^^^^^^^^^^^^^^^ 2 unexpected lifetime arguments\n+   |                   ^^  ^^ unexpected lifetime argument\n+   |                   |\n+   |                   unexpected lifetime argument\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f07529e7e9e1d82f1ea54acc1752308abf492885", "filename": "src/test/ui/error-codes/E0191.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,11 @@\n error[E0191]: the value of the associated type `Bar` (from the trait `Trait`) must be specified\n   --> $DIR/E0191.rs:15:12\n    |\n+LL |     type Bar;\n+   |     --------- `Bar` defined here\n+...\n LL | type Foo = Trait; //~ ERROR E0191\n-   |            ^^^^^ missing associated type `Bar` value\n+   |            ^^^^^ associated type `Bar` must be specified\n \n error: aborting due to previous error\n "}, {"sha": "d26e61fba8c6b6af1edc924196a4f8c3fd1046b5", "filename": "src/test/ui/error-codes/E0220.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -7,8 +7,11 @@ LL | type Foo = Trait<F=i32>; //~ ERROR E0220\n error[E0191]: the value of the associated type `Bar` (from the trait `Trait`) must be specified\n   --> $DIR/E0220.rs:15:12\n    |\n+LL |     type Bar;\n+   |     --------- `Bar` defined here\n+...\n LL | type Foo = Trait<F=i32>; //~ ERROR E0220\n-   |            ^^^^^^^^^^^^ missing associated type `Bar` value\n+   |            ^^^^^^^^^^^^ associated type `Bar` must be specified\n \n error: aborting due to 2 previous errors\n "}, {"sha": "27b9a34ff4eb769f229f6e2581532648925c2c9d", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/033cbfec4d3bb23948a99379f8d63b7cfe5eed45/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/033cbfec4d3bb23948a99379f8d63b7cfe5eed45/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs?ref=033cbfec4d3bb23948a99379f8d63b7cfe5eed45", "patch": "@@ -1,46 +0,0 @@\n-// edition:2018\n-\n-#![feature(alloc, underscore_imports)]\n-\n-extern crate alloc;\n-\n-mod in_scope {\n-    fn check() {\n-        let v = alloc::vec![0];\n-        //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-        type A = alloc::boxed::Box<u8>;\n-        //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-    }\n-}\n-\n-mod absolute {\n-    fn check() {\n-        let v = ::alloc::vec![0];\n-        //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-        type A = ::alloc::boxed::Box<u8>;\n-        //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-    }\n-}\n-\n-mod import_in_scope {\n-    use alloc as _;\n-    //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-    use alloc::boxed;\n-    //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-}\n-\n-mod import_absolute {\n-    use ::alloc;\n-    //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-    use ::alloc::boxed;\n-    //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-}\n-\n-extern crate alloc as core;\n-\n-mod unrelated_crate_renamed {\n-    type A = core::boxed::Box<u8>;\n-    //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n-}\n-\n-fn main() {}"}, {"sha": "103ab79ef84cb2fa96602e5d578547837071f203", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.stderr", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/033cbfec4d3bb23948a99379f8d63b7cfe5eed45/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/033cbfec4d3bb23948a99379f8d63b7cfe5eed45/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr?ref=033cbfec4d3bb23948a99379f8d63b7cfe5eed45", "patch": "@@ -1,75 +0,0 @@\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:26:9\n-   |\n-LL |     use alloc as _;\n-   |         ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:28:9\n-   |\n-LL |     use alloc::boxed;\n-   |         ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:33:11\n-   |\n-LL |     use ::alloc;\n-   |           ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:35:11\n-   |\n-LL |     use ::alloc::boxed;\n-   |           ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:9:17\n-   |\n-LL |         let v = alloc::vec![0];\n-   |                 ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:11:18\n-   |\n-LL |         type A = alloc::boxed::Box<u8>;\n-   |                  ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:18:19\n-   |\n-LL |         let v = ::alloc::vec![0];\n-   |                   ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:20:20\n-   |\n-LL |         type A = ::alloc::boxed::Box<u8>;\n-   |                    ^^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n-  --> $DIR/feature-gate-extern_crate_item_prelude.rs:42:14\n-   |\n-LL |     type A = core::boxed::Box<u8>;\n-   |              ^^^^\n-   |\n-   = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable\n-\n-error: aborting due to 9 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "877e4cdb0bdfc171bec74ab2e1041b4acc50a86b", "filename": "src/test/ui/imports/auxiliary/issue-55811.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-55811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-55811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-55811.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,5 @@\n+mod m {}\n+\n+// These two imports should not conflict when this crate is loaded from some other crate.\n+use m::{};\n+use m::{};"}, {"sha": "0ff407756b3ae6d963d9816b3bb3aeacd7ca094f", "filename": "src/test/ui/imports/auxiliary/issue-56125.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,9 @@\n+pub mod last_segment {\n+    pub mod issue_56125 {}\n+}\n+\n+pub mod non_last_segment {\n+    pub mod non_last_segment {\n+        pub mod issue_56125 {}\n+    }\n+}"}, {"sha": "cf91a9714ade089255f619b758e72234694856fc", "filename": "src/test/ui/imports/extern-prelude-extern-crate-absolute-expanded.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,6 @@\n // compile-pass\n // edition:2018\n \n-#![feature(extern_crate_item_prelude)]\n-\n macro_rules! define_iso { () => {\n     extern crate std as iso;\n }}"}, {"sha": "6117e5f6f3cd76681303d344f7805e49190b4af2", "filename": "src/test/ui/imports/extern-prelude-extern-crate-cfg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-cfg.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,7 +1,6 @@\n // compile-pass\n // compile-flags:--cfg my_feature\n \n-#![feature(extern_crate_item_prelude)]\n #![no_std]\n \n #[cfg(my_feature)]"}, {"sha": "bb4cf6ca99c752e87e87d5911a6c4ea272e45101", "filename": "src/test/ui/imports/extern-prelude-extern-crate-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-pass.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,6 @@\n // compile-pass\n // aux-build:two_macros.rs\n \n-#![feature(extern_crate_item_prelude)]\n-\n extern crate two_macros;\n \n mod m {"}, {"sha": "6ff3ab73639c0bec32db8ef41797a66fa84beb8e", "filename": "src/test/ui/imports/extern-prelude-extern-crate-restricted-shadowing.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,7 +1,5 @@\n // aux-build:two_macros.rs\n \n-#![feature(extern_crate_item_prelude)]\n-\n macro_rules! define_vec {\n     () => {\n         extern crate std as Vec;\n@@ -16,4 +14,13 @@ mod m {\n     }\n }\n \n+macro_rules! define_other_core {\n+    () => {\n+        extern crate std as core;\n+        //~^ ERROR macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+    }\n+}\n+\n+define_other_core!();\n+\n fn main() {}"}, {"sha": "795e1761ccdb3e097ca9b11542f28953e45c0443", "filename": "src/test/ui/imports/extern-prelude-extern-crate-restricted-shadowing.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,19 +1,28 @@\n+error: macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+  --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:19:9\n+   |\n+LL |         extern crate std as core;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | define_other_core!();\n+   | --------------------- in this macro invocation\n+\n error[E0659]: `Vec` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n-  --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:15:9\n+  --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:13:9\n    |\n LL |         Vec::panic!(); //~ ERROR `Vec` is ambiguous\n    |         ^^^ ambiguous name\n    |\n    = note: `Vec` could refer to a struct from prelude\n note: `Vec` could also refer to the extern crate imported here\n-  --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:7:9\n+  --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:5:9\n    |\n LL |         extern crate std as Vec;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | define_vec!();\n    | -------------- in this macro invocation\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "c5adeaf17fa9285c942b73bf0a812781d076e97b", "filename": "src/test/ui/imports/extern-prelude-extern-crate-shadowing.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-shadowing.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+// aux-build:two_macros.rs\n+\n+extern crate two_macros as core;\n+\n+mod m {\n+    fn check() {\n+        core::m!(); // OK\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "95316777fabf6330f8edd0e048207f362b92f65f", "filename": "src/test/ui/imports/issue-55811.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-55811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-55811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55811.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,6 @@\n+// compile-pass\n+// aux-build:issue-55811.rs\n+\n+extern crate issue_55811;\n+\n+fn main() {}"}, {"sha": "4baeb8a34dd7694a1cb1427e06eaecffb806929a", "filename": "src/test/ui/imports/issue-56125.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+// compile-flags:--extern issue_56125\n+// aux-build:issue-56125.rs\n+\n+use issue_56125::last_segment::*;\n+//~^ ERROR `issue_56125` is ambiguous\n+//~| ERROR unresolved import `issue_56125::last_segment`\n+use issue_56125::non_last_segment::non_last_segment::*;\n+//~^ ERROR `issue_56125` is ambiguous\n+//~| ERROR failed to resolve: could not find `non_last_segment` in `issue_56125`\n+\n+fn main() {}"}, {"sha": "096d5be97f0e0367ac0996086353230e802fa136", "filename": "src/test/ui/imports/issue-56125.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,46 @@\n+error[E0433]: failed to resolve: could not find `non_last_segment` in `issue_56125`\n+  --> $DIR/issue-56125.rs:8:18\n+   |\n+LL | use issue_56125::non_last_segment::non_last_segment::*;\n+   |                  ^^^^^^^^^^^^^^^^ could not find `non_last_segment` in `issue_56125`\n+\n+error[E0432]: unresolved import `issue_56125::last_segment`\n+  --> $DIR/issue-56125.rs:5:18\n+   |\n+LL | use issue_56125::last_segment::*;\n+   |                  ^^^^^^^^^^^^ could not find `last_segment` in `issue_56125`\n+\n+error[E0659]: `issue_56125` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/issue-56125.rs:5:5\n+   |\n+LL | use issue_56125::last_segment::*;\n+   |     ^^^^^^^^^^^ ambiguous name\n+   |\n+   = note: `issue_56125` could refer to an extern crate passed with `--extern`\n+   = help: use `::issue_56125` to refer to this extern crate unambiguously\n+note: `issue_56125` could also refer to the module imported here\n+  --> $DIR/issue-56125.rs:5:5\n+   |\n+LL | use issue_56125::last_segment::*;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::issue_56125` to refer to this module unambiguously\n+\n+error[E0659]: `issue_56125` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/issue-56125.rs:8:5\n+   |\n+LL | use issue_56125::non_last_segment::non_last_segment::*;\n+   |     ^^^^^^^^^^^ ambiguous name\n+   |\n+   = note: `issue_56125` could refer to an extern crate passed with `--extern`\n+   = help: use `::issue_56125` to refer to this extern crate unambiguously\n+note: `issue_56125` could also refer to the module imported here\n+  --> $DIR/issue-56125.rs:5:5\n+   |\n+LL | use issue_56125::last_segment::*;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::issue_56125` to refer to this module unambiguously\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0432, E0433, E0659.\n+For more information about an error, try `rustc --explain E0432`."}, {"sha": "741ba5f41ce16b9caf72e7b40a58bf226f86f64d", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,5 @@\n+fn a(&self) { }\n+//~^ ERROR unexpected `self` argument in function\n+//~| NOTE `self` is only valid as the first argument of an associated function\n+\n+fn main() { }"}, {"sha": "6a878b619d813651d91fa60bb63c34c1481ce960", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected `self` argument in function\n+  --> $DIR/bare-fn-start.rs:1:7\n+   |\n+LL | fn a(&self) { }\n+   |       ^^^^ `self` is only valid as the first argument of an associated function\n+\n+error: aborting due to previous error\n+"}, {"sha": "704fa996ca631a73fe1b3333ce1eae9406cbac02", "filename": "src/test/ui/invalid-self-argument/bare-fn.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,5 @@\n+fn b(foo: u32, &mut self) { }\n+//~^ ERROR unexpected `self` argument in function\n+//~| NOTE `self` is only valid as the first argument of an associated function\n+\n+fn main() { }"}, {"sha": "b13f746a4ec584a5bc3e2b62bc0de418247a8bbb", "filename": "src/test/ui/invalid-self-argument/bare-fn.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected `self` argument in function\n+  --> $DIR/bare-fn.rs:1:21\n+   |\n+LL | fn b(foo: u32, &mut self) { }\n+   |                     ^^^^ `self` is only valid as the first argument of an associated function\n+\n+error: aborting due to previous error\n+"}, {"sha": "31e867bc7641f4f263374b28e4814a5a39c6b4ef", "filename": "src/test/ui/invalid-self-argument/trait-fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,11 @@\n+struct Foo {}\n+\n+impl Foo {\n+    fn c(foo: u32, self) {}\n+    //~^ ERROR unexpected `self` argument in function\n+    //~| NOTE `self` is only valid as the first argument of an associated function\n+\n+    fn good(&mut self, foo: u32) {}\n+}\n+\n+fn main() { }"}, {"sha": "b3c2cc5b5ebe0874e1f222f695c4b3f0733f5c89", "filename": "src/test/ui/invalid-self-argument/trait-fn.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected `self` argument in function\n+  --> $DIR/trait-fn.rs:4:20\n+   |\n+LL |     fn c(foo: u32, self) {}\n+   |                    ^^^^ `self` is only valid as the first argument of an associated function\n+\n+error: aborting due to previous error\n+"}, {"sha": "d125438b8517d45723f0a6275e2301220bb5d1b2", "filename": "src/test/ui/issues/issue-19482.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,11 @@\n error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n   --> $DIR/issue-19482.rs:20:12\n    |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n LL | fn bar(x: &Foo) {}\n-   |            ^^^ missing associated type `A` value\n+   |            ^^^ associated type `A` must be specified\n \n error: aborting due to previous error\n "}, {"sha": "33c89dd4994b7d56c560d6bbb3d661a699fb8031", "filename": "src/test/ui/issues/issue-21950.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -10,7 +10,7 @@ error[E0191]: the value of the associated type `Output` (from the trait `std::op\n   --> $DIR/issue-21950.rs:17:14\n    |\n LL |             &Add;\n-   |              ^^^ missing associated type `Output` value\n+   |              ^^^ associated type `Output` must be specified\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3ba77346a1f8225da36b855ad668711fb8ea6bbb", "filename": "src/test/ui/issues/issue-22434.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,8 +1,11 @@\n error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n   --> $DIR/issue-22434.rs:15:19\n    |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n LL | type I<'a> = &'a (Foo + 'a);\n-   |                   ^^^^^^^^ missing associated type `A` value\n+   |                   ^^^^^^^^ associated type `A` must be specified\n \n error: aborting due to previous error\n "}, {"sha": "715f84011f64eaa1dde6219ec53a3034fb2f6f78", "filename": "src/test/ui/issues/issue-22560.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -28,7 +28,7 @@ LL |   type Test = Add +\n LL | |             //~^ ERROR E0393\n LL | |             //~| ERROR E0191\n LL | |             Sub;\n-   | |_______________^ missing associated type `Output` value\n+   | |_______________^ associated type `Output` must be specified\n \n error: aborting due to 4 previous errors\n "}, {"sha": "adee12a36d31b39eb99771b79cbb7d8d59120741", "filename": "src/test/ui/issues/issue-23024.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -16,7 +16,7 @@ error[E0191]: the value of the associated type `Output` (from the trait `std::op\n   --> $DIR/issue-23024.rs:19:35\n    |\n LL |     println!(\"{:?}\",(vfnfer[0] as Fn)(3));\n-   |                                   ^^ missing associated type `Output` value\n+   |                                   ^^ associated type `Output` must be specified\n \n error: aborting due to 3 previous errors\n "}, {"sha": "734c761d0b7bc1d75f3a07ca87b004db54a1e822", "filename": "src/test/ui/issues/issue-28344.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -2,7 +2,7 @@ error[E0191]: the value of the associated type `Output` (from the trait `std::op\n   --> $DIR/issue-28344.rs:14:17\n    |\n LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-   |                 ^^^^^^^^^^^^^ missing associated type `Output` value\n+   |                 ^^^^^^^^^^^^^ associated type `Output` must be specified\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n   --> $DIR/issue-28344.rs:14:17\n@@ -16,7 +16,7 @@ error[E0191]: the value of the associated type `Output` (from the trait `std::op\n   --> $DIR/issue-28344.rs:18:13\n    |\n LL |     let g = BitXor::bitor;\n-   |             ^^^^^^^^^^^^^ missing associated type `Output` value\n+   |             ^^^^^^^^^^^^^ associated type `Output` must be specified\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n   --> $DIR/issue-28344.rs:18:13"}, {"sha": "3a3eccdc33ce8f63e90b516e39f20b1c40568724", "filename": "src/test/ui/issues/issue-56128.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #56128. When this `pub(super) use...` gets\n+// exploded in the HIR, we were not handling ids correctly.\n+//\n+// compile-pass\n+\n+mod bar {\n+    pub(super) use self::baz::{x, y};\n+\n+    mod baz {\n+        pub fn x() { }\n+        pub fn y() { }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "23df4fa6132d3838a411d2af96d8799b769080b9", "filename": "src/test/ui/lint/must_use-trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,22 @@\n+#![deny(unused_must_use)]\n+\n+#[must_use]\n+trait Critical {}\n+\n+trait NotSoCritical {}\n+\n+trait DecidedlyUnimportant {}\n+\n+struct Anon;\n+\n+impl Critical for Anon {}\n+impl NotSoCritical for Anon {}\n+impl DecidedlyUnimportant for Anon {}\n+\n+fn get_critical() -> impl NotSoCritical + Critical + DecidedlyUnimportant {\n+    Anon {}\n+}\n+\n+fn main() {\n+    get_critical(); //~ ERROR unused implementer of `Critical` that must be used\n+}"}, {"sha": "94f5f4f40d2d54a80177a1fa39ceccf062f85a55", "filename": "src/test/ui/lint/must_use-trait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_use-trait.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,14 @@\n+error: unused implementer of `Critical` that must be used\n+  --> $DIR/must_use-trait.rs:21:5\n+   |\n+LL |     get_critical(); //~ ERROR unused implementer of `Critical` that must be used\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/must_use-trait.rs:1:9\n+   |\n+LL | #![deny(unused_must_use)]\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2dcc7a25c84014f35b0e4757b5adac09b60712d2", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -22,6 +22,8 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     f(|| panic!());\n     //~^ ERROR closure is expected to take\n+    f(  move    || panic!());\n+    //~^ ERROR closure is expected to take\n \n     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n     //~^ ERROR closure is expected to take"}, {"sha": "eeadf07262c3ee6f6f816d0e9e2ed561220d068d", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -60,8 +60,26 @@ help: consider changing the closure to take and ignore the expected argument\n LL |     f(|_| panic!());\n    |       ^^^\n \n+error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments\n+  --> $DIR/closure-arg-count.rs:25:5\n+   |\n+LL |     f(  move    || panic!());\n+   |     ^   ---------- takes 0 arguments\n+   |     |\n+   |     expected closure that takes 1 argument\n+   |\n+note: required by `f`\n+  --> $DIR/closure-arg-count.rs:13:1\n+   |\n+LL | fn f<F: Fn<usize>>(_: F) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider changing the closure to take and ignore the expected argument\n+   |\n+LL |     f(  move    |_| panic!());\n+   |                 ^^^\n+\n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:26:53\n+  --> $DIR/closure-arg-count.rs:28:53\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n    |                                                     ^^^ ------ takes 2 distinct arguments\n@@ -73,7 +91,7 @@ LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n    |                                                         ^^^^^^^^\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:28:53\n+  --> $DIR/closure-arg-count.rs:30:53\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n    |                                                     ^^^ ------------- takes 2 distinct arguments\n@@ -85,15 +103,15 @@ LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n    |                                                         ^^^^^^^^\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:30:53\n+  --> $DIR/closure-arg-count.rs:32:53\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n    |                                                     ^^^ --------- takes 3 distinct arguments\n    |                                                     |\n    |                                                     expected closure that takes a single 2-tuple as argument\n \n error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n-  --> $DIR/closure-arg-count.rs:32:53\n+  --> $DIR/closure-arg-count.rs:34:53\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n@@ -102,15 +120,15 @@ LL | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:35:53\n+  --> $DIR/closure-arg-count.rs:37:53\n    |\n LL |     let bar = |i, x, y| i;\n    |               --------- takes 3 distinct arguments\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n    |                                                     ^^^ expected closure that takes a single 2-tuple as argument\n \n error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:37:53\n+  --> $DIR/closure-arg-count.rs:39:53\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n@@ -119,13 +137,13 @@ LL | fn qux(x: usize, y: usize) {}\n    | -------------------------- takes 2 distinct arguments\n \n error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n-  --> $DIR/closure-arg-count.rs:40:41\n+  --> $DIR/closure-arg-count.rs:42:41\n    |\n LL |     let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n    |                                         ^^^ expected function that takes 1 argument\n \n error[E0593]: function is expected to take 0 arguments, but it takes 1 argument\n-  --> $DIR/closure-arg-count.rs:43:5\n+  --> $DIR/closure-arg-count.rs:45:5\n    |\n LL |     call(Foo);\n    |     ^^^^ expected function that takes 0 arguments\n@@ -134,11 +152,11 @@ LL | struct Foo(u8);\n    | --------------- takes 1 argument\n    |\n note: required by `call`\n-  --> $DIR/closure-arg-count.rs:50:1\n+  --> $DIR/closure-arg-count.rs:52:1\n    |\n LL | fn call<F, R>(_: F) where F: FnOnce() -> R {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0593`."}, {"sha": "4e553c4df2fd49a9b7b3b86b95881eee1997bdf1", "filename": "src/test/ui/panic-runtime/bad-panic-flag1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n // compile-flags:-C panic=foo\n-// error-pattern:either `panic` or `abort` was expected\n+// error-pattern:either `unwind` or `abort` was expected\n \n fn main() {}"}, {"sha": "013373c6f93132eb30a8b00bd37f54811a6a0ed8", "filename": "src/test/ui/panic-runtime/bad-panic-flag1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag1.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,2 +1,2 @@\n-error: incorrect value `foo` for codegen option `panic` - either `panic` or `abort` was expected\n+error: incorrect value `foo` for codegen option `panic` - either `unwind` or `abort` was expected\n "}, {"sha": "f560e7f4eb2de8046d27a9a5fe50288d63c3f2f8", "filename": "src/test/ui/panic-runtime/bad-panic-flag2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n // compile-flags:-C panic\n-// error-pattern:requires either `panic` or `abort`\n+// error-pattern:requires either `unwind` or `abort`\n \n fn main() {}"}, {"sha": "6ab94ea704d30c19f30b4322ffec3979cb01e939", "filename": "src/test/ui/panic-runtime/bad-panic-flag2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fbad-panic-flag2.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1,2 +1,2 @@\n-error: codegen option `panic` requires either `panic` or `abort` (C panic=<value>)\n+error: codegen option `panic` requires either `unwind` or `abort` (C panic=<value>)\n "}, {"sha": "58e7718ba5bb4fbdcbb088c0f2c191576dde78d2", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,8 @@\n+pub trait T<X, Y> {\n+    type A;\n+    type B;\n+    type C;\n+}\n+ pub struct Foo { i: Box<T<usize, usize, usize, usize, B=usize>> }\n+\n+ fn main() {}"}, {"sha": "b62b5d3b04ca072fa6b67b708245c9e6ee6b50b1", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -0,0 +1,31 @@\n+error[E0107]: wrong number of type arguments: expected 2, found 4\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:6:42\n+   |\n+LL |  pub struct Foo { i: Box<T<usize, usize, usize, usize, B=usize>> }\n+   |                                          ^^^^^  ^^^^^ unexpected type argument\n+   |                                          |\n+   |                                          unexpected type argument\n+\n+error[E0191]: the value of the associated types `A` (from the trait `T`), `C` (from the trait `T`) must be specified\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:6:26\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+LL |     type B;\n+LL |     type C;\n+   |     ------- `C` defined here\n+LL | }\n+LL |  pub struct Foo { i: Box<T<usize, usize, usize, usize, B=usize>> }\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          associated type `A` must be specified\n+   |                          associated type `C` must be specified\n+help: if you meant to specify the associated types, write\n+   |\n+LL |  pub struct Foo { i: Box<T<usize, usize, A = usize, C = usize, B=usize>> }\n+   |                                          ^^^^^^^^^  ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0107, E0191.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "fdb9427cba734635a0cecd46279f1169562801e0", "filename": "src/test/ui/traits/trait-alias-object.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -10,7 +10,7 @@ error[E0191]: the value of the associated type `Item` (from the trait `std::iter\n   --> $DIR/trait-alias-object.rs:18:13\n    |\n LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n-   |             ^^^^^^^^^^^^^^^^^ missing associated type `Item` value\n+   |             ^^^^^^^^^^^^^^^^^ associated type `Item` must be specified\n \n error: aborting due to 2 previous errors\n "}, {"sha": "754b4c07233ee18820265bd18467aa82263f9a3a", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit f5d868c9edfc6c2a9310d564a2f738bec67dfd6b\n+Subproject commit 754b4c07233ee18820265bd18467aa82263f9a3a"}, {"sha": "daa138ce7f222559e9a339600b44a715101a3f4d", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit 1c755efed6ee265c762f4d3fec73de8a989637a5\n+Subproject commit daa138ce7f222559e9a339600b44a715101a3f4d"}, {"sha": "1cc61cfc2b29ae3f29a924b4c8feb1bcb09aa5fc", "filename": "src/tools/rustfmt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -1 +1 @@\n-Subproject commit 750b25261380b776de2518fd6863fe63f98d2722\n+Subproject commit 1cc61cfc2b29ae3f29a924b4c8feb1bcb09aa5fc"}, {"sha": "a40ae8894d5e795bcd335f63c721c0fa50f86972", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Check license of third-party deps by inspecting src/vendor\n+//! Check license of third-party deps by inspecting vendor\n \n use std::collections::{BTreeSet, HashSet, HashMap};\n use std::fs::File;\n@@ -203,7 +203,7 @@ impl<'a> From<CrateVersion<'a>> for Crate<'a> {\n /// Specifically, this checks that the license is correct.\n pub fn check(path: &Path, bad: &mut bool) {\n     // Check licences\n-    let path = path.join(\"vendor\");\n+    let path = path.join(\"../vendor\");\n     assert!(path.exists(), \"vendor directory missing\");\n     let mut saw_dir = false;\n     for dir in t!(path.read_dir()) {\n@@ -215,7 +215,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n             dir.path()\n                 .to_str()\n                 .unwrap()\n-                .contains(&format!(\"src/vendor/{}\", exception))\n+                .contains(&format!(\"vendor/{}\", exception))\n         });\n         if is_exception {\n             continue;\n@@ -304,7 +304,7 @@ fn get_deps(path: &Path, cargo: &Path) -> Resolve {\n         .arg(\"--format-version\")\n         .arg(\"1\")\n         .arg(\"--manifest-path\")\n-        .arg(path.join(\"Cargo.toml\"))\n+        .arg(path.join(\"../Cargo.toml\"))\n         .output()\n         .expect(\"Unable to run `cargo metadata`\")\n         .stdout;"}, {"sha": "a78d2d4ee4e150ed51c85f9ac6870285444b702a", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -21,8 +21,8 @@ const WHITELISTED_SOURCES: &[&str] = &[\n \n /// check for external package sources\n pub fn check(path: &Path, bad: &mut bool) {\n-    // Cargo.lock of rust: src/Cargo.lock\n-    let path = path.join(\"Cargo.lock\");\n+    // Cargo.lock of rust (tidy runs inside src/)\n+    let path = path.join(\"../Cargo.lock\");\n \n     // open and read the whole file\n     let mut cargo_lock = String::new();"}, {"sha": "700103d35d88c0264422d8cc93ffdacaa036b019", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb1a48b415c1b586bb652d58f3d2078d87f44dd/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=ebb1a48b415c1b586bb652d58f3d2078d87f44dd", "patch": "@@ -64,7 +64,6 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/librustc_data_structures/owning_ref\",\n         \"src/compiler-rt\",\n         \"src/liblibc\",\n-        \"src/vendor\",\n         \"src/rt/hoedown\",\n         \"src/tools/cargo\",\n         \"src/tools/clang\",\n@@ -78,6 +77,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/target\",\n         \"src/stdsimd\",\n         \"target\",\n+        \"vendor\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}