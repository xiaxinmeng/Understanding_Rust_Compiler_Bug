{"sha": "b12a3582b113c0f9c217f6311ec0d47fd0f79016", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMmEzNTgyYjExM2MwZjljMjE3ZjYzMTFlYzBkNDdmZDBmNzkwMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-13T10:28:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-13T10:28:25Z"}, "message": "Auto merge of #29761 - eefriedman:rename-nopanic, r=sanxiyn\n\nJust `sed s/_nopanic//g`.  Hopefully makes libsyntax a bit more\nreadable.", "tree": {"sha": "8fc29c0a8f3bc0ccdd0b5d438c2ecc39068ad396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fc29c0a8f3bc0ccdd0b5d438c2ecc39068ad396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b12a3582b113c0f9c217f6311ec0d47fd0f79016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b12a3582b113c0f9c217f6311ec0d47fd0f79016", "html_url": "https://github.com/rust-lang/rust/commit/b12a3582b113c0f9c217f6311ec0d47fd0f79016", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b12a3582b113c0f9c217f6311ec0d47fd0f79016/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82251354ff30e9a6f9f98d8dbef9fe54df400285", "url": "https://api.github.com/repos/rust-lang/rust/commits/82251354ff30e9a6f9f98d8dbef9fe54df400285", "html_url": "https://github.com/rust-lang/rust/commit/82251354ff30e9a6f9f98d8dbef9fe54df400285"}, {"sha": "69210a96358dcd85bf6d08f21c8e2df5b0975d3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/69210a96358dcd85bf6d08f21c8e2df5b0975d3b", "html_url": "https://github.com/rust-lang/rust/commit/69210a96358dcd85bf6d08f21c8e2df5b0975d3b"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "ac18b9c0e49406e45accb6b4f28c35c31b20be03", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -79,7 +79,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     cx.span_err(sp, \"malformed inline assembly\");\n                     return DummyResult::expr(sp);\n                 }\n-                let (s, style) = match expr_to_string(cx, panictry!(p.parse_expr_nopanic()),\n+                let (s, style) = match expr_to_string(cx, panictry!(p.parse_expr()),\n                                                    \"inline assembly must be a string literal\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n@@ -102,7 +102,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let span = p.last_span;\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let out = panictry!(p.parse_expr_nopanic());\n+                    let out = panictry!(p.parse_expr());\n                     panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     // Expands a read+write operand into two operands.\n@@ -146,7 +146,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     }\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let input = panictry!(p.parse_expr_nopanic());\n+                    let input = panictry!(p.parse_expr());\n                     panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     inputs.push((constraint, input));"}, {"sha": "18db028b60b4cbf2deb867740f164f9f9abfa9df", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -821,7 +821,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n-    let ret = cx.expander().fold_expr(panictry!(p.parse_expr_nopanic()));\n+    let ret = cx.expander().fold_expr(panictry!(p.parse_expr()));\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n@@ -838,7 +838,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        es.push(cx.expander().fold_expr(panictry!(p.parse_expr_nopanic())));\n+        es.push(cx.expander().fold_expr(panictry!(p.parse_expr())));\n         if panictry!(p.eat(&token::Comma)){\n             continue;\n         }"}, {"sha": "904cf0c47768eb04b265e64fa89ee64039b8cdf8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -94,7 +94,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         ecx.span_err(sp, \"requires at least a format string argument\");\n         return None;\n     }\n-    let fmtstr = panictry!(p.parse_expr_nopanic());\n+    let fmtstr = panictry!(p.parse_expr());\n     let mut named = false;\n     while p.token != token::Eof {\n         if !panictry!(p.eat(&token::Comma)) {\n@@ -125,7 +125,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let name: &str = &ident.name.as_str();\n \n             panictry!(p.expect(&token::Eq));\n-            let e = panictry!(p.parse_expr_nopanic());\n+            let e = panictry!(p.parse_expr());\n             match names.get(name) {\n                 None => {}\n                 Some(prev) => {\n@@ -139,7 +139,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             order.push(name.to_string());\n             names.insert(name.to_string(), e);\n         } else {\n-            args.push(panictry!(p.parse_expr_nopanic()));\n+            args.push(panictry!(p.parse_expr()));\n         }\n     }\n     Some((fmtstr, args, order, names))"}, {"sha": "772786ad23289a7a06d7041290353bcf9cb62a44", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -752,7 +752,7 @@ fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[TokenTree])\n     let mut p = cx.new_parser_from_tts(tts);\n     p.quote_depth += 1;\n \n-    let cx_expr = panictry!(p.parse_expr_nopanic());\n+    let cx_expr = panictry!(p.parse_expr());\n     if !panictry!(p.eat(&token::Comma)) {\n         panic!(p.fatal(\"expected token `,`\"));\n     }"}, {"sha": "7899e170ecf195f322da65a4af938fa55be0fec0", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -109,13 +109,13 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n-            Some(panictry!(self.p.parse_expr_nopanic()))\n+            Some(panictry!(self.p.parse_expr()))\n         }\n         fn make_items(mut self: Box<ExpandResult<'a>>)\n                       -> Option<SmallVector<P<ast::Item>>> {\n             let mut ret = SmallVector::zero();\n             while self.p.token != token::Eof {\n-                match panictry!(self.p.parse_item_nopanic()) {\n+                match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n                     None => panic!(self.p.span_fatal(\n                         self.p.span,"}, {"sha": "dded634882dc150bb56acf65e9089016fd6f8d33", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -501,18 +501,18 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     // check at the beginning and the parser checks after each bump\n     panictry!(p.check_unknown_macro_variable());\n     match name {\n-        \"item\" => match panictry!(p.parse_item_nopanic()) {\n+        \"item\" => match panictry!(p.parse_item()) {\n             Some(i) => token::NtItem(i),\n             None => panic!(p.fatal(\"expected an item keyword\"))\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n-        \"stmt\" => match panictry!(p.parse_stmt_nopanic()) {\n+        \"stmt\" => match panictry!(p.parse_stmt()) {\n             Some(s) => token::NtStmt(s),\n             None => panic!(p.fatal(\"expected a statement\"))\n         },\n-        \"pat\" => token::NtPat(panictry!(p.parse_pat_nopanic())),\n-        \"expr\" => token::NtExpr(panictry!(p.parse_expr_nopanic())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty_nopanic())),\n+        \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n+        \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n+        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n             token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }"}, {"sha": "a34998196e57bfe978d430443b4dbea2e1ba2f4e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -67,18 +67,18 @@ impl<'a> ParserAnyMacro<'a> {\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n     fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_expr_nopanic());\n+        let ret = panictry!(self.parser.borrow_mut().parse_expr());\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n     fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_pat_nopanic());\n+        let ret = panictry!(self.parser.borrow_mut().parse_pat());\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n     fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n-        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item_nopanic()) {\n+        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item()) {\n             ret.push(item);\n         }\n         self.ensure_complete_parse(false);\n@@ -106,7 +106,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => match parser.parse_stmt_nopanic() {\n+                _ => match parser.parse_stmt() {\n                     Ok(maybe_stmt) => match maybe_stmt {\n                         Some(stmt) => ret.push(stmt),\n                         None => (),\n@@ -120,7 +120,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n     }\n \n     fn make_ty(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Ty>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_ty_nopanic());\n+        let ret = panictry!(self.parser.borrow_mut().parse_ty());\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }"}, {"sha": "7e2fd09a37316ecb267c98a6cc8b71fdb460646b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -116,7 +116,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> P<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(panictry!(p.parse_expr_nopanic()), p)\n+    maybe_aborted(panictry!(p.parse_expr()), p)\n }\n \n pub fn parse_item_from_source_str(name: String,\n@@ -125,7 +125,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> Option<P<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(panictry!(p.parse_item_nopanic()), p)\n+    maybe_aborted(panictry!(p.parse_item()), p)\n }\n \n pub fn parse_meta_from_source_str(name: String,\n@@ -148,7 +148,7 @@ pub fn parse_stmt_from_source_str(name: String,\n         name,\n         source\n     );\n-    maybe_aborted(panictry!(p.parse_stmt_nopanic()), p)\n+    maybe_aborted(panictry!(p.parse_stmt()), p)\n }\n \n // Warning: This parses with quote_depth > 0, which is not the default.\n@@ -882,7 +882,7 @@ mod tests {\n     #[test] fn parse_ident_pat () {\n         let sess = ParseSess::new();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n-        assert!(panictry!(parser.parse_pat_nopanic())\n+        assert!(panictry!(parser.parse_pat())\n                 == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),"}, {"sha": "c82c6dcdea33b4851b84a54f1e8384c33bd41ec1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -366,27 +366,27 @@ impl<'a> Parser<'a> {\n     // These functions are used by the quote_*!() syntax extensions, but shouldn't\n     // be used otherwise.\n     pub fn parse_expr_panic(&mut self) -> P<Expr> {\n-        panictry!(self.parse_expr_nopanic())\n+        panictry!(self.parse_expr())\n     }\n \n     pub fn parse_item_panic(&mut self) -> Option<P<Item>> {\n-        panictry!(self.parse_item_nopanic())\n+        panictry!(self.parse_item())\n     }\n \n     pub fn parse_pat_panic(&mut self) -> P<Pat> {\n-        panictry!(self.parse_pat_nopanic())\n+        panictry!(self.parse_pat())\n     }\n \n     pub fn parse_arm_panic(&mut self) -> Arm {\n-        panictry!(self.parse_arm_nopanic())\n+        panictry!(self.parse_arm())\n     }\n \n     pub fn parse_ty_panic(&mut self) -> P<Ty> {\n-        panictry!(self.parse_ty_nopanic())\n+        panictry!(self.parse_ty())\n     }\n \n     pub fn parse_stmt_panic(&mut self) -> Option<P<Stmt>> {\n-        panictry!(self.parse_stmt_nopanic())\n+        panictry!(self.parse_stmt())\n     }\n \n     pub fn parse_attribute_panic(&mut self, permit_inner: bool) -> ast::Attribute {\n@@ -1213,7 +1213,7 @@ impl<'a> Parser<'a> {\n                 let ty = try!(p.parse_ty_sum());\n                 let default = if p.check(&token::Eq) {\n                     try!(p.bump());\n-                    let expr = try!(p.parse_expr_nopanic());\n+                    let expr = try!(p.parse_expr());\n                     try!(p.commit_expr_expecting(&expr, token::Semi));\n                     Some(expr)\n                 } else {\n@@ -1280,7 +1280,7 @@ impl<'a> Parser<'a> {\n     /// Parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> PResult<MutTy> {\n         let mutbl = try!(self.parse_mutability());\n-        let t = try!(self.parse_ty_nopanic());\n+        let t = try!(self.parse_ty());\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n@@ -1290,7 +1290,7 @@ impl<'a> Parser<'a> {\n             if try!(self.eat(&token::Not) ){\n                 Ok(NoReturn(self.last_span))\n             } else {\n-                Ok(Return(try!(self.parse_ty_nopanic())))\n+                Ok(Return(try!(self.parse_ty())))\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1301,7 +1301,7 @@ impl<'a> Parser<'a> {\n     /// Parse a type in a context where `T1+T2` is allowed.\n     pub fn parse_ty_sum(&mut self) -> PResult<P<Ty>> {\n         let lo = self.span.lo;\n-        let lhs = try!(self.parse_ty_nopanic());\n+        let lhs = try!(self.parse_ty());\n \n         if !try!(self.eat(&token::BinOp(token::Plus)) ){\n             return Ok(lhs);\n@@ -1324,7 +1324,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a type.\n-    pub fn parse_ty_nopanic(&mut self) -> PResult<P<Ty>> {\n+    pub fn parse_ty(&mut self) -> PResult<P<Ty>> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1385,7 +1385,7 @@ impl<'a> Parser<'a> {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n             try!(self.expect(&token::OpenDelim(token::Paren)));\n-            let e = try!(self.parse_expr_nopanic());\n+            let e = try!(self.parse_expr());\n             try!(self.expect(&token::CloseDelim(token::Paren)));\n             TyTypeof(e)\n         } else if try!(self.eat_lt()) {\n@@ -1445,7 +1445,7 @@ impl<'a> Parser<'a> {\n                            known as `*const T`\");\n             MutImmutable\n         };\n-        let t = try!(self.parse_ty_nopanic());\n+        let t = try!(self.parse_ty());\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n@@ -1476,7 +1476,7 @@ impl<'a> Parser<'a> {\n         let pat = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{})\",\n                    require_name);\n-            let pat = try!(self.parse_pat_nopanic());\n+            let pat = try!(self.parse_pat());\n \n             try!(self.expect(&token::Colon));\n             pat\n@@ -1503,7 +1503,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an argument in a lambda header e.g. |arg, arg|\n     pub fn parse_fn_block_arg(&mut self) -> PResult<Arg> {\n-        let pat = try!(self.parse_pat_nopanic());\n+        let pat = try!(self.parse_pat());\n         let t = if try!(self.eat(&token::Colon) ){\n             try!(self.parse_ty_sum())\n         } else {\n@@ -1523,7 +1523,7 @@ impl<'a> Parser<'a> {\n     pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<Option<P<ast::Expr>>> {\n         if self.check(&token::Semi) {\n             try!(self.bump());\n-            Ok(Some(try!(self.parse_expr_nopanic())))\n+            Ok(Some(try!(self.parse_expr())))\n         } else {\n             Ok(None)\n         }\n@@ -1748,7 +1748,7 @@ impl<'a> Parser<'a> {\n                     |p| p.parse_ty_sum()));\n \n                 let output_ty = if try!(self.eat(&token::RArrow) ){\n-                    Some(try!(self.parse_ty_nopanic()))\n+                    Some(try!(self.parse_ty()))\n                 } else {\n                     None\n                 };\n@@ -1953,7 +1953,7 @@ impl<'a> Parser<'a> {\n         let i = try!(self.parse_ident());\n         let hi = self.last_span.hi;\n         try!(self.expect(&token::Colon));\n-        let e = try!(self.parse_expr_nopanic());\n+        let e = try!(self.parse_expr());\n         Ok(ast::Field {\n             ident: spanned(lo, hi, i),\n             span: mk_sp(lo, e.span.hi),\n@@ -2067,7 +2067,7 @@ impl<'a> Parser<'a> {\n                 let mut es = vec![];\n                 let mut trailing_comma = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n-                    es.push(try!(self.parse_expr_nopanic()));\n+                    es.push(try!(self.parse_expr()));\n                     try!(self.commit_expr(&**es.last().unwrap(), &[],\n                                      &[token::Comma, token::CloseDelim(token::Paren)]));\n                     if self.check(&token::Comma) {\n@@ -2113,11 +2113,11 @@ impl<'a> Parser<'a> {\n                     ex = ExprVec(Vec::new());\n                 } else {\n                     // Nonempty vector.\n-                    let first_expr = try!(self.parse_expr_nopanic());\n+                    let first_expr = try!(self.parse_expr());\n                     if self.check(&token::Semi) {\n                         // Repeating array syntax: [ 0; 512 ]\n                         try!(self.bump());\n-                        let count = try!(self.parse_expr_nopanic());\n+                        let count = try!(self.parse_expr());\n                         try!(self.expect(&token::CloseDelim(token::Bracket)));\n                         ex = ExprRepeat(first_expr, count);\n                     } else if self.check(&token::Comma) {\n@@ -2126,7 +2126,7 @@ impl<'a> Parser<'a> {\n                         let remaining_exprs = try!(self.parse_seq_to_end(\n                             &token::CloseDelim(token::Bracket),\n                             seq_sep_trailing_allowed(token::Comma),\n-                            |p| Ok(try!(p.parse_expr_nopanic()))\n+                            |p| Ok(try!(p.parse_expr()))\n                                 ));\n                         let mut exprs = vec!(first_expr);\n                         exprs.extend(remaining_exprs);\n@@ -2205,7 +2205,7 @@ impl<'a> Parser<'a> {\n                 }\n                 if try!(self.eat_keyword(keywords::Return) ){\n                     if self.token.can_begin_expr() {\n-                        let e = try!(self.parse_expr_nopanic());\n+                        let e = try!(self.parse_expr());\n                         hi = e.span.hi;\n                         ex = ExprRet(Some(e));\n                     } else {\n@@ -2259,7 +2259,7 @@ impl<'a> Parser<'a> {\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if try!(self.eat(&token::DotDot) ){\n-                                    base = Some(try!(self.parse_expr_nopanic()));\n+                                    base = Some(try!(self.parse_expr()));\n                                     break;\n                                 }\n \n@@ -2335,7 +2335,7 @@ impl<'a> Parser<'a> {\n                                 &token::OpenDelim(token::Paren),\n                                 &token::CloseDelim(token::Paren),\n                                 seq_sep_trailing_allowed(token::Comma),\n-                                |p| Ok(try!(p.parse_expr_nopanic()))\n+                                |p| Ok(try!(p.parse_expr()))\n                             ));\n                             hi = self.last_span.hi;\n \n@@ -2412,7 +2412,7 @@ impl<'a> Parser<'a> {\n                     &token::OpenDelim(token::Paren),\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n-                    |p| Ok(try!(p.parse_expr_nopanic()))\n+                    |p| Ok(try!(p.parse_expr()))\n                 ));\n                 hi = self.last_span.hi;\n \n@@ -2424,7 +2424,7 @@ impl<'a> Parser<'a> {\n               // Could be either an index expression or a slicing expression.\n               token::OpenDelim(token::Bracket) => {\n                 try!(self.bump());\n-                let ix = try!(self.parse_expr_nopanic());\n+                let ix = try!(self.parse_expr());\n                 hi = self.span.hi;\n                 try!(self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket)));\n                 let index = self.mk_index(e, ix);\n@@ -2716,7 +2716,7 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = try!(self.parse_ty_nopanic());\n+                let rhs = try!(self.parse_ty());\n                 lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprCast(lhs, rhs));\n                 continue\n             } else if op == AssocOp::DotDot {\n@@ -2869,7 +2869,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_if_let_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.last_span.lo;\n         try!(self.expect_keyword(keywords::Let));\n-        let pat = try!(self.parse_pat_nopanic());\n+        let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let thn = try!(self.parse_block());\n@@ -2891,7 +2891,7 @@ impl<'a> Parser<'a> {\n             DefaultReturn(_) => {\n                 // If no explicit return type is given, parse any\n                 // expr and wrap it up in a dummy block:\n-                let body_expr = try!(self.parse_expr_nopanic());\n+                let body_expr = try!(self.parse_expr());\n                 P(ast::Block {\n                     id: ast::DUMMY_NODE_ID,\n                     stmts: vec![],\n@@ -2927,7 +2927,7 @@ impl<'a> Parser<'a> {\n                           span_lo: BytePos) -> PResult<P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n-        let pat = try!(self.parse_pat_nopanic());\n+        let pat = try!(self.parse_pat());\n         try!(self.expect_keyword(keywords::In));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let loop_block = try!(self.parse_block());\n@@ -2952,7 +2952,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n                                 span_lo: BytePos) -> PResult<P<Expr>> {\n         try!(self.expect_keyword(keywords::Let));\n-        let pat = try!(self.parse_pat_nopanic());\n+        let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n@@ -2979,21 +2979,21 @@ impl<'a> Parser<'a> {\n         }\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n-            arms.push(try!(self.parse_arm_nopanic()));\n+            arms.push(try!(self.parse_arm()));\n         }\n         let hi = self.span.hi;\n         try!(self.bump());\n         return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms)));\n     }\n \n-    pub fn parse_arm_nopanic(&mut self) -> PResult<Arm> {\n+    pub fn parse_arm(&mut self) -> PResult<Arm> {\n         maybe_whole!(no_clone self, NtArm);\n \n         let attrs = try!(self.parse_outer_attributes());\n         let pats = try!(self.parse_pats());\n         let mut guard = None;\n         if try!(self.eat_keyword(keywords::If) ){\n-            guard = Some(try!(self.parse_expr_nopanic()));\n+            guard = Some(try!(self.parse_expr()));\n         }\n         try!(self.expect(&token::FatArrow));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n@@ -3017,7 +3017,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression\n-    pub fn parse_expr_nopanic(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_expr(&mut self) -> PResult<P<Expr>> {\n         self.parse_expr_res(Restrictions::empty())\n     }\n \n@@ -3043,7 +3043,7 @@ impl<'a> Parser<'a> {\n     fn parse_initializer(&mut self) -> PResult<Option<P<Expr>>> {\n         if self.check(&token::Eq) {\n             try!(self.bump());\n-            Ok(Some(try!(self.parse_expr_nopanic())))\n+            Ok(Some(try!(self.parse_expr())))\n         } else {\n             Ok(None)\n         }\n@@ -3053,7 +3053,7 @@ impl<'a> Parser<'a> {\n     fn parse_pats(&mut self) -> PResult<Vec<P<Pat>>> {\n         let mut pats = Vec::new();\n         loop {\n-            pats.push(try!(self.parse_pat_nopanic()));\n+            pats.push(try!(self.parse_pat()));\n             if self.check(&token::BinOp(token::Or)) { try!(self.bump());}\n             else { return Ok(pats); }\n         };\n@@ -3062,11 +3062,11 @@ impl<'a> Parser<'a> {\n     fn parse_pat_tuple_elements(&mut self) -> PResult<Vec<P<Pat>>> {\n         let mut fields = vec![];\n         if !self.check(&token::CloseDelim(token::Paren)) {\n-            fields.push(try!(self.parse_pat_nopanic()));\n+            fields.push(try!(self.parse_pat()));\n             if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n                 while try!(self.eat(&token::Comma)) &&\n                       !self.check(&token::CloseDelim(token::Paren)) {\n-                    fields.push(try!(self.parse_pat_nopanic()));\n+                    fields.push(try!(self.parse_pat()));\n                 }\n             }\n             if fields.len() == 1 {\n@@ -3114,7 +3114,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let subpat = try!(self.parse_pat_nopanic());\n+            let subpat = try!(self.parse_pat());\n             if before_slice && self.check(&token::DotDot) {\n                 try!(self.bump());\n                 slice = Some(subpat);\n@@ -3162,7 +3162,7 @@ impl<'a> Parser<'a> {\n                 // Parsing a pattern of the form \"fieldname: pat\"\n                 let fieldname = try!(self.parse_ident());\n                 try!(self.bump());\n-                let pat = try!(self.parse_pat_nopanic());\n+                let pat = try!(self.parse_pat());\n                 hi = pat.span.hi;\n                 (pat, fieldname, false)\n             } else {\n@@ -3233,7 +3233,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a pattern.\n-    pub fn parse_pat_nopanic(&mut self) -> PResult<P<Pat>> {\n+    pub fn parse_pat(&mut self) -> PResult<P<Pat>> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n@@ -3252,7 +3252,7 @@ impl<'a> Parser<'a> {\n                 return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n             }\n \n-            let subpat = try!(self.parse_pat_nopanic());\n+            let subpat = try!(self.parse_pat());\n             pat = PatRegion(subpat, mutbl);\n           }\n           token::OpenDelim(token::Paren) => {\n@@ -3280,7 +3280,7 @@ impl<'a> Parser<'a> {\n                 pat = try!(self.parse_pat_ident(BindByRef(mutbl)));\n             } else if try!(self.eat_keyword(keywords::Box)) {\n                 // Parse box pat\n-                let subpat = try!(self.parse_pat_nopanic());\n+                let subpat = try!(self.parse_pat());\n                 pat = PatBox(subpat);\n             } else if self.is_path_start() {\n                 // Parse pattern starting with a path\n@@ -3352,7 +3352,7 @@ impl<'a> Parser<'a> {\n                                     &token::OpenDelim(token::Paren),\n                                     &token::CloseDelim(token::Paren),\n                                     seq_sep_trailing_allowed(token::Comma),\n-                                    |p| p.parse_pat_nopanic()));\n+                                    |p| p.parse_pat()));\n                             pat = PatEnum(path, Some(args));\n                         }\n                       }\n@@ -3403,7 +3403,7 @@ impl<'a> Parser<'a> {\n         let last_span = self.last_span;\n         let name = codemap::Spanned{span: last_span, node: ident};\n         let sub = if try!(self.eat(&token::At) ){\n-            Some(try!(self.parse_pat_nopanic()))\n+            Some(try!(self.parse_pat()))\n         } else {\n             None\n         };\n@@ -3427,7 +3427,7 @@ impl<'a> Parser<'a> {\n     /// Parse a local variable declaration\n     fn parse_local(&mut self) -> PResult<P<Local>> {\n         let lo = self.span.lo;\n-        let pat = try!(self.parse_pat_nopanic());\n+        let pat = try!(self.parse_pat());\n \n         let mut ty = None;\n         if try!(self.eat(&token::Colon) ){\n@@ -3484,7 +3484,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement. may include decl.\n-    pub fn parse_stmt_nopanic(&mut self) -> PResult<Option<P<Stmt>>> {\n+    pub fn parse_stmt(&mut self) -> PResult<Option<P<Stmt>>> {\n         Ok(try!(self.parse_stmt_()).map(P))\n     }\n \n@@ -3915,7 +3915,7 @@ impl<'a> Parser<'a> {\n             self.span_err(self.span, &msg);\n \n             let span_hi = self.span.hi;\n-            let span_hi = if self.parse_ty_nopanic().is_ok() {\n+            let span_hi = if self.parse_ty().is_ok() {\n                 self.span.hi\n             } else {\n                 span_hi\n@@ -3959,7 +3959,7 @@ impl<'a> Parser<'a> {\n                     let span = p.span;\n                     p.span_warn(span, \"whoops, no =?\");\n                 }\n-                let ty = try!(p.parse_ty_nopanic());\n+                let ty = try!(p.parse_ty());\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);\n                 return Ok(P(TypeBinding{id: ast::DUMMY_NODE_ID,\n@@ -4040,7 +4040,7 @@ impl<'a> Parser<'a> {\n                         vec![]\n                     };\n \n-                    let bounded_ty = try!(self.parse_ty_nopanic());\n+                    let bounded_ty = try!(self.parse_ty());\n \n                     if try!(self.eat(&token::Colon) ){\n                         let bounds = try!(self.parse_ty_param_bounds(BoundParsingMode::Bare));\n@@ -4063,7 +4063,7 @@ impl<'a> Parser<'a> {\n \n                         parsed_something = true;\n                     } else if try!(self.eat(&token::Eq) ){\n-                        // let ty = try!(self.parse_ty_nopanic());\n+                        // let ty = try!(self.parse_ty());\n                         let hi = self.last_span.hi;\n                         let span = mk_sp(lo, hi);\n                         // where_clause.predicates.push(\n@@ -4479,7 +4479,7 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::Colon));\n             let typ = try!(self.parse_ty_sum());\n             try!(self.expect(&token::Eq));\n-            let expr = try!(self.parse_expr_nopanic());\n+            let expr = try!(self.parse_expr());\n             try!(self.commit_expr_expecting(&expr, token::Semi));\n             (name, ConstImplItem(typ, expr))\n         } else {\n@@ -4831,7 +4831,7 @@ impl<'a> Parser<'a> {\n     /// Given a termination token, parse all of the items in a module\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<Mod> {\n         let mut items = vec![];\n-        while let Some(item) = try!(self.parse_item_nopanic()) {\n+        while let Some(item) = try!(self.parse_item()) {\n             items.push(item);\n         }\n \n@@ -4857,7 +4857,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Colon));\n         let ty = try!(self.parse_ty_sum());\n         try!(self.expect(&token::Eq));\n-        let e = try!(self.parse_expr_nopanic());\n+        let e = try!(self.parse_expr());\n         try!(self.commit_expr_expecting(&*e, token::Semi));\n         let item = match m {\n             Some(m) => ItemStatic(ty, m, e),\n@@ -5187,7 +5187,7 @@ impl<'a> Parser<'a> {\n                 struct_def = VariantData::Tuple(try!(self.parse_tuple_struct_body(ParsePub::No)),\n                                                 ast::DUMMY_NODE_ID);\n             } else if try!(self.eat(&token::Eq) ){\n-                disr_expr = Some(try!(self.parse_expr_nopanic()));\n+                disr_expr = Some(try!(self.parse_expr()));\n                 any_disr = disr_expr.as_ref().map(|expr| expr.span);\n                 struct_def = VariantData::Unit(ast::DUMMY_NODE_ID);\n             } else {\n@@ -5619,7 +5619,7 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n-    pub fn parse_item_nopanic(&mut self) -> PResult<Option<P<Item>>> {\n+    pub fn parse_item(&mut self) -> PResult<Option<P<Item>>> {\n         let attrs = try!(self.parse_outer_attributes());\n         self.parse_item_(attrs, true)\n     }"}, {"sha": "a462dbeb6e4edb7412b6d8f54c3a6614735fc53d", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12a3582b113c0f9c217f6311ec0d47fd0f79016/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b12a3582b113c0f9c217f6311ec0d47fd0f79016", "patch": "@@ -50,29 +50,29 @@ pub fn string_to_crate (source_str : String) -> ast::Crate {\n /// Parse a string, return an expr\n pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_expr_nopanic()\n+        p.parse_expr()\n     })\n }\n \n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_item_nopanic()\n+        p.parse_item()\n     })\n }\n \n /// Parse a string, return a stmt\n pub fn string_to_stmt(source_str : String) -> Option<P<ast::Stmt>> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_stmt_nopanic()\n+        p.parse_stmt()\n     })\n }\n \n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_pat_nopanic()\n+        p.parse_pat()\n     })\n }\n "}]}