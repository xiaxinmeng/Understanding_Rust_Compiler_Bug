{"sha": "4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlOWI4YTI4ZjdjOWU4NTA4MGRkNTc3MTVlODU4M2MyM2EzZWY4MDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-02T10:30:11Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-02T11:20:11Z"}, "message": "Make resolving of imports behave more sanely\n\nAn import now ignores itself when resolving its target. This gets rid of\nthe previously existing (problematic) behaviour where the import would start\nlooking one scope up when its name was the same as its target's first\ncomponent.\n\nCloses #1114", "tree": {"sha": "f59b5d7c20f0cac05b58a15d360cdd7ca987cdf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f59b5d7c20f0cac05b58a15d360cdd7ca987cdf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "html_url": "https://github.com/rust-lang/rust/commit/4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e9b8a28f7c9e85080dd57715e8583c23a3ef802/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ed7e7fa7975205a0c45e94909c812e231083457", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed7e7fa7975205a0c45e94909c812e231083457", "html_url": "https://github.com/rust-lang/rust/commit/7ed7e7fa7975205a0c45e94909c812e231083457"}], "stats": {"total": 122, "additions": 57, "deletions": 65}, "files": [{"sha": "ebf99a996de78166e7288263f48c27d404edf1f5", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 57, "deletions": 65, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4e9b8a28f7c9e85080dd57715e8583c23a3ef802/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9b8a28f7c9e85080dd57715e8583c23a3ef802/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "patch": "@@ -107,6 +107,7 @@ type env =\n      ext_map: hashmap<def_id, [ident]>,\n      ext_cache: ext_hash,\n      mutable reported: [{ident: str, sc: scope}],\n+     mutable currently_resolving: node_id,\n      sess: session};\n \n \n@@ -127,6 +128,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           ext_map: new_def_hash::<[ident]>(),\n           ext_cache: new_ext_hash(),\n           mutable reported: [],\n+          mutable currently_resolving: -1,\n           sess: sess};\n     map_crate(e, crate);\n     resolve_imports(*e);\n@@ -218,11 +220,6 @@ fn map_crate(e: @env, c: @ast::crate) {\n             }\n         }\n         alt vi.node {\n-\n-\n-\n-\n-\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n@@ -435,73 +432,62 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n \n // Import resolution\n fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n-                  ids: [ast::ident], sp: codemap::span, sc_in: scopes) {\n+                  ids: [ast::ident], sp: codemap::span, sc: scopes) {\n+    fn register(e: env, id: node_id, sc: scopes, sp: codemap::span,\n+                name: ast::ident, lookup: block(namespace) -> option::t<def>){\n+        let val = lookup(ns_value), typ = lookup(ns_type),\n+            md = lookup(ns_module);\n+        if is_none(val) && is_none(typ) && is_none(md) {\n+            unresolved_err(e, sc, sp, name, \"import\");\n+        } else {\n+            e.imports.insert(id, resolved(val, typ, md));\n+        }\n+    }\n+    // This function has cleanup code at the end. Do not return without going\n+    // through that.\n     e.imports.insert(defid.node, resolving(sp));\n+    let previously_resolving = e.currently_resolving;\n+    e.currently_resolving = defid.node;\n     let n_idents = vec::len(ids);\n     let end_id = ids[n_idents - 1u];\n-    // Ignore the current scope if this import would shadow itself.\n-    let sc =\n-        if str::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n     if n_idents == 1u {\n-        register(e, defid, sp, end_id, sc_in,\n-                 lookup_in_scope(e, sc, sp, end_id, ns_value),\n-                 lookup_in_scope(e, sc, sp, end_id, ns_type),\n-                 lookup_in_scope(e, sc, sp, end_id, ns_module));\n-        remove_if_unresolved(e.imports, defid.node);\n+        register(e, defid.node, sc, sp, name,\n+                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns) });\n     } else {\n-        let dcur =\n-            alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n-              some(dcur) { dcur }\n-              none. {\n-                unresolved_err(e, sc, sp, ids[0], ns_name(ns_module));\n-                remove_if_unresolved(e.imports, defid.node);\n-                ret;\n-              }\n-            };\n-        let i = 1u;\n-        while true {\n-            if i == n_idents - 1u {\n-                register(e, defid, sp, end_id, sc_in,\n-                         lookup_in_mod(e, dcur, sp, end_id, ns_value,\n-                                       outside),\n-                         lookup_in_mod(e, dcur, sp, end_id, ns_type, outside),\n-                         lookup_in_mod(e, dcur, sp, end_id, ns_module,\n-                                       outside));\n-                remove_if_unresolved(e.imports, defid.node);\n-                break;\n-            } else {\n-                dcur = alt lookup_in_mod(e, dcur, sp, ids[i], ns_module,\n-                                         outside) {\n-                  some(dcur) { dcur }\n-                  none. {\n-                    unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n-                    remove_if_unresolved(e.imports, defid.node);\n-                    ret;\n-                  }\n-                };\n-                i += 1u;\n+        alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n+          none. { unresolved_err(e, sc, sp, ids[0], ns_name(ns_module)); }\n+          some(dcur_) {\n+            let dcur = dcur_, i = 1u;\n+            while true {\n+                if i == n_idents - 1u {\n+                    register(e, defid.node, sc, sp, name, {|ns|\n+                        lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n+                    });\n+                    break;\n+                } else {\n+                    dcur = alt lookup_in_mod(e, dcur, sp, ids[i], ns_module,\n+                                             outside) {\n+                      some(dcur) { dcur }\n+                      none. {\n+                        unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n+                        break;\n+                      }\n+                    };\n+                    i += 1u;\n+                }\n             }\n+          }\n         }\n     }\n-    fn register(e: env, defid: def_id, sp: span, name: ident, sc: scopes,\n-                val: option::t<def>, typ: option::t<def>,\n-                md: option::t<def>) {\n-        if is_none(val) && is_none(typ) && is_none(md) {\n-            unresolved_err(e, sc, sp, name, \"import\");\n-        } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n-    }\n-    fn remove_if_unresolved(imports: hashmap<ast::node_id, import_state>,\n-                            node_id: ast::node_id) {\n-\n-        // If we couldn't resolve the import, don't leave it in a partially\n-        // resolved state, to avoid having it reported later as a cyclic\n-        // import\n-        if imports.contains_key(node_id) {\n-            alt imports.get(node_id) {\n-              resolving(_) { imports.remove(node_id); }\n-              _ { }\n-            }\n-        }\n+    e.currently_resolving = previously_resolving;\n+    // If we couldn't resolve the import, don't leave it in a partially\n+    // resolved state, to avoid having it reported later as a cyclic\n+    // import\n+    alt e.imports.find(defid.node) {\n+      some(resolving(_)) {\n+        e.imports.insert(defid.node, resolved(none, none, none));\n+      }\n+      _ { }\n     }\n }\n \n@@ -937,7 +923,13 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n         resolve_import(e, local_def(node_id), name, path, span, scopes);\n         ret lookup_import(e, defid, ns);\n       }\n-      resolving(sp) { e.sess.span_err(sp, \"cyclic import\"); ret none; }\n+      resolving(sp) {\n+        // Imports are simply ignored when resolving themselves.\n+        if e.currently_resolving != defid.node {\n+            e.sess.span_err(sp, \"cyclic import\");\n+        }\n+        ret none;\n+      }\n       resolved(val, typ, md) {\n         ret alt ns { ns_value. { val } ns_type. { typ } ns_module. { md } };\n       }"}]}