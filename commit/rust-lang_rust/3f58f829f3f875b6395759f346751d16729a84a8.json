{"sha": "3f58f829f3f875b6395759f346751d16729a84a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNThmODI5ZjNmODc1YjYzOTU3NTlmMzQ2NzUxZDE2NzI5YTg0YTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-09T04:18:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-09T04:18:48Z"}, "message": "A different, more pretty printing approach.\n\nNo longer uses the Rope data strucure.", "tree": {"sha": "9680c0c63356ad0167349ce10c0a328530fa88f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9680c0c63356ad0167349ce10c0a328530fa88f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f58f829f3f875b6395759f346751d16729a84a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f58f829f3f875b6395759f346751d16729a84a8", "html_url": "https://github.com/rust-lang/rust/commit/3f58f829f3f875b6395759f346751d16729a84a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f58f829f3f875b6395759f346751d16729a84a8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fd5f867321104734ba163f20f71d2a8c076a90a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd5f867321104734ba163f20f71d2a8c076a90a", "html_url": "https://github.com/rust-lang/rust/commit/4fd5f867321104734ba163f20f71d2a8c076a90a"}], "stats": {"total": 452, "additions": 295, "deletions": 157}, "files": [{"sha": "7b56318be092ed3766a9e831f041a9ba880650d3", "filename": "src/changes.rs", "status": "modified", "additions": 21, "deletions": 58, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=3f58f829f3f875b6395759f346751d16729a84a8", "patch": "@@ -10,20 +10,19 @@\n \n \n // TODO\n-// print to files (maybe that shouldn't be here, but in mod)\n+// print to files \n // tests\n \n-use rope::{Rope, RopeSlice};\n+use string_buffer::StringBuffer;\n use std::collections::HashMap;\n-use syntax::codemap::{CodeMap, Span, BytePos};\n+use syntax::codemap::{CodeMap, Span};\n use std::fmt;\n \n // This is basically a wrapper around a bunch of Ropes which makes it convenient\n // to work with libsyntax. It is badly named.\n pub struct ChangeSet<'a> {\n-    file_map: HashMap<String, Rope>,\n+    file_map: HashMap<String, StringBuffer>,\n     codemap: &'a CodeMap,\n-    pub count: u64,\n }\n \n impl<'a> ChangeSet<'a> {\n@@ -32,64 +31,35 @@ impl<'a> ChangeSet<'a> {\n         let mut result = ChangeSet {\n             file_map: HashMap::new(),\n             codemap: codemap,\n-            count: 0,\n         };\n \n         for f in codemap.files.borrow().iter() {\n-            let contents = Rope::from_string((&**f.src.as_ref().unwrap()).clone());\n-            result.file_map.insert(f.name.clone(), contents);\n+            // Use the length of the file as a heuristic for how much space we\n+            // need. I hope that at some stage someone rounds this up to the next\n+            // power of two. TODO check that or do it here.\n+            result.file_map.insert(f.name.clone(),\n+                                   StringBuffer::with_capacity(f.src.as_ref().unwrap().len()));\n         }\n \n         result\n     }\n \n-    // Change a span of text in our stored text into the new text (`text`).\n-    // The span of text to change is given in the coordinates of the original\n-    // source text, not the current text,\n-    pub fn change(&mut self, file_name: &str, start: usize, end: usize, text: String) {\n-        println!(\"change: {}:{}-{} \\\"{}\\\"\", file_name, start, end, text);\n-\n-        self.count += 1;\n-\n-        let file = &mut self.file_map[*file_name];\n-\n-        if end - start == text.len() {\n-            // TODO src_replace_str would be much more efficient\n-            //file.src_replace_str(start, &text);\n-            file.src_remove(start, end);\n-            file.src_insert(start, text);\n-        } else {\n-            // TODO if we do this in one op, could we get better change info?\n-            file.src_remove(start, end);\n-            file.src_insert(start, text);\n-        }\n+    pub fn push_str(&mut self, file_name: &str, text: &str) {\n+        self.file_map[*file_name].push_str(text)\n     }\n \n-    // As for `change()`, but use a Span to indicate the text to change.\n-    pub fn change_span(&mut self, span: Span, text: String) {\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let file_offset = l_loc.file.start_pos.0;\n-        self.change(&l_loc.file.name,\n-                    (span.lo.0 - file_offset) as usize,\n-                    (span.hi.0 - file_offset) as usize,\n-                    text)\n+    pub fn push_str_span(&mut self, span: Span, text: &str) {\n+        let file_name = self.codemap.span_to_filename(span);\n+        self.push_str(&file_name, text)\n     }\n \n-    // Get a slice of the current text. Coordinates are relative to the source\n-    // text. I.e., this method returns the text which has been changed from the\n-    // indicated span.\n-    pub fn slice(&self, file_name: &str, start: usize, end: usize) -> RopeSlice {\n-        let file = &self.file_map[*file_name];\n-        file.src_slice(start..end)\n+    pub fn cur_offset(&mut self, file_name: &str) -> usize {\n+        self.file_map[*file_name].cur_offset()\n     }\n \n-    // As for `slice()`, but use a Span to indicate the text to return.\n-    pub fn slice_span(&self, span:Span) -> RopeSlice {\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let file_offset = l_loc.file.start_pos.0;\n-        self.slice(&l_loc.file.name,\n-                   (span.lo.0 - file_offset) as usize,\n-                   (span.hi.0 - file_offset) as usize)\n+    pub fn cur_offset_span(&mut self, span: Span) -> usize {\n+        let file_name = self.codemap.span_to_filename(span);\n+        self.cur_offset(&file_name)\n     }\n \n     // Return an iterator over the entire changed text.\n@@ -101,13 +71,6 @@ impl<'a> ChangeSet<'a> {\n         }\n     }\n \n-    // Get the current line-relative position of a position in the source text.\n-    pub fn col(&self, loc: BytePos) -> usize {\n-        let l_loc = self.codemap.lookup_char_pos(loc);\n-        let file_offset = l_loc.file.start_pos.0;\n-        let file = &self.file_map[l_loc.file.name[..]];\n-        file.col_for_src_loc(loc.0 as usize - file_offset as usize)\n-    }\n }\n \n // Iterates over each file in the ChangSet. Yields the filename and the changed\n@@ -119,9 +82,9 @@ pub struct FileIterator<'c, 'a: 'c> {\n }\n \n impl<'c, 'a> Iterator for FileIterator<'c, 'a> {\n-    type Item = (&'c str, &'c Rope);\n+    type Item = (&'c str, &'c StringBuffer);\n \n-    fn next(&mut self) -> Option<(&'c str, &'c Rope)> {\n+    fn next(&mut self) -> Option<(&'c str, &'c StringBuffer)> {\n         if self.cur_key >= self.keys.len() {\n             return None;\n         }"}, {"sha": "16e9c84ab84711441f96e11a9f7cb0815a058676", "filename": "src/mod.rs", "status": "modified", "additions": 255, "deletions": 97, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=3f58f829f3f875b6395759f346751d16729a84a8", "patch": "@@ -18,6 +18,9 @@\n #![feature(old_path)]\n #![feature(exit_status)]\n \n+// TODO we're going to allocate a whole bunch of temp Strings, is it worth\n+// keeping some scratch mem for this and running our own StrPool?\n+\n #[macro_use]\n extern crate log;\n \n@@ -30,29 +33,34 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n \n-use syntax::ast;\n-use syntax::codemap::{self, CodeMap, Span, Pos};\n+use syntax::{ast, ptr};\n+use syntax::codemap::{self, CodeMap, Span, Pos, BytePos};\n use syntax::diagnostics;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::visit;\n \n-use std::mem;\n+use std::slice::SliceConcatExt;\n \n use changes::ChangeSet;\n \n pub mod rope;\n+pub mod string_buffer;\n mod changes;\n \n const IDEAL_WIDTH: usize = 80;\n+const LEEWAY: usize = 5;\n const MAX_WIDTH: usize = 100;\n const MIN_STRING: usize = 10;\n \n // Formatting which depends on the AST.\n fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n-    let mut visitor = FmtVisitor { codemap: codemap,\n-                                   changes: ChangeSet::from_codemap(codemap) };\n+    let mut visitor = FmtVisitor::from_codemap(codemap);\n     visit::walk_crate(&mut visitor, krate);\n+    let files = codemap.files.borrow();\n+    if let Some(last) = files.last() {\n+        visitor.format_missing(last.end_pos);\n+    }\n \n     visitor.changes\n }\n@@ -69,7 +77,7 @@ fn fmt_lines(changes: &mut ChangeSet) {\n             if c == '\\n' { // TOOD test for \\r too\n                 // Check for (and record) trailing whitespace.\n                 if let Some(lw) = last_wspace {\n-                    trims.push((lw, b));\n+                    trims.push((cur_line, lw, b));\n                     line_len -= b - lw;\n                 }\n                 // Check for any line width errors we couldn't correct.\n@@ -93,45 +101,53 @@ fn fmt_lines(changes: &mut ChangeSet) {\n             }\n         }\n \n-        unsafe {\n-            // Invariant: we only mutate a rope after we have searched it, then\n-            // we will not search it again.\n-            let mut_text: &mut rope::Rope = mem::transmute(text);\n-            let mut_count: &mut u64 = mem::transmute(&changes.count);\n-            let mut offset = 0;\n-            // Get rid of any trailing whitespace we recorded earlier.\n-            for &(s, e) in trims.iter() {\n-                // Note that we change the underlying ropes directly, we don't\n-                // go through the changeset because our change positions are\n-                // relative to the newest text, not the original.\n-                debug!(\"Stripping trailing whitespace {}:{}-{} \\\"{}\\\"\",\n-                       f, s, e, text.slice(s-offset..e-offset));\n-                mut_text.remove(s-offset, e-offset);\n-                *mut_count += 1;\n-                offset += e - s;\n-            }\n+        for &(l, _, _) in trims.iter() {\n+            // FIXME store the error rather than reporting immediately.\n+            println!(\"Rustfmt left trailing whitespace at {}:{} (sorry)\", f, l);\n         }\n     }\n }\n \n struct FmtVisitor<'a> {\n     codemap: &'a CodeMap,\n     changes: ChangeSet<'a>,\n+    last_pos: BytePos,\n+    block_indent: usize,\n }\n \n impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        match ex.node {\n-            ast::Expr_::ExprLit(ref l) => match l.node {\n-                ast::Lit_::LitStr(ref is, _) => {\n-                    self.rewrite_string(&is, l.span);\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n+        self.format_missing(ex.span.lo);\n+        let offset = self.changes.cur_offset_span(ex.span);\n+        let new_str = self.rewrite_expr(ex, MAX_WIDTH - offset, offset);\n+        self.changes.push_str_span(ex.span, &new_str);\n+        self.last_pos = ex.span.hi;\n+    }\n+\n+    fn visit_block(&mut self, b: &'v ast::Block) {\n+        self.format_missing(b.span.lo);\n+\n+        self.changes.push_str_span(b.span, \"{\");\n+        self.last_pos = self.last_pos + BytePos(1);\n+        self.block_indent += 4;\n+\n+        for stmt in &b.stmts {\n+            self.format_missing_with_indent(stmt.span.lo);\n+            self.visit_stmt(&**stmt)\n+        }\n+        match b.expr {\n+            Some(ref e) => {\n+                self.format_missing_with_indent(e.span.lo);\n+                self.visit_expr(e);\n+            }\n+            None => {}\n         }\n \n-        visit::walk_expr(self, ex)\n+        self.block_indent -= 4;\n+        // TODO we should compress any newlines here to just one\n+        self.format_missing_with_indent(b.span.hi - BytePos(1));\n+        self.changes.push_str_span(b.span, \"}\");\n+        self.last_pos = b.span.hi;\n     }\n \n     fn visit_fn(&mut self,\n@@ -140,32 +156,38 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 _: ast::NodeId) {\n-        self.fix_formal_args(fd);\n+        if let Some(new_str) = self.formal_args(fk, fd) {\n+            self.changes.push_str_span(s, &new_str);            \n+        }\n         visit::walk_fn(self, fk, fd, b, s);\n     }\n \n     fn visit_item(&mut self, item: &'v ast::Item) {\n-        // TODO check each item is on a new line and is correctly indented.\n         match item.node {\n             ast::Item_::ItemUse(ref vp) => {\n                 match vp.node {\n                     ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n+                        self.format_missing(item.span.lo);\n                         let new_str = self.fix_use_list(path, path_list, vp.span);\n-\n-                        // TODO move these optimisations to ChangeSet\n-                        if new_str != self.codemap.span_to_snippet(item.span).unwrap() {\n-                            self.changes.change_span(item.span, new_str);\n-                        }\n+                        self.changes.push_str_span(item.span, &new_str);\n+                        self.last_pos = item.span.hi;\n                     }\n                     ast::ViewPath_::ViewPathGlob(_) => {\n                         // FIXME convert to list?\n                     }\n                     _ => {}\n                 }\n+                visit::walk_item(self, item);\n+            }\n+            ast::Item_::ItemImpl(..) => {\n+                self.block_indent += 4;\n+                visit::walk_item(self, item);\n+                self.block_indent -= 4;\n+            }\n+            _ => {\n+                visit::walk_item(self, item);\n             }\n-            _ => {}\n         }\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -178,30 +200,107 @@ fn make_indent(width: usize) -> String {\n }\n \n impl<'a> FmtVisitor<'a> {\n+    fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n+        FmtVisitor {\n+            codemap: codemap,\n+            changes: ChangeSet::from_codemap(codemap),\n+            last_pos: BytePos(0),\n+            block_indent: 0,\n+        }\n+    }\n+\n+    fn format_missing(&mut self, end: BytePos) {\n+        self.format_missing_inner(end, |this, last_snippet, span, _| {\n+            this.changes.push_str_span(span, last_snippet)\n+        })\n+    }\n+\n+    fn format_missing_with_indent(&mut self, end: BytePos) {\n+        self.format_missing_inner(end, |this, last_snippet, span, snippet| {\n+            if last_snippet == snippet {\n+                // No new lines\n+                this.changes.push_str_span(span, last_snippet);\n+                this.changes.push_str_span(span, \"\\n\");\n+            } else {\n+                this.changes.push_str_span(span, last_snippet.trim_right());\n+            }\n+            let indent = make_indent(this.block_indent);\n+            this.changes.push_str_span(span, &indent);           \n+        })\n+    }\n+\n+    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, Span, &str)>(&mut self,\n+                                                                      end: BytePos,\n+                                                                      process_last_snippet: F)\n+    {\n+        let start = self.last_pos;\n+        // TODO(#11) gets tricky if we're missing more than one file\n+        assert!(self.codemap.lookup_char_pos(start).file.name == self.codemap.lookup_char_pos(end).file.name,\n+                \"not implemented: unformated span across files\");\n+\n+        self.last_pos = end;\n+        let span = codemap::mk_sp(start, end);\n+        let snippet = self.snippet(span);\n+\n+        // Annoyingly, the library functions for splitting by lines etc. are not\n+        // quite right, so we must do it ourselves.\n+        let mut line_start = 0;\n+        let mut last_wspace = None;\n+        for (i, c) in snippet.char_indices() {\n+            if c == '\\n' {\n+                if let Some(lw) = last_wspace {\n+                    self.changes.push_str_span(span, &snippet[line_start..lw]);\n+                    self.changes.push_str_span(span, \"\\n\");\n+                } else {\n+                    self.changes.push_str_span(span, &snippet[line_start..i+1]);\n+                }\n+\n+                line_start = i + 1;\n+                last_wspace = None;\n+            } else {\n+                if c.is_whitespace() {\n+                    if last_wspace.is_none() {\n+                        last_wspace = Some(i);\n+                    }\n+                } else {\n+                    last_wspace = None;\n+                }\n+            }\n+        }\n+        process_last_snippet(self, &snippet[line_start..], span, &snippet);\n+    }\n+\n+    fn snippet(&self, span: Span) -> String {\n+        match self.codemap.span_to_snippet(span) {\n+            Ok(s) => s,\n+            Err(_) => {\n+                println!(\"Couldn't make snippet for span {:?}\", span);\n+                \"\".to_string()\n+            }\n+        }\n+    }\n+\n     // TODO NEEDS TESTS\n-    fn rewrite_string(&mut self, s: &str, span: Span) {\n+    fn rewrite_string(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n         // FIXME I bet this stomps unicode escapes in the source string\n \n         // Check if there is anything to fix: we always try to fixup multi-line\n         // strings, or if the string is too long for the line.\n         let l_loc = self.codemap.lookup_char_pos(span.lo);\n         let r_loc = self.codemap.lookup_char_pos(span.hi);\n         if l_loc.line == r_loc.line && r_loc.col.to_usize() <= MAX_WIDTH {\n-            return;\n+            return self.snippet(span);\n         }\n \n         // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n \n         let s = s.escape_default();\n \n-        // TODO use fixed value.\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let l_col = l_loc.col.to_usize();\n-        \n-        let indent = make_indent(l_col + 1);\n+        let offset = offset + 1;\n+        let indent = make_indent(offset);\n         let indent = &indent;\n \n-        let max_chars = MAX_WIDTH - (l_col + 1);\n+        let max_chars = width - 1;\n \n         let mut cur_start = 0;\n         let mut result = String::new();\n@@ -242,12 +341,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n         result.push('\"');\n \n-        // Check that we actually changed something.\n-        if result == self.codemap.span_to_snippet(span).unwrap() {\n-            return;\n-        }\n-\n-        self.changes.change_span(span, result);\n+        result\n     }\n \n     // Basically just pretty prints a multi-item import.\n@@ -314,55 +408,115 @@ impl<'a> FmtVisitor<'a> {\n         new_str\n     }\n \n-    fn fix_formal_args<'v>(&mut self, fd: &'v ast::FnDecl) {\n+    fn formal_args<'v>(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl) -> Option<String> {\n         // For now, just check the arguments line up and make them per-row if the line is too long.\n         let args = &fd.inputs;\n-        if args.len() <= 1 {\n-            return;\n+\n+        let ret_str = match fd.output {\n+            ast::FunctionRetTy::DefaultReturn(_) => \"\".to_string(),\n+            ast::FunctionRetTy::NoReturn(_) => \" -> !\".to_string(),\n+            ast::FunctionRetTy::Return(ref ty) => pprust::ty_to_string(ty),\n+        };\n+\n+        // TODO don't return, want to do the return type etc.\n+        if args.len() == 0 {\n+            return None;\n         }\n+\n         // TODO not really using the hi positions\n         let spans: Vec<_> = args.iter().map(|a| (a.pat.span.lo, a.ty.span.hi)).collect();\n-        let locs: Vec<_> = spans.iter().map(|&(a, b)| (self.codemap.lookup_char_pos(a), self.codemap.lookup_char_pos(b))).collect();\n-        let first_loc = &locs[0].0;\n-        // TODO need to adjust for previous changes here.\n-        let same_row = locs.iter().all(|&(ref l, _)| l.line == first_loc.line);\n-        let same_col = locs.iter().all(|&(ref l, _)| l.col == first_loc.col);\n-\n-        if same_col {\n-            // TODO Check one arg per line and no lines in between (except comments)\n-            return;\n-        }        \n-\n-        if same_row { // TODO check line is < 100 && first_loc.line {\n-            // TODO could also fix whitespace around punctuaton here\n-            // TODO and could check that we're on the same line as the function call, if possible\n-            return;\n+        let locs: Vec<_> = spans.iter().map(|&(a, b)| {\n+            (self.codemap.lookup_char_pos(a), self.codemap.lookup_char_pos(b))\n+        }).collect();\n+        let first_col = locs[0].0.col.0;\n+\n+        // Print up to the start of the args.\n+        self.format_missing(spans[0].0);\n+        self.last_pos = spans.last().unwrap().1;\n+\n+        let arg_strs: Vec<_> = args.iter().map(|a| format!(\"{}: {}\",\n+                                                           pprust::pat_to_string(&a.pat),\n+                                                           pprust::ty_to_string(&a.ty))).collect();\n+\n+        // Try putting everything on one row:\n+        let mut len = arg_strs.iter().fold(0, |a, b| a + b.len());\n+        // Account for punctuation and spacing.\n+        len += 2 * arg_strs.len() + 2 * (arg_strs.len()-1);\n+        // Return type.\n+        len += ret_str.len();\n+        // Opening brace if no where clause.\n+        match fk {\n+            visit::FnKind::FkItemFn(_, g, _, _) |\n+            visit::FnKind::FkMethod(_, g, _)\n+            if g.where_clause.predicates.len() > 0 => {}\n+            _ => len += 2 // ` {`\n         }\n+        len += first_col;\n+\n+        if len <= IDEAL_WIDTH + LEEWAY || args.len() == 1 {\n+            // It should all fit on one line.\n+            return Some(arg_strs.connect(\", \"));\n+        } else {\n+            // TODO multi-line\n+            let mut indent = String::with_capacity(first_col + 2);\n+            indent.push_str(\",\\n\");\n+            for _ in 0..first_col { indent.push(' '); }\n+            return Some(arg_strs.connect(&indent));\n+        }\n+    }\n \n-        let col = self.changes.col(spans[0].0);\n-        let mut indent = String::with_capacity(col);\n-        indent.push('\\n');\n-        for _ in 0..col { indent.push(' '); }\n-        let last_idx = spans.len() - 1;\n-        for (i, s) in spans.iter().enumerate() {\n-            // Take the span from lo to lo (or the last hi for the last arg), \n-            // trim, push on top of indent, then replace the old lo-lo span with it.\n-            let mut new_text = if i == 0 {\n-                \"\".to_string()\n-            } else {\n-                indent.clone()\n-            };\n-            let hi = if i == last_idx {\n-                s.1\n-            } else {\n-                spans[i+1].0\n-            };\n-            // TODO need a version of slice taking locs, not a span\n-            let snippet = self.changes.slice_span(Span{ lo: s.0, hi: hi, expn_id: codemap::NO_EXPANSION }).to_string();\n-            let snippet = snippet.trim();\n-            new_text.push_str(snippet);\n-            self.changes.change(&first_loc.file.name, (s.0).0 as usize, hi.0 as usize, new_text);\n+    fn rewrite_call(&mut self,\n+                    callee: &ast::Expr,\n+                    args: &[ptr::P<ast::Expr>],\n+                    width: usize,\n+                    offset: usize)\n+        -> String\n+    {\n+        debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n+\n+        // TODO using byte lens instead of char lens (and probably all over the place too)\n+        let callee_str = self.rewrite_expr(callee, width, offset);\n+        debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n+        // 2 is for parens.\n+        let remaining_width = width - callee_str.len() - 2;\n+        let offset = callee_str.len() + 1 + offset;\n+        let arg_count = args.len();\n+        let args: Vec<_> = args.iter().map(|e| self.rewrite_expr(e,\n+                                                                 remaining_width,\n+                                                                 offset)).collect();\n+        debug!(\"rewrite_call, args: `{}`\", args.connect(\",\"));\n+\n+        let multi_line = args.iter().any(|s| s.contains('\\n'));\n+        let args_width = args.iter().map(|s| s.len()).fold(0, |a, l| a + l);\n+        let over_wide = args_width + (arg_count - 1) * 2 > remaining_width;\n+        let args_str = if multi_line || over_wide {\n+            args.connect(&(\",\\n\".to_string() + &make_indent(offset)))\n+        } else {\n+            args.connect(\", \")\n+        };\n+\n+        format!(\"{}({})\", callee_str, args_str)\n+    }\n+\n+    fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n+        match expr.node {\n+            ast::Expr_::ExprLit(ref l) => {\n+                match l.node {\n+                    ast::Lit_::LitStr(ref is, _) => {\n+                        return self.rewrite_string(&is, l.span, width, offset);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            ast::Expr_::ExprCall(ref callee, ref args) => {\n+                return self.rewrite_call(callee, args, width, offset);\n+            }\n+            _ => {}\n         }\n+\n+        let result = self.snippet(expr.span);\n+        debug!(\"snippet: {}\", result);\n+        result\n     }\n }\n \n@@ -439,9 +593,11 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n             let mut changes = fmt_ast(krate, codemap);\n             fmt_lines(&mut changes);\n \n-            println!(\"Making {} changes\", changes.count);\n             println!(\"{}\", changes);\n             // FIXME(#5) Should be user specified whether to show or replace.\n+\n+            // TODO we stop before expansion, but we still seem to get expanded for loops which\n+            // cause problems - probably a rustc bug\n         };\n \n         control\n@@ -466,3 +622,5 @@ fn main() {\n // algorithm to keep the width under IDEAL_WIDTH. We should also convert multiline\n // /* ... */ comments to // and check doc comments are in the right place and of\n // the right kind.\n+\n+// Should also make sure comments have the right indent"}, {"sha": "c7ed62afb051da961831887f27f018d24fd02443", "filename": "src/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f58f829f3f875b6395759f346751d16729a84a8/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58f829f3f875b6395759f346751d16729a84a8/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=3f58f829f3f875b6395759f346751d16729a84a8", "patch": "@@ -1164,7 +1164,7 @@ mod test {\n \n     #[test]\n     fn test_from_string() {\n-        let mut r: Rope = \"Hello world!\".parse().unwrap();\n+        let r: Rope = \"Hello world!\".parse().unwrap();\n         assert!(r.to_string() == \"Hello world!\");\n     }\n "}, {"sha": "142231b6d7d4cead29ae5a8e2b7d85ce43dc31a6", "filename": "src/string_buffer.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fstring_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58f829f3f875b6395759f346751d16729a84a8/src%2Fstring_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring_buffer.rs?ref=3f58f829f3f875b6395759f346751d16729a84a8", "patch": "@@ -15,7 +15,7 @@\n // Debug\n // docs\n // char iterator\n-//   Chars -> CharsAndPos\n+//   chars -> char_indices and flip order of char/index\n // Eq\n \n extern crate unicode;\n@@ -74,6 +74,17 @@ impl StringBuffer {\n         }\n     }\n \n+    // Returns the number of characters from start of the last line in the\n+    // StringBuffer.\n+    // Note that it is possible for this operation to take a long time in\n+    // pathological cases (lots of nodes, few line breaks).\n+    pub fn cur_offset(&self) -> usize {\n+        unsafe {\n+            let result = (&*self.last).cur_offset();\n+            result.unwrap_or_else(|| panic!(\"Unimplemented cur_offset across node boundaries\"))\n+        }\n+    }\n+\n     pub fn chars<'a>(&'a self) -> Chars<'a> {\n         Chars::new(&self.first)\n     }\n@@ -108,6 +119,11 @@ impl StringNode {\n             &mut **next\n         }\n     }\n+\n+    // None if there is no new line in this node.\n+    fn cur_offset(&self) -> Option<usize> {\n+        self.data.rfind('\\n').map(|i| self.data.len() - i - 1)\n+    }\n }\n \n impl FromStr for StringBuffer {\n@@ -276,6 +292,7 @@ mod test {\n \n     // TODO test unicode\n \n+    // Helper methods.\n     fn count_nodes(s: &StringBuffer) -> usize {\n         count_nodes_from(&s.first)\n     }"}]}