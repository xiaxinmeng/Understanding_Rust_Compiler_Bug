{"sha": "73806ddd0fd91066d7b903a00a080cbadcc04311", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczODA2ZGRkMGZkOTEwNjZkN2I5MDNhMDBhMDgwY2JhZGNjMDQzMTE=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-09-16T02:29:47Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-05T20:00:56Z"}, "message": "Use $crate and macro reexport to reduce duplicated code\n\nMany of libstd's macros are now re-exported from libcore and libcollections.\nTheir libstd definitions have moved to a macros_stage0 module and can disappear\nafter the next snapshot.\n\nWhere the two crates had already diverged, I took the libstd versions as\nthey're generally newer and better-tested. See e.g. d3c831b, which was a fix to\nlibstd's assert_eq!() that didn't make it into libcore's.\n\nFixes #16806.", "tree": {"sha": "04df4f385e3e01a3f278862f190026aa6daca966", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04df4f385e3e01a3f278862f190026aa6daca966"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73806ddd0fd91066d7b903a00a080cbadcc04311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73806ddd0fd91066d7b903a00a080cbadcc04311", "html_url": "https://github.com/rust-lang/rust/commit/73806ddd0fd91066d7b903a00a080cbadcc04311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73806ddd0fd91066d7b903a00a080cbadcc04311/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2fddc6bf6332212fe899c2cb86ae7e645f6eba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2fddc6bf6332212fe899c2cb86ae7e645f6eba", "html_url": "https://github.com/rust-lang/rust/commit/1c2fddc6bf6332212fe899c2cb86ae7e645f6eba"}], "stats": {"total": 1157, "additions": 913, "deletions": 244}, "files": [{"sha": "27ab791b60425d60a7c3f243657c0a626ec273ee", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -51,6 +51,9 @@ pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+// Needed for the vec! macro\n+pub use alloc::boxed;\n+\n mod macros;\n \n pub mod binary_heap;"}, {"sha": "0dbc71269a6701150272309f8c62d0e4e06eb281", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -11,6 +11,8 @@\n #![macro_escape]\n \n /// Creates a `std::vec::Vec` containing the arguments.\n+// NOTE: remove after the next snapshot\n+#[cfg(stage0)]\n macro_rules! vec {\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning.\n@@ -21,3 +23,13 @@ macro_rules! vec {\n     ($($e:expr),+,) => (vec!($($e),+))\n }\n \n+/// Creates a `Vec` containing the arguments.\n+#[cfg(not(stage0))]\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: $crate::boxed::Box<[_]> = box [$($x),*];\n+        $crate::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}"}, {"sha": "b7c225c276ab9e55e971484af89ed4c1033cb434", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -20,12 +20,15 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, FnOnce};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt, Utf8Error};\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;"}, {"sha": "0cda2e4a9c692eb886300dfcd99aacd46252c3bc", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -130,6 +130,7 @@ mod array;\n #[doc(hidden)]\n mod core {\n     pub use panicking;\n+    pub use fmt;\n }\n \n #[doc(hidden)]"}, {"sha": "3b21a68a292f4ac23601a6e1b5a19a43e3580943", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 177, "deletions": 22, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -30,69 +30,224 @@ macro_rules! panic {\n     });\n }\n \n-/// Runtime assertion, for details see std::macros\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n-    ($cond:expr, $($arg:tt)*) => (\n+    ($cond:expr, $($arg:expr),+) => (\n         if !$cond {\n-            panic!($($arg)*)\n+            panic!($($arg),+)\n         }\n     );\n }\n \n-/// Runtime assertion for equality, for details see std::macros\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert_eq {\n-    ($cond1:expr, $cond2:expr) => ({\n-        let c1 = $cond1;\n-        let c2 = $cond2;\n-        if c1 != c2 || c2 != c1 {\n-            panic!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n         }\n     })\n }\n \n-/// Runtime assertion for equality, only without `--cfg ndebug`\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! debug_assert_eq {\n-    ($($a:tt)*) => ({\n-        if cfg!(not(ndebug)) {\n-            assert_eq!($($a)*);\n-        }\n-    })\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n }\n \n-/// Runtime assertion, disableable at compile time with `--cfg ndebug`\n+#[cfg(stage0)]\n #[macro_export]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+macro_rules! try {\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n /// Short circuiting evaluation on Err\n+///\n+/// `libstd` contains a more general `try!` macro that uses `FromError`.\n+#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! try {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+    ($e:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(e),\n+        }\n+    })\n }\n \n-/// Writing a formatted string into a writer\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n #[macro_export]\n macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-/// Writing a formatted string plus a newline into a writer\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n #[macro_export]\n+#[stable]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n     )\n }\n \n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n #[macro_export]\n-macro_rules! unreachable { () => (panic!(\"unreachable code\")) }\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n \n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}"}, {"sha": "b1906da43558fff8099d02c358a2a3d99f9f4370", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -21,7 +21,9 @@ use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, IteratorExt, IteratorCloneExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n-use result::Result::{Ok, Err};\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::{Ok, Err};\n \n use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n "}, {"sha": "0882efde232fe20c0a21ddc03dc2679aee9a5fde", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -18,11 +18,14 @@ use iter::ExactSizeIterator;\n use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n /// Wraps a Reader and buffers input from it\n ///\n /// It can be excessively inefficient to work directly with a `Reader`. For"}, {"sha": "eba90d39b4ab566caacbe0362aea1ec9e2991032", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -117,13 +117,18 @@\n \n #![reexport_test_harness_main = \"test_main\"]\n \n+#![macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n+    unreachable, unimplemented, write, writeln, vec)]\n+\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-extern crate alloc;\n-extern crate unicode;\n+#[phase(plugin, link)]\n extern crate core;\n+#[phase(plugin, link)]\n extern crate \"collections\" as core_collections;\n extern crate \"rand\" as core_rand;\n+extern crate alloc;\n+extern crate unicode;\n extern crate libc;\n \n // Make std testable by not duplicating lang items. See #2912\n@@ -167,7 +172,8 @@ pub use unicode::char;\n \n /* Exported macros */\n \n-pub mod macros;\n+#[cfg(stage0)] pub mod macros_stage0;\n+#[cfg(not(stage0))] pub mod macros;\n pub mod bitflags;\n \n mod rtdeps;"}, {"sha": "e833acb968df32a52fb817ce3e37068f020ffbfc", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 213, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -57,179 +57,6 @@ macro_rules! panic {\n     });\n }\n \n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// assert!(true);\n-/// # fn some_computation() -> bool { true }\n-/// assert!(some_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! assert {\n-    ($cond:expr) => (\n-        if !$cond {\n-            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n-        }\n-    );\n-    ($cond:expr, $($arg:expr),+) => (\n-        if !$cond {\n-            panic!($($arg),+)\n-        }\n-    );\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! assert_eq {\n-    ($left:expr , $right:expr) => ({\n-        match (&($left), &($right)) {\n-            (left_val, right_val) => {\n-                // check both directions of equality....\n-                if !((*left_val == *right_val) &&\n-                     (*right_val == *left_val)) {\n-                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n-                }\n-            }\n-        }\n-    })\n-}\n-\n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n-/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n-/// checks that are too expensive to be present in a release build but may be\n-/// helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// debug_assert!(true);\n-/// # fn some_expensive_computation() -> bool { true }\n-/// debug_assert!(some_expensive_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n-/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n-/// useful for checks that are too expensive to be present in a release build\n-/// but may be helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// debug_assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n-}\n-\n-/// A utility macro for indicating unreachable code.\n-///\n-/// This is useful any time that the compiler can't determine that some code is unreachable. For\n-/// example:\n-///\n-/// * Match arms with guard conditions.\n-/// * Loops that dynamically terminate.\n-/// * Iterators that dynamically terminate.\n-///\n-/// # Panics\n-///\n-/// This will always panic.\n-///\n-/// # Examples\n-///\n-/// Match arms:\n-///\n-/// ```rust\n-/// fn foo(x: Option<int>) {\n-///     match x {\n-///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n-///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n-///         Some(_)           => unreachable!(), // compile error if commented out\n-///         None              => println!(\"None\")\n-///     }\n-/// }\n-/// ```\n-///\n-/// Iterators:\n-///\n-/// ```rust\n-/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n-///     for i in std::iter::count(0_u32, 1) {\n-///         if 3*i < i { panic!(\"u32 overflow\"); }\n-///         if x < 3*i { return i-1; }\n-///     }\n-///     unreachable!();\n-/// }\n-/// ```\n-#[macro_export]\n-macro_rules! unreachable {\n-    () => ({\n-        panic!(\"internal error: entered unreachable code\")\n-    });\n-    ($msg:expr) => ({\n-        unreachable!(\"{}\", $msg)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n-    });\n-}\n-\n-/// A standardised placeholder for marking unfinished code. It panics with the\n-/// message `\"not yet implemented\"` when executed.\n-#[macro_export]\n-macro_rules! unimplemented {\n-    () => (panic!(\"not yet implemented\"))\n-}\n-\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///\n@@ -246,34 +73,6 @@ macro_rules! format {\n     ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n }\n \n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n-}\n-\n-/// Equivalent to the `write!` macro, except that a newline is appended after\n-/// the message is written.\n-#[macro_export]\n-#[stable]\n-macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n-}\n-\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -306,23 +105,15 @@ macro_rules! println {\n #[macro_export]\n macro_rules! try {\n     ($expr:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n         match $expr {\n             Ok(val) => val,\n-            Err(err) => return Err(::std::error::FromError::from_error(err))\n+            Err(err) => return Err($crate::error::FromError::from_error(err)),\n         }\n     })\n }\n \n-/// Create a `std::vec::Vec` containing the arguments.\n-#[macro_export]\n-macro_rules! vec {\n-    ($($x:expr),*) => ({\n-        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        ::std::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n /// A macro to select an event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of\n@@ -358,7 +149,7 @@ macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n-        use std::sync::mpsc::Select;\n+        use $crate::sync::mpsc::Select;\n         let sel = Select::new();\n         $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {"}, {"sha": "63fd3209cc0193b619f811373be8f97886f57781", "filename": "src/libstd/macros_stage0.rs", "status": "added", "additions": 649, "deletions": 0, "changes": 649, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fmacros_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Fmacros_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros_stage0.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -0,0 +1,649 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Standard library macros\n+//!\n+//! This modules contains a set of macros which are exported from the standard\n+//! library. Each macro is available for use when linking against the standard\n+//! library.\n+\n+#![experimental]\n+#![macro_escape]\n+\n+/// The entry point for panic of Rust tasks.\n+///\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n+/// the value which is transmitted.\n+///\n+/// The multi-argument form of this macro panics with a string and has the\n+/// `format!` syntax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![allow(unreachable_code)]\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n+#[macro_export]\n+macro_rules! panic {\n+    () => ({\n+        panic!(\"explicit panic\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+\n+    });\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert {\n+    ($cond:expr) => (\n+        if !$cond {\n+            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n+        }\n+    );\n+    ($cond:expr, $($arg:expr),+) => (\n+        if !$cond {\n+            panic!($($arg),+)\n+        }\n+    );\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_eq {\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert_eq {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n+}\n+\n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n+\n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}\n+\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! format {\n+    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+}\n+\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n+#[macro_export]\n+#[stable]\n+macro_rules! writeln {\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n+}\n+\n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n+#[macro_export]\n+#[stable]\n+macro_rules! print {\n+    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+}\n+\n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! println {\n+    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+}\n+\n+/// Helper macro for unwrapping `Result` values while returning early with an\n+/// error if the value of the expression is `Err`. For more information, see\n+/// `std::io`.\n+#[macro_export]\n+macro_rules! try {\n+    ($expr:expr) => ({\n+        match $expr {\n+            Ok(val) => val,\n+            Err(err) => return Err(::std::error::FromError::from_error(err))\n+        }\n+    })\n+}\n+\n+/// Create a `std::vec::Vec` containing the arguments.\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n+        ::std::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+/// A macro to select an event from a number of receivers.\n+///\n+/// This macro is used to wait for the first event to occur on a number of\n+/// receivers. It places no restrictions on the types of receivers given to\n+/// this macro, this can be viewed as a heterogeneous select.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::thread::Thread;\n+/// use std::sync::mpsc::channel;\n+///\n+/// let (tx1, rx1) = channel();\n+/// let (tx2, rx2) = channel();\n+/// # fn long_running_task() {}\n+/// # fn calculate_the_answer() -> int { 42i }\n+///\n+/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n+/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n+///\n+/// select! (\n+///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n+///     answer = rx2.recv() => {\n+///         println!(\"the answer was: {}\", answer.unwrap());\n+///     }\n+/// )\n+/// ```\n+///\n+/// For more information about select, see the `std::sync::mpsc::Select` structure.\n+#[macro_export]\n+#[experimental]\n+macro_rules! select {\n+    (\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        use std::sync::mpsc::Select;\n+        let sel = Select::new();\n+        $( let mut $rx = sel.handle(&$rx); )+\n+        unsafe {\n+            $( $rx.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}\n+\n+// When testing the standard library, we link to the liblog crate to get the\n+// logging macros. In doing so, the liblog crate was linked against the real\n+// version of libstd, and uses a different std::fmt module than the test crate\n+// uses. To get around this difference, we redefine the log!() macro here to be\n+// just a dumb version of what it should be.\n+#[cfg(test)]\n+macro_rules! log {\n+    ($lvl:expr, $($args:tt)*) => (\n+        if log_enabled!($lvl) { println!($($args)*) }\n+    )\n+}\n+\n+/// Built-in macros to the compiler itself.\n+///\n+/// These macros do not have any corresponding definition with a `macro_rules!`\n+/// macro, but are documented here. Their implementations can be found hardcoded\n+/// into libsyntax itself.\n+#[cfg(dox)]\n+pub mod builtin {\n+    /// The core macro for formatted string creation & output.\n+    ///\n+    /// This macro produces a value of type `fmt::Arguments`. This value can be\n+    /// passed to the functions in `std::fmt` for performing useful functions.\n+    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n+    /// proxied through this one.\n+    ///\n+    /// For more information, see the documentation in `std::fmt`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    ///\n+    /// ```\n+    #[macro_export]\n+    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n+        /* compiler built-in */\n+    }) }\n+\n+    /// Inspect an environment variable at compile time.\n+    ///\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// macro instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Optionally inspect an environment variable at compile time.\n+    ///\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {}\", key);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate literals into a static byte slice.\n+    ///\n+    /// This macro takes any number of comma-separated literal expressions,\n+    /// yielding an expression of type `&'static [u8]` which is the\n+    /// concatenation (left to right) of all the literals in their byte format.\n+    ///\n+    /// This extension currently only supports string literals, character\n+    /// literals, and integers less than 256. The byte slice returned is the\n+    /// utf8-encoding of strings and characters.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n+    /// assert_eq!(rust[1], b'u');\n+    /// assert_eq!(rust[4], 255);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate identifiers into one identifier.\n+    ///\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables, and macros are only allowed in item,\n+    /// statement or expression position, meaning this macro may be difficult to\n+    /// use in some situations.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> int { 23 }\n+    ///\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    /// # }\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat_idents {\n+        ($($e:ident),*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Concatenates literals into a static string slice.\n+    ///\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10i, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the line number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned line is not\n+    /// the invocation of the `line!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `line!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the column number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned column is not\n+    /// the invocation of the `column!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `column!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the file name from which it was invoked.\n+    ///\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!()` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which stringifies its argument.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a utf8-encoded file as a string.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the filename specified. The file is located relative to the\n+    /// current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_str!(\"secret-key.ascii\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a file as a byte slice.\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8]` which is\n+    /// the contents of the filename specified. The file is located relative to\n+    /// the current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_bytes!(\"secret-key.bin\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Deprecated alias for `include_bytes!()`.\n+    #[macro_export]\n+    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */}) }\n+\n+    /// Expands to a string that represents the current module path.\n+    ///\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n+    #[macro_export]\n+    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+\n+    /// Boolean evaluation of configuration flags.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the `cfg`\n+    /// attribute.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n+    #[macro_export]\n+    macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n+}"}, {"sha": "a79a6e35ebcfd377ff74265cba1a9ec9d842d149", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -23,11 +23,14 @@ mod imp {\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n-    use result::Result::{Ok, Err};\n+    use result::Result::Ok;\n     use slice::SliceExt;\n     use mem;\n     use os::errno;\n \n+    // NOTE: for old macros; remove after the next snapshot\n+    #[cfg(stage0)] use result::Result::Err;\n+\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n                   target_arch = \"x86\","}, {"sha": "ac1f0c5d803ac6a5b5b1e37a0a5fa7c51644c198", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -17,8 +17,10 @@ use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use num::Int;\n-use result::Result;\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "b01cad43603a90decd495466c9ba2d96c964ac7f", "filename": "src/test/run-pass/vec-macro-no-std.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73806ddd0fd91066d7b903a00a080cbadcc04311/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs?ref=73806ddd0fd91066d7b903a00a080cbadcc04311", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(phase, lang_items)]\n+#![no_std]\n+\n+#[phase(plugin, link)]\n+extern crate core;\n+extern crate libc;\n+\n+#[phase(plugin, link)]\n+extern crate collections;\n+\n+use core::option::Option::Some;\n+use core::slice::SliceExt;\n+use collections::vec::Vec;\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+\n+// Issue #16806\n+\n+#[start]\n+fn start(_argc: int, _argv: *const *const u8) -> int {\n+    let x: Vec<u8> = vec![0, 1, 2];\n+    match x.last() {\n+        Some(&2) => (),\n+        _ => panic!(),\n+    }\n+    0\n+}"}]}