{"sha": "0d687bd8294464634724ed1d99bf714188c1a5fc", "node_id": "C_kwDOAAsO6NoAKDBkNjg3YmQ4Mjk0NDY0NjM0NzI0ZWQxZDk5YmY3MTQxODhjMWE1ZmM", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-07-07T04:10:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-07T04:10:17Z"}, "message": "Merge pull request #190 from rust-lang/feature/more-simd\n\nFeature/more simd", "tree": {"sha": "acf6723df0b15530c151688c451d0ca3f09cd80f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acf6723df0b15530c151688c451d0ca3f09cd80f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d687bd8294464634724ed1d99bf714188c1a5fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixlypCRBK7hj4Ov3rIwAAZsEIAH9cE4glPstjODgO1tyCc7wu\nfnI3LBCXugmbao+Ep9YArMabSO61D/JGkuEKQEsmKFTho2CNN5yjLbJIyNWQlV9P\nUkSJbtU43/cTJgvqkWo6bmZbOgTWKS4li6Z5lkomBF1thYslYvOx/Jqtf2H4adCt\nS4eXDCIG5gZx7el9zPQAFy7w9Yqv7VHuNXeaduHiu2GyYLemxB/rPc0d9O0vd8IY\neFGDKZO7IUxBZyZuk0JaBaLXoa08ZZlX9dJKhaP7QZB0m959kYoR+L3QKMN9VZfF\nYk2wkra68RjDO5pk1I4D3uMxx6GX3yHUMKXiyZXox9LNApiZrQjRcQY7dwBmTyo=\n=Z6Gl\n-----END PGP SIGNATURE-----\n", "payload": "tree acf6723df0b15530c151688c451d0ca3f09cd80f\nparent 14e09245c49dbba9316e2662a6b85d10070f653a\nparent 5f4777e55da380a97336d09ca61ea615ef1dd315\nauthor antoyo <antoyo@users.noreply.github.com> 1657167017 -0400\ncommitter GitHub <noreply@github.com> 1657167017 -0400\n\nMerge pull request #190 from rust-lang/feature/more-simd\n\nFeature/more simd"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d687bd8294464634724ed1d99bf714188c1a5fc", "html_url": "https://github.com/rust-lang/rust/commit/0d687bd8294464634724ed1d99bf714188c1a5fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d687bd8294464634724ed1d99bf714188c1a5fc/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e09245c49dbba9316e2662a6b85d10070f653a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e09245c49dbba9316e2662a6b85d10070f653a", "html_url": "https://github.com/rust-lang/rust/commit/14e09245c49dbba9316e2662a6b85d10070f653a"}, {"sha": "5f4777e55da380a97336d09ca61ea615ef1dd315", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4777e55da380a97336d09ca61ea615ef1dd315", "html_url": "https://github.com/rust-lang/rust/commit/5f4777e55da380a97336d09ca61ea615ef1dd315"}], "stats": {"total": 249, "additions": 226, "deletions": 23}, "files": [{"sha": "ff09a08b5afe097fb9fab90ac6a08c561d7a6e87", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#a8997afb665dc467c1bdbddf04877143683f0cce\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#a8997afb665dc467c1bdbddf04877143683f0cce\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -215,6 +215,7 @@ dependencies = [\n  \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"target-lexicon\",\n  \"tempfile\",\n ]\n@@ -228,6 +229,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n+\n [[package]]\n name = \"target-lexicon\"\n version = \"0.10.0\""}, {"sha": "3ac354ea49427c1ae2b75100eeaeaabdcd61eb81", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -27,6 +27,7 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n target-lexicon = \"0.10.0\"\n \n ar = \"0.8.0\""}, {"sha": "93c63b5dcacfda4c14539665d4a004baeb2ae3c3", "filename": "patches/0001-Add-stdarch-Cargo.toml-for-testing.patch", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -0,0 +1,39 @@\n+From c3821e02fbd6cb5ad6e06d759fccdc9073712375 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Tue, 7 Jun 2022 21:40:13 -0400\n+Subject: [PATCH] Add stdarch Cargo.toml for testing\n+\n+---\n+ library/stdarch/Cargo.toml | 20 ++++++++++++++++++++\n+ 1 file changed, 20 insertions(+)\n+ create mode 100644 library/stdarch/Cargo.toml\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+new file mode 100644\n+index 0000000..fbe0a95\n+--- /dev/null\n++++ b/library/stdarch/Cargo.toml\n+@@ -0,0 +1,20 @@\n++[workspace]\n++members = [\n++  \"crates/core_arch\",\n++  \"crates/std_detect\",\n++  \"crates/stdarch-gen\",\n++  \"examples/\"\n++]\n++exclude = [\n++  \"crates/wasm-assert-instr-tests\"\n++]\n++\n++[profile.release]\n++debug = true\n++opt-level = 3\n++incremental = true\n++\n++[profile.bench]\n++debug = 1\n++opt-level = 3\n++incremental = true\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "e570b583decb844abebb4a6a6253d3ae1884117f", "filename": "src/attributes.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattributes.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -0,0 +1,112 @@\n+#[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n+use gccjit::FnAttribute;\n+use gccjit::Function;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::context::CodegenCx;\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(sess: &Session, features: &FxHashMap<&str, bool>) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|feature| enabled != features.get(feature)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO(antoyo): maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|features| features.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(features) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|features| (*features, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        let msg = format!(\"the target features {} must all be either enabled or disabled together\", features.join(\", \"));\n+        let mut err = cx.tcx.sess.struct_span_err(span, &msg);\n+        err.help(\"add the missing features in a `target_feature` attribute\");\n+        err.emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO(antoyo): support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Target, &target_features);\n+    }\n+}"}, {"sha": "9d81a01e7a61bcb98e49195c5defdfd09a726b72", "filename": "src/base.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -83,15 +83,23 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         context.add_command_line_option(\"-mavx2\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        /*context.add_command_line_option(\"-mavx512f\");\n         context.add_command_line_option(\"-msha\");\n         context.add_command_line_option(\"-mpclmul\");\n         context.add_command_line_option(\"-mfma\");\n         context.add_command_line_option(\"-mfma4\");\n-        context.add_command_line_option(\"-mavx512vpopcntdq\");\n-        context.add_command_line_option(\"-mavx512vl\");\n         context.add_command_line_option(\"-m64\");\n-        context.add_command_line_option(\"-mbmi\");*/\n+        context.add_command_line_option(\"-mbmi\");\n+        context.add_command_line_option(\"-mgfni\");\n+        context.add_command_line_option(\"-mavxvnni\");\n+        context.add_command_line_option(\"-mf16c\");\n+        context.add_command_line_option(\"-maes\");\n+        context.add_command_line_option(\"-mxsavec\");\n+        context.add_command_line_option(\"-mbmi2\");\n+        context.add_command_line_option(\"-mrtm\");\n+        context.add_command_line_option(\"-mvaes\");\n+        context.add_command_line_option(\"-mvpclmulqdq\");\n+        context.add_command_line_option(\"-mavx\");\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "867fd531f5043b23a625bd27631c7f3560c2d578", "filename": "src/builder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && (actual_ty.is_integral() && expected_ty.is_integral()) || (actual_ty.get_pointee().is_some() && expected_ty.get_pointee().is_some()) {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -1490,6 +1490,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+        // the & operation work.\n+        let masks = self.bitcast_if_needed(masks, then_val.get_type());\n         let then_vals = masks & then_val;\n \n         let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n@@ -1509,6 +1512,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n     let difference = a - b;\n     let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+    // the & operation work.\n+    let a_type = a.get_type();\n+    let masks =\n+        if masks.get_type() != a_type {\n+            context.new_bitcast(None, masks, a_type)\n+        }\n+        else {\n+            masks\n+        };\n     difference & masks\n }\n "}, {"sha": "5557f886b2877aa7d191fb1c8e4513d5e7ae66bf", "filename": "src/callee.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -67,8 +68,12 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n             // TODO(antoyo): set linkage and attributes.\n-            func\n+\n+            // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+            unsafe { std::mem::transmute(func) }\n         };\n \n     cx.function_instances.borrow_mut().insert(instance, func);"}, {"sha": "d55ad87e19bf77752fb1b6f70db2f6c3e30772fc", "filename": "src/common.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -177,8 +177,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                // TODO(bjorn3): assert size is correct\n-                self.const_bitcast(value, ty)\n+                let bytesize = layout.size(self).bytes();\n+                if bitsize > 1 && ty.is_integral() && bytesize as u32 == ty.get_size() {\n+                    // NOTE: since the intrinsic _xabort is called with a bitcast, which\n+                    // is non-const, but expects a constant, do a normal cast instead of a bitcast.\n+                    // FIXME(antoyo): fix bitcast to work in constant contexts.\n+                    // TODO(antoyo): perhaps only use bitcast for pointers?\n+                    self.context.new_cast(None, value, ty)\n+                }\n+                else {\n+                    // TODO(bjorn3): assert size is correct\n+                    self.const_bitcast(value, ty)\n+                }\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();"}, {"sha": "5f6360a7da5309cb1d2c684b7c1cbdb8cf637523", "filename": "src/declare.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -79,12 +79,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "f00c1b30109743f22214d712dfd160cfacf49754", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -287,9 +287,9 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool) -> RValue<'gcc> {\n     match func_name {\n         \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n-            let zero = builder.context.new_rvalue_zero(builder.int_type);\n             #[cfg(feature=\"master\")]\n             {\n+                let zero = builder.context.new_rvalue_zero(builder.int_type);\n                 return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n             }\n         },"}, {"sha": "9c2a1401a1544b9e7641109ad4628ff187220032", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -1,4 +1,6 @@\n-use gccjit::{BinaryOp, RValue, Type, ToRValue, ComparisonOp, UnaryOp};\n+#[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n+use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n+use gccjit::{BinaryOp, RValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -216,7 +218,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n         bx.llbb().add_assignment(None, variable, vector);\n         let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n-        // TODO: if simd_insert is constant, use BIT_REF.\n+        // TODO(antoyo): if simd_insert is constant, use BIT_REF.\n         bx.llbb().add_assignment(None, lvalue, value);\n         return Ok(variable.to_rvalue());\n     }\n@@ -545,9 +547,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 },\n                 (true, true) => {\n                     // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n-                    // TODO: improve using conditional operators if possible.\n+                    // TODO(antoyo): improve using conditional operators if possible.\n                     let arg_type = lhs.get_type();\n-                    // TODO: convert lhs and rhs to unsigned.\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n                     let sum = lhs + rhs;\n                     let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n                     let unit = vector_type.get_num_units();\n@@ -581,7 +583,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     // negative of the right operand. Find a proper subtraction algorithm.\n                     let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n \n-                    // TODO: convert lhs and rhs to unsigned.\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n                     let sum = lhs + rhs;\n                     let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n                     let unit = vector_type.get_num_units();"}, {"sha": "b3cbf344ad1366d6c605b4d251a34dc5b6a53420", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -13,6 +13,7 @@\n #![warn(unused_lifetimes)]\n \n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -32,6 +33,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -302,9 +304,11 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO(antoyo): maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n-                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+                (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\")\n             }\n             #[cfg(not(feature=\"master\"))]\n             {"}, {"sha": "60a42846bd3d1df735c32e8c43871b92b96abe6c", "filename": "src/mono_item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n@@ -28,9 +29,11 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above."}, {"sha": "594b63dfd0d81406c0d770a86dd031fa4ed44f59", "filename": "test.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d687bd8294464634724ed1d99bf714188c1a5fc/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0d687bd8294464634724ed1d99bf714188c1a5fc/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=0d687bd8294464634724ed1d99bf714188c1a5fc", "patch": "@@ -107,7 +107,7 @@ else\n fi\n \n if (( $build_only == 1 )); then\n-    echo \"Since it's `build-only`, exiting...\"\n+    echo \"Since it's 'build-only', exiting...\"\n     exit\n fi\n \n@@ -324,7 +324,7 @@ function all() {\n }\n \n if [ ${#funcs[@]} -eq 0 ]; then\n-    echo \"No command passed, running `--all`...\"\n+    echo \"No command passed, running '--all'...\"\n     all\n else\n     for t in ${funcs[@]}; do"}]}