{"sha": "c5a1b87c6f95e023ab465514aac143bdbd88f56b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTFiODdjNmY5NWUwMjNhYjQ2NTUxNGFhYzE0M2JkYmQ4OGY1NmI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-15T00:59:28Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-15T00:59:28Z"}, "message": "properly remove moved text", "tree": {"sha": "641c4d232c45bb2f872290b742f3a8489d69d6db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/641c4d232c45bb2f872290b742f3a8489d69d6db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a1b87c6f95e023ab465514aac143bdbd88f56b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a1b87c6f95e023ab465514aac143bdbd88f56b", "html_url": "https://github.com/rust-lang/rust/commit/c5a1b87c6f95e023ab465514aac143bdbd88f56b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a1b87c6f95e023ab465514aac143bdbd88f56b/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700895fdd7fcd19ffc00639d9fede532ffeb7952", "url": "https://api.github.com/repos/rust-lang/rust/commits/700895fdd7fcd19ffc00639d9fede532ffeb7952", "html_url": "https://github.com/rust-lang/rust/commit/700895fdd7fcd19ffc00639d9fede532ffeb7952"}], "stats": {"total": 177, "additions": 0, "deletions": 177}, "files": [{"sha": "df7cf00b99b683d985069219ea44bc6bdb8b0a60", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/c5a1b87c6f95e023ab465514aac143bdbd88f56b/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5a1b87c6f95e023ab465514aac143bdbd88f56b/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=c5a1b87c6f95e023ab465514aac143bdbd88f56b", "patch": "@@ -139,180 +139,3 @@ impl<T> Vec<T> {\n \n \n \n-\n-# Handling Zero-Sized Types\n-\n-It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n-*never* needs to care about this, but Vec is very intensive on raw pointers and\n-raw allocations, which are exactly the *only* two things that care about\n-zero-sized types. We need to be careful of two things:\n-\n-* The raw allocator API has undefined behaviour if you pass in 0 for an\n-  allocation size.\n-* raw pointer offsets are no-ops for zero-sized types, which will break our\n-  C-style pointer iterator.\n-\n-Thankfully we abstracted out pointer-iterators and allocating handling into\n-RawValIter and RawVec respectively. How mysteriously convenient.\n-\n-\n-\n-\n-## Allocating Zero-Sized Types\n-\n-So if the allocator API doesn't support zero-sized allocations, what on earth\n-do we store as our allocation? Why, `heap::EMPTY` of course! Almost every operation\n-with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\n-to be considered to store or load them. This actually extends to `ptr::read` and\n-`ptr::write`: they won't actually look at the pointer at all. As such we *never* need\n-to change the pointer.\n-\n-Note however that our previous reliance on running out of memory before overflow is\n-no longer valid with zero-sized types. We must explicitly guard against capacity\n-overflow for zero-sized types.\n-\n-Due to our current architecture, all this means is writing 3 guards, one in each\n-method of RawVec.\n-\n-```rust,ignore\n-impl<T> RawVec<T> {\n-    fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n-\n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n-        }\n-    }\n-\n-    fn grow(&mut self) {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the Vec is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            let align = mem::align_of::<T>();\n-\n-            let (new_cap, ptr) = if self.cap == 0 {\n-                let ptr = heap::allocate(elem_size, align);\n-                (1, ptr)\n-            } else {\n-                let new_cap = 2 * self.cap;\n-                let ptr = heap::reallocate(*self.ptr as *mut _,\n-                                            self.cap * elem_size,\n-                                            new_cap * elem_size,\n-                                            align);\n-                (new_cap, ptr)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n-\n-            self.ptr = Unique::new(ptr as *mut _);\n-            self.cap = new_cap;\n-        }\n-    }\n-}\n-\n-impl<T> Drop for RawVec<T> {\n-    fn drop(&mut self) {\n-        let elem_size = mem::size_of::<T>();\n-\n-        // don't free zero-sized allocations, as they were never allocated.\n-        if self.cap != 0 && elem_size != 0 {\n-            let align = mem::align_of::<T>();\n-\n-            let num_bytes = elem_size * self.cap;\n-            unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n-            }\n-        }\n-    }\n-}\n-```\n-\n-That's it. We support pushing and popping zero-sized types now. Our iterators\n-(that aren't provided by slice Deref) are still busted, though.\n-\n-\n-\n-\n-## Iterating Zero-Sized Types\n-\n-Zero-sized offsets are no-ops. This means that our current design will always\n-initialize `start` and `end` as the same value, and our iterators will yield\n-nothing. The current solution to this is to cast the pointers to integers,\n-increment, and then cast them back:\n-\n-```rust,ignore\n-impl<T> RawValIter<T> {\n-    unsafe fn new(slice: &[T]) -> Self {\n-        RawValIter {\n-            start: slice.as_ptr(),\n-            end: if mem::size_of::<T>() == 0 {\n-                ((slice.as_ptr() as usize) + slice.len()) as *const _\n-            } else if slice.len() == 0 {\n-                slice.as_ptr()\n-            } else {\n-                slice.as_ptr().offset(slice.len() as isize)\n-            }\n-        }\n-    }\n-}\n-```\n-\n-Now we have a different bug. Instead of our iterators not running at all, our\n-iterators now run *forever*. We need to do the same trick in our iterator impls.\n-Also, our size_hint computation code will divide by 0 for ZSTs. Since we'll\n-basically be treating the two pointers as if they point to bytes, we'll just\n-map size 0 to divide by 1.\n-\n-```rust,ignore\n-impl<T> Iterator for RawValIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                let result = ptr::read(self.start);\n-                self.start = if mem::size_of::<T>() == 0 {\n-                    (self.start as usize + 1) as *const _\n-                } else {\n-                    self.start.offset(1);\n-                }\n-                Some(result)\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let elem_size = mem::size_of::<T>();\n-        let len = (self.end as usize - self.start as usize)\n-                  / if elem_size == 0 { 1 } else { elem_size };\n-        (len, Some(len))\n-    }\n-}\n-\n-impl<T> DoubleEndedIterator for RawValIter<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.start == self.end {\n-            None\n-        } else {\n-            unsafe {\n-                self.end = if mem::size_of::<T>() == 0 {\n-                    (self.end as usize - 1) as *const _\n-                } else {\n-                    self.end.offset(-1);\n-                }\n-                Some(ptr::read(self.end))\n-            }\n-        }\n-    }\n-}\n-```\n-\n-And that's it. Iteration works!"}]}