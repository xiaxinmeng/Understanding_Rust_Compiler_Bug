{"sha": "956e2bcbaa00c05e051718b1375375915064f1c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NmUyYmNiYWEwMGMwNWUwNTE3MThiMTM3NTM3NTkxNTA2NGYxYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-12T23:21:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-12T23:21:15Z"}, "message": "Auto merge of #39572 - jseyfried:fix_inert_attributes, r=nrc\n\nmacros: fix inert attributes from `proc_macro_derives` with `#![feature(proc_macro)]`\n\nThis PR refactors collection of `proc_macro_derive` invocations to fix #39347.\n\nAfter this PR, the input to a `#[proc_macro_derive]` function no longer sees `#[derive]`s on the underlying item. For example, consider:\n```rust\nextern crate my_derives;\nuse my_derives::{Trait, Trait2};\n\n#[derive(Copy, Clone)]\n#[derive(Trait)]\n#[derive(Trait2)]\nstruct S;\n```\n\nToday, the input to the `Trait` derive is `#[derive(Copy, Clone, Trait2)] struct S;`, and the input to the `Trait2` derive is `#[derive(Copy, Clone)] struct S;`. More generally, a `proc_macro_derive` sees all builtin derives, as well as all `proc_macro_derive`s listed *after* the one being invoked.\n\nAfter this PR, both `Trait` and `Trait2` will see `struct S;`.\nThis is a [breaking-change], but I believe it is highly unlikely to cause breakage in practice.\n\nr? @nrc", "tree": {"sha": "a3063138179425237fe22fd4b30065ca96a98c34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3063138179425237fe22fd4b30065ca96a98c34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956e2bcbaa00c05e051718b1375375915064f1c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956e2bcbaa00c05e051718b1375375915064f1c3", "html_url": "https://github.com/rust-lang/rust/commit/956e2bcbaa00c05e051718b1375375915064f1c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956e2bcbaa00c05e051718b1375375915064f1c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81bd2675eaf96396e363d63aa068b0a462ec5a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/81bd2675eaf96396e363d63aa068b0a462ec5a6d", "html_url": "https://github.com/rust-lang/rust/commit/81bd2675eaf96396e363d63aa068b0a462ec5a6d"}, {"sha": "2cc61eebb7f1677af2a20f76fb1411ed40f6901b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc61eebb7f1677af2a20f76fb1411ed40f6901b", "html_url": "https://github.com/rust-lang/rust/commit/2cc61eebb7f1677af2a20f76fb1411ed40f6901b"}], "stats": {"total": 638, "additions": 325, "deletions": 313}, "files": [{"sha": "104d76b1f600d6cd8971d82752898a6f0cf28e01", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -616,10 +616,9 @@ impl<'a> CrateLoader<'a> {\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n-                let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n-                let derive = SyntaxExtension::ProcMacroDerive(\n-                    Box::new(ProcMacroDerive::new(expand, attrs))\n-                );\n+                let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                let derive = ProcMacroDerive::new(expand, attrs.clone());\n+                let derive = SyntaxExtension::ProcMacroDerive(Box::new(derive), attrs);\n                 self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n "}, {"sha": "97d3e6c9e43d93c8d35f74aa9bd3e1f21b76c9e1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 62, "deletions": 14, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -27,10 +27,10 @@ use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{emit_feature_err, GateIssue, is_builtin_attr};\n+use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -130,12 +130,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.whitelisted_legacy_custom_derives.contains(&name)\n     }\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n         self.collect_def_ids(invocation, expansion);\n \n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n+        self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n+        for &derive in derives {\n+            self.invocations.insert(derive, invocation);\n+        }\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             legacy_scope: LegacyScope::Invocation(invocation),\n@@ -172,7 +176,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n \n-    fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+    // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n+                              -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             match self.builtin_macros.get(&attrs[i].name()).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n@@ -183,11 +189,50 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 },\n                 None => {}\n             }\n+        }\n \n-            if self.proc_macro_enabled && !is_builtin_attr(&attrs[i]) {\n-                return Some(attrs.remove(i));\n+        // Check for legacy derives\n+        for i in 0..attrs.len() {\n+            if attrs[i].name() == \"derive\" {\n+                let mut traits = match attrs[i].meta_item_list() {\n+                    Some(traits) if !traits.is_empty() => traits.to_owned(),\n+                    _ => continue,\n+                };\n+\n+                for j in 0..traits.len() {\n+                    let legacy_name = Symbol::intern(&match traits[j].word() {\n+                        Some(..) => format!(\"derive_{}\", traits[j].name().unwrap()),\n+                        None => continue,\n+                    });\n+                    if !self.builtin_macros.contains_key(&legacy_name) {\n+                        continue\n+                    }\n+                    let span = traits.remove(j).span;\n+                    self.gate_legacy_custom_derive(legacy_name, span);\n+                    if traits.is_empty() {\n+                        attrs.remove(i);\n+                    } else {\n+                        attrs[i].value = ast::MetaItem {\n+                            name: attrs[i].name(),\n+                            span: attrs[i].span,\n+                            node: ast::MetaItemKind::List(traits),\n+                        };\n+                    }\n+                    return Some(ast::Attribute {\n+                        value: ast::MetaItem {\n+                            name: legacy_name,\n+                            span: span,\n+                            node: ast::MetaItemKind::Word,\n+                        },\n+                        id: attr::mk_attr_id(),\n+                        style: ast::AttrStyle::Outer,\n+                        is_sugared_doc: false,\n+                        span: span,\n+                    });\n+                }\n             }\n         }\n+\n         None\n     }\n \n@@ -236,7 +281,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 _ => {\n-                    let msg = format!(\"macro undefined: '{}!'\", name);\n+                    let msg = format!(\"macro undefined: `{}`\", name);\n                     let mut err = self.session.struct_span_err(span, &msg);\n                     self.suggest_macro_name(&name.as_str(), &mut err);\n                     err.emit();\n@@ -251,13 +296,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         result\n     }\n \n-    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        match self.builtin_macros.get(&tname).cloned() {\n-            Some(binding) => Ok(binding.get_macro(self)),\n-            None => Err(Determinacy::Undetermined),\n-        }\n-    }\n-\n     fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                             -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { span, .. } = *path;\n@@ -540,4 +578,14 @@ impl<'a> Resolver<'a> {\n                              `use {}::{};`\", crate_name, name))\n             .emit();\n     }\n+\n+    fn gate_legacy_custom_derive(&mut self, name: Symbol, span: Span) {\n+        if !self.session.features.borrow().custom_derive {\n+            let sess = &self.session.parse_sess;\n+            let explain = feature_gate::EXPLAIN_CUSTOM_DERIVE;\n+            emit_feature_err(sess, \"custom_derive\", span, GateIssue::Language, explain);\n+        } else if !self.is_whitelisted_legacy_custom_derive(name) {\n+            self.session.span_warn(span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n+        }\n+    }\n }"}, {"sha": "b5afd0c453a1ef894f3a1cdca5f3422bae893444", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -514,7 +514,7 @@ pub enum SyntaxExtension {\n     /// The input is the annotated item.\n     /// Allows generating code to implement a Trait for a given struct\n     /// or enum item.\n-    ProcMacroDerive(Box<MultiItemModifier>),\n+    ProcMacroDerive(Box<MultiItemModifier>, Vec<Symbol> /* inert attribute names */),\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n@@ -528,15 +528,15 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn resolve_imports(&mut self);\n-    fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy>;\n     fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                             -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n@@ -555,19 +555,16 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n-    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n+    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn resolve_imports(&mut self) {}\n-    fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n-    fn resolve_builtin_macro(&mut self, _tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n     fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                             -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "77cc7bab0315acc2c4a2aef3ccbdfea2e045df82", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 35, "deletions": 169, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -8,132 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::Name;\n-use attr;\n-use ast::{self, NestedMetaItem}; use ext::base::{ExtCtxt, SyntaxExtension};\n-use codemap;\n+use attr::HasAttrs;\n+use {ast, codemap};\n+use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use feature_gate;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn derive_attr_trait<'a>(cx: &mut ExtCtxt, attr: &'a ast::Attribute)\n-                             -> Option<&'a NestedMetaItem> {\n-    if attr.name() != \"derive\" {\n-        return None;\n-    }\n-    if attr.value_str().is_some() {\n-        cx.span_err(attr.span, \"unexpected value in `derive`\");\n-        return None;\n-    }\n-\n-    let traits = attr.meta_item_list().unwrap_or(&[]);\n-\n-    if traits.is_empty() {\n-        cx.span_warn(attr.span, \"empty trait list in `derive`\");\n-        return None;\n-    }\n-\n-    return traits.get(0);\n-}\n-\n-pub fn verify_derive_attrs(cx: &mut ExtCtxt, attrs: &[ast::Attribute]) {\n-    for attr in attrs {\n+pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<(Symbol, Span)> {\n+    let mut result = Vec::new();\n+    attrs.retain(|attr| {\n         if attr.name() != \"derive\" {\n-            continue;\n+            return true;\n         }\n \n         if attr.value_str().is_some() {\n             cx.span_err(attr.span, \"unexpected value in `derive`\");\n+            return false;\n         }\n \n         let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n-\n         if traits.is_empty() {\n             cx.span_warn(attr.span, \"empty trait list in `derive`\");\n-            attr::mark_used(&attr);\n-            continue;\n+            return false;\n         }\n+\n         for titem in traits {\n             if titem.word().is_none() {\n                 cx.span_err(titem.span, \"malformed `derive` entry\");\n+                return false;\n             }\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, Debug, Clone, Copy)]\n-pub enum DeriveType {\n-    Legacy,\n-    ProcMacro,\n-    Builtin\n-}\n-\n-impl DeriveType {\n-    // Classify a derive trait name by resolving the macro.\n-    pub fn classify(cx: &mut ExtCtxt, tname: Name) -> DeriveType {\n-        let legacy_derive_name = Symbol::intern(&format!(\"derive_{}\", tname));\n-\n-        if let Ok(_) = cx.resolver.resolve_builtin_macro(legacy_derive_name) {\n-            return DeriveType::Legacy;\n-        }\n-\n-        match cx.resolver.resolve_builtin_macro(tname) {\n-            Ok(ext) => match *ext {\n-                SyntaxExtension::BuiltinDerive(..) => DeriveType::Builtin,\n-                _ => DeriveType::ProcMacro,\n-            },\n-            Err(_) => DeriveType::ProcMacro,\n-        }\n-    }\n-}\n-\n-pub fn get_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>,\n-                       derive_type: DeriveType) -> Option<ast::Attribute> {\n-    for i in 0..attrs.len() {\n-        if attrs[i].name() != \"derive\" {\n-            continue;\n-        }\n-\n-        if attrs[i].value_str().is_some() {\n-            continue;\n-        }\n-\n-        let mut traits = attrs[i].meta_item_list().unwrap_or(&[]).to_owned();\n-\n-        // First, weed out malformed #[derive]\n-        traits.retain(|titem| titem.word().is_some());\n-\n-        let mut titem = None;\n-\n-        // See if we can find a matching trait.\n-        for j in 0..traits.len() {\n-            let tname = match traits[j].name() {\n-                Some(tname) => tname,\n-                _ => continue,\n-            };\n-\n-            if DeriveType::classify(cx, tname) == derive_type {\n-                titem = Some(traits.remove(j));\n-                break;\n-            }\n+            result.push((titem.name().unwrap(), titem.span));\n         }\n \n-        // If we find a trait, remove the trait from the attribute.\n-        if let Some(titem) = titem {\n-            if traits.len() == 0 {\n-                attrs.remove(i);\n-            } else {\n-                let derive = Symbol::intern(\"derive\");\n-                let mitem = cx.meta_list(titem.span, derive, traits);\n-                attrs[i] = cx.attribute(titem.span, mitem);\n-            }\n-            let derive = Symbol::intern(\"derive\");\n-            let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n-            return Some(cx.attribute(mitem.span, mitem));\n-        }\n-    }\n-    return None;\n+        true\n+    });\n+    result\n }\n \n fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n@@ -150,69 +60,25 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn add_derived_markers(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) {\n-    if attrs.is_empty() {\n-        return;\n-    }\n-\n-    let titems = attrs.iter().filter(|a| {\n-        a.name() == \"derive\"\n-    }).flat_map(|a| {\n-        a.meta_item_list().unwrap_or(&[]).iter()\n-    }).filter_map(|titem| {\n-        titem.name()\n-    }).collect::<Vec<_>>();\n-\n-    let span = attrs[0].span;\n-\n-    if !attrs.iter().any(|a| a.name() == \"structural_match\") &&\n-       titems.iter().any(|t| *t == \"PartialEq\") && titems.iter().any(|t| *t == \"Eq\") {\n-        let structural_match = Symbol::intern(\"structural_match\");\n-        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n-        let meta = cx.meta_word(span, structural_match);\n-        attrs.push(cx.attribute(span, meta));\n-    }\n-\n-    if !attrs.iter().any(|a| a.name() == \"rustc_copy_clone_marker\") &&\n-       titems.iter().any(|t| *t == \"Copy\") && titems.iter().any(|t| *t == \"Clone\") {\n-        let structural_match = Symbol::intern(\"rustc_copy_clone_marker\");\n-        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n-        let meta = cx.meta_word(span, structural_match);\n-        attrs.push(cx.attribute(span, meta));\n-    }\n-}\n-\n-pub fn find_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>)\n-                        -> Option<ast::Attribute> {\n-    verify_derive_attrs(cx, attrs);\n-    get_derive_attr(cx, attrs, DeriveType::Legacy).and_then(|a| {\n-        let titem = derive_attr_trait(cx, &a);\n-        titem.and_then(|titem| {\n-            let tword = titem.word().unwrap();\n-            let tname = tword.name();\n-            if !cx.ecfg.enable_custom_derive() {\n-                feature_gate::emit_feature_err(\n-                    &cx.parse_sess,\n-                    \"custom_derive\",\n-                    titem.span,\n-                    feature_gate::GateIssue::Language,\n-                    feature_gate::EXPLAIN_CUSTOM_DERIVE\n-                );\n-                None\n-            } else {\n-                let name = Symbol::intern(&format!(\"derive_{}\", tname));\n-                if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n-                    cx.span_warn(titem.span,\n-                                 feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-                }\n-                let mitem = cx.meta_word(titem.span, name);\n-                Some(cx.attribute(mitem.span, mitem))\n-            }\n-        })\n-    }).or_else(|| {\n-        get_derive_attr(cx, attrs, DeriveType::ProcMacro)\n-    }).or_else(|| {\n-        add_derived_markers(cx, attrs);\n-        get_derive_attr(cx, attrs, DeriveType::Builtin)\n+pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[(Symbol, Span)], item: T) -> T {\n+    let span = match traits.get(0) {\n+        Some(&(_, span)) => span,\n+        None => return item,\n+    };\n+\n+    item.map_attrs(|mut attrs| {\n+        if traits.iter().any(|&(name, _)| name == \"PartialEq\") &&\n+           traits.iter().any(|&(name, _)| name == \"Eq\") {\n+            let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+            let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+        if traits.iter().any(|&(name, _)| name == \"Copy\") &&\n+           traits.iter().any(|&(name, _)| name == \"Clone\") {\n+            let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+            let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+        attrs\n     })\n }"}, {"sha": "d011d7c2a1c447c7ea7444e3031b6785ab484ee8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 179, "deletions": 82, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -14,10 +14,10 @@ use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n-use ext::derive::{find_derive_attr, derive_attr_trait};\n+use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::Mark;\n use ext::placeholders::{placeholder, PlaceholderExpander};\n-use feature_gate::{self, Features};\n+use feature_gate::{self, Features, is_builtin_attr};\n use fold;\n use fold::*;\n use parse::parser::Parser;\n@@ -33,6 +33,7 @@ use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n \n+use std::collections::HashMap;\n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -164,11 +165,13 @@ pub enum InvocationKind {\n         span: Span,\n     },\n     Attr {\n-        attr: ast::Attribute,\n+        attr: Option<ast::Attribute>,\n+        traits: Vec<(Symbol, Span)>,\n         item: Annotatable,\n     },\n     Derive {\n-        attr: ast::Attribute,\n+        name: Symbol,\n+        span: Span,\n         item: Annotatable,\n     },\n }\n@@ -177,8 +180,9 @@ impl Invocation {\n     fn span(&self) -> Span {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n-            InvocationKind::Attr { ref attr, .. } => attr.span,\n-            InvocationKind::Derive { ref attr, .. } => attr.span,\n+            InvocationKind::Attr { attr: Some(ref attr), .. } => attr.span,\n+            InvocationKind::Attr { attr: None, .. } => syntax_pos::DUMMY_SP,\n+            InvocationKind::Derive { span, .. } => span,\n         }\n     }\n }\n@@ -227,15 +231,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n \n-        let (expansion, mut invocations) = self.collect_invocations(expansion);\n+        let (expansion, mut invocations) = self.collect_invocations(expansion, &[]);\n         self.resolve_imports();\n         invocations.reverse();\n \n         let mut expansions = Vec::new();\n+        let mut derives = HashMap::new();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let invoc = if let Some(invoc) = invocations.pop() {\n+            let mut invoc = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -247,24 +252,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let resolution = match invoc.kind {\n-                InvocationKind::Bang { ref mac, .. } => {\n-                    self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n-                }\n-                InvocationKind::Attr { ref attr, .. } => {\n-                    let ident = Ident::with_empty_ctxt(attr.name());\n-                    let path = ast::Path::from_ident(attr.span, ident);\n-                    self.cx.resolver.resolve_macro(scope, &path, force)\n-                }\n-                InvocationKind::Derive { ref attr, .. } => {\n-                    let titem = derive_attr_trait(self.cx, &attr).unwrap();\n-                    let tname = titem.name().expect(\"Expected derive macro name\");\n-                    let ident = Ident::with_empty_ctxt(tname);\n-                    let path = ast::Path::from_ident(attr.span, ident);\n-                    self.cx.resolver.resolve_derive_macro(scope, &path, force)\n-                }\n-            };\n-            let ext = match resolution {\n+            let ext = match self.resolve_invoc(&mut invoc, scope, force) {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -278,13 +266,49 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             self.cx.current_expansion.mark = scope;\n-            let expansion = match ext {\n-                Some(ext) => self.expand_invoc(invoc, ext),\n-                None => invoc.expansion_kind.dummy(invoc.span()),\n+            // FIXME(jseyfried): Refactor out the following logic\n+            let (expansion, new_invocations) = if let Some(ext) = ext {\n+                if let Some(ext) = ext {\n+                    let expansion = self.expand_invoc(invoc, ext);\n+                    self.collect_invocations(expansion, &[])\n+                } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n+                    let item = item\n+                        .map_attrs(|mut attrs| { attrs.retain(|a| a.name() != \"derive\"); attrs });\n+                    let item_with_markers =\n+                        add_derived_markers(&mut self.cx, &traits, item.clone());\n+                    let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n+\n+                    for &(name, span) in &traits {\n+                        let mark = Mark::fresh();\n+                        derives.push(mark);\n+                        let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+                        let item = match self.cx.resolver\n+                                             .resolve_macro(Mark::root(), &path, false) {\n+                            Ok(ext) => match *ext {\n+                                SyntaxExtension::BuiltinDerive(..) => item_with_markers.clone(),\n+                                _ => item.clone(),\n+                            },\n+                            _ => item.clone(),\n+                        };\n+                        invocations.push(Invocation {\n+                            kind: InvocationKind::Derive { name: name, span: span, item: item },\n+                            expansion_kind: invoc.expansion_kind,\n+                            expansion_data: ExpansionData {\n+                                mark: mark,\n+                                ..invoc.expansion_data.clone()\n+                            },\n+                        });\n+                    }\n+                    let expansion = invoc.expansion_kind\n+                        .expect_from_annotatables(::std::iter::once(item_with_markers));\n+                    self.collect_invocations(expansion, derives)\n+                } else {\n+                    unreachable!()\n+                }\n+            } else {\n+                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()), &[])\n             };\n \n-            let (expansion, new_invocations) = self.collect_invocations(expansion);\n-\n             if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n@@ -299,7 +323,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                placeholder_expander.add(mark.as_placeholder_id(), expansion);\n+                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(mark.as_placeholder_id(), expansion, derives);\n             }\n         }\n \n@@ -314,7 +339,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n+    fn collect_invocations(&mut self, expansion: Expansion, derives: &[Mark])\n+                           -> (Expansion, Vec<Invocation>) {\n         let result = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n@@ -332,13 +358,69 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         if self.monotonic {\n             let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n             let mark = self.cx.current_expansion.mark;\n-            self.cx.resolver.visit_expansion(mark, &result.0);\n+            self.cx.resolver.visit_expansion(mark, &result.0, derives);\n             self.cx.resolve_err_count += self.cx.parse_sess.span_diagnostic.err_count() - err_count;\n         }\n \n         result\n     }\n \n+    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+        let (attr, traits, item) = match invoc.kind {\n+            InvocationKind::Bang { ref mac, .. } => {\n+                return self.cx.resolver.resolve_macro(scope, &mac.node.path, force).map(Some);\n+            }\n+            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n+            InvocationKind::Derive { name, span, .. } => {\n+                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+                return self.cx.resolver.resolve_derive_macro(scope, &path, force).map(Some);\n+            }\n+            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n+        };\n+\n+        let (attr_name, path) = {\n+            let attr = attr.as_ref().unwrap();\n+            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n+        };\n+\n+        let mut determined = true;\n+        match self.cx.resolver.resolve_macro(scope, &path, force) {\n+            Ok(ext) => return Ok(Some(ext)),\n+            Err(Determinacy::Undetermined) => determined = false,\n+            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n+            _ => {}\n+        }\n+\n+        for &(name, span) in traits {\n+            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+            match self.cx.resolver.resolve_macro(scope, &path, force) {\n+                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n+                    if inert_attrs.contains(&attr_name) {\n+                        // FIXME(jseyfried) Avoid `mem::replace` here.\n+                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+                            .make_items().pop().unwrap();\n+                        *item = mem::replace(item, Annotatable::Item(dummy_item))\n+                            .map_attrs(|mut attrs| {\n+                                let inert_attr = attr.take().unwrap();\n+                                attr::mark_known(&inert_attr);\n+                                if self.cx.ecfg.proc_macro_enabled() {\n+                                    *attr = find_attr_invoc(&mut attrs);\n+                                }\n+                                attrs.push(inert_attr);\n+                                attrs\n+                            });\n+                    }\n+                    return Err(Determinacy::Undetermined);\n+                },\n+                Err(Determinacy::Undetermined) => determined = false,\n+                Err(Determinacy::Determined) => {}\n+            }\n+        }\n+\n+        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n+    }\n+\n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n@@ -350,7 +432,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n-            InvocationKind::Attr { attr, item } => (attr, item),\n+            InvocationKind::Attr { attr, item, .. } => (attr.unwrap(), item),\n             _ => unreachable!(),\n         };\n \n@@ -503,64 +585,60 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a derive invocation. Returns the result of expansion.\n     fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n-        let (attr, item) = match invoc.kind {\n-            InvocationKind::Derive { attr, item } => (attr, item),\n+        let (name, span, item) = match invoc.kind {\n+            InvocationKind::Derive { name, span, item } => (name, span, item),\n             _ => unreachable!(),\n         };\n \n-        attr::mark_used(&attr);\n-        let titem = derive_attr_trait(self.cx, &attr).unwrap();\n-        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n-        let name = Symbol::intern(&format!(\"derive({})\", tname));\n-        let mitem = &attr.value;\n+        let mitem = ast::MetaItem { name: name, span: span, node: ast::MetaItemKind::Word };\n+        let pretty_name = Symbol::intern(&format!(\"derive({})\", name));\n \n         self.cx.bt_push(ExpnInfo {\n-            call_site: attr.span,\n+            call_site: span,\n             callee: NameAndSpan {\n-                format: MacroAttribute(attr.name()),\n-                span: Some(attr.span),\n+                format: MacroAttribute(pretty_name),\n+                span: Some(span),\n                 allow_internal_unstable: false,\n             }\n         });\n \n         match *ext {\n-            SyntaxExtension::ProcMacroDerive(ref ext) => {\n+            SyntaxExtension::ProcMacroDerive(ref ext, _) => {\n                 let span = Span {\n                     expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: mitem.span,\n+                        call_site: span,\n                         callee: NameAndSpan {\n-                            format: MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n+                            format: MacroAttribute(pretty_name),\n                             span: None,\n                             allow_internal_unstable: false,\n                         },\n                     }),\n-                    ..mitem.span\n+                    ..span\n                 };\n                 return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n             }\n             SyntaxExtension::BuiltinDerive(func) => {\n                 let span = Span {\n                     expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: titem.span,\n+                        call_site: span,\n                         callee: NameAndSpan {\n-                            format: MacroAttribute(name),\n+                            format: MacroAttribute(pretty_name),\n                             span: None,\n                             allow_internal_unstable: true,\n                         },\n                     }),\n-                    ..titem.span\n+                    ..span\n                 };\n                 let mut items = Vec::new();\n                 func(self.cx, span, &mitem, &item, &mut |a| {\n                     items.push(a)\n                 });\n-                items.insert(0, item);\n                 return kind.expect_from_annotatables(items);\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n-                self.cx.span_err(attr.span, &msg);\n-                kind.dummy(attr.span)\n+                self.cx.span_err(span, &msg);\n+                kind.dummy(span)\n             }\n         }\n     }\n@@ -672,34 +750,40 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n \n-    fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n+    fn collect_attr(&mut self,\n+                    attr: Option<ast::Attribute>,\n+                    traits: Vec<(Symbol, Span)>,\n+                    item: Annotatable,\n+                    kind: ExpansionKind)\n                     -> Expansion {\n-        let invoc_kind = if attr.name() == \"derive\" {\n-            if kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems {\n-                self.cx.span_err(attr.span, \"`derive` can be only be applied to items\");\n-                return kind.expect_from_annotatables(::std::iter::once(item));\n-            }\n-            InvocationKind::Derive { attr: attr, item: item }\n-        } else {\n-            InvocationKind::Attr { attr: attr, item: item }\n-        };\n-\n-        self.collect(kind, invoc_kind)\n+        if !traits.is_empty() &&\n+           (kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems) {\n+            self.cx.span_err(traits[0].1, \"`derive` can be only be applied to items\");\n+            return kind.expect_from_annotatables(::std::iter::once(item));\n+        }\n+        self.collect(kind, InvocationKind::Attr { attr: attr, traits: traits, item: item })\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n-        let mut attr = None;\n+    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<(Symbol, Span)>, T)\n+        where T: HasAttrs,\n+    {\n+        let (mut attr, mut traits) = (None, Vec::new());\n \n         item = item.map_attrs(|mut attrs| {\n-            attr = self.cx.resolver.find_attr_invoc(&mut attrs).or_else(|| {\n-                find_derive_attr(self.cx, &mut attrs)\n-            });\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs) {\n+                attr = Some(legacy_attr_invoc);\n+                return attrs;\n+            }\n \n+            if self.cx.ecfg.proc_macro_enabled() {\n+                attr = find_attr_invoc(&mut attrs);\n+            }\n+            traits = collect_derives(&mut self.cx, &mut attrs);\n             attrs\n         });\n \n-        (item, attr)\n+        (attr, traits, item)\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -717,6 +801,16 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n+fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+    for i in 0 .. attrs.len() {\n+        if !attr::is_known(&attrs[i]) && !is_builtin_attr(&attrs[i]) {\n+             return Some(attrs.remove(i));\n+        }\n+    }\n+\n+    None\n+}\n+\n // These are pretty nasty. Ideally, we would keep the tokens around, linked from\n // the AST. However, we don't so we need to create new ones. Since the item might\n // have come from a macro expansion (possibly only in part), we can't use the\n@@ -844,10 +938,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let item = configure!(self, item);\n \n-        let (mut item, attr) = self.classify_item(item);\n-        if let Some(attr) = attr {\n+        let (attr, traits, mut item) = self.classify_item(item);\n+        if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n-            return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n+            return self.collect_attr(attr, traits, item, ExpansionKind::Items).make_items();\n         }\n \n         match item.node {\n@@ -928,11 +1022,12 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         let item = configure!(self, item);\n \n-        let (item, attr) = self.classify_item(item);\n-        if let Some(attr) = attr {\n+        let (attr, traits, item) = self.classify_item(item);\n+        if attr.is_some() || !traits.is_empty() {\n             let item =\n                 Annotatable::TraitItem(P(fully_configure!(self, item, noop_fold_trait_item)));\n-            return self.collect_attr(attr, item, ExpansionKind::TraitItems).make_trait_items()\n+            return self.collect_attr(attr, traits, item, ExpansionKind::TraitItems)\n+                .make_trait_items()\n         }\n \n         match item.node {\n@@ -948,10 +1043,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n         let item = configure!(self, item);\n \n-        let (item, attr) = self.classify_item(item);\n-        if let Some(attr) = attr {\n+        let (attr, traits, item) = self.classify_item(item);\n+        if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::ImplItem(P(fully_configure!(self, item, noop_fold_impl_item)));\n-            return self.collect_attr(attr, item, ExpansionKind::ImplItems).make_impl_items();\n+            return self.collect_attr(attr, traits, item, ExpansionKind::ImplItems)\n+                .make_impl_items();\n         }\n \n         match item.node {\n@@ -1038,6 +1134,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_trace_macros = trace_macros,\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = custom_derive,\n+        fn proc_macro_enabled = proc_macro,\n     }\n }\n "}, {"sha": "0636a78b2152f11ac0ed6e868cc78d3f85d16cba", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -84,8 +84,17 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion) {\n-        let expansion = expansion.fold_with(self);\n+    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion, derives: Vec<Mark>) {\n+        let mut expansion = expansion.fold_with(self);\n+        if let Expansion::Items(mut items) = expansion {\n+            for derive in derives {\n+                match self.remove(derive.as_placeholder_id()) {\n+                    Expansion::Items(derived_items) => items.extend(derived_items),\n+                    _ => unreachable!(),\n+                }\n+            }\n+            expansion = Expansion::Items(items);\n+        }\n         self.expansions.insert(id, expansion);\n     }\n "}, {"sha": "a7e2d82bb978f7b4c2c1917fd335d480d81f3e36", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -107,12 +107,10 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         });\n \n-        let mut res = vec![Annotatable::Item(item)];\n         // Reassign spans of all expanded items to the input `item`\n         // for better errors here.\n-        res.extend(new_items.into_iter().flat_map(|item| {\n-            ChangeSpan { span: span }.fold_item(item)\n-        }).map(Annotatable::Item));\n-        res\n+        new_items.into_iter().map(|item| {\n+            Annotatable::Item(ChangeSpan { span: span }.fold_item(item).expect_one(\"\"))\n+        }).collect()\n     }\n }"}, {"sha": "3480bd895bf1cabb56602da59851abc89de9fd03", "filename": "src/test/compile-fail-fulldeps/gated-quote.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -39,18 +39,18 @@ impl ParseSess {\n \n pub fn main() {\n     let ecx = &ParseSess;\n-    let x = quote_tokens!(ecx, 3);    //~ ERROR macro undefined: 'quote_tokens!'\n-    let x = quote_expr!(ecx, 3);      //~ ERROR macro undefined: 'quote_expr!'\n-    let x = quote_ty!(ecx, 3);        //~ ERROR macro undefined: 'quote_ty!'\n-    let x = quote_method!(ecx, 3);    //~ ERROR macro undefined: 'quote_method!'\n-    let x = quote_item!(ecx, 3);      //~ ERROR macro undefined: 'quote_item!'\n-    let x = quote_pat!(ecx, 3);       //~ ERROR macro undefined: 'quote_pat!'\n-    let x = quote_arm!(ecx, 3);       //~ ERROR macro undefined: 'quote_arm!'\n-    let x = quote_stmt!(ecx, 3);      //~ ERROR macro undefined: 'quote_stmt!'\n-    let x = quote_matcher!(ecx, 3);   //~ ERROR macro undefined: 'quote_matcher!'\n-    let x = quote_attr!(ecx, 3);      //~ ERROR macro undefined: 'quote_attr!'\n-    let x = quote_arg!(ecx, 3);       //~ ERROR macro undefined: 'quote_arg!'\n-    let x = quote_block!(ecx, 3);     //~ ERROR macro undefined: 'quote_block!'\n-    let x = quote_meta_item!(ecx, 3); //~ ERROR macro undefined: 'quote_meta_item!'\n-    let x = quote_path!(ecx, 3);      //~ ERROR macro undefined: 'quote_path!'\n+    let x = quote_tokens!(ecx, 3);    //~ ERROR macro undefined: `quote_tokens`\n+    let x = quote_expr!(ecx, 3);      //~ ERROR macro undefined: `quote_expr`\n+    let x = quote_ty!(ecx, 3);        //~ ERROR macro undefined: `quote_ty`\n+    let x = quote_method!(ecx, 3);    //~ ERROR macro undefined: `quote_method`\n+    let x = quote_item!(ecx, 3);      //~ ERROR macro undefined: `quote_item`\n+    let x = quote_pat!(ecx, 3);       //~ ERROR macro undefined: `quote_pat`\n+    let x = quote_arm!(ecx, 3);       //~ ERROR macro undefined: `quote_arm`\n+    let x = quote_stmt!(ecx, 3);      //~ ERROR macro undefined: `quote_stmt`\n+    let x = quote_matcher!(ecx, 3);   //~ ERROR macro undefined: `quote_matcher`\n+    let x = quote_attr!(ecx, 3);      //~ ERROR macro undefined: `quote_attr`\n+    let x = quote_arg!(ecx, 3);       //~ ERROR macro undefined: `quote_arg`\n+    let x = quote_block!(ecx, 3);     //~ ERROR macro undefined: `quote_block`\n+    let x = quote_meta_item!(ecx, 3); //~ ERROR macro undefined: `quote_meta_item`\n+    let x = quote_path!(ecx, 3);      //~ ERROR macro undefined: `quote_path`\n }"}, {"sha": "d5d8d7b6ef85a7d5398adea7057e85da980ca7ce", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -14,5 +14,5 @@\n extern crate macro_crate_test;\n \n fn main() {\n-    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: 'unexported_macro!'\n+    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: `unexported_macro`\n }"}, {"sha": "03c3960a1efe2696f6a372e905dac74b95cb8792", "filename": "src/test/compile-fail/feature-gate-rustc-diagnostic-macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -12,12 +12,12 @@\n // gate\n \n __register_diagnostic!(E0001);\n-//~^ ERROR macro undefined: '__register_diagnostic!'\n+//~^ ERROR macro undefined: `__register_diagnostic`\n \n fn main() {\n     __diagnostic_used!(E0001);\n-    //~^ ERROR macro undefined: '__diagnostic_used!'\n+    //~^ ERROR macro undefined: `__diagnostic_used`\n }\n \n __build_diagnostic_array!(DIAGNOSTICS);\n-//~^ ERROR macro undefined: '__build_diagnostic_array!'\n+//~^ ERROR macro undefined: `__build_diagnostic_array`"}, {"sha": "7819fd4c1abc7febf0e8796a319c60a91b010313", "filename": "src/test/compile-fail/issue-11692.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     print!(test!());\n-    //~^ ERROR: macro undefined: 'test!'\n+    //~^ ERROR: macro undefined: `test`\n     //~^^ ERROR: format argument must be a string literal\n \n     concat!(test!());\n-    //~^ ERROR: macro undefined: 'test!'\n+    //~^ ERROR: macro undefined: `test`\n }"}, {"sha": "fe0648c3713ffc9144ef3d68053c5e53a8e90e7b", "filename": "src/test/compile-fail/issue-19734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -11,5 +11,5 @@\n fn main() {}\n \n impl Type {\n-    undef!(); //~ ERROR macro undefined: 'undef!'\n+    undef!(); //~ ERROR macro undefined: `undef`\n }"}, {"sha": "3512b21961a1419618238cdb9318c310f4cb6091", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR macro undefined: 'derive!'\n+    derive!(); //~ ERROR macro undefined: `derive`\n }"}, {"sha": "d35428efaccb3b5fd93073e707892c7644484c01", "filename": "src/test/compile-fail/macro_undefined.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -18,8 +18,8 @@ mod m {\n }\n \n fn main() {\n-    k!(); //~ ERROR macro undefined: 'k!'\n+    k!(); //~ ERROR macro undefined: `k`\n           //~^ HELP did you mean `kl!`?\n-    kl!(); //~ ERROR macro undefined: 'kl!'\n+    kl!(); //~ ERROR macro undefined: `kl`\n            //~^ HELP have you added the `#[macro_use]` on the module/import?\n }"}, {"sha": "b3ab96b79c4925747d50e862c051b1797637ec96", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n         ref mut Self => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Self!() => (),\n-        //~^ ERROR macro undefined: 'Self!'\n+        //~^ ERROR macro undefined: `Self`\n         Foo { Self } => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n     }"}, {"sha": "b7374a07e427ade5132ede77ba9e65c4bba1b6b7", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -20,6 +20,5 @@ use proc_macro::TokenStream;\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n-    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n     \"\".parse().unwrap()\n }"}, {"sha": "67d828d92a700028fdd3418880a6577ad91b235c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-atob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -19,6 +19,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"#[derive(Copy, Clone)]\\nstruct A;\");\n+    assert_eq!(input, \"struct A;\");\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "bf793534d50c960a1beb6ed5a023a7d6738e8363", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2bcbaa00c05e051718b1375375915064f1c3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=956e2bcbaa00c05e051718b1375375915064f1c3", "patch": "@@ -22,6 +22,5 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     assert!(input.contains(\"#[B]\"));\n     assert!(input.contains(\"struct B {\"));\n     assert!(input.contains(\"#[C]\"));\n-    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n     \"\".parse().unwrap()\n }"}]}