{"sha": "4f0ca9248f93162201ea88a99594deedf0ebd897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMGNhOTI0OGY5MzE2MjIwMWVhODhhOTk1OTRkZWVkZjBlYmQ4OTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-07T03:55:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-07T03:55:28Z"}, "message": "Auto merge of #52123 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #51901 (Rc: remove unused allocation and fix segfault in Weak::new())\n - #52058 (Use of unimplemented!() causing ICE with NLL)\n - #52067 (Visit the mir basic blocks in reverse-postfix order)\n - #52083 (Dont run ast borrowck on mir mode)\n - #52099 (fix typo in stable `--edition` error message)\n - #52103 (Stabilize rc_downcast)\n - #52104 (Remove unnecessary feature gate.)\n - #52117 (Dedupe filetime)\n - #52120 (ARM: expose the \"mclass\" target feature)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f60c4cc897ab197b4e2128f7160d54421db8ca06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60c4cc897ab197b4e2128f7160d54421db8ca06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f0ca9248f93162201ea88a99594deedf0ebd897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f0ca9248f93162201ea88a99594deedf0ebd897", "html_url": "https://github.com/rust-lang/rust/commit/4f0ca9248f93162201ea88a99594deedf0ebd897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f0ca9248f93162201ea88a99594deedf0ebd897/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99b0ddb88a3e6aa5ddec35961be845ff361d031e", "url": "https://api.github.com/repos/rust-lang/rust/commits/99b0ddb88a3e6aa5ddec35961be845ff361d031e", "html_url": "https://github.com/rust-lang/rust/commit/99b0ddb88a3e6aa5ddec35961be845ff361d031e"}, {"sha": "cd7ddae695fca0aac2f10b5eeaa3af4612cddf23", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7ddae695fca0aac2f10b5eeaa3af4612cddf23", "html_url": "https://github.com/rust-lang/rust/commit/cd7ddae695fca0aac2f10b5eeaa3af4612cddf23"}], "stats": {"total": 529, "additions": 354, "deletions": 175}, "files": [{"sha": "7297d8a8299a82bcf0d407b29288cc832e3f0f78", "filename": "src/Cargo.lock", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -147,7 +147,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cc 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cmake 0.1.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -416,7 +416,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -693,16 +693,6 @@ dependencies = [\n name = \"features\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"filetime\"\n-version = \"0.1.15\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cfg-if 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"filetime\"\n version = \"0.2.1\"\n@@ -1139,11 +1129,11 @@ dependencies = [\n \n [[package]]\n name = \"lzma-sys\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3075,7 +3065,7 @@ name = \"xz2\"\n version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lzma-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lzma-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3134,7 +3124,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n \"checksum failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7cdda555bb90c9bb67a3b670a0f42de8e73f5981524123ad8578aafec8ddb8b\"\n-\"checksum filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"714653f3e34871534de23771ac7b26e999651a0a228f47beb324dfdf1dd4b10f\"\n \"checksum filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da4b9849e77b13195302c174324b5ba73eec9b236b24c221a61000daefb95c5f\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fac2277e84e5e858483756647a9d0aa8d9a2b7cba517fd84325a0aaa69a0909\"\n@@ -3179,7 +3168,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b\"\n \"checksum log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"61bd98ae7f7b754bc53dca7d44b604f733c6bba044ea6f41bc8d89272d8161d2\"\n \"checksum log_settings 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n-\"checksum lzma-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1b93b78f89e8737dac81837fc8f5521ac162abcba902e1a3db949d55346d1da\"\n+\"checksum lzma-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1eaa027402541975218bb0eec67d6b0412f6233af96e0d096d31dbdfd22e614\"\n \"checksum mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c41e0c4fef86961ac6d6f8a82609f55f31b05e4fce149ac5710e439df7619ba4\"\n \"checksum maplit 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \"checksum markup5ever 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bfedc97d5a503e96816d10fedcd5b42f760b2e525ce2f7ec71f6a41780548475\""}, {"sha": "57a526038041e5037fe82acb2cbc23104968d463", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -36,7 +36,7 @@ test = false\n [dependencies]\n build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.23\"\n-filetime = \"0.1\"\n+filetime = \"0.2\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n cc = \"1.0.1\""}, {"sha": "f7c12b98f481e5db3175c6d27b0f1b18e4431b27", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -253,7 +253,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n@@ -620,13 +620,12 @@ impl<T: Clone> Rc<T> {\n \n impl Rc<Any> {\n     #[inline]\n-    #[unstable(feature = \"rc_downcast\", issue = \"44608\")]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Rc<Any>` to a concrete type.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_downcast)]\n     /// use std::any::Any;\n     /// use std::rc::Rc;\n     ///\n@@ -1153,6 +1152,10 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1165,8 +1168,8 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1181,18 +1184,18 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Box::into_raw_non_null(box RcBox {\n-                    strong: Cell::new(0),\n-                    weak: Cell::new(1),\n-                    value: uninitialized(),\n-                }),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n \n+pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+    let address = ptr.as_ptr() as *mut () as usize;\n+    let align = align_of_val(unsafe { ptr.as_ref() });\n+    address == align\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n     /// the lifetime of the value if successful.\n@@ -1222,13 +1225,25 @@ impl<T: ?Sized> Weak<T> {\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n+        let inner = self.inner()?;\n+        if inner.strong() == 0 {\n             None\n         } else {\n-            self.inc_strong();\n+            inner.inc_strong();\n             Some(Rc { ptr: self.ptr, phantom: PhantomData })\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&RcBox<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1258,12 +1273,14 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dec_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n-            if self.weak() == 0 {\n-                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+            if inner.weak() == 0 {\n+                unsafe {\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                }\n             }\n         }\n     }\n@@ -1284,7 +1301,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.inc_weak()\n+        }\n         Weak { ptr: self.ptr }\n     }\n }\n@@ -1317,7 +1336,7 @@ impl<T> Default for Weak<T> {\n     }\n }\n \n-// NOTE: We checked_add here to deal with mem::forget safety. In particular\n+// NOTE: We checked_add here to deal with mem::forget safely. In particular\n // if you mem::forget Rcs (or Weaks), the ref-count can overflow, and then\n // you can free the allocation while outstanding Rcs (or Weaks) exist.\n // We abort because this is such a degenerate scenario that we don't care about\n@@ -1370,12 +1389,10 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            self.ptr.as_ref()\n-        }\n+        self\n     }\n }\n "}, {"sha": "5a738fc54441f41674488c6dbc1c4d84d3bec963", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -34,6 +34,7 @@ use core::convert::From;\n \n use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use boxed::Box;\n+use rc::is_dangling;\n use string::String;\n use vec::Vec;\n \n@@ -43,9 +44,6 @@ use vec::Vec;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// A sentinel value that is used for the pointer of `Weak::new()`.\n-const WEAK_EMPTY: usize = 1;\n-\n /// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n /// Reference Counted'.\n ///\n@@ -239,9 +237,9 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n-    // but it is actually not truly \"non-null\". A `Weak::new()` will set this\n-    // to a sentinel value, instead of needing to allocate some space in the\n-    // heap.\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -982,13 +980,12 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n \n impl Arc<Any + Send + Sync> {\n     #[inline]\n-    #[unstable(feature = \"rc_downcast\", issue = \"44608\")]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Arc<Any + Send + Sync>` to a concrete type.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_downcast)]\n     /// use std::any::Any;\n     /// use std::sync::Arc;\n     ///\n@@ -1035,10 +1032,8 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: NonNull::new_unchecked(WEAK_EMPTY as *mut _),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n@@ -1074,11 +1069,7 @@ impl<T: ?Sized> Weak<T> {\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return None;\n-        } else {\n-            unsafe { self.ptr.as_ref() }\n-        };\n+        let inner = self.inner()?;\n \n         // Relaxed load because any write of 0 that we can observe\n         // leaves the field in a permanently zero state (so a\n@@ -1109,6 +1100,17 @@ impl<T: ?Sized> Weak<T> {\n             }\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&ArcInner<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -1126,10 +1128,10 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return Weak { ptr: self.ptr };\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return Weak { ptr: self.ptr };\n         };\n         // See comments in Arc::clone() for why this is relaxed.  This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n@@ -1204,10 +1206,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // weak count can only be locked if there was precisely one weak ref,\n         // meaning that drop could only subsequently run ON that remaining weak\n         // ref, which can only happen after the lock is released.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return;\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return\n         };\n \n         if inner.weak.fetch_sub(1, Release) == 1 {"}, {"sha": "753873dd294ce19564c075a6bf275706e4ba5553", "filename": "src/liballoc/tests/arc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::sync::{Arc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n+    let a: Arc<[u32]> = a;  // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Arc<u32> = Arc::new(4);\n+    let a: Arc<Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "2c361598e8928c8389172f86a4a1a93e478825df", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -32,12 +32,14 @@ extern crate rand;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n+mod arc;\n mod binary_heap;\n mod btree;\n mod cow_str;\n mod fmt;\n mod heap;\n mod linked_list;\n+mod rc;\n mod slice;\n mod str;\n mod string;"}, {"sha": "baa0406acfc3dbcc02cdc8d1f2f2d349cd225349", "filename": "src/liballoc/tests/rc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::rc::{Rc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n+    let a: Rc<[u32]> = a;  // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Rc<u32> = Rc::new(4);\n+    let a: Rc<Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "bbe6ae8619fec5bd27a154fe61afb5794b0a3664", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -122,7 +122,6 @@\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n-#![cfg_attr(stage0, feature(repr_transparent))]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "95c68214ec7ce6e7a62a8c2dc63001d31a93ded2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1816,7 +1816,7 @@ pub fn build_session_options_and_crate_config(\n         early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"Edition {} is unstable an only\\\n+                    \"Edition {} is unstable and only \\\n                     available for nightly builds of rustc.\",\n                     edition,\n                 )"}, {"sha": "8f7f9d09423f68198ffd321e6587a286881f7ba9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1354,6 +1354,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         !self.sess.opts.debugging_opts.disable_ast_check_for_mutation_in_guard\n     }\n \n+    /// If true, we should use the AST-based borrowck (we may *also* use\n+    /// the MIR-based borrowck).\n+    pub fn use_ast_borrowck(self) -> bool {\n+        self.borrowck_mode().use_ast()\n+    }\n+\n     /// If true, we should use the MIR-based borrowck (we may *also* use\n     /// the AST-based borrowck).\n     pub fn use_mir_borrowck(self) -> bool {"}, {"sha": "df1b1138f3e888cbbe7848242dcf370875a2b2db", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -89,6 +89,8 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     -> Lrc<BorrowCheckResult>\n {\n+    assert!(tcx.use_ast_borrowck());\n+\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();"}, {"sha": "87ee9ef5adb23aad019ecafd85a8c1571d24e198", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -84,6 +84,7 @@ unsafe fn configure_llvm(sess: &Session) {\n // array, leading to crashes.\n \n const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"mclass\", Some(\"arm_target_feature\")),\n     (\"neon\", Some(\"arm_target_feature\")),\n     (\"v7\", Some(\"arm_target_feature\")),\n     (\"vfp2\", Some(\"arm_target_feature\")),"}, {"sha": "96e9616699d3717a8ba86adfb524547f4307927c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1279,7 +1279,11 @@ where\n                 middle::liveness::check_crate(tcx)\n             });\n \n-            time(sess, \"borrow checking\", || borrowck::check_crate(tcx));\n+            time(sess, \"borrow checking\", || {\n+                if tcx.use_ast_borrowck() {\n+                    borrowck::check_crate(tcx);\n+                }\n+            });\n \n             time(sess,\n                  \"MIR borrow checking\","}, {"sha": "e9e0c5c36135322c7594209307c627ec4cae2df8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -53,25 +53,22 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     }\n }\n \n-/// Every two-phase borrow has *exactly one* use (or else it is not a\n-/// proper two-phase borrow under our current definition). However, not\n-/// all uses are actually ones that activate the reservation.. In\n-/// particular, a shared borrow of a `&mut` does not activate the\n-/// reservation.\n+/// Location where a two phase borrow is activated, if a borrow\n+/// is in fact a two phase borrow.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum TwoPhaseUse {\n-    MutActivate,\n-    SharedUse,\n+crate enum TwoPhaseActivation {\n+    NotTwoPhase,\n+    NotActivated,\n+    ActivatedAt(Location),\n }\n \n #[derive(Debug)]\n crate struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n     /// In many cases, this will be equal to the activation location but not always.\n     crate reserve_location: Location,\n-    /// Location where the borrow is activated. None if this is not a\n-    /// 2-phase borrow.\n-    crate activation_location: Option<(TwoPhaseUse, Location)>,\n+    /// Location where the borrow is activated.\n+    crate activation_location: TwoPhaseActivation,\n     /// What kind of borrow this is\n     crate kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n@@ -116,19 +113,6 @@ impl<'tcx> BorrowSet<'tcx> {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n \n-        // Double check: We should have found an activation for every pending\n-        // activation.\n-        assert_eq!(\n-            visitor\n-                .pending_activations\n-                .iter()\n-                .find(|&(_local, &borrow_index)| visitor.idx_vec[borrow_index]\n-                    .activation_location\n-                    .is_none()),\n-            None,\n-            \"never found an activation for this borrow!\",\n-        );\n-\n         BorrowSet {\n             borrows: visitor.idx_vec,\n             location_map: visitor.location_map,\n@@ -183,7 +167,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 kind,\n                 region,\n                 reserve_location: location,\n-                activation_location: None,\n+                activation_location: TwoPhaseActivation::NotTwoPhase,\n                 borrowed_place: borrowed_place.clone(),\n                 assigned_place: assigned_place.clone(),\n             };\n@@ -232,38 +216,43 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    if let Some(other_activation) = borrow_data.activation_location {\n+                    if let TwoPhaseActivation::ActivatedAt(other_location) =\n+                            borrow_data.activation_location {\n                         span_bug!(\n                             self.mir.source_info(location).span,\n                             \"found two uses for 2-phase borrow temporary {:?}: \\\n                              {:?} and {:?}\",\n                             temp,\n                             location,\n-                            other_activation,\n+                            other_location,\n                         );\n                     }\n \n                     // Otherwise, this is the unique later use\n                     // that we expect.\n-\n-                    let two_phase_use;\n-\n-                    match context {\n+                    borrow_data.activation_location = match context {\n                         // The use of TMP in a shared borrow does not\n                         // count as an actual activation.\n                         PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. } => {\n-                            two_phase_use = TwoPhaseUse::SharedUse;\n+                            TwoPhaseActivation::NotActivated\n                         }\n                         _ => {\n-                            two_phase_use = TwoPhaseUse::MutActivate;\n+                            // Double check: This borrow is indeed a two-phase borrow (that is,\n+                            // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n+                            // we've not found any other activations (checked above).\n+                            assert_eq!(\n+                                borrow_data.activation_location,\n+                                TwoPhaseActivation::NotActivated,\n+                                \"never found an activation for this borrow!\",\n+                            );\n+\n                             self.activation_map\n                                 .entry(location)\n                                 .or_insert(Vec::new())\n                                 .push(borrow_index);\n+                            TwoPhaseActivation::ActivatedAt(location)\n                         }\n-                    }\n-\n-                    borrow_data.activation_location = Some((two_phase_use, location));\n+                    };\n                 }\n \n                 None => {}\n@@ -342,6 +331,11 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n             );\n         };\n \n+        // Consider the borrow not activated to start. When we find an activation, we'll update\n+        // this field.\n+        let borrow_data = &mut self.idx_vec[borrow_index];\n+        borrow_data.activation_location = TwoPhaseActivation::NotActivated;\n+\n         // Insert `temp` into the list of pending activations. From\n         // now on, we'll be on the lookout for a use of it. Note that\n         // we are guaranteed that this use will come after the"}, {"sha": "a5db0d15d8ab309414ab7c3de44c8ea9fa785e0b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -80,7 +80,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     let mut return_early;\n \n     // Return early if we are not supposed to use MIR borrow checker for this function.\n-    return_early = !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir_borrowck();\n+    return_early = !tcx.has_attr(def_id, \"rustc_mir\") && !tcx.use_mir_borrowck();\n \n     if tcx.is_struct_constructor(def_id) {\n         // We are not borrow checking the automatically generated struct constructors"}, {"sha": "ca2a120ceb7375e3ece7b6eb3ed23e376a41fdbc", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseUse};\n+use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseActivation};\n use borrow_check::places_conflict;\n use borrow_check::Context;\n use borrow_check::ShallowOrDeep;\n@@ -83,11 +83,11 @@ pub(super) fn is_active<'tcx>(\n \n     let activation_location = match borrow_data.activation_location {\n         // If this is not a 2-phase borrow, it is always active.\n-        None => return true,\n+        TwoPhaseActivation::NotTwoPhase => return true,\n         // And if the unique 2-phase use is not an activation, then it is *never* active.\n-        Some((TwoPhaseUse::SharedUse, _)) => return false,\n-        // Otherwise, we derive info from the activation point `v`:\n-        Some((TwoPhaseUse::MutActivate, v)) => v,\n+        TwoPhaseActivation::NotActivated => return false,\n+        // Otherwise, we derive info from the activation point `loc`:\n+        TwoPhaseActivation::ActivatedAt(loc) => loc,\n     };\n \n     // Otherwise, it is active for every location *except* in between"}, {"sha": "e3b67b0a003efd2b202deafa16a4953f5466e885", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::work_queue::WorkQueue;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n+use rustc::mir::traversal;\n use rustc::session::Session;\n \n use std::borrow::Borrow;\n@@ -332,7 +333,7 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n         let flow = flow_uninit;\n-        for bb in self.mir().basic_blocks().indices() {\n+        for (bb, _) in traversal::reverse_postorder(self.mir()) {\n             flow.reset_to_entry_of(bb);\n             self.process_basic_block(bb, flow);\n         }"}, {"sha": "90dfebeef1b0ca7b0bb194b1bc46d3808e2ca251", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -225,7 +225,10 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n     let _ = tcx.mir_borrowck(def_id);\n-    let _ = tcx.borrowck(def_id);\n+\n+    if tcx.use_ast_borrowck() {\n+        let _ = tcx.borrowck(def_id);\n+    }\n \n     let mut mir = tcx.mir_validated(def_id).steal();\n     run_passes![tcx, mir, def_id, 2;"}, {"sha": "da149f420644c5cd551dfd04cb013150b334caaa", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -36,7 +36,7 @@ impl MirPass for SanityCheck {\n                           src: MirSource, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") {\n+        if !tcx.has_attr(def_id, \"rustc_mir\") {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n             return;\n         } else {"}, {"sha": "f5f0ede6864f4df3fe5064aef97b50de96edfdb0", "filename": "src/test/compile-fail/mir-dataflow/def-inits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,14 +10,14 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n+#![feature(nll)]\n #![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};\n \n struct S(i32);\n \n-#[rustc_mir_borrowck]\n #[rustc_mir(rustc_peek_definite_init,stop_after_dataflow)]\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;"}, {"sha": "595f01f7c94b34a065a5736b8297a6ea34b2c1f4", "filename": "src/test/compile-fail/mir-dataflow/inits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,14 +10,14 @@\n \n // General test of maybe_inits state computed by MIR dataflow.\n \n+#![feature(nll)]\n #![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};\n \n struct S(i32);\n \n-#[rustc_mir_borrowck]\n #[rustc_mir(rustc_peek_maybe_init,stop_after_dataflow)]\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;"}, {"sha": "bb10c03254e3cb065a7514ee7108635a9f86a289", "filename": "src/test/compile-fail/mir-dataflow/uninits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,14 +10,14 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n+#![feature(nll)]\n #![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};\n \n struct S(i32);\n \n-#[rustc_mir_borrowck]\n #[rustc_mir(rustc_peek_maybe_uninit,stop_after_dataflow)]\n fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n     let ret;"}, {"sha": "9854ea779b3adfac2de73d5d63a36fd5e195a420", "filename": "src/test/compile-fail/mir-dataflow/uninits-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,14 +10,14 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n+#![feature(nll)]\n #![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};\n \n struct S(i32);\n \n-#[rustc_mir_borrowck]\n #[rustc_mir(rustc_peek_maybe_uninit,stop_after_dataflow)]\n fn foo(x: &mut S) {\n     // `x` is initialized here, so maybe-uninit bit is 0."}, {"sha": "9efd08195a1bb123f5324f5f319a0b5c87052792", "filename": "src/test/run-fail/issue-51345.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-fail%2Fissue-51345.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-fail%2Fissue-51345.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-51345.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: thread 'main' panicked at 'explicit panic'\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let mut vec = vec![];\n+    vec.push((vec.len(), panic!()));\n+}"}, {"sha": "7d392944685b830b39c5a7828d0990f87ad87e44", "filename": "src/test/run-pass/issue-51345.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-pass%2Fissue-51345.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-pass%2Fissue-51345.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-51345.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    loop { v.push(break) }\n+}"}, {"sha": "eb57c12ed12c62609f0ee4b70b71dd36e13322f9", "filename": "src/test/run-pass/weak-new-uninhabited-issue-48493.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    enum Void {}\n+    std::rc::Weak::<Void>::new();\n+    std::sync::Weak::<Void>::new();\n+}"}, {"sha": "addbbf4434f4f99cda802fd5f319acefb0642d90", "filename": "src/test/ui/error-codes/E0017.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,18 +10,18 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0017.rs:17:38\n-   |\n-LL | static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n-   |                                      ^^^^^^ statics require immutable values\n-\n error[E0596]: cannot borrow immutable item `X` as mutable\n   --> $DIR/E0017.rs:15:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ cannot borrow as mutable\n \n+error[E0017]: references in statics may only refer to immutable values\n+  --> $DIR/E0017.rs:17:38\n+   |\n+LL | static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n+   |                                      ^^^^^^ statics require immutable values\n+\n error: aborting due to 4 previous errors\n \n Some errors occurred: E0017, E0596."}, {"sha": "0238ca6b623da26ab44c7c91d11c7f624c785c50", "filename": "src/test/ui/error-codes/E0388.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -10,18 +10,18 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0388.rs:17:38\n-   |\n-LL | static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n-   |                                      ^^^^^^ statics require immutable values\n-\n error[E0596]: cannot borrow immutable item `X` as mutable\n   --> $DIR/E0388.rs:15:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ cannot borrow as mutable\n \n+error[E0017]: references in statics may only refer to immutable values\n+  --> $DIR/E0388.rs:17:38\n+   |\n+LL | static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n+   |                                      ^^^^^^ statics require immutable values\n+\n error: aborting due to 4 previous errors\n \n Some errors occurred: E0017, E0596."}, {"sha": "32a9783e9c213137c4ec9064c12aaa6586d26ca5", "filename": "src/test/ui/issue-47184.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fissue-47184.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fissue-47184.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47184.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -2,10 +2,9 @@ error[E0597]: borrowed value does not live long enough\n   --> $DIR/issue-47184.rs:14:44\n    |\n LL |     let _vec: Vec<&'static String> = vec![&String::new()];\n-   |                                            ^^^^^^^^^^^^^ temporary value does not live long enough\n-LL |     //~^ ERROR borrowed value does not live long enough [E0597]\n-LL | }\n-   | - temporary value only lives until here\n+   |                                            ^^^^^^^^^^^^^ - temporary value only lives until here\n+   |                                            |\n+   |                                            temporary value does not live long enough\n    |\n    = note: borrowed value must be valid for the static lifetime...\n "}, {"sha": "75194bf55bc9f1a3b9864d3648790578ea782852", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -55,6 +55,18 @@ LL | |     }\n LL | | }\n    | |_^\n \n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:45:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+LL |             Some(v) => {\n+LL |                 map.set(String::new()); // Both AST and MIR error here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+LL |                 return v;\n+   |                        - borrow later used here\n+\n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17\n    |\n@@ -76,18 +88,6 @@ LL | |     }\n LL | | }\n    | |_^\n \n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:45:17\n-   |\n-LL |         match map.get() {\n-   |               --- immutable borrow occurs here\n-LL |             Some(v) => {\n-LL |                 map.set(String::new()); // Both AST and MIR error here\n-   |                 ^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n-\n error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0502`."}, {"sha": "cbb9d0429c616350bcf11d035b5a382bf0cfa39d", "filename": "src/test/ui/span/dropck_arr_cycle_checked.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1,7 +1,7 @@\n-error[E0597]: `b1` does not live long enough\n-  --> $DIR/dropck_arr_cycle_checked.rs:111:24\n+error[E0597]: `b3` does not live long enough\n+  --> $DIR/dropck_arr_cycle_checked.rs:105:24\n    |\n-LL |     b3.a[0].v.set(Some(&b1));\n+LL |     b1.a[1].v.set(Some(&b3));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n@@ -22,10 +22,10 @@ LL | }\n    | borrowed value only lives until here\n    | borrow later used here, when `b1` is dropped\n \n-error[E0597]: `b3` does not live long enough\n-  --> $DIR/dropck_arr_cycle_checked.rs:105:24\n+error[E0597]: `b1` does not live long enough\n+  --> $DIR/dropck_arr_cycle_checked.rs:111:24\n    |\n-LL |     b1.a[1].v.set(Some(&b3));\n+LL |     b3.a[0].v.set(Some(&b1));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }"}, {"sha": "37fffe886e30950cc2882aec517ece53f6b9812a", "filename": "src/test/ui/span/dropck_direct_cycle_with_drop.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1,9 +1,9 @@\n-error[E0597]: `d1` does not live long enough\n-  --> $DIR/dropck_direct_cycle_with_drop.rs:48:19\n+error[E0597]: `d2` does not live long enough\n+  --> $DIR/dropck_direct_cycle_with_drop.rs:46:19\n    |\n-LL |     d2.p.set(Some(&d1));\n+LL |     d1.p.set(Some(&d2));\n    |                   ^^^ borrowed value does not live long enough\n-LL |     //~^ ERROR `d1` does not live long enough\n+...\n LL | }\n    | -\n    | |\n@@ -12,12 +12,12 @@ LL | }\n    |\n    = note: values in a scope are dropped in the opposite order they are defined\n \n-error[E0597]: `d2` does not live long enough\n-  --> $DIR/dropck_direct_cycle_with_drop.rs:46:19\n+error[E0597]: `d1` does not live long enough\n+  --> $DIR/dropck_direct_cycle_with_drop.rs:48:19\n    |\n-LL |     d1.p.set(Some(&d2));\n+LL |     d2.p.set(Some(&d1));\n    |                   ^^^ borrowed value does not live long enough\n-...\n+LL |     //~^ ERROR `d1` does not live long enough\n LL | }\n    | -\n    | |"}, {"sha": "13bd1f54198212077863744198898998f925bef6", "filename": "src/test/ui/span/dropck_vec_cycle_checked.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1,7 +1,7 @@\n-error[E0597]: `c1` does not live long enough\n-  --> $DIR/dropck_vec_cycle_checked.rs:121:24\n+error[E0597]: `c3` does not live long enough\n+  --> $DIR/dropck_vec_cycle_checked.rs:115:24\n    |\n-LL |     c3.v[0].v.set(Some(&c1));\n+LL |     c1.v[1].v.set(Some(&c3));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n@@ -22,10 +22,10 @@ LL | }\n    | borrowed value only lives until here\n    | borrow later used here, when `c1` is dropped\n \n-error[E0597]: `c3` does not live long enough\n-  --> $DIR/dropck_vec_cycle_checked.rs:115:24\n+error[E0597]: `c1` does not live long enough\n+  --> $DIR/dropck_vec_cycle_checked.rs:121:24\n    |\n-LL |     c1.v[1].v.set(Some(&c3));\n+LL |     c3.v[0].v.set(Some(&c1));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }"}, {"sha": "100b4c1292f44ad73c36be2c8ea02c36fb600d69", "filename": "src/test/ui/span/vec-must-not-hide-type-from-dropck.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -1,21 +1,21 @@\n-error[E0597]: `c1` does not live long enough\n-  --> $DIR/vec-must-not-hide-type-from-dropck.rs:129:24\n+error[E0597]: `c2` does not live long enough\n+  --> $DIR/vec-must-not-hide-type-from-dropck.rs:127:24\n    |\n-LL |     c2.v[0].v.set(Some(&c1));\n+LL |     c1.v[0].v.set(Some(&c2));\n    |                        ^^^ borrowed value does not live long enough\n-LL |     //~^ ERROR `c1` does not live long enough\n+...\n LL | }\n    | -\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `c1` is dropped\n \n-error[E0597]: `c2` does not live long enough\n-  --> $DIR/vec-must-not-hide-type-from-dropck.rs:127:24\n+error[E0597]: `c1` does not live long enough\n+  --> $DIR/vec-must-not-hide-type-from-dropck.rs:129:24\n    |\n-LL |     c1.v[0].v.set(Some(&c2));\n+LL |     c2.v[0].v.set(Some(&c1));\n    |                        ^^^ borrowed value does not live long enough\n-...\n+LL |     //~^ ERROR `c1` does not live long enough\n LL | }\n    | -\n    | |"}, {"sha": "582ba5adfe529c4d8ed7e31fb6429d5f11314d83", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f0ca9248f93162201ea88a99594deedf0ebd897/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=4f0ca9248f93162201ea88a99594deedf0ebd897", "patch": "@@ -6,7 +6,7 @@ version = \"0.0.0\"\n [dependencies]\n diff = \"0.1.10\"\n env_logger = { version = \"0.5\", default-features = false }\n-filetime = \"0.1\"\n+filetime = \"0.2\"\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"0.2\""}]}