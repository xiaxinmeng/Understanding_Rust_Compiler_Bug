{"sha": "93757d81853302408dd30a3ad1a4102eae26b7c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNzU3ZDgxODUzMzAyNDA4ZGQzMGEzYWQxYTQxMDJlYWUyNmI3YzU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T04:34:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T04:53:37Z"}, "message": "core::rt: Clean up the thread-local scheduler code\n\nRemove the ThreadLocalScheduler type in favor of functions.\nMove everything into the sched::local module.", "tree": {"sha": "aecf7a61921e8478b4996ef5c3ec567072277cbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aecf7a61921e8478b4996ef5c3ec567072277cbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93757d81853302408dd30a3ad1a4102eae26b7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93757d81853302408dd30a3ad1a4102eae26b7c5", "html_url": "https://github.com/rust-lang/rust/commit/93757d81853302408dd30a3ad1a4102eae26b7c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93757d81853302408dd30a3ad1a4102eae26b7c5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2e5827866876e9bafcf1f4e94f4e354e500420a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e5827866876e9bafcf1f4e94f4e354e500420a", "html_url": "https://github.com/rust-lang/rust/commit/a2e5827866876e9bafcf1f4e94f4e354e500420a"}], "stats": {"total": 153, "additions": 79, "deletions": 74}, "files": [{"sha": "e4d9c9681d74ec7e9ee3c3355b5811d46de5cdbd", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 79, "deletions": 74, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/93757d81853302408dd30a3ad1a4102eae26b7c5/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93757d81853302408dd30a3ad1a4102eae26b7c5/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=93757d81853302408dd30a3ad1a4102eae26b7c5", "patch": "@@ -11,14 +11,11 @@\n use option::*;\n use sys;\n use cast::transmute;\n-use libc::c_void;\n-use ptr::mut_null;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n-use tls = super::thread_local_storage;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -110,18 +107,13 @@ pub impl Scheduler {\n     }\n \n     fn install(~self, f: &fn(&mut Scheduler)) -> ~Scheduler {\n-        let mut tlsched = ThreadLocalScheduler::new();\n-        tlsched.put_scheduler(self);\n-        {\n-            let sched = tlsched.get_scheduler();\n-            f(sched);\n+        do local::install(self) {\n+            local::borrow(f)\n         }\n-        return tlsched.take_scheduler();\n     }\n \n     fn local(f: &fn(&mut Scheduler)) {\n-        let mut tlsched = ThreadLocalScheduler::new();\n-        f(tlsched.get_scheduler());\n+        local::borrow(f)\n     }\n \n     // * Scheduler-context operations\n@@ -329,15 +321,15 @@ pub impl Task {\n             // This is the first code to execute after the initial\n             // context switch to the task. The previous context may\n             // have asked us to do some cleanup.\n-            let mut sched = ThreadLocalScheduler::new();\n-            let sched = sched.get_scheduler();\n-            sched.run_cleanup_job();\n+            do Scheduler::local |sched| {\n+                sched.run_cleanup_job();\n+            }\n \n             start();\n \n-            let mut sched = ThreadLocalScheduler::new();\n-            let sched = sched.get_scheduler();\n-            sched.terminate_current_task();\n+            do Scheduler::local |sched| {\n+                sched.terminate_current_task();\n+            }\n         };\n         return wrapper;\n     }\n@@ -352,90 +344,103 @@ pub impl Task {\n     }\n }\n \n-// NB: This is a type so we can use make use of the &self region.\n-struct ThreadLocalScheduler(tls::Key);\n+mod local {\n+\n+    //! Access to the thread-local Scheduler\n+\n+    use ptr::mut_null;\n+    use libc::c_void;\n+    use cast::transmute;\n+\n+    use super::Scheduler;\n+    use tls = super::super::thread_local_storage;\n+    #[cfg(test)] use super::super::uvio::UvEventLoop;\n \n-impl ThreadLocalScheduler {\n-    fn new() -> ThreadLocalScheduler {\n+    /// Give the Scheduler to thread-local storage\n+    pub fn put(sched: ~Scheduler) {\n         unsafe {\n-            // NB: This assumes that the TLS key has been created prior.\n-            // Currently done in rust_start.\n-            let key: *mut c_void = rust_get_sched_tls_key();\n-            let key: &mut tls::Key = transmute(key);\n-            ThreadLocalScheduler(*key)\n+            let key = tls_key();\n+            let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+            tls::set(key, void_sched);\n         }\n     }\n \n-    fn put_scheduler(&mut self, scheduler: ~Scheduler) {\n+    /// Take ownership of the Scheduler from thread-local storage\n+    pub fn take() -> ~Scheduler {\n         unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let value: *mut c_void = transmute::<~Scheduler, *mut c_void>(scheduler);\n-            tls::set(key, value);\n+            let key = tls_key();\n+            let void_sched: *mut c_void = tls::get(key);\n+            assert!(void_sched.is_not_null());\n+            let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+            tls::set(key, mut_null());\n+            return sched;\n         }\n     }\n \n-    fn get_scheduler(&mut self) -> &'self mut Scheduler {\n+    /// Give the Scheduler to thread-local storage for the duration of the block\n+    pub fn install(sched: ~Scheduler, f: &fn()) -> ~Scheduler {\n+        put(sched);\n+        f();\n+        return take();\n+    }\n+\n+    /// Borrow a mutable reference to the thread-local Scheduler\n+    /// # Safety Note\n+    /// Because this leaves the Scheduler in thread-local storage it is possible\n+    /// For the Scheduler pointer to be aliased\n+    pub fn borrow(f: &fn(&mut Scheduler)) {\n         unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let mut value: *mut c_void = tls::get(key);\n-            assert!(value.is_not_null());\n+            let key = tls_key();\n+            let mut void_sched: *mut c_void = tls::get(key);\n+            assert!(void_sched.is_not_null());\n             {\n-                let value_ptr = &mut value;\n+                let void_sched_ptr = &mut void_sched;\n                 let sched: &mut ~Scheduler = {\n-                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n+                    transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n                 };\n                 let sched: &mut Scheduler = &mut **sched;\n-                return sched;\n+                f(sched);\n             }\n         }\n     }\n \n-    fn take_scheduler(&mut self) -> ~Scheduler {\n+    fn tls_key() -> tls::Key {\n         unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let value: *mut c_void = tls::get(key);\n-            assert!(value.is_not_null());\n-            let sched = transmute(value);\n-            tls::set(key, mut_null());\n-            return sched;\n+            let key: *mut c_void = rust_get_sched_tls_key();\n+            let key: &mut tls::Key = transmute(key);\n+            return *key;\n         }\n     }\n-}\n-\n-extern {\n-    fn rust_get_sched_tls_key() -> *mut c_void;\n-}\n-\n-#[test]\n-fn thread_local_scheduler_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    tls_scheduler.put_scheduler(scheduler);\n-    {\n-        let _scheduler = tls_scheduler.get_scheduler();\n-    }\n-    let _scheduler = tls_scheduler.take_scheduler();\n-}\n \n-#[test]\n-fn thread_local_scheduler_two_instances() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    tls_scheduler.put_scheduler(scheduler);\n-    {\n+    extern {\n+        fn rust_get_sched_tls_key() -> *mut c_void;\n+    }\n \n-        let _scheduler = tls_scheduler.get_scheduler();\n+    #[test]\n+    fn thread_local_scheduler_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        put(scheduler);\n+        let _scheduler = take();\n     }\n-    {\n-        let scheduler = tls_scheduler.take_scheduler();\n-        tls_scheduler.put_scheduler(scheduler);\n+\n+    #[test]\n+    fn thread_local_scheduler_two_instances() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        put(scheduler);\n+        let _scheduler = take();\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        put(scheduler);\n+        let _scheduler = take();\n     }\n \n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    {\n-        let _scheduler = tls_scheduler.get_scheduler();\n+    #[test]\n+    fn install_borrow_smoke_test() {\n+        let scheduler = ~UvEventLoop::new_scheduler();\n+        let _scheduler = do install(scheduler) {\n+            do borrow |_sched| {\n+            }\n+        };\n     }\n-    let _scheduler = tls_scheduler.take_scheduler();\n }\n \n #[test]"}]}