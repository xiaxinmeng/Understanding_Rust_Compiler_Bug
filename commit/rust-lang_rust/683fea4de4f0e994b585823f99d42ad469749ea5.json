{"sha": "683fea4de4f0e994b585823f99d42ad469749ea5", "node_id": "C_kwDOAAsO6NoAKDY4M2ZlYTRkZTRmMGU5OTRiNTg1ODIzZjk5ZDQyYWQ0Njk3NDllYTU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-14T20:05:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-14T20:05:46Z"}, "message": "Merge #11707\n\n11707: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "39d4399bb3f44bec9b7c05bb0125cd74e4efc3f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39d4399bb3f44bec9b7c05bb0125cd74e4efc3f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/683fea4de4f0e994b585823f99d42ad469749ea5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiL6AaCRBK7hj4Ov3rIwAAoSIIAEhdJUiUh5XnAA4L2z2X/080\nUv86Xt3FYPp7xJm79yPtE6I8SLRYxevlLrxcitDtXnJ2CHImklEMQnrvayefDs6a\nyvYmKBiFsgfoo8SWvklGje2Gu7WUk8uy+oh8YSUc0MHeNY3SmbKe3/9ajgO3j+As\nf7TW+w96Hsib+rze6w9+h8Q64jVrk6ne7tryEgrIez2s4gwUTJaZycvOoyabPjiH\nFz7cT5xvHwYlQ12J72xO/K0VxvcOe9o0QOEeQ3emSGC6LinX0dKlpd/U/eDVS2rJ\npHbHcMSr8mCSqrJICWmu6NJqf5+rZuo0+Nby9wIr/Yfbi3AkCurMeSuB5gpLN5g=\n=3icx\n-----END PGP SIGNATURE-----\n", "payload": "tree 39d4399bb3f44bec9b7c05bb0125cd74e4efc3f3\nparent 83575c96ed4e95c6910b45a445846c07668e0595\nparent fbc1d2a51436ed186c85f6f0d64217d9d1dd4523\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647288346 +0000\ncommitter GitHub <noreply@github.com> 1647288346 +0000\n\nMerge #11707\n\n11707: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/683fea4de4f0e994b585823f99d42ad469749ea5", "html_url": "https://github.com/rust-lang/rust/commit/683fea4de4f0e994b585823f99d42ad469749ea5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/683fea4de4f0e994b585823f99d42ad469749ea5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83575c96ed4e95c6910b45a445846c07668e0595", "url": "https://api.github.com/repos/rust-lang/rust/commits/83575c96ed4e95c6910b45a445846c07668e0595", "html_url": "https://github.com/rust-lang/rust/commit/83575c96ed4e95c6910b45a445846c07668e0595"}, {"sha": "fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "html_url": "https://github.com/rust-lang/rust/commit/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523"}], "stats": {"total": 73, "additions": 38, "deletions": 35}, "files": [{"sha": "7857edb521abbe03f84eb2b4368e79574d434f33", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=683fea4de4f0e994b585823f99d42ad469749ea5", "patch": "@@ -1327,14 +1327,14 @@ impl<'a> SemanticsScope<'a> {\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                     resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(id.into()),\n-                    resolver::ScopeDef::Local(pat_id) => {\n-                        let parent = self.resolver.body_owner().unwrap();\n-                        ScopeDef::Local(Local { parent, pat_id })\n-                    }\n-                    resolver::ScopeDef::Label(label_id) => {\n-                        let parent = self.resolver.body_owner().unwrap();\n-                        ScopeDef::Label(Label { parent, label_id })\n-                    }\n+                    resolver::ScopeDef::Local(pat_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Local(Local { parent, pat_id }),\n+                        None => continue,\n+                    },\n+                    resolver::ScopeDef::Label(label_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Label(Label { parent, label_id }),\n+                        None => continue,\n+                    },\n                 };\n                 f(name.clone(), def)\n             }"}, {"sha": "b8c88282d67ef26c648bdbe52a9bcdcf7528d4bf", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=683fea4de4f0e994b585823f99d42ad469749ea5", "patch": "@@ -1,5 +1,5 @@\n //! Name resolution fa\u00e7ade.\n-use std::sync::Arc;\n+use std::{hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n@@ -343,7 +343,7 @@ impl Resolver {\n     /// Returns a set of names available in the current scope.\n     ///\n     /// Note that this is a somewhat fuzzy concept -- internally, the compiler\n-    /// doesn't necessary follow a strict scoping discipline. Rathe, it just\n+    /// doesn't necessary follow a strict scoping discipline. Rather, it just\n     /// tells for each ident what it resolves to.\n     ///\n     /// A good example is something like `str::from_utf8`. From scopes point of\n@@ -378,10 +378,13 @@ impl Resolver {\n     /// The result is ordered *roughly* from the innermost scope to the\n     /// outermost: when the name is introduced in two namespaces in two scopes,\n     /// we use the position of the first scope.\n-    pub fn names_in_scope(&self, db: &dyn DefDatabase) -> IndexMap<Name, SmallVec<[ScopeDef; 1]>> {\n+    pub fn names_in_scope(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> FxIndexMap<Name, SmallVec<[ScopeDef; 1]>> {\n         let mut res = ScopeNames::default();\n         for scope in self.scopes() {\n-            scope.process_names(db, &mut res);\n+            scope.process_names(&mut res, db);\n         }\n         res.map\n     }\n@@ -466,7 +469,7 @@ impl Resolver {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDefId),\n     Unknown,\n@@ -478,7 +481,7 @@ pub enum ScopeDef {\n }\n \n impl Scope {\n-    fn process_names(&self, db: &dyn DefDatabase, acc: &mut ScopeNames) {\n+    fn process_names(&self, acc: &mut ScopeNames, db: &dyn DefDatabase) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -691,9 +694,10 @@ fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n     Some(res)\n }\n \n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<rustc_hash::FxHasher>>;\n #[derive(Default)]\n struct ScopeNames {\n-    map: IndexMap<Name, SmallVec<[ScopeDef; 1]>>,\n+    map: FxIndexMap<Name, SmallVec<[ScopeDef; 1]>>,\n }\n \n impl ScopeNames {"}, {"sha": "4fffd1aa0c4d9f1b1c40fb9542b106cf290237e6", "filename": "crates/ide_completion/src/completions/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=683fea4de4f0e994b585823f99d42ad469749ea5", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext)\n     let param_lifetime = param_lifetime.as_ref().map(ast::Lifetime::text);\n     let param_lifetime = param_lifetime.as_ref().map(TokenText::as_str);\n \n-    ctx.scope.process_all_names(&mut |name, res| {\n+    ctx.process_all_names_raw(&mut |name, res| {\n         if matches!(\n             res,\n             ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_))\n@@ -49,7 +49,7 @@ pub(crate) fn complete_label(acc: &mut Completions, ctx: &CompletionContext) {\n     if !matches!(ctx.lifetime_ctx, Some(LifetimeContext::LabelRef)) {\n         return;\n     }\n-    ctx.scope.process_all_names(&mut |name, res| {\n+    ctx.process_all_names_raw(&mut |name, res| {\n         if let ScopeDef::Label(_) = res {\n             acc.add_label(ctx, name);\n         }"}, {"sha": "ba664a29dae2e41dbf1e825e6950b194c90ba8f3", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683fea4de4f0e994b585823f99d42ad469749ea5/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=683fea4de4f0e994b585823f99d42ad469749ea5", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n     famous_defs::FamousDefs,\n     RootDatabase,\n };\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n     ast::{self, AttrKind, HasName, NameOrNameRef},\n@@ -146,7 +146,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n-    pub(super) locals: Vec<(Name, Local)>,\n+    pub(super) locals: FxHashMap<Name, Local>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -293,6 +293,10 @@ impl<'a> CompletionContext<'a> {\n         self.path_context.as_ref().and_then(|it| it.kind)\n     }\n \n+    pub(crate) fn is_immediately_after_macro_bang(&self) -> bool {\n+        self.token.kind() == BANG && self.token.parent().map_or(false, |it| it.kind() == MACRO_CALL)\n+    }\n+\n     /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n     pub(crate) fn is_visible<I>(&self, item: &I) -> Visible\n     where\n@@ -318,11 +322,6 @@ impl<'a> CompletionContext<'a> {\n             _ => false,\n         }\n     }\n-\n-    pub(crate) fn is_immediately_after_macro_bang(&self) -> bool {\n-        self.token.kind() == BANG && self.token.parent().map_or(false, |it| it.kind() == MACRO_CALL)\n-    }\n-\n     /// Whether the given trait is an operator trait or not.\n     pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {\n         match trait_.attrs(self.db).lang() {\n@@ -340,7 +339,12 @@ impl<'a> CompletionContext<'a> {\n             }\n \n             f(name, def);\n-        })\n+        });\n+    }\n+\n+    pub(crate) fn process_all_names_raw(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n+        let _p = profile::span(\"CompletionContext::process_all_names_raw\");\n+        self.scope.process_all_names(&mut |name, def| f(name, def));\n     }\n \n     fn is_visible_impl(\n@@ -372,16 +376,11 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn is_doc_hidden(&self, attrs: &hir::Attrs, defining_crate: hir::Crate) -> bool {\n-        let krate = match self.krate {\n-            Some(it) => it,\n-            None => return true,\n-        };\n-        if krate != defining_crate && attrs.has_doc_hidden() {\n+        match self.krate {\n             // `doc(hidden)` items are only completed within the defining crate.\n-            return true;\n+            Some(krate) => krate != defining_crate && attrs.has_doc_hidden(),\n+            None => true,\n         }\n-\n-        false\n     }\n }\n \n@@ -413,10 +412,10 @@ impl<'a> CompletionContext<'a> {\n         let scope = sema.scope_at_offset(&token.parent()?, offset);\n         let krate = scope.krate();\n         let module = scope.module();\n-        let mut locals = vec![];\n+        let mut locals = FxHashMap::default();\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n-                locals.push((name, local));\n+                locals.insert(name, local);\n             }\n         });\n "}]}